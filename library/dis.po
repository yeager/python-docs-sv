# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-21 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!dis` --- Disassembler for Python bytecode"
msgstr ""

msgid "**Source code:** :source:`Lib/dis.py`"
msgstr ""

msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""

msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""

msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""

msgid ""
"The argument of jump, exception handling and loop instructions is now the "
"instruction offset rather than the byte offset."
msgstr ""

msgid ""
"Some instructions are accompanied by one or more inline cache entries, which "
"take the form of :opcode:`CACHE` instructions. These instructions are hidden "
"by default, but can be shown by passing ``show_caches=True`` to any :mod:"
"`dis` utility. Furthermore, the interpreter now adapts the bytecode to "
"specialize it for different runtime conditions. The adaptive bytecode can be "
"shown by passing ``adaptive=True``."
msgstr ""

msgid ""
"The argument of a jump is the offset of the target instruction relative to "
"the instruction that appears immediately after the jump instruction's :"
"opcode:`CACHE` entries."
msgstr ""

msgid ""
"As a consequence, the presence of the :opcode:`CACHE` instructions is "
"transparent for forward jumps but needs to be taken into account when "
"reasoning about backward jumps."
msgstr ""

msgid ""
"The output shows logical labels rather than instruction offsets for jump "
"targets and exception handlers. The ``-O`` command line option and the "
"``show_offsets`` argument were added."
msgstr ""

msgid ""
"The :option:`-P <dis --show-positions>` command-line option and the "
"``show_positions`` argument were added."
msgstr ""

msgid "The :option:`-S <dis --specialized>` command-line option is added."
msgstr ""

msgid "Example: Given the function :func:`!myfunc`::"
msgstr ""

msgid ""
"def myfunc(alist):\n"
"    return len(alist)"
msgstr ""

msgid ""
"the following command can be used to display the disassembly of :func:`!"
"myfunc`:"
msgstr ""

msgid ""
">>> dis.dis(myfunc)\n"
"  2           RESUME                   0\n"
"\n"
"  3           LOAD_GLOBAL              1 (len + NULL)\n"
"              LOAD_FAST_BORROW         0 (alist)\n"
"              CALL                     1\n"
"              RETURN_VALUE"
msgstr ""

msgid "(The \"2\" is a line number)."
msgstr ""

msgid "Command-line interface"
msgstr ""

msgid "The :mod:`dis` module can be invoked as a script from the command line:"
msgstr ""

msgid "python -m dis [-h] [-C] [-O] [-P] [-S] [infile]"
msgstr ""

msgid "The following options are accepted:"
msgstr ""

msgid "Display usage and exit."
msgstr ""

msgid "Show inline caches."
msgstr ""

msgid "Show offsets of instructions."
msgstr ""

msgid "Show positions of instructions in the source code."
msgstr ""

msgid "Show specialized bytecode."
msgstr ""

msgid ""
"If :file:`infile` is specified, its disassembled code will be written to "
"stdout. Otherwise, disassembly is performed on compiled source code received "
"from stdin."
msgstr ""

msgid "Bytecode analysis"
msgstr ""

msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a :"
"class:`Bytecode` object that provides easy access to details of the compiled "
"code."
msgstr ""

msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""

msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""

msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""

msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""

msgid ""
"If *show_caches* is ``True``, :meth:`.dis` will display inline cache entries "
"used by the interpreter to specialize the bytecode."
msgstr ""

msgid ""
"If *adaptive* is ``True``, :meth:`.dis` will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""

msgid ""
"If *show_offsets* is ``True``, :meth:`.dis` will include instruction offsets "
"in the output."
msgstr ""

msgid ""
"If *show_positions* is ``True``, :meth:`.dis` will include instruction "
"source code positions in the output."
msgstr ""

msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""

msgid "The compiled code object."
msgstr ""

msgid "The first source line of the code object (if available)"
msgstr ""

msgid ""
"Return a formatted view of the bytecode operations (the same as printed by :"
"func:`dis.dis`, but returned as a multi-line string)."
msgstr ""

msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""

msgid "This can now handle coroutine and asynchronous generator objects."
msgstr ""

msgid "Added the *show_caches* and *adaptive* parameters."
msgstr ""

msgid "Added the *show_offsets* parameter"
msgstr ""

msgid "Added the *show_positions* parameter."
msgstr ""

msgid "Example:"
msgstr ""

msgid ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> for instr in bytecode:\n"
"...     print(instr.opname)\n"
"...\n"
"RESUME\n"
"LOAD_GLOBAL\n"
"LOAD_FAST_BORROW\n"
"CALL\n"
"RETURN_VALUE"
msgstr ""

msgid "Analysis functions"
msgstr ""

msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""

msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""

msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""

msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""

msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""

msgid "Added *file* parameter."
msgstr ""

msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects. These can include generator "
"expressions, nested functions, the bodies of nested classes, and the code "
"objects used for :ref:`annotation scopes <annotation-scopes>`. Strings are "
"first compiled to code objects with the :func:`compile` built-in function "
"before being disassembled.  If no object is provided, this function "
"disassembles the last traceback."
msgstr ""

msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""

msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""

msgid ""
"If *show_caches* is ``True``, this function will display inline cache "
"entries used by the interpreter to specialize the bytecode."
msgstr ""

msgid ""
"If *adaptive* is ``True``, this function will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""

msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr ""

msgid "Added the *show_offsets* parameter."
msgstr ""

msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""

msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""

msgid ""
"the source code location of the instruction. Complete location information "
"is shown if *show_positions* is true. Otherwise (the default) only the line "
"number is displayed."
msgstr ""

msgid "the current instruction, indicated as ``-->``,"
msgstr ""

msgid "a labelled instruction, indicated with ``>>``,"
msgstr ""

msgid "the address of the instruction,"
msgstr ""

msgid "the operation code name,"
msgstr ""

msgid "operation parameters, and"
msgstr ""

msgid "interpretation of the parameters in parentheses."
msgstr ""

msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""

msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""

msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""

msgid "The *adaptive* parameter works as it does in :func:`dis`."
msgstr ""

msgid ""
"The *show_caches* parameter is deprecated and has no effect. The iterator "
"generates the :class:`Instruction` instances with the *cache_info* field "
"populated (regardless of the value of *show_caches*) and it no longer "
"generates separate items for the cache entries."
msgstr ""

msgid ""
"This generator function uses the :meth:`~codeobject.co_lines` method of the :"
"ref:`code object <code-objects>` *code* to find the offsets which are starts "
"of lines in the source code.  They are generated as ``(offset, lineno)`` "
"pairs."
msgstr ""

msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr ""

msgid ""
"The :pep:`626` :meth:`~codeobject.co_lines` method is used instead of the :"
"attr:`~codeobject.co_firstlineno` and :attr:`~codeobject.co_lnotab` "
"attributes of the :ref:`code object <code-objects>`."
msgstr ""

msgid ""
"Line numbers can be ``None`` for bytecode that does not map to source lines."
msgstr ""

msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""

msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr ""

msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""

msgid "Added *jump* parameter."
msgstr ""

msgid ""
"If ``oparg`` is omitted (or ``None``), the stack effect is now returned for "
"``oparg=0``. Previously this was an error for opcodes that use their arg. It "
"is also no longer an error to pass an integer ``oparg`` when the ``opcode`` "
"does not use it; the ``oparg`` in this case is ignored."
msgstr ""

msgid "Python Bytecode Instructions"
msgstr ""

msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""

msgid "Details for a bytecode operation"
msgstr ""

msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""

msgid "human readable name for operation"
msgstr ""

msgid ""
"numeric code for the base operation if operation is specialized; otherwise "
"equal to :data:`opcode`"
msgstr ""

msgid ""
"human readable name for the base operation if operation is specialized; "
"otherwise equal to :data:`opname`"
msgstr ""

msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr ""

msgid "alias for :data:`arg`"
msgstr ""

msgid "resolved arg value (if any), otherwise ``None``"
msgstr ""

msgid ""
"human readable description of operation argument (if any), otherwise an "
"empty string."
msgstr ""

msgid "start index of operation within bytecode sequence"
msgstr ""

msgid ""
"start index of operation within bytecode sequence, including prefixed "
"``EXTENDED_ARG`` operations if present; otherwise equal to :data:`offset`"
msgstr ""

msgid "start index of the cache entries following the operation"
msgstr ""

msgid "end index of the cache entries following the operation"
msgstr ""

msgid "``True`` if this opcode starts a source line, otherwise ``False``"
msgstr ""

msgid ""
"source line number associated with this opcode (if any), otherwise ``None``"
msgstr ""

msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr ""

msgid ""
"bytecode index of the jump target if this is a jump operation, otherwise "
"``None``"
msgstr ""

msgid ""
":class:`dis.Positions` object holding the start and end locations that are "
"covered by this instruction."
msgstr ""

msgid ""
"Information about the cache entries of this instruction, as triplets of the "
"form ``(name, size, data)``, where the ``name`` and ``size`` describe the "
"cache format and data is the contents of the cache. ``cache_info`` is "
"``None`` if the instruction does not have caches."
msgstr ""

msgid "Field ``positions`` is added."
msgstr ""

msgid "Changed field ``starts_line``."
msgstr ""

msgid ""
"Added fields ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"and ``cache_info``."
msgstr ""

msgid ""
"In case the information is not available, some fields might be ``None``."
msgstr ""

msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr ""

msgid "**General instructions**"
msgstr ""

msgid ""
"In the following, We will refer to the interpreter stack as ``STACK`` and "
"describe operations on it as if it was a Python list. The top of the stack "
"corresponds to ``STACK[-1]`` in this language."
msgstr ""

msgid ""
"Do nothing code.  Used as a placeholder by the bytecode optimizer, and to "
"generate line tracing events."
msgstr ""

msgid "Removes the top-of-stack item::"
msgstr ""

msgid "STACK.pop()"
msgstr ""

msgid ""
"Removes the top-of-stack item. Equivalent to ``POP_TOP``. Used to clean up "
"at the end of loops, hence the name."
msgstr ""

msgid "Implements ``del STACK[-2]``. Used to clean up when a generator exits."
msgstr ""

msgid ""
"Push the i-th item to the top of the stack without removing it from its "
"original location::"
msgstr ""

msgid ""
"assert i > 0\n"
"STACK.append(STACK[-i])"
msgstr ""

msgid "Swap the top of the stack with the i-th element::"
msgstr ""

msgid "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"
msgstr ""

msgid ""
"Rather than being an actual instruction, this opcode is used to mark extra "
"space for the interpreter to cache useful data directly in the bytecode "
"itself. It is automatically hidden by all ``dis`` utilities, but can be "
"viewed with ``show_caches=True``."
msgstr ""

msgid ""
"Logically, this space is part of the preceding instruction. Many opcodes "
"expect to be followed by an exact number of caches, and will instruct the "
"interpreter to skip over them at runtime."
msgstr ""

msgid ""
"Populated caches can look like arbitrary instructions, so great care should "
"be taken when reading or modifying raw, adaptive bytecode containing "
"quickened data."
msgstr ""

msgid "**Unary operations**"
msgstr ""

msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""

msgid "Implements ``STACK[-1] = -STACK[-1]``."
msgstr ""

msgid "Implements ``STACK[-1] = not STACK[-1]``."
msgstr ""

msgid "This instruction now requires an exact :class:`bool` operand."
msgstr ""

msgid "Implements ``STACK[-1] = ~STACK[-1]``."
msgstr ""

msgid "Implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""

msgid ""
"If ``STACK[-1]`` is a :term:`generator iterator` or :term:`coroutine` object "
"it is left as is.  Otherwise, implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""

msgid "Implements ``STACK[-1] = bool(STACK[-1])``."
msgstr ""

msgid "**Binary and in-place operations**"
msgstr ""

msgid ""
"Binary operations remove the top two items from the stack (``STACK[-1]`` and "
"``STACK[-2]``). They perform the operation, then put the result back on the "
"stack."
msgstr ""

msgid ""
"In-place operations are like binary operations, but the operation is done in-"
"place when ``STACK[-2]`` supports it, and the resulting ``STACK[-1]`` may be "
"(but does not have to be) the original ``STACK[-2]``."
msgstr ""

msgid ""
"Implements the binary and in-place operators (depending on the value of "
"*op*)::"
msgstr ""

msgid ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"
msgstr ""

msgid ""
"With oparg :``NB_SUBSCR``, implements binary subscript (replaces opcode "
"``BINARY_SUBSCR``)"
msgstr ""

msgid "Implements::"
msgstr ""

msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"value = STACK.pop()\n"
"container[key] = value"
msgstr ""

msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[key]"
msgstr ""

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[start:end])"
msgstr ""

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"values = STACK.pop()\n"
"container[start:end] = value"
msgstr ""

msgid "**Coroutine opcodes**"
msgstr ""

msgid ""
"Implements ``STACK[-1] = get_awaitable(STACK[-1])``, where "
"``get_awaitable(o)`` returns ``o`` if ``o`` is a coroutine object or a "
"generator object with the :data:`~inspect.CO_ITERABLE_COROUTINE` flag, or "
"resolves ``o.__await__``."
msgstr ""

msgid ""
"If the ``where`` operand is nonzero, it indicates where the instruction "
"occurs:"
msgstr ""

msgid "``1``: After a call to ``__aenter__``"
msgstr ""

msgid "``2``: After a call to ``__aexit__``"
msgstr ""

msgid "Previously, this instruction did not have an oparg."
msgstr ""

msgid "Implements ``STACK[-1] = STACK[-1].__aiter__()``."
msgstr ""

msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr ""

msgid ""
"Implement ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` to the "
"stack. See ``GET_AWAITABLE`` for details about ``get_awaitable``."
msgstr ""

msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item. The stack contains the async iterable in ``STACK[-2]`` "
"and the raised exception in ``STACK[-1]``. Both are popped. If the exception "
"is not :exc:`StopAsyncIteration`, it is re-raised."
msgstr ""

msgid ""
"Exception representation on the stack now consist of one, not three, items."
msgstr ""

msgid ""
"Handles an exception raised during a :meth:`~generator.throw` or :meth:"
"`~generator.close` call through the current frame.  If ``STACK[-1]`` is an "
"instance of :exc:`StopIteration`, pop three values from the stack and push "
"its ``value`` member.  Otherwise, re-raise ``STACK[-1]``."
msgstr ""

msgid "**Miscellaneous opcodes**"
msgstr ""

msgid ""
"item = STACK.pop()\n"
"set.add(STACK[-i], item)"
msgstr ""

msgid "Used to implement set comprehensions."
msgstr ""

msgid ""
"item = STACK.pop()\n"
"list.append(STACK[-i], item)"
msgstr ""

msgid "Used to implement list comprehensions."
msgstr ""

msgid ""
"value = STACK.pop()\n"
"key = STACK.pop()\n"
"dict.__setitem__(STACK[-i], key, value)"
msgstr ""

msgid "Used to implement dict comprehensions."
msgstr ""

msgid ""
"Map value is ``STACK[-1]`` and map key is ``STACK[-2]``. Before, those were "
"reversed."
msgstr ""

msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and :opcode:"
"`MAP_ADD` instructions, while the added value or key/value pair is popped "
"off, the container object remains on the stack so that it is available for "
"further iterations of the loop."
msgstr ""

msgid "Returns with ``STACK[-1]`` to the caller of the function."
msgstr ""

msgid "Yields ``STACK.pop()`` from a :term:`generator`."
msgstr ""

msgid "oparg set to be the stack depth."
msgstr ""

msgid ""
"oparg set to be the exception block depth, for efficient closing of "
"generators."
msgstr ""

msgid ""
"oparg is ``1`` if this instruction is part of a yield-from or await, and "
"``0`` otherwise."
msgstr ""

msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""

msgid ""
"Pops a value from the stack, which is used to restore the exception state."
msgstr ""

msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"pops an additional value from the stack which is used to set :attr:`~frame."
"f_lasti` of the current frame."
msgstr ""

msgid ""
"Pops a value from the stack. Pushes the current exception to the top of the "
"stack. Pushes the value originally popped back to the stack. Used in "
"exception handlers."
msgstr ""

msgid ""
"Performs exception matching for ``except``. Tests whether the ``STACK[-2]`` "
"is an exception matching ``STACK[-1]``. Pops ``STACK[-1]`` and pushes the "
"boolean result of the test."
msgstr ""

msgid ""
"Performs exception matching for ``except*``. Applies ``split(STACK[-1])`` on "
"the exception group representing ``STACK[-2]``."
msgstr ""

msgid ""
"In case of a match, pops two items from the stack and pushes the non-"
"matching subgroup (``None`` in case of full match) followed by the matching "
"subgroup. When there is no match, pops one item (the match type) and pushes "
"``None``."
msgstr ""

msgid ""
"Calls the function in position 4 on the stack with arguments (type, val, tb) "
"representing the exception at the top of the stack. Used to implement the "
"call ``context_manager.__exit__(*exc_info())`` when an exception has "
"occurred in a :keyword:`with` statement."
msgstr ""

msgid ""
"The ``__exit__`` function is in position 4 of the stack rather than 7. "
"Exception representation on the stack now consist of one, not three, items."
msgstr ""

msgid ""
"Pushes a common constant onto the stack. The interpreter contains a "
"hardcoded list of constants supported by this instruction.  Used by the :"
"keyword:`assert` statement to load :exc:`AssertionError`."
msgstr ""

msgid ""
"Pushes :func:`!builtins.__build_class__` onto the stack.  It is later called "
"to construct a class."
msgstr ""

msgid ""
"Perform ``STACK.append(len(STACK[-1]))``. Used in :keyword:`match` "
"statements where comparison with structure of pattern is needed."
msgstr ""

msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Mapping` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""

msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Sequence` and is "
"*not* an instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""

msgid ""
"``STACK[-1]`` is a tuple of mapping keys, and ``STACK[-2]`` is the match "
"subject. If ``STACK[-2]`` contains all of the keys in ``STACK[-1]``, push a :"
"class:`tuple` containing the corresponding values. Otherwise, push ``None``."
msgstr ""

msgid ""
"Previously, this instruction also pushed a boolean value indicating success "
"(``True``) or failure (``False``)."
msgstr ""

msgid ""
"Implements ``name = STACK.pop()``. *namei* is the index of *name* in the "
"attribute :attr:`~codeobject.co_names` of the :ref:`code object <code-"
"objects>`. The compiler tries to use :opcode:`STORE_FAST` or :opcode:"
"`STORE_GLOBAL` if possible."
msgstr ""

msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`~codeobject."
"co_names` attribute of the :ref:`code object <code-objects>`."
msgstr ""

msgid ""
"Unpacks ``STACK[-1]`` into *count* individual values, which are put onto the "
"stack right-to-left. Require there to be exactly *count* values.::"
msgstr ""

msgid ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"
msgstr ""

msgid ""
"Implements assignment with a starred target: Unpacks an iterable in "
"``STACK[-1]`` into individual values, where the total number of values can "
"be smaller than the number of items in the iterable: one of the new values "
"will be a list of all leftover items."
msgstr ""

msgid "The number of values before and after the list value is limited to 255."
msgstr ""

msgid ""
"The number of values before the list value is encoded in the argument of the "
"opcode. The number of values after the list if any is encoded using an "
"``EXTENDED_ARG``. As a consequence, the argument can be seen as a two bytes "
"values where the low byte of *counts* is the number of values before the "
"list value, the high byte of *counts* the number of values after it."
msgstr ""

msgid ""
"The extracted values are put onto the stack right-to-left, i.e. ``a, *b, c = "
"d`` will be stored after execution as ``STACK.extend((a, b, c))``."
msgstr ""

msgid ""
"obj = STACK.pop()\n"
"value = STACK.pop()\n"
"obj.name = value"
msgstr ""

msgid ""
"where *namei* is the index of name in :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""

msgid ""
"obj = STACK.pop()\n"
"del obj.name"
msgstr ""

msgid ""
"where *namei* is the index of name into :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""

msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr ""

msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr ""

msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr ""

msgid ""
"Pushes the integer ``i`` onto the stack. ``i`` must be in ``range(256)``"
msgstr ""

msgid ""
"Pushes the value associated with ``co_names[namei]`` onto the stack. The "
"name is looked up within the locals, then the globals, then the builtins."
msgstr ""

msgid ""
"Pushes a reference to the locals dictionary onto the stack.  This is used to "
"prepare namespace dictionaries for :opcode:`LOAD_FROM_DICT_OR_DEREF` and :"
"opcode:`LOAD_FROM_DICT_OR_GLOBALS`."
msgstr ""

msgid ""
"Pops a mapping off the stack and looks up the value for ``co_names[namei]``. "
"If the name is not found there, looks it up in the globals and then the "
"builtins, similar to :opcode:`LOAD_GLOBAL`. This is used for loading global "
"variables in :ref:`annotation scopes <annotation-scopes>` within class "
"bodies."
msgstr ""

msgid ""
"Constructs a new :class:`~string.templatelib.Template` instance from a tuple "
"of strings and a tuple of interpolations and pushes the resulting object "
"onto the stack::"
msgstr ""

msgid ""
"interpolations = STACK.pop()\n"
"strings = STACK.pop()\n"
"STACK.append(_build_template(strings, interpolations))"
msgstr ""

msgid ""
"Constructs a new :class:`~string.templatelib.Interpolation` instance from a "
"value and its source expression and pushes the resulting object onto the "
"stack."
msgstr ""

msgid ""
"If no conversion or format specification is present, ``format`` is set to "
"``2``."
msgstr ""

msgid ""
"If the low bit of ``format`` is set, it indicates that the interpolation "
"contains a format specification."
msgstr ""

msgid ""
"If ``format >> 2`` is non-zero, it indicates that the interpolation contains "
"a conversion. The value of ``format >> 2`` is the conversion type (``0`` for "
"no conversion, ``1`` for ``!s``, ``2`` for ``!r``, and ``3`` for ``!a``)::"
msgstr ""

msgid ""
"conversion = format >> 2\n"
"if format & 1:\n"
"    format_spec = STACK.pop()\n"
"else:\n"
"    format_spec = None\n"
"expression = STACK.pop()\n"
"value = STACK.pop()\n"
"STACK.append(_build_interpolation(value, expression, conversion, "
"format_spec))"
msgstr ""

msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack::"
msgstr ""

msgid ""
"if count == 0:\n"
"    value = ()\n"
"else:\n"
"    value = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(value)"
msgstr ""

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr ""

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr ""

msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."
msgstr ""

msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""

msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr ""

msgid ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"
msgstr ""

msgid "Used to build lists."
msgstr ""

msgid ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"
msgstr ""

msgid "Used to build sets."
msgstr ""

msgid ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"
msgstr ""

msgid "Used to build dicts."
msgstr ""

msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""

msgid ""
"If the low bit of ``namei`` is not set, this replaces ``STACK[-1]`` with "
"``getattr(STACK[-1], co_names[namei>>1])``."
msgstr ""

msgid ""
"If the low bit of ``namei`` is set, this will attempt to load a method named "
"``co_names[namei>>1]`` from the ``STACK[-1]`` object. ``STACK[-1]`` is "
"popped. This bytecode distinguishes two cases: if ``STACK[-1]`` has a method "
"with the correct name, the bytecode pushes the unbound method and "
"``STACK[-1]``. ``STACK[-1]`` will be used as the first argument (``self``) "
"by :opcode:`CALL` or :opcode:`CALL_KW` when calling the unbound method. "
"Otherwise, ``NULL`` and the object returned by the attribute lookup are "
"pushed."
msgstr ""

msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` or ``self`` is pushed to "
"the stack before the attribute or unbound method respectively."
msgstr ""

msgid ""
"This opcode implements :func:`super`, both in its zero-argument and two-"
"argument forms (e.g. ``super().method()``, ``super().attr`` and ``super(cls, "
"self).method()``, ``super(cls, self).attr``)."
msgstr ""

msgid "It pops three values from the stack (from top of stack down):"
msgstr ""

msgid "``self``: the first argument to the current method"
msgstr ""

msgid "``cls``: the class within which the current method was defined"
msgstr ""

msgid "the global ``super``"
msgstr ""

msgid ""
"With respect to its argument, it works similarly to :opcode:`LOAD_ATTR`, "
"except that ``namei`` is shifted left by 2 bits instead of 1."
msgstr ""

msgid ""
"The low bit of ``namei`` signals to attempt a method load, as with :opcode:"
"`LOAD_ATTR`, which results in pushing ``NULL`` and the loaded method. When "
"it is unset a single value is pushed to the stack."
msgstr ""

msgid ""
"The second-low bit of ``namei``, if set, means that this was a two-argument "
"call to :func:`super` (unset means zero-argument)."
msgstr ""

msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname >> 5]``. If the fifth-lowest bit of ``opname`` is set "
"(``opname & 16``), the result should be coerced to ``bool``."
msgstr ""

msgid ""
"The fifth-lowest bit of the oparg now indicates a forced conversion to :"
"class:`bool`."
msgstr ""

msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr ""

msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr ""

msgid ""
"Imports the module ``co_names[namei]``.  ``STACK[-1]`` and ``STACK[-2]`` are "
"popped and provide the *fromlist* and *level* arguments of :func:"
"`__import__`. The module object is pushed onto the stack.  The current "
"namespace is not affected: for a proper import statement, a subsequent :"
"opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""

msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in "
"``STACK[-1]``. The resulting object is pushed onto the stack, to be "
"subsequently stored by a :opcode:`STORE_FAST` instruction."
msgstr ""

msgid "Increments bytecode counter by *delta*."
msgstr ""

msgid "Decrements bytecode counter by *delta*. Checks for interrupts."
msgstr ""

msgid "Decrements bytecode counter by *delta*. Does not check for interrupts."
msgstr ""

msgid ""
"If ``STACK[-1]`` is true, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

msgid ""
"The oparg is now a relative delta rather than an absolute target. This "
"opcode is a pseudo-instruction, replaced in final bytecode by the directed "
"versions (forward/backward)."
msgstr ""

msgid "This is no longer a pseudo-instruction."
msgstr ""

msgid ""
"If ``STACK[-1]`` is false, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

msgid ""
"If ``STACK[-1]`` is not ``None``, increments the bytecode counter by "
"*delta*. ``STACK[-1]`` is popped."
msgstr ""

msgid ""
"If ``STACK[-1]`` is ``None``, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""

msgid ""
"``STACK[-1]`` is an :term:`iterator`.  Call its :meth:`~iterator.__next__` "
"method. If this yields a new value, push it on the stack (leaving the "
"iterator below it).  If the iterator indicates it is exhausted then the byte "
"code counter is incremented by *delta*."
msgstr ""

msgid "Up until 3.11 the iterator was popped when it was exhausted."
msgstr ""

msgid "Loads the global named ``co_names[namei>>1]`` onto the stack."
msgstr ""

msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` is pushed to the stack "
"before the global variable."
msgstr ""

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr ""

msgid ""
"This opcode is now only used in situations where the local variable is "
"guaranteed to be initialized. It cannot raise :exc:`UnboundLocalError`."
msgstr ""

msgid ""
"Pushes a borrowed reference to the local ``co_varnames[var_num]`` onto the "
"stack."
msgstr ""

msgid ""
"Pushes references to ``co_varnames[var_nums >> 4]`` and "
"``co_varnames[var_nums & 15]`` onto the stack."
msgstr ""

msgid ""
"Pushes borrowed references to ``co_varnames[var_nums >> 4]`` and "
"``co_varnames[var_nums & 15]`` onto the stack."
msgstr ""

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack, "
"raising an :exc:`UnboundLocalError` if the local variable has not been "
"initialized."
msgstr ""

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack (or "
"pushes ``NULL`` onto the stack if the local variable has not been "
"initialized) and sets ``co_varnames[var_num]`` to ``NULL``."
msgstr ""

msgid "Stores ``STACK.pop()`` into the local ``co_varnames[var_num]``."
msgstr ""

msgid ""
"Stores ``STACK[-1]`` into ``co_varnames[var_nums >> 4]`` and ``STACK[-2]`` "
"into ``co_varnames[var_nums & 15]``."
msgstr ""

msgid ""
"Stores ``STACK.pop()`` into the local ``co_varnames[var_nums >> 4]`` and "
"pushes a reference to the local ``co_varnames[var_nums & 15]`` onto the "
"stack."
msgstr ""

msgid "Deletes local ``co_varnames[var_num]``."
msgstr ""

msgid ""
"Creates a new cell in slot ``i``.  If that slot is nonempty then that value "
"is stored into the new cell."
msgstr ""

msgid ""
"Loads the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""

msgid ""
"``i`` is no longer offset by the length of :attr:`~codeobject.co_varnames`."
msgstr ""

msgid ""
"Pops a mapping off the stack and looks up the name associated with slot "
"``i`` of the \"fast locals\" storage in this mapping. If the name is not "
"found there, loads it from the cell contained in slot ``i``, similar to :"
"opcode:`LOAD_DEREF`. This is used for loading :term:`closure variables "
"<closure variable>` in class bodies (which previously used :opcode:`!"
"LOAD_CLASSDEREF`) and in :ref:`annotation scopes <annotation-scopes>` within "
"class bodies."
msgstr ""

msgid ""
"Stores ``STACK.pop()`` into the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""

msgid ""
"Empties the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Used by the :keyword:`del` statement."
msgstr ""

msgid ""
"Copies the ``n`` :term:`free (closure) variables <closure variable>` from "
"the closure into the frame. Removes the need for special code on the "
"caller's side when calling closures."
msgstr ""

msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""

msgid "0: ``raise`` (re-raise previous exception)"
msgstr ""

msgid ""
"1: ``raise STACK[-1]`` (raise exception instance or type at ``STACK[-1]``)"
msgstr ""

msgid ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"
msgstr ""

msgid ""
"Calls a callable object with the number of arguments specified by ``argc``. "
"On the stack are (in ascending order):"
msgstr ""

msgid "The callable"
msgstr ""

msgid "``self`` or ``NULL``"
msgstr ""

msgid "The remaining positional arguments"
msgstr ""

msgid "``argc`` is the total of the positional arguments, excluding ``self``."
msgstr ""

msgid ""
"``CALL`` pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value returned "
"by the callable object."
msgstr ""

msgid "The callable now always appears at the same position on the stack."
msgstr ""

msgid "Calls with keyword arguments are now handled by :opcode:`CALL_KW`."
msgstr ""

msgid ""
"Calls a callable object with the number of arguments specified by ``argc``, "
"including one or more named arguments. On the stack are (in ascending order):"
msgstr ""

msgid "The named arguments"
msgstr ""

msgid "A :class:`tuple` of keyword argument names"
msgstr ""

msgid ""
"``argc`` is the total of the positional and named arguments, excluding "
"``self``. The length of the tuple of keyword argument names is the number of "
"named arguments."
msgstr ""

msgid ""
"``CALL_KW`` pops all arguments, the keyword names, and the callable object "
"off the stack, calls the callable object with those arguments, and pushes "
"the return value returned by the callable object."
msgstr ""

msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""

msgid ""
"Pushes a ``NULL`` to the stack. Used in the call sequence to match the "
"``NULL`` pushed by :opcode:`LOAD_METHOD` for non-method calls."
msgstr ""

msgid ""
"Pushes a new function object on the stack built from the code object at "
"``STACK[-1]``."
msgstr ""

msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr ""

msgid "Qualified name at ``STACK[-1]`` was removed."
msgstr ""

msgid ""
"Extra function attributes on the stack, signaled by oparg flags, were "
"removed. They now use :opcode:`SET_FUNCTION_ATTRIBUTE`."
msgstr ""

msgid ""
"Sets an attribute on a function object. Expects the function at "
"``STACK[-1]`` and the attribute value to set at ``STACK[-2]``; consumes both "
"and leaves the function at ``STACK[-1]``. The flag determines which "
"attribute to set:"
msgstr ""

msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""

msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""

msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr ""

msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""

msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"implements::"
msgstr ""

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end))"
msgstr ""

msgid "if it is 3, implements::"
msgstr ""

msgid ""
"step = STACK.pop()\n"
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end, step))"
msgstr ""

msgid "See the :func:`slice` built-in function for more information."
msgstr ""

msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""

msgid "Convert value to a string, depending on ``oparg``::"
msgstr ""

msgid ""
"value = STACK.pop()\n"
"result = func(value)\n"
"STACK.append(result)"
msgstr ""

msgid "``oparg == 1``: call :func:`str` on *value*"
msgstr ""

msgid "``oparg == 2``: call :func:`repr` on *value*"
msgstr ""

msgid "``oparg == 3``: call :func:`ascii` on *value*"
msgstr ""

msgid "Used for implementing formatted string literals (f-strings)."
msgstr ""

msgid "Formats the value on top of stack::"
msgstr ""

msgid ""
"value = STACK.pop()\n"
"result = value.__format__(\"\")\n"
"STACK.append(result)"
msgstr ""

msgid "Formats the given value with the given format spec::"
msgstr ""

msgid ""
"spec = STACK.pop()\n"
"value = STACK.pop()\n"
"result = value.__format__(spec)\n"
"STACK.append(result)"
msgstr ""

msgid ""
"``STACK[-1]`` is a tuple of keyword attribute names, ``STACK[-2]`` is the "
"class being matched against, and ``STACK[-3]`` is the match subject.  "
"*count* is the number of positional sub-patterns."
msgstr ""

msgid ""
"Pop ``STACK[-1]``, ``STACK[-2]``, and ``STACK[-3]``. If ``STACK[-3]`` is an "
"instance of ``STACK[-2]`` and has the positional and keyword attributes "
"required by *count* and ``STACK[-1]``, push a tuple of extracted attributes. "
"Otherwise, push ``None``."
msgstr ""

msgid "A no-op. Performs internal tracing, debugging and optimization checks."
msgstr ""

msgid ""
"The ``context`` operand consists of two parts. The lowest two bits indicate "
"where the ``RESUME`` occurs:"
msgstr ""

msgid ""
"``0`` The start of a function, which is neither a generator, coroutine nor "
"an async generator"
msgstr ""

msgid "``1`` After a ``yield`` expression"
msgstr ""

msgid "``2`` After a ``yield from`` expression"
msgstr ""

msgid "``3`` After an ``await`` expression"
msgstr ""

msgid ""
"The next bit is ``1`` if the RESUME is at except-depth ``1``, and ``0`` "
"otherwise."
msgstr ""

msgid "The oparg value changed to include information about except-depth"
msgstr ""

msgid ""
"Create a generator, coroutine, or async generator from the current frame. "
"Used as first opcode of in code object for the above mentioned callables. "
"Clear the current frame and return the newly created generator."
msgstr ""

msgid ""
"Equivalent to ``STACK[-1] = STACK[-2].send(STACK[-1])``. Used in ``yield "
"from`` and ``await`` statements."
msgstr ""

msgid ""
"If the call raises :exc:`StopIteration`, pop the top value from the stack, "
"push the exception's ``value`` attribute, and increment the bytecode counter "
"by *delta*."
msgstr ""

msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes in the range [0,255] which don't use their argument and those that "
"do (``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""

msgid ""
"If your application uses pseudo instructions or specialized instructions, "
"use the :data:`hasarg` collection instead."
msgstr ""

msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""

msgid ""
"Pseudo instructions were added to the :mod:`dis` module, and for them it is "
"not true that comparison with ``HAVE_ARGUMENT`` indicates whether they use "
"their arg."
msgstr ""

msgid "Use :data:`hasarg` instead."
msgstr ""

msgid ""
"Calls an intrinsic function with one argument. Passes ``STACK[-1]`` as the "
"argument and sets ``STACK[-1]`` to the result. Used to implement "
"functionality that is not performance critical."
msgstr ""

msgid "The operand determines which intrinsic function is called:"
msgstr ""

msgid "Operand"
msgstr ""

msgid "Description"
msgstr ""

msgid "``INTRINSIC_1_INVALID``"
msgstr ""

msgid "Not valid"
msgstr ""

msgid "``INTRINSIC_PRINT``"
msgstr ""

msgid "Prints the argument to standard out. Used in the REPL."
msgstr ""

msgid "``INTRINSIC_IMPORT_STAR``"
msgstr ""

msgid "Performs ``import *`` for the named module."
msgstr ""

msgid "``INTRINSIC_STOPITERATION_ERROR``"
msgstr ""

msgid "Extracts the return value from a ``StopIteration`` exception."
msgstr ""

msgid "``INTRINSIC_ASYNC_GEN_WRAP``"
msgstr ""

msgid "Wraps an async generator value"
msgstr ""

msgid "``INTRINSIC_UNARY_POSITIVE``"
msgstr ""

msgid "Performs the unary ``+`` operation"
msgstr ""

msgid "``INTRINSIC_LIST_TO_TUPLE``"
msgstr ""

msgid "Converts a list to a tuple"
msgstr ""

msgid "``INTRINSIC_TYPEVAR``"
msgstr ""

msgid "Creates a :class:`typing.TypeVar`"
msgstr ""

msgid "``INTRINSIC_PARAMSPEC``"
msgstr ""

msgid "Creates a :class:`typing.ParamSpec`"
msgstr ""

msgid "``INTRINSIC_TYPEVARTUPLE``"
msgstr ""

msgid "Creates a :class:`typing.TypeVarTuple`"
msgstr ""

msgid "``INTRINSIC_SUBSCRIPT_GENERIC``"
msgstr ""

msgid "Returns :class:`typing.Generic` subscripted with the argument"
msgstr ""

msgid "``INTRINSIC_TYPEALIAS``"
msgstr ""

msgid ""
"Creates a :class:`typing.TypeAliasType`; used in the :keyword:`type` "
"statement. The argument is a tuple of the type alias's name, type "
"parameters, and value."
msgstr ""

msgid ""
"Calls an intrinsic function with two arguments. Used to implement "
"functionality that is not performance critical::"
msgstr ""

msgid ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"result = intrinsic2(arg1, arg2)\n"
"STACK.append(result)"
msgstr ""

msgid "``INTRINSIC_2_INVALID``"
msgstr ""

msgid "``INTRINSIC_PREP_RERAISE_STAR``"
msgstr ""

msgid "Calculates the :exc:`ExceptionGroup` to raise from a ``try-except*``."
msgstr ""

msgid "``INTRINSIC_TYPEVAR_WITH_BOUND``"
msgstr ""

msgid "Creates a :class:`typing.TypeVar` with a bound."
msgstr ""

msgid "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"
msgstr ""

msgid "Creates a :class:`typing.TypeVar` with constraints."
msgstr ""

msgid "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"
msgstr ""

msgid "Sets the ``__type_params__`` attribute of a function."
msgstr ""

msgid ""
"Performs special method lookup on ``STACK[-1]``. If ``type(STACK[-1])."
"__xxx__`` is a method, leave ``type(STACK[-1]).__xxx__; STACK[-1]`` on the "
"stack. If ``type(STACK[-1]).__xxx__`` is not a method, leave ``STACK[-1]."
"__xxx__; NULL`` on the stack."
msgstr ""

msgid "**Pseudo-instructions**"
msgstr ""

msgid ""
"These opcodes do not appear in Python bytecode. They are used by the "
"compiler but are replaced by real opcodes or removed before bytecode is "
"generated."
msgstr ""

msgid ""
"Set up an exception handler for the following code block. If an exception "
"occurs, the value stack level is restored to its current state and control "
"is transferred to the exception handler at ``target``."
msgstr ""

msgid ""
"Like ``SETUP_FINALLY``, but in case of an exception also pushes the last "
"instruction (``lasti``) to the stack so that ``RERAISE`` can restore it. If "
"an exception occurs, the value stack level and the last instruction on the "
"frame are restored to their current state, and control is transferred to the "
"exception handler at ``target``."
msgstr ""

msgid ""
"Like ``SETUP_CLEANUP``, but in case of an exception one more item is popped "
"from the stack before control is transferred to the exception handler at "
"``target``."
msgstr ""

msgid ""
"This variant is used in :keyword:`with` and :keyword:`async with` "
"constructs, which push the return value of the context manager's :meth:"
"`~object.__enter__` or :meth:`~object.__aenter__` to the stack."
msgstr ""

msgid ""
"Marks the end of the code block associated with the last ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` or ``SETUP_WITH``."
msgstr ""

msgid ""
"Undirected relative jump instructions which are replaced by their directed "
"(forward/backward) counterparts by the assembler."
msgstr ""

msgid ""
"Conditional jumps which do not impact the stack. Replaced by the sequence "
"``COPY 1``, ``TO_BOOL``, ``POP_JUMP_IF_TRUE/FALSE``."
msgstr ""

msgid ""
"Pushes a reference to the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""

msgid ""
"Note that ``LOAD_CLOSURE`` is replaced with ``LOAD_FAST`` in the assembler."
msgstr ""

msgid "This opcode is now a pseudo-instruction."
msgstr ""

msgid ""
"Optimized unbound method lookup. Emitted as a ``LOAD_ATTR`` opcode with a "
"flag set in the arg."
msgstr ""

msgid "Opcode collections"
msgstr ""

msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr ""

msgid ""
"The collections now contain pseudo instructions and instrumented "
"instructions as well. These are opcodes with values ``>= MIN_PSEUDO_OPCODE`` "
"and ``>= MIN_INSTRUMENTED_OPCODE``."
msgstr ""

msgid "Sequence of operation names, indexable using the bytecode."
msgstr ""

msgid "Dictionary mapping operation names to bytecodes."
msgstr ""

msgid "Sequence of all compare operation names."
msgstr ""

msgid "Sequence of bytecodes that use their argument."
msgstr ""

msgid "Sequence of bytecodes that access a constant."
msgstr ""

msgid ""
"Sequence of bytecodes that access a :term:`free (closure) variable <closure "
"variable>`. 'free' in this context refers to names in the current scope that "
"are referenced by inner scopes or names in outer scopes that are referenced "
"from this scope.  It does *not* include references to global or builtin "
"scopes."
msgstr ""

msgid "Sequence of bytecodes that access an attribute by name."
msgstr ""

msgid "Sequence of bytecodes that have a jump target. All jumps are relative."
msgstr ""

msgid "Sequence of bytecodes that access a local variable."
msgstr ""

msgid "Sequence of bytecodes of Boolean operations."
msgstr ""

msgid "Sequence of bytecodes that set an exception handler."
msgstr ""

msgid "Sequence of bytecodes that have a relative jump target."
msgstr ""

msgid "All jumps are now relative. Use :data:`hasjump`."
msgstr ""

msgid "Sequence of bytecodes that have an absolute jump target."
msgstr ""

msgid "All jumps are now relative. This list is empty."
msgstr ""

msgid "built-in function"
msgstr ""

msgid "slice"
msgstr ""
