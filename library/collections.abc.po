# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!collections.abc` --- Abstract Base Classes for Containers"
msgstr ":mod:`!collections.abc` --- Abstrakta basklasser för behållare"

msgid "Formerly, this module was part of the :mod:`collections` module."
msgstr "Tidigare var denna modul en del av modulen :mod:`collections`."

msgid "**Source code:** :source:`Lib/_collections_abc.py`"
msgstr "**Källkod:** :source:`Lib/_collections_abc.py`"

msgid ""
"This module provides :term:`abstract base classes <abstract base class>` "
"that can be used to test whether a class provides a particular interface; "
"for example, whether it is :term:`hashable` or whether it is a :term:"
"`mapping`."
msgstr ""
"Denna modul tillhandahåller :term:`abstrakta basklasser <abstract base "
"class>` som kan användas för att testa om en klass tillhandahåller ett visst "
"gränssnitt, till exempel om den är :term:`hashable` eller om den är en :term:"
"`mapping`."

msgid ""
"An :func:`issubclass` or :func:`isinstance` test for an interface works in "
"one of three ways."
msgstr ""
"Ett :func:`issubclass`- eller :func:`isinstance`-test för ett gränssnitt "
"fungerar på ett av tre sätt."

msgid ""
"A newly written class can inherit directly from one of the abstract base "
"classes.  The class must supply the required abstract methods.  The "
"remaining mixin methods come from inheritance and can be overridden if "
"desired.  Other methods may be added as needed:"
msgstr ""
"En nyskriven klass kan ärva direkt från en av de abstrakta basklasserna.  "
"Klassen måste tillhandahålla de abstrakta metoder som krävs.  De återstående "
"mixin-metoderna kommer från arv och kan åsidosättas om så önskas.  Andra "
"metoder kan läggas till efter behov:"

msgid ""
"class C(Sequence):                      # Direct inheritance\n"
"    def __init__(self): ...             # Extra method not required by the "
"ABC\n"
"    def __getitem__(self, index):  ...  # Required abstract method\n"
"    def __len__(self):  ...             # Required abstract method\n"
"    def count(self, value): ...         # Optionally override a mixin method"
msgstr ""
"klass C(Sekvens):                      # Direkt arv\n"
"    def __init__(self): ...             # Extra metod som inte krävs av ABC\n"
"    def __getitem__(self, index): ...  # Nödvändig abstrakt metod\n"
"    def __len__(self):  ...             # Krävs abstrakt metod\n"
"    def count(self, värde): ...         # Eventuellt åsidosätta en mixin-"
"metod"

msgid ""
">>> issubclass(C, Sequence)\n"
"True\n"
">>> isinstance(C(), Sequence)\n"
"True"
msgstr ""
">>> issubclass(C, Sekvens)\n"
"Sant\n"
">>> isinstance(C(), Sekvens)\n"
"Sant"

msgid ""
"Existing classes and built-in classes can be registered as \"virtual "
"subclasses\" of the ABCs.  Those classes should define the full API "
"including all of the abstract methods and all of the mixin methods. This "
"lets users rely on :func:`issubclass` or :func:`isinstance` tests to "
"determine whether the full interface is supported.  The exception to this "
"rule is for methods that are automatically inferred from the rest of the API:"
msgstr ""
"Befintliga klasser och inbyggda klasser kan registreras som \"virtuella "
"underklasser\" av ABC.  Dessa klasser bör definiera hela API:et, inklusive "
"alla abstrakta metoder och alla mixin-metoder. Detta gör att användare kan "
"förlita sig på :func:`issubclass` eller :func:`isinstance`-tester för att "
"avgöra om det fullständiga gränssnittet stöds.  Undantaget från denna regel "
"är för metoder som automatiskt härleds från resten av API:et:"

msgid ""
"class D:                                 # No inheritance\n"
"    def __init__(self): ...              # Extra method not required by the "
"ABC\n"
"    def __getitem__(self, index):  ...   # Abstract method\n"
"    def __len__(self):  ...              # Abstract method\n"
"    def count(self, value): ...          # Mixin method\n"
"    def index(self, value): ...          # Mixin method\n"
"\n"
"Sequence.register(D)                     # Register instead of inherit"
msgstr ""
"klass D:                                 # Ingen nedärvning\n"
"    def __init__(self): ...              # Extra metod som inte krävs av "
"ABC\n"
"    def __getitem__(self, index): ...   # Abstrakt metod\n"
"    def __len__(self):  ...              # Abstrakt metod\n"
"    def count(self, värde): ...          # Mixin-metod\n"
"    def index(self, värde): ...          # Mixin-metod\n"
"\n"
"Sequence.register(D) # Registrera istället för att ärva"

msgid ""
">>> issubclass(D, Sequence)\n"
"True\n"
">>> isinstance(D(), Sequence)\n"
"True"
msgstr ""
">>> issubclass(D, Sekvens)\n"
"Sant\n"
">>> isinstance(D(), Sekvens)\n"
"Sant"

msgid ""
"In this example, class :class:`!D` does not need to define ``__contains__``, "
"``__iter__``, and ``__reversed__`` because the :ref:`in-operator "
"<comparisons>`, the :term:`iteration <iterable>` logic, and the :func:"
"`reversed` function automatically fall back to using ``__getitem__`` and "
"``__len__``."
msgstr ""
"I det här exemplet behöver klassen :class:`!D` inte definiera "
"``__contains__``, ``__iter__`` och ``__reversed__`` eftersom logiken :ref:"
"`in-operator <comparisons>`, logiken :term:`iteration <iterable>` och "
"funktionen :func:`reversed` automatiskt faller tillbaka till att använda "
"``__getitem__`` och ``__len__``."

msgid ""
"Some simple interfaces are directly recognizable by the presence of the "
"required methods (unless those methods have been set to :const:`None`):"
msgstr ""
"Vissa enkla gränssnitt är direkt igenkännliga genom att de nödvändiga "
"metoderna finns (såvida inte dessa metoder har ställts in på :const:`None`):"

msgid ""
"class E:\n"
"    def __iter__(self): ...\n"
"    def __next__(self): ..."
msgstr ""
"klass E:\n"
"    def __iter__(self): ...\n"
"    def __next__(self): ..."

msgid ""
">>> issubclass(E, Iterable)\n"
"True\n"
">>> isinstance(E(), Iterable)\n"
"True"
msgstr ""
">>> issubclass(E, Iterable)\n"
"Sant\n"
">>> isinstance(E(), Iterabel)\n"
"Sant"

msgid ""
"Complex interfaces do not support this last technique because an interface "
"is more than just the presence of method names.  Interfaces specify "
"semantics and relationships between methods that cannot be inferred solely "
"from the presence of specific method names.  For example, knowing that a "
"class supplies ``__getitem__``, ``__len__``, and ``__iter__`` is "
"insufficient for distinguishing a :class:`Sequence` from a :class:`Mapping`."
msgstr ""
"Komplexa gränssnitt stöder inte denna sista teknik eftersom ett gränssnitt "
"är mer än bara förekomsten av metodnamn.  Gränssnitt specificerar semantik "
"och relationer mellan metoder som inte kan härledas enbart från förekomsten "
"av specifika metodnamn.  Att veta att en klass tillhandahåller "
"``__getitem__``, ``__len__`` och ``__iter__`` är till exempel inte "
"tillräckligt för att skilja en :class:`Sequence` från en :class:`Mapping`."

msgid ""
"These abstract classes now support ``[]``. See :ref:`types-genericalias` "
"and :pep:`585`."
msgstr ""
"Dessa abstrakta klasser har nu stöd för ``[]``. Se :ref:`types-genericalias` "
"och :pep:`585`."

msgid "Collections Abstract Base Classes"
msgstr "Samlingar Abstrakta basklasser"

msgid ""
"The collections module offers the following :term:`ABCs <abstract base "
"class>`:"
msgstr "Samlingsmodulen erbjuder följande :term:`ABCs <abstract base class>`:"

msgid "ABC"
msgstr "ABC"

msgid "Inherits from"
msgstr "Ärver från"

msgid "Abstract Methods"
msgstr "Abstrakta metoder"

msgid "Mixin Methods"
msgstr "Mixin-metoder"

msgid ":class:`Container` [1]_"
msgstr ":class:`Container` [1]_"

msgid "``__contains__``"
msgstr "``__innehåller__```"

msgid ":class:`Hashable` [1]_"
msgstr ":class:`Hashable` [1]_"

msgid "``__hash__``"
msgstr "``__hash__```"

msgid ":class:`Iterable` [1]_ [2]_"
msgstr ":class:`Iterable` [1]_ [2]_"

msgid "``__iter__``"
msgstr "``__iter__``"

msgid ":class:`Iterator` [1]_"
msgstr ":class:`Iterator` [1]_"

msgid ":class:`Iterable`"
msgstr ":class:`Iterable`"

msgid "``__next__``"
msgstr "``__nästa__```"

msgid ":class:`Reversible` [1]_"
msgstr ":class:`Reversibel` [1]_"

msgid "``__reversed__``"
msgstr "``__vända__```"

msgid ":class:`Generator`  [1]_"
msgstr ":class:`Generator`  [1]_"

msgid ":class:`Iterator`"
msgstr ":class:`Iterator`"

msgid "``send``, ``throw``"
msgstr "\"skicka\", \"kasta"

msgid "``close``, ``__iter__``, ``__next__``"
msgstr "``close``, ``__iter__``, ``__next__``"

msgid ":class:`Sized`  [1]_"
msgstr ":class:`Sized` [1]_"

msgid "``__len__``"
msgstr "``__len__```"

msgid ":class:`Callable`  [1]_"
msgstr ":class:`Callable` [1]_"

msgid "``__call__``"
msgstr "``__anrop__```"

msgid ":class:`Collection`  [1]_"
msgstr ":class:`Collection` [1]_"

msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ":class:`Sized`, :class:`Iterable`, :class:`Container`"

msgid "``__contains__``, ``__iter__``, ``__len__``"
msgstr "``__innehåller__``, ``__iter__``, ``__len__``"

msgid ":class:`Sequence`"
msgstr ":class:`Sequence`"

msgid ":class:`Reversible`, :class:`Collection`"
msgstr ":class:`Reversible`, :class:`Collection`"

msgid "``__getitem__``, ``__len__``"
msgstr "``__getitem__``, ``__len__``"

msgid ""
"``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"
msgstr ""
"``__contains__``, ``__iter__``, ``__reversed__``, ``index`` och ``count``"

msgid ":class:`MutableSequence`"
msgstr ":class:`MutableSequence`"

msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"

msgid ""
"Inherited :class:`Sequence` methods and ``append``, ``clear``, ``reverse``, "
"``extend``, ``pop``, ``remove``, and ``__iadd__``"
msgstr ""
"Ärvda :class:`Sequence`-metoder och ``append``, ``clear``, ``reverse``, "
"``extend``, ``pop``, ``remove`` och ``__iadd__``"

msgid ":class:`Set`"
msgstr ":class:`Set`"

msgid ":class:`Collection`"
msgstr ":class:`Collection`"

msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__rsub__``, ``__xor__``, "
"``__rxor__`` and ``isdisjoint``"
msgstr ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__rsub__``, ``__xor__``, "
"``__rxor__`` och ``isdisjoint``"

msgid ":class:`MutableSet`"
msgstr ":class:`MutableSet`"

msgid "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"
msgstr "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"

msgid ""
"Inherited :class:`Set` methods and ``clear``, ``pop``, ``remove``, "
"``__ior__``, ``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ""
"Ärvda :class:`Set`-metoder och ``clear``, ``pop``, ``remove``, ``__ior__``, "
"``__iand__``, ``__ixor__`` och ``__isub__``"

msgid ":class:`Mapping`"
msgstr ":class:`Mapping`"

msgid "``__getitem__``, ``__iter__``, ``__len__``"
msgstr "``__getitem__``, ``__iter__``, ``__len__``"

msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and "
"``__ne__``"
msgstr ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__`` och "
"``ne__``"

msgid ":class:`MutableMapping`"
msgstr ":class:`MutableMapping`"

msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"

msgid ""
"Inherited :class:`Mapping` methods and ``pop``, ``popitem``, ``clear``, "
"``update``, and ``setdefault``"
msgstr ""
"Ärvda :class:`Mapping`-metoder och ``pop``, ``popitem``, ``clear``, "
"``update`` och ``setdefault``"

msgid ":class:`MappingView`"
msgstr ":class:`MappingView`"

msgid ":class:`Sized`"
msgstr ":class:`Sized`"

msgid "``__init__``, ``__len__`` and ``__repr__``"
msgstr "``__init__``, ``__len__`` och ``__repr__``"

msgid ":class:`ItemsView`"
msgstr ":class:`ItemsView`"

msgid ":class:`MappingView`, :class:`Set`"
msgstr ":class:`MappingView`, :class:`Set`"

msgid "``__contains__``, ``__iter__``"
msgstr "``__innehåller__``, ``__iter__``"

msgid ":class:`KeysView`"
msgstr ":class:`KeysView`"

msgid ":class:`ValuesView`"
msgstr ":class:`ValuesView`"

msgid ":class:`MappingView`, :class:`Collection`"
msgstr ":class:`MappingView`, :class:`Collection`"

msgid ":class:`Awaitable` [1]_"
msgstr ":class:`Awaitable` [1]_"

msgid "``__await__``"
msgstr "``__avvakta__``"

msgid ":class:`Coroutine` [1]_"
msgstr ":class:`Coroutine` [1]_"

msgid ":class:`Awaitable`"
msgstr ":class:`Awaitable`"

msgid "``close``"
msgstr "``stänga``"

msgid ":class:`AsyncIterable` [1]_"
msgstr ":class:`AsyncIterable` [1]_"

msgid "``__aiter__``"
msgstr "``__aiter__```"

msgid ":class:`AsyncIterator` [1]_"
msgstr ":class:`AsyncIterator` [1]_"

msgid ":class:`AsyncIterable`"
msgstr ":class:`AsyncIterable`"

msgid "``__anext__``"
msgstr "``__anext__```"

msgid ":class:`AsyncGenerator` [1]_"
msgstr ":class:`AsyncGenerator` [1]_"

msgid ":class:`AsyncIterator`"
msgstr ":class:`AsyncIterator`"

msgid "``asend``, ``athrow``"
msgstr "``asend``, ``athrow``"

msgid "``aclose``, ``__aiter__``, ``__anext__``"
msgstr "``sluta``, ``__aiter__``, ``__anext__``"

msgid ":class:`Buffer` [1]_"
msgstr ":class:`Buffer` [1]_"

msgid "``__buffer__``"
msgstr "``__buffer__```"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"These ABCs override :meth:`~abc.ABCMeta.__subclasshook__` to support testing "
"an interface by verifying the required methods are present and have not been "
"set to :const:`None`.  This only works for simple interfaces.  More complex "
"interfaces require registration or direct subclassing."
msgstr ""
"Dessa ABC:er åsidosätter :meth:`~abc.ABCMeta.__subclasshook__` för att "
"stödja testning av ett gränssnitt genom att verifiera att de nödvändiga "
"metoderna finns och inte har satts till :const:`None`.  Detta fungerar "
"endast för enkla gränssnitt.  Mer komplexa gränssnitt kräver registrering "
"eller direkt subklassning."

msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are registered "
"as :class:`Iterable` or that have an :meth:`~container.__iter__` method, but "
"it does not detect classes that iterate with the :meth:`~object.__getitem__` "
"method.  The only reliable way to determine whether an object is :term:"
"`iterable` is to call ``iter(obj)``."
msgstr ""
"Kontrollen ``isinstance(obj, Iterable)`` upptäcker klasser som är "
"registrerade som :class:`Iterable` eller som har en :meth:`~container."
"__iter__`-metod, men den upptäcker inte klasser som itererar med :meth:"
"`~object.__getitem__`-metoden.  Det enda tillförlitliga sättet att avgöra om "
"ett objekt är :term:`iterable` är att anropa ``iter(obj)``."

msgid "Collections Abstract Base Classes -- Detailed Descriptions"
msgstr "Collections Abstrakta basklasser -- Detaljerade beskrivningar"

msgid "ABC for classes that provide the :meth:`~object.__contains__` method."
msgstr ""
"ABC för klasser som tillhandahåller metoden :meth:`~object.__contains__`."

msgid "ABC for classes that provide the :meth:`~object.__hash__` method."
msgstr "ABC för klasser som tillhandahåller metoden :meth:`~object.__hash__`."

msgid "ABC for classes that provide the :meth:`~object.__len__` method."
msgstr "ABC för klasser som tillhandahåller metoden :meth:`~object.__len__`."

msgid "ABC for classes that provide the :meth:`~object.__call__` method."
msgstr "ABC för klasser som tillhandahåller metoden :meth:`~object.__call__`."

msgid ""
"See :ref:`annotating-callables` for details on how to use :class:`!Callable` "
"in type annotations."
msgstr ""
"Se :ref:`annotating-callables` för detaljer om hur man använder :class:`!"
"Callable` i typannoteringar."

msgid "ABC for classes that provide the :meth:`~container.__iter__` method."
msgstr ""
"ABC för klasser som tillhandahåller metoden :meth:`~container.__iter__`."

msgid ""
"Checking ``isinstance(obj, Iterable)`` detects classes that are registered "
"as :class:`Iterable` or that have an :meth:`~container.__iter__` method, but "
"it does not detect classes that iterate with the :meth:`~object.__getitem__` "
"method. The only reliable way to determine whether an object is :term:"
"`iterable` is to call ``iter(obj)``."
msgstr ""
"Kontrollen ``isinstance(obj, Iterable)`` upptäcker klasser som är "
"registrerade som :class:`Iterable` eller som har en :meth:`~container."
"__iter__`-metod, men den upptäcker inte klasser som itererar med :meth:"
"`~object.__getitem__`-metoden. Det enda tillförlitliga sättet att avgöra om "
"ett objekt är :term:`iterable` är att anropa ``iter(obj)``."

msgid "ABC for sized iterable container classes."
msgstr "ABC för stora iterabla containerklasser."

msgid ""
"ABC for classes that provide the :meth:`~iterator.__iter__` and :meth:"
"`~iterator.__next__` methods.  See also the definition of :term:`iterator`."
msgstr ""
"ABC för klasser som tillhandahåller metoderna :meth:`~iterator.__iter__` "
"och :meth:`~iterator.__next__`.  Se även definitionen av :term:`iterator`."

msgid ""
"ABC for iterable classes that also provide the :meth:`~object.__reversed__` "
"method."
msgstr ""
"ABC för iterabla klasser som också tillhandahåller metoden :meth:`~object."
"__reversed__`."

msgid ""
"ABC for :term:`generator` classes that implement the protocol defined in :"
"pep:`342` that extends :term:`iterators <iterator>` with the :meth:"
"`~generator.send`, :meth:`~generator.throw` and :meth:`~generator.close` "
"methods."
msgstr ""
"ABC för :term:`generator`-klasser som implementerar protokollet definierat "
"i :pep:`342` som utökar :term:`iterators <iterator>` med metoderna :meth:"
"`~generator.send`, :meth:`~generator.throw` och :meth:`~generator.close`."

msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using :class:"
"`!Generator` in type annotations."
msgstr ""
"Se :ref:`annotating-generators-and-coroutines` för detaljer om hur man "
"använder :class:`!Generator` i typannoteringar."

msgid "ABCs for read-only and mutable :term:`sequences <sequence>`."
msgstr "ABC för skrivskyddade och muterbara :term:`sekvenser <sequence>`."

msgid ""
"Implementation note: Some of the mixin methods, such as :meth:`~container."
"__iter__`, :meth:`~object.__reversed__` and :meth:`index`, make repeated "
"calls to the underlying :meth:`~object.__getitem__` method. Consequently, "
"if :meth:`~object.__getitem__` is implemented with constant access speed, "
"the mixin methods will have linear performance; however, if the underlying "
"method is linear (as it would be with a linked list), the mixins will have "
"quadratic performance and will likely need to be overridden."
msgstr ""
"Implementationsanmärkning: Vissa av mixinmetoderna, t.ex. :meth:`~container."
"__iter__`, :meth:`~object.__reversed__` och :meth:`index`, gör upprepade "
"anrop till den underliggande metoden :meth:`~object.__getitem__`. "
"Följaktligen, om :meth:`~object.__getitem__` implementeras med konstant "
"åtkomsthastighet, kommer mixinmetoderna att ha linjär prestanda; men om den "
"underliggande metoden är linjär (som den skulle vara med en länkad lista), "
"kommer mixinerna att ha kvadratisk prestanda och kommer sannolikt att behöva "
"åsidosättas."

msgid "The index() method added support for *stop* and *start* arguments."
msgstr ""
"I metoden index() har stöd för argumenten *stop* och *start* lagts till."

msgid "ABCs for read-only and mutable :ref:`sets <types-set>`."
msgstr "ABC för skrivskyddade och muterbara :ref:`sets <types-set>`."

msgid "ABCs for read-only and mutable :term:`mappings <mapping>`."
msgstr "ABC för skrivskyddade och muterbara :term:`mappningar <mapping>`."

msgid ""
"ABCs for mapping, items, keys, and values :term:`views <dictionary view>`."
msgstr ""
"ABC för mappning, objekt, nycklar och värden :term:`views <dictionary view>`."

msgid ""
"ABC for :term:`awaitable` objects, which can be used in :keyword:`await` "
"expressions.  Custom implementations must provide the :meth:`~object."
"__await__` method."
msgstr ""
"ABC för :term:`awaitable`-objekt, som kan användas i :keyword:`await`-"
"uttryck.  Anpassade implementationer måste tillhandahålla metoden :meth:"
"`~object.__await__`."

msgid ""
":term:`Coroutine <coroutine>` objects and instances of the :class:"
"`~collections.abc.Coroutine` ABC are all instances of this ABC."
msgstr ""
":term:`Coroutine <coroutine>` objekt och instanser av :class:`~collections."
"abc.Coroutine` ABC är alla instanser av denna ABC."

msgid ""
"In CPython, generator-based coroutines (:term:`generators <generator>` "
"decorated with :func:`@types.coroutine <types.coroutine>`) are *awaitables*, "
"even though they do not have an :meth:`~object.__await__` method. Using "
"``isinstance(gencoro, Awaitable)`` for them will return ``False``. Use :func:"
"`inspect.isawaitable` to detect them."
msgstr ""
"I CPython är generatorbaserade coroutines (:term:`generators <generator>` "
"dekorerad med :func:`@types.coroutine <types.coroutine>`) *awaitables*, även "
"om de inte har en :meth:`~object.__await__`-metod. Att använda "
"``isinstance(gencoro, Awaitable)`` för dem kommer att returnera ``False``. "
"Använd :func:`inspect.isawaitable` för att upptäcka dem."

msgid ""
"ABC for :term:`coroutine` compatible classes.  These implement the following "
"methods, defined in :ref:`coroutine-objects`: :meth:`~coroutine.send`, :meth:"
"`~coroutine.throw`, and :meth:`~coroutine.close`.  Custom implementations "
"must also implement :meth:`~object.__await__`.  All :class:`Coroutine` "
"instances are also instances of :class:`Awaitable`."
msgstr ""
"ABC för :term:`coroutine`-kompatibla klasser.  Dessa implementerar följande "
"metoder, definierade i :ref:`coroutine-objects`: :meth:`~coroutine.send`, :"
"meth:`~coroutine.throw`, och :meth:`~coroutine.close`.  Anpassade "
"implementationer måste också implementera :meth:`~object.__await__`.  Alla :"
"class:`Coroutine`-instanser är också instanser av :class:`Awaitable`."

msgid ""
"In CPython, generator-based coroutines (:term:`generators <generator>` "
"decorated with :func:`@types.coroutine <types.coroutine>`) are *awaitables*, "
"even though they do not have an :meth:`~object.__await__` method. Using "
"``isinstance(gencoro, Coroutine)`` for them will return ``False``. Use :func:"
"`inspect.isawaitable` to detect them."
msgstr ""
"I CPython är generatorbaserade coroutines (:term:`generators <generator>` "
"dekorerad med :func:`@types.coroutine <types.coroutine>`) *awaitables*, även "
"om de inte har en :meth:`~object.__await__`-metod. Att använda "
"``isinstance(gencoro, Coroutine)`` för dem kommer att returnera ``False``. "
"Använd :func:`inspect.isawaitable` för att upptäcka dem."

msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using :class:"
"`!Coroutine` in type annotations. The variance and order of type parameters "
"correspond to those of :class:`Generator`."
msgstr ""
"Se :ref:`annotating-generators-and-coroutines` för detaljer om hur man "
"använder :class:`!Coroutine` i typannoteringar. Variansen och ordningen på "
"typ-parametrarna motsvarar de i :class:`Generator`."

msgid ""
"ABC for classes that provide an ``__aiter__`` method.  See also the "
"definition of :term:`asynchronous iterable`."
msgstr ""
"ABC för klasser som tillhandahåller en ``__aiter__``-metod.  Se även "
"definitionen av :term:`asynkron iterabel`."

msgid ""
"ABC for classes that provide ``__aiter__`` and ``__anext__`` methods.  See "
"also the definition of :term:`asynchronous iterator`."
msgstr ""
"ABC för klasser som tillhandahåller metoderna ``__aiter__`` och "
"``__anext__``.  Se även definitionen av :term:`asynkron iterator`."

msgid ""
"ABC for :term:`asynchronous generator` classes that implement the protocol "
"defined in :pep:`525` and :pep:`492`."
msgstr ""
"ABC för :term:`asynkron generator`-klasser som implementerar protokollet "
"definierat i :pep:`525` och :pep:`492`."

msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using :class:"
"`!AsyncGenerator` in type annotations."
msgstr ""
"Se :ref:`annotating-generators-and-coroutines` för detaljer om hur man "
"använder :class:`!AsyncGenerator` i typannoteringar."

msgid ""
"ABC for classes that provide the :meth:`~object.__buffer__` method, "
"implementing the :ref:`buffer protocol <bufferobjects>`. See :pep:`688`."
msgstr ""
"ABC för klasser som tillhandahåller metoden :meth:`~object.__buffer__` och "
"som implementerar :ref:`buffer protocol <bufferobjects>`. Se :pep:`688`."

msgid "Examples and Recipes"
msgstr "Exempel och recept"

msgid ""
"ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr ""
"ABC gör det möjligt för oss att fråga klasser eller instanser om de "
"tillhandahåller viss funktionalitet, till exempel::"

msgid ""
"size = None\n"
"if isinstance(myvar, collections.abc.Sized):\n"
"    size = len(myvar)"
msgstr ""
"size = Ingen\n"
"if isinstance(myvar, collections.abc.Sized):\n"
"    size = len(myvar)"

msgid ""
"Several of the ABCs are also useful as mixins that make it easier to develop "
"classes supporting container APIs.  For example, to write a class supporting "
"the full :class:`Set` API, it is only necessary to supply the three "
"underlying abstract methods: :meth:`~object.__contains__`, :meth:`~container."
"__iter__`, and :meth:`~object.__len__`. The ABC supplies the remaining "
"methods such as :meth:`!__and__` and :meth:`~frozenset.isdisjoint`::"
msgstr ""
"Flera av ABC:erna är också användbara som mixins som gör det enklare att "
"utveckla klasser som stöder container-API:er.  Om du till exempel vill "
"skriva en klass som stöder hela :class:`Set` API behöver du bara "
"tillhandahålla de tre underliggande abstrakta metoderna: :meth:`~object."
"__contains__`, :meth:`~container.__iter__` och :meth:`~object.__len__`. ABC "
"tillhandahåller de återstående metoderna som :meth:`!__and__` och :meth:"
"`~frozenset.isdisjoint`::"

msgid ""
"class ListBasedSet(collections.abc.Set):\n"
"    ''' Alternate set implementation favoring space over speed\n"
"        and not requiring the set elements to be hashable. '''\n"
"    def __init__(self, iterable):\n"
"        self.elements = lst = []\n"
"        for value in iterable:\n"
"            if value not in lst:\n"
"                lst.append(value)\n"
"\n"
"    def __iter__(self):\n"
"        return iter(self.elements)\n"
"\n"
"    def __contains__(self, value):\n"
"        return value in self.elements\n"
"\n"
"    def __len__(self):\n"
"        return len(self.elements)\n"
"\n"
"s1 = ListBasedSet('abcdef')\n"
"s2 = ListBasedSet('defghi')\n"
"overlap = s1 & s2            # The __and__() method is supported "
"automatically"
msgstr ""
"class ListBasedSet(collections.abc.Set):\n"
"    ''' Alternativ set-implementering som prioriterar utrymme framför "
"hastighet\n"
"        och som inte kräver att set-elementen ska vara hashbara. '''\n"
"    def __init__(self, iterable):\n"
"        self.elements = lst = []\n"
"        för värde i iterable:\n"
"            om värdet inte finns i lst:\n"
"                lst.append(värde)\n"
"\n"
"    def __iter__(self):\n"
"        return iter(self.elements)\n"
"\n"
"    def __contains__(self, värde):\n"
"        return värde i self.elements\n"
"\n"
"    def __len__(self):\n"
"        return len(self.elements)\n"
"\n"
"s1 = ListBasedSet('abcdef')\n"
"s2 = ListBasedSet('defghi')\n"
"overlap = s1 & s2 # Metoden __and__() stöds automatiskt"

msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr ""
"Anteckningar om hur man använder :class:`Set` och :class:`MutableSet` som "
"mixin:"

msgid ""
"Since some set operations create new sets, the default mixin methods need a "
"way to create new instances from an :term:`iterable`. The class constructor "
"is assumed to have a signature in the form ``ClassName(iterable)``. That "
"assumption is factored-out to an internal :class:`classmethod` called :meth:"
"`!_from_iterable` which calls ``cls(iterable)`` to produce a new set. If "
"the :class:`Set` mixin is being used in a class with a different constructor "
"signature, you will need to override :meth:`!_from_iterable` with a "
"classmethod or regular method that can construct new instances from an "
"iterable argument."
msgstr ""
"Eftersom vissa set-operationer skapar nya set, behöver "
"standardmixinmetoderna ett sätt att skapa nya instanser från en :term:"
"`iterable`. Klasskonstruktören antas ha en signatur i formen "
"``ClassName(iterable)``. Detta antagande faktureras ut till en intern :class:"
"`classmethod` som kallas :meth:`!_from_iterable` som anropar "
"``cls(iterable)`` för att producera en ny uppsättning. Om mixinen :class:"
"`Set` används i en klass med en annan konstruktörsignatur, måste du "
"åsidosätta :meth:`!_from_iterable` med en klassmetod eller vanlig metod som "
"kan konstruera nya instanser från ett iterabelt argument."

msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`~object.__le__` and :meth:`~object.__ge__`, then the "
"other operations will automatically follow suit."
msgstr ""
"För att åsidosätta jämförelserna (förmodligen för snabbhetens skull, "
"eftersom semantiken är fast), omdefiniera :meth:`~object.__le__` och :meth:"
"`~object.__ge__`, så kommer de andra operationerna automatiskt att följa "
"efter."

msgid ""
"The :class:`Set` mixin provides a :meth:`!_hash` method to compute a hash "
"value for the set; however, :meth:`~object.__hash__` is not defined because "
"not all sets are :term:`hashable` or immutable.  To add set hashability "
"using mixins, inherit from both :meth:`Set` and :meth:`Hashable`, then "
"define ``__hash__ = Set._hash``."
msgstr ""
"Mixinen :class:`Set` tillhandahåller en metod :meth:`!_hash` för att beräkna "
"ett hashvärde för uppsättningen, men :meth:`~object.__hash__` definieras "
"inte eftersom inte alla uppsättningar är :term:`hashable` eller "
"oföränderliga.  För att lägga till hashbarhet för set med hjälp av mixins, "
"ärva från både :meth:`Set` och :meth:`Hashable` och definiera sedan "
"``__hash__ = Set._hash``."

msgid ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ for an "
"example built on :class:`MutableSet`."
msgstr ""
"`OrderedSet recept <https://code.activestate.com/recipes/576694/>`_ för ett "
"exempel som bygger på :class:`MutableSet`."

msgid "For more about ABCs, see the :mod:`abc` module and :pep:`3119`."
msgstr "Mer information om ABC finns i modulen :mod:`abc` och :pep:`3119`."
