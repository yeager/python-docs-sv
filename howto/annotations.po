# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Annotations Best Practices"
msgstr "Bästa praxis för annoteringar"

msgid "author"
msgstr "författare"

msgid "Larry Hastings"
msgstr "Larry Hastings"

msgid "Abstract"
msgstr "Abstrakt"

msgid ""
"This document is designed to encapsulate the best practices for working with "
"annotations dicts.  If you write Python code that examines "
"``__annotations__`` on Python objects, we encourage you to follow the "
"guidelines described below."
msgstr ""
"Detta dokument är utformat för att sammanfatta de bästa metoderna för att "
"arbeta med annotations-dikter.  Om du skriver Python-kod som undersöker "
"``__annotations__`` på Python-objekt, uppmuntrar vi dig att följa de "
"riktlinjer som beskrivs nedan."

msgid ""
"The document is organized into four sections: best practices for accessing "
"the annotations of an object in Python versions 3.10 and newer, best "
"practices for accessing the annotations of an object in Python versions 3.9 "
"and older, other best practices for ``__annotations__`` that apply to any "
"Python version, and quirks of ``__annotations__``."
msgstr ""
"Dokumentet är indelat i fyra avsnitt: bästa praxis för att komma åt "
"anteckningarna för ett objekt i Python version 3.10 och senare, bästa praxis "
"för att komma åt anteckningarna för ett objekt i Python version 3.9 och "
"äldre, andra bästa praxis för ``__annotations__`` som gäller för alla Python-"
"versioner, och egenheter med ``__annotations__``."

msgid ""
"Note that this document is specifically about working with "
"``__annotations__``, not uses *for* annotations. If you're looking for "
"information on how to use \"type hints\" in your code, please see the :mod:"
"`typing` module."
msgstr ""
"Observera att det här dokumentet handlar specifikt om att arbeta med "
"``__annotationer__``, inte om användningar *för* annotationer. Om du letar "
"efter information om hur du använder \"typtips\" i din kod, vänligen se "
"modulen :mod:`typing`."

msgid "Accessing The Annotations Dict Of An Object In Python 3.10 And Newer"
msgstr "Åtkomst till Annotations Dict of An Object i Python 3.10 och nyare"

msgid ""
"Python 3.10 adds a new function to the standard library: :func:`inspect."
"get_annotations`.  In Python versions 3.10 through 3.13, calling this "
"function is the best practice for accessing the annotations dict of any "
"object that supports annotations.  This function can also \"un-stringize\" "
"stringized annotations for you."
msgstr ""
"Python 3.10 lägger till en ny funktion i standardbiblioteket: :func:`inspect."
"get_annotations`.  I Python-versionerna 3.10 till 3.13 är det bästa sättet "
"att komma åt annotationsdikten för alla objekt som stöder annotationer att "
"anropa den här funktionen.  Denna funktion kan också \"avstränga\" strängade "
"annoteringar åt dig."

msgid ""
"In Python 3.14, there is a new :mod:`annotationlib` module with "
"functionality for working with annotations. This includes a :func:"
"`annotationlib.get_annotations` function, which supersedes :func:`inspect."
"get_annotations`."
msgstr ""
"I Python 3.14 finns en ny modul :mod:`annotationlib` med funktionalitet för "
"att arbeta med annoteringar. Detta inkluderar en :func:`annotationlib."
"get_annotations`-funktion, som ersätter :func:`inspect.get_annotations`."

msgid ""
"If for some reason :func:`inspect.get_annotations` isn't viable for your use "
"case, you may access the ``__annotations__`` data member manually.  Best "
"practice for this changed in Python 3.10 as well: as of Python 3.10, ``o."
"__annotations__`` is guaranteed to *always* work on Python functions, "
"classes, and modules.  If you're certain the object you're examining is one "
"of these three *specific* objects, you may simply use ``o.__annotations__`` "
"to get at the object's annotations dict."
msgstr ""
"Om :func:`inspect.get_annotations` av någon anledning inte är användbar för "
"ditt användningsfall, kan du komma åt ``__annotations__`` datamedlemmen "
"manuellt.  Bästa praxis för detta ändrades också i Python 3.10: från och med "
"Python 3.10 garanteras ``o.__annotations__`` att *alltid* fungera på Python-"
"funktioner, klasser och moduler.  Om du är säker på att objektet du "
"undersöker är ett av dessa tre *specifika* objekt, kan du helt enkelt "
"använda ``o.__annotations__`` för att komma åt objektets annotationsdiktat."

msgid ""
"However, other types of callables--for example, callables created by :func:"
"`functools.partial`--may not have an ``__annotations__`` attribute defined.  "
"When accessing the ``__annotations__`` of a possibly unknown object,  best "
"practice in Python versions 3.10 and newer is to call :func:`getattr` with "
"three arguments, for example ``getattr(o, '__annotations__', None)``."
msgstr ""
"Men andra typer av anropbara objekt - till exempel anropbara objekt skapade "
"av :func:`functools.partial` - kanske inte har ett ``__annotations__``-"
"attribut definierat.  När man vill komma åt ``__annotations__`` för ett "
"eventuellt okänt objekt är bästa praxis i Python version 3.10 och senare att "
"anropa :func:`getattr` med tre argument, till exempel ``getattr(o, "
"'__annotations__', None)``."

msgid ""
"Before Python 3.10, accessing ``__annotations__`` on a class that defines no "
"annotations but that has a parent class with annotations would return the "
"parent's ``__annotations__``. In Python 3.10 and newer, the child class's "
"annotations will be an empty dict instead."
msgstr ""
"Före Python 3.10 skulle åtkomst till ``__annotations__`` på en klass som "
"inte definierar några annoteringar men som har en föräldraklass med "
"annoteringar returnera förälderns ``__annotations__``. I Python 3.10 och "
"nyare kommer barnklassens annotationer att vara en tom dict istället."

msgid "Accessing The Annotations Dict Of An Object In Python 3.9 And Older"
msgstr "Åtkomst till Annotations Dict of An Object i Python 3.9 och äldre"

msgid ""
"In Python 3.9 and older, accessing the annotations dict of an object is much "
"more complicated than in newer versions. The problem is a design flaw in "
"these older versions of Python, specifically to do with class annotations."
msgstr ""
"I Python 3.9 och äldre är det mycket mer komplicerat att komma åt "
"annotationsdikten för ett objekt än i nyare versioner. Problemet är ett "
"designfel i dessa äldre versioner av Python, särskilt när det gäller "
"klassannoteringar."

msgid ""
"Best practice for accessing the annotations dict of other objects--"
"functions, other callables, and modules--is the same as best practice for "
"3.10, assuming you aren't calling :func:`inspect.get_annotations`: you "
"should use three-argument :func:`getattr` to access the object's "
"``__annotations__`` attribute."
msgstr ""
"Bästa praxis för att komma åt annotationsdikten för andra objekt - "
"funktioner, andra anropsbara objekt och moduler - är densamma som bästa "
"praxis för 3.10, förutsatt att du inte anropar :func:`inspect."
"get_annotations`: du bör använda treargument :func:`getattr` för att komma "
"åt objektets ``__annotations__``-attribut."

msgid ""
"Unfortunately, this isn't best practice for classes.  The problem is that, "
"since ``__annotations__`` is optional on classes, and because classes can "
"inherit attributes from their base classes, accessing the "
"``__annotations__`` attribute of a class may inadvertently return the "
"annotations dict of a *base class.* As an example::"
msgstr ""
"Tyvärr är detta inte bästa praxis för klasser.  Problemet är att eftersom "
"``__annotations__`` är valfritt för klasser, och eftersom klasser kan ärva "
"attribut från sina basklasser, kan åtkomst till ``__annotations__``-"
"attributet för en klass oavsiktligt returnera annotationsdikten för en "
"*basklass.* Som ett exempel::"

msgid ""
"class Base:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"class Derived(Base):\n"
"    pass\n"
"\n"
"print(Derived.__annotations__)"
msgstr ""
"klass Bas:\n"
"    a: int = 3\n"
"    b: str = 'abc'\n"
"\n"
"klass Avledda(Bas):\n"
"    pass\n"
"\n"
"print(Avledda.__annotationer__)"

msgid "This will print the annotations dict from ``Base``, not ``Derived``."
msgstr ""
"Detta kommer att skriva ut annoteringsdikten från ``Base``, inte ``Derived``."

msgid ""
"Your code will have to have a separate code path if the object you're "
"examining is a class (``isinstance(o, type)``). In that case, best practice "
"relies on an implementation detail of Python 3.9 and before: if a class has "
"annotations defined, they are stored in the class's :attr:`~type.__dict__` "
"dictionary.  Since the class may or may not have annotations defined, best "
"practice is to call the :meth:`~dict.get` method on the class dict."
msgstr ""
"Din kod måste ha en separat kodväg om objektet du undersöker är en klass "
"(``isinstance(o, type)``). I det fallet förlitar sig bästa praxis på en "
"implementeringsdetalj i Python 3.9 och tidigare: om en klass har "
"annotationer definierade lagras de i klassens :attr:`~type.__dict__`-"
"ordbok.  Eftersom klassen kanske eller kanske inte har annotationer "
"definierade är bästa praxis att anropa metoden :meth:`~dict.get` på klassen "
"dict."

msgid ""
"To put it all together, here is some sample code that safely accesses the "
"``__annotations__`` attribute on an arbitrary object in Python 3.9 and "
"before::"
msgstr ""
"För att sammanfatta det hela, här är några exempel på kod som på ett säkert "
"sätt kommer åt attributet ``__annotations__`` på ett godtyckligt objekt i "
"Python 3.9 och tidigare::"

msgid ""
"if isinstance(o, type):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"
msgstr ""
"if isinstance(o, typ):\n"
"    ann = o.__dict__.get('__annotations__', None)\n"
"else:\n"
"    ann = getattr(o, '__annotations__', None)"

msgid ""
"After running this code, ``ann`` should be either a dictionary or ``None``.  "
"You're encouraged to double-check the type of ``ann`` using :func:"
"`isinstance` before further examination."
msgstr ""
"Efter att ha kört den här koden bör ``ann`` vara antingen en dictionary "
"eller ``None``.  Du uppmanas att dubbelkolla typen av ``ann`` med hjälp av :"
"func:`isinstance` innan vidare undersökning."

msgid ""
"Note that some exotic or malformed type objects may not have a :attr:`~type."
"__dict__` attribute, so for extra safety you may also wish to use :func:"
"`getattr` to access :attr:`!__dict__`."
msgstr ""
"Observera att vissa exotiska eller missbildade typobjekt kanske inte har ett "
"attribut :attr:`~type.__dict__`, så för extra säkerhet kan du också vilja "
"använda :func:`getattr` för att komma åt :attr:`!__dict__`."

msgid "Manually Un-Stringizing Stringized Annotations"
msgstr "Manuell avsträngning av strängade annoteringar"

msgid ""
"In situations where some annotations may be \"stringized\", and you wish to "
"evaluate those strings to produce the Python values they represent, it "
"really is best to call :func:`inspect.get_annotations` to do this work for "
"you."
msgstr ""
"I situationer där vissa annoteringar kan vara \"strängade\", och du vill "
"utvärdera dessa strängar för att producera de Python-värden de "
"representerar, är det verkligen bäst att anropa :func:`inspect."
"get_annotations` för att göra detta arbete åt dig."

msgid ""
"If you're using Python 3.9 or older, or if for some reason you can't use :"
"func:`inspect.get_annotations`, you'll need to duplicate its logic.  You're "
"encouraged to examine the implementation of :func:`inspect.get_annotations` "
"in the current Python version and follow a similar approach."
msgstr ""
"Om du använder Python 3.9 eller äldre, eller om du av någon anledning inte "
"kan använda :func:`inspect.get_annotations`, måste du duplicera dess logik.  "
"Du uppmuntras att undersöka implementeringen av :func:`inspect."
"get_annotations` i den aktuella Python-versionen och följa ett liknande "
"tillvägagångssätt."

msgid ""
"In a nutshell, if you wish to evaluate a stringized annotation on an "
"arbitrary object ``o``:"
msgstr ""
"I ett nötskal, om du vill utvärdera en strängformad annotering på ett "
"godtyckligt objekt ``o``:"

msgid ""
"If ``o`` is a module, use ``o.__dict__`` as the ``globals`` when calling :"
"func:`eval`."
msgstr ""
"Om ``o`` är en modul, använd ``o.__dict__`` som ``globals`` när du anropar :"
"func:`eval`."

msgid ""
"If ``o`` is a class, use ``sys.modules[o.__module__].__dict__`` as the "
"``globals``, and ``dict(vars(o))`` as the ``locals``, when calling :func:"
"`eval`."
msgstr ""
"Om ``o`` är en klass, använd ``sys.modules[o.__module__].__dict__`` som "
"``globals``, och ``dict(vars(o))`` som ``locals``, när du anropar :func:"
"`eval`."

msgid ""
"If ``o`` is a wrapped callable using :func:`functools.update_wrapper`, :func:"
"`functools.wraps`, or :func:`functools.partial`, iteratively unwrap it by "
"accessing either ``o.__wrapped__`` or ``o.func`` as appropriate, until you "
"have found the root unwrapped function."
msgstr ""
"Om ``o`` är en inkapslad anropbar funktion som använder :func:`functools."
"update_wrapper`, :func:`functools.wraps`, eller :func:`functools.partial`, "
"kan du iterativt packa upp den genom att använda antingen ``o.__wrapped__`` "
"eller ``o.func``, tills du har hittat den uppackade rotfunktionen."

msgid ""
"If ``o`` is a callable (but not a class), use :attr:`o.__globals__ <function."
"__globals__>` as the globals when calling :func:`eval`."
msgstr ""
"Om ``o`` är en callable (men inte en class), använd :attr:`o.__globals__ "
"<function.__globals__>` som globals när du anropar :func:`eval`."

msgid ""
"However, not all string values used as annotations can be successfully "
"turned into Python values by :func:`eval`. String values could theoretically "
"contain any valid string, and in practice there are valid use cases for type "
"hints that require annotating with string values that specifically *can't* "
"be evaluated.  For example:"
msgstr ""
"Det är dock inte alla strängvärden som används som annotationer som "
"framgångsrikt kan omvandlas till Python-värden med :func:`eval`. "
"Strängvärden kan teoretiskt sett innehålla vilken giltig sträng som helst, "
"och i praktiken finns det giltiga användningsfall för typtips som kräver "
"annotering med strängvärden som specifikt *inte* kan utvärderas.  Ett "
"exempel:"

msgid ""
":pep:`604` union types using ``|``, before support for this was added to "
"Python 3.10."
msgstr ""
":pep:`604` unionstyper som använder ``|``, innan stöd för detta lades till i "
"Python 3.10."

msgid ""
"Definitions that aren't needed at runtime, only imported when :const:`typing."
"TYPE_CHECKING` is true."
msgstr ""
"Definitioner som inte behövs vid körning, importeras endast när :const:"
"`typing.TYPE_CHECKING` är true."

msgid ""
"If :func:`eval` attempts to evaluate such values, it will fail and raise an "
"exception.  So, when designing a library API that works with annotations, "
"it's recommended to only attempt to evaluate string values when explicitly "
"requested to by the caller."
msgstr ""
"Om :func:`eval` försöker utvärdera sådana värden kommer det att misslyckas "
"och ge upphov till ett undantag.  Så när du utformar ett biblioteks-API som "
"arbetar med annotationer rekommenderas att du bara försöker utvärdera "
"strängvärden när det uttryckligen begärs av den som anropar."

msgid "Best Practices For ``__annotations__`` In Any Python Version"
msgstr "Bästa praxis för ``__annotationer__`` i alla Python-versioner"

msgid ""
"You should avoid assigning to the ``__annotations__`` member of objects "
"directly.  Let Python manage setting ``__annotations__``."
msgstr ""
"Du bör undvika att tilldela ``__annotations__``-medlemmen i objekt direkt.  "
"Låt Python sköta inställningen av ``__annotations__``."

msgid ""
"If you do assign directly to the ``__annotations__`` member of an object, "
"you should always set it to a ``dict`` object."
msgstr ""
"Om du tilldelar direkt till ``__annotations__``-medlemmen i ett objekt, bör "
"du alltid sätta den till ett ``dict``-objekt."

msgid ""
"You should avoid accessing ``__annotations__`` directly on any object. "
"Instead, use :func:`annotationlib.get_annotations` (Python 3.14+) or :func:"
"`inspect.get_annotations` (Python 3.10+)."
msgstr ""
"Du bör undvika att komma åt ``__annotations__`` direkt på något objekt. "
"Använd istället :func:`annotationlib.get_annotations` (Python 3.14+) eller :"
"func:`inspect.get_annotations` (Python 3.10+)."

msgid ""
"If you do directly access the ``__annotations__`` member of an object, you "
"should ensure that it's a dictionary before attempting to examine its "
"contents."
msgstr ""
"Om du har direktåtkomst till medlemmen ``__annotations__`` i ett objekt bör "
"du kontrollera att det är en ordbok innan du försöker undersöka innehållet."

msgid "You should avoid modifying ``__annotations__`` dicts."
msgstr "Du bör undvika att modifiera ``__annotations__`` dicts."

msgid ""
"You should avoid deleting the ``__annotations__`` attribute of an object."
msgstr ""
"Du bör undvika att ta bort attributet ``__annotations__`` för ett objekt."

msgid "``__annotations__`` Quirks"
msgstr "``__annotations__`` Märkligheter"

msgid ""
"In all versions of Python 3, function objects lazy-create an annotations "
"dict if no annotations are defined on that object.  You can delete the "
"``__annotations__`` attribute using ``del fn.__annotations__``, but if you "
"then access ``fn.__annotations__`` the object will create a new empty dict "
"that it will store and return as its annotations.  Deleting the annotations "
"on a function before it has lazily created its annotations dict will throw "
"an ``AttributeError``; using ``del fn.__annotations__`` twice in a row is "
"guaranteed to always throw an ``AttributeError``."
msgstr ""
"I alla versioner av Python 3 skapar funktionsobjekt latent en "
"annotationsdikt om inga annotationer är definierade på objektet.  Du kan ta "
"bort attributet ``__annotations__`` med ``del fn.__annotations__``, men om "
"du sedan använder ``fn.__annotations__`` kommer objektet att skapa en ny tom "
"dict som den kommer att lagra och returnera som sina annotationer.  Om du "
"tar bort anteckningarna på en funktion innan den har skapat sin diktat med "
"anteckningar kommer du att få ett ``AttributeError``; om du använder ``del "
"fn.__annotations__`` två gånger i rad kommer du garanterat alltid att få ett "
"``AttributeError``."

msgid ""
"Everything in the above paragraph also applies to class and module objects "
"in Python 3.10 and newer."
msgstr ""
"Allt i ovanstående stycke gäller även för klass- och modulobjekt i Python "
"3.10 och senare."

msgid ""
"In all versions of Python 3, you can set ``__annotations__`` on a function "
"object to ``None``.  However, subsequently accessing the annotations on that "
"object using ``fn.__annotations__`` will lazy-create an empty dictionary as "
"per the first paragraph of this section.  This is *not* true of modules and "
"classes, in any Python version; those objects permit setting "
"``__annotations__`` to any Python value, and will retain whatever value is "
"set."
msgstr ""
"I alla versioner av Python 3 kan du ställa in ``__annotations__`` på ett "
"funktionsobjekt till ``None``.  Men om du sedan kommer åt anteckningarna på "
"det objektet med hjälp av ``fn.__annotations__`` kommer en tom ordbok att "
"skapas enligt första stycket i detta avsnitt.  Detta är *inte* sant för "
"moduler och klasser, i någon Python-version; dessa objekt tillåter "
"inställning av ``__annotations__`` till något Python-värde, och kommer att "
"behålla det värde som är inställt."

msgid ""
"If Python stringizes your annotations for you (using ``from __future__ "
"import annotations``), and you specify a string as an annotation, the string "
"will itself be quoted.  In effect the annotation is quoted *twice.*  For "
"example::"
msgstr ""
"Om Python strängar dina annotationer åt dig (med hjälp av ``from __future__ "
"import annotations``), och du anger en sträng som en annotation, kommer "
"strängen själv att citeras.  I själva verket citeras annotationen *två "
"gånger.* Till exempel::"

msgid ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"
msgstr ""
"from __future__ import annotations\n"
"def foo(a: \"str\"): pass\n"
"\n"
"print(foo.__annotations__)"

msgid ""
"This prints ``{'a': \"'str'\"}``.  This shouldn't really be considered a "
"\"quirk\"; it's mentioned here simply because it might be surprising."
msgstr ""
"Detta skriver ut ``{'a': \"'str'\"}``.  Detta bör egentligen inte betraktas "
"som en \"finurlighet\"; det nämns här helt enkelt för att det kan vara "
"överraskande."

msgid ""
"If you use a class with a custom metaclass and access ``__annotations__`` on "
"the class, you may observe unexpected behavior; see :pep:`749 <749#pep749-"
"metaclasses>` for some examples. You can avoid these quirks by using :func:"
"`annotationlib.get_annotations` on Python 3.14+ or :func:`inspect."
"get_annotations` on Python 3.10+. On earlier versions of Python, you can "
"avoid these bugs by accessing the annotations from the class's :attr:`~type."
"__dict__` (for example, ``cls.__dict__.get('__annotations__', None)``)."
msgstr ""
"Om du använder en klass med en anpassad metaklass och kommer åt "
"``__annotations__`` på klassen, kan du observera oväntat beteende; se :pep:"
"`749 <749#pep749-metaklasser>` för några exempel. Du kan undvika dessa "
"konstigheter genom att använda :func:`annotationlib.get_annotations` på "
"Python 3.14+ eller :func:`inspect.get_annotations` på Python 3.10+. På "
"tidigare versioner av Python kan du undvika dessa buggar genom att komma åt "
"anteckningarna från klassens :attr:`~type.__dict__` (till exempel ``cls."
"__dict__.get('__annotations__', None)``)."

msgid ""
"In some versions of Python, instances of classes may have an "
"``__annotations__`` attribute. However, this is not supported functionality. "
"If you need the annotations of an instance, you can use :func:`type` to "
"access its class (for example, ``annotationlib."
"get_annotations(type(myinstance))`` on Python 3.14+)."
msgstr ""
"I vissa versioner av Python kan instanser av klasser ha attributet "
"``__annotations__``. Detta är dock inte en funktionalitet som stöds. Om du "
"behöver anteckningarna för en instans kan du använda :func:`type` för att "
"komma åt dess klass (till exempel ``annotationlib."
"get_annotations(type(myinstance))`` på Python 3.14+)."
