# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!urllib.request` --- Extensible library for opening URLs"
msgstr ":mod:`!urllib.request` --- Utökat bibliotek för att öppna webbadresser"

msgid "**Source code:** :source:`Lib/urllib/request.py`"
msgstr "**Källkod:** :source:`Lib/urllib/request.py`"

msgid ""
"The :mod:`urllib.request` module defines functions and classes which help in "
"opening URLs (mostly HTTP) in a complex world --- basic and digest "
"authentication, redirections, cookies and more."
msgstr ""
"Modulen :mod:`urllib.request` definierar funktioner och klasser som hjälper "
"till att öppna webbadresser (oftast HTTP) i en komplex värld --- "
"grundläggande och samlad autentisering, omdirigeringar, cookies och mer."

msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"Paketet `Requests <https://requests.readthedocs.io/en/master/>`_ "
"rekommenderas för ett HTTP-klientgränssnitt på högre nivå."

msgid ""
"On macOS it is unsafe to use this module in programs using :func:`os.fork` "
"because the :func:`getproxies` implementation for macOS uses a higher-level "
"system API. Set the environment variable ``no_proxy`` to ``*`` to avoid this "
"problem (e.g. ``os.environ[\"no_proxy\"] = \"*\"``)."
msgstr ""
"På macOS är det inte säkert att använda denna modul i program som använder :"
"func:`os.fork` eftersom :func:`getproxies`-implementeringen för macOS "
"använder ett system-API på högre nivå. Ställ in miljövariabeln ``no_proxy`` "
"till ``*`` för att undvika detta problem (t.ex. ``os.environ[\"no_proxy\"] = "
"\"*\"``)."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid "The :mod:`urllib.request` module defines the following functions:"
msgstr "Modulen :mod:`urllib.request` definierar följande funktioner:"

msgid ""
"Open *url*, which can be either a string containing a valid, properly "
"encoded URL, or a :class:`Request` object."
msgstr ""
"Öppna *url*, som kan vara antingen en sträng som innehåller en giltig, "
"korrekt kodad URL eller ett :class:`Request`-objekt."

msgid ""
"*data* must be an object specifying additional data to be sent to the "
"server, or ``None`` if no such data is needed.  See :class:`Request` for "
"details."
msgstr ""
"*data* måste vara ett objekt som anger ytterligare data som ska skickas till "
"servern, eller ``None`` om inga sådana data behövs.  Se :class:`Request` för "
"detaljer."

msgid ""
"urllib.request module uses HTTP/1.1 and includes ``Connection:close`` header "
"in its HTTP requests."
msgstr ""
"urllib.request-modulen använder HTTP/1.1 och inkluderar rubriken "
"``Connection:close`` i sina HTTP-förfrågningar."

msgid ""
"The optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used).  This actually only works for HTTP, HTTPS and "
"FTP connections."
msgstr ""
"Den valfria parametern *timeout* anger en timeout i sekunder för blockering "
"av åtgärder som anslutningsförsöket (om den inte anges kommer den globala "
"standardinställningen för timeout att användas).  Detta fungerar faktiskt "
"bara för HTTP-, HTTPS- och FTP-anslutningar."

msgid ""
"If *context* is specified, it must be a :class:`ssl.SSLContext` instance "
"describing the various SSL options. See :class:`~http.client."
"HTTPSConnection` for more details."
msgstr ""
"Om *context* anges måste det vara en :class:`ssl.SSLContext`-instans som "
"beskriver de olika SSL-alternativen. Se :class:`~http.client."
"HTTPSConnection` för mer information."

msgid ""
"This function always returns an object which can work as a :term:`context "
"manager` and has the properties *url*, *headers*, and *status*. See :class:"
"`urllib.response.addinfourl` for more detail on these properties."
msgstr ""
"Denna funktion returnerar alltid ett objekt som kan fungera som en :term:"
"`context manager` och som har egenskaperna *url*, *headers* och *status*. "
"Se :class:`urllib.response.addinfourl` för mer information om dessa "
"egenskaper."

msgid ""
"For HTTP and HTTPS URLs, this function returns a :class:`http.client."
"HTTPResponse` object slightly modified. In addition to the three new methods "
"above, the msg attribute contains the same information as the :attr:`~http."
"client.HTTPResponse.reason` attribute --- the reason phrase returned by "
"server --- instead of the response headers as it is specified in the "
"documentation for :class:`~http.client.HTTPResponse`."
msgstr ""
"För HTTP- och HTTPS-URL:er returnerar denna funktion ett :class:`http.client."
"HTTPResponse`-objekt något modifierat. Förutom de tre nya metoderna ovan "
"innehåller msg-attributet samma information som :attr:`~http.client."
"HTTPResponse.reason`-attributet --- den reason-fras som returneras av "
"servern --- istället för svarshuvudena som det specificeras i "
"dokumentationen för :class:`~http.client.HTTPResponse`."

msgid ""
"For FTP, file, and data URLs, this function returns a :class:`urllib."
"response.addinfourl` object."
msgstr ""
"För FTP-, fil- och data-URL:er returnerar denna funktion ett :class:`urllib."
"response.addinfourl`-objekt."

msgid "Raises :exc:`~urllib.error.URLError` on protocol errors."
msgstr "Utlöser :exc:`~urllib.error.URLError` vid protokollfel."

msgid ""
"Note that ``None`` may be returned if no handler handles the request (though "
"the default installed global :class:`OpenerDirector` uses :class:"
"`UnknownHandler` to ensure this never happens)."
msgstr ""
"Observera att ``None`` kan returneras om ingen hanterare hanterar begäran "
"(även om den standardinstallerade globala :class:`OpenerDirector` använder :"
"class:`UnknownHandler` för att säkerställa att detta aldrig händer)."

msgid ""
"In addition, if proxy settings are detected (for example, when a ``*_proxy`` "
"environment variable like :envvar:`!http_proxy` is set), :class:"
"`ProxyHandler` is default installed and makes sure the requests are handled "
"through the proxy."
msgstr ""
"Om proxyinställningar upptäcks (t.ex. när en miljövariabel ``*_proxy`` som :"
"envvar:`!http_proxy`` är inställd) installeras dessutom :class:"
"`ProxyHandler` som standard och ser till att förfrågningarna hanteras via "
"proxyn."

msgid ""
"The legacy ``urllib.urlopen`` function from Python 2.6 and earlier has been "
"discontinued; :func:`urllib.request.urlopen` corresponds to the old "
"``urllib2.urlopen``.  Proxy handling, which was done by passing a dictionary "
"parameter to ``urllib.urlopen``, can be obtained by using :class:"
"`ProxyHandler` objects."
msgstr ""
"Den äldre funktionen ``urllib.urlopen`` från Python 2.6 och tidigare har "
"utgått; :func:`urllib.request.urlopen`` motsvarar den gamla ``urllib2."
"urlopen``.  Proxyhantering, som gjordes genom att skicka en dictionary-"
"parameter till ``urllib.urlopen``, kan erhållas genom att använda :class:"
"`ProxyHandler`-objekt."

msgid ""
"The default opener raises an :ref:`auditing event <auditing>` ``urllib."
"Request`` with arguments ``fullurl``, ``data``, ``headers``, ``method`` "
"taken from the request object."
msgstr ""
"Standardöppnaren utlöser en :ref:`auditing event <auditing>``urllib."
"Request`` med argumenten ``fullurl``, ``data``, ``headers``, ``method`` "
"hämtade från request-objektet."

msgid "*cafile* and *capath* were added."
msgstr "*cafile* och *capath* har lagts till."

msgid ""
"HTTPS virtual hosts are now supported if possible (that is, if :const:`ssl."
"HAS_SNI` is true)."
msgstr ""
"Virtuella HTTPS-värdar stöds nu om det är möjligt (dvs. om :const:`ssl."
"HAS_SNI` är true)."

msgid "*data* can be an iterable object."
msgstr "*data* kan vara ett itererbart objekt."

msgid "*cadefault* was added."
msgstr "*cadefault* lades till."

msgid "*context* was added."
msgstr "*sammanhang* lades till."

msgid ""
"HTTPS connection now send an ALPN extension with protocol indicator "
"``http/1.1`` when no *context* is given. Custom *context* should set ALPN "
"protocols with :meth:`~ssl.SSLContext.set_alpn_protocols`."
msgstr ""
"HTTPS-anslutning skickar nu ett ALPN-tillägg med protokollindikatorn "
"``http/1.1`` när ingen *kontext* anges. Anpassad *kontext* bör ställa in "
"ALPN-protokoll med :meth:`~ssl.SSLContext.set_alpn_protocols`."

msgid ""
"Remove *cafile*, *capath* and *cadefault* parameters: use the *context* "
"parameter instead."
msgstr ""
"Ta bort parametrarna *cafile*, *capath* och *cadefault*: använd parametern "
"*context* i stället."

msgid ""
"Install an :class:`OpenerDirector` instance as the default global opener. "
"Installing an opener is only necessary if you want urlopen to use that "
"opener; otherwise, simply call :meth:`OpenerDirector.open` instead of :func:"
"`~urllib.request.urlopen`.  The code does not check for a real :class:"
"`OpenerDirector`, and any class with the appropriate interface will work."
msgstr ""
"Installera en instans av :class:`OpenerDirector` som global standardöppnare. "
"Att installera en öppnare är bara nödvändigt om du vill att urlopen ska "
"använda den öppnaren; annars anropar du helt enkelt :meth:`OpenerDirector."
"open` istället för :func:`~urllib.request.urlopen`.  Koden kontrollerar inte "
"om det finns en riktig :class:`OpenerDirector`, och vilken klass som helst "
"med lämpligt gränssnitt kommer att fungera."

msgid ""
"Return an :class:`OpenerDirector` instance, which chains the handlers in the "
"order given. *handler*\\s can be either instances of :class:`BaseHandler`, "
"or subclasses of :class:`BaseHandler` (in which case it must be possible to "
"call the constructor without any parameters).  Instances of the following "
"classes will be in front of the *handler*\\s, unless the *handler*\\s "
"contain them, instances of them or subclasses of them: :class:`ProxyHandler` "
"(if proxy settings are detected), :class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."
msgstr ""
"Returnerar en :class:`OpenerDirector`-instans, som kedjar handlers i den "
"ordning som anges. *handler*\\s kan vara antingen instanser av :class:"
"`BaseHandler`, eller subklasser av :class:`BaseHandler` (i vilket fall det "
"måste vara möjligt att anropa konstruktören utan några parametrar).  "
"Instanser av följande klasser kommer att stå framför *handler*\\s, såvida "
"inte *handler*\\s innehåller dem, instanser av dem eller subklasser av dem: :"
"class:`ProxyHandler` (om proxyinställningar upptäcks), :class:"
"`UnknownHandler`, :class:`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :"
"class:`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :"
"class:`HTTPErrorProcessor`."

msgid ""
"If the Python installation has SSL support (i.e., if the :mod:`ssl` module "
"can be imported), :class:`HTTPSHandler` will also be added."
msgstr ""
"Om Python-installationen har SSL-stöd (dvs. om modulen :mod:`ssl` kan "
"importeras) kommer även :class:`HTTPSHandler` att läggas till."

msgid ""
"A :class:`BaseHandler` subclass may also change its :attr:`handler_order` "
"attribute to modify its position in the handlers list."
msgstr ""
"En :class:`BaseHandler` subklass kan också ändra sitt :attr:`handler_order` "
"attribut för att ändra sin position i listan över handlers."

msgid ""
"Convert the given local path to a ``file:`` URL. This function uses :func:"
"`~urllib.parse.quote` function to encode the path."
msgstr ""
"Konverterar den angivna lokala sökvägen till en ``file:`` URL. Denna "
"funktion använder :func:`~urllib.parse.quote`-funktionen för att koda "
"sökvägen."

msgid ""
"If *add_scheme* is false (the default), the return value omits the ``file:`` "
"scheme prefix. Set *add_scheme* to true to return a complete URL."
msgstr ""
"Om *add_scheme* är false (standard) utelämnas prefixet ``file:`` för schemat "
"i returvärdet. Sätt *add_scheme* till true för att returnera en komplett URL."

msgid "This example shows the function being used on Windows::"
msgstr "Detta exempel visar hur funktionen används i Windows::"

msgid ""
">>> from urllib.request import pathname2url\n"
">>> path = 'C:\\\\Program Files'\n"
">>> pathname2url(path, add_scheme=True)\n"
"'file:///C:/Program%20Files'"
msgstr ""
">>> from urllib.request import pathname2url\n"
">>> path = 'C:\\\\Program Files'\n"
">>> pathname2url(path, add_scheme=True)\n"
"'file:///C:/Program%20Files'"

msgid ""
"Windows drive letters are no longer converted to uppercase, and ``:`` "
"characters not following a drive letter no longer cause an :exc:`OSError` "
"exception to be raised on Windows."
msgstr ""
"Windows-enhetsbokstäver konverteras inte längre till versaler, och ``:``-"
"tecken som inte följer efter en enhetsbokstav orsakar inte längre ett :exc:"
"`OSError`-undantag i Windows."

msgid ""
"Paths beginning with a slash are converted to URLs with authority sections. "
"For example, the path ``/etc/hosts`` is converted to the URL ``///etc/"
"hosts``."
msgstr ""
"Sökvägar som börjar med ett snedstreck konverteras till webbadresser med "
"auktoritetsavsnitt. Till exempel konverteras sökvägen ``/etc/hosts`` till "
"URL:en ``///etc/hosts``."

msgid "The *add_scheme* parameter was added."
msgstr "Parametern *add_scheme* har lagts till."

msgid ""
"Convert the given ``file:`` URL to a local path. This function uses :func:"
"`~urllib.parse.unquote` to decode the URL."
msgstr ""
"Konverterar den angivna ``file:`` URL:en till en lokal sökväg. Denna "
"funktion använder :func:`~urllib.parse.unquote` för att avkoda URL:en."

msgid ""
"If *require_scheme* is false (the default), the given value should omit a "
"``file:`` scheme prefix. If *require_scheme* is set to true, the given value "
"should include the prefix; a :exc:`~urllib.error.URLError` is raised if it "
"doesn't."
msgstr ""
"Om *require_scheme* är false (standard) ska det angivna värdet utelämna ett "
"prefix för ``file:``-schema. Om *require_scheme* är satt till true, bör det "
"angivna värdet innehålla prefixet; ett :exc:`~urllib.error.URLError` uppstår "
"om det inte gör det."

msgid ""
"The URL authority is discarded if it is empty, ``localhost``, or the local "
"hostname. Otherwise, if *resolve_host* is set to true, the authority is "
"resolved using :func:`socket.gethostbyname` and discarded if it matches a "
"local IP address (as per :rfc:`RFC 8089 §3 <8089#section-3>`). If the "
"authority is still unhandled, then on Windows a UNC path is returned, and on "
"other platforms a :exc:`~urllib.error.URLError` is raised."
msgstr ""
"URL-auktoriteten kasseras om den är tom, ``localhost`` eller det lokala "
"värdnamnet. I annat fall, om *resolve_host* är satt till true, löses "
"auktoriteten upp med :func:`socket.gethostbyname` och kasseras om den "
"matchar en lokal IP-adress (enligt :rfc:`RFC 8089 §3 <8089#section-3>`). Om "
"behörigheten fortfarande inte kan hanteras returneras en UNC-sökväg på "
"Windows och ett :exc:`~urllib.error.URLError` på andra plattformar."

msgid ""
">>> from urllib.request import url2pathname\n"
">>> url = 'file:///C:/Program%20Files'\n"
">>> url2pathname(url, require_scheme=True)\n"
"'C:\\\\Program Files'"
msgstr ""
">>> från urllib.request import url2pathname\n"
">>> url = 'file:///C:/Program%20Files'\n"
">>> url2pathname(url, require_scheme=True)\n"
"'C:\\\\Programfiler'"

msgid ""
"The URL authority is discarded if it matches the local hostname. Otherwise, "
"if the authority isn't empty or ``localhost``, then on Windows a UNC path is "
"returned (as before), and on other platforms a :exc:`~urllib.error.URLError` "
"is raised."
msgstr ""
"URL-auktoriteten kasseras om den matchar det lokala värdnamnet. I annat "
"fall, om auktoriteten inte är tom eller ``localhost``, returneras en UNC-"
"sökväg på Windows (som tidigare) och på andra plattformar genereras ett :exc:"
"`~urllib.error.URLError`."

msgid "The URL query and fragment components are discarded if present."
msgstr "URL-frågan och fragmentkomponenterna kasseras om de finns med."

msgid "The *require_scheme* and *resolve_host* parameters were added."
msgstr "Parametrarna *require_scheme* och *resolve_host* har lagts till."

msgid ""
"This helper function returns a dictionary of scheme to proxy server URL "
"mappings. It scans the environment for variables named ``<scheme>_proxy``, "
"in a case insensitive approach, for all operating systems first, and when it "
"cannot find it, looks for proxy information from System Configuration for "
"macOS and Windows Systems Registry for Windows. If both lowercase and "
"uppercase environment variables exist (and disagree), lowercase is preferred."
msgstr ""
"Denna hjälpfunktion returnerar en ordbok med URL-mappningar mellan schema "
"och proxyserver. Den söker i miljön efter variabler med namnet "
"``<scheme>_proxy``, utan hänsyn till versaler, för alla operativsystem "
"först, och när den inte hittar den söker den efter proxyinformation från "
"System Configuration för macOS och Windows Systems Registry för Windows. Om "
"det finns miljövariabler med både små och stora bokstäver (och de inte är "
"överens) föredras små bokstäver."

msgid ""
"If the environment variable ``REQUEST_METHOD`` is set, which usually "
"indicates your script is running in a CGI environment, the environment "
"variable ``HTTP_PROXY`` (uppercase ``_PROXY``) will be ignored. This is "
"because that variable can be injected by a client using the \"Proxy:\" HTTP "
"header. If you need to use an HTTP proxy in a CGI environment, either use "
"``ProxyHandler`` explicitly, or make sure the variable name is in lowercase "
"(or at least the ``_proxy`` suffix)."
msgstr ""
"Om miljövariabeln ``REQUEST_METHOD`` är inställd, vilket vanligtvis "
"indikerar att ditt skript körs i en CGI-miljö, kommer miljövariabeln "
"``HTTP_PROXY`` (versaler ``_PROXY``) att ignoreras. Detta beror på att den "
"variabeln kan injiceras av en klient med hjälp av HTTP-rubriken \"Proxy:\". "
"Om du behöver använda en HTTP-proxy i en CGI-miljö, använd antingen "
"``ProxyHandler`` explicit, eller se till att variabelnamnet är i gemener "
"(eller åtminstone suffixet ``_proxy``)."

msgid "The following classes are provided:"
msgstr "Följande klasser erbjuds:"

msgid "This class is an abstraction of a URL request."
msgstr "Denna klass är en abstraktion av en URL-begäran."

msgid "*url* should be a string containing a valid, properly encoded URL."
msgstr "*url* ska vara en sträng som innehåller en giltig, korrekt kodad URL."

msgid ""
"*data* must be an object specifying additional data to send to the server, "
"or ``None`` if no such data is needed.  Currently HTTP requests are the only "
"ones that use *data*.  The supported object types include bytes, file-like "
"objects, and iterables of bytes-like objects. If no ``Content-Length`` nor "
"``Transfer-Encoding`` header field has been provided, :class:`HTTPHandler` "
"will set these headers according to the type of *data*.  ``Content-Length`` "
"will be used to send bytes objects, while ``Transfer-Encoding: chunked`` as "
"specified in :rfc:`7230`, Section 3.3.1 will be used to send files and other "
"iterables."
msgstr ""
"*data* måste vara ett objekt som anger ytterligare data som ska skickas till "
"servern, eller ``None`` om inga sådana data behövs.  För närvarande är HTTP-"
"förfrågningar de enda som använder *data*.  De objekttyper som stöds är "
"bytes, filliknande objekt och iterabler av bytesliknande objekt. Om inget "
"``Content-Length`` eller ``Transfer-Encoding`` rubrikfält har "
"tillhandahållits, kommer :class:`HTTPHandler`` att ställa in dessa rubriker "
"enligt typen av *data*.  ``Content-Length`` kommer att användas för att "
"skicka bytesobjekt, medan ``Transfer-Encoding: chunked`` enligt "
"specifikationen i :rfc:`7230`, avsnitt 3.3.1 kommer att användas för att "
"skicka filer och andra iterabler."

msgid ""
"For an HTTP POST request method, *data* should be a buffer in the standard :"
"mimetype:`application/x-www-form-urlencoded` format.  The :func:`urllib."
"parse.urlencode` function takes a mapping or sequence of 2-tuples and "
"returns an ASCII string in this format. It should be encoded to bytes before "
"being used as the *data* parameter."
msgstr ""
"För en HTTP POST-begäran bör *data* vara en buffert i standardformatet :"
"mimetype:`application/x-www-form-urlencoded`.  Funktionen :func:`urllib."
"parse.urlencode` tar en mappning eller en sekvens av 2-tupler och returnerar "
"en ASCII-sträng i detta format. Den bör kodas till bytes innan den används "
"som *data*-parameter."

msgid ""
"*headers* should be a dictionary, and will be treated as if :meth:"
"`add_header` was called with each key and value as arguments. This is often "
"used to \"spoof\" the ``User-Agent`` header value, which is used by a "
"browser to identify itself -- some HTTP servers only allow requests coming "
"from common browsers as opposed to scripts. For example, Mozilla Firefox may "
"identify itself as ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``, while :mod:`urllib`'s default user agent string is "
"``\"Python-urllib/2.6\"`` (on Python 2.6). All header keys are sent in camel "
"case."
msgstr ""
"*headers* bör vara en ordbok och kommer att behandlas som om :meth:"
"`add_header` hade anropats med varje nyckel och värde som argument. Detta "
"används ofta för att \"förfalska\" ``User-Agent``-headervärdet, som används "
"av en webbläsare för att identifiera sig själv - vissa HTTP-servrar tillåter "
"bara förfrågningar som kommer från vanliga webbläsare i motsats till skript. "
"Till exempel kan Mozilla Firefox identifiera sig som ``\"Mozilla/5.0 (X11; "
"U; Linux i686) Gecko/20071127 Firefox/2.0.0.11\"``, medan :mod:`urllib`:s "
"standardiserade användaragentsträng är ``\"Python-urllib/2.6\"`` (på Python "
"2.6). Alla rubriknycklar skickas i kamelbokstäver."

msgid ""
"An appropriate ``Content-Type`` header should be included if the *data* "
"argument is present.  If this header has not been provided and *data* is not "
"``None``, ``Content-Type: application/x-www-form-urlencoded`` will be added "
"as a default."
msgstr ""
"Ett lämpligt ``Content-Type``-huvud bör inkluderas om *data*-argumentet "
"finns.  Om detta huvud inte har angetts och *data* inte är ``None``, kommer "
"``Content-Type: application/x-www-form-urlencoded`` att läggas till som "
"standard."

msgid ""
"The next two arguments are only of interest for correct handling of third-"
"party HTTP cookies:"
msgstr ""
"De två följande argumenten är endast av intresse för korrekt hantering av "
"HTTP-cookies från tredje part:"

msgid ""
"*origin_req_host* should be the request-host of the origin transaction, as "
"defined by :rfc:`2965`.  It defaults to ``http.cookiejar."
"request_host(self)``.  This is the host name or IP address of the original "
"request that was initiated by the user. For example, if the request is for "
"an image in an HTML document, this should be the request-host of the request "
"for the page containing the image."
msgstr ""
"*origin_req_host* bör vara request-host för ursprungstransaktionen, enligt "
"definitionen i :rfc:`2965`.  Standardvärdet är ``http.cookiejar."
"request_host(self)``.  Detta är värdnamnet eller IP-adressen för den "
"ursprungliga begäran som initierades av användaren. Om begäran t.ex. gäller "
"en bild i ett HTML-dokument bör detta vara request-host för begäran om den "
"sida som innehåller bilden."

msgid ""
"*unverifiable* should indicate whether the request is unverifiable, as "
"defined by :rfc:`2965`.  It defaults to ``False``.  An unverifiable request "
"is one whose URL the user did not have the option to approve.  For example, "
"if the request is for an image in an HTML document, and the user had no "
"option to approve the automatic fetching of the image, this should be true."
msgstr ""
"*unverifiable* bör ange om begäran är overifierbar, enligt definitionen i :"
"rfc:`2965`.  Standardvärdet är ``False``.  En begäran som inte kan "
"verifieras är en begäran vars URL användaren inte hade möjlighet att "
"godkänna.  Om begäran t.ex. gäller en bild i ett HTML-dokument och "
"användaren inte hade någon möjlighet att godkänna automatisk hämtning av "
"bilden, bör detta vara sant."

msgid ""
"*method* should be a string that indicates the HTTP request method that will "
"be used (e.g. ``'HEAD'``).  If provided, its value is stored in the :attr:"
"`~Request.method` attribute and is used by :meth:`get_method`. The default "
"is ``'GET'`` if *data* is ``None`` or ``'POST'`` otherwise. Subclasses may "
"indicate a different default method by setting the :attr:`~Request.method` "
"attribute in the class itself."
msgstr ""
"*method* bör vara en sträng som anger vilken HTTP-förfrågningsmetod som ska "
"användas (t.ex. ``'HEAD'``).  Om den tillhandahålls lagras dess värde i "
"attributet :attr:`~Request.method` och används av :meth:`get_method`. "
"Standardvärdet är ``'GET'`` om *data* är ``None`` eller ``'POST'`` annars. "
"Subklasser kan ange en annan standardmetod genom att ställa in attributet :"
"attr:`~Request.method` i själva klassen."

msgid ""
"The request will not work as expected if the data object is unable to "
"deliver its content more than once (e.g. a file or an iterable that can "
"produce the content only once) and the request is retried for HTTP redirects "
"or authentication.  The *data* is sent to the HTTP server right away after "
"the headers.  There is no support for a 100-continue expectation in the "
"library."
msgstr ""
"Begäran kommer inte att fungera som förväntat om dataobjektet inte kan "
"leverera sitt innehåll mer än en gång (t.ex. en fil eller en iterabel som "
"bara kan producera innehållet en gång) och begäran omprövas för HTTP-"
"omdirigeringar eller autentisering.  *Data* skickas till HTTP-servern direkt "
"efter rubrikerna.  Det finns inget stöd för en 100-continue-förväntan i "
"biblioteket."

msgid ":attr:`Request.method` argument is added to the Request class."
msgstr ":attr:`Request.method`-argumentet läggs till i Request-klassen."

msgid "Default :attr:`Request.method` may be indicated at the class level."
msgstr "Standard :attr:`Request.method` kan anges på klassnivå."

msgid ""
"Do not raise an error if the ``Content-Length`` has not been provided and "
"*data* is neither ``None`` nor a bytes object. Fall back to use chunked "
"transfer encoding instead."
msgstr ""
"Ge inte felmeddelanden om ``Content-Length`` inte har angetts och *data* "
"varken är ``None`` eller ett bytes-objekt. Fall tillbaka till att använda "
"chunked transfer encoding istället."

msgid ""
"The :class:`OpenerDirector` class opens URLs via :class:`BaseHandler`\\ s "
"chained together. It manages the chaining of handlers, and recovery from "
"errors."
msgstr ""
"Klassen :class:`OpenerDirector` öppnar URL:er via :class:`BaseHandler` som "
"kedjats ihop. Den hanterar kedjandet av handlers och återställning efter fel."

msgid ""
"This is the base class for all registered handlers --- and handles only the "
"simple mechanics of registration."
msgstr ""
"Detta är basklassen för alla registrerade handläggare --- och hanterar "
"endast de enkla mekanikerna för registrering."

msgid ""
"A class which defines a default handler for HTTP error responses; all "
"responses are turned into :exc:`~urllib.error.HTTPError` exceptions."
msgstr ""
"En klass som definierar en standardhanterare för HTTP-felsvar; alla svar "
"förvandlas till :exc:`~urllib.error.HTTPError`-undantag."

msgid "A class to handle redirections."
msgstr "En klass för att hantera omdirigeringar."

msgid "A class to handle HTTP Cookies."
msgstr "En klass för att hantera HTTP-cookies."

msgid ""
"Cause requests to go through a proxy. If *proxies* is given, it must be a "
"dictionary mapping protocol names to URLs of proxies. The default is to read "
"the list of proxies from the environment variables ``<protocol>_proxy``.  If "
"no proxy environment variables are set, then in a Windows environment proxy "
"settings are obtained from the registry's Internet Settings section, and in "
"a macOS environment proxy information is retrieved from the System "
"Configuration Framework."
msgstr ""
"Gör att förfrågningar går via en proxy. Om *proxies* anges måste det vara en "
"ordbok som mappar protokollnamn till webbadresser för proxyer. "
"Standardinställningen är att läsa listan över proxyer från miljövariablerna "
"``<protocol>_proxy``.  Om inga miljövariabler för proxy anges hämtas "
"proxyinställningar i en Windows-miljö från registrets avsnitt "
"Internetinställningar och i en macOS-miljö hämtas proxyinformation från "
"System Configuration Framework."

msgid "To disable autodetected proxy pass an empty dictionary."
msgstr "För att inaktivera autodetekterad proxy skicka en tom ordbok."

msgid ""
"The :envvar:`no_proxy` environment variable can be used to specify hosts "
"which shouldn't be reached via proxy; if set, it should be a comma-separated "
"list of hostname suffixes, optionally with ``:port`` appended, for example "
"``cern.ch,ncsa.uiuc.edu,some.host:8080``."
msgstr ""
"Miljövariabeln :envvar:`no_proxy` kan användas för att ange värdar som inte "
"ska nås via proxy; om den är inställd ska den vara en kommaseparerad lista "
"med värdnamnssuffix, eventuellt med ``:port`` tillagt, till exempel ``cern."
"ch,ncsa.uiuc.edu,some.host:8080``."

msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` ignoreras om en variabel ``REQUEST_METHOD`` är inställd; se "
"dokumentationen för :func:`~urllib.request.getproxies`."

msgid "Keep a database of  ``(realm, uri) -> (user, password)`` mappings."
msgstr ""
"Förvara en databas med ``(realm, uri) -> (user, password)`` mappningar."

msgid ""
"Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A realm "
"of ``None`` is considered a catch-all realm, which is searched if no other "
"realm fits."
msgstr ""
"Förvara en databas med ``(realm, uri) -> (user, password)`` mappningar. En "
"sfär med ``None`` anses vara en catch-all-sfär, som söks om ingen annan sfär "
"passar."

msgid ""
"A variant of :class:`HTTPPasswordMgrWithDefaultRealm` that also has a "
"database of ``uri -> is_authenticated`` mappings.  Can be used by a "
"BasicAuth handler to determine when to send authentication credentials "
"immediately instead of waiting for a ``401`` response first."
msgstr ""
"En variant av :class:`HTTPPasswordMgrWithDefaultRealm` som också har en "
"databas med ``uri -> is_authenticated`` mappningar.  Kan användas av en "
"BasicAuth-hanterare för att avgöra när autentiseringsuppgifter ska skickas "
"omedelbart istället för att vänta på ett ``401``-svar först."

msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be "
"supported.  If *passwd_mgr* also provides ``is_authenticated`` and "
"``update_authenticated`` methods (see :ref:`http-password-mgr-with-prior-"
"auth`), then the handler will use the ``is_authenticated`` result for a "
"given URI to determine whether or not to send authentication credentials "
"with the request.  If ``is_authenticated`` returns ``True`` for the URI, "
"credentials are sent.  If ``is_authenticated`` is ``False``, credentials are "
"not sent, and then if a ``401`` response is received the request is re-sent "
"with the authentication credentials.  If authentication succeeds, "
"``update_authenticated`` is called to set ``is_authenticated`` ``True`` for "
"the URI, so that subsequent requests to the URI or any of its super-URIs "
"will automatically include the authentication credentials."
msgstr ""
"Detta är en mixin-klass som hjälper till med HTTP-autentisering, både till "
"fjärrvärden och till en proxy. *password_mgr*, om den ges, bör vara något "
"som är kompatibelt med :class:`HTTPPasswordMgr`; se avsnitt :ref:`http-"
"password-mgr` för information om gränssnittet som måste stödjas.  Om "
"*passwd_mgr* också tillhandahåller metoderna ``is_authenticated`` och "
"``update_authenticated`` (se :ref:`http-password-mgr-with-prior-auth`), "
"kommer hanteraren att använda resultatet ``is_authenticated`` för en given "
"URI för att avgöra om autentiseringsuppgifter ska skickas med begäran eller "
"inte.  Om ``is_authenticated`` returnerar ``True`` för URI:n skickas "
"autentiseringsuppgifter.  Om ``is_authenticated`` är ``False`` skickas inte "
"autentiseringsuppgifterna och om ett ``401``-svar tas emot skickas begäran "
"på nytt med autentiseringsuppgifterna.  Om autentiseringen lyckas anropas "
"``update_authenticated`` för att sätta ``is_authenticated`` ``True`` för URI:"
"n, så att efterföljande förfrågningar till URI:n eller någon av dess super-"
"URI:er automatiskt kommer att innehålla autentiseringsuppgifterna."

msgid "Added ``is_authenticated`` support."
msgstr "Stöd för ``is_authenticated`` har lagts till."

msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. HTTPBasicAuthHandler will raise a :exc:`ValueError` when "
"presented with a wrong Authentication scheme."
msgstr ""
"Hantera autentisering med fjärrvärden. *password_mgr*, om det anges, bör "
"vara något som är kompatibelt med :class:`HTTPPasswordMgr`; se avsnitt :ref:"
"`http-password-mgr` för information om gränssnittet som måste stödjas. "
"HTTPBasicAuthHandler kommer att ge upphov till ett :exc:`ValueError` när den "
"presenteras med ett felaktigt autentiseringsschema."

msgid ""
"Handle authentication with the proxy. *password_mgr*, if given, should be "
"something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported."
msgstr ""
"Hantera autentisering med proxyn. *password_mgr*, om det anges, bör vara "
"något som är kompatibelt med :class:`HTTPPasswordMgr`; se avsnitt :ref:`http-"
"password-mgr` för information om det gränssnitt som måste stödjas."

msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be supported."
msgstr ""
"Detta är en mixin-klass som hjälper till med HTTP-autentisering, både till "
"fjärrvärden och till en proxy. *password_mgr*, om den anges, bör vara något "
"som är kompatibelt med :class:`HTTPPasswordMgr`; se avsnitt :ref:`http-"
"password-mgr` för information om det gränssnitt som måste stödjas."

msgid "Added support for HTTP digest authentication algorithm ``SHA-256``."
msgstr "Lagt till stöd för HTTP digest-autentiseringsalgoritmen ``SHA-256``."

msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. When both Digest Authentication Handler and Basic "
"Authentication Handler are both added, Digest Authentication is always tried "
"first. If the Digest Authentication returns a 40x response again, it is sent "
"to Basic Authentication handler to Handle.  This Handler method will raise "
"a :exc:`ValueError` when presented with an authentication scheme other than "
"Digest or Basic."
msgstr ""
"Hantera autentisering med fjärrvärden. *password_mgr*, om det anges, bör "
"vara något som är kompatibelt med :class:`HTTPPasswordMgr`; se avsnitt :ref:"
"`http-password-mgr` för information om det gränssnitt som måste stödjas. När "
"både Digest Authentication Handler och Basic Authentication Handler läggs "
"till, prövas alltid Digest Authentication först. Om Digest Authentication "
"returnerar ett 40x-svar igen skickas det till Basic Authentication Handler "
"för att hanteras.  Denna Handler-metod kommer att ge upphov till ett :exc:"
"`ValueError` när den presenteras med ett annat autentiseringsschema än "
"Digest eller Basic."

msgid "Raise :exc:`ValueError` on unsupported Authentication Scheme."
msgstr "Utlös :exc:`ValueError` om autentiseringsschema som inte stöds."

msgid "A class to handle opening of HTTP URLs."
msgstr "En klass för att hantera öppning av HTTP-URL:er."

msgid ""
"A class to handle opening of HTTPS URLs.  *context* and *check_hostname* "
"have the same meaning as in :class:`http.client.HTTPSConnection`."
msgstr ""
"En klass för att hantera öppning av HTTPS-URL:er.  *context* och "
"*check_hostname* har samma betydelse som i :class:`http.client."
"HTTPSConnection`."

msgid "*context* and *check_hostname* were added."
msgstr "*context* och *check_hostname* har lagts till."

msgid "Open local files."
msgstr "Öppna lokala filer."

msgid "Open data URLs."
msgstr "URL:er för öppna data."

msgid "Open FTP URLs."
msgstr "Öppna FTP-URL:er."

msgid ""
"Open FTP URLs, keeping a cache of open FTP connections to minimize delays."
msgstr ""
"Öppna FTP-URL:er och behåll en cache för öppna FTP-anslutningar för att "
"minimera fördröjningar."

msgid "A catch-all class to handle unknown URLs."
msgstr "En catch-all-klass för att hantera okända webbadresser."

msgid "Process HTTP error responses."
msgstr "Behandla HTTP-felsvar."

msgid "Request Objects"
msgstr "Begär objekt"

msgid ""
"The following methods describe :class:`Request`'s public interface, and so "
"all may be overridden in subclasses.  It also defines several public "
"attributes that can be used by clients to inspect the parsed request."
msgstr ""
"Följande metoder beskriver :class:`Request` publika gränssnitt, och alla kan "
"därför åsidosättas i underklasser.  Det definierar också flera publika "
"attribut som kan användas av klienter för att inspektera den analyserade "
"begäran."

msgid "The original URL passed to the constructor."
msgstr "Den ursprungliga URL som skickas till konstruktören."

msgid ""
"Request.full_url is a property with setter, getter and a deleter. Getting :"
"attr:`~Request.full_url` returns the original request URL with the fragment, "
"if it was present."
msgstr ""
"Request.full_url är en egenskap med setter, getter och en deleter. Getting :"
"attr:`~Request.full_url` returnerar den ursprungliga URL:en för begäran med "
"fragmentet, om det fanns."

msgid "The URI scheme."
msgstr "URI-schema."

msgid ""
"The URI authority, typically a host, but may also contain a port separated "
"by a colon."
msgstr ""
"URI-auktoriteten, vanligtvis en host, men kan också innehålla en port "
"åtskild av ett kolon."

msgid "The original host for the request, without port."
msgstr "Den ursprungliga värden för begäran, utan port."

msgid ""
"The URI path.  If the :class:`Request` uses a proxy, then selector will be "
"the full URL that is passed to the proxy."
msgstr ""
"Sökvägen till URI.  Om :class:`Request` använder en proxy, kommer väljaren "
"att vara den fullständiga URL som skickas till proxyn."

msgid "The entity body for the request, or ``None`` if not specified."
msgstr "Entitetskroppen för begäran, eller ``None`` om den inte anges."

msgid ""
"Changing value of :attr:`Request.data` now deletes \"Content-Length\" header "
"if it was previously set or calculated."
msgstr ""
"Ändring av värdet på :attr:`Request.data` raderar nu \"Content-Length\"-"
"rubriken om den tidigare var inställd eller beräknad."

msgid ""
"boolean, indicates whether the request is unverifiable as defined by :rfc:"
"`2965`."
msgstr ""
"boolean, anger om begäran är overifierbar enligt definitionen i :rfc:`2965`."

msgid ""
"The HTTP request method to use.  By default its value is :const:`None`, "
"which means that :meth:`~Request.get_method` will do its normal computation "
"of the method to be used.  Its value can be set (thus overriding the default "
"computation in :meth:`~Request.get_method`) either by providing a default "
"value by setting it at the class level in a :class:`Request` subclass, or by "
"passing a value in to the :class:`Request` constructor via the *method* "
"argument."
msgstr ""
"Den HTTP-förfrågningsmetod som ska användas.  Som standard är dess värde :"
"const:`None`, vilket innebär att :meth:`~Request.get_method` kommer att göra "
"sin normala beräkning av den metod som ska användas.  Dess värde kan ställas "
"in (och därmed åsidosätta standardberäkningen i :meth:`~Request.get_method`) "
"antingen genom att tillhandahålla ett standardvärde genom att ställa in det "
"på klassnivå i en :class:`Request`-underklass, eller genom att skicka ett "
"värde till :class:`Request`-konstruktören via argumentet *method*."

msgid ""
"A default value can now be set in subclasses; previously it could only be "
"set via the constructor argument."
msgstr ""
"Ett standardvärde kan nu anges i underklasser; tidigare kunde det endast "
"anges via konstruktörsargumentet."

msgid ""
"Return a string indicating the HTTP request method.  If :attr:`Request."
"method` is not ``None``, return its value, otherwise return ``'GET'`` if :"
"attr:`Request.data` is ``None``, or ``'POST'`` if it's not. This is only "
"meaningful for HTTP requests."
msgstr ""
"Returnerar en sträng som anger HTTP-förfrågningsmetoden.  Om :attr:`Request."
"method` inte är ``None``, returneras dess värde, annars returneras ``'GET'`` "
"om :attr:`Request.data` är ``None``, eller ``'POST'`` om den inte är det. "
"Detta är endast meningsfullt för HTTP-förfrågningar."

msgid "get_method now looks at the value of :attr:`Request.method`."
msgstr "get_method tittar nu på värdet av :attr:`Request.method`."

msgid ""
"Add another header to the request.  Headers are currently ignored by all "
"handlers except HTTP handlers, where they are added to the list of headers "
"sent to the server.  Note that there cannot be more than one header with the "
"same name, and later calls will overwrite previous calls in case the *key* "
"collides. Currently, this is no loss of HTTP functionality, since all "
"headers which have meaning when used more than once have a (header-specific) "
"way of gaining the same functionality using only one header.  Note that "
"headers added using this method are also added to redirected requests."
msgstr ""
"Lägg till en ny header till begäran.  Headers ignoreras för närvarande av "
"alla hanterare utom HTTP-hanterare, där de läggs till i listan över headers "
"som skickas till servern.  Observera att det inte kan finnas mer än en "
"header med samma namn, och att senare anrop kommer att skriva över tidigare "
"anrop om *nyckeln* kolliderar. För närvarande innebär detta inte någon "
"förlust av HTTP-funktionalitet, eftersom alla headers som har betydelse när "
"de används mer än en gång har ett (header-specifikt) sätt att få samma "
"funktionalitet med endast en header.  Observera att headers som läggs till "
"med den här metoden också läggs till i omdirigerade begäranden."

msgid "Add a header that will not be added to a redirected request."
msgstr "Lägg till ett huvud som inte läggs till i en omdirigerad begäran."

msgid ""
"Return whether the instance has the named header (checks both regular and "
"unredirected)."
msgstr ""
"Returnerar om instansen har den angivna rubriken (kontrollerar både vanlig "
"och oomdirigerad)."

msgid ""
"Remove named header from the request instance (both from regular and "
"unredirected headers)."
msgstr ""
"Ta bort namngiven header från request-instansen (både från vanliga och ej "
"omdirigerade headers)."

msgid "Return the URL given in the constructor."
msgstr "Returnerar den URL som anges i konstruktören."

msgid "Returns :attr:`Request.full_url`"
msgstr "Returnerar :attr:`Request.full_url`"

msgid ""
"Prepare the request by connecting to a proxy server. The *host* and *type* "
"will replace those of the instance, and the instance's selector will be the "
"original URL given in the constructor."
msgstr ""
"Förbered begäran genom att ansluta till en proxyserver. *host* och *type* "
"kommer att ersätta instansens, och instansens väljare kommer att vara den "
"ursprungliga URL som anges i konstruktören."

msgid ""
"Return the value of the given header. If the header is not present, return "
"the default value."
msgstr ""
"Returnerar värdet för den angivna rubriken. Om rubriken inte finns, "
"returneras standardvärdet."

msgid ""
"Return a list of tuples (header_name, header_value) of the Request headers."
msgstr ""
"Returnerar en lista med tupler (header_name, header_value) av Request-"
"rubrikerna."

msgid ""
"The request methods add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host and is_unverifiable that were deprecated "
"since 3.3 have been removed."
msgstr ""
"Förfrågningsmetoderna add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host och is_unverifiable som inte längre "
"används sedan 3.3 har tagits bort."

msgid "OpenerDirector Objects"
msgstr "OpenerDirector-objekt"

msgid ":class:`OpenerDirector` instances have the following methods:"
msgstr ":class:`OpenerDirector`-instanser har följande metoder:"

msgid ""
"*handler* should be an instance of :class:`BaseHandler`.  The following "
"methods are searched, and added to the possible chains (note that HTTP "
"errors are a special case).  Note that, in the following, *protocol* should "
"be replaced with the actual protocol to handle, for example :meth:"
"`http_response` would be the HTTP protocol response handler.  Also *type* "
"should be replaced with the actual HTTP code, for example :meth:"
"`http_error_404` would handle HTTP 404 errors."
msgstr ""
"*handler* bör vara en instans av :class:`BaseHandler`.  Följande metoder "
"söks och läggs till i de möjliga kedjorna (observera att HTTP-fel är ett "
"specialfall).  Observera att i det följande ska *protocol* ersättas med det "
"faktiska protokoll som ska hanteras, t.ex. skulle :meth:`http_response` vara "
"svarshanteraren för HTTP-protokollet.  Även *type* bör ersättas med den "
"faktiska HTTP-koden, t.ex. :meth:`http_error_404` hanterar HTTP 404-fel."

msgid ""
":meth:`!<protocol>_open` --- signal that the handler knows how to open "
"*protocol* URLs."
msgstr ""
":meth:`!<protocol>_open` --- signal att hanteraren vet hur man öppnar "
"*protokoll* URL:er."

msgid "See |protocol_open|_ for more information."
msgstr "Se |protocol_open|_ för mer information."

msgid ""
":meth:`!http_error_\\<type\\>` --- signal that the handler knows how to "
"handle HTTP errors with HTTP error code *type*."
msgstr ""
":meth:`!http_error_\\<type\\>` --- signalerar att hanteraren vet hur man "
"hanterar HTTP-fel med HTTP-felkod *typ*."

msgid "See |http_error_nnn|_ for more information."
msgstr "Se |http_error_nnn|_ för mer information."

msgid ""
":meth:`!<protocol>_error` --- signal that the handler knows how to handle "
"errors from (non-\\ ``http``) *protocol*."
msgstr ""
":meth:`!<protocol>_error` --- signal att hanteraren vet hur man hanterar fel "
"från (icke ``http``) *protokoll*."

msgid ""
":meth:`!<protocol>_request` --- signal that the handler knows how to pre-"
"process *protocol* requests."
msgstr ""
":meth:`!<protocol>_request` --- signalera att hanteraren vet hur man "
"förbehandlar *protokoll* förfrågningar."

msgid "See |protocol_request|_ for more information."
msgstr "Se |protocol_request|_ för mer information."

msgid ""
":meth:`!<protocol>_response` --- signal that the handler knows how to post-"
"process *protocol* responses."
msgstr ""
":meth:`!<protocol>_response` --- signalera att hanteraren vet hur man "
"efterbehandlar *protokoll* svar."

msgid "See |protocol_response|_ for more information."
msgstr "Se |protocol_response|_ för mer information."

msgid ""
"Open the given *url* (which can be a request object or a string), optionally "
"passing the given *data*. Arguments, return values and exceptions raised are "
"the same as those of :func:`urlopen` (which simply calls the :meth:`open` "
"method on the currently installed global :class:`OpenerDirector`).  The "
"optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used). The timeout feature actually works only for "
"HTTP, HTTPS and FTP connections."
msgstr ""
"Öppnar den angivna *url* (som kan vara ett request-objekt eller en sträng), "
"och skickar eventuellt den angivna *data*. Argument, returvärden och "
"undantag är desamma som för :func:`urlopen` (som helt enkelt anropar "
"metoden :meth:`open` på den globala :class:`OpenerDirector` som för "
"närvarande är installerad).  Den valfria parametern *timeout* anger en "
"timeout i sekunder för blockerande operationer som anslutningsförsöket (om "
"den inte anges kommer den globala standardinställningen för timeout att "
"användas). Timeout-funktionen fungerar faktiskt bara för HTTP-, HTTPS- och "
"FTP-anslutningar."

msgid ""
"Handle an error of the given protocol.  This will call the registered error "
"handlers for the given protocol with the given arguments (which are protocol "
"specific).  The HTTP protocol is a special case which uses the HTTP response "
"code to determine the specific error handler; refer to the :meth:`!"
"http_error_\\<type\\>` methods of the handler classes."
msgstr ""
"Hantera ett fel i det angivna protokollet.  Detta kommer att anropa de "
"registrerade felhanterarna för det angivna protokollet med de angivna "
"argumenten (som är protokollspecifika).  HTTP-protokollet är ett specialfall "
"som använder HTTP-svarskoden för att bestämma den specifika felhanteraren; "
"se :meth:`!http_error_\\<type\\>`-metoderna i hanterarklasserna."

msgid ""
"Return values and exceptions raised are the same as those of :func:`urlopen`."
msgstr "Returvärden och undantag är desamma som för :func:`urlopen`."

msgid "OpenerDirector objects open URLs in three stages:"
msgstr "OpenerDirector-objekt öppnar webbadresser i tre steg:"

msgid ""
"The order in which these methods are called within each stage is determined "
"by sorting the handler instances."
msgstr ""
"Den ordning i vilken dessa metoder anropas inom varje steg bestäms genom att "
"sortera hanterarinstanserna."

msgid ""
"Every handler with a method named like :meth:`!<protocol>_request` has that "
"method called to pre-process the request."
msgstr ""
"Varje hanterare med en metod som heter :meth:`!<protocol>_request` har den "
"metoden som anropas för att förbehandla begäran."

msgid ""
"Handlers with a method named like :meth:`!<protocol>_open` are called to "
"handle the request. This stage ends when a handler either returns a non-\\ :"
"const:`None` value (ie. a response), or raises an exception (usually :exc:"
"`~urllib.error.URLError`).  Exceptions are allowed to propagate."
msgstr ""
"Hanterare med en metod som heter :meth:`!<protocol>_open` anropas för att "
"hantera begäran. Detta steg avslutas när en hanterare antingen returnerar "
"ett icke-värde :const:`None` (dvs. ett svar), eller ger upphov till ett "
"undantag (vanligtvis :exc:`~urllib.error.URLError`).  Undantag tillåts att "
"spridas."

msgid ""
"In fact, the above algorithm is first tried for methods named :meth:"
"`~BaseHandler.default_open`.  If all such methods return :const:`None`, the "
"algorithm is repeated for methods named like :meth:`!<protocol>_open`.  If "
"all such methods return :const:`None`, the algorithm is repeated for methods "
"named :meth:`~BaseHandler.unknown_open`."
msgstr ""
"Faktum är att ovanstående algoritm först prövas för metoder med namnet :meth:"
"`~BaseHandler.default_open`.  Om alla sådana metoder returnerar :const:"
"`None`, upprepas algoritmen för metoder med namn som :meth:`!"
"<protocol>_open`.  Om alla sådana metoder returnerar :const:`None` upprepas "
"algoritmen för metoder med namnet :meth:`~BaseHandler.unknown_open`."

msgid ""
"Note that the implementation of these methods may involve calls of the "
"parent :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` and :"
"meth:`~OpenerDirector.error` methods."
msgstr ""
"Observera att implementeringen av dessa metoder kan innebära anrop av den "
"överordnade :class:`OpenerDirector`-instansens metoder :meth:"
"`~OpenerDirector.open` och :meth:`~OpenerDirector.error`."

msgid ""
"Every handler with a method named like :meth:`!<protocol>_response` has that "
"method called to post-process the response."
msgstr ""
"Varje hanterare med en metod som heter som :meth:`!<protocol>_response` har "
"den metoden som anropas för att efterbehandla svaret."

msgid "BaseHandler Objects"
msgstr "BaseHandler-objekt"

msgid ""
":class:`BaseHandler` objects provide a couple of methods that are directly "
"useful, and others that are meant to be used by derived classes.  These are "
"intended for direct use:"
msgstr ""
":class:`BaseHandler`-objekt tillhandahåller ett par metoder som är direkt "
"användbara och andra som är avsedda att användas av härledda klasser.  Dessa "
"är avsedda för direkt användning:"

msgid "Add a director as parent."
msgstr "Lägg till en direktör som förälder."

msgid "Remove any parents."
msgstr "Ta bort eventuella föräldrar."

msgid ""
"The following attribute and methods should only be used by classes derived "
"from :class:`BaseHandler`."
msgstr ""
"Följande attribut och metoder bör endast användas av klasser som härrör "
"från :class:`BaseHandler`."

msgid ""
"The convention has been adopted that subclasses defining :meth:`!"
"<protocol>_request` or :meth:`!<protocol>_response` methods are named :class:"
"`!\\*Processor`; all others are named :class:`!\\*Handler`."
msgstr ""
"Konventionen har antagits att subklasser som definierar :meth:`!"
"<protocol>_request` eller :meth:`!<protocol>_response` metoder heter :class:"
"`!\\*Processor`; alla andra heter :class:`!\\*Handler`."

msgid ""
"A valid :class:`OpenerDirector`, which can be used to open using a different "
"protocol, or handle errors."
msgstr ""
"En giltig :class:`OpenerDirector`, som kan användas för att öppna med ett "
"annat protokoll eller hantera fel."

msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs."
msgstr ""
"Denna metod är *inte* definierad i :class:`BaseHandler`, men underklasser "
"bör definiera den om de vill fånga alla URL:er."

msgid ""
"This method, if implemented, will be called by the parent :class:"
"`OpenerDirector`.  It should return a file-like object as described in the "
"return value of the :meth:`~OpenerDirector.open` method of :class:"
"`OpenerDirector`, or ``None``. It should raise :exc:`~urllib.error."
"URLError`, unless a truly exceptional thing happens (for example, :exc:"
"`MemoryError` should not be mapped to :exc:`~urllib.error.URLError`)."
msgstr ""
"Denna metod, om den är implementerad, kommer att anropas av den överordnade :"
"class:`OpenerDirector`.  Den bör returnera ett filliknande objekt som "
"beskrivs i returvärdet för metoden :meth:`~OpenerDirector.open` i :class:"
"`OpenerDirector`, eller ``None``. Den bör ge upphov till :exc:`~urllib.error."
"URLError`, såvida inte något verkligt exceptionellt inträffar (till exempel "
"bör :exc:`MemoryError` inte mappas till :exc:`~urllib.error.URLError`)."

msgid "This method will be called before any protocol-specific open method."
msgstr ""
"Denna metod kommer att anropas före någon protokollspecifik öppen metod."

msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to handle URLs with the given protocol."
msgstr ""
"Denna metod är *inte* definierad i :class:`BaseHandler`, men underklasser "
"bör definiera den om de vill hantera URL:er med det angivna protokollet."

msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. Return values should be the same as for  :meth:"
"`~BaseHandler.default_open`."
msgstr ""
"Denna metod, om den är definierad, kommer att anropas av den överordnade :"
"class:`OpenerDirector`. Returvärdena bör vara desamma som för :meth:"
"`~BaseHandler.default_open`."

msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs with no specific registered handler "
"to open it."
msgstr ""
"Denna metod är *inte* definierad i :class:`BaseHandler`, men underklasser "
"bör definiera den om de vill fånga upp alla URL:er som inte har någon "
"specifik registrerad hanterare för att öppna den."

msgid ""
"This method, if implemented, will be called by the :attr:`parent` :class:"
"`OpenerDirector`.  Return values should be the same as for :meth:"
"`default_open`."
msgstr ""
"Denna metod, om den implementeras, kommer att anropas av :attr:`parent` :"
"class:`OpenerDirector`.  Returvärdena bör vara desamma som för :meth:"
"`default_open`."

msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"override it if they intend to provide a catch-all for otherwise unhandled "
"HTTP errors.  It will be called automatically by the  :class:"
"`OpenerDirector` getting the error, and should not normally be called in "
"other circumstances."
msgstr ""
"Denna metod är *inte* definierad i :class:`BaseHandler`, men subklasser bör "
"åsidosätta den om de avser att tillhandahålla en catch-all för annars "
"ohanterade HTTP-fel.  Den kommer att anropas automatiskt av den :class:"
"`OpenerDirector` som får felet, och bör normalt inte anropas under andra "
"omständigheter."

msgid ""
":class:`OpenerDirector` will call this method with five positional arguments:"
msgstr ""
":class:`OpenerDirector` kommer att anropa denna metod med fem positionella "
"argument:"

msgid "a :class:`Request` object,"
msgstr "ett :class:`Request`-objekt,"

msgid "a file-like object with the HTTP error body,"
msgstr "ett filliknande objekt med HTTP-feltexten,"

msgid "the three-digit code of the error, as a string,"
msgstr "den tresiffriga koden för felet, som en sträng,"

msgid "the user-visible explanation of the code, as a string, and"
msgstr "den för användaren synliga förklaringen av koden, som en sträng, och"

msgid "the headers of the error, as a mapping object."
msgstr "rubrikerna för felet, som ett mappningsobjekt."

msgid ""
"Return values and exceptions raised should be the same as those of :func:"
"`urlopen`."
msgstr ""
"Returvärden och undantag som tas upp bör vara desamma som för :func:"
"`urlopen`."

msgid ""
"*nnn* should be a three-digit HTTP error code.  This method is also not "
"defined in :class:`BaseHandler`, but will be called, if it exists, on an "
"instance of a subclass, when an HTTP error with code *nnn* occurs."
msgstr ""
"*nnn* bör vara en tresiffrig HTTP-felkod.  Denna metod är inte heller "
"definierad i :class:`BaseHandler`, men kommer att anropas, om den finns, på "
"en instans av en subklass, när ett HTTP-fel med koden *nnn* inträffar."

msgid "Subclasses should override this method to handle specific HTTP errors."
msgstr ""
"Underklasser bör åsidosätta denna metod för att hantera specifika HTTP-fel."

msgid ""
"Arguments, return values and exceptions raised should be the same as for :"
"meth:`~BaseHandler.http_error_default`."
msgstr ""
"Argument, returvärden och undantag som tas upp bör vara desamma som för :"
"meth:`~BaseHandler.http_error_default`."

msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to pre-process requests of the given protocol."
msgstr ""
"Denna metod är *inte* definierad i :class:`BaseHandler`, men underklasser "
"bör definiera den om de vill förbehandla förfrågningar av det angivna "
"protokollet."

msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. The return value "
"should be a :class:`Request` object."
msgstr ""
"Denna metod, om den är definierad, kommer att anropas av den överordnade :"
"class:`OpenerDirector`. *req* kommer att vara ett :class:`Request`-objekt. "
"Returvärdet bör vara ett :class:`Request`-objekt."

msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to post-process responses of the given protocol."
msgstr ""
"Denna metod är *inte* definierad i :class:`BaseHandler`, men underklasser "
"bör definiera den om de vill efterbehandla svar från det angivna protokollet."

msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. *response* will "
"be an object implementing the same interface as the return value of :func:"
"`urlopen`.  The return value should implement the same interface as the "
"return value of :func:`urlopen`."
msgstr ""
"Denna metod, om den är definierad, kommer att anropas av den överordnade :"
"class:`OpenerDirector`. *req* kommer att vara ett :class:`Request`-objekt. "
"*response* kommer att vara ett objekt som implementerar samma gränssnitt som "
"returvärdet för :func:`urlopen`.  Returvärdet bör implementera samma "
"gränssnitt som returvärdet för :func:`urlopen`."

msgid "HTTPRedirectHandler Objects"
msgstr "HTTPRedirectHandler-objekt"

msgid ""
"Some HTTP redirections require action from this module's client code.  If "
"this is the case, :exc:`~urllib.error.HTTPError` is raised.  See :rfc:`2616` "
"for details of the precise meanings of the various redirection codes."
msgstr ""
"Vissa HTTP-omdirigeringar kräver åtgärder från den här modulens klientkod.  "
"Om så är fallet kommer :exc:`~urllib.error.HTTPError` att uppstå.  Se :rfc:"
"`2616` för detaljer om den exakta betydelsen av de olika "
"omdirigeringskoderna."

msgid ""
"An :exc:`~urllib.error.HTTPError` exception raised as a security "
"consideration if the HTTPRedirectHandler is presented with a redirected URL "
"which is not an HTTP, HTTPS or FTP URL."
msgstr ""
"Ett :exc:`~urllib.error.HTTPError`-undantag som uppstår av säkerhetsskäl om "
"HTTPRedirectHandler presenteras med en omdirigerad URL som inte är en HTTP-, "
"HTTPS- eller FTP-URL."

msgid ""
"Return a :class:`Request` or ``None`` in response to a redirect. This is "
"called by the default implementations of the :meth:`!http_error_30\\*` "
"methods when a redirection is received from the server.  If a redirection "
"should take place, return a new :class:`Request` to allow :meth:`!"
"http_error_30\\*` to perform the redirect to *newurl*.  Otherwise, raise :"
"exc:`~urllib.error.HTTPError` if no other handler should try to handle this "
"URL, or return ``None`` if you can't but another handler might."
msgstr ""
"Returnerar en :class:`Request` eller ``None`` som svar på en omdirigering. "
"Detta anropas av standardimplementeringarna av :meth:`!http_error_30\\*`-"
"metoderna när en omdirigering tas emot från servern.  Om en omdirigering ska "
"ske, returnera en ny :class:`Request` för att tillåta :meth:`!"
"http_error_30\\*` att utföra omdirigeringen till *newurl*.  I annat fall, "
"skapa :exc:`~urllib.error.HTTPError` om ingen annan hanterare bör försöka "
"hantera denna URL, eller returnera ``None`` om du inte kan men en annan "
"hanterare kanske kan."

msgid ""
"The default implementation of this method does not strictly follow :rfc:"
"`2616`, which says that 301 and 302 responses to ``POST`` requests must not "
"be automatically redirected without confirmation by the user.  In reality, "
"browsers do allow automatic redirection of these responses, changing the "
"POST to a ``GET``, and the default implementation reproduces this behavior."
msgstr ""
"Standardemplementeringen av denna metod följer inte strikt :rfc:`2616`, som "
"säger att 301- och 302-svar på ``POST``-förfrågningar inte får omdirigeras "
"automatiskt utan bekräftelse från användaren.  I verkligheten tillåter "
"webbläsare automatisk omdirigering av dessa svar, genom att ändra POST till "
"en ``GET``, och standardimplementeringen reproducerar detta beteende."

msgid ""
"Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by the "
"parent :class:`OpenerDirector` when getting an HTTP 'moved permanently' "
"response."
msgstr ""
"Omdirigera till URL:en ``Location:`` eller ``URI:``.  Denna metod anropas av "
"den överordnade :class:`OpenerDirector` när den får ett HTTP-svar 'moved "
"permanently'."

msgid ""
"The same as :meth:`http_error_301`, but called for the 'found' response."
msgstr ""
"Samma sak som :meth:`http_error_301`, men anropas för svaret \"found\"."

msgid ""
"The same as :meth:`http_error_301`, but called for the 'see other' response."
msgstr ""
"Samma sak som :meth:`http_error_301`, men kallas för svaret \"see other\"."

msgid ""
"The same as :meth:`http_error_301`, but called for the 'temporary redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr ""
"Samma som :meth:`http_error_301`, men kallas för svaret 'temporary "
"redirect'. Det tillåter inte att ändra förfrågningsmetoden från ``POST`` "
"till ``GET``."

msgid ""
"The same as :meth:`http_error_301`, but called for the 'permanent redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr ""
"Samma som :meth:`http_error_301`, men kallas för svaret 'permanent "
"redirect'. Det tillåter inte att ändra förfrågningsmetoden från ``POST`` "
"till ``GET``."

msgid "HTTPCookieProcessor Objects"
msgstr "HTTPCookieProcessor-objekt"

msgid ":class:`HTTPCookieProcessor` instances have one attribute:"
msgstr ":class:`HTTPCookieProcessor`-instanser har ett attribut:"

msgid "The :class:`http.cookiejar.CookieJar` in which cookies are stored."
msgstr "Den :class:`http.cookiejar.CookieJar` i vilken cookies lagras."

msgid "ProxyHandler Objects"
msgstr "ProxyHandler-objekt"

msgid ""
"The :class:`ProxyHandler` will have a method :meth:`!<protocol>_open` for "
"every *protocol* which has a proxy in the *proxies* dictionary given in the "
"constructor.  The method will modify requests to go through the proxy, by "
"calling ``request.set_proxy()``, and call the next handler in the chain to "
"actually execute the protocol."
msgstr ""
"Klassen:`ProxyHandler` kommer att ha en metod :meth:`!<protocol>_open` för "
"varje *protokoll* som har en proxy i *proxies*-ordlistan som ges i "
"konstruktören.  Metoden kommer att ändra förfrågningar så att de går genom "
"proxyn, genom att anropa ``request.set_proxy()``, och anropa nästa hanterare "
"i kedjan för att faktiskt exekvera protokollet."

msgid "HTTPPasswordMgr Objects"
msgstr "HTTPPasswordMgr-objekt"

msgid ""
"These methods are available on :class:`HTTPPasswordMgr` and :class:"
"`HTTPPasswordMgrWithDefaultRealm` objects."
msgstr ""
"Dessa metoder är tillgängliga för objekten :class:`HTTPPasswordMgr` och :"
"class:`HTTPPasswordMgrWithDefaultRealm`."

msgid ""
"*uri* can be either a single URI, or a sequence of URIs. *realm*, *user* and "
"*passwd* must be strings. This causes ``(user, passwd)`` to be used as "
"authentication tokens when authentication for *realm* and a super-URI of any "
"of the given URIs is given."
msgstr ""
"*uri* kan vara antingen en enskild URI eller en sekvens av URI:er. *realm*, "
"*user* och *passwd* måste vara strängar. Detta gör att ``(user, passwd)`` "
"används som autentiseringstoken när autentisering för *realm* och en super-"
"URI för någon av de angivna URI:erna anges."

msgid ""
"Get user/password for given realm and URI, if any.  This method will return "
"``(None, None)`` if there is no matching user/password."
msgstr ""
"Hämta användare/lösenord för given realm och URI, om någon.  Denna metod "
"returnerar ``(None, None)`` om det inte finns någon matchande användare/"
"lösenord."

msgid ""
"For :class:`HTTPPasswordMgrWithDefaultRealm` objects, the realm ``None`` "
"will be searched if the given *realm* has no matching user/password."
msgstr ""
"För :class:`HTTPPasswordMgrWithDefaultRealm`-objekt kommer sfären ``None`` "
"att sökas om den angivna *sfären* inte har någon matchande användare/"
"lösenord."

msgid "HTTPPasswordMgrWithPriorAuth Objects"
msgstr "HTTPPasswordMgrWithPriorAuth Objekt"

msgid ""
"This password manager extends :class:`HTTPPasswordMgrWithDefaultRealm` to "
"support tracking URIs for which authentication credentials should always be "
"sent."
msgstr ""
"Denna lösenordshanterare utökar :class:`HTTPPasswordMgrWithDefaultRealm` för "
"att stödja spårning av URI:er för vilka autentiseringsuppgifter alltid ska "
"skickas."

msgid ""
"*realm*, *uri*, *user*, *passwd* are as for :meth:`HTTPPasswordMgr."
"add_password`.  *is_authenticated* sets the initial value of the "
"``is_authenticated`` flag for the given URI or list of URIs. If "
"*is_authenticated* is specified as ``True``, *realm* is ignored."
msgstr ""
"*realm*, *uri*, *user*, *passwd* är som för :meth:`HTTPPasswordMgr."
"add_password`.  *is_authenticated* anger det initiala värdet för flaggan "
"``is_authenticated`` för den angivna URI:n eller listan med URI:er. Om "
"*is_authenticated* anges som ``True`` ignoreras *realm*."

msgid "Same as for :class:`HTTPPasswordMgrWithDefaultRealm` objects"
msgstr "Samma som för :class:`HTTPPasswordMgrWithDefaultRealm`-objekt"

msgid ""
"Update the ``is_authenticated`` flag for the given *uri* or list of URIs."
msgstr ""
"Uppdaterar flaggan ``is_authenticated`` för den angivna *uri* eller listan "
"med URI:er."

msgid ""
"Returns the current state of the ``is_authenticated`` flag for the given URI."
msgstr ""
"Returnerar det aktuella läget för flaggan ``is_authenticated`` för den "
"angivna URI:n."

msgid "AbstractBasicAuthHandler Objects"
msgstr "AbstractBasicAuthHandler-objekt"

msgid ""
"Handle an authentication request by getting a user/password pair, and re-"
"trying the request.  *authreq* should be the name of the header where the "
"information about the realm is included in the request, *host* specifies the "
"URL and path to authenticate for, *req* should be the (failed) :class:"
"`Request` object, and *headers* should be the error headers."
msgstr ""
"Hantera en autentiseringsbegäran genom att hämta ett par av användare/"
"lösenord och försöka igen.  *authreq* ska vara namnet på rubriken där "
"informationen om sfären ingår i begäran, *host* anger URL och sökväg för "
"autentisering, *req* ska vara det (misslyckade) :class:`Request`-objektet "
"och *headers* ska vara felrubrikerna."

msgid ""
"*host* is either an authority (e.g. ``\"python.org\"``) or a URL containing "
"an authority component (e.g. ``\"http://python.org/\"``). In either case, "
"the authority must not contain a userinfo component (so, ``\"python.org\"`` "
"and ``\"python.org:80\"`` are fine, ``\"joe:password@python.org\"`` is not)."
msgstr ""
"*host* är antingen en auktoritet (t.ex. ``\"python.org\"``) eller en URL som "
"innehåller en auktoritetskomponent (t.ex. ``\"http://python.org/\"``). I "
"båda fallen får auktoriteten inte innehålla en userinfo-komponent (så "
"``\"python.org\"`` och ``\"python.org:80\"`` är bra, ``\"joe:password@python."
"org\"`` är det inte)."

msgid "HTTPBasicAuthHandler Objects"
msgstr "HTTPBasicAuthHandler-objekt"

msgid "Retry the request with authentication information, if available."
msgstr "Försök igen med autentiseringsinformation, om sådan finns tillgänglig."

msgid "ProxyBasicAuthHandler Objects"
msgstr "ProxyBasicAuthHandler-objekt"

msgid "AbstractDigestAuthHandler Objects"
msgstr "AbstractDigestAuthHandler-objekt"

msgid ""
"*authreq* should be the name of the header where the information about the "
"realm is included in the request, *host* should be the host to authenticate "
"to, *req* should be the (failed) :class:`Request` object, and *headers* "
"should be the error headers."
msgstr ""
"*authreq* ska vara namnet på det huvud där informationen om sfären "
"inkluderas i begäran, *host* ska vara värden att autentisera sig mot, *req* "
"ska vara det (misslyckade) :class:`Request`-objektet och *headers* ska vara "
"felhuvudena."

msgid "HTTPDigestAuthHandler Objects"
msgstr "HTTPDigestAuthHandler-objekt"

msgid "ProxyDigestAuthHandler Objects"
msgstr "ProxyDigestAuthHandler-objekt"

msgid "HTTPHandler Objects"
msgstr "HTTPHandler-objekt"

msgid ""
"Send an HTTP request, which can be either GET or POST, depending on ``req."
"data``."
msgstr ""
"Skicka en HTTP-begäran, som kan vara antingen GET eller POST, beroende på "
"``req.data``."

msgid "HTTPSHandler Objects"
msgstr "HTTPSHandler-objekt"

msgid ""
"Send an HTTPS request, which can be either GET or POST, depending on ``req."
"data``."
msgstr ""
"Skicka en HTTPS-förfrågan, som kan vara antingen GET eller POST, beroende på "
"``req.data``."

msgid "FileHandler Objects"
msgstr "FileHandler-objekt"

msgid ""
"Open the file locally, if there is no host name, or the host name is "
"``'localhost'``."
msgstr ""
"Öppna filen lokalt om det inte finns något värdnamn eller om värdnamnet är "
"``'localhost``."

msgid ""
"This method is applicable only for local hostnames.  When a remote hostname "
"is given, a :exc:`~urllib.error.URLError` is raised."
msgstr ""
"Denna metod är endast tillämplig för lokala värdnamn.  När ett "
"fjärrvärddatornamn anges, uppstår ett :exc:`~urllib.error.URLError`."

msgid "DataHandler Objects"
msgstr "DataHandler-objekt"

msgid ""
"Read a data URL. This kind of URL contains the content encoded in the URL "
"itself. The data URL syntax is specified in :rfc:`2397`. This implementation "
"ignores white spaces in base64 encoded data URLs so the URL may be wrapped "
"in whatever source file it comes from. But even though some browsers don't "
"mind about a missing padding at the end of a base64 encoded data URL, this "
"implementation will raise a :exc:`ValueError` in that case."
msgstr ""
"Läs en data-URL. Denna typ av URL innehåller innehållet som är kodat i "
"själva URL:en. Syntaxen för data-URL:er anges i :rfc:`2397`. Den här "
"implementationen ignorerar blanksteg i base64-kodade data-URL:er så att URL:"
"en kan förpackas i vilken källfil den än kommer ifrån. Men även om vissa "
"webbläsare inte bryr sig om att det saknas mellanslag i slutet av en base64-"
"kodad data-URL, kommer den här implementationen att ge upphov till ett :exc:"
"`ValueError` i så fall."

msgid "FTPHandler Objects"
msgstr "FTPHandler-objekt"

msgid ""
"Open the FTP file indicated by *req*. The login is always done with empty "
"username and password."
msgstr ""
"Öppna den FTP-fil som anges med *req*. Inloggningen sker alltid med tomt "
"användarnamn och lösenord."

msgid "CacheFTPHandler Objects"
msgstr "CacheFTPHandler-objekt"

msgid ""
":class:`CacheFTPHandler` objects are :class:`FTPHandler` objects with the "
"following additional methods:"
msgstr ""
":class:`CacheFTPHandler`-objekt är :class:`FTPHandler`-objekt med följande "
"ytterligare metoder:"

msgid "Set timeout of connections to *t* seconds."
msgstr "Ställ in timeout för anslutningar till *t* sekunder."

msgid "Set maximum number of cached connections to *m*."
msgstr "Ställ in maximalt antal cachade anslutningar till *m*."

msgid "UnknownHandler Objects"
msgstr "UnknownHandler-objekt"

msgid "Raise a :exc:`~urllib.error.URLError` exception."
msgstr "Utlöser ett :exc:`~urllib.error.URLError` undantag."

msgid "HTTPErrorProcessor Objects"
msgstr "HTTPErrorProcessor-objekt"

msgid "For 200 error codes, the response object is returned immediately."
msgstr "För 200-felkoder returneras svarsobjektet omedelbart."

msgid ""
"For non-200 error codes, this simply passes the job on to the :meth:`!"
"http_error_\\<type\\>` handler methods, via :meth:`OpenerDirector.error`. "
"Eventually, :class:`HTTPDefaultErrorHandler` will raise an :exc:`~urllib."
"error.HTTPError` if no other handler handles the error."
msgstr ""
"För felkoder som inte är 200 skickas jobbet helt enkelt vidare till "
"hanteringsmetoderna :meth:`!http_error_\\<type\\>`, via :meth:"
"`OpenerDirector.error`. I slutändan kommer :class:`HTTPDefaultErrorHandler` "
"att skapa en :exc:`~urllib.error.HTTPError` om ingen annan hanterare "
"hanterar felet."

msgid "Process HTTPS error responses."
msgstr "Behandla HTTPS-felsvar."

msgid "The behavior is same as :meth:`http_response`."
msgstr "Beteendet är detsamma som :meth:`http_response`."

msgid "Examples"
msgstr "Exempel"

msgid ""
"In addition to the examples below, more examples are given in :ref:`urllib-"
"howto`."
msgstr "Förutom exemplen nedan finns fler exempel i :ref:`urllib-howto`."

msgid ""
"This example gets the python.org main page and displays the first 300 bytes "
"of it::"
msgstr ""
"Detta exempel hämtar huvudsidan för python.org och visar de första 300 byte "
"av den::"

msgid ""
">>> import urllib.request\n"
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(300))\n"
"...\n"
"b'<!doctype html>\\n<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-"
"ie8 lt-ie9\">   <![endif]-->\\n<!--[if IE 7]>      <html class=\"no-js ie7 "
"lt-ie8 lt-ie9\">          <![endif]-->\\n<!--[if IE 8]>      <html "
"class=\"no-js ie8 lt-ie9\">"
msgstr ""
">>> import urllib.request\n"
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(300))\n"
"...\n"
"b'<!doctype html>\\n<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-"
"ie8 lt-ie9\">   <![endif]-->\\n<!--[if IE 7]>      <html class=\"no-js ie7 "
"lt-ie8 lt-ie9\">          <![endif]-->\\n<!--[if IE 8]>      <html "
"class=\"no-js ie8 lt-ie9\">"

msgid ""
"Note that urlopen returns a bytes object.  This is because there is no way "
"for urlopen to automatically determine the encoding of the byte stream it "
"receives from the HTTP server. In general, a program will decode the "
"returned bytes object to string once it determines or guesses the "
"appropriate encoding."
msgstr ""
"Observera att urlopen returnerar ett bytes-objekt.  Detta beror på att det "
"inte finns något sätt för urlopen att automatiskt bestämma kodningen av "
"byteströmmen som den tar emot från HTTP-servern. I allmänhet kommer ett "
"program att avkoda det returnerade bytes-objektet till en sträng när det har "
"bestämt eller gissat sig för lämplig kodning."

msgid ""
"The following HTML spec document, https://html.spec.whatwg.org/#charset, "
"lists the various ways in which an HTML or an XML document could have "
"specified its encoding information."
msgstr ""
"I följande HTML-specifikationsdokument, https://html.spec.whatwg.org/"
"#charset, listas de olika sätt på vilka ett HTML- eller XML-dokument kan ha "
"specificerat sin kodningsinformation."

msgid ""
"For additional information, see the W3C document: https://www.w3.org/"
"International/questions/qa-html-encoding-declarations."
msgstr ""
"För ytterligare information, se W3C-dokumentet: https://www.w3.org/"
"International/questions/qa-html-encoding-declarations."

msgid ""
"As the python.org website uses *utf-8* encoding as specified in its meta "
"tag, we will use the same for decoding the bytes object::"
msgstr ""
"Eftersom webbplatsen python.org använder *utf-8* kodning enligt "
"specifikationen i dess metatagg, kommer vi att använda samma för att avkoda "
"bytesobjektet::"

msgid ""
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"<!-"
msgstr ""
"&gt;&gt;&gt; med urllib.request.urlopen('http://www.python.org/') som f:\n"
"... print(f.read(100).decode('utf-8'))\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"&lt;!-"

msgid ""
"It is also possible to achieve the same result without using the :term:"
"`context manager` approach::"
msgstr ""
"Det är också möjligt att uppnå samma resultat utan att använda :term:"
"`kontexthanteraren`::"

msgid ""
">>> import urllib.request\n"
">>> f = urllib.request.urlopen('http://www.python.org/')\n"
">>> try:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"... finally:\n"
"...     f.close()\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"<!--"
msgstr ""
"&gt;&gt;&gt; import urllib.request\n"
"&gt;&gt;&gt; f = urllib.request.urlopen('http://www.python.org/')\n"
"&gt;&gt;&gt; försök:\n"
"... print(f.read(100).decode('utf-8'))\n"
"... slutligen:\n"
"... f.close()\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"&lt;!--"

msgid ""
"In the following example, we are sending a data-stream to the stdin of a CGI "
"and reading the data it returns to us. Note that this example will only work "
"when the Python installation supports SSL. ::"
msgstr ""
"I följande exempel skickar vi en dataström till stdin på en CGI och läser de "
"data som den returnerar till oss. Observera att det här exemplet bara "
"fungerar om Python-installationen stöder SSL. ::"

msgid ""
">>> import urllib.request\n"
">>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',\n"
"...                       data=b'This data is passed to stdin of the CGI')\n"
">>> with urllib.request.urlopen(req) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"...\n"
"Got Data: \"This data is passed to stdin of the CGI\""
msgstr ""
">>> import urllib.request\n"
">>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',\n"
"... data=b'Denna data skickas till stdin i CGI')\n"
">>> med urllib.request.urlopen(req) som f:\n"
"... print(f.read().decode('utf-8'))\n"
"...\n"
"Fick data: \"Dessa data skickas till CGI:s stdin\""

msgid "The code for the sample CGI used in the above example is::"
msgstr "Koden för den exempel-CGI som används i exemplet ovan är::"

msgid ""
"#!/usr/bin/env python\n"
"import sys\n"
"data = sys.stdin.read()\n"
"print('Content-type: text/plain\\n\\nGot Data: \"%s\"' % data)"
msgstr ""
"#!/usr/bin/env python\n"
"import sys\n"
"data = sys.stdin.read()\n"
"print('Content-type: text/plain\\n\\nGot Data: \"%s\"' % data)"

msgid "Here is an example of doing a ``PUT`` request using :class:`Request`::"
msgstr ""
"Här är ett exempel på hur man gör en ``PUT`` förfrågan med :class:`Request`::"

msgid ""
"import urllib.request\n"
"DATA = b'some data'\n"
"req = urllib.request.Request(url='http://localhost:8080', data=DATA, "
"method='PUT')\n"
"with urllib.request.urlopen(req) as f:\n"
"    pass\n"
"print(f.status)\n"
"print(f.reason)"
msgstr ""
"import urllib.request\n"
"DATA = b'några data'\n"
"req = urllib.request.Request(url='http://localhost:8080', data=DATA, "
"method='PUT')\n"
"med urllib.request.urlopen(req) som f:\n"
"    pass\n"
"print(f.status)\n"
"print(f.reason)"

msgid "Use of Basic HTTP Authentication::"
msgstr "Användning av grundläggande HTTP-autentisering::"

msgid ""
"import urllib.request\n"
"# Create an OpenerDirector with support for Basic HTTP Authentication...\n"
"auth_handler = urllib.request.HTTPBasicAuthHandler()\n"
"auth_handler.add_password(realm='PDQ Application',\n"
"                          uri='https://mahler:8092/site-updates.py',\n"
"                          user='klem',\n"
"                          passwd='kadidd!ehopper')\n"
"opener = urllib.request.build_opener(auth_handler)\n"
"# ...and install it globally so it can be used with urlopen.\n"
"urllib.request.install_opener(opener)\n"
"with urllib.request.urlopen('http://www.example.com/login.html') as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"# Create an OpenerDirector with support for Basic HTTP Authentication...\n"
"auth_handler = urllib.request.HTTPBasicAuthHandler()\n"
"auth_handler.add_password(realm='PDQ Application',\n"
"                          uri='https://mahler:8092/site-updates.py',\n"
"                          user='klem',\n"
"                          passwd='kadidd!ehopper')\n"
"opener = urllib.request.build_opener(auth_handler)\n"
"# ...and install it globally so it can be used with urlopen.\n"
"urllib.request.install_opener(opener)\n"
"with urllib.request.urlopen('http://www.example.com/login.html') as f:\n"
"    print(f.read().decode('utf-8'))"

msgid ""
":func:`build_opener` provides many handlers by default, including a :class:"
"`ProxyHandler`.  By default, :class:`ProxyHandler` uses the environment "
"variables named ``<scheme>_proxy``, where ``<scheme>`` is the URL scheme "
"involved.  For example, the :envvar:`!http_proxy` environment variable is "
"read to obtain the HTTP proxy's URL."
msgstr ""
":func:`build_opener` tillhandahåller många hanterare som standard, inklusive "
"en :class:`ProxyHandler`.  Som standard använder :class:`ProxyHandler` "
"miljövariablerna med namnet ``<scheme>_proxy``, där ``<scheme>`` är det "
"aktuella URL-schemat.  Till exempel läses miljövariabeln :envvar:`!"
"http_proxy` för att få HTTP-proxyns URL."

msgid ""
"This example replaces the default :class:`ProxyHandler` with one that uses "
"programmatically supplied proxy URLs, and adds proxy authorization support "
"with :class:`ProxyBasicAuthHandler`. ::"
msgstr ""
"Detta exempel ersätter standard :class:`ProxyHandler` med en som använder "
"programmatiskt angivna proxy-URL:er och lägger till stöd för "
"proxyauktorisering med :class:`ProxyBasicAuthHandler`. ::"

msgid ""
"proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example."
"com:3128/'})\n"
"proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()\n"
"proxy_auth_handler.add_password('realm', 'host', 'username', 'password')\n"
"\n"
"opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)\n"
"# This time, rather than install the OpenerDirector, we use it directly:\n"
"with opener.open('http://www.example.com/login.html') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""
"proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example."
"com:3128/'})\n"
"proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()\n"
"proxy_auth_handler.add_password('realm', 'host', 'username', 'password')\n"
"\n"
"opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)\n"
"# Den här gången använder vi OpenerDirector direkt i stället för att "
"installera den:\n"
"med opener.open('http://www.example.com/login.html') som f:\n"
"   print(f.read().decode('utf-8'))"

msgid "Adding HTTP headers:"
msgstr "Lägga till HTTP-rubriker:"

msgid "Use the *headers* argument to the :class:`Request` constructor, or::"
msgstr ""
"Använd *headers*-argumentet till :class:`Request`-konstruktören, eller::"

msgid ""
"import urllib.request\n"
"req = urllib.request.Request('http://www.example.com/')\n"
"req.add_header('Referer', 'http://www.python.org/')\n"
"# Customize the default User-Agent header value:\n"
"req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')\n"
"with urllib.request.urlopen(req) as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"req = urllib.request.Request('http://www.example.com/')\n"
"req.add_header('Referer', 'http://www.python.org/')\n"
"# Anpassa standardvärdet för User-Agent-huvudet:\n"
"req.add_header('User-Agent', 'urllib-example/0.1 (Kontakt: . . .)')\n"
"med urllib.request.urlopen(req) som f:\n"
"    print(f.read().decode('utf-8'))"

msgid ""
":class:`OpenerDirector` automatically adds a :mailheader:`User-Agent` header "
"to every :class:`Request`.  To change this::"
msgstr ""
":class:`OpenerDirector` lägger automatiskt till en :mailheader:`User-Agent` "
"header till varje :class:`Request`.  För att ändra detta::"

msgid ""
"import urllib.request\n"
"opener = urllib.request.build_opener()\n"
"opener.addheaders = [('User-agent', 'Mozilla/5.0')]\n"
"with opener.open('http://www.example.com/') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"opener = urllib.request.build_opener()\n"
"opener.addheaders = [('User-agent', 'Mozilla/5.0')]\n"
"med opener.open('http://www.example.com/') som f:\n"
"   print(f.read().decode('utf-8'))"

msgid ""
"Also, remember that a few standard headers (:mailheader:`Content-Length`, :"
"mailheader:`Content-Type` and :mailheader:`Host`) are added when the :class:"
"`Request` is passed to :func:`urlopen` (or :meth:`OpenerDirector.open`)."
msgstr ""
"Kom också ihåg att några standardrubriker (:mailheader:`Content-Length`, :"
"mailheader:`Content-Type` och :mailheader:`Host`) läggs till när :class:"
"`Request` skickas till :func:`urlopen` (eller :meth:`OpenerDirector.open`)."

msgid ""
"Here is an example session that uses the ``GET`` method to retrieve a URL "
"containing parameters::"
msgstr ""
"Här är ett exempel på en session som använder metoden ``GET`` för att hämta "
"en URL som innehåller parametrar::"

msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> url = \"http://www.musi-cal.com/cgi-bin/query?%s\" % params\n"
">>> with urllib.request.urlopen(url) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> url = \"http://www.musi-cal.com/cgi-bin/query?%s\" % params\n"
">>> with urllib.request.urlopen(url) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."

msgid ""
"The following example uses the ``POST`` method instead. Note that params "
"output from urlencode is encoded to bytes before it is sent to urlopen as "
"data::"
msgstr ""
"I följande exempel används istället metoden ``POST``. Notera att params-"
"utdata från urlencode kodas till bytes innan det skickas till urlopen som "
"data::"

msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> data = data.encode('ascii')\n"
">>> with urllib.request.urlopen(\"http://requestb.in/xrbl82xr\", data) as "
"f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> data = data.encode('ascii')\n"
">>> with urllib.request.urlopen(\"http://requestb.in/xrbl82xr\", data) as "
"f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."

msgid ""
"The following example uses an explicitly specified HTTP proxy, overriding "
"environment settings::"
msgstr ""
"I följande exempel används en explicit angiven HTTP-proxy som åsidosätter "
"miljöinställningarna::"

msgid ""
">>> import urllib.request\n"
">>> proxies = {'http': 'http://proxy.example.com:8080/'}\n"
">>> opener = urllib.request.build_opener(urllib.request."
"ProxyHandler(proxies))\n"
">>> with opener.open(\"http://www.python.org\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> proxies = {'http': 'http://proxy.example.com:8080/'}\n"
">>> opener = urllib.request.build_opener(urllib.request."
"ProxyHandler(proxies))\n"
">>> med opener.open(\"http://www.python.org\") som f:\n"
"... f.read().decode('utf-8')\n"
"..."

msgid ""
"The following example uses no proxies at all, overriding environment "
"settings::"
msgstr ""
"I följande exempel används inga proxyservrar alls, utan miljöinställningarna "
"åsidosätts::"

msgid ""
">>> import urllib.request\n"
">>> opener = urllib.request.build_opener(urllib.request.ProxyHandler({}}))\n"
">>> with opener.open(\"http://www.python.org/\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> opener = urllib.request.build_opener(urllib.request.ProxyHandler({}})))\n"
">>> med opener.open(\"http://www.python.org/\") som f:\n"
"... f.read().decode('utf-8')\n"
"..."

msgid "Legacy interface"
msgstr "Äldre gränssnitt"

msgid ""
"The following functions and classes are ported from the Python 2 module "
"``urllib`` (as opposed to ``urllib2``).  They might become deprecated at "
"some point in the future."
msgstr ""
"Följande funktioner och klasser är portade från Python 2-modulen ``urllib`` "
"(i motsats till ``urllib2``).  De kan komma att bli föråldrade någon gång i "
"framtiden."

msgid ""
"Copy a network object denoted by a URL to a local file. If the URL points to "
"a local file, the object will not be copied unless filename is supplied. "
"Return a tuple ``(filename, headers)`` where *filename* is the local file "
"name under which the object can be found, and *headers* is whatever the :"
"meth:`!info` method of the object returned by :func:`urlopen` returned (for "
"a remote object). Exceptions are the same as for :func:`urlopen`."
msgstr ""
"Kopierar ett nätverksobjekt som anges med en URL till en lokal fil. Om URL:"
"en pekar på en lokal fil kommer objektet inte att kopieras om inte filnamnet "
"anges. Returnerar en tupel ``(filename, headers)`` där *filnamn* är det "
"lokala filnamnet under vilket objektet kan hittas, och *headers* är vad :"
"meth:`!info`-metoden för objektet som returnerades av :func:`urlopen` "
"returnerade (för ett fjärrobjekt). Undantag är desamma som för :func:"
"`urlopen`."

msgid ""
"The second argument, if present, specifies the file location to copy to (if "
"absent, the location will be a tempfile with a generated name). The third "
"argument, if present, is a callable that will be called once on "
"establishment of the network connection and once after each block read "
"thereafter.  The callable will be passed three arguments; a count of blocks "
"transferred so far, a block size in bytes, and the total size of the file.  "
"The third argument may be ``-1`` on older FTP servers which do not return a "
"file size in response to a retrieval request."
msgstr ""
"Det andra argumentet, om det finns, anger den filplats som ska kopieras till "
"(om det inte finns någon plats kommer platsen att vara en tempfil med ett "
"genererat namn). Det tredje argumentet, om det finns, är en callable som "
"kommer att anropas en gång när nätverksanslutningen upprättas och en gång "
"efter varje block som läses därefter.  Anropet får tre argument: ett antal "
"block som hittills har överförts, blockstorleken i byte och filens totala "
"storlek.  Det tredje argumentet kan vara ``-1`` på äldre FTP-servrar som "
"inte returnerar en filstorlek som svar på en hämtningsbegäran."

msgid "The following example illustrates the most common usage scenario::"
msgstr "Följande exempel illustrerar det vanligaste användningsscenariot::"

msgid ""
">>> import urllib.request\n"
">>> local_filename, headers = urllib.request.urlretrieve('http://python."
"org/')\n"
">>> html = open(local_filename)\n"
">>> html.close()"
msgstr ""
">>> import urllib.request\n"
">>> local_filename, headers = urllib.request.urlretrieve('http://python."
"org/')\n"
">>> html = öppna(lokalt_filnamn)\n"
">>> html.close()"

msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must be a bytes object in standard :"
"mimetype:`application/x-www-form-urlencoded` format; see the :func:`urllib."
"parse.urlencode` function."
msgstr ""
"Om *url* använder schemaidentifieraren :file:`http:` kan det valfria *data*-"
"argumentet anges för att specificera en ``POST``-begäran (normalt är "
"begärandetypen ``GET``).  Argumentet *data* måste vara ett bytesobjekt i "
"standardformatet :mimetype:`application/x-www-form-urlencoded`; se "
"funktionen :func:`urllib.parse.urlencode`."

msgid ""
":func:`urlretrieve` will raise :exc:`~urllib.error.ContentTooShortError` "
"when it detects that the amount of data available  was less than the "
"expected amount (which is the size reported by a  *Content-Length* header). "
"This can occur, for example, when the  download is interrupted."
msgstr ""
":func:`urlretrieve` ger upphov till :exc:`~urllib.error."
"ContentTooShortError` när den upptäcker att mängden tillgängliga data var "
"mindre än den förväntade mängden (vilket är den storlek som rapporteras av "
"en *Content-Length*-header). Detta kan t.ex. inträffa när nedladdningen "
"avbryts."

msgid ""
"The *Content-Length* is treated as a lower bound: if there's more data  to "
"read, urlretrieve reads more data, but if less data is available,  it raises "
"the exception."
msgstr ""
"*Content-Length* behandlas som en nedre gräns: om det finns mer data att "
"läsa, läser urlretrieve mer data, men om mindre data finns tillgängliga, "
"uppstår ett undantag."

msgid ""
"You can still retrieve the downloaded data in this case, it is stored in "
"the :attr:`!content` attribute of the exception instance."
msgstr ""
"Du kan fortfarande hämta de nedladdade uppgifterna i det här fallet, de "
"lagras i attributet :attr:`!content` i undantagsinstansen."

msgid ""
"If no *Content-Length* header was supplied, urlretrieve can not check the "
"size of the data it has downloaded, and just returns it.  In this case you "
"just have to assume that the download was successful."
msgstr ""
"Om ingen *Content-Length*-header har angetts kan urlretrieve inte "
"kontrollera storleken på de data den har hämtat, utan returnerar dem bara.  "
"I det här fallet får man anta att nedladdningen lyckades."

msgid ""
"Cleans up temporary files that may have been left behind by previous calls "
"to :func:`urlretrieve`."
msgstr ""
"Rensar bort temporära filer som kan ha lämnats kvar av tidigare anrop till :"
"func:`urlretrieve`."

msgid ":mod:`urllib.request` Restrictions"
msgstr ":mod:`urllib.request` Begränsningar"

msgid ""
"Currently, only the following protocols are supported: HTTP (versions 0.9 "
"and 1.0), FTP, local files, and data URLs."
msgstr ""
"För närvarande stöds endast följande protokoll: HTTP (version 0.9 och 1.0), "
"FTP, lokala filer och data-URL:er."

msgid "Added support for data URLs."
msgstr "Stöd för data-URL:er har lagts till."

msgid ""
"The caching feature of :func:`urlretrieve` has been disabled until someone "
"finds the time to hack proper processing of Expiration time headers."
msgstr ""
"Cachningsfunktionen i :func:`urlretrieve` har inaktiverats tills någon "
"hittar tid att hacka korrekt bearbetning av Expiration time-rubriker."

msgid ""
"There should be a function to query whether a particular URL is in the cache."
msgstr ""
"Det bör finnas en funktion för att fråga om en viss URL finns i cacheminnet."

msgid ""
"For backward compatibility, if a URL appears to point to a local file but "
"the file can't be opened, the URL is re-interpreted using the FTP protocol.  "
"This can sometimes cause confusing error messages."
msgstr ""
"Om en URL verkar peka på en lokal fil men filen inte kan öppnas tolkas URL:"
"en på nytt med FTP-protokollet av bakåtkompatibilitetsskäl.  Detta kan "
"ibland orsaka förvirrande felmeddelanden."

msgid ""
"The :func:`urlopen` and :func:`urlretrieve` functions can cause arbitrarily "
"long delays while waiting for a network connection to be set up.  This means "
"that it is difficult to build an interactive web client using these "
"functions without using threads."
msgstr ""
"Funktionerna :func:`urlopen` och :func:`urlretrieve` kan orsaka godtyckligt "
"långa fördröjningar i väntan på att en nätverksanslutning skall upprättas.  "
"Detta innebär att det är svårt att bygga en interaktiv webbklient med hjälp "
"av dessa funktioner utan att använda trådar."

msgid ""
"The data returned by :func:`urlopen` or :func:`urlretrieve` is the raw data "
"returned by the server.  This may be binary data (such as an image), plain "
"text or (for example) HTML.  The HTTP protocol provides type information in "
"the reply header, which can be inspected by looking at the :mailheader:"
"`Content-Type` header.  If the returned data is HTML, you can use the "
"module :mod:`html.parser` to parse it."
msgstr ""
"De data som returneras av :func:`urlopen` eller :func:`urlretrieve` är de "
"rådata som returneras av servern.  Det kan vara binära data (t.ex. en bild), "
"vanlig text eller (t.ex.) HTML.  HTTP-protokollet tillhandahåller "
"typinformation i svarshuvudet, som kan inspekteras genom att titta på :"
"mailheader:`Content-Type` -huvudet.  Om de returnerade uppgifterna är HTML "
"kan du använda modulen :mod:`html.parser` för att analysera dem."

msgid ""
"The code handling the FTP protocol cannot differentiate between a file and a "
"directory.  This can lead to unexpected behavior when attempting to read a "
"URL that points to a file that is not accessible.  If the URL ends in a ``/"
"``, it is assumed to refer to a directory and will be handled accordingly.  "
"But if an attempt to read a file leads to a 550 error (meaning the URL "
"cannot be found or is not accessible, often for permission reasons), then "
"the path is treated as a directory in order to handle the case when a "
"directory is specified by a URL but the trailing ``/`` has been left off.  "
"This can cause misleading results when you try to fetch a file whose read "
"permissions make it inaccessible; the FTP code will try to read it, fail "
"with a 550 error, and then perform a directory listing for the unreadable "
"file. If fine-grained control is needed, consider using the :mod:`ftplib` "
"module."
msgstr ""
"Koden som hanterar FTP-protokollet kan inte skilja mellan en fil och en "
"katalog.  Detta kan leda till oväntat beteende när man försöker läsa en URL "
"som pekar på en fil som inte är tillgänglig.  Om URL:en slutar med ``/`` "
"antas den hänvisa till en katalog och hanteras därefter.  Men om ett försök "
"att läsa en fil leder till ett 550-fel (vilket innebär att URL:en inte kan "
"hittas eller inte är tillgänglig, ofta av behörighetsskäl), behandlas "
"sökvägen som en katalog för att hantera fallet när en katalog anges av en "
"URL men den efterföljande ``/`` har utelämnats.  Detta kan leda till "
"missvisande resultat när du försöker hämta en fil som inte kan läsas på "
"grund av läsbehörigheter. FTP-koden försöker läsa den, misslyckas med ett "
"550-fel och utför sedan en kataloglistning för den oläsbara filen. Om du "
"behöver mer detaljerad kontroll bör du överväga att använda modulen :mod:"
"`ftplib`."

msgid ":mod:`urllib.response` --- Response classes used by urllib"
msgstr ":mod:`urllib.response` --- Svarsklasser som används av urllib"

msgid ""
"The :mod:`urllib.response` module defines functions and classes which define "
"a minimal file-like interface, including ``read()`` and ``readline()``. "
"Functions defined by this module are used internally by the :mod:`urllib."
"request` module. The typical response object is a :class:`urllib.response."
"addinfourl` instance:"
msgstr ""
"Modulen :mod:`urllib.response` definierar funktioner och klasser som "
"definierar ett minimalt filliknande gränssnitt, inklusive ``read()`` och "
"``readline()``. Funktioner som definieras av denna modul används internt av "
"modulen :mod:`urllib.request`. Det typiska svarsobjektet är en :class:"
"`urllib.response.addinfourl`-instans:"

msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr ""
"URL för den hämtade resursen, används vanligen för att avgöra om en "
"omdirigering följdes."

msgid ""
"Returns the headers of the response in the form of an :class:`~email.message."
"EmailMessage` instance."
msgstr ""
"Returnerar svarets rubriker i form av en :class:`~email.message."
"EmailMessage`-instans."

msgid "Status code returned by server."
msgstr "Statuskod som returneras av servern."

msgid "Deprecated in favor of :attr:`~addinfourl.url`."
msgstr "Föråldrad till förmån för :attr:`~addinfourl.url`."

msgid "Deprecated in favor of :attr:`~addinfourl.headers`."
msgstr "Föråldrad till förmån för :attr:`~addinfourl.headers`."

msgid "Deprecated in favor of :attr:`~addinfourl.status`."
msgstr "Föråldrad till förmån för :attr:`~addinfourl.status`."

msgid "HTTP"
msgstr "HTTP"

msgid "protocol"
msgstr "protokoll"

msgid "FTP"
msgstr "FTP"

msgid "HTML"
msgstr "HTML"
