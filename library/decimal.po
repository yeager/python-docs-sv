# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!decimal` --- Decimal fixed-point and floating-point arithmetic"
msgstr ""
":mod:`!decimal` --- Decimal aritmetik med fasta och flytande kommatecken"

msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**Källkod:** :source:`Lib/decimal.py`"

msgid ""
"The :mod:`decimal` module provides support for fast correctly rounded "
"decimal floating-point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ""
"Modulen :mod:`decimal` ger stöd för snabb, korrekt avrundad decimal "
"aritmetik med flyttal. Den erbjuder flera fördelar jämfört med datatypen :"
"class:`float`:"

msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Decimal \"är baserat på en flyttalsmodell som utformades med människor i "
"åtanke och som nödvändigtvis har en överordnad vägledande princip - datorer "
"måste tillhandahålla en aritmetik som fungerar på samma sätt som den "
"aritmetik som människor lär sig i skolan.\" -- Utdrag ur specifikationen för "
"decimal aritmetik."

msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like "
"``1.1`` and ``2.2`` do not have exact representations in binary floating "
"point. End users typically would not expect ``1.1 + 2.2`` to display as "
"``3.3000000000000003`` as it does with binary floating point."
msgstr ""
"Decimaltal kan representeras exakt.  Däremot har tal som ``1,1`` och ``2,2`` "
"inte exakta representationer i binär flyttal. Slutanvändare förväntar sig "
"vanligtvis inte att ``1,1 + 2,2`` ska visas som ``3,3000000000000003`` som "
"det gör med binär flyttal."

msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is ``5.5511151231257827e-017``.  While near to zero, the "
"differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"Exaktheten överförs till aritmetik.  I decimal flyttal är ``0,1 + 0,1 + 0,1 "
"- 0,3`` exakt lika med noll.  I binär flyttal blir resultatet "
"``5,5511151231257827e-017``.  Även om skillnaderna är nära noll förhindrar "
"de tillförlitlig jämlikhetstestning och skillnaderna kan ackumuleras. Av "
"denna anledning föredras decimal i bokföringsapplikationer som har strikta "
"jämlikhetsinvarianter."

msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is ``2.50``.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives ``1.56`` while ``1.30 * "
"1.20`` gives ``1.5600``."
msgstr ""
"Decimalmodulen innehåller ett begrepp om signifikanta ställen så att ``1,30 "
"+ 1,20`` är ``2,50``.  Den efterföljande nollan behålls för att indikera "
"signifikans. Detta är den gängse presentationen för monetära tillämpningar. "
"Vid multiplikation används enligt \"skolboken\" alla siffror i "
"multiplikanden.  Till exempel ger ``1,3 * 1,2`` ``1,56`` medan ``1,30 * "
"1,20`` ger ``1,5600``."

msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""
"Till skillnad från maskinvarubaserad binär flyttalsräkning har "
"decimalmodulen en precision som kan ändras av användaren (standard är 28 "
"enheter) och som kan vara så stor som behövs för ett visst problem:"

msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"Både binär och decimal flyttal implementeras i enlighet med publicerade "
"standarder.  Medan den inbyggda float-typen bara visar en blygsam del av "
"sina möjligheter, visar decimalmodulen alla nödvändiga delar av standarden. "
"När det behövs har programmeraren full kontroll över avrundning och "
"signalhantering. Detta inkluderar ett alternativ för att genomdriva exakt "
"aritmetik genom att använda undantag för att blockera alla inexakta "
"operationer."

msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Decimalmodulen utformades för att \"utan fördomar stödja både exakt "
"oavrundad decimalaritmetik (ibland kallad fastpunktsaritmetik) och avrundad "
"flyttalsaritmetik\"  -- Utdrag ur specifikationen för decimalaritmetik."

msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""
"Modulens design är centrerad kring tre koncept: decimaltalet, sammanhanget "
"för aritmetik och signaler."

msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as ``Infinity``, "
"``-Infinity``, and ``NaN``.  The standard also differentiates ``-0`` from "
"``+0``."
msgstr ""
"Ett decimaltal är oföränderligt.  Det har ett tecken, koefficientsiffror och "
"en exponent.  För att bevara signifikansen trunkeras inte nollorna i "
"koefficientsiffrorna.  Decimaltal innehåller också specialvärden som "
"``Oändlighet``, ``Oändlighet`` och ``NaN``.  Standarden skiljer också mellan "
"``-0`` och ``+0``."

msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"Kontexten för aritmetik är en miljö som anger precision, avrundningsregler, "
"gränser för exponenter, flaggor som anger resultatet av operationer och trap "
"enablers som avgör om signaler ska behandlas som undantag.  "
"Avrundningsalternativ inkluderar :const:`ROUND_CEILING`, :const:"
"`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:"
"`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:`ROUND_UP` och :const:"
"`ROUND_05UP`."

msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"Signaler är grupper av exceptionella förhållanden som uppstår under "
"beräkningarnas gång.  Beroende på applikationens behov kan signaler "
"ignoreras, betraktas som information eller behandlas som undantag. "
"Signalerna i decimalmodulen är: :const:`Clamped`, :const:"
"`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, :const:"
"`Rounded`, :const:`Subnormal`, :const:`Overflow`, :const:`Underflow` och :"
"const:`FloatOperation`."

msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"För varje signal finns det en flagga och en fällaktiverare.  När en signal "
"påträffas sätts dess flagga till ett, och om trap enabler sätts till ett "
"utlöses ett undantag.  Flaggor är \"sticky\", så användaren måste återställa "
"dem innan han/hon övervakar en beräkning."

msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"IBM:s allmänna decimalaritmetiska specifikation, \"The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."

msgid "Quick-start tutorial"
msgstr "Handledning för snabbstart"

msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"Den vanliga starten för att använda decimaler är att importera modulen, se "
"den aktuella kontexten med :func:`getcontext` och, om nödvändigt, ange nya "
"värden för precision, avrundning eller aktiverade fällor::"

msgid ""
">>> from decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7       # Set a new precision"
msgstr ""
">>> från decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, avrundning=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capital=1, clamp=0, flags=[], traps=[Överflöde, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7 # Ställ in en ny precision"

msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as ``NaN`` which stands for \"Not a number\", positive and "
"negative ``Infinity``, and ``-0``::"
msgstr ""
"Decimalinstanser kan konstrueras från heltal, strängar, flyttal eller "
"tupler. Konstruktion från ett heltal eller en float utför en exakt "
"konvertering av värdet för det heltalet eller floaten.  Decimaltal "
"innehåller specialvärden som ``NaN`` som står för \"Not a number\", positiva "
"och negativa ``Infinity``, och ``-0``::"

msgid ""
">>> getcontext().prec = 28\n"
">>> Decimal(10)\n"
"Decimal('10')\n"
">>> Decimal('3.14')\n"
"Decimal('3.14')\n"
">>> Decimal(3.14)\n"
"Decimal('3.140000000000000124344978758017532527446746826171875')\n"
">>> Decimal((0, (3, 1, 4), -2))\n"
"Decimal('3.14')\n"
">>> Decimal(str(2.0 ** 0.5))\n"
"Decimal('1.4142135623730951')\n"
">>> Decimal(2) ** Decimal('0.5')\n"
"Decimal('1.414213562373095048801688724')\n"
">>> Decimal('NaN')\n"
"Decimal('NaN')\n"
">>> Decimal('-Infinity')\n"
"Decimal('-Infinity')"
msgstr ""
">>> getcontext().prec = 28\n"
">>> Decimal(10)\n"
"Decimal('10')\n"
">>> Decimal('3,14')\n"
"Decimal('3.14')\n"
">>> Decimal(3.14)\n"
"Decimal('3.140000000000000124344978758017532527446746826171875')\n"
">>> Decimal((0, (3, 1, 4), -2))\n"
"Decimal('3.14')\n"
">>> Decimal(str(2,0 ** 0,5))\n"
"Decimal('1.4142135623730951')\n"
">>> Decimal(2) ** Decimal('0.5')\n"
"Decimal('1.414213562373095048801688724')\n"
">>> Decimal('NaN')\n"
"Decimal('NaN')\n"
">>> Decimal('-Infinity')\n"
"Decimal('-Infinity')"

msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
"Om signalen :exc:`FloatOperation` är fångad, kommer oavsiktlig blandning av "
"decimaler och flyttal i konstruktörer eller orderjämförelser att ge upphov "
"till ett undantag::"

msgid ""
">>> c = getcontext()\n"
">>> c.traps[FloatOperation] = True\n"
">>> Decimal(3.14)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') < 3.7\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') == 3.5\n"
"True"
msgstr ""
"&gt;&gt;&gt; c = hämta kontext()\n"
"&gt;&gt;&gt; c.traps[FloatOperation] = True\n"
"&gt;&gt;&gt; Decimal(3,14)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
"&gt;&gt;&gt; Decimal('3,5') &lt; 3,7\n"
"Återkoppling (senaste anropet senast):\n"
"  Fil \"&lt;stdin&gt;\", rad 1, i <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
"&gt;&gt;&gt; Decimal('3,5') == 3,5\n"
"Sant"

msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"Betydelsen av en ny decimal bestäms enbart av antalet inmatade siffror.  "
"Kontextens precision och avrundning spelar bara in under aritmetiska "
"operationer."

msgid ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"
msgstr ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"

msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr ""
"Om de interna gränserna för C-versionen överskrids, ger konstruktionen av en "
"decimal :class:`InvalidOperation`::"

msgid ""
">>> Decimal(\"1e9999999999999999999\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]"
msgstr ""
"&gt;&gt;&gt; Decimal(\"1e9999999999999999999\")\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]"

msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating-point flying circus:"
msgstr ""
"Decimaler samverkar bra med mycket av resten av Python.  Här är en liten "
"flygande cirkus med decimala flyttal:"

msgid ""
">>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))\n"
">>> max(data)\n"
"Decimal('9.25')\n"
">>> min(data)\n"
"Decimal('0.03')\n"
">>> sorted(data)\n"
"[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),\n"
" Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]\n"
">>> sum(data)\n"
"Decimal('19.29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.34\n"
">>> round(a, 1)\n"
"Decimal('1.3')\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6.70')\n"
">>> a * b\n"
"Decimal('2.5058')\n"
">>> c % a\n"
"Decimal('0.77')"
msgstr ""
">>> data = list(map(Decimal, '1,34 1,87 3,45 2,35 1,00 0,03 9,25'."
"split())))\n"
">>> max(data)\n"
"Decimal('9,25')\n"
">>> min(data)\n"
"Decimal('0,03')\n"
">>> sorterad(data)\n"
"[Decimal('0,03'), Decimal('1,00'), Decimal('1,34'), Decimal('1,87'),\n"
" Decimal('2,35'), Decimal('3,45'), Decimal('9,25')]\n"
">>> sum(data)\n"
"Decimal('19,29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.34\n"
">>> runda(a, 1)\n"
"Decimal('1,3')\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6,70')\n"
">>> a * b\n"
"Decimal('2,5058')\n"
">>> c % a\n"
"Decimal('0,77')"

msgid "And some mathematical functions are also available to Decimal:"
msgstr "Och vissa matematiska funktioner är också tillgängliga för Decimal:"

msgid ""
"The :meth:`~Decimal.quantize` method rounds a number to a fixed exponent.  "
"This method is useful for monetary applications that often round results to "
"a fixed number of places:"
msgstr ""
"Metoden :meth:`~Decimal.quantize` avrundar ett tal till en fast exponent.  "
"Denna metod är användbar för monetära applikationer som ofta avrundar "
"resultat till ett fast antal enheter:"

msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""
"Som visas ovan får funktionen :func:`getcontext` tillgång till det aktuella "
"sammanhanget och gör det möjligt att ändra inställningarna.  Detta "
"tillvägagångssätt uppfyller behoven i de flesta applikationer."

msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""
"För mer avancerat arbete kan det vara användbart att skapa alternativa "
"kontexter med hjälp av Context()-konstruktören.  För att göra en alternativ "
"kontext aktiv, använd funktionen :func:`setcontext`."

msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
"I enlighet med standarden tillhandahåller modulen :mod:`decimal` två "
"standardkontexter som är färdiga att använda, :const:`BasicContext` och :"
"const:`ExtendedContext`. Den förstnämnda är speciellt användbar för "
"felsökning eftersom många av fällorna är aktiverade:"

msgid ""
">>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Infinity')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#143>\", line 1, in -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""
">>> myothercontext = Context(prec=60, avrundning=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        huvudstäder=1, clamp=0, flaggor=[], fällor=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Oändlighet')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<pyshell#143>\", rad 1, i -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"

msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`~Context.clear_flags` method. ::"
msgstr ""
"Kontexter har också signalflaggor för övervakning av exceptionella "
"förhållanden som uppstår under beräkningar.  Flaggorna förblir inställda "
"tills de uttryckligen rensas, så det är bäst att rensa flaggorna före varje "
"uppsättning av övervakade beräkningar genom att använda metoden :meth:"
"`~Context.clear_flags`. ::"

msgid ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])"
msgstr ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        versaler=1, clamp=0, flaggor=[Inexakt, Avrundad], fällor=[])"

msgid ""
"The *flags* entry shows that the rational approximation to pi was rounded "
"(digits beyond the context precision were thrown away) and that the result "
"is inexact (some of the discarded digits were non-zero)."
msgstr ""
"Posten *flags* visar att den rationella approximationen av pi avrundades "
"(siffror utanför kontextprecisionen kastades bort) och att resultatet är "
"inexakt (några av de bortkastade siffrorna var andra än noll)."

msgid ""
"Individual traps are set using the dictionary in the :attr:`~Context.traps` "
"attribute of a context:"
msgstr ""
"Enskilda fällor ställs in med hjälp av ordlistan i attributet :attr:"
"`~Context.traps` i en kontext:"

msgid ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#112>\", line 1, in -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<pyshell#112>\", rad 1, i -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"

msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"De flesta program justerar den aktuella kontexten endast en gång, i början "
"av programmet.  Och i många applikationer konverteras data till :class:"
"`Decimal` med en enda cast inuti en loop.  När kontexten är inställd och "
"decimaler skapade, manipulerar huvuddelen av programmet data på samma sätt "
"som med andra numeriska Python-typer."

msgid "Decimal objects"
msgstr "Decimala objekt"

msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "Konstruera ett nytt :class:`Decimal`-objekt baserat på *värde*."

msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*value* kan vara ett heltal, en sträng, en tupel, :class:`float` eller ett "
"annat :class:`Decimal`-objekt. Om inget *värde* anges returneras "
"``Decimal('0')``.  Om *värde* är en sträng bör den överensstämma med den "
"decimala numeriska strängsyntaxen efter att inledande och avslutande "
"blankstegstecken, samt understrykningstecken, har tagits bort::"

msgid ""
"sign           ::=  '+' | '-'\n"
"digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | "
"'9'\n"
"indicator      ::=  'e' | 'E'\n"
"digits         ::=  digit [digit]...\n"
"decimal-part   ::=  digits '.' [digits] | ['.'] digits\n"
"exponent-part  ::=  indicator [sign] digits\n"
"infinity       ::=  'Infinity' | 'Inf'\n"
"nan            ::=  'NaN' [digits] | 'sNaN' [digits]\n"
"numeric-value  ::=  decimal-part [exponent-part] | infinity\n"
"numeric-string ::=  [sign] numeric-value | [sign] nan"
msgstr ""
"tecken ::= '+' | '-'\n"
"siffra ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n"
"indikator ::= 'e' | 'E'\n"
"siffror ::= siffra [siffra]...\n"
"decimal-del ::= siffror '.' [siffror] | ['.'] siffror\n"
"exponent-del ::= indikator [tecken] siffror\n"
"infinity ::= 'Oändlighet' | 'Inf'\n"
"nan ::= 'NaN' [siffror] | 'sNaN' [siffror]\n"
"numeriskt värde ::= decimaldel [exponentdel] | oändlighet\n"
"numerisk-sträng ::= [tecken] numeriskt-värde | [tecken] nan"

msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``. Case is not significant, so, for "
"example, ``inf``, ``Inf``, ``INFINITY``, and ``iNfINity`` are all acceptable "
"spellings for positive infinity."
msgstr ""
"Andra Unicode decimalsiffror är också tillåtna där ``digit`` visas ovan.  "
"Dessa inkluderar decimalsiffror från olika andra alfabet (till exempel "
"arabisk-indiska och Devanāgarī-siffror) tillsammans med fullbreddssiffrorna "
"``'\\uff10`` till ``'\\uff19``. Versal är inte signifikant, så till exempel "
"``inf``, ``Inf``, ``INFINITY`` och ``iNfINity`` är alla acceptabla "
"stavningar för positiv oändlighet."

msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign "
"(``0`` for positive or ``1`` for negative), a :class:`tuple` of digits, and "
"an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))`` returns "
"``Decimal('1.414')``."
msgstr ""
"Om *värde* är en :class:`tupel` ska den ha tre komponenter, ett tecken "
"(``0`` för positiv eller ``1`` för negativ), en :class:`tupel` av siffror "
"och en heltalsexponent. Till exempel ger ``Decimal((0, (1, 4, 1, 4), -3))`` "
"``Decimal('1.414')``."

msgid ""
"If *value* is a :class:`float`, the binary floating-point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"Om *värde* är en :class:`float` konverteras det binära flyttalsvärdet "
"förlustfritt till sin exakta decimala motsvarighet.  Denna konvertering kan "
"ofta kräva 53 eller fler precisionssiffror.  Till exempel konverterar "
"``Decimal(float('1.1'))`` till "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."

msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"Precisionen i *kontexten* påverkar inte hur många siffror som lagras. Det "
"bestäms uteslutande av antalet siffror i *värdet*. Till exempel, "
"``Decimal('3.00000')`` registrerar alla fem nollor även om "
"kontextprecisionen bara är tre."

msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of ``NaN``."
msgstr ""
"Syftet med argumentet *context* är att bestämma vad som ska göras om *value* "
"är en felformad sträng.  Om kontexten fångar :const:`InvalidOperation`, "
"väcks ett undantag; i annat fall returnerar konstruktören en ny Decimal med "
"värdet ``NaN``."

msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "När :class:`Decimal`-objekt har konstruerats är de oföränderliga."

msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr "Argumentet till konstruktören får nu vara en :class:`float`-instans."

msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
":class:`float`-argument ger upphov till ett undantag om :exc:"
"`FloatOperation`-fällan är inställd. Som standard är fällan avstängd."

msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr ""
"Underscores är tillåtna för gruppering, som med integral- och "
"flyttalslitteraler i kod."

msgid ""
"Decimal floating-point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""
"Decimala flyttalsobjekt delar många egenskaper med de andra inbyggda "
"numeriska typerna, t.ex. :class:`float` och :class:`int`.  Alla vanliga "
"matematiska operationer och specialmetoder gäller.  På samma sätt kan "
"decimalobjekt kopieras, betas, skrivas ut, användas som ordboksnycklar, "
"användas som set-element, jämföras, sorteras och tvingas till en annan typ "
"(t.ex. :class:`float` eller :class:`int`)."

msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"Det finns några små skillnader mellan aritmetik på decimalobjekt och "
"aritmetik på heltal och flyttal.  När restoperatorn ``%`` används på "
"decimalobjekt är resultatets tecken tecknet på *divisorn* i stället för "
"tecknet på divisorn::"

msgid ""
">>> (-7) % 4\n"
"1\n"
">>> Decimal(-7) % Decimal(4)\n"
"Decimal('-3')"
msgstr ""
">>> (-7) % 4\n"
"1\n"
">>> Decimal(-7) % Decimal(4)\n"
"Decimal('-3')"

msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"Operatorn för heltalsdivision ``//`` fungerar på samma sätt och returnerar "
"heltalsdelen av den verkliga kvoten (trunkerad mot noll) i stället för dess "
"golv, så att den vanliga identiteten ``x == (x // y) * y + x % y`` bevaras::"

msgid ""
">>> -7 // 4\n"
"-2\n"
">>> Decimal(-7) // Decimal(4)\n"
"Decimal('-1')"
msgstr ""
">>> -7 // 4\n"
"-2\n"
">>> Decimal(-7) // Decimal(4)\n"
"Decimal('-1')"

msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"Operatorerna ``%`` och ``//`` implementerar operationerna ``remainder`` "
"respektive ``divide-integer`` enligt beskrivningen i specifikationen."

msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Decimalobjekt kan i allmänhet inte kombineras med float eller instanser av :"
"class:`fractions.Fraction` i aritmetiska operationer: ett försök att lägga "
"till en :class:`Decimal` till en :class:`float`, till exempel, kommer att ge "
"upphov till ett :exc:`TypeError`.  Det är dock möjligt att använda Pythons "
"jämförelseoperatorer för att jämföra en :class:`Decimal`-instans ``x`` med "
"ett annat tal ``y``.  Detta undviker förvirrande resultat när man gör "
"jämlikhetsjämförelser mellan tal av olika typer."

msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr ""
"Jämförelser av blandade typer mellan :class:`Decimal`-instanser och andra "
"numeriska typer stöds nu fullt ut."

msgid ""
"In addition to the standard numeric properties, decimal floating-point "
"objects also have a number of specialized methods:"
msgstr ""
"Förutom de numeriska standardegenskaperna har decimala flyttalsobjekt också "
"ett antal specialiserade metoder:"

msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"Returnerar den justerade exponenten efter att koefficientens högra siffror "
"har flyttats ut tills endast den första siffran återstår: "
"``Decimal('321e+5').adjusted()`` returnerar sju.  Används för att bestämma "
"positionen för den mest signifikanta siffran i förhållande till "
"decimaltecknet."

msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr ""
"Returnerar ett par ``(n, d)`` av heltal som representerar den givna :class:"
"`Decimal`-instansen som ett bråk, i lägsta termer och med en positiv "
"nämnare::"

msgid ""
">>> Decimal('-3.14').as_integer_ratio()\n"
"(-157, 50)"
msgstr ""
">>> Decimal('-3,14').as_integer_ratio()\n"
"(-157, 50)"

msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr ""
"Omvandlingen är exakt.  Ge upphov till OverflowError för oändligheter och "
"ValueError för NaNs."

msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"Returnera en :term:`named tuple` representation av talet: "
"``DecimalTuple(sign, digits, exponent)``."

msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""
"Returnerar den kanoniska kodningen av argumentet.  För närvarande är "
"kodningen av en :class:`Decimal`-instans alltid kanonisk, så denna operation "
"returnerar sitt argument oförändrat."

msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"Jämför värdena för två decimalinstanser. :meth:`compare` returnerar en "
"decimalinstans, och om någon av operanderna är ett NaN blir resultatet ett "
"NaN::"

msgid ""
"a or b is a NaN  ==> Decimal('NaN')\n"
"a < b            ==> Decimal('-1')\n"
"a == b           ==> Decimal('0')\n"
"a > b            ==> Decimal('1')"
msgstr ""
"a eller b är en NaN ==> Decimal('NaN')\n"
"a < b ==> Decimal('-1')\n"
"a == b ==> Decimal('0')\n"
"a > b ==> Decimal('1')"

msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"Denna operation är identisk med metoden :meth:`compare`, förutom att alla "
"NaN signalerar.  Det vill säga, om ingen av operanderna är ett signalerande "
"NaN, behandlas varje tyst NaN-operand som om det vore ett signalerande NaN."

msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"Jämför två operander med hjälp av deras abstrakta representation snarare än "
"deras numeriska värde.  Liknar metoden :meth:`compare`, men resultatet ger "
"en total ordning på :class:`Decimal`-instanser.  Två :class:`Decimal`-"
"instanser med samma numeriska värde men olika representationer jämförs "
"ojämlikt i denna ordning:"

msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"Tysta och signalerande NaNs ingår också i den totala ordningen.  Resultatet "
"av denna funktion är ``Decimal('0')`` om båda operanderna har samma "
"representation, ``Decimal('-1')`` om den första operanden är lägre i den "
"totala ordningen än den andra, och ``Decimal('1')`` om den första operanden "
"är högre i den totala ordningen än den andra operanden.  Se specifikationen "
"för detaljer om den totala ordningen."

msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"Denna operation påverkas inte av kontexten och är tyst: inga flaggor ändras "
"och ingen avrundning utförs.  Som ett undantag kan C-versionen ge upphov "
"till InvalidOperation om den andra operanden inte kan konverteras exakt."

msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"Jämför två operander med hjälp av deras abstrakta representation i stället "
"för deras värde som i :meth:`compare_total`, men ignorerar tecknet för varje "
"operand. ``x.compare_total_mag(y)`` är ekvivalent med ``x.copy_abs()."
"compare_total(y.copy_abs())``."

msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""
"Returnerar bara self, denna metod är endast till för att uppfylla Decimal "
"Specification."

msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Returnerar argumentets absoluta värde.  Denna operation påverkas inte av "
"kontexten och är tyst: inga flaggor ändras och ingen avrundning utförs."

msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Returnerar negationen av argumentet.  Denna operation påverkas inte av "
"kontexten och är tyst: inga flaggor ändras och ingen avrundning utförs."

msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr ""
"Returnerar en kopia av det första operandet med tecknet satt till samma som "
"tecknet för det andra operandet.  Till exempel"

msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""
"Returnerar värdet av den (naturliga) exponentialfunktionen ``e**x`` vid det "
"angivna talet.  Resultatet avrundas korrekt med hjälp av avrundningsläget :"
"const:`ROUND_HALF_EVEN`."

msgid ""
"Alternative constructor that only accepts instances of :class:`float` or :"
"class:`int`."
msgstr ""
"Alternativ konstruktör som endast accepterar instanser av :class:`float` "
"eller :class:`int`."

msgid ""
"Note ``Decimal.from_float(0.1)`` is not the same as ``Decimal('0.1')``. "
"Since 0.1 is not exactly representable in binary floating point, the value "
"is stored as the nearest representable value which is "
"``0x1.999999999999ap-4``.  That equivalent value in decimal is "
"``0.1000000000000000055511151231257827021181583404541015625``."
msgstr ""
"Observera att ``Decimal.from_float(0.1)`` inte är detsamma som "
"``Decimal('0.1')``. Eftersom 0,1 inte är exakt representerbart i binär "
"flyttal lagras värdet som det närmaste representerbara värdet som är "
"``0x1.999999999999ap-4``.  Det motsvarande värdet i decimal är "
"\"0,1000000000000000055511151231257827021181583404541015625\"."

msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr ""
"Från Python 3.2 och framåt kan en :class:`Decimal`-instans också konstrueras "
"direkt från en :class:`float`."

msgid ""
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_float(float('nan'))\n"
"Decimal('NaN')\n"
">>> Decimal.from_float(float('inf'))\n"
"Decimal('Infinity')\n"
">>> Decimal.from_float(float('-inf'))\n"
"Decimal('-Infinity')"
msgstr ""
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_float(float('nan'))\n"
"Decimal('NaN')\n"
">>> Decimal.from_float(float('inf'))\n"
"Decimal('Infinity')\n"
">>> Decimal.from_float(float('-inf'))\n"
"Decimal('-Oändlighet')"

msgid ""
"Alternative constructor that only accepts instances of :class:`float`, :"
"class:`int` or :class:`Decimal`, but not strings or tuples."
msgstr ""
"Alternativ konstruktör som endast accepterar instanser av :class:`float`, :"
"class:`int` eller :class:`Decimal`, men inte strängar eller tupler."

msgid ""
">>> Decimal.from_number(314)\n"
"Decimal('314')\n"
">>> Decimal.from_number(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_number(Decimal('3.14'))\n"
"Decimal('3.14')"
msgstr ""
">>> Decimal.from_number(314)\n"
"Decimal('314')\n"
">>> Decimal.from_number(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_number(Decimal('3.14'))\n"
"Decimal('3.14')"

msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"Fusionerad multiplicera-add.  Returnera self*other+third utan avrundning av "
"mellanprodukten self*other."

msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"Returnerar :const:`True` om argumentet är kanoniskt och :const:`False` "
"annars.  För närvarande är en :class:`Decimal`-instans alltid kanonisk, så "
"denna operation returnerar alltid :const:`True`."

msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"Returnerar :const:`True` om argumentet är ett ändligt tal, och :const:"
"`False` om argumentet är oändligt eller NaN."

msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""
"Returnerar :const:`True` om argumentet är antingen positiv eller negativ "
"oändlighet och :const:`False` annars."

msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""
"Returnerar :const:`True` om argumentet är en (tyst eller signalerande) NaN "
"och :const:`False` annars."

msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"Returnerar :const:`True` om argumentet är ett *normalt* ändligt tal.  "
"Returnerar :const:`False` om argumentet är noll, subnormalt, oändligt eller "
"ett NaN."

msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""
"Returnerar :const:`True` om argumentet är ett tyst NaN, och :const:`False` i "
"annat fall."

msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"Returnerar :const:`True` om argumentet har ett negativt tecken och :const:"
"`False` annars.  Observera att både nollor och NaNs kan ha tecken."

msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""
"Returnerar :const:`True` om argumentet är en NaN-signal och :const:`False` "
"annars."

msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"Returnerar :const:`True` om argumentet är subnormal, och :const:`False` "
"annars."

msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""
"Returnerar :const:`True` om argumentet är en (positiv eller negativ) nolla "
"och :const:`False` annars."

msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Returnerar den naturliga (bas e) logaritmen av operanden.  Resultatet "
"avrundas korrekt med hjälp av avrundningsläget :const:`ROUND_HALF_EVEN`."

msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Returnerar bas tio logaritmen av operanden.  Resultatet är korrekt avrundat "
"med :const:`ROUND_HALF_EVEN` avrundningsläge."

msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"För ett tal som inte är noll, returneras den justerade exponenten för "
"operanden som en :class:`Decimal`-instans.  Om operanden är en nolla "
"returneras ``Decimal('-Infinity')`` och flaggan :const:`DivisionByZero`` "
"aktiveras.  Om operanden är en oändlighet returneras ``Decimal('Infinity')``."

msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`logical_and` är en logisk operation som tar två *logiska operander* "
"(se :ref:`logical_operands_label`).  Resultatet är det siffervisa ``och`` av "
"de två operanderna."

msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ""
":meth:`logical_invert` är en logisk operation.  Resultatet är den "
"siffermässiga inverteringen av operanden."

msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`logical_or` är en logisk operation som tar två *logiska operander* "
"(se :ref:`logical_operands_label`).  Resultatet är det siffervisa ``eller`` "
"av de två operanderna."

msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`logical_xor` är en logisk operation som tar två *logiska operander* "
"(se :ref:`logical_operands_label`).  Resultatet är det siffermässigt "
"uteslutande eller av de två operanderna."

msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Som ``max(self, other)`` förutom att kontextens avrundningsregel tillämpas "
"innan den returneras och att ``NaN``-värden antingen signaleras eller "
"ignoreras (beroende på kontexten och om de är signalerande eller tysta)."

msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Påminner om metoden :meth:`.max`, men jämförelsen görs med hjälp av "
"operandernas absoluta värden."

msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Som ``min(self, other)`` förutom att kontextens avrundningsregel tillämpas "
"innan den returneras och att ``NaN``-värden antingen signaleras eller "
"ignoreras (beroende på kontexten och om de är signalerande eller tysta)."

msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Påminner om metoden :meth:`.min`, men jämförelsen görs med hjälp av "
"operandernas absoluta värden."

msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""
"Returnerar det största tal som kan representeras i den givna kontexten "
"(eller i den aktuella trådens kontext om ingen kontext anges) som är mindre "
"än den givna operanden."

msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"Returnerar det minsta tal som kan representeras i den givna kontexten (eller "
"i den aktuella trådens kontext om ingen kontext anges) som är större än den "
"givna operanden."

msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"Om de två operanderna är olika, returneras det tal som ligger närmast den "
"första operanden i riktning mot den andra operanden.  Om båda operanderna är "
"numeriskt lika, returneras en kopia av den första operanden med tecknet satt "
"till samma som tecknet för den andra operanden."

msgid ""
"Used for producing canonical values of an equivalence class within either "
"the current context or the specified context."
msgstr ""
"Används för att producera kanoniska värden för en ekvivalensklass inom "
"antingen den aktuella kontexten eller den angivna kontexten."

msgid ""
"This has the same semantics as the unary plus operation, except that if the "
"final result is finite it is reduced to its simplest form, with all trailing "
"zeros removed and its sign preserved. That is, while the coefficient is non-"
"zero and a multiple of ten the coefficient is divided by ten and the "
"exponent is incremented by 1. Otherwise (the coefficient is zero) the "
"exponent is set to 0. In all cases the sign is unchanged."
msgstr ""
"Detta har samma semantik som den unära plusoperationen, förutom att om "
"slutresultatet är ändligt reduceras det till sin enklaste form, med alla "
"efterföljande nollor borttagna och dess tecken bevarat. Det vill säga, om "
"koefficienten inte är noll och är en multipel av tio divideras koefficienten "
"med tio och exponenten ökas med 1. I annat fall (koefficienten är noll) "
"sätts exponenten till 0. I samtliga fall är tecknet oförändrat."

msgid ""
"For example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both "
"normalize to the equivalent value ``Decimal('32.1')``."
msgstr ""
"Till exempel normaliseras ``Decimal('32.100')`` och "
"``Decimal('0.321000e+2')`` båda till det likvärdiga värdet "
"``Decimal('32.1')``."

msgid "Note that rounding is applied *before* reducing to simplest form."
msgstr "Observera att avrundning görs *innan* reducering till enklaste form."

msgid ""
"In the latest versions of the specification, this operation is also known as "
"``reduce``."
msgstr ""
"I de senaste versionerna av specifikationen kallas denna operation även för "
"\"reducera\"."

msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""
"Returnerar en sträng som beskriver operandens *klass*.  Det returnerade "
"värdet är en av följande tio strängar."

msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr ""
"``\"-Infinity\"``, vilket indikerar att operanden är negativ oändlighet."

msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr ""
"``\"-Normal\"``, vilket indikerar att operanden är ett negativt normaltal."

msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr ""
"``\"-Subnormal\"``, vilket indikerar att operanden är negativ och subnormal."

msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, vilket indikerar att operanden är en negativ nolla."

msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, vilket indikerar att operanden är en positiv nolla."

msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr ""
"``\"+Subnormal\"``, vilket indikerar att operanden är positiv och subnormal."

msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr ""
"``\"+Normal\"``, vilket indikerar att operanden är ett positivt normalt tal."

msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr ""
"``\"+Infinity\"``, vilket indikerar att operanden är positiv oändlighet."

msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr ""
"``\"NaN\"``, vilket indikerar att operanden är ett tyst NaN (Not a Number)."

msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, vilket indikerar att operanden är en NaN-signal."

msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""
"Returnerar ett värde som är lika med den första operanden efter avrundning "
"och med den andra operandens exponent."

msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"Till skillnad från andra operationer, om koefficientens längd efter "
"kvantiseringsoperationen skulle vara större än precisionen, så signaleras "
"en :const:`InvalidOperation`. Detta garanterar att den kvantiserade "
"exponenten alltid är lika med den högra operandens exponent, såvida inte ett "
"feltillstånd föreligger."

msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""
"Till skillnad från andra operationer signalerar quantize aldrig underflöde, "
"även om resultatet är onormalt och inexakt."

msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"Om exponenten i den andra operanden är större än i den första kan avrundning "
"vara nödvändig.  I detta fall bestäms avrundningssättet av argumentet "
"``rounding`` om det ges, annars av det givna argumentet ``context``; om "
"inget av argumenten ges används avrundningssättet för den aktuella trådens "
"kontext."

msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`~Context.Emax` or less than :meth:`~Context.Etiny`."
msgstr ""
"Ett fel returneras när den resulterande exponenten är större än :attr:"
"`~Context.Emax` eller mindre än :meth:`~Context.Etiny`."

msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""
"Returnerar ``Decimal(10)``, den radix (bas) i vilken :class:`Decimal`-"
"klassen gör all sin aritmetik.  Inkluderad för kompatibilitet med "
"specifikationen."

msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"Returnerar resten från att dividera *self* med *other*.  Detta skiljer sig "
"från ``self % other`` genom att tecknet på återstoden väljs så att dess "
"absoluta värde minimeras.  Mer exakt är returvärdet ``self - n * other`` där "
"``n`` är det heltal som ligger närmast det exakta värdet av ``self / "
"other``, och om två heltal ligger lika nära väljs det jämna."

msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "Om resultatet är noll kommer dess tecken att vara tecknet för *själv*."

msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"Returnerar resultatet av att rotera siffrorna i den första operanden med en "
"mängd som anges av den andra operanden.  Det andra operandet måste vara ett "
"heltal i intervallet -precision till precision.  Det andra operandets "
"absoluta värde anger antalet platser som ska roteras.  Om det andra "
"operandvärdet är positivt sker rotationen åt vänster, annars åt höger. "
"Koefficienten i det första operandet fylls vid behov på vänster sida med "
"nollor för att förlänga precisionen.  Tecknet och exponenten för den första "
"operanden är oförändrade."

msgid ""
"Test whether self and other have the same exponent or whether both are "
"``NaN``."
msgstr "Testa om self och other har samma exponent eller om båda är ``NaN``."

msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"Returnerar den första operanden med exponenten justerad med den andra. På "
"motsvarande sätt returneras den första operanden multiplicerad med "
"``10**annan``.  Den andra operanden måste vara ett heltal."

msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"Returnerar resultatet av att flytta siffrorna i den första operanden med ett "
"belopp som anges av den andra operanden.  Det andra operandet måste vara ett "
"heltal i intervallet -precision till precision.  Det andra operandets "
"absoluta värde anger antalet platser som ska skiftas.  Om det andra "
"operandet är positivt sker förskjutningen åt vänster, annars åt höger.  "
"Siffror som flyttas in i koefficienten är nollor.  Tecknet och exponenten "
"för den första operanden är oförändrade."

msgid "Return the square root of the argument to full precision."
msgstr "Returnera kvadratroten av argumentet till full precision."

msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr ""
"Konvertera till en sträng, med hjälp av ingenjörsnotation om en exponent "
"behövs."

msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr ""
"Teknisk notation har en exponent som är en multipel av 3. Detta kan ge upp "
"till 3 siffror till vänster om decimaltecknet och kan kräva tillägg av "
"antingen en eller två efterföljande nollor."

msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""
"Detta konverterar till exempel ``Decimal('123E+1')`` till "
"``Decimal('1.23E+3')``."

msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""
"Identisk med metoden :meth:`to_integral_value`.  Namnet ``to_integral`` har "
"behållits för kompatibilitet med äldre versioner."

msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"Avrunda till närmaste heltal, signalera :const:`Inexact` eller :const:"
"`Rounded` som lämpligt om avrundning sker.  Avrundningsläget bestäms av "
"parametern ``rounding`` om den är angiven, annars av den angivna "
"``contexten``.  Om ingen av parametrarna anges används avrundningsläget för "
"den aktuella kontexten."

msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
"Avrunda till närmaste heltal utan att signalera :const:`Inexact` eller :"
"const:`Rounded`.  Om den anges, tillämpas *avrundning*; annars används "
"avrundningsmetoden i antingen den medföljande *kontexten* eller den aktuella "
"kontexten."

msgid "Decimal numbers can be rounded using the :func:`.round` function:"
msgstr "Decimaltal kan avrundas med hjälp av funktionen :func:`.round`:"

msgid ""
"If *ndigits* is not given or ``None``, returns the nearest :class:`int` to "
"*number*, rounding ties to even, and ignoring the rounding mode of the :"
"class:`Decimal` context.  Raises :exc:`OverflowError` if *number* is an "
"infinity or :exc:`ValueError` if it is a (quiet or signaling) NaN."
msgstr ""
"Om *ndigits* inte anges eller ``None``, returneras det närmaste :class:`int` "
"till *number*, med avrundning till jämnt och utan hänsyn till "
"avrundningssättet i :class:`Decimal`-kontexten.  Utlöser :exc:"
"`OverflowError` om *number* är en oändlighet eller :exc:`ValueError` om det "
"är ett (tyst eller signalerande) NaN."

msgid ""
"If *ndigits* is an :class:`int`, the context's rounding mode is respected "
"and a :class:`Decimal` representing *number* rounded to the nearest multiple "
"of ``Decimal('1E-ndigits')`` is returned; in this case, ``round(number, "
"ndigits)`` is equivalent to ``self.quantize(Decimal('1E-ndigits'))``.  "
"Returns ``Decimal('NaN')`` if *number* is a quiet NaN.  Raises :class:"
"`InvalidOperation` if *number* is an infinity, a signaling NaN, or if the "
"length of the coefficient after the quantize operation would be greater than "
"the current context's precision.  In other words, for the non-corner cases:"
msgstr ""
"Om *ndigits* är en :class:`int`, respekteras kontextens avrundningsläge och "
"en :class:`Decimal` som representerar *tal* avrundat till närmaste multipel "
"av ``Decimal('1E-ndigits')`` returneras; i detta fall är ``round(number, "
"ndigits)`` ekvivalent med ``self.quantize(Decimal('1E-ndigits'))``.  "
"Returnerar ``Decimal('NaN')`` om *tal* är ett tyst NaN.  Utlöser :class:"
"`InvalidOperation` om *tal* är ett oändligt tal, ett signalerande NaN eller "
"om koefficientens längd efter kvantiseringsoperationen skulle vara större än "
"det aktuella sammanhangets precision.  Med andra ord, för de fall som inte "
"är hörnfall:"

msgid ""
"if *ndigits* is positive, return *number* rounded to *ndigits* decimal "
"places;"
msgstr ""
"om *ndigits* är positiv, returnera *number* avrundat till *ndigits* "
"decimaler;"

msgid "if *ndigits* is zero, return *number* rounded to the nearest integer;"
msgstr ""
"om *ndigits* är noll, returnera *number* avrundat till närmaste heltal;"

msgid ""
"if *ndigits* is negative, return *number* rounded to the nearest multiple of "
"``10**abs(ndigits)``."
msgstr ""
"om *ndigits* är negativt, returnera *number* avrundat till närmaste multipel "
"av ``10**abs(ndigits)``."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
">>> from decimal import Decimal, getcontext, ROUND_DOWN\n"
">>> getcontext().rounding = ROUND_DOWN\n"
">>> round(Decimal('3.75'))     # context rounding ignored\n"
"4\n"
">>> round(Decimal('3.5'))      # round-ties-to-even\n"
"4\n"
">>> round(Decimal('3.75'), 0)  # uses the context rounding\n"
"Decimal('3')\n"
">>> round(Decimal('3.75'), 1)\n"
"Decimal('3.7')\n"
">>> round(Decimal('3.75'), -1)\n"
"Decimal('0E+1')"
msgstr ""
">>> from decimal import Decimal, getcontext, ROUND_DOWN\n"
">>> getcontext().avrundning = ROUND_DOWN\n"
">>> round(Decimal('3,75'))     # kontextavrundning ignoreras\n"
"4\n"
">>> runda(Decimal('3,5'))      # runda-ties-till-jämn\n"
"4\n"
">>> round(Decimal('3.75'), 0) # använder kontextavrundningen\n"
"Decimal('3')\n"
">>> runda(Decimal('3.75'), 1)\n"
"Decimal('3,7')\n"
">>> avrunda(Decimal('3.75'), -1)\n"
"Decimal('0E+1')"

msgid "Logical operands"
msgstr "Logiska operander"

msgid ""
"The :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, :meth:"
"`~Decimal.logical_or`, and :meth:`~Decimal.logical_xor` methods expect their "
"arguments to be *logical operands*.  A *logical operand* is a :class:"
"`Decimal` instance whose exponent and sign are both zero, and whose digits "
"are all either ``0`` or ``1``."
msgstr ""
"Metoderna :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, :"
"meth:`~Decimal.logical_or` och :meth:`~Decimal.logical_xor` förväntar sig "
"att deras argument är *logiska operander*.  En *logisk operand* är en :class:"
"`Decimal`-instans vars exponent och tecken båda är noll, och vars siffror "
"alla är antingen ``0`` eller ``1``."

msgid "Context objects"
msgstr "Objekt i kontext"

msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""
"Kontexter är miljöer för aritmetiska operationer.  De styr precisionen, "
"sätter regler för avrundning, bestämmer vilka signaler som ska behandlas som "
"undantag och begränsar intervallet för exponenter."

msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"Varje tråd har sin egen aktuella kontext som kan nås eller ändras med hjälp "
"av funktionerna :func:`getcontext` och :func:`setcontext`:"

msgid "Return the current context for the active thread."
msgstr "Returnerar det aktuella sammanhanget för den aktiva tråden."

msgid "Set the current context for the active thread to *c*."
msgstr "Ställ in det aktuella sammanhanget för den aktiva tråden till *c*."

msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""
"Du kan också använda :keyword:`with`-satsen och :func:`localcontext`-"
"funktionen för att tillfälligt ändra den aktiva kontexten."

msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used.  The *kwargs* argument is "
"used to set the attributes of the new context."
msgstr ""
"Returnerar en kontexthanterare som sätter den aktuella kontexten för den "
"aktiva tråden till en kopia av *ctx* vid ingången till with-satsen och "
"återställer den tidigare kontexten när with-satsen avslutas. Om ingen "
"kontext anges används en kopia av den aktuella kontexten.  Argumentet "
"*kwargs* används för att ställa in attributen för den nya kontexten."

msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""
"Följande kod ställer t.ex. in den aktuella decimalprecisionen till 42 "
"enheter, utför en beräkning och återställer sedan automatiskt det tidigare "
"sammanhanget::"

msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext() as ctx:\n"
"    ctx.prec = 42   # Perform a high precision calculation\n"
"    s = calculate_something()\n"
"s = +s  # Round the final result back to the default precision"
msgstr ""
"från decimal import localcontext\n"
"\n"
"med localcontext() som ctx:\n"
"    ctx.prec = 42 # Utför en beräkning med hög precision\n"
"    s = beräkna_något()\n"
"s = +s # Runda tillbaka slutresultatet till standardprecisionen"

msgid "Using keyword arguments, the code would be the following::"
msgstr "Med hjälp av nyckelordsargument skulle koden vara följande::"

msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext(prec=42) as ctx:\n"
"    s = calculate_something()\n"
"s = +s"
msgstr ""
"från decimal import localcontext\n"
"\n"
"med localcontext(prec=42) som ctx:\n"
"    s = beräkna_något()\n"
"s = +s"

msgid ""
"Raises :exc:`TypeError` if *kwargs* supplies an attribute that :class:"
"`Context` doesn't support.  Raises either :exc:`TypeError` or :exc:"
"`ValueError` if *kwargs* supplies an invalid value for an attribute."
msgstr ""
"Utlöser :exc:`TypeError` om *kwargs* anger ett attribut som :class:`Context` "
"inte stöder.  Utlöser antingen :exc:`TypeError` eller :exc:`ValueError` om "
"*kwargs* anger ett ogiltigt värde för ett attribut."

msgid ""
":meth:`localcontext` now supports setting context attributes through the use "
"of keyword arguments."
msgstr ""
":meth:`localcontext` stöder nu inställning av kontextattribut genom "
"användning av nyckelordsargument."

msgid ""
"Return a context object initialized to the proper values for one of the IEEE "
"interchange formats.  The argument must be a multiple of 32 and less than :"
"const:`IEEE_CONTEXT_MAX_BITS`."
msgstr ""
"Returnerar ett kontextobjekt som initierats till rätt värden för ett av IEEE:"
"s utbytesformat.  Argumentet måste vara en multipel av 32 och mindre än :"
"const:`IEEE_CONTEXT_MAX_BITS`."

msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""
"Nya kontexter kan också skapas med hjälp av :class:`Context`-konstruktören "
"som beskrivs nedan. Dessutom tillhandahåller modulen tre färdiga kontexter:"

msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"Detta är en standardkontext som definieras av General Decimal Arithmetic "
"Specification.  Precisionen är satt till nio.  Avrundning är satt till :"
"const:`ROUND_HALF_UP`.  Alla flaggor är rensade.  Alla traps är aktiverade "
"(behandlas som undantag) utom :const:`Inexact`, :const:`Rounded` och :const:"
"`Subnormal`."

msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr ""
"Eftersom många av fällorna är aktiverade är detta sammanhang användbart för "
"felsökning."

msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"Detta är en standardkontext som definieras av General Decimal Arithmetic "
"Specification.  Precisionen är satt till nio.  Avrundning är satt till :"
"const:`ROUND_HALF_EVEN`.  Alla flaggor är rensade.  Inga fällor är "
"aktiverade (så att undantag inte uppstår under beräkningar)."

msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of ``NaN`` or ``Infinity`` instead of raising "
"exceptions.  This allows an application to complete a run in the presence of "
"conditions that would otherwise halt the program."
msgstr ""
"Eftersom fällorna är inaktiverade är detta sammanhang användbart för "
"applikationer som föredrar att ha resultatvärdet ``NaN`` eller ``Infinity`` "
"istället för att skapa undantag.  Detta gör att en applikation kan slutföra "
"en körning trots förhållanden som annars skulle stoppa programmet."

msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"Denna kontext används av :class:`Context`-konstruktören som en prototyp för "
"nya kontexter.  Om man ändrar ett fält (t.ex. precision) ändras "
"standardvärdet för nya kontexter som skapas av konstruktören :class:"
"`Context`."

msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"Detta sammanhang är mest användbart i flertrådade miljöer.  Om du ändrar ett "
"av fälten innan trådarna har startats innebär det att du ställer in "
"systemomfattande standardvärden.  Det är inte rekommenderat att ändra fälten "
"efter att trådarna har startat eftersom det kräver trådsynkronisering för "
"att förhindra tävlingsförhållanden."

msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"I enkeltrådade miljöer är det att föredra att inte använda detta sammanhang "
"alls.  Skapa istället kontexter explicit enligt beskrivningen nedan."

msgid ""
"The default values are :attr:`Context.prec`\\ =\\ ``28``, :attr:`Context."
"rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:"
"`Overflow`, :class:`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"Standardvärdena är :attr:`Context.prec`\\ =\\``28``, :attr:`Context."
"rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, och aktiverade fällor för :class:"
"`Overflow`, :class:`InvalidOperation`, och :class:`DivisionByZero`."

msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""
"Förutom de tre medföljande kontexterna kan nya kontexter skapas med :class:"
"`Context`-konstruktören."

msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"Skapar en ny kontext.  Om ett fält inte anges eller är :const:`None`, "
"kopieras standardvärdena från :const:`DefaultContext`.  Om fältet *flags* "
"inte anges eller är :const:`None`, rensas alla flaggor."

msgid ""
"An integer in the range [``1``, :const:`MAX_PREC`] that sets the precision "
"for arithmetic operations in the context."
msgstr ""
"Ett heltal i intervallet [``1``, :const:`MAX_PREC``] som anger precisionen "
"för aritmetiska operationer i kontexten."

msgid "One of the constants listed in the section `Rounding Modes`_."
msgstr "En av de konstanter som anges i avsnittet `Rounding Modes`_."

msgid ""
"Lists of any signals to be set. Generally, new contexts should only set "
"traps and leave the flags clear."
msgstr ""
"Listor över eventuella signaler som ska ställas in. I allmänhet bör nya "
"kontexter endast ställa in fällor och lämna flaggorna fria."

msgid ""
"Integers specifying the outer limits allowable for exponents. *Emin* must be "
"in the range [:const:`MIN_EMIN`, ``0``], *Emax* in the range [``0``, :const:"
"`MAX_EMAX`]."
msgstr ""
"Heltal som anger de yttre gränser som tillåts för exponenter. *Emin* måste "
"ligga i intervallet [:const:`MIN_EMIN`, ``0``], *Emax* i intervallet "
"[``0``, :const:`MAX_EMAX`]."

msgid ""
"Either ``0`` or ``1`` (the default). If set to ``1``, exponents are printed "
"with a capital ``E``; otherwise, a lowercase ``e`` is used: "
"``Decimal('6.02e+23')``."
msgstr ""
"Antingen ``0`` eller ``1`` (standard). Om värdet är satt till ``1`` skrivs "
"exponenter ut med ett stort ``E``; annars används ett litet ``e``: "
"``Decimal('6.02e+23')``."

msgid ""
"Either ``0`` (the default) or ``1``.  If set to ``1``, the exponent ``e`` of "
"a :class:`Decimal` instance representable in this context is strictly "
"limited to the range ``Emin - prec + 1 <= e <= Emax - prec + 1``. If *clamp* "
"is ``0`` then a weaker condition holds: the adjusted exponent of the :class:"
"`Decimal` instance is at most :attr:`~Context.Emax`.  When *clamp* is ``1``, "
"a large normal number will, where possible, have its exponent reduced and a "
"corresponding number of zeros added to its coefficient, in order to fit the "
"exponent constraints; this preserves the value of the number but loses "
"information about significant trailing zeros.  For example::"
msgstr ""
"Antingen ``0`` (standard) eller ``1``.  Om den är satt till ``1``, är "
"exponenten ``e`` för en :class:`Decimal`-instans som kan representeras i "
"detta sammanhang strikt begränsad till intervallet ``Emin - prec + 1 <= e <= "
"Emax - prec + 1``. Om *clamp* är ``0`` gäller ett svagare villkor: den "
"justerade exponenten för :class:`Decimal`-instansen är högst :attr:`~Context."
"Emax`.  När *clamp* är ``1`` kommer ett stort normalt tal, där så är "
"möjligt, att få sin exponent reducerad och ett motsvarande antal nollor "
"tillagda till sin koefficient, för att passa exponentbegränsningarna; detta "
"bevarar talets värde men förlorar information om signifikanta efterföljande "
"nollor.  Till exempel::"

msgid ""
">>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')\n"
"Decimal('1.23000E+999')"
msgstr ""
">>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')\n"
"Decimal('1.23000E+999')"

msgid ""
"A *clamp* value of ``1`` allows compatibility with the fixed-width decimal "
"interchange formats specified in IEEE 754."
msgstr ""
"Ett *clamp*-värde på ``1`` ger kompatibilitet med de decimala utbytesformat "
"med fast bredd som anges i IEEE 754."

msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`~Decimal.adjusted` and :meth:"
"`~Decimal.as_tuple` methods) there is a corresponding :class:`Context` "
"method.  For example, for a :class:`Context` instance ``C`` and :class:"
"`Decimal` instance ``x``, ``C.exp(x)`` is equivalent to ``x."
"exp(context=C)``.  Each :class:`Context` method accepts a Python integer (an "
"instance of :class:`int`) anywhere that a Decimal instance is accepted."
msgstr ""
"Klassen :class:`Context` definierar flera metoder för allmänna ändamål samt "
"ett stort antal metoder för att utföra aritmetik direkt i ett givet "
"sammanhang. Dessutom finns det för var och en av de :class:`Decimal`-metoder "
"som beskrivs ovan (med undantag för metoderna :meth:`~Decimal.adjusted` och :"
"meth:`~Decimal.as_tuple`) en motsvarande :class:`Context`-metod.  Till "
"exempel, för en :class:`Context`-instans ``C`` och :class:`Decimal`-instans "
"``x``, är ``C.exp(x)`` ekvivalent med ``x.exp(context=C)``.  Varje :class:"
"`Context`-metod accepterar ett Python-heltal (en instans av :class:`int`) "
"överallt där en Decimal-instans accepteras."

msgid "Resets all of the flags to ``0``."
msgstr "Återställer alla flaggor till ``0``."

msgid "Resets all of the traps to ``0``."
msgstr "Återställer alla fällor till ``0``."

msgid "Return a duplicate of the context."
msgstr "Returnerar en kopia av kontexten."

msgid "Return a copy of the Decimal instance num."
msgstr "Returnerar en kopia av Decimal-instansen num."

msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"Skapar en ny Decimal-instans från *num* men använder *self* som kontext. "
"Till skillnad från :class:`Decimal`-konstruktören tillämpas kontextens "
"precision, avrundningsmetod, flaggor och fällor på konverteringen."

msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"Detta är användbart eftersom konstanter ofta ges med större precision än vad "
"som behövs i programmet.  En annan fördel är att avrundning omedelbart "
"eliminerar oavsiktliga effekter från siffror som ligger utanför den aktuella "
"precisionen. I följande exempel innebär oavrundade indata att resultatet kan "
"ändras om man lägger till noll i en summa:"

msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.4445') + Decimal('1.0023')\n"
"Decimal('4.45')\n"
">>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\n"
"Decimal('4.44')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> Decimal('3,4445') + Decimal('1,0023')\n"
"Decimal('4,45')\n"
">>> Decimal('3,4445') + Decimal(0) + Decimal('1,0023')\n"
"Decimal('4.44')"

msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr ""
"Denna metod implementerar IBM-specifikationens \"to-number\"-operation. Om "
"argumentet är en sträng tillåts inga inledande eller avslutande blanksteg "
"eller understrykningstecken."

msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"Skapar en ny Decimal-instans från en float *f* men avrundning med *self* som "
"kontext.  Till skillnad från klassmetoden :meth:`Decimal.from_float` "
"tillämpas kontextens precision, avrundningsmetod, flaggor och fällor på "
"konverteringen."

msgid ""
">>> context = Context(prec=5, rounding=ROUND_DOWN)\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Decimal('3.1415')\n"
">>> context = Context(prec=5, traps=[Inexact])\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"decimal.Inexact: None"
msgstr ""
">>> context = Context(prec=5, avrundning=ROUND_DOWN)\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Decimal('3,1415')\n"
">>> context = Context(prec=5, fällor=[Inexakt])\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"decimal.Inexakt: Ingen"

msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""
"Returnerar ett värde lika med ``Emin - prec + 1``, vilket är det lägsta "
"exponentvärdet för subnormala resultat.  När underflöde inträffar sätts "
"exponenten till :const:`Etiny`."

msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "Returnerar ett värde som är lika med ``Emax - prec + 1``."

msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"Det vanliga sättet att arbeta med decimaler är att skapa :class:`Decimal`-"
"instanser och sedan tillämpa aritmetiska operationer som äger rum inom den "
"aktuella kontexten för den aktiva tråden.  Ett alternativt tillvägagångssätt "
"är att använda kontextmetoder för att beräkna inom en specifik kontext.  "
"Metoderna liknar dem för klassen :class:`Decimal` och beskrivs bara "
"kortfattat här."

msgid "Returns the absolute value of *x*."
msgstr "Returnerar det absoluta värdet av *x*."

msgid "Return the sum of *x* and *y*."
msgstr "Returnera summan av *x* och *y*."

msgid "Returns the same Decimal object *x*."
msgstr "Returnerar samma Decimal-objekt *x*."

msgid "Compares *x* and *y* numerically."
msgstr "Jämför *x* och *y* numeriskt."

msgid "Compares the values of the two operands numerically."
msgstr "Jämför värdena för de två operanderna numeriskt."

msgid "Compares two operands using their abstract representation."
msgstr "Jämför två operander med hjälp av deras abstrakta representation."

msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr ""
"Jämför två operander med hjälp av deras abstrakta representation, utan att "
"ta hänsyn till tecken."

msgid "Returns a copy of *x* with the sign set to 0."
msgstr "Returnerar en kopia av *x* med tecknet satt till 0."

msgid "Returns a copy of *x* with the sign inverted."
msgstr "Returnerar en kopia av *x* med inverterat tecken."

msgid "Copies the sign from *y* to *x*."
msgstr "Kopierar tecknet från *y* till *x*."

msgid "Return *x* divided by *y*."
msgstr "Returnera *x* dividerat med *y*."

msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "Returnerar *x* dividerat med *y*, trunkerat till ett heltal."

msgid "Divides two numbers and returns the integer part of the result."
msgstr "Dividerar två tal och returnerar heltalsdelen av resultatet."

msgid "Returns ``e ** x``."
msgstr "Returnerar ``e ** x``."

msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "Returnerar *x* multiplicerat med *y*, plus *z*."

msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr "Returnerar ``True`` om *x* är kanonisk; annars returneras ``False``."

msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "Returnerar ``True`` om *x* är ändlig; annars returneras ``False``."

msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr "Returnerar ``True`` om *x* är oändlig; annars returneras ``False``."

msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""
"Returnerar ``True`` om *x* är en qNaN eller sNaN; annars returneras "
"``False``."

msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""
"Returnerar ``True`` om *x* är ett normalt tal; annars returneras ``False``."

msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr ""
"Returnerar ``True`` om *x* är ett tyst NaN; annars returneras ``False``."

msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr "Returnerar ``True`` om *x* är negativ; annars returneras ``False``."

msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""
"Returnerar ``True`` om *x* är en signalerande NaN; annars returneras "
"``False``."

msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr "Returnerar ``True`` om *x* är subnormal; annars returneras ``False``."

msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr "Returnerar ``True`` om *x* är en nolla; annars returneras ``False``."

msgid "Returns the natural (base e) logarithm of *x*."
msgstr "Returnerar den naturliga (bas e) logaritmen för *x*."

msgid "Returns the base 10 logarithm of *x*."
msgstr "Returnerar bas 10-logaritmen för *x*."

msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "Returnerar exponenten av magnituden för operandens MSD."

msgid "Applies the logical operation *and* between each operand's digits."
msgstr "Använder den logiska operationen *och* mellan varje operands siffror."

msgid "Invert all the digits in *x*."
msgstr "Invertera alla siffrorna i *x*."

msgid "Applies the logical operation *or* between each operand's digits."
msgstr ""
"Tillämpar den logiska operationen *eller* mellan varje operands siffror."

msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "Tillämpar den logiska operationen *xor* mellan varje operands siffror."

msgid "Compares two values numerically and returns the maximum."
msgstr "Jämför två värden numeriskt och returnerar det högsta värdet."

msgid "Compares the values numerically with their sign ignored."
msgstr "Jämför värdena numeriskt utan att ta hänsyn till deras tecken."

msgid "Compares two values numerically and returns the minimum."
msgstr "Jämför två värden numeriskt och returnerar det lägsta värdet."

msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "Minus motsvarar den unära prefixoperatorn minus i Python."

msgid "Return the product of *x* and *y*."
msgstr "Returnera produkten av *x* och *y*."

msgid "Returns the largest representable number smaller than *x*."
msgstr "Returnerar det största representerbara talet som är mindre än *x*."

msgid "Returns the smallest representable number larger than *x*."
msgstr "Returnerar det minsta representerbara talet som är större än *x*."

msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "Returnerar det tal som ligger närmast *x*, i riktning mot *y*."

msgid "Reduces *x* to its simplest form."
msgstr "Reducerar *x* till sin enklaste form."

msgid "Returns an indication of the class of *x*."
msgstr "Returnerar en indikation på klassen för *x*."

msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"Plus motsvarar den unära prefixoperatorn plus i Python.  Denna operation "
"tillämpar kontextens precision och avrundning, så det är *inte* en "
"identitetsoperation."

msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""
"Returnerar ``x`` till potensen av ``y``, reducerad modulo ``modulo`` om den "
"anges."

msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly rounded "
"in the Python version."
msgstr ""
"Beräkna ``x**y`` med två argument.  Om ``x`` är negativt måste ``y`` vara "
"heltal.  Resultatet blir inexakt om inte ``y`` är heltal och resultatet är "
"ändligt och kan uttryckas exakt i 'precisionssiffror'. Kontextens "
"avrundningsläge används. Resultat avrundas alltid korrekt i Python-versionen."

msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""
"``Decimal(0) ** Decimal(0)`` resulterar i ``InvalidOperation``, och om "
"``InvalidOperation`` inte fångas, resulterar det i ``Decimal('NaN')``."

msgid ""
"The C module computes :meth:`power` in terms of the correctly rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly rounded\"."
msgstr ""
"C-modulen beräknar :meth:`power` i termer av de korrekt avrundade "
"funktionerna :meth:`exp` och :meth:`ln`. Resultatet är väldefinierat men "
"bara \"nästan alltid korrekt avrundat\"."

msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""
"Med tre argument beräkna ``(x**y) % modulo``.  För formen med tre argument "
"gäller följande restriktioner för argumenten:"

msgid "all three arguments must be integral"
msgstr "alla tre argumenten måste vara integrerade"

msgid "``y`` must be nonnegative"
msgstr "``y`` måste vara icke-negativ"

msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "minst en av ``x`` eller ``y`` måste vara icke-noll"

msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` måste vara icke-noll och ha högst 'precision' siffror"

msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"Det värde som erhålls genom ``Context.power(x, y, modulo)`` är lika med det "
"värde som skulle erhållas genom att beräkna ``(x**y) % modulo`` med "
"obegränsad precision, men beräknas mer effektivt.  Resultatets exponent är "
"noll, oavsett exponenterna för ``x``, ``y`` och ``modulo``.  Resultatet är "
"alltid exakt."

msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr ""
"Returnerar ett värde som är lika med *x* (avrundat), med exponenten *y*."

msgid "Just returns 10, as this is Decimal, :)"
msgstr "Returnerar bara 10, eftersom detta är decimal, :)"

msgid "Returns the remainder from integer division."
msgstr "Returnerar restvärdet från heltalsdivision."

msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr ""
"Om resultatet inte är noll har det samma tecken som den ursprungliga "
"utdelningen."

msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"Returnerar ``x - y * n``, där *n* är det heltal som ligger närmast det "
"exakta värdet av ``x / y`` (om resultatet är 0 kommer dess tecken att vara "
"tecknet för *x*)."

msgid "Returns a rotated copy of *x*, *y* times."
msgstr "Returnerar en roterad kopia av *x*, *y* gånger."

msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "Returnerar ``True`` om de två operanderna har samma exponent."

msgid "Returns the first operand after adding the second value its exp."
msgstr ""
"Returnerar den första operanden efter att ha adderat det andra värdet dess "
"exp."

msgid "Returns a shifted copy of *x*, *y* times."
msgstr "Returnerar en förskjuten kopia av *x*, *y* gånger."

msgid "Square root of a non-negative number to context precision."
msgstr "Kvadratrot av ett icke-negativt tal med kontextprecision."

msgid "Return the difference between *x* and *y*."
msgstr "Returnera skillnaden mellan *x* och *y*."

msgid "Rounds to an integer."
msgstr "Avrundas till ett heltal."

msgid "Converts a number to a string using scientific notation."
msgstr "Konverterar ett tal till en sträng med vetenskaplig notation."

msgid "Constants"
msgstr "Konstanter"

msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr ""
"Konstanterna i detta avsnitt är endast relevanta för C-modulen. De ingår "
"också i den rena Python-versionen för kompatibilitet."

msgid "32-bit"
msgstr "32-bitars"

msgid "64-bit"
msgstr "64-bitars"

msgid "``425000000``"
msgstr "``425000000``"

msgid "``999999999999999999``"
msgstr "``999999999999999999``"

msgid "``-425000000``"
msgstr "``-425000000``"

msgid "``-999999999999999999``"
msgstr "``-999999999999999999``"

msgid "``-849999999``"
msgstr "``-849999999``"

msgid "``-1999999999999999997``"
msgstr "``-1999999999999999997``"

msgid "``256``"
msgstr "``256``"

msgid "``512``"
msgstr "``512``"

msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr "Värdet är ``True``.  Föråldrad, eftersom Python nu alltid har trådar."

msgid ""
"The default value is ``True``. If Python is :option:`configured using the --"
"without-decimal-contextvar option <--without-decimal-contextvar>`, the C "
"version uses a thread-local rather than a coroutine-local context and the "
"value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""
"Standardvärdet är ``True``. Om Python är :option:`konfigurerad med "
"alternativet --without-decimal-contextvar <--without-decimal-contextvar>`, "
"använder C-versionen en trådlokal snarare än en koroutinlokal kontext och "
"värdet är ``False``.  Detta är något snabbare i vissa scenarier med nästlade "
"kontexter."

msgid "Rounding modes"
msgstr "Avrundningslägen"

msgid "Round towards ``Infinity``."
msgstr "Runda mot ``Infinity``."

msgid "Round towards zero."
msgstr "Runda mot noll."

msgid "Round towards ``-Infinity``."
msgstr "Runda mot ``Infinity``."

msgid "Round to nearest with ties going towards zero."
msgstr "Avrunda till närmaste med oavgjorda tal mot noll."

msgid "Round to nearest with ties going to nearest even integer."
msgstr "Avrunda till närmaste med oavgjort till närmaste jämna heltal."

msgid "Round to nearest with ties going away from zero."
msgstr "Avrunda till närmaste med tiotal som går bort från noll."

msgid "Round away from zero."
msgstr "Avrunda bort från noll."

msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr ""
"Avrunda bort från noll om sista siffran efter avrundning mot noll skulle ha "
"varit 0 eller 5; annars avrunda mot noll."

msgid "Signals"
msgstr "Signaler"

msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""
"Signalerna representerar förhållanden som uppstår under beräkningen. Var och "
"en motsvarar en kontextflagga och en kontextfälla."

msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"Kontextflaggan sätts närhelst villkoret uppfylls. Efter beräkningen kan "
"flaggorna kontrolleras i informationssyfte (t.ex. för att avgöra om en "
"beräkning var exakt). När du har kontrollerat flaggorna måste du rensa alla "
"flaggor innan du startar nästa beräkning."

msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"Om kontextens trap enabler är inställd för signalen, orsakar villkoret att "
"ett Python-undantag utlöses.  Till exempel, om :class:`DivisionByZero`-"
"fällan är inställd, kommer ett :exc:`DivisionByZero`-undantag att utlösas "
"när villkoret påträffas."

msgid "Altered an exponent to fit representation constraints."
msgstr "Ändrade en exponent för att passa representationsbegränsningar."

msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`~Context.Emin` and :attr:`~Context.Emax` limits.  If possible, the "
"exponent is reduced to fit by adding zeros to the coefficient."
msgstr ""
"Vanligtvis sker fastspänning när en exponent faller utanför kontextens "
"gränser :attr:`~Context.Emin` och :attr:`~Context.Emax`.  Om möjligt "
"reduceras exponenten så att den passar genom att nollor läggs till i "
"koefficienten."

msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr ""
"Basklass för andra signaler och en underklass till :exc:`ArithmeticError`."

msgid "Signals the division of a non-infinite number by zero."
msgstr "Signalerar division av ett icke oändligt tal med noll."

msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns ``Infinity`` or ``-"
"Infinity`` with the sign determined by the inputs to the calculation."
msgstr ""
"Kan uppstå vid division, modulo-division eller när ett tal upphöjs till en "
"negativ potens.  Om denna signal inte fångas upp returneras ``Oändlighet`` "
"eller ``Oändlighet`` med det tecken som bestäms av ingångarna till "
"beräkningen."

msgid "Indicates that rounding occurred and the result is not exact."
msgstr "Indikerar att avrundning har skett och att resultatet inte är exakt."

msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""
"Signalerar när siffror som inte är noll har tagits bort under avrundningen. "
"Det avrundade resultatet returneras.  Signalflaggan eller trap används för "
"att upptäcka när resultaten är inexakta."

msgid "An invalid operation was performed."
msgstr "En ogiltig operation utfördes."

msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns ``NaN``.  Possible causes include::"
msgstr ""
"Indikerar att en åtgärd begärdes som inte är meningsfull. Om den inte fångas "
"upp returneras ``NaN``.  Möjliga orsaker inkluderar::"

msgid ""
"Infinity - Infinity\n"
"0 * Infinity\n"
"Infinity / Infinity\n"
"x % 0\n"
"Infinity % x\n"
"sqrt(-x) and x > 0\n"
"0 ** 0\n"
"x ** (non-integer)\n"
"x ** Infinity"
msgstr ""
"Oändlighet - Oändlighet\n"
"0 * Infinity\n"
"Oändlighet / Oändlighet\n"
"x % 0\n"
"Oändligt % x\n"
"sqrt(-x) och x > 0\n"
"0 ** 0\n"
"x ** (icke heltal)\n"
"x ** oändlighet"

msgid "Numerical overflow."
msgstr "Numeriskt överflöde."

msgid ""
"Indicates the exponent is larger than :attr:`Context.Emax` after rounding "
"has occurred.  If not trapped, the result depends on the rounding mode, "
"either pulling inward to the largest representable finite number or rounding "
"outward to ``Infinity``.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"Anger att exponenten är större än :attr:`Context.Emax` efter att avrundning "
"har skett.  Om den inte fångas beror resultatet på avrundningsläget, "
"antingen dras det inåt till det största representativa ändliga talet eller "
"avrundas utåt till ``Infinity``.  I båda fallen signaleras också :class:"
"`Inexact` och :class:`Rounded`."

msgid "Rounding occurred though possibly no information was lost."
msgstr "Avrundning skedde, men möjligen gick ingen information förlorad."

msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding ``5.00`` to ``5.0``).  If not trapped, returns the result "
"unchanged.  This signal is used to detect loss of significant digits."
msgstr ""
"Signaleras när avrundning tar bort siffror, även om dessa siffror är noll (t."
"ex. avrundning av ``5,00`` till ``5,0``).  Om den inte fångas, returneras "
"resultatet oförändrat.  Denna signal används för att upptäcka förlust av "
"signifikanta siffror."

msgid "Exponent was lower than :attr:`~Context.Emin` prior to rounding."
msgstr "Exponent var lägre än :attr:`~Context.Emin` före avrundning."

msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""
"Inträffar när ett operationsresultat är onormalt (exponenten är för liten). "
"Om det inte fångas, returneras resultatet oförändrat."

msgid "Numerical underflow with result rounded to zero."
msgstr "Numeriskt underflöde med resultatet avrundat till noll."

msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"Inträffar när ett subnormalt resultat pressas till noll genom avrundning. :"
"class:`Inexact` och :class:`Subnormal` signaleras också."

msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr "Möjliggör striktare semantik för blandning av floats och decimaler."

msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""
"Om signalen inte är fångad (standard) är det tillåtet att blanda floats och "
"decimaler i :class:`~decimal.Decimal`-konstruktorn, :meth:`~decimal.Context."
"create_decimal` och alla jämförelseoperatorer. Både konvertering och "
"jämförelser är exakta. Varje förekomst av en blandad operation registreras "
"tyst genom att ställa in :exc:`FloatOperation` i kontextflaggorna. Explicita "
"konverteringar med :meth:`~decimal.Decimal.from_float` eller :meth:`~decimal."
"Context.create_decimal_from_float` sätter inte flaggan."

msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr ""
"I annat fall (signalen fångas upp) är endast jämlikhetsjämförelser och "
"explicita konverteringar tysta. Alla andra blandade operationer ger upphov "
"till :exc:`FloatOperation`."

msgid "The following table summarizes the hierarchy of signals::"
msgstr "Följande tabell sammanfattar signalernas hierarki::"

msgid ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Clamped\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexact\n"
"            Overflow(Inexact, Rounded)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        InvalidOperation\n"
"        Rounded\n"
"        Subnormal\n"
"        FloatOperation(DecimalException, exceptions.TypeError)"
msgstr ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Klämd\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexakt\n"
"            Överflöde(Inexakt, Avrundad)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        OgiltigOperation\n"
"        Avrundad\n"
"        Subnormal\n"
"        FloatOperation(DecimalException, undantag.TypeError)"

msgid "Floating-point notes"
msgstr "Flyttalsnoteringar"

msgid "Mitigating round-off error with increased precision"
msgstr "Minska avrundningsfel med ökad precision"

msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent ``0.1`` exactly); however, some operations "
"can still incur round-off error when non-zero digits exceed the fixed "
"precision."
msgstr ""
"Användningen av decimalt flyttal eliminerar fel i decimalrepresentationen "
"(vilket gör det möjligt att representera ``0,1`` exakt); vissa operationer "
"kan dock fortfarande medföra avrundningsfel när siffror som inte är noll "
"överstiger den fasta precisionen."

msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating-point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""
"Effekterna av avrundningsfel kan förstärkas genom addition eller subtraktion "
"av nästan motsatta mängder, vilket leder till förlust av signifikans.  Knuth "
"ger två instruktiva exempel där avrundad aritmetik med flyttal med "
"otillräcklig precision leder till att de associativa och distributiva "
"egenskaperna hos addition bryts ned:"

msgid ""
"# Examples from Seminumerical Algorithms, Section 4.2.2.\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""
"# Exempel från Seminumeriska algoritmer, avsnitt 4.2.2.\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0,01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"

msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""
"Modulen :mod:`decimal` gör det möjligt att återställa identiteterna genom "
"att utöka precisionen tillräckligt för att undvika förlust av signifikans:"

msgid ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0,0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"

msgid "Special values"
msgstr "Särskilda värden"

msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity``, and two zeros, "
"``+0`` and ``-0``."
msgstr ""
"Talsystemet för modulen :mod:`decimal` innehåller specialvärden som ``NaN``, "
"``NaN``, ``Infinity``, ``Infinity`` och två nollor, ``+0`` och ``-0``."

msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"Oändligheter kan konstrueras direkt med:  ``Decimal('Infinity')``. De kan "
"också uppstå genom att dividera med noll när signalen :exc:`DivisionByZero` "
"inte är spärrad.  På samma sätt kan oändlighet uppstå när man avrundar "
"bortom gränserna för det största representerbara talet när signalen :exc:"
"`Overflow` inte fångas upp."

msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""
"De oändliga talen är signerade (affina) och kan användas i aritmetiska "
"operationer där de behandlas som mycket stora, obestämda tal.  Om man t.ex. "
"adderar en konstant till oändligheten får man ett annat oändligt resultat."

msgid ""
"Some operations are indeterminate and return ``NaN``, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns ``NaN`` which means \"not a number\".  This variety of "
"``NaN`` is quiet and, once created, will flow through other computations "
"always resulting in another ``NaN``.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"Vissa operationer är obestämda och returnerar ``NaN``, eller om :exc:"
"`InvalidOperation`-signalen fångas, ger upphov till ett undantag.  Till "
"exempel, ``0/0`` returnerar ``NaN`` vilket betyder \"inte ett tal\".  Denna "
"variant av ``NaN`` är tyst och när den väl har skapats kommer den att flöda "
"genom andra beräkningar som alltid resulterar i en annan ``NaN``.  Detta "
"beteende kan vara användbart för en serie beräkningar som ibland saknar "
"indata --- det gör att beräkningen kan fortsätta medan specifika resultat "
"flaggas som ogiltiga."

msgid ""
"A variant is ``sNaN`` which signals rather than remaining quiet after every "
"operation.  This is a useful return value when an invalid result needs to "
"interrupt a calculation for special handling."
msgstr ""
"En variant är ``NaN`` som signalerar istället för att vara tyst efter varje "
"operation.  Detta är ett användbart returvärde när ett ogiltigt resultat "
"måste avbryta en beräkning för särskild hantering."

msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a ``NaN`` is involved.  A test for equality where one of the operands "
"is a quiet or signaling ``NaN`` always returns :const:`False` (even when "
"doing ``Decimal('NaN')==Decimal('NaN')``), while a test for inequality "
"always returns :const:`True`.  An attempt to compare two Decimals using any "
"of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :exc:"
"`InvalidOperation` signal if either operand is a ``NaN``, and return :const:"
"`False` if this signal is not trapped.  Note that the General Decimal "
"Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a ``NaN`` were taken from "
"the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`~Decimal.compare` and :meth:`~Decimal."
"compare_signal` methods instead."
msgstr ""
"Beteendet hos Pythons jämförelseoperatorer kan vara lite förvånande när en "
"``NaN`` är inblandad.  Ett test för likhet där en av operanderna är en tyst "
"eller signalerande ``NaN`` returnerar alltid :const:`False`` (även när man "
"gör ``Decimal('NaN')==Decimal('NaN')``), medan ett test för olikhet alltid "
"returnerar :const:`True``.  Ett försök att jämföra två decimaler med någon "
"av operatorerna ``<``, ``<=``, ``>`` eller ``>=`` kommer att ge upphov till "
"signalen :exc:`InvalidOperation` om någon av operanderna är ett ``NaN``, och "
"returnera :const:`False` om denna signal inte fångas upp.  Observera att "
"General Decimal Arithmetic-specifikationen inte specificerar beteendet för "
"direkta jämförelser; dessa regler för jämförelser som involverar ett ``NaN`` "
"har hämtats från IEEE 854-standarden (se tabell 3 i avsnitt 5.7).  För att "
"säkerställa strikt standardöverensstämmelse, använd metoderna :meth:"
"`~Decimal.compare` och :meth:`~Decimal.compare_signal` istället."

msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"De signerade nollorna kan uppstå vid beräkningar som underflödar. De "
"behåller det tecken som skulle ha blivit resultatet om beräkningen hade "
"utförts med större precision.  Eftersom deras magnitud är noll behandlas "
"både positiva och negativa nollor som lika och deras tecken är informativt."

msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating-point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""
"Förutom de två signerade nollorna, som är olika men ändå lika, finns det "
"olika representationer av noll med olika noggrannhet men ändå likvärdiga i "
"värde.  Detta tar lite tid att vänja sig vid.  För ett öga som är vant vid "
"normaliserade flyttalsrepresentationer är det inte omedelbart uppenbart att "
"följande beräkning ger ett värde som är lika med noll:"

msgid "Working with threads"
msgstr "Arbeta med trådar"

msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
"Funktionen :func:`getcontext` ger åtkomst till ett olika :class:`Context`-"
"objekt för varje tråd.  Att ha separata trådkontexter innebär att trådar kan "
"göra ändringar (t.ex. ``getcontext().prec=10``) utan att störa andra trådar."

msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""
"På samma sätt tilldelar funktionen :func:`setcontext` automatiskt sitt mål "
"till den aktuella tråden."

msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread.  New context objects have default values set from the :data:"
"`decimal.DefaultContext` object."
msgstr ""
"Om :func:`setcontext` inte har anropats före :func:`getcontext`, kommer :"
"func:`getcontext` automatiskt att skapa en ny kontext för användning i den "
"aktuella tråden.  Nya kontextobjekt har standardvärden från :data:`decimal."
"DefaultContext`-objektet."

msgid ""
"The :data:`sys.flags.thread_inherit_context` flag affects the context for "
"new threads.  If the flag is false, new threads will start with an empty "
"context.  In this case, :func:`getcontext` will create a new context object "
"when called and use the default values from *DefaultContext*.  If the flag "
"is true, new threads will start with a copy of context from the caller of :"
"meth:`threading.Thread.start`."
msgstr ""
"Flaggan :data:`sys.flags.thread_inherit_context` påverkar kontexten för nya "
"trådar.  Om flaggan är false kommer nya trådar att starta med en tom "
"kontext.  I detta fall kommer :func:`getcontext` att skapa ett nytt "
"kontextobjekt när den anropas och använda standardvärdena från "
"*DefaultContext*.  Om flaggan är true kommer nya trådar att starta med en "
"kopia av kontexten från den som anropar :meth:`threading.Thread.start`."

msgid ""
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""
"För att styra standardvärdena så att varje tråd använder samma värden i hela "
"applikationen, modifierar du *DefaultContext*-objektet direkt. Detta bör "
"göras *innan* några trådar startas så att det inte blir ett race condition "
"mellan trådar som anropar :func:`getcontext`. Till exempel::"

msgid ""
"# Set applicationwide defaults for all threads about to be launched\n"
"DefaultContext.prec = 12\n"
"DefaultContext.rounding = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# Afterwards, the threads can be started\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."
msgstr ""
"# Ställ in applikationsomfattande standardvärden för alla trådar som ska "
"startas\n"
"DefaultContext.prec = 12\n"
"DefaultContext.avrundning = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# Efteråt kan trådarna startas\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."

msgid "Recipes"
msgstr "Recept"

msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""
"Här är några recept som fungerar som verktygsfunktioner och som visar hur "
"man kan arbeta med klassen :class:`Decimal`::"

msgid ""
"def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"Convert Decimal to a money formatted string.\n"
"\n"
"    places:  required number of places after the decimal point\n"
"    curr:    optional currency symbol before the sign (may be blank)\n"
"    sep:     optional grouping separator (comma, period, space, or blank)\n"
"    dp:      decimal point indicator (comma or period)\n"
"             only specify as blank when places is zero\n"
"    pos:     optional sign for positive numbers: '+', space or blank\n"
"    neg:     optional sign for negative numbers: '-', '(', space or blank\n"
"    trailneg:optional trailing minus indicator:  '-', ')', space or blank\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -places      # 2 places --> '0.01'\n"
"    sign, digits, exp = value.quantize(q).as_tuple()\n"
"    result = []\n"
"    digits = list(map(str, digits))\n"
"    build, next = result.append, digits.pop\n"
"    if sign:\n"
"        build(trailneg)\n"
"    for i in range(places):\n"
"        build(next() if digits else '0')\n"
"    if places:\n"
"        build(dp)\n"
"    if not digits:\n"
"        build('0')\n"
"    i = 0\n"
"    while digits:\n"
"        build(next())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if sign else pos)\n"
"    return ''.join(reversed(result))\n"
"\n"
"def pi():\n"
"    \"\"\"Compute Pi to the current precision.\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2  # extra digits for intermediate steps\n"
"    three = Decimal(3)      # substitute \"three=3.0\" for regular floats\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s               # unary plus applies the new precision\n"
"\n"
"def exp(x):\n"
"    \"\"\"Return e raised to the power of x.  Result type matches input "
"type.\n"
"\n"
"    >>> print(exp(Decimal(1)))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2)))\n"
"    7.389056098930650227230427461\n"
"    >>> print(exp(2.0))\n"
"    7.38905609893\n"
"    >>> print(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 1\n"
"        fact *= i\n"
"        num *= x\n"
"        s += num / fact\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"Return the cosine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(cos(Decimal('0.5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> print(cos(0.5))\n"
"    0.87758256189\n"
"    >>> print(cos(0.5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"Return the sine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(sin(Decimal('0.5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> print(sin(0.5))\n"
"    0.479425538604\n"
"    >>> print(sin(0.5+0j))\n"
"    (0.479425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s"
msgstr ""
"def moneyfmt(värde, places=2, curr='', sep=',', dp='.'',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"Konvertera decimaltal till en sträng i penningformat.\n"
"\n"
"    places: önskat antal platser efter decimaltecknet\n"
"    curr: valfri valutasymbol före tecknet (kan vara tom)\n"
"    sep: valfri grupperingsavskiljare (kommatecken, punkt, mellanslag eller "
"blank)\n"
"    dp: decimalpunktsindikator (kommatecken eller punkt)\n"
"             anges endast som blank när places är noll\n"
"    pos: valfritt tecken för positiva tal: \"+\", mellanslag eller "
"blanksteg\n"
"    neg: valfritt tecken för negativa tal: '-', '(', mellanslag eller "
"blanksteg\n"
"    trailneg: valfri indikator för efterföljande minus: '-', ')', mellanslag "
"eller blank\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0,02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -platser # 2 platser --> '0,01'\n"
"    tecken, siffror, exp = värde.quantize(q).as_tuple()\n"
"    resultat = []\n"
"    digits = list(map(str, digits))\n"
"    build, nästa = result.append, digits.pop\n"
"    om tecken:\n"
"        build(trailneg)\n"
"    för i i intervall(platser):\n"
"        build(next() if siffror else '0')\n"
"    if platser:\n"
"        build(dp)\n"
"    om inte siffror:\n"
"        build('0')\n"
"    i = 0\n"
"    medan siffror:\n"
"        build(nästa())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if tecken else pos)\n"
"    return ''.join(reversed(resultat))\n"
"\n"
"def pi():\n"
"    \"\"\"Beräkna Pi med aktuell precision.\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2 # extra siffror för mellanliggande steg\n"
"    three = Decimal(3) # ersätt \"three=3.0\" för vanliga flyttal\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        sista = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s # unary plus tillämpar den nya precisionen\n"
"\n"
"def exp(x):\n"
"    \"\"\"Returnerar e upphöjt till potensen av x. Resultattypen matchar "
"indatatypen.\n"
"\n"
"    >>> print(exp(Decimal(1))))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2))))\n"
"    7.389056098930650227230427461\n"
"    >>> Skriv ut(exp(2,0))\n"
"    7.38905609893\n"
"    >>> skriv ut(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        sista = s\n"
"        i += 1\n"
"        fakta *= i\n"
"        num *= x\n"
"        s += num / fakta\n"
"    getcontext().prec -= 2\n"
"    returnera +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"Returnerar cosinus för x mätt i radianer.\n"
"\n"
"    Taylorseriens approximation fungerar bäst för ett litet värde på x.\n"
"    För större värden beräknar du först x = x % (2 * pi).\n"
"\n"
"    >>> print(cos(Decimal('0,5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> Skriv ut(cos(0,5))\n"
"    0.87758256189\n"
"    >>> Skriv ut(cos(0,5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1, 1\n"
"    medan s != sista:\n"
"        sista = s\n"
"        i += 2\n"
"        fakta *= i * (i-1)\n"
"        num *= x * x\n"
"        tecken *= -1\n"
"        s += num / fact * tecken\n"
"    getcontext().prec -= 2\n"
"    returnera +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"Returnerar sinus för x mätt i radianer.\n"
"\n"
"    Taylorseriens approximation fungerar bäst för ett litet värde på x.\n"
"    För större värden beräknar du först x = x % (2 * pi).\n"
"\n"
"    >>> print(sin(Decimal('0,5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> Skriv ut(sin(0,5))\n"
"    0.479425538604\n"
"    >>> Skriv ut(sin(0,5+0j))\n"
"    (0.479425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    medan s != sista:\n"
"        sista = s\n"
"        i += 2\n"
"        fakta *= i * (i-1)\n"
"        num *= x * x\n"
"        tecken *= -1\n"
"        s += num / fact * tecken\n"
"    getcontext().prec -= 2\n"
"    returnera +s"

msgid "Decimal FAQ"
msgstr "Decimal FAQ"

msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""
"Q. Det är besvärligt att skriva ``decimal.Decimal('1234.5')``.  Finns det "
"något sätt att minimera skrivandet när man använder den interaktiva tolken?"

msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "A. Vissa användare förkortar konstruktören till bara en enda bokstav:"

msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""
"Q. I en fastpunktsapplikation med två decimaler har vissa indata många "
"decimaler och måste avrundas.  Andra ska inte ha överflödiga siffror och "
"måste valideras.  Vilka metoder bör användas?"

msgid ""
"A. The :meth:`~Decimal.quantize` method rounds to a fixed number of decimal "
"places. If the :const:`Inexact` trap is set, it is also useful for "
"validation:"
msgstr ""
"A. Metoden :meth:`~Decimal.quantize` avrundar till ett fast antal decimaler. "
"Om :const:`Inexact`-fällan är inställd är den också användbar för validering:"

msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""
"Q. När jag väl har giltiga tvåplatsinmatningar, hur behåller jag den "
"invariansen genom en applikation?"

msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`~Decimal.quantize` step:"
msgstr ""
"A. Vissa operationer, som addition, subtraktion och multiplikation med ett "
"heltal, bevarar automatiskt fixpunkten.  Andra operationer, t.ex. division "
"och multiplikation med annat än heltal, ändrar antalet decimaler och måste "
"följas upp med ett :meth:`~Decimal.quantize`-steg:"

msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`~Decimal.quantize` step:"
msgstr ""
"Vid utveckling av fastpunktstillämpningar är det praktiskt att definiera "
"funktioner för att hantera :meth:`~Decimal.quantize`-steget:"

msgid ""
"Q. There are many ways to express the same value.  The numbers ``200``, "
"``200.000``, ``2E2``, and ``.02E+4`` all have the same value at various "
"precisions. Is there a way to transform them to a single recognizable "
"canonical value?"
msgstr ""
"Q. Det finns många sätt att uttrycka samma värde.  Siffrorna ``200``, "
"``200.000``, ``2E2`` och ``.02E+4`` har alla samma värde med olika "
"noggrannhet. Finns det något sätt att omvandla dem till ett enda "
"igenkännbart kanoniskt värde?"

msgid ""
"A. The :meth:`~Decimal.normalize` method maps all equivalent values to a "
"single representative:"
msgstr ""
"A. Metoden :meth:`~Decimal.normalize` mappar alla likvärdiga värden till en "
"enda representant:"

msgid "Q. When does rounding occur in a computation?"
msgstr "Q. När sker avrundning i en beräkning?"

msgid ""
"A. It occurs *after* the computation.  The philosophy of the decimal "
"specification is that numbers are considered exact and are created "
"independent of the current context.  They can even have greater precision "
"than current context.  Computations process with those exact inputs and then "
"rounding (or other context operations) is applied to the *result* of the "
"computation::"
msgstr ""
"A. Det sker *efter* beräkningen.  Filosofin bakom decimalspecifikationen är "
"att tal betraktas som exakta och skapas oberoende av det aktuella "
"sammanhanget.  De kan till och med ha större precision än det aktuella "
"sammanhanget.  Beräkningar utförs med dessa exakta indata och sedan "
"tillämpas avrundning (eller andra kontextoperationer) på *resultatet* av "
"beräkningen::"

msgid ""
">>> getcontext().prec = 5\n"
">>> pi = Decimal('3.1415926535')   # More than 5 digits\n"
">>> pi                             # All digits are retained\n"
"Decimal('3.1415926535')\n"
">>> pi + 0                         # Rounded after an addition\n"
"Decimal('3.1416')\n"
">>> pi - Decimal('0.00005')        # Subtract unrounded numbers, then round\n"
"Decimal('3.1415')\n"
">>> pi + 0 - Decimal('0.00005').   # Intermediate values are rounded\n"
"Decimal('3.1416')"
msgstr ""
">>> getcontext().prec = 5\n"
">>> pi = Decimal('3.1415926535') # Mer än 5 siffror\n"
">>> pi # Alla siffror behålls\n"
"Decimal('3.1415926535')\n"
">>> pi + 0 # Avrundad efter en addition\n"
"Decimal('3.1416')\n"
">>> pi - Decimal('0.00005') # Subtrahera oavrundade tal, avrunda sedan\n"
"Decimal('3,1415')\n"
">>> pi + 0 - Decimal('0.00005').   # Mellanliggande värden avrundas\n"
"Decimal('3,1416')"

msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""
"Q. Vissa decimalvärden skrivs alltid ut med exponentiell notation.  Finns "
"det något sätt att få en icke-exponentiell representation?"

msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing "
"``5.0E+3`` as ``5000`` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"A. För vissa värden är exponentiell notation det enda sättet att uttrycka "
"antalet signifikanta ställen i koefficienten.  Om man t.ex. uttrycker "
"``5,0E+3`` som ``5000`` hålls värdet konstant, men man kan inte visa "
"originalets signifikans på två ställen."

msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""
"Om en applikation inte bryr sig om att spåra signifikans är det enkelt att "
"ta bort exponenten och de efterföljande nollorna, vilket gör att "
"signifikansen försvinner men värdet förblir oförändrat:"

msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr ""
"Q. Finns det något sätt att konvertera en vanlig float till en :class:"
"`Decimal`?"

msgid ""
"A. Yes, any binary floating-point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr ""
"A. Ja, alla binära flyttal kan uttryckas exakt som decimaltal, även om en "
"exakt konvertering kan kräva mer precision än intuitionen skulle föreslå:"

msgid ""
">>> Decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"
msgstr ""
">>> Decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"

msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""
"Q. Hur kan jag i en komplex beräkning försäkra mig om att jag inte har fått "
"ett felaktigt resultat på grund av otillräcklig precision eller "
"avrundningsavvikelser?"

msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"A. Decimalmodulen gör det enkelt att testa resultat.  En bra metod är att "
"köra om beräkningarna med större precision och med olika avrundningslägen. "
"Om resultaten skiljer sig mycket åt tyder det på otillräcklig precision, "
"problem med avrundningslägen, dåligt konditionerade indata eller en "
"numeriskt instabil algoritm."

msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""
"Q. Jag har märkt att kontextprecision tillämpas på resultatet av operationer "
"men inte på indata.  Finns det något att se upp med när man blandar värden "
"med olika precisioner?"

msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""
"A. Ja, det stämmer.  Principen är att alla värden anses vara exakta och det "
"gäller även aritmetiken för dessa värden.  Endast resultaten avrundas.  "
"Fördelen med inmatningar är att \"det du skriver är det du får\".  En "
"nackdel är att resultaten kan se konstiga ut om man glömmer att indata inte "
"har avrundats:"

msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.104') + Decimal('2.104')\n"
"Decimal('5.21')\n"
">>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')\n"
"Decimal('5.20')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> Decimal('3,104') + Decimal('2,104')\n"
"Decimal('5,21')\n"
">>> Decimal('3,104') + Decimal('0,000') + Decimal('2,104')\n"
"Decimal('5.20')"

msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""
"Lösningen är antingen att öka precisionen eller att tvinga fram avrundning "
"av indata med hjälp av den unära plusoperationen:"

msgid ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789')      # unary plus triggers rounding\n"
"Decimal('1.23')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789') # unary plus triggar avrundning\n"
"Decimal('1.23')"

msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""
"Alternativt kan indata avrundas vid skapandet med hjälp av metoden :meth:"
"`Context.create_decimal`:"

msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "Q. Är CPython-implementeringen snabb för stora tal?"

msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly rounded decimal floating-point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""
"A. Ja, det stämmer.  I CPython- och PyPy3-implementeringarna integrerar C/"
"CFFI-versionerna av decimalmodulen höghastighetsbiblioteket `libmpdec "
"<https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ för aritmetik "
"med flytande punkter med godtycklig precision och korrekt avrundad decimal "
"[#]_. ``libmpdec`` använder `Karatsuba-multiplikation <https://en.wikipedia."
"org/wiki/Karatsuba_algorithm>`_ för medelstora tal och `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ för "
"mycket stora tal."

msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`~Context.Emin` and :attr:`~Context.Emax` should always be set to the "
"maximum values, :attr:`~Context.clamp` should always be 0 (the default).  "
"Setting :attr:`~Context.prec` requires some care."
msgstr ""
"Kontexten måste anpassas för aritmetik med exakt godtycklig precision. :attr:"
"`~Context.Emin` och :attr:`~Context.Emax` bör alltid sättas till maximala "
"värden, :attr:`~Context.clamp` bör alltid vara 0 (standard).  Att ställa in :"
"attr:`~Context.prec` kräver viss försiktighet."

msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`~Context.prec` as well [#]_::"
msgstr ""
"Den enklaste metoden för att prova bignum-aritmetik är att använda det "
"maximala värdet för :attr:`~Context.prec` samt [#]_::"

msgid ""
">>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))\n"
">>> x = Decimal(2) ** 256\n"
">>> x / 128\n"
"Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')"
msgstr ""
">>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))\n"
">>> x = Decimal(2) ** 256\n"
">>> x / 128\n"
"Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')"

msgid ""
"For inexact results, :const:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr ""
"För inexakta resultat är :const:`MAX_PREC` alldeles för stor på 64-bitars "
"plattformar och det tillgängliga minnet kommer inte att räcka till::"

msgid ""
">>> Decimal(1) / 3\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"MemoryError"
msgstr ""
"&gt;&gt;&gt; Decimal(1) / 3\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"Minnesfel"

msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`~Context.prec` to the amount of available RAM.  Suppose "
"that you have 8GB of RAM and expect 10 simultaneous operands using a maximum "
"of 500MB each::"
msgstr ""
"På system med overallokering (t.ex. Linux) är en mer sofistikerad metod att "
"justera :attr:`~Context.prec` till mängden tillgängligt RAM-minne.  Anta att "
"du har 8 GB RAM och förväntar dig 10 samtidiga operander som använder "
"maximalt 500 MB vardera::"

msgid ""
">>> import sys\n"
">>>\n"
">>> # Maximum number of digits for a single operand using 500MB in 8-byte "
"words\n"
">>> # with 19 digits per word (4-byte and 9 digits for the 32-bit build):\n"
">>> maxdigits = 19 * ((500 * 1024**2) // 8)\n"
">>>\n"
">>> # Check that this works:\n"
">>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)\n"
">>> c.traps[Inexact] = True\n"
">>> setcontext(c)\n"
">>>\n"
">>> # Fill the available precision with nines:\n"
">>> x = Decimal(0).logical_invert() * 9\n"
">>> sys.getsizeof(x)\n"
"524288112\n"
">>> x + 2\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  decimal.Inexact: [<class 'decimal.Inexact'>]"
msgstr ""
">>> import sys\n"
">>>\n"
">>> # Maximum number of digits for a single operand using 500MB in 8-byte "
"words\n"
">>> # with 19 digits per word (4-byte and 9 digits for the 32-bit build):\n"
">>> maxdigits = 19 * ((500 * 1024**2) // 8)\n"
">>>\n"
">>> # Check that this works:\n"
">>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)\n"
">>> c.traps[Inexact] = True\n"
">>> setcontext(c)\n"
">>>\n"
">>> # Fill the available precision with nines:\n"
">>> x = Decimal(0).logical_invert() * 9\n"
">>> sys.getsizeof(x)\n"
"524288112\n"
">>> x + 2\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  decimal.Inexact: [<class 'decimal.Inexact'>]"

msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr ""
"I allmänhet (och i synnerhet i system utan overallokering) rekommenderas att "
"man uppskattar ännu snävare gränser och ställer in :attr:`Inexact`-fällan om "
"alla beräkningar förväntas vara exakta."

msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr ""
"Detta tillvägagångssätt fungerar nu för alla exakta resultat utom för icke-"
"integrerade potenser."
