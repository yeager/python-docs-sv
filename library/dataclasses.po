# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!dataclasses` --- Data Classes"
msgstr ":mod:`!dataclasses` --- Dataklasser"

msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**Källkod:** :source:`Lib/dataclasses.py`"

msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special methods <special method>` such as :meth:`~object."
"__init__` and :meth:`~object.__repr__` to user-defined classes.  It was "
"originally described in :pep:`557`."
msgstr ""
"Denna modul tillhandahåller en dekorator och funktioner för att automatiskt "
"lägga till genererade :term:`specialmetoder <special method>` såsom :meth:"
"`~object.__init__` och :meth:`~object.__repr__` till användardefinierade "
"klasser.  Den beskrevs ursprungligen i :pep:`557`."

msgid ""
"The member variables to use in these generated methods are defined using :"
"pep:`526` type annotations.  For example, this code::"
msgstr ""
"De medlemsvariabler som ska användas i dessa genererade metoder definieras "
"med hjälp av :pep:`526` typannoteringar.  Till exempel den här koden::"

msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataklass\n"
"klass InventoryItem:\n"
"    \"\"\"Klass för att hålla reda på ett objekt i inventering.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    kvantitet_på_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"

msgid "will add, among other things, a :meth:`!__init__` that looks like::"
msgstr ""
"kommer bland annat att lägga till en :meth:`!__init__` som ser ut så här::"

msgid ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"
msgstr ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = namn\n"
"    self.unit_price = enhetspris\n"
"    self.quantity_on_hand = kvantitet_on_hand"

msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the :class:`!InventoryItem` definition shown above."
msgstr ""
"Notera att denna metod automatiskt läggs till i klassen: den är inte direkt "
"specificerad i :class:`!InventoryItem`-definitionen som visas ovan."

msgid "Module contents"
msgstr "Modulens innehåll"

msgid ""
"This function is a :term:`decorator` that is used to add generated :term:"
"`special methods <special method>` to classes, as described below."
msgstr ""
"Denna funktion är en :term:`decorator` som används för att lägga till "
"genererade :term:`special methods <special method>` till klasser, enligt "
"beskrivningen nedan."

msgid ""
"The ``@dataclass`` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in "
"``@dataclass`` examines the type specified in the variable annotation."
msgstr ""
"Dekoratorn ``@dataclass`` undersöker klassen för att hitta ``field``.  Ett "
"``field`` definieras som en klassvariabel som har en :term:`type annotation "
"<variable annotation>`.  Med två undantag som beskrivs nedan, undersöker "
"ingenting i ``@dataclass`` den typ som anges i variabelannoteringen."

msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr ""
"Ordningen på fälten i alla de genererade metoderna är den ordning i vilken "
"de förekommer i klassdefinitionen."

msgid ""
"The ``@dataclass`` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"Dekoratorn ``@dataclass`` kommer att lägga till olika \"dunder\"-metoder "
"till klassen, beskrivna nedan.  Om någon av de tillagda metoderna redan "
"finns i klassen beror beteendet på parametern, vilket dokumenteras nedan. "
"Dekoratorn returnerar samma klass som den anropas på; ingen ny klass skapas."

msgid ""
"If ``@dataclass`` is used just as a simple decorator with no parameters, it "
"acts as if it has the default values documented in this signature.  That is, "
"these three uses of ``@dataclass`` are equivalent::"
msgstr ""
"Om ``@dataclass`` bara används som en enkel dekorator utan parametrar, "
"fungerar den som om den har de standardvärden som dokumenteras i denna "
"signatur.  Det vill säga, dessa tre användningar av ``@dataclass`` är "
"likvärdiga::"

msgid ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, "
"frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."
msgstr ""
"@dataklass\n"
"klass C:\n"
"    ...\n"
"\n"
"@dataklass()\n"
"klass C: ..:\n"
"    ...\n"
"\n"
"@dataklass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, "
"frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"klass C:\n"
"    ..."

msgid "The parameters to ``@dataclass`` are:"
msgstr "Parametrarna till ``@dataclass`` är:"

msgid ""
"*init*: If true (the default), a :meth:`~object.__init__` method will be "
"generated."
msgstr ""
"*init*: Om true (standard) kommer en :meth:`~object.__init__`-metod att "
"genereras."

msgid ""
"If the class already defines :meth:`!__init__`, this parameter is ignored."
msgstr ""
"Om klassen redan definierar :meth:`!__init__`, ignoreras denna parameter."

msgid ""
"*repr*: If true (the default), a :meth:`~object.__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"*repr*: Om true (standard) kommer en :meth:`~object.__repr__`-metod att "
"genereras.  Den genererade repr-strängen innehåller klassnamnet samt namn "
"och repr för varje fält, i den ordning de definieras i klassen.  Fält som är "
"markerade som uteslutna från repr inkluderas inte.  Till exempel: "
"``InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)``."

msgid ""
"If the class already defines :meth:`!__repr__`, this parameter is ignored."
msgstr ""
"Om klassen redan definierar :meth:`!__repr__`, ignoreras denna parameter."

msgid ""
"*eq*: If true (the default), an :meth:`~object.__eq__` method will be "
"generated.  This method compares the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type."
msgstr ""
"*eq*: Om true (standard) kommer en :meth:`~object.__eq__`-metod att "
"genereras.  Denna metod jämför klassen som om den vore en tupel av dess "
"fält, i ordning.  Båda instanserna i jämförelsen måste vara av samma typ."

msgid ""
"If the class already defines :meth:`!__eq__`, this parameter is ignored."
msgstr ""
"Om klassen redan definierar :meth:`!__eq__`, ignoreras denna parameter."

msgid ""
"*order*: If true (the default is ``False``), :meth:`~object.__lt__`, :meth:"
"`~object.__le__`, :meth:`~object.__gt__`, and :meth:`~object.__ge__` methods "
"will be generated.  These compare the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type.  If *order* is true and *eq* is false, a :exc:`ValueError` is raised."
msgstr ""
"*order*: Om true (standardvärdet är ``False``) kommer metoderna :meth:"
"`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object.__gt__` och :meth:"
"`~object.__ge__` att genereras.  Dessa jämför klassen som om den vore en "
"tupel av dess fält, i ordning.  Båda instanserna i jämförelsen måste vara av "
"samma typ.  Om *order* är sant och *eq* är falskt, genereras ett :exc:"
"`ValueError`."

msgid ""
"If the class already defines any of :meth:`!__lt__`, :meth:`!__le__`, :meth:"
"`!__gt__`, or :meth:`!__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"Om klassen redan definierar något av :meth:`!__lt__`, :meth:`!__le__`, :meth:"
"`!__gt__`, eller :meth:`!__ge__`, så kommer :exc:`TypeError` att tas upp."

msgid ""
"*unsafe_hash*: If true, force ``dataclasses`` to create a :meth:`~object."
"__hash__` method, even though it may not be safe to do so. Otherwise, "
"generate a :meth:`~object.__hash__` method according to how *eq* and "
"*frozen* are set. The default value is ``False``."
msgstr ""
"*unsafe_hash*: Om true, tvinga ``dataclasses`` att skapa en :meth:`~object."
"__hash__`-metod, även om det kanske inte är säkert att göra det. Annars "
"genereras en :meth:`~object.__hash__`-metod enligt hur *eq* och *frozen* är "
"inställda. Standardvärdet är ``False``."

msgid ""
":meth:`!__hash__` is used by built-in :meth:`hash`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a :meth:`!"
"__hash__` implies that instances of the class are immutable. Mutability is a "
"complicated property that depends on the programmer's intent, the existence "
"and behavior of :meth:`!__eq__`, and the values of the *eq* and *frozen* "
"flags in the ``@dataclass`` decorator."
msgstr ""
":meth:`!__hash__` används av den inbyggda :meth:`hash`, och när objekt läggs "
"till i hashade samlingar som dictionaries och sets.  Att ha en :meth:`!"
"__hash__` innebär att instanser av klassen är oföränderliga. Föränderlighet "
"är en komplicerad egenskap som beror på programmerarens avsikt, förekomsten "
"av och beteendet hos :meth:`!__eq__` samt värdena på flaggorna *eq* och "
"*frozen* i dekoratorn ``@dataclass``."

msgid ""
"By default, ``@dataclass`` will not implicitly add a :meth:`~object."
"__hash__` method unless it is safe to do so.  Neither will it add or change "
"an existing explicitly defined :meth:`!__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described "
"in the :meth:`!__hash__` documentation."
msgstr ""
"Som standard kommer ``@dataclass`` inte att implicit lägga till en :meth:"
"`~object.__hash__`-metod om det inte är säkert att göra det.  Inte heller "
"kommer den att lägga till eller ändra en befintlig explicit definierad :meth:"
"`!__hash__`-metod.  Att ställa in klassattributet ``__hash__ = None`` har en "
"specifik betydelse för Python, som beskrivs i :meth:`!__hash__`-"
"dokumentationen."

msgid ""
"If :meth:`!__hash__` is not explicitly defined, or if it is set to ``None``, "
"then ``@dataclass`` *may* add an implicit :meth:`!__hash__` method. Although "
"not recommended, you can force ``@dataclass`` to create a :meth:`!__hash__` "
"method with ``unsafe_hash=True``. This might be the case if your class is "
"logically immutable but can still be mutated. This is a specialized use case "
"and should be considered carefully."
msgstr ""
"Om :meth:`!__hash__` inte är explicit definierad, eller om den är satt till "
"``None``, så *kan* ``@dataclass`` lägga till en implicit :meth:`!__hash__`-"
"metod. Även om det inte rekommenderas kan du tvinga ``@dataklass`` att skapa "
"en :meth:`!__hash__`` metod med ``unsafe_hash=True``. Detta kan vara fallet "
"om din klass är logiskt oföränderlig men fortfarande kan muteras. Detta är "
"ett specialiserat användningsfall och bör övervägas noggrant."

msgid ""
"Here are the rules governing implicit creation of a :meth:`!__hash__` "
"method.  Note that you cannot both have an explicit :meth:`!__hash__` method "
"in your dataclass and set ``unsafe_hash=True``; this will result in a :exc:"
"`TypeError`."
msgstr ""
"Här är reglerna för implicit skapande av en :meth:`!__hash__`-metod.  "
"Observera att du inte både kan ha en explicit :meth:`!__hash__`-metod i din "
"dataklass och sätta ``unsafe_hash=True``; detta kommer att resultera i ett :"
"exc:`TypeError`."

msgid ""
"If *eq* and *frozen* are both true, by default ``@dataclass`` will generate "
"a :meth:`!__hash__` method for you.  If *eq* is true and *frozen* is false, :"
"meth:`!__hash__` will be set to ``None``, marking it unhashable (which it "
"is, since it is mutable).  If *eq* is false, :meth:`!__hash__` will be left "
"untouched meaning the :meth:`!__hash__` method of the superclass will be "
"used (if the superclass is :class:`object`, this means it will fall back to "
"id-based hashing)."
msgstr ""
"Om *eq* och *frozen* båda är true, kommer ``@dataclass`` som standard att "
"generera en :meth:`!__hash__`-metod åt dig.  Om *eq* är sant och *frozen* är "
"falskt, kommer :meth:`!__hash__` att sättas till ``None``, vilket markerar "
"att den inte är hashbar (vilket den är, eftersom den är mutabel).  Om *eq* "
"är false, kommer :meth:`!__hash__` att lämnas orörd vilket innebär att :meth:"
"`!__hash__` metoden i superklassen kommer att användas (om superklassen är :"
"class:`object`, innebär detta att den kommer att falla tillbaka till id-"
"baserad hashing)."

msgid ""
"*frozen*: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If :meth:"
"`~object.__setattr__` or :meth:`~object.__delattr__` is defined in the "
"class, then :exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"*fryst*: Om true (standard är ``False``), kommer tilldelning till fält att "
"generera ett undantag.  Detta emulerar skrivskyddade frysta instanser.  Om :"
"meth:`~object.__setattr__` eller :meth:`~object.__delattr__` är definierad i "
"klassen, så genereras :exc:`TypeError`.  Se diskussionen nedan."

msgid ""
"*match_args*: If true (the default is ``True``), the :attr:`~object."
"__match_args__` tuple will be created from the list of non keyword-only "
"parameters to the generated :meth:`~object.__init__` method (even if :meth:`!"
"__init__` is not generated, see above).  If false, or if :attr:`!"
"__match_args__` is already defined in the class, then :attr:`!"
"__match_args__` will not be generated."
msgstr ""
"*match_args*: Om true (standardvärdet är ``True``) skapas tupeln :attr:"
"`~object.__match_args__` från listan över parametrar som inte innehåller "
"nyckelord till den genererade metoden :meth:`~object.__init__` (även om :"
"meth:`!__init__` inte genereras, se ovan).  Om false, eller om :attr:`!"
"__match_args__` redan är definierad i klassen, kommer :attr:`!"
"__match_args__` inte att genereras."

msgid ""
"*kw_only*: If true (the default value is ``False``), then all fields will be "
"marked as keyword-only.  If a field is marked as keyword-only, then the only "
"effect is that the :meth:`~object.__init__` parameter generated from a "
"keyword-only field must be specified with a keyword when :meth:`!__init__` "
"is called. See the :term:`parameter` glossary entry for details.  Also see "
"the :const:`KW_ONLY` section."
msgstr ""
"*kw_only*: Om true anges (standardvärdet är ``False``) kommer alla fält att "
"markeras som keyword-only.  Om ett fält markeras som endast nyckelord är den "
"enda effekten att parametern :meth:`~object.__init__` som genereras från ett "
"fält med endast nyckelord måste anges med ett nyckelord när :meth:`!"
"__init__` anropas. Se ordlistan :term:`parameter` för mer information.  Se "
"även avsnittet :const:`KW_ONLY`."

msgid "Keyword-only fields are not included in :attr:`!__match_args__`."
msgstr ""
"Fält som endast innehåller nyckelord ingår inte i :attr:`!__match_args__`."

msgid ""
"*slots*: If true (the default is ``False``), :attr:`~object.__slots__` "
"attribute will be generated and new class will be returned instead of the "
"original one. If :attr:`!__slots__` is already defined in the class, then :"
"exc:`TypeError` is raised."
msgstr ""
"*slots*: Om true (default är ``False``), kommer attributet :attr:`~object."
"__slots__` att genereras och en ny klass kommer att returneras istället för "
"den ursprungliga. Om :attr:`!__slots__` redan är definierat i klassen, "
"kommer :exc:`TypeError` att returneras."

msgid ""
"Passing parameters to a base class :meth:`~object.__init_subclass__` when "
"using ``slots=True`` will result in a :exc:`TypeError`. Either use "
"``__init_subclass__`` with no parameters or use default values as a "
"workaround. See :gh:`91126` for full details."
msgstr ""
"Att skicka parametrar till en basklass :meth:`~object.__init_subclass__` när "
"man använder ``slots=True`` kommer att resultera i ett :exc:`TypeError`. "
"Använd antingen ``__init_subclass__`` utan parametrar eller använd "
"standardvärden som en lösning. Se :gh:`91126` för fullständig information."

msgid ""
"If a field name is already included in the :attr:`!__slots__` of a base "
"class, it will not be included in the generated :attr:`!__slots__` to "
"prevent :ref:`overriding them <datamodel-note-slots>`. Therefore, do not "
"use :attr:`!__slots__` to retrieve the field names of a dataclass. Use :func:"
"`fields` instead. To be able to determine inherited slots, base class :attr:"
"`!__slots__` may be any iterable, but *not* an iterator."
msgstr ""
"Om ett fältnamn redan ingår i :attr:`!__slots__` för en basklass kommer det "
"inte att ingå i den genererade :attr:`!__slots__` för att förhindra att :ref:"
"`överskriver dem <datamodel-note-slots>`. Använd därför inte :attr:`!"
"__slots__` för att hämta fältnamnen i en dataklass. Använd :func:`fields` "
"istället. För att kunna bestämma ärvda slots kan basklassen :attr:`!"
"__slots__` vara vilken iterabel som helst, men *inte* en iterator."

msgid ""
"*weakref_slot*: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance :func:`weakref-able "
"<weakref.ref>`. It is an error to specify ``weakref_slot=True`` without also "
"specifying ``slots=True``."
msgstr ""
"*weakref_slot*: Om true (standard är ``False``), lägg till en slot med "
"namnet \"__weakref__\", som krävs för att göra en instans :func:`weakref-"
"able <weakref.ref>`. Det är ett fel att ange ``weakref_slot=True`` utan att "
"också ange ``slots=True``."

msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr ""
"``field`` kan valfritt ange ett standardvärde, med normal Python-syntax::"

msgid ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' has no default value\n"
"    b: int = 0   # assign a default value for 'b'"
msgstr ""
"@dataklass\n"
"klass C:\n"
"    a: int # 'a' har inget förinställt värde\n"
"    b: int = 0 # tilldela ett förinställt värde för 'b'"

msgid ""
"In this example, both :attr:`!a` and :attr:`!b` will be included in the "
"added :meth:`~object.__init__` method, which will be defined as::"
msgstr ""
"I detta exempel kommer både :attr:`!a` och :attr:`!b` att inkluderas i den "
"tillagda :meth:`~object.__init__`-metoden, som kommer att definieras som::"

msgid "def __init__(self, a: int, b: int = 0):"
msgstr "def __init__(self, a: int, b: int = 0):"

msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a "
"field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
":exc:`TypeError` kommer att uppstå om ett fält utan ett standardvärde följer "
"ett fält med ett standardvärde.  Detta gäller oavsett om det sker i en enda "
"klass eller som ett resultat av klassarv."

msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`!field` "
"function.  For example::"
msgstr ""
"För vanliga och enkla användningsfall krävs ingen annan funktionalitet.  Det "
"finns dock vissa dataklassfunktioner som kräver ytterligare information per "
"fält.  För att tillgodose detta behov av ytterligare information kan du "
"ersätta standardvärdet för fältet med ett anrop till den medföljande "
"funktionen :func:`!field`.  Till exempel::"

msgid ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"
msgstr ""
"@dataklass\n"
"klass C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"

msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"Som visas ovan är :const:`MISSING`-värdet ett sentinel-objekt som används "
"för att upptäcka om vissa parametrar tillhandahålls av användaren. Denna "
"sentinel används eftersom ``None`` är ett giltigt värde för vissa parametrar "
"med en distinkt betydelse.  Ingen kod bör direkt använda :const:`MISSING`-"
"värdet."

msgid "The parameters to :func:`!field` are:"
msgstr "Parametrarna till :func:`!field` är:"

msgid ""
"*default*: If provided, this will be the default value for this field.  This "
"is needed because the :func:`!field` call itself replaces the normal "
"position of the default value."
msgstr ""
"*default*: Om det anges kommer detta att vara standardvärdet för fältet.  "
"Detta behövs eftersom :func:`!field`-anropet i sig ersätter den normala "
"positionen för standardvärdet."

msgid ""
"*default_factory*: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as "
"discussed below.  It is an error to specify both *default* and "
"*default_factory*."
msgstr ""
"*default_factory*: Om det anges måste det vara en nollargumentskallelse som "
"anropas när ett standardvärde behövs för detta fält.  Detta kan bland annat "
"användas för att ange fält med föränderliga standardvärden, vilket "
"diskuteras nedan.  Det är ett fel att ange både *default* och "
"*default_factory*."

msgid ""
"*init*: If true (the default), this field is included as a parameter to the "
"generated :meth:`~object.__init__` method."
msgstr ""
"*init*: Om true (standard) inkluderas detta fält som en parameter i den "
"genererade :meth:`~object.__init__`-metoden."

msgid ""
"*repr*: If true (the default), this field is included in the string returned "
"by the generated :meth:`~object.__repr__` method."
msgstr ""
"*repr*: Om true (standard) inkluderas detta fält i den sträng som returneras "
"av den genererade metoden :meth:`~object.__repr__`."

msgid ""
"*hash*: This can be a bool or ``None``.  If true, this field is included in "
"the generated :meth:`~object.__hash__` method.  If false, this field is "
"excluded from the generated :meth:`~object.__hash__`. If ``None`` (the "
"default), use the value of *compare*: this would normally be the expected "
"behavior, since a field should be included in the hash if it's used for "
"comparisons.  Setting this value to anything other than ``None`` is "
"discouraged."
msgstr ""
"*hash*: Detta kan vara en bool eller ``None``.  Om true, inkluderas detta "
"fält i den genererade metoden :meth:`~object.__hash__`.  Om false, "
"exkluderas detta fält från den genererade :meth:`~object.__hash__`. Om "
"``None`` (standard), använd värdet för *compare*: detta skulle normalt vara "
"det förväntade beteendet, eftersom ett fält bör ingå i hashen om det används "
"för jämförelser.  Att ställa in detta värde till något annat än ``None`` "
"avråds."

msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a "
"field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"En möjlig anledning till att ställa in ``hash=False`` men ``compare=True`` "
"skulle vara om ett fält är dyrt att beräkna ett hashvärde för, det fältet "
"behövs för likhetstestning och det finns andra fält som bidrar till typens "
"hashvärde.  Även om ett fält utesluts från hashvärdet kommer det ändå att "
"användas för jämförelser."

msgid ""
"*compare*: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`~object.__eq__`, :meth:`~object."
"__gt__`, et al.)."
msgstr ""
"*compare*: Om true (standard) inkluderas detta fält i de genererade "
"metoderna för likhet och jämförelse (:meth:`~object.__eq__`, :meth:`~object."
"__gt__`, etc.)."

msgid ""
"*metadata*: This can be a mapping or ``None``. ``None`` is treated as an "
"empty dict.  This value is wrapped in :func:`~types.MappingProxyType` to "
"make it read-only, and exposed on the :class:`Field` object. It is not used "
"at all by Data Classes, and is provided as a third-party extension "
"mechanism. Multiple third-parties can each have their own key, to use as a "
"namespace in the metadata."
msgstr ""
"*metadata*: Detta kan vara en mappning eller ``None``. ``None`` behandlas "
"som en tom dict.  Detta värde är inkapslat i :func:`~types.MappingProxyType` "
"för att göra det skrivskyddat och exponeras på :class:`Field`-objektet. Det "
"används inte alls av dataklasser, utan tillhandahålls som en "
"tilläggsmekanism från tredje part. Flera tredje parter kan var och en ha sin "
"egen nyckel, för att användas som ett namnområde i metadata."

msgid ""
"*kw_only*: If true, this field will be marked as keyword-only. This is used "
"when the generated :meth:`~object.__init__` method's parameters are computed."
msgstr ""
"*kw_only*: Om true, markeras detta fält som keyword-only. Detta används när "
"parametrarna för den genererade :meth:`~object.__init__`-metoden beräknas."

msgid "Keyword-only fields are also not included in :attr:`!__match_args__`."
msgstr ""
"Fält som endast innehåller nyckelord ingår inte heller i :attr:`!"
"__match_args__`."

msgid "*doc*: optional docstring for this field."
msgstr "*doc*: valfri docstring för detta fält."

msgid ""
"If the default value of a field is specified by a call to :func:`!field`, "
"then the class attribute for this field will be replaced by the specified "
"*default* value.  If *default* is not provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`@dataclass "
"<dataclass>` decorator runs, the class attributes will all contain the "
"default values for the fields, just as if the default value itself were "
"specified.  For example, after::"
msgstr ""
"Om standardvärdet för ett fält anges genom ett anrop till :func:`!field`, "
"kommer klassattributet för detta fält att ersättas med det angivna *default*-"
"värdet.  Om *default* inte anges kommer klassattributet att tas bort.  "
"Avsikten är att efter att dekoratorn :func:`@dataclass <dataclass>` har "
"körts, kommer alla klassattribut att innehålla standardvärden för fälten, "
"precis som om standardvärdet självt hade angetts.  Till exempel, efter::"

msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"
msgstr ""
"@dataklass\n"
"klass C:\n"
"    x: int\n"
"    y: int = fält(repr=False)\n"
"    z: int = fält(repr=False, default=10)\n"
"    t: int = 20"

msgid ""
"The class attribute :attr:`!C.z` will be ``10``, the class attribute :attr:`!"
"C.t` will be ``20``, and the class attributes :attr:`!C.x` and :attr:`!C.y` "
"will not be set."
msgstr ""
"Klassattributet :attr:`!C.z` kommer att vara ``10``, klassattributet :attr:`!"
"C.t` kommer att vara ``20`` och klassattributen :attr:`!C.x` och :attr:`!C."
"y` kommer inte att anges."

msgid ""
":class:`!Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`!Field` object "
"directly.  Its documented attributes are:"
msgstr ""
":class:`!Field`-objekt beskriver varje definierat fält. Dessa objekt skapas "
"internt och returneras av metoden :func:`fields` på modulnivå (se nedan).  "
"Användare bör aldrig instansiera ett :class:`!Field`-objekt direkt.  Dess "
"dokumenterade attribut är:"

msgid ":attr:`!name`: The name of the field."
msgstr ":attr:`!name`: Namnet på fältet."

msgid ":attr:`!type`: The type of the field."
msgstr ":attr:`!typ`: Typen av fält."

msgid ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :"
"attr:`!hash`, :attr:`!compare`, :attr:`!metadata`, and :attr:`!kw_only` have "
"the identical meaning and values as they do in the :func:`field` function."
msgstr ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :"
"attr:`!hash`, :attr:`!compare`, :attr:`!metadata` och :attr:`!kw_only` har "
"samma betydelse och värden som de har i funktionen :func:`field`."

msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr ""
"Andra attribut kan finnas, men de är privata och får inte inspekteras eller "
"åberopas."

msgid ""
"``InitVar[T]`` type annotations describe variables that are :ref:`init-only "
"<dataclasses-init-only-variables>`. Fields annotated with :class:`!InitVar` "
"are considered pseudo-fields, and thus are neither returned by the :func:"
"`fields` function nor used in any way except adding them as parameters to :"
"meth:`~object.__init__` and an optional :meth:`__post_init__`."
msgstr ""
"typannoteringarna ``InitVar[T]`` beskriver variabler som är :ref:``init-only "
"<dataclasses-init-only-variables>``. Fält annoterade med :class:`!InitVar` "
"betraktas som pseudofält och returneras därför varken av funktionen :func:"
"`fields` eller används på något annat sätt än att de läggs till som "
"parametrar i :meth:`~object.__init__` och en valfri :meth:`__post_init__`."

msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"Returnerar en tupel av :class:`Field`-objekt som definierar fälten för denna "
"dataklass.  Accepterar antingen en dataklass eller en instans av en "
"dataklass. Utlöser :exc:`TypeError` om ingen dataklass eller instans av en "
"dataklass skickas. Returnerar inte pseudofält som är ``ClassVar`` eller "
"``InitVar``."

msgid ""
"Converts the dataclass *obj* to a dict (by using the factory function "
"*dict_factory*).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Konverterar dataklassen *obj* till en dict (med hjälp av fabriksfunktionen "
"*dict_factory*).  Varje dataklass konverteras till en dict av dess fält, som "
"``namn: värde``-par. dataklasser, dicts, listor och tupler recursas in i.  "
"Andra objekt kopieras med :func:`copy.deepcopy`."

msgid "Example of using :func:`!asdict` on nested dataclasses::"
msgstr "Exempel på användning av :func:`!asdict` på nästlade dataklasser::"

msgid ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"
msgstr ""
"@dataklass\n"
"klass Punkt:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataklass\n"
"klass C:\n"
"     mylist: lista[Punkt]\n"
"\n"
"p = Punkt(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Punkt(0, 0), Punkt(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"

msgid "To create a shallow copy, the following workaround may be used::"
msgstr "Om du vill skapa en ytlig kopia kan du använda följande lösning::"

msgid "{field.name: getattr(obj, field.name) for field in fields(obj)}"
msgstr "{field.name: getattr(obj, field.name) for field in fields(obj)}"

msgid ""
":func:`!asdict` raises :exc:`TypeError` if *obj* is not a dataclass instance."
msgstr ""
":func:`!asdict` ger upphov till :exc:`TypeError` om *obj* inte är en "
"dataklassinstans."

msgid ""
"Converts the dataclass *obj* to a tuple (by using the factory function "
"*tuple_factory*).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Konverterar dataklassen *obj* till en tupel (med hjälp av fabriksfunktionen "
"*tuple_factory*).  Varje dataklass konverteras till en tupel av dess "
"fältvärden. dataklasser, dicts, listor och tuplar recursas till. Andra "
"objekt kopieras med :func:`copy.deepcopy`."

msgid "Continuing from the previous example::"
msgstr "Fortsättning från föregående exempel::"

msgid ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"
msgstr ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"

msgid "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"
msgstr "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"

msgid ""
":func:`!astuple` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr ""
":func:`!astuple` ger upphov till :exc:`TypeError` om *obj* inte är en "
"dataklassinstans."

msgid ""
"Creates a new dataclass with name *cls_name*, fields as defined in *fields*, "
"base classes as given in *bases*, and initialized with a namespace as given "
"in *namespace*.  *fields* is an iterable whose elements are each either "
"``name``, ``(name, type)``, or ``(name, type, Field)``.  If just ``name`` is "
"supplied, :data:`typing.Any` is used for ``type``.  The values of *init*, "
"*repr*, *eq*, *order*, *unsafe_hash*, *frozen*, *match_args*, *kw_only*, "
"*slots*, and *weakref_slot* have the same meaning as they do in :func:"
"`@dataclass <dataclass>`."
msgstr ""
"Skapar en ny dataklass med namnet *cls_name*, fält som definieras i "
"*fields*, basklasser som anges i *bases* och initialiseras med ett "
"namnområde som anges i *namespace*.  *fields* är en iterabel vars element är "
"antingen ``name``, ``(name, type)`` eller ``(name, type, Field)``.  Om bara "
"``name`` anges, används :data:`typing.Any` för ``type``.  Värdena för "
"*init*, *repr*, *eq*, *order*, *unsafe_hash*, *frozen*, *match_args*, "
"*kw_only*, *slots* och *weakref_slot* har samma betydelse som de har i :func:"
"`@dataclass <dataclass>`."

msgid ""
"If *module* is defined, the :attr:`!__module__` attribute of the dataclass "
"is set to that value. By default, it is set to the module name of the caller."
msgstr ""
"Om *module* är definierat, kommer attributet :attr:`!__module__` i "
"dataklassen att sättas till det värdet. Som standard sätts det till "
"modulnamnet för den som anropar."

msgid ""
"The *decorator* parameter is a callable that will be used to create the "
"dataclass. It should take the class object as a first argument and the same "
"keyword arguments as :func:`@dataclass <dataclass>`. By default, the :func:"
"`@dataclass <dataclass>` function is used."
msgstr ""
"Parametern *decorator* är en callable som kommer att användas för att skapa "
"dataklassen. Den bör ta klassobjektet som ett första argument och samma "
"nyckelordsargument som :func:`@dataclass <dataclass>`. Som standard används "
"funktionen :func:`@dataclass <dataclass>`."

msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with :attr:`!__annotations__` can then apply the :func:"
"`@dataclass <dataclass>` function to convert that class to a dataclass.  "
"This function is provided as a convenience.  For example::"
msgstr ""
"Denna funktion är inte absolut nödvändig, eftersom alla Python-mekanismer "
"för att skapa en ny klass med :attr:`!__annotations__` sedan kan använda "
"funktionen :func:`@dataclass <dataclass>` för att konvertera klassen till en "
"dataklass.  Denna funktion tillhandahålls som en bekvämlighet.  Till "
"exempel::"

msgid ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"
msgstr ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"

msgid "Is equivalent to::"
msgstr "Är likvärdig med::"

msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"
msgstr ""
"@dataklass\n"
"klass C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        returnera self.x + 1"

msgid "Added the *decorator* parameter."
msgstr "Parametern *decorator* har lagts till."

msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values "
"from *changes*.  If *obj* is not a Data Class, raises :exc:`TypeError`.  If "
"keys in *changes* are not field names of the given dataclass, raises :exc:"
"`TypeError`."
msgstr ""
"Skapar ett nytt objekt av samma typ som *obj* och ersätter fälten med värden "
"från *changes*.  Om *obj* inte är en dataklass, uppstår :exc:`TypeError`.  "
"Om nycklarna i *changes* inte är fältnamn i den angivna dataklassen, "
"uppstår :exc:`TypeError`."

msgid ""
"The newly returned object is created by calling the :meth:`~object.__init__` "
"method of the dataclass.  This ensures that :meth:`__post_init__`, if "
"present, is also called."
msgstr ""
"Det nyligen returnerade objektet skapas genom anrop av metoden :meth:"
"`~object.__init__` i dataklassen.  Detta säkerställer att :meth:"
"`__post_init__`, om sådan finns, också anropas."

msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`!replace` so that they can be passed to :meth:`!"
"__init__` and :meth:`__post_init__`."
msgstr ""
"Init-only variabler utan standardvärden, om sådana finns, måste anges i "
"anropet till :func:`!replace` så att de kan skickas till :meth:`!__init__` "
"och :meth:`__post_init__`."

msgid ""
"It is an error for *changes* to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"Det är ett fel om *changes* innehåller några fält som definieras som att de "
"har ``init=False``.  Ett :exc:`ValueError` kommer att uppstå i detta fall."

msgid ""
"Be forewarned about how ``init=False`` fields work during a call to :func:`!"
"replace`.  They are not copied from the source object, but rather are "
"initialized in :meth:`__post_init__`, if they're initialized at all.  It is "
"expected that ``init=False`` fields will be rarely and judiciously used.  If "
"they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom :func:`!replace` (or similarly named) method which handles "
"instance copying."
msgstr ""
"Var försiktig med hur ``init=False``-fält fungerar under ett anrop till :"
"func:`!replace`.  De kopieras inte från källobjektet utan initieras i :meth:"
"`__post_init__`, om de initieras överhuvudtaget.  Det förväntas att "
"``init=False``-fält kommer att användas sällan och med omdöme.  Om de "
"används kan det vara klokt att ha alternativa klasskonstruktörer, eller "
"kanske en anpassad :func:`!replace`-metod (eller liknande namn) som hanterar "
"kopiering av instanser."

msgid ""
"Dataclass instances are also supported by generic function :func:`copy."
"replace`."
msgstr ""
"Dataklassinstanser stöds också av den generiska funktionen :func:`copy."
"replace`."

msgid ""
"Return ``True`` if its parameter is a dataclass (including subclasses of a "
"dataclass) or an instance of one, otherwise return ``False``."
msgstr ""
"Returnerar ``True`` om dess parameter är en dataklass (inklusive "
"underklasser av en dataklass) eller en instans av en sådan, annars "
"returneras ``False``."

msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"Om du behöver veta om en klass är en instans av en dataklass (och inte en "
"dataklass i sig), lägg då till ytterligare en kontroll för ``not "
"isinstance(obj, type)``::"

msgid ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"
msgstr ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) och inte isinstance(obj, type)"

msgid "A sentinel value signifying a missing default or default_factory."
msgstr "Ett sentinelvärde som visar att default eller default_factory saknas."

msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field "
"with the type of :const:`!KW_ONLY` are marked as keyword-only fields.  Note "
"that a pseudo-field of type :const:`!KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`!KW_ONLY` field.  Keyword-only fields signify :"
"meth:`~object.__init__` parameters that must be specified as keywords when "
"the class is instantiated."
msgstr ""
"Ett sentinelvärde som används som en typannotering.  Alla fält efter ett "
"pseudofält av typen :const:`!KW_ONLY` markeras som fält som endast "
"innehåller nyckelord.  Observera att ett pseudofält av typen :const:`!"
"KW_ONLY` annars ignoreras helt.  Detta gäller även namnet på ett sådant "
"fält.  Av konvention används namnet ``_`` för ett fält av typen :const:`!"
"KW_ONLY`.  Fält som endast innehåller nyckelord betecknar :meth:`~object."
"__init__`-parametrar som måste anges som nyckelord när klassen instansieras."

msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr ""
"I det här exemplet markeras fälten ``y`` och ``z`` som fält med endast "
"nyckelord::"

msgid ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"
msgstr ""
"@dataklass\n"
"klass Punkt:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Punkt(0, y=1,5, z=2,0)"

msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`!KW_ONLY`."
msgstr ""
"I en enskild dataklass är det ett fel att ange mer än ett fält vars typ är :"
"const:`!KW_ONLY`."

msgid ""
"Raised when an implicitly defined :meth:`~object.__setattr__` or :meth:"
"`~object.__delattr__` is called on a dataclass which was defined with "
"``frozen=True``. It is a subclass of :exc:`AttributeError`."
msgstr ""
"Uppstår när en implicit definierad :meth:`~object.__setattr__` eller :meth:"
"`~object.__delattr__` anropas på en dataklass som definierades med "
"``frozen=True``. Det är en underklass till :exc:`AttributeError`."

msgid "Post-init processing"
msgstr "Behandling efter initiering"

msgid ""
"When defined on the class, it will be called by the generated :meth:`~object."
"__init__`, normally as :meth:`!self.__post_init__`. However, if any "
"``InitVar`` fields are defined, they will also be passed to :meth:`!"
"__post_init__` in the order they were defined in the class.  If no :meth:`!"
"__init__` method is generated, then :meth:`!__post_init__` will not "
"automatically be called."
msgstr ""
"När den definieras i klassen kommer den att anropas av den genererade :meth:"
"`~object.__init__`, normalt som :meth:`!self.__post_init__`. Men om några "
"``InitVar``-fält är definierade, kommer de också att skickas till :meth:`!"
"__post_init__` i den ordning de definierades i klassen.  Om ingen :meth:`!"
"__init__`-metod genereras kommer :meth:`!__post_init__` inte att anropas "
"automatiskt."

msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr ""
"Detta gör det bland annat möjligt att initiera fältvärden som är beroende av "
"ett eller flera andra fält.  Till exempel::"

msgid ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"
msgstr ""
"@dataklass\n"
"klass C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = fält(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"

msgid ""
"The :meth:`~object.__init__` method generated by :func:`@dataclass "
"<dataclass>` does not call base class :meth:`!__init__` methods. If the base "
"class has an :meth:`!__init__` method that has to be called, it is common to "
"call this method in a :meth:`__post_init__` method::"
msgstr ""
"Metoden :meth:`~object.__init__` som genereras av :func:`@dataclass "
"<dataclass>` anropar inte basklassens :meth:`!__init__`-metoder. Om "
"basklassen har en :meth:`!__init__`-metod som måste anropas är det vanligt "
"att anropa denna metod i en :meth:`__post_init__`-metod::"

msgid ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"        self.height = height\n"
"        self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"
msgstr ""
"klass Rektangel:\n"
"    def __init__(self, höjd, bredd):\n"
"        self.height = höjd\n"
"        self.width = bredd\n"
"\n"
"@dataklass\n"
"klass Kvadrat(Rektangel):\n"
"    sida: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"

msgid ""
"Note, however, that in general the dataclass-generated :meth:`!__init__` "
"methods don't need to be called, since the derived dataclass will take care "
"of initializing all fields of any base class that is a dataclass itself."
msgstr ""
"Observera dock att de dataklassgenererade :meth:`!__init__'-metoderna i "
"allmänhet inte behöver anropas, eftersom den härledda dataklassen tar hand "
"om initieringen av alla fält i alla basklasser som själva är en dataklass."

msgid ""
"See the section below on init-only variables for ways to pass parameters to :"
"meth:`!__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"Se avsnittet nedan om init-only variabler för sätt att skicka parametrar "
"till :meth:`!__post_init__`.  Se även varningen om hur :func:`replace` "
"hanterar ``init=False`` fält."

msgid "Class variables"
msgstr "Klassvariabler"

msgid ""
"One of the few places where :func:`@dataclass <dataclass>` actually inspects "
"the type of a field is to determine if a field is a class variable as "
"defined in :pep:`526`.  It does this by checking if the type of the field "
"is :data:`typing.ClassVar`.  If a field is a ``ClassVar``, it is excluded "
"from consideration as a field and is ignored by the dataclass mechanisms.  "
"Such ``ClassVar`` pseudo-fields are not returned by the module-level :func:"
"`fields` function."
msgstr ""
"Ett av de få ställen där :func:`@dataclass <dataclass>` faktiskt "
"kontrollerar typen av ett fält är för att avgöra om ett fält är en "
"klassvariabel enligt definitionen i :pep:`526`.  Detta görs genom att "
"kontrollera om fältets typ är :data:`typing.ClassVar`.  Om ett fält är en "
"``ClassVar`` är det uteslutet från att betraktas som ett fält och ignoreras "
"av dataklassmekanismerna.  Sådana pseudofält av typen ``ClassVar`` "
"returneras inte av funktionen :func:`fields` på modulnivå."

msgid "Init-only variables"
msgstr "Init-only-variabler"

msgid ""
"Another place where :func:`@dataclass <dataclass>` inspects a type "
"annotation is to determine if a field is an init-only variable.  It does "
"this by seeing if the type of a field is of type :class:`InitVar`.  If a "
"field is an :class:`InitVar`, it is considered a pseudo-field called an init-"
"only field.  As it is not a true field, it is not returned by the module-"
"level :func:`fields` function.  Init-only fields are added as parameters to "
"the generated :meth:`~object.__init__` method, and are passed to the "
"optional :meth:`__post_init__` method.  They are not otherwise used by "
"dataclasses."
msgstr ""
"Ett annat ställe där :func:`@dataclass <dataclass>` inspekterar en "
"typannotering är för att avgöra om ett fält är en init-only-variabel.  Detta "
"görs genom att se om fältets typ är av typen :class:`InitVar`.  Om ett fält "
"är av typen :class:`InitVar`, betraktas det som ett pseudofält som kallas "
"ett init-only-fält.  Eftersom det inte är ett riktigt fält returneras det "
"inte av funktionen :func:`fields` på modulnivå.  Init-only-fält läggs till "
"som parametrar i den genererade metoden :meth:`~object.__init__` och skickas "
"till den valfria metoden :meth:`__post_init__`.  De används inte på annat "
"sätt av dataklasser."

msgid ""
"For example, suppose a field will be initialized from a database, if a value "
"is not provided when creating the class::"
msgstr ""
"Anta t.ex. att ett fält initieras från en databas om inget värde anges när "
"klassen skapas::"

msgid ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"
msgstr ""
"@dataklass\n"
"klass C:\n"
"    i: int\n"
"    j: int | Ingen = Ingen\n"
"    databas: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, databas):\n"
"        om self.j är None och databasen inte är None:\n"
"            self.j = databas.lookup('j')\n"
"\n"
"c = C(10, databas=min_databas)"

msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for :attr:`!"
"i` and :attr:`!j`, but not for :attr:`!database`."
msgstr ""
"I det här fallet kommer :func:`fields` att returnera :class:`Field`-objekt "
"för :attr:`!i` och :attr:`!j`, men inte för :attr:`!database`."

msgid "Frozen instances"
msgstr "Frysta instanser"

msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :func:`@dataclass <dataclass>` decorator you "
"can emulate immutability.  In that case, dataclasses will add :meth:`~object."
"__setattr__` and :meth:`~object.__delattr__` methods to the class.  These "
"methods will raise a :exc:`FrozenInstanceError` when invoked."
msgstr ""
"Det är inte möjligt att skapa verkligt oföränderliga Python-objekt.  Men "
"genom att skicka ``frozen=True`` till :func:`@dataclass <dataclass>` "
"dekoratorn kan du emulera oföränderlighet.  I så fall kommer dataclasses att "
"lägga till :meth:`~object.__setattr__` och :meth:`~object.__delattr__` "
"metoder till klassen.  Dessa metoder kommer att ge upphov till ett :exc:"
"`FrozenInstanceError` när de anropas."

msgid ""
"There is a tiny performance penalty when using ``frozen=True``: :meth:"
"`~object.__init__` cannot use simple assignment to initialize fields, and "
"must use :meth:`!object.__setattr__`."
msgstr ""
"Det finns en liten prestandaförlust när man använder ``frozen=True``: :meth:"
"`~object.__init__` kan inte använda enkel tilldelning för att initiera fält, "
"utan måste använda :meth:`!object.__setattr__`."

msgid "Inheritance"
msgstr "Ärftlighet"

msgid ""
"When the dataclass is being created by the :func:`@dataclass <dataclass>` "
"decorator, it looks through all of the class's base classes in reverse MRO "
"(that is, starting at :class:`object`) and, for each dataclass that it "
"finds, adds the fields from that base class to an ordered mapping of fields. "
"After all of the base class fields are added, it adds its own fields to the "
"ordered mapping.  All of the generated methods will use this combined, "
"calculated ordered mapping of fields.  Because the fields are in insertion "
"order, derived classes override base classes.  An example::"
msgstr ""
"När dataklassen skapas av dekoratorn :func:`@dataclass <dataclass>` går den "
"igenom alla klassens basklasser i omvänd MRO (dvs. börjar med :class:"
"`object`) och för varje dataklass som den hittar lägger den till fälten från "
"basklassen i en ordnad mappning av fält. När alla basklassens fält har lagts "
"till, lägger den till sina egna fält i den ordnade mappningen.  Alla "
"genererade metoder kommer att använda denna kombinerade, beräknade ordnade "
"mappning av fält.  Eftersom fälten är i inmatningsordning åsidosätter "
"härledda klasser basklasser.  Ett exempel::"

msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"
msgstr ""
"@dataklass\n"
"klass Bas:\n"
"    x: Valfritt = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataklass\n"
"klass C(Bas):\n"
"    z: int = 10\n"
"    x: int = 15"

msgid ""
"The final list of fields is, in order, :attr:`!x`, :attr:`!y`, :attr:`!z`.  "
"The final type of :attr:`!x` is :class:`int`, as specified in class :class:`!"
"C`."
msgstr ""
"Den slutliga listan av fält är, i ordning, :attr:`!x`, :attr:`!y`, :attr:`!"
"z`.  Den slutliga typen av :attr:`!x` är :class:`int`, som specificeras i "
"klassen :class:`!C`."

msgid ""
"The generated :meth:`~object.__init__` method for :class:`!C` will look "
"like::"
msgstr ""
"Den genererade :meth:`~object.__init__`-metoden för :class:`!C` kommer att "
"se ut så här::"

msgid "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"
msgstr "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"

msgid "Re-ordering of keyword-only parameters in :meth:`!__init__`"
msgstr ""
"Omordning av parametrar som endast innehåller nyckelord i :meth:`!__init__`"

msgid ""
"After the parameters needed for :meth:`~object.__init__` are computed, any "
"keyword-only parameters are moved to come after all regular (non-keyword-"
"only) parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"Efter att de parametrar som behövs för :meth:`~object.__init__` har "
"beräknats, flyttas alla parametrar med endast nyckelord till att komma efter "
"alla vanliga (icke-nyckelordsbara) parametrar.  Detta är ett krav på hur "
"parametrar med endast nyckelord implementeras i Python: de måste komma efter "
"parametrar utan endast nyckelord."

msgid ""
"In this example, :attr:`!Base.y`, :attr:`!Base.w`, and :attr:`!D.t` are "
"keyword-only fields, and :attr:`!Base.x` and :attr:`!D.z` are regular "
"fields::"
msgstr ""
"I det här exemplet är :attr:`!Base.y`, :attr:`!Base.w` och :attr:`!D.t` fält "
"med endast nyckelord, och :attr:`!Base.x` och :attr:`!D.z` är vanliga fält:"

msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"
msgstr ""
"@dataklass\n"
"klass Bas:\n"
"    x: Valfritt = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataklass\n"
"klass D(Bas):\n"
"    z: int = 10\n"
"    t: int = fält(kw_only=True, default=0)"

msgid "The generated :meth:`!__init__` method for :class:`!D` will look like::"
msgstr ""
"Den genererade :meth:`!__init__`-metoden för :class:`!D` kommer att se ut så "
"här::"

msgid ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: "
"int = 0):"
msgstr ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: "
"int = 0):"

msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""
"Observera att parametrarna har ordnats om från hur de visas i listan över "
"fält: parametrar som härrör från vanliga fält följs av parametrar som härrör "
"från fält som endast innehåller nyckelord."

msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`!__init__` parameter list."
msgstr ""
"Den relativa ordningsföljden för parametrar som endast innehåller nyckelord "
"bibehålls i den omordnade parameterlistan :meth:`!__init__`."

msgid "Default factory functions"
msgstr "Fabriksinställda funktioner"

msgid ""
"If a :func:`field` specifies a *default_factory*, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"Om en :func:`field` specificerar en *default_factory*, anropas den med noll "
"argument när ett standardvärde för fältet behövs.  Om du t.ex. vill skapa en "
"ny instans av en lista använder du::"

msgid "mylist: list = field(default_factory=list)"
msgstr "mylist: lista = fält(default_factory=lista)"

msgid ""
"If a field is excluded from :meth:`~object.__init__` (using ``init=False``) "
"and the field also specifies *default_factory*, then the default factory "
"function will always be called from the generated :meth:`!__init__` "
"function.  This happens because there is no other way to give the field an "
"initial value."
msgstr ""
"Om ett fält utesluts från :meth:`~object.__init__` (med ``init=False``) och "
"fältet också anger *default_factory*, kommer default factory-funktionen "
"alltid att anropas från den genererade :meth:`!__init__`-funktionen.  Detta "
"sker eftersom det inte finns något annat sätt att ge fältet ett initialt "
"värde."

msgid "Mutable default values"
msgstr "Föränderliga standardvärden"

msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"Python lagrar standardvärden för medlemsvariabler i klassattribut. Tänk på "
"detta exempel, utan att använda dataklasser::"

msgid ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"
msgstr ""
"klass C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x är o2.x"

msgid ""
"Note that the two instances of class :class:`!C` share the same class "
"variable :attr:`!x`, as expected."
msgstr ""
"Observera att de två instanserna av klassen :class:`!C` delar samma "
"klassvariabel :attr:`!x`, som förväntat."

msgid "Using dataclasses, *if* this code was valid::"
msgstr "Med hjälp av dataklasser, *om* denna kod var giltig::"

msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # This code raises ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"
msgstr ""
"@dataklass\n"
"klass D:\n"
"    x: list = [] # Denna kod ger upphov till ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"

msgid "it would generate code similar to::"
msgstr "skulle det generera kod som liknar::"

msgid ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"
msgstr ""
"klass D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x är D().x"

msgid ""
"This has the same issue as the original example using class :class:`!C`. "
"That is, two instances of class :class:`!D` that do not specify a value for :"
"attr:`!x` when creating a class instance will share the same copy of :attr:`!"
"x`.  Because dataclasses just use normal Python class creation they also "
"share this behavior.  There is no general way for Data Classes to detect "
"this condition.  Instead, the :func:`@dataclass <dataclass>` decorator will "
"raise a :exc:`ValueError` if it detects an unhashable default parameter.  "
"The assumption is that if a value is unhashable, it is mutable.  This is a "
"partial solution, but it does protect against many common errors."
msgstr ""
"Detta har samma problem som det ursprungliga exemplet med klassen :class:`!"
"C`. Det vill säga, två instanser av klassen :class:`!D` som inte anger ett "
"värde för :attr:`!x` när de skapar en klassinstans kommer att dela samma "
"kopia av :attr:`!x`.  Eftersom dataklasser bara använder normal Python-"
"klassskapande delar de också detta beteende.  Det finns inget allmänt sätt "
"för dataklasser att upptäcka detta tillstånd.  Istället kommer dekoratorn :"
"func:`@dataklass <dataclass>` att ge upphov till ett :exc:`ValueError` om "
"den upptäcker en standardparameter som inte går att hasha.  Antagandet är "
"att om ett värde är ohashable, så är det mutable.  Detta är en partiell "
"lösning, men den skyddar mot många vanliga fel."

msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr ""
"Att använda standardfabriksfunktioner är ett sätt att skapa nya instanser av "
"föränderliga typer som standardvärden för fält::"

msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"
msgstr ""
"@dataklass\n"
"klass D:\n"
"    x: list = fält(default_factory=list)\n"
"\n"
"assert D().x är inte D().x"

msgid ""
"Instead of looking for and disallowing objects of type :class:`list`, :class:"
"`dict`, or :class:`set`, unhashable objects are now not allowed as default "
"values.  Unhashability is used to approximate mutability."
msgstr ""
"Istället för att leta efter och förbjuda objekt av typen :class:`list`, :"
"class:`dict` eller :class:`set`, tillåts nu inte ohashbara objekt som "
"standardvärden.  Unhashability används för att approximera mutability."

msgid "Descriptor-typed fields"
msgstr "Deskriptortypade fält"

msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their "
"default value have the following special behaviors:"
msgstr ""
"Fält som tilldelas :ref:``descriptor objects <descriptors>`` som "
"standardvärde har följande speciella beteenden:"

msgid ""
"The value for the field passed to the dataclass's :meth:`~object.__init__` "
"method is passed to the descriptor's :meth:`~object.__set__` method rather "
"than overwriting the descriptor object."
msgstr ""
"Värdet för det fält som skickas till dataklassens metod :meth:`~object."
"__init__` skickas till deskriptorns metod :meth:`~object.__set__` i stället "
"för att skriva över deskriptorobjektet."

msgid ""
"Similarly, when getting or setting the field, the descriptor's :meth:"
"`~object.__get__` or :meth:`!__set__` method is called rather than returning "
"or overwriting the descriptor object."
msgstr ""
"På samma sätt anropas deskriptorns :meth:`~object.__get__`- eller :meth:`!"
"__set__`-metod när fältet hämtas eller ställs in, i stället för att "
"returnera eller skriva över deskriptorobjektet."

msgid ""
"To determine whether a field contains a default value, :func:`@dataclass "
"<dataclass>` will call the descriptor's :meth:`!__get__` method using its "
"class access form: ``descriptor.__get__(obj=None, type=cls)``.  If the "
"descriptor returns a value in this case, it will be used as the field's "
"default. On the other hand, if the descriptor raises :exc:`AttributeError` "
"in this situation, no default value will be provided for the field."
msgstr ""
"För att avgöra om ett fält innehåller ett standardvärde anropar :func:"
"`@dataclass <dataclass>` deskriptorns :meth:`!__get__`-metod med hjälp av "
"dess klassåtkomstform: ``descriptor.__get__(obj=None, type=cls)``.  Om "
"deskriptorn returnerar ett värde i det här fallet kommer det att användas "
"som fältets standardvärde. Å andra sidan, om deskriptorn ger upphov till :"
"exc:`AttributeError` i denna situation, kommer inget standardvärde att "
"tillhandahållas för fältet."

msgid ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # calls __set__ with 2.5\n"
"print(i.quantity_on_hand)   # 2"
msgstr ""
"klass IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, ägare, namn):\n"
"        self._name = \"_\" + namn\n"
"\n"
"    def __get__(self, obj, type):\n"
"        om obj är None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, värde):\n"
"        setattr(obj, self._name, int(värde))\n"
"\n"
"@dataklass\n"
"klass InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.kvantitet_på_hand) # 100\n"
"i.quantity_on_hand = 2.5 # anropar __set__ med 2.5\n"
"print(i.quantity_on_hand) # 2"

msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act like a "
"normal field."
msgstr ""
"Observera att om ett fält är annoterat med en deskriptortyp, men inte har "
"tilldelats ett deskriptorobjekt som standardvärde, kommer fältet att fungera "
"som ett vanligt fält."
