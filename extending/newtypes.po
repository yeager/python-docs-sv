# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Defining Extension Types: Assorted Topics"
msgstr "Definiera utökningstyper: Blandade ämnen"

msgid ""
"This section aims to give a quick fly-by on the various type methods you can "
"implement and what they do."
msgstr ""
"Detta avsnitt syftar till att ge en snabb genomgång av de olika typmetoder "
"som du kan implementera och vad de gör."

msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only used "
"in :ref:`debug builds <debug-build>` omitted:"
msgstr ""
"Här är definitionen av :c:type:`PyTypeObject`, med vissa fält som endast "
"används i :ref:`debug builds <debug-build>` utelämnade:"

msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache; /* no longer used */\n"
"    void *tp_subclasses;  /* for static builtin types this is an index */\n"
"    PyObject *tp_weaklist; /* not used for static builtin types */\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6.\n"
"     * If zero, the cache is invalid and must be initialized.\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"\n"
"    /* Number of tp_version_tag values used.\n"
"     * Set to _Py_ATTR_CACHE_UNUSED if the attribute cache is\n"
"     * disabled for this type (e.g. due to custom MRO entries).\n"
"     * Otherwise, limited to MAX_VERSIONS_PER_CLASS (defined elsewhere).\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"
msgstr ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* För utskrift, i formatet \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* För allokering */\n"
"\n"
"    /* Metoder för att implementera standardoperationer */\n"
"\n"
"    destruktor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* tidigare känd som tp_compare (Python 2)\n"
"                                    eller tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Metodsviter för standardklasser */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* Fler standardoperationer (här för binär kompatibilitet) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Funktioner för att komma åt objekt som inmatnings-/utmatningsbuffert "
"*/\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flaggor för att definiera förekomst av valfria/utökade funktioner */\n"
"    osignerad lång tp_flags;\n"
"\n"
"    const char *tp_doc; /* Dokumentationssträng */\n"
"\n"
"    /* Tilldelad betydelse i version 2.0 */\n"
"    /* anropsfunktion för alla tillgängliga objekt */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* radera referenser till inneslutna objekt */\n"
"    förfrågan tp_clear;\n"
"\n"
"    /* Tilldelad betydelse i version 2.1 */\n"
"    /* rika jämförelser */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* Möjliggör svag referens */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iteratorer */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attributbeskrivare och underklassningsgrejer */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // Stark referens på en heap-typ, lånad referens på en statisk typ\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Rutin för fritt minne på låg nivå */\n"
"    inquiry tp_is_gc; /* För PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* metodupplösningsordning */\n"
"    PyObject *tp_cache; /* används inte längre */\n"
"    void *tp_subclasses; /* för statiska inbyggda typer är detta ett index "
"*/\n"
"    PyObject *tp_weaklist; /* används inte för statiska inbyggda typer */\n"
"    destruktor tp_del;\n"
"\n"
"    /* Typattribut för cacheversionstagg. Tillagd i version 2.6.\n"
"     * Om noll är cacheminnet ogiltigt och måste initialiseras.\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destruktor tp_finalize;\n"
"    vektorcallfunc tp_vectorcall;\n"
"\n"
"    /* bituppsättning av vilka typövervakare som bryr sig om denna typ */\n"
"    osignerad char tp_watched;\n"
"\n"
"    /* Antal använda tp_version_tag-värden.\n"
"     * Sätts till _Py_ATTR_CACHE_UNUSED om attributcachen är\n"
"     * inaktiverad för den här typen (t.ex. på grund av anpassade MRO-"
"poster).\n"
"     * Annars begränsat till MAX_VERSIONS_PER_CLASS (definieras på annan "
"plats).\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"

msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you have a "
"type you want to define, the chances are very good that you will only "
"implement a handful of these."
msgstr ""
"Nu är det en *mängd* metoder.  Oroa dig dock inte för mycket - om du har en "
"typ som du vill definiera är chansen mycket stor att du bara kommer att "
"implementera en handfull av dessa."

msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they are "
"defined in the structure, because there is a lot of historical baggage that "
"impacts the ordering of the fields.  It's often easiest to find an example "
"that includes the fields you need and then change the values to suit your "
"new type. ::"
msgstr ""
"Som du förmodligen förväntar dig vid det här laget kommer vi att gå igenom "
"detta och ge mer information om de olika hanterarna.  Vi kommer inte att gå "
"igenom dem i den ordning de definieras i strukturen, eftersom det finns en "
"hel del historiskt bagage som påverkar ordningen på fälten.  Det är ofta "
"enklast att hitta ett exempel som innehåller de fält du behöver och sedan "
"ändra värdena så att de passar din nya typ:"

msgid "const char *tp_name; /* For printing */"
msgstr "const char *tp_name; /* För utskrift */"

msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to "
"choose something that will be helpful in such a situation! ::"
msgstr ""
"Typens namn - som nämndes i föregående kapitel kommer detta att visas på "
"olika ställen, nästan uteslutande för diagnostiska ändamål. Försök att välja "
"något som kan vara till hjälp i en sådan situation! ::"

msgid "Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */"
msgstr "Py_ssize_t tp_basicsize, tp_itemsize; /* För allokering */"

msgid ""
"These fields tell the runtime how much memory to allocate when new objects "
"of this type are created.  Python has some built-in support for variable "
"length structures (think: strings, tuples) which is where the :c:member:"
"`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt with "
"later. ::"
msgstr ""
"Dessa fält talar om för runtime hur mycket minne som ska allokeras när nya "
"objekt av den här typen skapas.  Python har en del inbyggt stöd för "
"strukturer med variabel längd (tänk: strängar, tupler) och det är här "
"fältet :c:member:`~PyTypeObject.tp_itemsize` kommer in i bilden.  Detta "
"kommer att behandlas senare. ::"

msgid "const char *tp_doc;"
msgstr "const char *tp_doc;"

msgid ""
"Here you can put a string (or its address) that you want returned when the "
"Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"Här kan du lägga in en sträng (eller dess adress) som du vill ska returneras "
"när Python-skriptet refererar till ``obj.__doc__`` för att hämta doc-"
"strängen."

msgid ""
"Now we come to the basic type methods -- the ones most extension types will "
"implement."
msgstr ""
"Nu kommer vi till de grundläggande typmetoderna - de som de flesta "
"extensionstyper kommer att implementera."

msgid "Finalization and De-allocation"
msgstr "Slutförande och avyttring"

msgid "destructor tp_dealloc;"
msgstr "destruktor tp_dealloc;"

msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  If "
"your type has memory to free or other clean-up to perform, you can put it "
"here.  The object itself needs to be freed here as well.  Here is an example "
"of this function::"
msgstr ""
"Denna funktion anropas när referensantalet för instansen av din typ har "
"reducerats till noll och Python-tolken vill återta den.  Om din typ har "
"minne att frigöra eller annan upprensning att utföra, kan du lägga det här.  "
"Själva objektet måste också frigöras här.  Här är ett exempel på denna "
"funktion::"

msgid ""
"static void\n"
"newdatatype_dealloc(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    free(self->obj_UnderlyingDatatypePtr);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"statiskt void\n"
"newdatatype_dealloc(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    free(self->obj_UnderlyingDatatypePtr);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"

msgid ""
"If your type supports garbage collection, the destructor should call :c:func:"
"`PyObject_GC_UnTrack` before clearing any member fields::"
msgstr ""
"Om din typ stöder sopsortering bör destruktorn anropa :c:func:"
"`PyObject_GC_UnTrack` innan den rensar alla medlemsfält::"

msgid ""
"static void\n"
"newdatatype_dealloc(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    PyObject_GC_UnTrack(op);\n"
"    Py_CLEAR(self->other_obj);\n"
"    ...\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"statiskt void\n"
"newdatatype_dealloc(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    PyObject_GC_UnTrack(op);\n"
"    Py_CLEAR(self->other_obj);\n"
"    ...\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"

msgid ""
"One important requirement of the deallocator function is that it leaves any "
"pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), nothing "
"is done to protect the deallocators from seeing that an exception has "
"already been set.  Any actions which a deallocator performs which may cause "
"additional Python code to be executed may detect that an exception has been "
"set.  This can lead to misleading errors from the interpreter.  The proper "
"way to protect against this is to save a pending exception before performing "
"the unsafe action, and restoring it when done.  This can be done using the :"
"c:func:`PyErr_Fetch` and :c:func:`PyErr_Restore` functions::"
msgstr ""
"Ett viktigt krav på deallocator-funktionen är att den lämnar alla väntande "
"undantag i fred.  Detta är viktigt eftersom deallokatorer ofta anropas när "
"tolken rullar upp Python-stacken; när stacken rullas upp på grund av ett "
"undantag (snarare än normala returer) görs ingenting för att skydda "
"deallokatorerna från att se att ett undantag redan har ställts in.  Alla "
"åtgärder som en deallokator utför som kan orsaka att ytterligare Python-kod "
"exekveras kan upptäcka att ett undantag har satts.  Detta kan leda till "
"missvisande fel från tolken.  Det korrekta sättet att skydda sig mot detta "
"är att spara ett väntande undantag innan man utför den osäkra åtgärden och "
"återställa det när man är klar.  Detta kan göras med hjälp av funktionerna :"
"c:func:`PyErr_Fetch` och :c:func:`PyErr_Restore`::"

msgid ""
"static void\n"
"my_dealloc(PyObject *obj)\n"
"{\n"
"    MyObject *self = (MyObject *) obj;\n"
"    PyObject *cbresult;\n"
"\n"
"    if (self->my_callback != NULL) {\n"
"        PyObject *err_type, *err_value, *err_traceback;\n"
"\n"
"        /* This saves the current exception state */\n"
"        PyErr_Fetch(&err_type, &err_value, &err_traceback);\n"
"\n"
"        cbresult = PyObject_CallNoArgs(self->my_callback);\n"
"        if (cbresult == NULL) {\n"
"           PyErr_WriteUnraisable(self->my_callback);\n"
"        }\n"
"        else {\n"
"            Py_DECREF(cbresult);\n"
"        }\n"
"\n"
"        /* This restores the saved exception state */\n"
"        PyErr_Restore(err_type, err_value, err_traceback);\n"
"\n"
"        Py_DECREF(self->my_callback);\n"
"    }\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"statiskt void\n"
"my_dealloc(PyObject *obj)\n"
"{\n"
"    MyObject *self = (MyObject *) obj;\n"
"    PyObject *cbresultat;\n"
"\n"
"    if (self->my_callback != NULL) {\n"
"        PyObject *err_type, *err_value, *err_traceback;\n"
"\n"
"        /* Detta sparar det aktuella undantagstillståndet */\n"
"        PyErr_Fetch(&err_type, &err_value, &err_traceback);\n"
"\n"
"        cbresult = PyObject_CallNoArgs(self->my_callback);\n"
"        if (cbresult == NULL) {\n"
"           PyErr_WriteUnraisable(self->my_callback);\n"
"        }\n"
"        else {\n"
"            Py_DECREF(cbresult);\n"
"        }\n"
"\n"
"        /* Detta återställer det sparade undantagstillståndet */\n"
"        PyErr_Restore(err_type, err_value, err_traceback);\n"
"\n"
"        Py_DECREF(self->my_callback);\n"
"    }\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"

msgid ""
"There are limitations to what you can safely do in a deallocator function. "
"First, if your type supports garbage collection (using :c:member:"
"`~PyTypeObject.tp_traverse` and/or :c:member:`~PyTypeObject.tp_clear`), some "
"of the object's members can have been cleared or finalized by the time :c:"
"member:`~PyTypeObject.tp_dealloc` is called.  Second, in :c:member:"
"`~PyTypeObject.tp_dealloc`, your object is in an unstable state: its "
"reference count is equal to zero.  Any call to a non-trivial object or API "
"(as in the example above) might end up calling :c:member:`~PyTypeObject."
"tp_dealloc` again, causing a double free and a crash."
msgstr ""
"Det finns begränsningar för vad du säkert kan göra i en "
"deallokeringsfunktion. För det första, om din typ stöder garbage collection "
"(med :c:member:`~PyTypeObject.tp_traverse` och/eller :c:member:"
"`~PyTypeObject.tp_clear`), kan några av objektets medlemmar ha rensats eller "
"slutförts när :c:member:`~PyTypeObject.tp_dealloc` anropas.  För det andra, "
"i :c:member:`~PyTypeObject.tp_dealloc` är ditt objekt i ett instabilt "
"tillstånd: dess referensantal är lika med noll.  Varje anrop till ett icke-"
"trivialt objekt eller API (som i exemplet ovan) kan sluta med att :c:member:"
"`~PyTypeObject.tp_dealloc` anropas igen, vilket orsakar en dubbel free och "
"en krasch."

msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead use "
"the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"Från och med Python 3.4 rekommenderas det att inte lägga in någon komplex "
"avslutningskod i :c:member:`~PyTypeObject.tp_dealloc`, utan istället använda "
"den nya typmetoden :c:member:`~PyTypeObject.tp_finalize`."

msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442` förklarar det nya finaliseringsschemat."

msgid "Object Presentation"
msgstr "Presentation av objekt"

msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The :func:"
"`print` function just calls :func:`str`.)  These handlers are both optional."
msgstr ""
"I Python finns det två sätt att generera en textuell representation av ett "
"objekt: funktionen :func:`repr` och funktionen :func:`str`.  (Funktionen :"
"func:`print` anropar bara :func:`str`.) Dessa hanterare är båda valfria."

msgid ""
"reprfunc tp_repr;\n"
"reprfunc tp_str;"
msgstr ""
"reprfunc tp_repr;\n"
"reprfunc tp_str;"

msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string object "
"containing a representation of the instance for which it is called.  Here is "
"a simple example::"
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_repr` bör returnera ett strängobjekt "
"som innehåller en representation av den instans för vilken den anropas.  Här "
"är ett enkelt exempel::"

msgid ""
"static PyObject *\n"
"newdatatype_repr(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    return PyUnicode_FromFormat(\"Repr-ified_newdatatype{{size:%d}}\",\n"
"                                self->obj_UnderlyingDatatypePtr->size);\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"newdatatype_repr(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    return PyUnicode_FromFormat(\"Repr-ified_newdatatype{{size:%d}}\",\n"
"                                self->obj_UnderlyingDatatypePtr->size);\n"
"}"

msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's :c:member:"
"`~PyTypeObject.tp_name` and a uniquely identifying value for the object."
msgstr ""
"Om ingen :c:member:`~PyTypeObject.tp_repr`-hanterare har angetts kommer "
"tolken att tillhandahålla en representation som använder typens :c:member:"
"`~PyTypeObject.tp_name` och ett unikt identifierande värde för objektet."

msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the :c:"
"member:`~PyTypeObject.tp_repr` handler described above is to :func:`repr`; "
"that is, it is called when Python code calls :func:`str` on an instance of "
"your object.  Its implementation is very similar to the :c:member:"
"`~PyTypeObject.tp_repr` function, but the resulting string is intended for "
"human consumption.  If :c:member:`~PyTypeObject.tp_str` is not specified, "
"the :c:member:`~PyTypeObject.tp_repr` handler is used instead."
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_str` är för :func:`str` vad "
"hanteraren :c:member:`~PyTypeObject.tp_repr` som beskrivs ovan är för :func:"
"`repr`; det vill säga den anropas när Python-kod anropar :func:`str` på en "
"instans av ditt objekt.  Dess implementering är mycket lik :c:member:"
"`~PyTypeObject.tp_repr`-funktionen, men den resulterande strängen är avsedd "
"för mänsklig konsumtion.  Om :c:member:`~PyTypeObject.tp_str` inte "
"specificeras används istället :c:member:`~PyTypeObject.tp_repr`."

msgid "Here is a simple example::"
msgstr "Här är ett enkelt exempel::"

msgid ""
"static PyObject *\n"
"newdatatype_str(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    return PyUnicode_FromFormat(\"Stringified_newdatatype{{size:%d}}\",\n"
"                                self->obj_UnderlyingDatatypePtr->size);\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"newdatatype_str(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    return PyUnicode_FromFormat(\"Stringified_newdatatype{{size:%d}}\",\n"
"                                self->obj_UnderlyingDatatypePtr->size);\n"
"}"

msgid "Attribute Management"
msgstr "Hantering av attribut"

msgid ""
"For every object which can support attributes, the corresponding type must "
"provide the functions that control how the attributes are resolved.  There "
"needs to be a function which can retrieve attributes (if any are defined), "
"and another to set attributes (if setting attributes is allowed).  Removing "
"an attribute is a special case, for which the new value passed to the "
"handler is ``NULL``."
msgstr ""
"För varje objekt som kan stödja attribut måste motsvarande typ "
"tillhandahålla de funktioner som styr hur attributen löses.  Det måste "
"finnas en funktion som kan hämta attribut (om några är definierade) och en "
"annan för att ställa in attribut (om det är tillåtet att ställa in "
"attribut).  Att ta bort ett attribut är ett specialfall, för vilket det nya "
"värdet som skickas till hanteraren är ``NULL``."

msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a :c:expr:"
"`char\\*`, while the other accepts a :c:expr:`PyObject*`.  Each type can use "
"whichever pair makes more sense for the implementation's convenience. ::"
msgstr ""
"Python stöder två par attributhanterare; en typ som stöder attribut behöver "
"bara implementera funktionerna för ett par.  Skillnaden är att det ena paret "
"tar namnet på attributet som ett :c:expr:`char\\*`, medan det andra "
"accepterar ett :c:expr:`PyObject*`.  Varje typ kan använda det par som är "
"mest meningsfullt för implementeringens bekvämlighet. ::"

msgid ""
"getattrfunc  tp_getattr;        /* char * version */\n"
"setattrfunc  tp_setattr;\n"
"/* ... */\n"
"getattrofunc tp_getattro;       /* PyObject * version */\n"
"setattrofunc tp_setattro;"
msgstr ""
"getattrfunc tp_getattr; /* char * version */\n"
"setattrfunc tp_setattr;\n"
"/* ... */\n"
"getattrofunc tp_getattro; /* PyObject * version */\n"
"setattrofunc tp_setattro;"

msgid ""
"If accessing attributes of an object is always a simple operation (this will "
"be explained shortly), there are generic implementations which can be used "
"to provide the :c:expr:`PyObject*` version of the attribute management "
"functions. The actual need for type-specific attribute handlers almost "
"completely disappeared starting with Python 2.2, though there are many "
"examples which have not been updated to use some of the new generic "
"mechanism that is available."
msgstr ""
"Om åtkomst till attribut för ett objekt alltid är en enkel operation (detta "
"kommer att förklaras inom kort), finns det generiska implementationer som "
"kan användas för att tillhandahålla :c:expr:`PyObject*`-versionen av "
"attributhanteringsfunktionerna. Det faktiska behovet av typspecifika "
"attributhanterare försvann nästan helt från och med Python 2.2, även om det "
"finns många exempel som inte har uppdaterats för att använda några av de nya "
"generiska mekanismer som finns tillgängliga."

msgid "Generic Attribute Management"
msgstr "Generisk attributhantering"

msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be met:"
msgstr ""
"De flesta tilläggstyper använder bara *enkla* attribut.  Vad är det då som "
"gör attributen enkla?  Det finns bara ett par villkor som måste uppfyllas:"

msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ""
"Namnet på attributen måste vara känt när :c:func:`PyType_Ready` anropas."

msgid ""
"No special processing is needed to record that an attribute was looked up or "
"set, nor do actions need to be taken based on the value."
msgstr ""
"Ingen särskild behandling behövs för att registrera att ett attribut har "
"sökts upp eller ställts in, och inga åtgärder behöver vidtas baserat på "
"värdet."

msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr ""
"Observera att denna lista inte innehåller några restriktioner för "
"attributens värden, när värdena beräknas eller hur relevanta data lagras."

msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by "
"the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all "
"three are ``NULL``, instances of the type will only have attributes that are "
"inherited from their base type, and should leave the :c:member:"
"`~PyTypeObject.tp_getattro` and :c:member:`~PyTypeObject.tp_setattro` fields "
"``NULL`` as well, allowing the base type to handle attributes."
msgstr ""
"När :c:func:`PyType_Ready` anropas används tre tabeller som refereras av "
"typobjektet för att skapa :term:`descriptor` som placeras i typobjektets "
"dictionary.  Varje deskriptor kontrollerar åtkomst till ett attribut hos "
"instansobjektet.  Var och en av tabellerna är valfri; om alla tre är "
"``NULL`` kommer instanser av typen endast att ha attribut som ärvs från "
"deras bastyp, och bör lämna fälten :c:member:`~PyTypeObject.tp_getattro` "
"och :c:member:`~PyTypeObject.tp_setattro` ``NULL`` också, så att bastypen "
"kan hantera attribut."

msgid "The tables are declared as three fields of the type object::"
msgstr "Tabellerna deklareras som tre fält av typen object::"

msgid ""
"struct PyMethodDef *tp_methods;\n"
"struct PyMemberDef *tp_members;\n"
"struct PyGetSetDef *tp_getset;"
msgstr ""
"struct PyMethodDef *tp_methods;\n"
"struct PyMemberDef *tp_members;\n"
"struct PyGetSetDef *tp_getset;"

msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to an "
"array of :c:type:`PyMethodDef` structures.  Each entry in the table is an "
"instance of this structure::"
msgstr ""
"Om :c:member:`~PyTypeObject.tp_methods` inte är ``NULL``, måste den referera "
"till en array av :c:type:`PyMethodDef`-strukturer.  Varje post i tabellen är "
"en instans av denna struktur::"

msgid ""
"typedef struct PyMethodDef {\n"
"    const char  *ml_name;       /* method name */\n"
"    PyCFunction  ml_meth;       /* implementation function */\n"
"    int          ml_flags;      /* flags */\n"
"    const char  *ml_doc;        /* docstring */\n"
"} PyMethodDef;"
msgstr ""
"typedef struct PyMethodDef {\n"
"    const char *ml_name; /* metodens namn */\n"
"    PyCFunction ml_meth; /* implementeringsfunktion */\n"
"    int ml_flags; /* flaggor */\n"
"    const char *ml_doc; /* dokumentsträng */\n"
"} PyMethodDef;"

msgid ""
"One entry should be defined for each method provided by the type; no entries "
"are needed for methods inherited from a base type.  One additional entry is "
"needed at the end; it is a sentinel that marks the end of the array.  The :c:"
"member:`~PyMethodDef.ml_name` field of the sentinel must be ``NULL``."
msgstr ""
"En post ska definieras för varje metod som tillhandahålls av typen; inga "
"poster behövs för metoder som ärvs från en bastyp.  Ytterligare en post "
"behövs i slutet; det är en sentinel som markerar slutet på arrayen.  Fältet :"
"c:member:`~PyMethodDef.ml_name` i sentineln måste vara ``NULL``."

msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, and "
"access may be read-only or read-write.  The structures in the table are "
"defined as::"
msgstr ""
"Den andra tabellen används för att definiera attribut som är direkt kopplade "
"till data som lagras i instansen.  En mängd olika primitiva C-typer stöds "
"och åtkomsten kan vara skrivskyddad eller skrivskyddad.  Strukturerna i "
"tabellen definieras enligt följande::"

msgid ""
"typedef struct PyMemberDef {\n"
"    const char *name;\n"
"    int         type;\n"
"    int         offset;\n"
"    int         flags;\n"
"    const char *doc;\n"
"} PyMemberDef;"
msgstr ""
"typedef struct PyMemberDef {\n"
"    const char *namn;\n"
"    int typ;\n"
"    int offset;\n"
"    int flaggor;\n"
"    const char *doc;\n"
"} PyMemberDef;"

msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and "
"added to the type which will be able to extract a value from the instance "
"structure.  The :c:member:`~PyMemberDef.type` field should contain a type "
"code like :c:macro:`Py_T_INT` or :c:macro:`Py_T_DOUBLE`; the value will be "
"used to determine how to convert Python values to and from C values.  The :c:"
"member:`~PyMemberDef.flags` field is used to store flags which control how "
"the attribute can be accessed: you can set it to :c:macro:`Py_READONLY` to "
"prevent Python code from setting it."
msgstr ""
"För varje post i tabellen kommer en :term:`descriptor` att konstrueras och "
"läggas till typen som kommer att kunna extrahera ett värde från "
"instansstrukturen.  Fältet :c:member:`~PyMemberDef.type` bör innehålla en "
"typkod som :c:macro:`Py_T_INT` eller :c:macro:`Py_T_DOUBLE`; värdet kommer "
"att användas för att bestämma hur Python-värden skall konverteras till och "
"från C-värden.  Fältet :c:member:`~PyMemberDef.flags` används för att lagra "
"flaggor som styr hur attributet kan nås: du kan sätta det till :c:macro:"
"`Py_READONLY` för att förhindra Python-kod från att sätta det."

msgid ""
"An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` "
"table to build descriptors that are used at runtime is that any attribute "
"defined this way can have an associated doc string simply by providing the "
"text in the table.  An application can use the introspection API to retrieve "
"the descriptor from the class object, and get the doc string using its :attr:"
"`~type.__doc__` attribute."
msgstr ""
"En intressant fördel med att använda tabellen :c:member:`~PyTypeObject."
"tp_members` för att skapa beskrivningar som används vid körning är att alla "
"attribut som definieras på det här sättet kan ha en associerad doc-sträng "
"genom att helt enkelt tillhandahålla texten i tabellen.  Ett program kan "
"använda introspektions-API:et för att hämta deskriptorn från klassobjektet "
"och hämta dokumentsträngen med hjälp av attributet :attr:`~type.__doc__`."

msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :c:member:`~PyMethodDef.ml_name` value of ``NULL`` is required."
msgstr ""
"Precis som i tabellen :c:member:`~PyTypeObject.tp_methods` krävs en sentinel-"
"post med värdet ``NULL`` i :c:member:`~PyMethodDef.ml_name`."

msgid "Type-specific Attribute Management"
msgstr "Typspecifik attributhantering"

msgid ""
"For simplicity, only the :c:expr:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the :c:"
"expr:`char\\*` and :c:expr:`PyObject*` flavors of the interface. This "
"example effectively does the same thing as the generic example above, but "
"does not use the generic support added in Python 2.2.  It explains how the "
"handler functions are called, so that if you do need to extend their "
"functionality, you'll understand what needs to be done."
msgstr ""
"För enkelhetens skull kommer endast :c:expr:`char\\*`-versionen att "
"demonstreras här; typen av namnparametern är den enda skillnaden mellan :c:"
"expr:`char\\*`- och :c:expr:`PyObject*`-versionerna av gränssnittet. Det här "
"exemplet gör i princip samma sak som det generiska exemplet ovan, men "
"använder inte det generiska stöd som tillkom i Python 2.2.  Det förklarar "
"hur hanterarfunktionerna anropas, så att du förstår vad som behöver göras om "
"du behöver utöka deras funktionalitet."

msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object "
"requires an attribute look-up.  It is called in the same situations where "
"the :meth:`~object.__getattr__` method of a class would be called."
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_getattr` anropas när objektet kräver "
"en attributuppslagning.  Den anropas i samma situationer som :meth:`~object."
"__getattr__`-metoden för en klass skulle anropas."

msgid "Here is an example::"
msgstr "Här är ett exempel::"

msgid ""
"static PyObject *\n"
"newdatatype_getattr(PyObject *op, char *name)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    if (strcmp(name, \"data\") == 0) {\n"
"        return PyLong_FromLong(self->data);\n"
"    }\n"
"\n"
"    PyErr_Format(PyExc_AttributeError,\n"
"                 \"'%.100s' object has no attribute '%.400s'\",\n"
"                 Py_TYPE(self)->tp_name, name);\n"
"    return NULL;\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"newdatatype_getattr(PyObject *op, char *namn)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    if (strcmp(namn, \"data\") == 0) {\n"
"        return PyLong_FromLong(self->data);\n"
"    }\n"
"\n"
"    PyErr_Format(PyExc_AttributeError,\n"
"                 \"'%.100s' objekt har inget attribut '%.400s'\",\n"
"                 Py_TYPE(self)->tp_name, namn);\n"
"    returnera NULL;\n"
"}"

msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:"
"`~object.__setattr__` or :meth:`~object.__delattr__` method of a class "
"instance would be called.  When an attribute should be deleted, the third "
"parameter will be ``NULL``.  Here is an example that simply raises an "
"exception; if this were really all you wanted, the :c:member:`~PyTypeObject."
"tp_setattr` handler should be set to ``NULL``. ::"
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_setattr` anropas när metoden :meth:"
"`~object.__setattr__` eller :meth:`~object.__delattr__` för en klassinstans "
"skulle anropas.  När ett attribut skall tas bort kommer den tredje "
"parametern att vara ``NULL``.  Här är ett exempel som helt enkelt ger upphov "
"till ett undantag; om detta verkligen var allt du ville ha, skulle "
"handläggaren :c:member:`~PyTypeObject.tp_setattr` sättas till ``NULL``. ::"

msgid ""
"static int\n"
"newdatatype_setattr(PyObject *op, char *name, PyObject *v)\n"
"{\n"
"    PyErr_Format(PyExc_RuntimeError, \"Read-only attribute: %s\", name);\n"
"    return -1;\n"
"}"
msgstr ""
"statisk int\n"
"newdatatype_setattr(PyObject *op, char *name, PyObject *v)\n"
"{\n"
"    PyErr_Format(PyExc_RuntimeError, \"Skrivskyddat attribut: %s\", namn);\n"
"    return -1;\n"
"}"

msgid "Object Comparison"
msgstr "Jämförelse av objekt"

msgid "richcmpfunc tp_richcompare;"
msgstr "richcmpfunc tp_richcompare;"

msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`!__lt__`, and also called by :c:func:"
"`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_richcompare` anropas när jämförelser "
"behövs.  Den är analog med :ref:`rich comparison methods <richcmpfuncs>`, "
"som :meth:`!__lt__`, och anropas även av :c:func:`PyObject_RichCompare` och :"
"c:func:`PyObject_RichCompareBool`."

msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GE``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects with "
"respect to the specified operator and return ``Py_True`` or ``Py_False`` if "
"the comparison is successful, ``Py_NotImplemented`` to indicate that "
"comparison is not implemented and the other object's comparison method "
"should be tried, or ``NULL`` if an exception was set."
msgstr ""
"Denna funktion anropas med två Python-objekt och operatorn som argument, där "
"operatorn är en av ``Py_EQ``, ``Py_NE``, ``Py_LE``, ``Py_GE``, ``Py_LT`` "
"eller ``Py_GT``.  Den bör jämföra de två objekten med avseende på den "
"angivna operatorn och returnera ``Py_True`` eller ``Py_False`` om "
"jämförelsen lyckas, ``Py_NotImplemented`` för att indikera att jämförelsen "
"inte är implementerad och att det andra objektets jämförelsemetod bör "
"prövas, eller ``NULL`` om ett undantag har angetts."

msgid ""
"Here is a sample implementation, for a datatype that is considered equal if "
"the size of an internal pointer is equal::"
msgstr ""
"Här är ett exempel på implementering, för en datatyp som anses vara lika om "
"storleken på en intern pekare är lika::"

msgid ""
"static PyObject *\n"
"newdatatype_richcmp(PyObject *lhs, PyObject *rhs, int op)\n"
"{\n"
"    newdatatypeobject *obj1 = (newdatatypeobject *) lhs;\n"
"    newdatatypeobject *obj2 = (newdatatypeobject *) rhs;\n"
"    PyObject *result;\n"
"    int c, size1, size2;\n"
"\n"
"    /* code to make sure that both arguments are of type\n"
"       newdatatype omitted */\n"
"\n"
"    size1 = obj1->obj_UnderlyingDatatypePtr->size;\n"
"    size2 = obj2->obj_UnderlyingDatatypePtr->size;\n"
"\n"
"    switch (op) {\n"
"    case Py_LT: c = size1 <  size2; break;\n"
"    case Py_LE: c = size1 <= size2; break;\n"
"    case Py_EQ: c = size1 == size2; break;\n"
"    case Py_NE: c = size1 != size2; break;\n"
"    case Py_GT: c = size1 >  size2; break;\n"
"    case Py_GE: c = size1 >= size2; break;\n"
"    }\n"
"    result = c ? Py_True : Py_False;\n"
"    return Py_NewRef(result);\n"
" }"
msgstr ""
"statiskt PyObject *\n"
"newdatatype_richcmp(PyObject *lhs, PyObject *rhs, int op)\n"
"{\n"
"    newdatatypeobject *obj1 = (newdatatypeobject *) lhs;\n"
"    newdatatypeobject *obj2 = (newdatatypeobject *) rhs;\n"
"    PyObject *resultat;\n"
"    int c, storlek1, storlek2;\n"
"\n"
"    /* kod för att se till att båda argumenten är av typen\n"
"       nydatatyp utelämnad */\n"
"\n"
"    size1 = obj1->obj_UnderliggandeDatatypPtr->size;\n"
"    size2 = obj2->obj_UnderlyingDatatypePtr->size;\n"
"\n"
"    switch (op) {\n"
"    fall Py_LT: c = storlek1 < storlek2; bryt;\n"
"    fall Py_LE: c = storlek1 <= storlek2; bryt;\n"
"    fall Py_EQ: c = storlek1 == storlek2; bryt;\n"
"    fall Py_NE: c = storlek1 != storlek2; bryt;\n"
"    fall Py_GT: c = storlek1 > storlek2; bryt;\n"
"    fall Py_GE: c = storlek1 >= storlek2; bryt;\n"
"    }\n"
"    resultat = c ? Py_True : Py_False;\n"
"    return Py_NewRef(resultat);\n"
" }"

msgid "Abstract Protocol Support"
msgstr "Stöd för abstrakta protokoll"

msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific interfaces "
"provided to use these interfaces are documented in :ref:`abstract`."
msgstr ""
"Python stöder en mängd olika *abstrakta* \"protokoll\"; de specifika "
"gränssnitt som tillhandahålls för att använda dessa gränssnitt dokumenteras "
"i :ref:`abstract`."

msgid ""
"A number of these abstract interfaces were defined early in the development "
"of the Python implementation.  In particular, the number, mapping, and "
"sequence protocols have been part of Python since the beginning.  Other "
"protocols have been added over time.  For protocols which depend on several "
"handler routines from the type implementation, the older protocols have been "
"defined as optional blocks of handlers referenced by the type object.  For "
"newer protocols there are additional slots in the main type object, with a "
"flag bit being set to indicate that the slots are present and should be "
"checked by the interpreter.  (The flag bit does not indicate that the slot "
"values are non-``NULL``. The flag may be set to indicate the presence of a "
"slot, but a slot may still be unfilled.) ::"
msgstr ""
"Ett antal av dessa abstrakta gränssnitt definierades tidigt i utvecklingen "
"av Python-implementeringen.  I synnerhet har nummer-, mappnings- och "
"sekvensprotokollen varit en del av Python sedan början.  Andra protokoll har "
"lagts till över tiden.  För protokoll som är beroende av flera "
"hanterarrutiner från typimplementationen har de äldre protokollen "
"definierats som valfria block av hanterare som refereras av typobjektet.  "
"För nyare protokoll finns det ytterligare slots i huvudtypobjektet, med en "
"flaggbit som sätts för att indikera att slots finns och bör kontrolleras av "
"tolken.  (Flaggbiten anger inte att slotvärdena är icke-``NULL``. Flaggan "
"kan vara satt för att ange att en slot finns, men en slot kan fortfarande "
"vara ofylld) ::"

msgid ""
"PyNumberMethods   *tp_as_number;\n"
"PySequenceMethods *tp_as_sequence;\n"
"PyMappingMethods  *tp_as_mapping;"
msgstr ""
"PyNumberMethods *tp_as_number;\n"
"PySequenceMethods *tp_as_sequence;\n"
"PyMappingMethods *tp_as_mapping;"

msgid ""
"If you wish your object to be able to act like a number, a sequence, or a "
"mapping object, then you place the address of a structure that implements "
"the C type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or :c:"
"type:`PyMappingMethods`, respectively. It is up to you to fill in this "
"structure with appropriate values. You can find examples of the use of each "
"of these in the :file:`Objects` directory of the Python source "
"distribution. ::"
msgstr ""
"Om du vill att ditt objekt ska kunna fungera som ett nummer, en sekvens "
"eller ett mappningsobjekt, så placerar du adressen till en struktur som "
"implementerar C-typen :c:type:`PyNumberMethods`, :c:type:"
"`PySequenceMethods`, eller :c:type:`PyMappingMethods`, respektive. Det är "
"upp till dig att fylla i denna struktur med lämpliga värden. Du kan hitta "
"exempel på användningen av var och en av dessa i :file:`Objects`-katalogen i "
"Python-källdistributionen. ::"

msgid "hashfunc tp_hash;"
msgstr "hashfunc tp_hash;"

msgid ""
"This function, if you choose to provide it, should return a hash number for "
"an instance of your data type. Here is a simple example::"
msgstr ""
"Denna funktion, om du väljer att tillhandahålla den, ska returnera ett "
"hashnummer för en instans av din datatyp. Här är ett enkelt exempel::"

msgid ""
"static Py_hash_t\n"
"newdatatype_hash(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    Py_hash_t result;\n"
"    result = self->some_size + 32767 * self->some_number;\n"
"    if (result == -1) {\n"
"        result = -2;\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"statisk Py_hash_t\n"
"newdatatype_hash(PyObject *op)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    Py_hash_t resultat;\n"
"    resultat = self->some_size + 32767 * self->some_number;\n"
"    if (resultat == -1) {\n"
"        resultat = -2;\n"
"    }\n"
"    return result;\n"
"}"

msgid ""
":c:type:`Py_hash_t` is a signed integer type with a platform-varying width. "
"Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates an error, "
"which is why you should be careful to avoid returning it when hash "
"computation is successful, as seen above."
msgstr ""
":c:type:`Py_hash_t` är en signerad heltalstyp med plattformsvarierande "
"bredd. Att returnera ``-1`` från :c:member:`~PyTypeObject.tp_hash` indikerar "
"ett fel, vilket är anledningen till att du bör vara noga med att undvika att "
"returnera det när hashberäkningen lyckas, som ovan."

msgid "ternaryfunc tp_call;"
msgstr "ternaryfunc tp_call;"

msgid ""
"This function is called when an instance of your data type is \"called\", "
"for example, if ``obj1`` is an instance of your data type and the Python "
"script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` "
"handler is invoked."
msgstr ""
"Denna funktion anropas när en instans av din datatyp \"anropas\", t.ex. om "
"``obj1`` är en instans av din datatyp och Python-skriptet innehåller "
"``obj1('hello')``, anropas hanteraren :c:member:`~PyTypeObject.tp_call`."

msgid "This function takes three arguments:"
msgstr "Denna funktion tar tre argument:"

msgid ""
"*self* is the instance of the data type which is the subject of the call. If "
"the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr ""
"*self* är instansen av den datatyp som är föremål för anropet. Om anropet är "
"``obj1('hello')``, så är *self* ``obj1``."

msgid ""
"*args* is a tuple containing the arguments to the call.  You can use :c:func:"
"`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*args* är en tupel som innehåller argumenten till anropet.  Du kan använda :"
"c:func:`PyArg_ParseTuple` för att extrahera argumenten."

msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is non-"
"``NULL`` and you support keyword arguments, use :c:func:"
"`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you do not want "
"to support keyword arguments and this is non-``NULL``, raise a :exc:"
"`TypeError` with a message saying that keyword arguments are not supported."
msgstr ""
"*kwds* är en ordbok med nyckelordsargument som skickades. Om detta är icke-"
"``NULL`` och du stöder nyckelordsargument, använd :c:func:"
"`PyArg_ParseTupleAndKeywords` för att extrahera argumenten.  Om du inte vill "
"stödja nyckelordsargument och detta är icke-``NULL``, skapa ett :exc:"
"`TypeError` med ett meddelande som säger att nyckelordsargument inte stöds."

msgid "Here is a toy ``tp_call`` implementation::"
msgstr "Här är en leksaksimplementation av ``tp_call``::"

msgid ""
"static PyObject *\n"
"newdatatype_call(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    PyObject *result;\n"
"    const char *arg1;\n"
"    const char *arg2;\n"
"    const char *arg3;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {\n"
"        return NULL;\n"
"    }\n"
"    result = PyUnicode_FromFormat(\n"
"        \"Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\\n\",\n"
"        self->obj_UnderlyingDatatypePtr->size,\n"
"        arg1, arg2, arg3);\n"
"    return result;\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"newdatatype_call(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    newdatatypeobject *self = (newdatatypeobject *) op;\n"
"    PyObject *resultat;\n"
"    const char *arg1;\n"
"    const char *arg2;\n"
"    const char *arg3;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"sss:call\", &arg1, &arg2, &arg3)) {\n"
"        returneras NULL;\n"
"    }\n"
"    result = PyUnicode_FromFormat(\n"
"        \"Återlämnar -- värde: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\\n\",\n"
"        self->obj_UnderliggandeDatatypPtr->storlek,\n"
"        arg1, arg2, arg3);\n"
"    returnera resultatet;\n"
"}"

msgid ""
"/* Iterators */\n"
"getiterfunc tp_iter;\n"
"iternextfunc tp_iternext;"
msgstr ""
"/* Iteratorer */\n"
"getiterfunc tp_iter;\n"
"iternextfunc tp_iternext;"

msgid ""
"These functions provide support for the iterator protocol.  Both handlers "
"take exactly one parameter, the instance for which they are being called, "
"and return a new reference.  In the case of an error, they should set an "
"exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter` "
"corresponds to the Python :meth:`~object.__iter__` method, while :c:member:"
"`~PyTypeObject.tp_iternext` corresponds to the Python :meth:`~iterator."
"__next__` method."
msgstr ""
"Dessa funktioner ger stöd för iteratorprotokollet.  Båda hanterarna tar "
"exakt en parameter, den instans som de anropas för, och returnerar en ny "
"referens.  I händelse av ett fel bör de ange ett undantag och returnera "
"``NULL``. :c:member:`~PyTypeObject.tp_iter` motsvarar Pythons :meth:`~object."
"__iter__`-metod, medan :c:member:`~PyTypeObject.tp_iternext` motsvarar "
"Pythons :meth:`~iterator.__next__`-metod."

msgid ""
"Any :term:`iterable` object must implement the :c:member:`~PyTypeObject."
"tp_iter` handler, which must return an :term:`iterator` object.  Here the "
"same guidelines apply as for Python classes:"
msgstr ""
"Alla :term:`iterable`-objekt måste implementera :c:member:`~PyTypeObject."
"tp_iter`-hanteraren, som måste returnera ett :term:`iterator`-objekt.  Här "
"gäller samma riktlinjer som för Python-klasser:"

msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by each "
"call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""
"För samlingar (t.ex. listor och tupler) som kan stödja flera oberoende "
"iteratorer bör en ny iterator skapas och returneras vid varje anrop till :c:"
"member:`~PyTypeObject.tp_iter`."

msgid ""
"Objects which can only be iterated over once (usually due to side effects of "
"iteration, such as file objects) can implement :c:member:`~PyTypeObject."
"tp_iter` by returning a new reference to themselves -- and should also "
"therefore implement the :c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""
"Objekt som bara kan itereras över en gång (vanligtvis på grund av bieffekter "
"av iteration, t.ex. filobjekt) kan implementera :c:member:`~PyTypeObject."
"tp_iter` genom att returnera en ny referens till sig själva -- och bör "
"därför också implementera :c:member:`~PyTypeObject.tp_iternext`-hanteraren."

msgid ""
"Any :term:`iterator` object should implement both :c:member:`~PyTypeObject."
"tp_iter` and :c:member:`~PyTypeObject.tp_iternext`.  An iterator's :c:member:"
"`~PyTypeObject.tp_iter` handler should return a new reference to the "
"iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler should return a "
"new reference to the next object in the iteration, if there is one. If the "
"iteration has reached the end, :c:member:`~PyTypeObject.tp_iternext` may "
"return ``NULL`` without setting an exception, or it may set :exc:"
"`StopIteration` *in addition* to returning ``NULL``; avoiding the exception "
"can yield slightly better performance.  If an actual error occurs, :c:member:"
"`~PyTypeObject.tp_iternext` should always set an exception and return "
"``NULL``."
msgstr ""
"Varje :term:`iterator`-objekt bör implementera både :c:member:`~PyTypeObject."
"tp_iter` och :c:member:`~PyTypeObject.tp_iternext`.  En iterators :c:member:"
"`~PyTypeObject.tp_iter`-hanterare bör returnera en ny referens till "
"iteratorn.  Dess :c:member:`~PyTypeObject.tp_iternext`-hanterare bör "
"returnera en ny referens till nästa objekt i iterationen, om det finns ett "
"sådant. Om iterationen har nått slutet kan :c:member:`~PyTypeObject."
"tp_iternext` returnera ``NULL`` utan att ställa in ett undantag, eller så "
"kan den ställa in :exc:`StopIteration` *i tillägg* till att returnera "
"``NULL``; att undvika undantaget kan ge något bättre prestanda.  Om ett "
"faktiskt fel inträffar bör :c:member:`~PyTypeObject.tp_iternext` alltid "
"sätta ett undantag och returnera ``NULL``."

msgid "Weak Reference Support"
msgstr "Svagt referensstöd"

msgid ""
"One of the goals of Python's weak reference implementation is to allow any "
"type to participate in the weak reference mechanism without incurring the "
"overhead on performance-critical objects (such as numbers)."
msgstr ""
"Ett av målen med Pythons implementering av svaga referenser är att låta alla "
"typer delta i mekanismen för svaga referenser utan att det uppstår overhead "
"på prestandakritiska objekt (t.ex. tal)."

msgid "Documentation for the :mod:`weakref` module."
msgstr "Dokumentation för modulen :mod:`weakref`."

msgid ""
"For an object to be weakly referenceable, the extension type must set the "
"``Py_TPFLAGS_MANAGED_WEAKREF`` bit of the :c:member:`~PyTypeObject.tp_flags` "
"field. The legacy :c:member:`~PyTypeObject.tp_weaklistoffset` field should "
"be left as zero."
msgstr ""
"För att ett objekt ska vara svagt refererbart måste tilläggstypen sätta "
"``Py_TPFLAGS_MANAGED_WEAKREF`` bit i fältet :c:member:`~PyTypeObject."
"tp_flags`. Det äldre fältet :c:member:`~PyTypeObject.tp_weaklistoffset` bör "
"lämnas som noll."

msgid ""
"Concretely, here is how the statically declared type object would look::"
msgstr "Konkret ser det statiskt deklarerade typobjektet ut på följande sätt::"

msgid ""
"static PyTypeObject TrivialType = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    /* ... other members omitted for brevity ... */\n"
"    .tp_flags = Py_TPFLAGS_MANAGED_WEAKREF | ...,\n"
"};"
msgstr ""
"static PyTypeObject TrivialType = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    /* ... andra medlemmar utelämnade för korthetens skull ... */\n"
"    .tp_flags = Py_TPFLAGS_MANAGED_WEAKREF | ...,\n"
"};"

msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`)::"
msgstr ""
"Det enda ytterligare tillägget är att ``tp_dealloc`` måste rensa alla svaga "
"referenser (genom att anropa :c:func:`PyObject_ClearWeakRefs`)::"

msgid ""
"static void\n"
"Trivial_dealloc(PyObject *op)\n"
"{\n"
"    /* Clear weakrefs first before calling any destructors */\n"
"    PyObject_ClearWeakRefs(op);\n"
"    /* ... remainder of destruction code omitted for brevity ... */\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}"
msgstr ""
"statiskt void\n"
"Trivial_dealloc(PyObject *op)\n"
"{\n"
"    /* Rensa svagreferenser först innan du anropar några destruktorer */\n"
"    PyObject_ClearWeakRefs(op);\n"
"    /* ... resten av destruktionskoden utelämnad för korthetens skull ... "
"*/\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}"

msgid "More Suggestions"
msgstr "Fler förslag"

msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function you "
"want (for example, ``tp_richcompare``).  You will find examples of the "
"function you want to implement."
msgstr ""
"För att lära dig hur du implementerar en specifik metod för din nya datatyp, "
"hämta :term:`CPython` källkod.  Gå till katalogen :file:`Objects` och sök "
"sedan i C-källfilerna efter ``tp_`` plus den funktion du vill ha (t.ex. "
"``tp_richcompare``).  Där hittar du exempel på den funktion som du vill "
"implementera."

msgid ""
"When you need to verify that an object is a concrete instance of the type "
"you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr ""
"När du behöver verifiera att ett objekt är en konkret instans av den typ du "
"implementerar, använd funktionen :c:func:`PyObject_TypeCheck`.  Ett exempel "
"på dess användning kan vara något i stil med följande::"

msgid ""
"if (!PyObject_TypeCheck(some_object, &MyType)) {\n"
"    PyErr_SetString(PyExc_TypeError, \"arg #1 not a mything\");\n"
"    return NULL;\n"
"}"
msgstr ""
"if (!PyObject_TypeCheck(some_object, &MyType)) {\n"
"    PyErr_SetString(PyExc_TypeError, \"arg #1 inte en mything\");\n"
"    returnera NULL;\n"
"}"

msgid "Download CPython source releases."
msgstr "Ladda ner CPython källversioner."

msgid "https://www.python.org/downloads/source/"
msgstr "https://www.python.org/downloads/source/"

msgid ""
"The CPython project on GitHub, where the CPython source code is developed."
msgstr "CPython-projektet på GitHub, där källkoden för CPython utvecklas."

msgid "https://github.com/python/cpython"
msgstr "https://github.com/python/cpython"

msgid "object"
msgstr "objekt"

msgid "deallocation"
msgstr "avallokering"

msgid "deallocation, object"
msgstr "deallokering, objekt"

msgid "finalization"
msgstr "slutförande"

msgid "finalization, of objects"
msgstr "slutförande, av objekt"

msgid "PyErr_Fetch (C function)"
msgstr "PyErr_Fetch (C-funktion)"

msgid "PyErr_Restore (C function)"
msgstr "PyErr_Restore (C-funktion)"

msgid "string"
msgstr "sträng"

msgid "object representation"
msgstr "objektrepresentation"

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "repr"
msgstr "repr"
