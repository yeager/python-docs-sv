# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!signal` --- Set handlers for asynchronous events"
msgstr ":mod:`!signal` --- Ställ in hanterare för asynkrona händelser"

msgid "**Source code:** :source:`Lib/signal.py`"
msgstr "**Källkod:** :source:`Lib/signal.py`"

msgid "This module provides mechanisms to use signal handlers in Python."
msgstr ""
"Denna modul tillhandahåller mekanismer för att använda signalhanterare i "
"Python."

msgid "General rules"
msgstr "Allmänna regler"

msgid ""
"The :func:`signal.signal` function allows defining custom handlers to be "
"executed when a signal is received.  A small number of default handlers are "
"installed: :const:`SIGPIPE` is ignored (so write errors on pipes and sockets "
"can be reported as ordinary Python exceptions) and :const:`SIGINT` is "
"translated into a :exc:`KeyboardInterrupt` exception if the parent process "
"has not changed it."
msgstr ""
"Funktionen :func:`signal.signal` gör det möjligt att definiera anpassade "
"hanterare som ska köras när en signal tas emot.  Ett litet antal "
"standardhanterare är installerade: :const:`SIGPIPE` ignoreras (så att "
"skrivfel på pipes och sockets kan rapporteras som vanliga Python-undantag) "
"och :const:`SIGINT` översätts till ett :exc:`KeyboardInterrupt`-undantag om "
"den överordnade processen inte har ändrat det."

msgid ""
"A handler for a particular signal, once set, remains installed until it is "
"explicitly reset (Python emulates the BSD style interface regardless of the "
"underlying implementation), with the exception of the handler for :const:"
"`SIGCHLD`, which follows the underlying implementation."
msgstr ""
"En hanterare för en viss signal, när den väl är inställd, förblir "
"installerad tills den uttryckligen återställs (Python emulerar BSD-"
"stilgränssnittet oavsett den underliggande implementeringen), med undantag "
"för hanteraren för :const:`SIGCHLD`, som följer den underliggande "
"implementeringen."

msgid ""
"On WebAssembly platforms, signals are emulated and therefore behave "
"differently. Several functions and signals are not available on these "
"platforms."
msgstr ""
"På WebAssembly-plattformar är signaler emulerade och beter sig därför "
"annorlunda. Flera funktioner och signaler är inte tillgängliga på dessa "
"plattformar."

msgid "Execution of Python signal handlers"
msgstr "Exekvering av Python-signalhanterare"

msgid ""
"A Python signal handler does not get executed inside the low-level (C) "
"signal handler.  Instead, the low-level signal handler sets a flag which "
"tells the :term:`virtual machine` to execute the corresponding Python signal "
"handler at a later point(for example at the next :term:`bytecode` "
"instruction). This has consequences:"
msgstr ""
"En Python-signalhanterare exekveras inte inuti lågnivåsignalhanteraren (C).  "
"Istället sätter signalhanteraren på låg nivå en flagga som talar om för :"
"term:`virtual machine` att exekvera motsvarande Python-signalhanterare vid "
"ett senare tillfälle (till exempel vid nästa :term:`bytecode`-instruktion). "
"Detta har konsekvenser:"

msgid ""
"It makes little sense to catch synchronous errors like :const:`SIGFPE` or :"
"const:`SIGSEGV` that are caused by an invalid operation in C code.  Python "
"will return from the signal handler to the C code, which is likely to raise "
"the same signal again, causing Python to apparently hang.  From Python 3.3 "
"onwards, you can use the :mod:`faulthandler` module to report on synchronous "
"errors."
msgstr ""
"Det är meningslöst att fånga synkrona fel som :const:`SIGFPE` eller :const:"
"`SIGSEGV` som orsakas av en ogiltig operation i C-koden.  Python kommer att "
"återvända från signalhanteraren till C-koden, som sannolikt kommer att ge "
"upphov till samma signal igen, vilket gör att Python uppenbarligen hänger "
"sig.  Från och med Python 3.3 och framåt kan du använda modulen :mod:"
"`faulthandler` för att rapportera synkrona fel."

msgid ""
"A long-running calculation implemented purely in C (such as regular "
"expression matching on a large body of text) may run uninterrupted for an "
"arbitrary amount of time, regardless of any signals received.  The Python "
"signal handlers will be called when the calculation finishes."
msgstr ""
"En långdragen beräkning som implementeras enbart i C (t.ex. matchning av "
"reguljära uttryck i en stor textmassa) kan köras oavbrutet under godtycklig "
"tid, oavsett vilka signaler som tas emot.  Pythons signalhanterare kommer "
"att anropas när beräkningen är klar."

msgid ""
"If the handler raises an exception, it will be raised \"out of thin air\" in "
"the main thread. See the :ref:`note below <handlers-and-exceptions>` for a "
"discussion."
msgstr ""
"Om hanteraren skapar ett undantag kommer det att skapas \"ur tomma intet\" i "
"huvudtråden. Se :ref:`noten nedan <handlers-and-exceptions>` för en "
"diskussion."

msgid "Signals and threads"
msgstr "Signaler och trådar"

msgid ""
"Python signal handlers are always executed in the main Python thread of the "
"main interpreter, even if the signal was received in another thread.  This "
"means that signals can't be used as a means of inter-thread communication.  "
"You can use the synchronization primitives from the :mod:`threading` module "
"instead."
msgstr ""
"Pythons signalhanterare exekveras alltid i huvudtolkens Python-tråd, även om "
"signalen mottogs i en annan tråd.  Detta innebär att signaler inte kan "
"användas som ett medel för kommunikation mellan trådar.  Du kan använda "
"synkroniseringsprimitiven från modulen :mod:`threading` istället."

msgid ""
"Besides, only the main thread of the main interpreter is allowed to set a "
"new signal handler."
msgstr ""
"Dessutom är det bara huvudtråden i huvudtolken som får ställa in en ny "
"signalhanterare."

msgid "Module contents"
msgstr "Modulens innehåll"

msgid ""
"signal (SIG*), handler (:const:`SIG_DFL`, :const:`SIG_IGN`) and sigmask (:"
"const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) related "
"constants listed below were turned into :class:`enums <enum.IntEnum>` (:"
"class:`Signals`, :class:`Handlers` and :class:`Sigmasks` respectively). :"
"func:`getsignal`, :func:`pthread_sigmask`, :func:`sigpending` and :func:"
"`sigwait` functions return human-readable :class:`enums <enum.IntEnum>` as :"
"class:`Signals` objects."
msgstr ""
"signal (SIG*), hanterare (:const:`SIG_DFL`, :const:`SIG_IGN`) och sigmask (:"
"const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) relaterade "
"konstanter listade nedan omvandlades till :class:`enums <enum.IntEnum>` (:"
"class:`Signals`, :class:`Handlers` respektive :class:`Sigmasks`). "
"funktionerna :func:`getsignal`, :func:`pthread_sigmask`, :func:`sigpending` "
"och :func:`sigwait` returnerar mänskligt läsbara :class:`enums <enum."
"IntEnum>` som :class:`Signals`-objekt."

msgid "The signal module defines three enums:"
msgstr "Signalmodulen definierar tre enumer:"

msgid ""
":class:`enum.IntEnum` collection of SIG* constants and the CTRL_* constants."
msgstr ""
":class:`enum.IntEnum` samling av SIG*-konstanter och CTRL_*-konstanter."

msgid ""
":class:`enum.IntEnum` collection the constants :const:`SIG_DFL` and :const:"
"`SIG_IGN`."
msgstr ""
":class:`enum.IntEnum` samlar in konstanterna :const:`SIG_DFL` och :const:"
"`SIG_IGN`."

msgid ""
":class:`enum.IntEnum` collection the constants :const:`SIG_BLOCK`, :const:"
"`SIG_UNBLOCK` and :const:`SIG_SETMASK`."
msgstr ""
":class:`enum.IntEnum` samlar konstanterna :const:`SIG_BLOCK`, :const:"
"`SIG_UNBLOCK` och :const:`SIG_SETMASK`."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"See the man page :manpage:`sigprocmask(2)` and :manpage:`pthread_sigmask(3)` "
"for further information."
msgstr ""
"Se man-sidorna :manpage:`sigprocmask(2)` och :manpage:`pthread_sigmask(3)` "
"för ytterligare information."

msgid "The variables defined in the :mod:`signal` module are:"
msgstr "De variabler som definieras i modulen :mod:`signal` är:"

msgid ""
"This is one of two standard signal handling options; it will simply perform "
"the default function for the signal.  For example, on most systems the "
"default action for :const:`SIGQUIT` is to dump core and exit, while the "
"default action for :const:`SIGCHLD` is to simply ignore it."
msgstr ""
"Detta är ett av två standardalternativ för signalhantering; det kommer helt "
"enkelt att utföra standardfunktionen för signalen.  På de flesta system är "
"till exempel standardåtgärden för :const:`SIGQUIT` att dumpa kärnan och "
"avsluta, medan standardåtgärden för :const:`SIGCHLD` är att helt enkelt "
"ignorera den."

msgid ""
"This is another standard signal handler, which will simply ignore the given "
"signal."
msgstr ""
"Detta är en annan standardsignalhanterare, som helt enkelt ignorerar den "
"givna signalen."

msgid "Abort signal from :manpage:`abort(3)`."
msgstr "Avbrottssignal från :manpage:`abort(3)`."

msgid "Timer signal from :manpage:`alarm(2)`."
msgstr "Timersignal från :manpage:`alarm(2)`."

msgid "Interrupt from keyboard (CTRL + BREAK)."
msgstr "Avbrott från tangentbordet (CTRL + BREAK)."

msgid "Bus error (bad memory access)."
msgstr "Bussfel (dålig minnesåtkomst)."

msgid "Child process stopped or terminated."
msgstr "Barnprocessen stoppades eller avslutades."

msgid "Alias to :data:`SIGCHLD`."
msgstr "Alias till :data:`SIGCHLD`."

msgid "Continue the process if it is currently stopped"
msgstr "Fortsätt processen om den för närvarande är stoppad"

msgid "Floating-point exception. For example, division by zero."
msgstr "Undantag för flyttal. Till exempel division med noll."

msgid ""
":exc:`ZeroDivisionError` is raised when the second argument of a division or "
"modulo operation is zero."
msgstr ""
":exc:`ZeroDivisionError` uppstår när det andra argumentet i en divisions- "
"eller modulooperation är noll."

msgid ""
"Hangup detected on controlling terminal or death of controlling process."
msgstr ""
"Upphängning upptäckt på styrande terminal eller död i styrande process."

msgid "Illegal instruction."
msgstr "Olaglig instruktion."

msgid "Interrupt from keyboard (CTRL + C)."
msgstr "Avbrott från tangentbordet (CTRL + C)."

msgid "Default action is to raise :exc:`KeyboardInterrupt`."
msgstr "Standardåtgärden är att skapa :exc:`KeyboardInterrupt`."

msgid "Kill signal."
msgstr "Dödssignal."

msgid "It cannot be caught, blocked, or ignored."
msgstr "Den kan inte fångas, blockeras eller ignoreras."

msgid "Broken pipe: write to pipe with no readers."
msgstr "Trasigt rör: skriv till ett rör utan läsare."

msgid "Default action is to ignore the signal."
msgstr "Standardåtgärden är att ignorera signalen."

msgid "Segmentation fault: invalid memory reference."
msgstr "Segmenteringsfel: ogiltig minnesreferens."

msgid ""
"Stack fault on coprocessor. The Linux kernel does not raise this signal: it "
"can only be raised in user space."
msgstr ""
"Stapelfel på coprocessor. Linuxkärnan ger inte ut den här signalen: den kan "
"bara ges ut i användarutrymmet."

msgid ""
"On architectures where the signal is available. See the man page :manpage:"
"`signal(7)` for further information."
msgstr ""
"På arkitekturer där signalen är tillgänglig. Se man-sidan :manpage:"
"`signal(7)` för ytterligare information."

msgid "Termination signal."
msgstr "Signal för avslutning."

msgid "User-defined signal 1."
msgstr "Användardefinierad signal 1."

msgid "User-defined signal 2."
msgstr "Användardefinierad signal 2."

msgid "Window resize signal."
msgstr "Signal för ändring av fönsterstorlek."

msgid ""
"All the signal numbers are defined symbolically.  For example, the hangup "
"signal is defined as :const:`signal.SIGHUP`; the variable names are "
"identical to the names used in C programs, as found in ``<signal.h>``.  The "
"Unix man page for ':c:func:`signal`' lists the existing signals (on some "
"systems this is :manpage:`signal(2)`, on others the list is in :manpage:"
"`signal(7)`). Note that not all systems define the same set of signal names; "
"only those names defined by the system are defined by this module."
msgstr ""
"Alla signalnummer är symboliskt definierade.  Till exempel definieras hangup-"
"signalen som :const:`signal.SIGHUP`; variabelnamnen är identiska med de namn "
"som används i C-program och som finns i ``<signal.h>``.  Unix man page för ':"
"c:func:`signal`' listar de befintliga signalerna (på vissa system är detta :"
"manpage:`signal(2)`, på andra finns listan i :manpage:`signal(7)`). "
"Observera att inte alla system definierar samma uppsättning signalnamn; "
"endast de namn som definieras av systemet definieras av den här modulen."

msgid ""
"The signal corresponding to the :kbd:`Ctrl+C` keystroke event. This signal "
"can only be used with :func:`os.kill`."
msgstr ""
"Den signal som motsvarar händelsen :kbd:`Ctrl+C` tangenttryckning. Denna "
"signal kan endast användas med :func:`os.kill`."

msgid ""
"The signal corresponding to the :kbd:`Ctrl+Break` keystroke event. This "
"signal can only be used with :func:`os.kill`."
msgstr ""
"Den signal som motsvarar händelsen :kbd:`Ctrl+Break` tangenttryckning. Denna "
"signal kan endast användas med :func:`os.kill`."

msgid ""
"One more than the number of the highest signal number. Use :func:"
"`valid_signals` to get valid signal numbers."
msgstr ""
"Ett mer än numret på det högsta signalnumret. Använd :func:`valid_signals` "
"för att få giltiga signalnummer."

msgid ""
"Decrements interval timer in real time, and delivers :const:`SIGALRM` upon "
"expiration."
msgstr ""
"Minskar intervalltimern i realtid och levererar :const:`SIGALRM` när den "
"löper ut."

msgid ""
"Decrements interval timer only when the process is executing, and delivers "
"SIGVTALRM upon expiration."
msgstr ""
"Minskar intervalltimern endast när processen körs och levererar SIGVTALRM "
"när den löper ut."

msgid ""
"Decrements interval timer both when the process executes and when the system "
"is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this "
"timer is usually used to profile the time spent by the application in user "
"and kernel space. SIGPROF is delivered upon expiration."
msgstr ""
"Minskar intervalltimern både när processen körs och när systemet körs på "
"uppdrag av processen. Tillsammans med ITIMER_VIRTUAL används den här timern "
"vanligtvis för att profilera den tid som programmet spenderar i användar- "
"och kärnutrymmet. SIGPROF levereras när den löper ut."

msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be blocked."
msgstr ""
"Ett möjligt värde för parametern *how* i :func:`pthread_sigmask` som anger "
"att signaler ska blockeras."

msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be unblocked."
msgstr ""
"Ett möjligt värde för *how*-parametern till :func:`pthread_sigmask` som "
"anger att signaler ska avblockeras."

msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that the signal mask is to be replaced."
msgstr ""
"Ett möjligt värde för *how*-parametern till :func:`pthread_sigmask` som "
"anger att signalmasken ska ersättas."

msgid "The :mod:`signal` module defines one exception:"
msgstr "Modulen :mod:`signal` definierar ett undantag:"

msgid ""
"Raised to signal an error from the underlying :func:`setitimer` or :func:"
"`getitimer` implementation. Expect this error if an invalid interval timer "
"or a negative time is passed to :func:`setitimer`. This error is a subtype "
"of :exc:`OSError`."
msgstr ""
"Utlöses för att signalera ett fel från den underliggande :func:`setitimer` "
"eller :func:`getitimer` implementationen. Förvänta dig detta fel om en "
"ogiltig intervalltimer eller en negativ tid skickas till :func:`setitimer`. "
"Detta fel är en subtyp av :exc:`OSError`."

msgid ""
"This error used to be a subtype of :exc:`IOError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Detta fel var tidigare en subtyp av :exc:`IOError`, som nu är ett alias av :"
"exc:`OSError`."

msgid "The :mod:`signal` module defines the following functions:"
msgstr "Modulen :mod:`signal` definierar följande funktioner:"

msgid ""
"If *time* is non-zero, this function requests that a :const:`SIGALRM` signal "
"be sent to the process in *time* seconds. Any previously scheduled alarm is "
"canceled (only one alarm can be scheduled at any time).  The returned value "
"is then the number of seconds before any previously set alarm was to have "
"been delivered. If *time* is zero, no alarm is scheduled, and any scheduled "
"alarm is canceled.  If the return value is zero, no alarm is currently "
"scheduled."
msgstr ""
"Om *time* inte är noll, begär denna funktion att en :const:`SIGALRM`-signal "
"skickas till processen om *time* sekunder. Eventuella tidigare schemalagda "
"larm avbryts (endast ett larm kan schemaläggas åt gången).  Det returnerade "
"värdet är då antalet sekunder innan något tidigare inställt larm skulle ha "
"levererats. Om *time* är noll är inget larm schemalagt och ett eventuellt "
"schemalagt larm avbryts.  Om returvärdet är noll är inget larm för "
"närvarande schemalagt."

msgid "See the man page :manpage:`alarm(2)` for further information."
msgstr "Se manualsidan :manpage:`alarm(2)` för ytterligare information."

msgid ""
"Return the current signal handler for the signal *signalnum*. The returned "
"value may be a callable Python object, or one of the special values :const:"
"`signal.SIG_IGN`, :const:`signal.SIG_DFL` or :const:`None`.  Here, :const:"
"`signal.SIG_IGN` means that the signal was previously ignored, :const:"
"`signal.SIG_DFL` means that the default way of handling the signal was "
"previously in use, and ``None`` means that the previous signal handler was "
"not installed from Python."
msgstr ""
"Returnerar den aktuella signalhanteraren för signalen *signalnum*. Det "
"returnerade värdet kan vara ett anropbart Python-objekt eller ett av "
"specialvärdena :const:`signal.SIG_IGN`, :const:`signal.SIG_DFL` eller :const:"
"`None`.  Här betyder :const:`signal.SIG_IGN` att signalen tidigare "
"ignorerades, :const:`signal.SIG_DFL` betyder att standardmetoden för att "
"hantera signalen tidigare användes och ``None`` betyder att den tidigare "
"signalhanteraren inte installerades från Python."

msgid ""
"Returns the description of signal *signalnum*, such as \"Interrupt\" for :"
"const:`SIGINT`. Returns :const:`None` if *signalnum* has no description. "
"Raises :exc:`ValueError` if *signalnum* is invalid."
msgstr ""
"Returnerar beskrivningen av signalen *signalnum*, t.ex. \"Interrupt\" för :"
"const:`SIGINT`. Returnerar :const:`None` om *signalnum* inte har någon "
"beskrivning. Utlöser :exc:`ValueError` om *signalnum* är ogiltig."

msgid ""
"Return the set of valid signal numbers on this platform.  This can be less "
"than ``range(1, NSIG)`` if some signals are reserved by the system for "
"internal use."
msgstr ""
"Returnerar uppsättningen av giltiga signalnummer på denna plattform.  Detta "
"kan vara mindre än ``range(1, NSIG)`` om vissa signaler är reserverade av "
"systemet för internt bruk."

msgid ""
"Cause the process to sleep until a signal is received; the appropriate "
"handler will then be called.  Returns nothing."
msgstr ""
"Får processen att sova tills en signal tas emot; lämplig hanterare kommer då "
"att anropas.  Returnerar ingenting."

msgid "See the man page :manpage:`signal(2)` for further information."
msgstr "Se man-sidan :manpage:`signal(2)` för ytterligare information."

msgid ""
"See also :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` and :"
"func:`sigpending`."
msgstr ""
"Se även :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` och :func:"
"`sigpending`."

msgid "Sends a signal to the calling process. Returns nothing."
msgstr "Skickar en signal till den anropande processen. Returnerar ingenting."

msgid ""
"Send signal *sig* to the process referred to by file descriptor *pidfd*. "
"Python does not currently support the *siginfo* parameter; it must be "
"``None``.  The *flags* argument is provided for future extensions; no flag "
"values are currently defined."
msgstr ""
"Skicka signalen *sig* till den process som filbeskrivaren *pidfd* refererar "
"till. Python har för närvarande inte stöd för parametern *siginfo*; den "
"måste vara ``None``.  Argumentet *flags* tillhandahålls för framtida "
"tillägg; inga flaggvärden är för närvarande definierade."

msgid "See the :manpage:`pidfd_send_signal(2)` man page for more information."
msgstr "Se :manpage:`pidfd_send_signal(2)` man page för mer information."

msgid ""
"Send the signal *signalnum* to the thread *thread_id*, another thread in the "
"same process as the caller.  The target thread can be executing any code "
"(Python or not).  However, if the target thread is executing the Python "
"interpreter, the Python signal handlers will be :ref:`executed by the main "
"thread of the main interpreter <signals-and-threads>`.  Therefore, the only "
"point of sending a signal to a particular Python thread would be to force a "
"running system call to fail with :exc:`InterruptedError`."
msgstr ""
"Skicka signalen *signalnum* till tråden *thread_id*, en annan tråd i samma "
"process som anroparen.  Måltråden kan exekvera vilken kod som helst (Python "
"eller inte).  Men om måltråden exekverar Python-tolken kommer Python-"
"signalhanterarna att :ref:`exekveras av huvudtråden i huvudtolken <signals-"
"and-threads>`.  Därför skulle den enda poängen med att skicka en signal till "
"en viss Python-tråd vara att tvinga ett pågående systemanrop att misslyckas "
"med :exc:`InterruptedError`."

msgid ""
"Use :func:`threading.get_ident` or the :attr:`~threading.Thread.ident` "
"attribute of :class:`threading.Thread` objects to get a suitable value for "
"*thread_id*."
msgstr ""
"Använd :func:`threading.get_ident` eller attributet :attr:`~threading.Thread."
"ident` i :class:`threading.Thread`-objekt för att få ett lämpligt värde för "
"*thread_id*."

msgid ""
"If *signalnum* is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check if the target thread is still running."
msgstr ""
"Om *signalnum* är 0 skickas ingen signal, men felkontroll utförs ändå; detta "
"kan användas för att kontrollera om måltråden fortfarande körs."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``signal.pthread_kill`` with "
"arguments ``thread_id``, ``signalnum``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``signal.pthread_kill`` med "
"argumenten ``thread_id``, ``signalnum``."

msgid "See the man page :manpage:`pthread_kill(3)` for further  information."
msgstr "Se man-sidan :manpage:`pthread_kill(3)` för ytterligare information."

msgid "See also :func:`os.kill`."
msgstr "Se även :func:`os.kill`."

msgid ""
"Fetch and/or change the signal mask of the calling thread.  The signal mask "
"is the set of signals whose delivery is currently blocked for the caller. "
"Return the old signal mask as a set of signals."
msgstr ""
"Hämta och/eller ändra signalmasken för den anropande tråden.  Signalmasken "
"är den uppsättning signaler vars leverans för närvarande är blockerad för "
"den anropande tråden. Returnera den gamla signalmasken som en uppsättning "
"signaler."

msgid ""
"The behavior of the call is dependent on the value of *how*, as follows."
msgstr "Anropets beteende är beroende av värdet på *how*, enligt följande."

msgid ""
":data:`SIG_BLOCK`: The set of blocked signals is the union of the current "
"set and the *mask* argument."
msgstr ""
":data:`SIG_BLOCK`: Uppsättningen av blockerade signaler är en förening av "
"den aktuella uppsättningen och argumentet *mask*."

msgid ""
":data:`SIG_UNBLOCK`: The signals in *mask* are removed from the current set "
"of blocked signals.  It is permissible to attempt to unblock a signal which "
"is not blocked."
msgstr ""
":data:`SIG_UNBLOCK`: Signalerna i *mask* tas bort från den aktuella "
"uppsättningen av blockerade signaler.  Det är tillåtet att försöka "
"avblockera en signal som inte är blockerad."

msgid ""
":data:`SIG_SETMASK`: The set of blocked signals is set to the *mask* "
"argument."
msgstr ""
":data:`SIG_SETMASK`: Uppsättningen av blockerade signaler ställs in till "
"argumentet *mask*."

msgid ""
"*mask* is a set of signal numbers (e.g. {:const:`signal.SIGINT`, :const:"
"`signal.SIGTERM`}). Use :func:`~signal.valid_signals` for a full mask "
"including all signals."
msgstr ""
"*mask* är en uppsättning signalnummer (t.ex. {:const:`signal.SIGINT`, :const:"
"`signal.SIGTERM`}). Använd :func:`~signal.valid_signals` för en fullständig "
"mask som inkluderar alla signaler."

msgid ""
"For example, ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` reads the "
"signal mask of the calling thread."
msgstr ""
"Till exempel läser ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` "
"signalmasken för den anropande tråden."

msgid ":data:`SIGKILL` and :data:`SIGSTOP` cannot be blocked."
msgstr ":data:`SIGKILL` och :data:`SIGSTOP` kan inte blockeras."

msgid "See also :func:`pause`, :func:`sigpending` and :func:`sigwait`."
msgstr "Se även :func:`pause`, :func:`sigpending` och :func:`sigwait`."

msgid ""
"Sets given interval timer (one of :const:`signal.ITIMER_REAL`, :const:"
"`signal.ITIMER_VIRTUAL` or :const:`signal.ITIMER_PROF`) specified by *which* "
"to fire after *seconds* (float is accepted, different from :func:`alarm`) "
"and after that every *interval* seconds (if *interval* is non-zero). The "
"interval timer specified by *which* can be cleared by setting *seconds* to "
"zero."
msgstr ""
"Ställer in en given intervalltimer (en av :const:`signal.ITIMER_REAL`, :"
"const:`signal.ITIMER_VIRTUAL` eller :const:`signal.ITIMER_PROF`) "
"specificerad av *which* att starta efter *seconds* (float accepteras, "
"skiljer sig från :func:`alarm`) och därefter var *intervall* sekund (om "
"*intervall* inte är noll). Intervalltimern som anges av *which* kan rensas "
"genom att *seconds* sätts till noll."

msgid ""
"When an interval timer fires, a signal is sent to the process. The signal "
"sent is dependent on the timer being used; :const:`signal.ITIMER_REAL` will "
"deliver :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` sends :const:"
"`SIGVTALRM`, and :const:`signal.ITIMER_PROF` will deliver :const:`SIGPROF`."
msgstr ""
"När en intervalltimer startar skickas en signal till processen. Signalen som "
"skickas beror på vilken timer som används; :const:`signal.ITIMER_REAL` "
"kommer att leverera :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` "
"skickar :const:`SIGVTALRM`, och :const:`signal.ITIMER_PROF` kommer att "
"leverera :const:`SIGPROF`."

msgid "The old values are returned as a tuple: (delay, interval)."
msgstr "De gamla värdena returneras som en tupel: (delay, interval)."

msgid ""
"Attempting to pass an invalid interval timer will cause an :exc:"
"`ItimerError`."
msgstr ""
"Försök att skicka en ogiltig intervalltimer kommer att orsaka ett :exc:"
"`ItimerError`."

msgid "Returns current value of a given interval timer specified by *which*."
msgstr ""
"Returnerar aktuellt värde för en given intervalltimer som specificeras av "
"*which*."

msgid ""
"Set the wakeup file descriptor to *fd*.  When a signal your program has "
"registered a signal handler for is received, the signal number is written as "
"a single byte into the fd.  If you haven't registered a signal handler for "
"the signals you care about, then nothing will be written to the wakeup fd. "
"This can be used by a library to wakeup a poll or select call, allowing the "
"signal to be fully processed."
msgstr ""
"Ställ in wakeup-filens deskriptor till *fd*.  När en signal som ditt program "
"har registrerat en signalhanterare för tas emot, skrivs signalnumret som en "
"enda byte till fd.  Om du inte har registrerat en signalhanterare för de "
"signaler du bryr dig om, skrivs ingenting till wakeup fd. Detta kan användas "
"av ett bibliotek för att väcka ett poll- eller select-anrop, så att signalen "
"kan bearbetas fullständigt."

msgid ""
"The old wakeup fd is returned (or -1 if file descriptor wakeup was not "
"enabled).  If *fd* is -1, file descriptor wakeup is disabled. If not -1, "
"*fd* must be non-blocking.  It is up to the library to remove any bytes from "
"*fd* before calling poll or select again."
msgstr ""
"Den gamla wakeup fd returneras (eller -1 om wakeup för filbeskrivare inte "
"var aktiverad).  Om *fd* är -1 inaktiveras väckning av filbeskrivare. Om "
"*fd* inte är -1 måste den vara icke-blockerande.  Det är upp till "
"biblioteket att ta bort eventuella byte från *fd* innan poll eller select "
"anropas igen."

msgid ""
"When threads are enabled, this function can only be called from :ref:`the "
"main thread of the main interpreter <signals-and-threads>`; attempting to "
"call it from other threads will cause a :exc:`ValueError` exception to be "
"raised."
msgstr ""
"När trådar är aktiverade kan den här funktionen endast anropas från :ref:"
"`huvudtråden i huvudtolken <signals-and-threads>`; om du försöker anropa den "
"från andra trådar kommer ett :exc:`ValueError`-undantag att uppstå."

msgid ""
"There are two common ways to use this function. In both approaches, you use "
"the fd to wake up when a signal arrives, but then they differ in how they "
"determine *which* signal or signals have arrived."
msgstr ""
"Det finns två vanliga sätt att använda den här funktionen. I båda fallen "
"använder man fd för att vakna när en signal kommer, men sedan skiljer de sig "
"åt i hur de avgör *vilken* signal eller vilka signaler som har kommit."

msgid ""
"In the first approach, we read the data out of the fd's buffer, and the byte "
"values give you the signal numbers. This is simple, but in rare cases it can "
"run into a problem: generally the fd will have a limited amount of buffer "
"space, and if too many signals arrive too quickly, then the buffer may "
"become full, and some signals may be lost. If you use this approach, then "
"you should set ``warn_on_full_buffer=True``, which will at least cause a "
"warning to be printed to stderr when signals are lost."
msgstr ""
"I den första metoden läser vi ut data ur fd:ns buffert, och bytevärdena ger "
"dig signalnumren. Det här är enkelt, men i sällsynta fall kan det uppstå "
"problem: i allmänhet har fd en begränsad mängd buffertutrymme, och om för "
"många signaler kommer för snabbt kan bufferten bli full och vissa signaler "
"kan gå förlorade. Om du använder det här tillvägagångssättet bör du ställa "
"in ``warn_on_full_buffer=True``, vilket åtminstone kommer att leda till att "
"en varning skrivs ut till stderr när signaler går förlorade."

msgid ""
"In the second approach, we use the wakeup fd *only* for wakeups, and ignore "
"the actual byte values. In this case, all we care about is whether the fd's "
"buffer is empty or non-empty; a full buffer doesn't indicate a problem at "
"all. If you use this approach, then you should set "
"``warn_on_full_buffer=False``, so that your users are not confused by "
"spurious warning messages."
msgstr ""
"I det andra tillvägagångssättet använder vi wakeup fd *endast* för "
"väckningar och ignorerar de faktiska bytevärdena. I det här fallet är allt "
"vi bryr oss om huruvida fd:s buffert är tom eller inte; en full buffert "
"indikerar inte alls något problem. Om du använder det här "
"tillvägagångssättet bör du ställa in ``warn_on_full_buffer=False``, så att "
"dina användare inte förvirras av falska varningsmeddelanden."

msgid "On Windows, the function now also supports socket handles."
msgstr "I Windows stöder funktionen nu även socket-handtag."

msgid "Added ``warn_on_full_buffer`` parameter."
msgstr "Lagt till parametern ``warn_on_full_buffer``."

msgid ""
"Change system call restart behaviour: if *flag* is :const:`False`, system "
"calls will be restarted when interrupted by signal *signalnum*, otherwise "
"system calls will be interrupted.  Returns nothing."
msgstr ""
"Ändra beteende för omstart av systemanrop: om *flag* är :const:`False`, "
"kommer systemanrop att startas om när de avbryts av signal *signalnum*, "
"annars kommer systemanrop att avbrytas.  Returnerar ingenting."

msgid "See the man page :manpage:`siginterrupt(3)` for further information."
msgstr "Se manualsidan :manpage:`siginterrupt(3)` för ytterligare information."

msgid ""
"Note that installing a signal handler with :func:`signal` will reset the "
"restart behaviour to interruptible by implicitly calling :c:func:`!"
"siginterrupt` with a true *flag* value for the given signal."
msgstr ""
"Observera att installation av en signalhanterare med :func:`signal` kommer "
"att återställa omstartbeteendet till avbrytbart genom att implicit anropa :c:"
"func:`!siginterrupt` med ett sant *flagg*-värde för den givna signalen."

msgid ""
"Set the handler for signal *signalnum* to the function *handler*.  *handler* "
"can be a callable Python object taking two arguments (see below), or one of "
"the special values :const:`signal.SIG_IGN` or :const:`signal.SIG_DFL`.  The "
"previous signal handler will be returned (see the description of :func:"
"`getsignal` above).  (See the Unix man page :manpage:`signal(2)` for further "
"information.)"
msgstr ""
"Ställ in hanteraren för signalen *signalnum* till funktionen *handler*.  "
"*handler* kan vara ett anropbart Python-objekt som tar två argument (se "
"nedan), eller ett av specialvärdena :const:`signal.SIG_IGN` eller :const:"
"`signal.SIG_DFL`.  Den föregående signalhanteraren kommer att returneras (se "
"beskrivningen av :func:`getsignal` ovan).  (Se Unix man page :manpage:"
"`signal(2)` för ytterligare information)"

msgid ""
"The *handler* is called with two arguments: the signal number and the "
"current stack frame (``None`` or a frame object; for a description of frame "
"objects, see the :ref:`description in the type hierarchy <frame-objects>` or "
"see the attribute descriptions in the :mod:`inspect` module)."
msgstr ""
"*Handler* anropas med två argument: signalnumret och den aktuella stackramen "
"(``None`` eller ett ramobjekt; för en beskrivning av ramobjekt, se :ref:"
"`description i typhierarkin <frame-objects>` eller se "
"attributbeskrivningarna i modulen :mod:`inspect`)."

msgid ""
"On Windows, :func:`signal` can only be called with :const:`SIGABRT`, :const:"
"`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, :const:"
"`SIGTERM`, or :const:`SIGBREAK`. A :exc:`ValueError` will be raised in any "
"other case. Note that not all systems define the same set of signal names; "
"an :exc:`AttributeError` will be raised if a signal name is not defined as "
"``SIG*`` module level constant."
msgstr ""
"I Windows kan :func:`signal` endast anropas med :const:`SIGABRT`, :const:"
"`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, :const:"
"`SIGTERM` eller :const:`SIGBREAK`. Ett :exc:`ValueError` kommer att uppstå i "
"alla andra fall. Observera att inte alla system definierar samma uppsättning "
"signalnamn; ett :exc:`AttributeError` kommer att uppstå om ett signalnamn "
"inte är definierat som ``SIG*`` konstant på modulnivå."

msgid ""
"Examine the set of signals that are pending for delivery to the calling "
"thread (i.e., the signals which have been raised while blocked).  Return the "
"set of the pending signals."
msgstr ""
"Undersök uppsättningen signaler som väntar på att levereras till den "
"anropande tråden (dvs. de signaler som har skapats medan de blockerats).  "
"Returnera uppsättningen av de väntande signalerna."

msgid "See the man page :manpage:`sigpending(2)` for further information."
msgstr "Se manualsidan :manpage:`sigpending(2)` för ytterligare information."

msgid "See also :func:`pause`, :func:`pthread_sigmask` and :func:`sigwait`."
msgstr "Se även :func:`pause`, :func:`pthread_sigmask` och :func:`sigwait`."

msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal (removes it from the pending list of signals), and returns the signal "
"number."
msgstr ""
"Avbryter exekveringen av den anropande tråden tills en av de signaler som "
"anges i signaluppsättningen *sigset* har levererats.  Funktionen accepterar "
"signalen (tar bort den från listan över väntande signaler) och returnerar "
"signalnumret."

msgid "See the man page :manpage:`sigwait(3)` for further information."
msgstr "Se manualsidan :manpage:`sigwait(3)` för ytterligare information."

msgid ""
"See also :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :func:"
"`sigwaitinfo` and :func:`sigtimedwait`."
msgstr ""
"Se även :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :func:"
"`sigwaitinfo` och :func:`sigtimedwait`."

msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal and removes it from the pending list of signals. If one of the "
"signals in *sigset* is already pending for the calling thread, the function "
"will return immediately with information about that signal. The signal "
"handler is not called for the delivered signal. The function raises an :exc:"
"`InterruptedError` if it is interrupted by a signal that is not in *sigset*."
msgstr ""
"Avbryt exekveringen av den anropande tråden tills en av de signaler som "
"anges i signaluppsättningen *sigset* har levererats.  Funktionen accepterar "
"signalen och tar bort den från listan över väntande signaler. Om en av "
"signalerna i *sigset* redan är väntande för den anropande tråden, kommer "
"funktionen att returnera omedelbart med information om den signalen. "
"Signalhanteraren anropas inte för den levererade signalen. Funktionen ger "
"upphov till ett :exc:`InterruptedError` om den avbryts av en signal som inte "
"finns i *sigset*."

msgid ""
"The return value is an object representing the data contained in the :c:type:"
"`siginfo_t` structure, namely: :attr:`si_signo`, :attr:`si_code`, :attr:"
"`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, :attr:"
"`si_band`."
msgstr ""
"Returvärdet är ett objekt som representerar de data som finns i strukturen :"
"c:type:`siginfo_t`, nämligen: :attr:`si_signo`, :attr:`si_code`, :attr:"
"`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, :attr:"
"`si_band`."

msgid "See the man page :manpage:`sigwaitinfo(2)` for further information."
msgstr "Se manualsidan :manpage:`sigwaitinfo(2)` för ytterligare information."

msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigtimedwait`."
msgstr "Se även :func:`pause`, :func:`sigwait` och :func:`sigtimedwait`."

msgid ""
"The function is now retried if interrupted by a signal not in *sigset* and "
"the signal handler does not raise an exception (see :pep:`475` for the "
"rationale)."
msgstr ""
"Funktionen prövas nu igen om den avbryts av en signal som inte finns i "
"*sigset* och signalhanteraren inte ger upphov till ett undantag (se :pep:"
"`475` för motivering)."

msgid ""
"Like :func:`sigwaitinfo`, but takes an additional *timeout* argument "
"specifying a timeout. If *timeout* is specified as ``0``, a poll is "
"performed. Returns :const:`None` if a timeout occurs."
msgstr ""
"Som :func:`sigwaitinfo`, men tar ytterligare ett *timeout*-argument som "
"anger en timeout. Om *timeout* anges som ``0`` utförs en pollning. "
"Returnerar :const:`None` om en timeout inträffar."

msgid "See the man page :manpage:`sigtimedwait(2)` for further information."
msgstr "Se manualsidan :manpage:`sigtimedwait(2)` för ytterligare information."

msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigwaitinfo`."
msgstr "Se även :func:`pause`, :func:`sigwait` och :func:`sigwaitinfo`."

msgid ""
"The function is now retried with the recomputed *timeout* if interrupted by "
"a signal not in *sigset* and the signal handler does not raise an exception "
"(see :pep:`475` for the rationale)."
msgstr ""
"Funktionen försöker nu igen med den omräknade *timeout* om den avbryts av en "
"signal som inte finns i *sigset* och signalhanteraren inte gör ett undantag "
"(se :pep:`475` för motivering)."

msgid "Examples"
msgstr "Exempel"

msgid ""
"Here is a minimal example program. It uses the :func:`alarm` function to "
"limit the time spent waiting to open a file; this is useful if the file is "
"for a serial device that may not be turned on, which would normally cause "
"the :func:`os.open` to hang indefinitely.  The solution is to set a 5-second "
"alarm before opening the file; if the operation takes too long, the alarm "
"signal will be sent, and the handler raises an exception. ::"
msgstr ""
"Här är ett minimalt exempelprogram. Det använder funktionen :func:`alarm` "
"för att begränsa väntetiden för att öppna en fil; detta är användbart om "
"filen är för en seriell enhet som kanske inte är påslagen, vilket normalt "
"skulle få :func:`os.open` att hänga sig på obestämd tid.  Lösningen är att "
"ställa in ett 5-sekunders alarm innan filen öppnas; om operationen tar för "
"lång tid skickas alarmsignalen och hanteraren gör ett undantag. ::"

msgid ""
"import signal, os\n"
"\n"
"def handler(signum, frame):\n"
"    signame = signal.Signals(signum).name\n"
"    print(f'Signal handler called with signal {signame} ({signum})')\n"
"    raise OSError(\"Couldn't open device!\")\n"
"\n"
"# Set the signal handler and a 5-second alarm\n"
"signal.signal(signal.SIGALRM, handler)\n"
"signal.alarm(5)\n"
"\n"
"# This open() may hang indefinitely\n"
"fd = os.open('/dev/ttyS0', os.O_RDWR)\n"
"\n"
"signal.alarm(0)          # Disable the alarm"
msgstr ""
"import signal, os\n"
"\n"
"def handler(signum, frame):\n"
"    signame = signal.Signals(signum).name\n"
"    print(f'Signal handler called with signal {signame} ({signum})')\n"
"    raise OSError(\"Couldn't open device!\")\n"
"\n"
"# Set the signal handler and a 5-second alarm\n"
"signal.signal(signal.SIGALRM, handler)\n"
"signal.alarm(5)\n"
"\n"
"# This open() may hang indefinitely\n"
"fd = os.open('/dev/ttyS0', os.O_RDWR)\n"
"\n"
"signal.alarm(0)          # Disable the alarm"

msgid "Note on SIGPIPE"
msgstr "Anmärkning om SIGPIPE"

msgid ""
"Piping output of your program to tools like :manpage:`head(1)` will cause a :"
"const:`SIGPIPE` signal to be sent to your process when the receiver of its "
"standard output closes early.  This results in an exception like :code:"
"`BrokenPipeError: [Errno 32] Broken pipe`.  To handle this case, wrap your "
"entry point to catch this exception as follows::"
msgstr ""
"Att pipa utdata från ditt program till verktyg som :manpage:`head(1)` kommer "
"att orsaka att en :const:`SIGPIPE`-signal skickas till din process när "
"mottagaren av dess standardutdata stängs tidigt.  Detta resulterar i ett "
"undantag som :code:`BrokenPipeError: [Errno 32] Broken pipe`.  För att "
"hantera det här fallet, linda in din ingångspunkt för att fånga det här "
"undantaget enligt följande::"

msgid ""
"import os\n"
"import sys\n"
"\n"
"def main():\n"
"    try:\n"
"        # simulate large output (your code replaces this loop)\n"
"        for x in range(10000):\n"
"            print(\"y\")\n"
"        # flush output here to force SIGPIPE to be triggered\n"
"        # while inside this try block.\n"
"        sys.stdout.flush()\n"
"    except BrokenPipeError:\n"
"        # Python flushes standard streams on exit; redirect remaining "
"output\n"
"        # to devnull to avoid another BrokenPipeError at shutdown\n"
"        devnull = os.open(os.devnull, os.O_WRONLY)\n"
"        os.dup2(devnull, sys.stdout.fileno())\n"
"        sys.exit(1)  # Python exits with error code 1 on EPIPE\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import os\n"
"import sys\n"
"\n"
"def main():\n"
"    try:\n"
"        # simulate large output (your code replaces this loop)\n"
"        for x in range(10000):\n"
"            print(\"y\")\n"
"        # flush output here to force SIGPIPE to be triggered\n"
"        # while inside this try block.\n"
"        sys.stdout.flush()\n"
"    except BrokenPipeError:\n"
"        # Python flushes standard streams on exit; redirect remaining "
"output\n"
"        # to devnull to avoid another BrokenPipeError at shutdown\n"
"        devnull = os.open(os.devnull, os.O_WRONLY)\n"
"        os.dup2(devnull, sys.stdout.fileno())\n"
"        sys.exit(1)  # Python exits with error code 1 on EPIPE\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

msgid ""
"Do not set :const:`SIGPIPE`'s disposition to :const:`SIG_DFL` in order to "
"avoid :exc:`BrokenPipeError`.  Doing that would cause your program to exit "
"unexpectedly whenever any socket connection is interrupted while your "
"program is still writing to it."
msgstr ""
"Ställ inte in :const:`SIGPIPE` disposition till :const:`SIG_DFL` för att "
"undvika :exc:`BrokenPipeError`.  Om du gör det kommer ditt program att "
"avslutas oväntat när en socketanslutning avbryts medan ditt program "
"fortfarande skriver till den."

msgid "Note on Signal Handlers and Exceptions"
msgstr "Anmärkning om signalhanterare och undantag"

msgid ""
"If a signal handler raises an exception, the exception will be propagated to "
"the main thread and may be raised after any :term:`bytecode` instruction. "
"Most notably, a :exc:`KeyboardInterrupt` may appear at any point during "
"execution. Most Python code, including the standard library, cannot be made "
"robust against this, and so a :exc:`KeyboardInterrupt` (or any other "
"exception resulting from a signal handler) may on rare occasions put the "
"program in an unexpected state."
msgstr ""
"Om en signalhanterare ger upphov till ett undantag, kommer undantaget att "
"spridas till huvudtråden och kan ges upphov till efter varje :term:"
"`bytecode`-instruktion. Mest anmärkningsvärt är att ett :exc:"
"`KeyboardInterrupt` kan dyka upp när som helst under exekveringen. Den mesta "
"Python-koden, inklusive standardbiblioteket, kan inte göras robust mot "
"detta, och därför kan ett :exc:`KeyboardInterrupt` (eller något annat "
"undantag som härrör från en signalhanterare) vid sällsynta tillfällen "
"försätta programmet i ett oväntat tillstånd."

msgid "To illustrate this issue, consider the following code::"
msgstr "För att illustrera detta problem kan du titta på följande kod::"

msgid ""
"class SpamContext:\n"
"    def __init__(self):\n"
"        self.lock = threading.Lock()\n"
"\n"
"    def __enter__(self):\n"
"        # If KeyboardInterrupt occurs here, everything is fine\n"
"        self.lock.acquire()\n"
"        # If KeyboardInterrupt occurs here, __exit__ will not be called\n"
"        ...\n"
"        # KeyboardInterrupt could occur just before the function returns\n"
"\n"
"    def __exit__(self, exc_type, exc_val, exc_tb):\n"
"        ...\n"
"        self.lock.release()"
msgstr ""
"class SpamContext:\n"
"    def __init__(self):\n"
"        self.lock = threading.Lock()\n"
"\n"
"    def __enter__(self):\n"
"        # If KeyboardInterrupt occurs here, everything is fine\n"
"        self.lock.acquire()\n"
"        # If KeyboardInterrupt occurs here, __exit__ will not be called\n"
"        ...\n"
"        # KeyboardInterrupt could occur just before the function returns\n"
"\n"
"    def __exit__(self, exc_type, exc_val, exc_tb):\n"
"        ...\n"
"        self.lock.release()"

msgid ""
"For many programs, especially those that merely want to exit on :exc:"
"`KeyboardInterrupt`, this is not a problem, but applications that are "
"complex or require high reliability should avoid raising exceptions from "
"signal handlers. They should also avoid catching :exc:`KeyboardInterrupt` as "
"a means of gracefully shutting down.  Instead, they should install their "
"own :const:`SIGINT` handler. Below is an example of an HTTP server that "
"avoids :exc:`KeyboardInterrupt`::"
msgstr ""
"För många program, speciellt de som bara vill avsluta på :exc:"
"`KeyboardInterrupt`, är detta inget problem, men applikationer som är "
"komplexa eller kräver hög tillförlitlighet bör undvika att skapa undantag "
"från signalhanterare. De bör också undvika att fånga :exc:"
"`KeyboardInterrupt` som ett sätt att stänga av på ett elegant sätt.  "
"Istället bör de installera sin egen :const:`SIGINT`-hanterare. Nedan följer "
"ett exempel på en HTTP-server som undviker :exc:`KeyboardInterrupt`::"

msgid ""
"import signal\n"
"import socket\n"
"from selectors import DefaultSelector, EVENT_READ\n"
"from http.server import HTTPServer, SimpleHTTPRequestHandler\n"
"\n"
"interrupt_read, interrupt_write = socket.socketpair()\n"
"\n"
"def handler(signum, frame):\n"
"    print('Signal handler called with signal', signum)\n"
"    interrupt_write.send(b'\\0')\n"
"signal.signal(signal.SIGINT, handler)\n"
"\n"
"def serve_forever(httpd):\n"
"    sel = DefaultSelector()\n"
"    sel.register(interrupt_read, EVENT_READ)\n"
"    sel.register(httpd, EVENT_READ)\n"
"\n"
"    while True:\n"
"        for key, _ in sel.select():\n"
"            if key.fileobj == interrupt_read:\n"
"                interrupt_read.recv(1)\n"
"                return\n"
"            if key.fileobj == httpd:\n"
"                httpd.handle_request()\n"
"\n"
"print(\"Serving on port 8000\")\n"
"httpd = HTTPServer(('', 8000), SimpleHTTPRequestHandler)\n"
"serve_forever(httpd)\n"
"print(\"Shutdown...\")"
msgstr ""
"import signal\n"
"import socket\n"
"from selectors import DefaultSelector, EVENT_READ\n"
"from http.server import HTTPServer, SimpleHTTPRequestHandler\n"
"\n"
"interrupt_read, interrupt_write = socket.socketpair()\n"
"\n"
"def handler(signum, frame):\n"
"    print('Signal handler called with signal', signum)\n"
"    interrupt_write.send(b'\\0')\n"
"signal.signal(signal.SIGINT, handler)\n"
"\n"
"def serve_forever(httpd):\n"
"    sel = DefaultSelector()\n"
"    sel.register(interrupt_read, EVENT_READ)\n"
"    sel.register(httpd, EVENT_READ)\n"
"\n"
"    while True:\n"
"        for key, _ in sel.select():\n"
"            if key.fileobj == interrupt_read:\n"
"                interrupt_read.recv(1)\n"
"                return\n"
"            if key.fileobj == httpd:\n"
"                httpd.handle_request()\n"
"\n"
"print(\"Serving on port 8000\")\n"
"httpd = HTTPServer(('', 8000), SimpleHTTPRequestHandler)\n"
"serve_forever(httpd)\n"
"print(\"Shutdown...\")"
