# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!logging.config` --- Logging configuration"
msgstr ":mod:`!logging.config` --- Konfiguration av loggning"

msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**Källkod:** :source:`Lib/logging/config.py`"

msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Denna sida innehåller endast referensinformation. För handledning, vänligen "
"se"

msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:``Grundläggande handledning <logging-basic-tutorial>``"

msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Avancerad handledning <logging-advanced-tutorial>`"

msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Loggningskokbok <logging-cookbook>`"

msgid "This section describes the API for configuring the logging module."
msgstr "I det här avsnittet beskrivs API:et för konfiguration av loggmodulen."

msgid "Configuration functions"
msgstr "Funktioner för konfiguration"

msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the "
"main API (defined in :mod:`logging` itself) and defining handlers which are "
"declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"Följande funktioner konfigurerar loggningsmodulen. De finns i modulen :mod:"
"`logging.config`.  Användningen av dem är valfri --- du kan konfigurera "
"loggmodulen med hjälp av dessa funktioner eller genom att göra anrop till "
"huvud-API:t (definierat i :mod:`logging` själv) och definiera hanterare som "
"deklareras antingen i :mod:`logging` eller :mod:`logging.handlers`."

msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr ""
"Hämtar loggningskonfigurationen från en ordbok.  Innehållet i denna ordbok "
"beskrivs i :ref:`logging-config-dictschema` nedan."

msgid ""
"If an error is encountered during configuration, this function will raise a :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or :exc:"
"`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"Om ett fel uppstår under konfigurationen kommer denna funktion att ge upphov "
"till :exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` eller :exc:"
"`ImportError` med ett lämpligt beskrivande meddelande.  Följande är en "
"(eventuellt ofullständig) lista över villkor som ger upphov till ett fel:"

msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr ""
"En ``level`` som inte är en sträng eller som är en sträng som inte motsvarar "
"en faktisk loggningsnivå."

msgid "A ``propagate`` value which is not a boolean."
msgstr "Ett ``propagate``-värde som inte är en boolean."

msgid "An id which does not have a corresponding destination."
msgstr "Ett id som inte har någon motsvarande destination."

msgid "A non-existent handler id found during an incremental call."
msgstr ""
"Ett icke-existerande hanterar-id hittades under ett inkrementellt anrop."

msgid "An invalid logger name."
msgstr "Ett ogiltigt loggarnamn."

msgid "Inability to resolve to an internal or external object."
msgstr "Oförmåga att bestämma sig för ett inre eller yttre objekt."

msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a :meth:"
"`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to :class:"
"`DictConfigurator`. You can replace the value of :attr:`dictConfigClass` "
"with a suitable implementation of your own."
msgstr ""
"Parsningen utförs av klassen :class:`DictConfigurator`, vars konstruktör får "
"den ordbok som används för konfigurationen och har en metod :meth:"
"`configure`.  Modulen :mod:`logging.config` har ett anropbart attribut :attr:"
"`dictConfigClass` som initialt är inställt på :class:`DictConfigurator`. Du "
"kan ersätta värdet på :attr:`dictConfigClass` med en egen lämplig "
"implementation."

msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` anropar :attr:`dictConfigClass` som skickar den angivna "
"ordlistan, och anropar sedan :meth:`configure`-metoden på det returnerade "
"objektet för att sätta konfigurationen i kraft::"

msgid ""
"def dictConfig(config):\n"
"    dictConfigClass(config).configure()"
msgstr ""
"def dictConfig(config):\n"
"    dictConfigClass(config).configure()"

msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then :"
"func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""
"Till exempel skulle en underklass till :class:`DictConfigurator` kunna "
"anropa ``DictConfigurator.__init__()`` i sin egen :meth:`__init__`, och "
"sedan ställa in anpassade prefix som skulle kunna användas i det "
"efterföljande :meth:`configure`-anropet. :attr:`dictConfigClass` skulle "
"bindas till denna nya underklass, och sedan skulle :func:`dictConfig` kunna "
"anropas exakt som i standardtillståndet, utan anpassning."

msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"Läser in loggningskonfigurationen från en fil i formatet :mod:"
"`configparser`. Filens format bör vara det som beskrivs i :ref:`logging-"
"config-fileformat`. Den här funktionen kan anropas flera gånger från en "
"applikation, så att slutanvändaren kan välja mellan olika förinställda "
"konfigurationer (om utvecklaren tillhandahåller en mekanism för att "
"presentera alternativen och ladda den valda konfigurationen)."

msgid ""
"It will raise :exc:`FileNotFoundError` if the file doesn't exist and :exc:"
"`RuntimeError` if the file is invalid or empty."
msgstr ""
"Den ger upphov till :exc:`FileNotFoundError` om filen inte finns och :exc:"
"`RuntimeError` om filen är ogiltig eller tom."

msgid "Parameters"
msgstr "Parametrar"

msgid ""
"A filename, or a file-like object, or an instance derived from :class:"
"`~configparser.RawConfigParser`. If a :class:`!RawConfigParser`-derived "
"instance is passed, it is used as is. Otherwise, a :class:`~configparser."
"ConfigParser` is instantiated, and the configuration read by it from the "
"object passed in ``fname``. If that has a :meth:`readline` method, it is "
"assumed to be a file-like object and read using :meth:`~configparser."
"ConfigParser.read_file`; otherwise, it is assumed to be a filename and "
"passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""
"Ett filnamn, eller ett filliknande objekt, eller en instans härledd från :"
"class:`~configparser.RawConfigParser`. Om en :class:`!RawConfigParser`-"
"deriverad instans skickas, används den som den är. Annars instansieras en :"
"class:`~configparser.ConfigParser` och konfigurationen läses av den från "
"objektet som passeras i ``fname``. Om det har en :meth:`readline`-metod, "
"antas det vara ett filliknande objekt och läses med :meth:`~configparser."
"ConfigParser.read_file`; annars antas det vara ett filnamn och skickas till :"
"meth:`~configparser.ConfigParser.read`."

msgid ""
"Defaults to be passed to the :class:`!ConfigParser` can be specified in this "
"argument."
msgstr ""
"Standardvärden som ska skickas till :class:`!ConfigParser` kan anges i detta "
"argument."

msgid ""
"If specified as ``False``, loggers which exist when this call is made are "
"left enabled. The default is ``True`` because this enables old behaviour in "
"a backward-compatible way. This behaviour is to disable any existing non-"
"root loggers unless they or their ancestors are explicitly named in the "
"logging configuration."
msgstr ""
"Om det anges som \"False\" kommer loggar som finns när anropet görs att vara "
"aktiverade. Standardvärdet är ``True`` eftersom detta aktiverar gammalt "
"beteende på ett bakåtkompatibelt sätt. Detta beteende är att inaktivera alla "
"befintliga loggar som inte är rotloggar om inte de eller deras förfäder "
"uttryckligen namnges i loggningskonfigurationen."

msgid "The encoding used to open file when *fname* is filename."
msgstr "Den kodning som används för att öppna filen när *fname* är filnamnet."

msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   now "
"accepted as a value for ``fname``. This facilitates:"
msgstr ""
"En instans av en underklass till :class:`~configparser.RawConfigParser` "
"accepteras nu som ett värde för ``fname``. Detta underlättar:"

msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr ""
"Användning av en konfigurationsfil där loggningskonfigurationen bara är en "
"del av den övergripande applikationskonfigurationen."

msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr ""
"Användning av en konfiguration som läses från en fil och sedan ändras av det "
"användande programmet (t.ex. baserat på kommandoradsparametrar eller andra "
"aspekter av körtidsmiljön) innan den skickas till ``fileConfig``."

msgid "Added the *encoding* parameter."
msgstr "Parametern *encoding* har lagts till."

msgid ""
"An exception will be thrown if the provided file doesn't exist or is invalid "
"or empty."
msgstr ""
"Ett undantag kommer att kastas om den angivna filen inte finns eller är "
"ogiltig eller tom."

msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent "
"as a file suitable for processing by :func:`dictConfig` or :func:"
"`fileConfig`. Returns a :class:`~threading.Thread` instance on which you can "
"call :meth:`~threading.Thread.start` to start the server, and which you can :"
"meth:`~threading.Thread.join` when appropriate. To stop the server, call :"
"func:`stopListening`."
msgstr ""
"Startar upp en socket-server på den angivna porten och lyssnar efter nya "
"konfigurationer. Om ingen port anges används modulens standard :const:"
"`DEFAULT_LOGGING_CONFIG_PORT`. Loggningskonfigurationer kommer att skickas "
"som en fil som kan bearbetas av :func:`dictConfig` eller :func:`fileConfig`. "
"Returnerar en :class:`~threading.Thread`-instans på vilken du kan anropa :"
"meth:`~threading.Thread.start` för att starta servern, och som du kan :meth:"
"`~threading.Thread.join` när det är lämpligt. För att stoppa servern, "
"anropa :func:`stopListening`."

msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g. "
"when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"Argumentet ``verify``, om det specificeras, bör vara en anropbar funktion "
"som verifierar om byte som tas emot via sockeln är giltiga och bör "
"behandlas. Detta kan göras genom att kryptera och/eller signera det som "
"skickas över sockeln, så att anropsbarnet ``verify`` kan utföra "
"signaturverifiering och/eller dekryptering. Anropsbarheten ``verify`` "
"anropas med ett enda argument - de byte som mottagits över sockeln - och bör "
"returnera de byte som skall behandlas, eller ``None`` för att ange att byte "
"skall kasseras. De returnerade bytena kan vara desamma som de överförda "
"bytena (t.ex. när endast verifiering görs), eller så kan de vara helt "
"annorlunda (kanske om dekryptering utförts)."

msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"För att skicka en konfiguration till uttaget läser du in konfigurationsfilen "
"och skickar den till uttaget som en sekvens av byte som föregås av en fyra "
"byte lång sträng som packas binärt med hjälp av ``struct.pack('>L', n)``."

msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs "
"whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even "
"if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations "
"from being applied."
msgstr ""
"Eftersom delar av konfigurationen skickas genom :func:`eval` kan användning "
"av denna funktion innebära en säkerhetsrisk för användaren. Även om "
"funktionen endast binder till ett uttag på ``localhost``, och därför inte "
"accepterar anslutningar från fjärranslutna maskiner, finns det scenarier där "
"opålitlig kod kan köras under kontot för den process som anropar :func:"
"`listen`. Om processen som anropar :func:`listen` körs på en "
"fleranvändarmaskin där användarna inte kan lita på varandra, kan en "
"illvillig användare ordna så att i princip godtycklig kod körs i en utsatt "
"användares process, helt enkelt genom att ansluta till den utsatta "
"användarens :func:`listen`-socket och skicka en konfiguration som kör den "
"kod som angriparen vill ha körd i den utsatta användarens process. Detta är "
"särskilt lätt att göra om standardporten används, men inte svårt även om en "
"annan port används. För att undvika risken att detta händer, använd "
"argumentet ``verify`` till :func:`listen` för att förhindra att "
"konfigurationer som inte känns igen används."

msgid "The ``verify`` argument was added."
msgstr "Argumentet ``verify`` har lagts till."

msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"Om du vill skicka konfigurationer till lyssnaren som inte inaktiverar "
"befintliga loggar, måste du använda ett JSON-format för konfigurationen, som "
"använder :func:`dictConfig` för konfigurationen. Med den här metoden kan du "
"ange ``disable_existing_loggers`` som ``False`` i den konfiguration du "
"skickar."

msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
"Stoppar den lyssnande server som skapades med ett anrop till :func:`listen`. "
"Detta anropas vanligtvis innan :meth:`join` anropas på returvärdet från :"
"func:`listen`."

msgid "Security considerations"
msgstr "Överväganden om säkerhet"

msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you "
"like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""
"Loggningskonfigurationsfunktionaliteten försöker erbjuda bekvämlighet, och "
"delvis görs detta genom att erbjuda möjligheten att konvertera text i "
"konfigurationsfiler till Python-objekt som används i "
"loggningskonfigurationen - till exempel enligt beskrivningen i :ref:`logging-"
"config-dict-userdef`. Samma mekanismer (importera anropbara objekt från "
"användardefinierade moduler och anropa dem med parametrar från "
"konfigurationen) kan dock användas för att anropa vilken kod som helst, och "
"därför bör du behandla konfigurationsfiler från opålitliga källor med "
"*extrema försiktighet* och försäkra dig om att inget dåligt kan hända om du "
"läser in dem innan du faktiskt läser in dem."

msgid "Configuration dictionary schema"
msgstr "Schema för konfigurationsordbok"

msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own "
"formatter or handler class. The parameters to these classes may also need to "
"include external objects such as ``sys.stderr``.  The syntax for describing "
"these objects and connections is defined in :ref:`logging-config-dict-"
"connections` below."
msgstr ""
"För att beskriva en loggningskonfiguration måste du lista de olika objekt "
"som ska skapas och kopplingarna mellan dem; du kan till exempel skapa en "
"hanterare med namnet \"console\" och sedan säga att loggern med namnet "
"\"startup\" ska skicka sina meddelanden till hanteraren \"console\". Dessa "
"objekt är inte begränsade till dem som tillhandahålls av modulen :mod:"
"`logging` eftersom du kan skriva din egen formaterare eller hanterarklass. "
"Parametrarna till dessa klasser kan också behöva inkludera externa objekt "
"som ``sys.stderr``.  Syntaxen för att beskriva dessa objekt och anslutningar "
"definieras i :ref:`logging-config-dict-connections` nedan."

msgid "Dictionary Schema Details"
msgstr "Dictionary Schema Detaljer"

msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr ""
"Den ordbok som skickas till :func:`dictConfig` måste innehålla följande "
"nycklar:"

msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr ""
"*version* - ska sättas till ett heltalsvärde som representerar "
"schemaversionen.  Det enda giltiga värdet för närvarande är 1, men genom att "
"ha denna nyckel kan schemat utvecklas samtidigt som bakåtkompatibiliteten "
"bevaras."

msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref:"
"`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"Alla andra nycklar är valfria, men om de finns med tolkas de enligt "
"beskrivningen nedan.  I alla fall nedan där en \"configuring dict\" nämns, "
"kommer den att kontrolleras för den speciella nyckeln ``'()'`` för att se om "
"en anpassad instansiering krävs.  Om så är fallet används den mekanism som "
"beskrivs i :ref:`logging-config-dict-userdef` nedan för att skapa en "
"instans; annars används sammanhanget för att avgöra vad som ska instansieras."

msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a "
"formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* - motsvarande värde kommer att vara en dict där varje nyckel är "
"ett formatter-id och varje värde är en dict som beskriver hur man "
"konfigurerar motsvarande :class:`~logging.Formatter`-instans."

msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a :class:`~logging.Formatter` "
"object:"
msgstr ""
"Konfigurationsdikten genomsöks efter följande valfria nycklar som motsvarar "
"de argument som skickas för att skapa ett :class:`~logging.Formatter`-objekt:"

msgid "``format``"
msgstr "``format``"

msgid "``datefmt``"
msgstr "``datefmt``"

msgid "``style``"
msgstr "``style``"

msgid "``validate`` (since version >=3.8)"
msgstr "``validate`` (sedan version >=3.8)"

msgid "``defaults`` (since version >=3.12)"
msgstr "``defaults`` (sedan version >=3.12)"

msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as a "
"dotted module and class name).  The instantiation arguments are as for :"
"class:`~logging.Formatter`, thus this key is most useful for instantiating a "
"customised subclass of :class:`~logging.Formatter`.  For example, the "
"alternative class might present exception tracebacks in an expanded or "
"condensed format.  If your formatter requires different or extra "
"configuration keys, you should use :ref:`logging-config-dict-userdef`."
msgstr ""
"En valfri ``class``-nyckel anger namnet på formaterarens klass (som en "
"prickad modul och klassnamn).  Instantieringsargumenten är desamma som för :"
"class:`~logging.Formatter`, så den här nyckeln är mest användbar för "
"instansiering av en anpassad underklass till :class:`~logging.Formatter`.  "
"Den alternativa klassen kan t.ex. presentera spårningar av undantag i ett "
"utökat eller förkortat format.  Om din formatterare kräver andra eller extra "
"konfigurationsnycklar bör du använda :ref:`logging-config-dict-userdef`."

msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr ""
"*filters* - motsvarande värde kommer att vara en dikt där varje nyckel är "
"ett filter-ID och varje värde är en dikt som beskriver hur man konfigurerar "
"motsvarande filterinstans."

msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr ""
"Konfigurationsdikten genomsöks efter nyckeln ``name`` (standard är den tomma "
"strängen) och denna används för att konstruera en :class:`logging.Filter`-"
"instans."

msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*handlers* - motsvarande värde kommer att vara ett dict där varje nyckel är "
"ett handläggar-ID och varje värde är ett dict som beskriver hur man "
"konfigurerar motsvarande handläggarinstans."

msgid "The configuring dict is searched for the following keys:"
msgstr "Konfigurationsdikten genomsöks efter följande nycklar:"

msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr ""
"``class`` (obligatorisk).  Detta är det fullständigt kvalificerade namnet på "
"hanterarklassen."

msgid "``level`` (optional).  The level of the handler."
msgstr "``level`` (valfritt).  Behandlarens nivå."

msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr "``formatter`` (valfritt).  ID för formateraren för den här hanteraren."

msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr ""
"``filters`` (valfritt).  En lista med id:n för filtren för den här "
"hanteraren."

msgid "``filters`` can take filter instances in addition to ids."
msgstr "``filters`` kan ta filterinstanser i tillägg till id:n."

msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr ""
"Alla *andra* nycklar skickas som nyckelordsargument till hanterarens "
"konstruktör.  Till exempel, med tanke på utdraget:"

msgid ""
"handlers:\n"
"  console:\n"
"    class : logging.StreamHandler\n"
"    formatter: brief\n"
"    level   : INFO\n"
"    filters: [allow_foo]\n"
"    stream  : ext://sys.stdout\n"
"  file:\n"
"    class : logging.handlers.RotatingFileHandler\n"
"    formatter: precise\n"
"    filename: logconfig.log\n"
"    maxBytes: 1024\n"
"    backupCount: 3"
msgstr ""
"handläggare:\n"
"  konsol:\n"
"    klass : loggning.StreamHandler\n"
"    formaterare: kort\n"
"    nivå: INFO\n"
"    filter: [allow_foo]\n"
"    ström : ext://sys.stdout\n"
"  fil : stdout\n"
"    klass : logging.handlers.RotatingFileHandler\n"
"    formaterare: exakt\n"
"    filnamn: logconfig.log\n"
"    maxBytes: 1024\n"
"    backupCount: 3"

msgid ""
"the handler with id ``console`` is instantiated as a :class:`logging."
"StreamHandler`, using ``sys.stdout`` as the underlying stream.  The handler "
"with id ``file`` is instantiated as a :class:`logging.handlers."
"RotatingFileHandler` with the keyword arguments ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."
msgstr ""
"hanteraren med id ``console`` instansieras som en :class:`logging."
"StreamHandler`, med ``sys.stdout`` som underliggande ström.  Hanteraren med "
"id ``file`` instansieras som en :class:`logging.handlers."
"RotatingFileHandler`` med nyckelordsargumenten ``filnamn='logconfig.log', "
"maxBytes=1024, backupCount=3``."

msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr ""
"*loggers* - motsvarande värde kommer att vara ett dict där varje nyckel är "
"ett loggernamn och varje värde är ett dict som beskriver hur man "
"konfigurerar motsvarande Logger-instans."

msgid "``level`` (optional).  The level of the logger."
msgstr "``level`` (valfritt).  Loggarens nivå."

msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr "``propagate`` (valfritt).  Loggerns inställning för spridning."

msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr ""
"``filters`` (valfritt).  En lista med id:n för filtren för den här loggern."

msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr ""
"``handlers`` (valfritt).  En lista med id:n för handläggarna för denna "
"logger."

msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr ""
"De angivna loggarna kommer att konfigureras enligt den nivå, spridning, de "
"filter och de hanterare som anges."

msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr ""
"*root* - detta är konfigurationen för rotloggaren. Konfigurationen bearbetas "
"på samma sätt som för alla loggar, förutom att inställningen ``propagate`` "
"inte är tillämplig."

msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing :func:"
"`fileConfig` API."
msgstr ""
"*incremental* - om konfigurationen ska tolkas som inkrementell till den "
"befintliga konfigurationen.  Standardvärdet är ``False``, vilket innebär att "
"den angivna konfigurationen ersätter den befintliga konfigurationen med "
"samma semantik som används av det befintliga API:et :func:`fileConfig`."

msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"Om det angivna värdet är ``True`` bearbetas konfigurationen enligt "
"beskrivningen i avsnittet om :ref:`logging-config-dict-incremental`."

msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be "
"disabled. This setting mirrors the parameter of the same name in :func:"
"`fileConfig`. If absent, this parameter defaults to ``True``. This value is "
"ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* - om alla befintliga loggar som inte är rotloggar "
"ska inaktiveras. Denna inställning speglar parametern med samma namn i :func:"
"`fileConfig`. Om parametern saknas är standardvärdet ``True``. Detta värde "
"ignoreras om *incremental* är ``True``."

msgid "Incremental Configuration"
msgstr "Inkrementell konfiguration"

msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr ""
"Det är svårt att ge fullständig flexibilitet för inkrementell "
"konfiguration.  Eftersom objekt som filter och formatterare är anonyma är "
"det till exempel inte möjligt att hänvisa till sådana anonyma objekt när en "
"konfiguration har konfigurerats."

msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"Det finns inte heller några övertygande skäl för att godtyckligt ändra "
"objektgrafen för loggrar, hanterare, filter och formaterare under körning, "
"när en konfiguration väl har skapats; ordrikedomen hos loggrar och hanterare "
"kan styras genom att bara ange nivåer (och, när det gäller loggrar, "
"spridningsflaggor).  Att ändra objektgrafen godtyckligt på ett säkert sätt "
"är problematiskt i en flertrådad miljö; även om det inte är omöjligt är "
"fördelarna inte värda den komplexitet som det tillför implementeringen."

msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is "
"``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"När nyckeln ``incremental`` i en konfigurationsdikt är närvarande och är "
"``True``, kommer systemet att helt ignorera alla ``formatters`` och "
"``filters`` poster och endast bearbeta ``level`` inställningarna i "
"``handlers`` posterna, och ``level`` och ``propagate`` inställningarna i "
"``loggers`` och ``root`` posterna."

msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"Genom att använda ett värde i konfigurationsdictet kan konfigurationer "
"skickas över kabeln som pickled dicts till en socketlyssnare. På så sätt kan "
"loggningsstyrkan i en applikation som körs under lång tid ändras över tid "
"utan att applikationen behöver stoppas och startas om."

msgid "Object connections"
msgstr "Objektanslutningar"

msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph.  "
"Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a "
"particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"Schemat beskriver en uppsättning loggningsobjekt - loggers, handlers, "
"formatters, filters - som är kopplade till varandra i en objektgraf.  "
"Schemat måste alltså representera kopplingar mellan objekten.  Låt oss till "
"exempel säga att en viss logger har en viss hanterare kopplad till sig när "
"den väl har konfigurerats.  I den här diskussionen kan vi säga att loggern "
"representerar källan och hanteraren destinationen för en koppling mellan de "
"två.  I de konfigurerade objekten representeras detta naturligtvis av att "
"loggern har en referens till hanteraren.  I konfigurationsdikten görs detta "
"genom att ge varje destinationsobjekt ett id som identifierar det på ett "
"otvetydigt sätt och sedan använda id:t i källobjektets konfiguration för att "
"ange att det finns en koppling mellan källan och destinationsobjektet med "
"det id:t."

msgid "So, for example, consider the following YAML snippet:"
msgstr "Tänk till exempel på följande YAML-utdrag:"

msgid ""
"formatters:\n"
"  brief:\n"
"    # configuration for formatter with id 'brief' goes here\n"
"  precise:\n"
"    # configuration for formatter with id 'precise' goes here\n"
"handlers:\n"
"  h1: #This is an id\n"
"   # configuration of handler with id 'h1' goes here\n"
"   formatter: brief\n"
"  h2: #This is another id\n"
"   # configuration of handler with id 'h2' goes here\n"
"   formatter: precise\n"
"loggers:\n"
"  foo.bar.baz:\n"
"    # other configuration for logger 'foo.bar.baz'\n"
"    handlers: [h1, h2]"
msgstr ""
"formatterare:\n"
"  kort:\n"
"    # konfigurationen för formatterare med id 'brief' hamnar här\n"
"  exakt:\n"
"    # konfiguration för formatterare med id 'precise' går här\n"
"hanterare:\n"
"  h1: #Detta är ett id\n"
"   # konfiguration av hanterare med id 'h1' går här\n"
"   formatterare: kort\n"
"  h2: #Detta är ett annat id\n"
"   # konfiguration av hanterare med id 'h2' går här\n"
"   formattering: exakt\n"
"loggers:\n"
"  foo.bar.baz:\n"
"    # annan konfiguration för logger 'foo.bar.baz'\n"
"    handläggare: [h1, h2]"

msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr ""
"(Observera: YAML används här eftersom det är lite mer läsbart än motsvarande "
"Python-källform för ordlistan)"

msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. ``foo.bar."
"baz``.  The ids for Formatters and Filters can be any string value (such as "
"``brief``, ``precise`` above) and they are transient, in that they are only "
"meaningful for processing the configuration dictionary and used to determine "
"connections between objects, and are not persisted anywhere when the "
"configuration call is complete."
msgstr ""
"Ids för loggers är de loggernamn som skulle användas programmatiskt för att "
"få en referens till dessa loggers, t.ex. ``foo.bar.baz``.  ID:n för "
"Formatters och Filters kan vara vilket strängvärde som helst (t.ex. "
"``brief``, ``precise`` ovan) och de är transienta, dvs. de är endast "
"meningsfulla för bearbetning av konfigurationsordlistan och används för att "
"fastställa kopplingar mellan objekt, och sparas inte någonstans när "
"konfigurationsanropet är klart."

msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"Ovanstående utdrag visar att loggern med namnet ``foo.bar.baz`` ska ha två "
"hanterare kopplade till sig, vilka beskrivs av hanterar-ID ``h1`` och "
"``h2``. Formateringen för ``h1`` är den som beskrivs av id ``brief``, och "
"formateringen för ``h2`` är den som beskrivs av id ``precise``."

msgid "User-defined objects"
msgstr "Användardefinierade objekt"

msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"Schemat stöder användardefinierade objekt för hanterare, filter och "
"formaterare.  (Loggrar behöver inte ha olika typer för olika instanser, så "
"det finns inget stöd i detta konfigurationsschema för användardefinierade "
"loggerklasser)"

msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"Objekt som ska konfigureras beskrivs av ordböcker som beskriver deras "
"konfiguration.  På vissa ställen kan loggningssystemet dra slutsatser från "
"sammanhanget om hur ett objekt ska instansieras, men när ett "
"användardefinierat objekt ska instansieras vet systemet inte hur det ska "
"göras.  För att ge fullständig flexibilitet för instansiering av "
"användardefinierade objekt måste användaren tillhandahålla en \"fabrik\" - "
"en anropsbar funktion som anropas med en konfigurationsordbok och som "
"returnerar det instansierade objektet. Detta signaleras genom att en absolut "
"importsökväg till fabriken görs tillgänglig under den speciella nyckeln "
"``'()'``.  Här är ett konkret exempel:"

msgid ""
"formatters:\n"
"  brief:\n"
"    format: '%(message)s'\n"
"  default:\n"
"    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'\n"
"    datefmt: '%Y-%m-%d %H:%M:%S'\n"
"  custom:\n"
"      (): my.package.customFormatterFactory\n"
"      bar: baz\n"
"      spam: 99.9\n"
"      answer: 42"
msgstr ""
"formatterare:\n"
"  kort:\n"
"    format: '%(message)s'\n"
"  standard:\n"
"    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'\n"
"    datefmt: '%Y-%m-%d %H:%M:%S'\n"
"  custom:\n"
"      (): my.package.customFormatterFactory\n"
"      bar: baz\n"
"      spam: 99.9\n"
"      svar: 42"

msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a :"
"class:`logging.Formatter` initialized with those two format strings.  Shown "
"in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"YAML-utdraget ovan definierar tre formaterare.  Den första, med id "
"``brief``, är en standard :class:`logging.Formatter`-instans med den angivna "
"formatsträngen.  Den andra, med id ``default``, har ett längre format och "
"definierar även tidsformatet explicit, och kommer att resultera i en :class:"
"`logging.Formatter` som initieras med dessa två formatsträngar.  Visas i "
"Python-källform, ``brief`` och ``default`` formatterarna har "
"konfigurationsunderordnade ordböcker::"

msgid ""
"{\n"
"  'format' : '%(message)s'\n"
"}"
msgstr ""
"{\n"
"  'format' : '%(message)s'\n"
"}"

msgid "and::"
msgstr "och::"

msgid ""
"{\n"
"  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',\n"
"  'datefmt' : '%Y-%m-%d %H:%M:%S'\n"
"}"
msgstr ""
"{\n"
"  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',\n"
"  'datefmt' : '%Y-%m-%d %H:%M:%S'\n"
"}"

msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"respektive, och eftersom dessa ordböcker inte innehåller specialnyckeln "
"``'()'``, härleds instansen från sammanhanget: som ett resultat skapas "
"standard :class:`logging.Formatter`-instanser.  Konfigurationsunderordlistan "
"för den tredje formatteraren, med id ``custom``, är::"

msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42\n"
"}"
msgstr ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'svar' : 42\n"
"}"

msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the "
"**remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"och denna innehåller specialnyckeln ``'()'``, vilket innebär att en "
"användardefinierad instansiering önskas.  I detta fall kommer den angivna "
"fabriksinställningen att användas. Om det är en faktisk callable kommer den "
"att användas direkt - i annat fall, om du anger en sträng (som i exemplet) "
"kommer den faktiska callable att lokaliseras med hjälp av normala "
"importmekanismer. Den anropbara funktionen anropas med de **återstående** "
"objekten i konfigurationsunderordlistan som nyckelordsargument.  I exemplet "
"ovan kommer formatteraren med id ``custom`` att antas returneras av anropet::"

msgid "my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)"
msgstr "my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)"

msgid ""
"The values for keys such as ``bar``, ``spam`` and ``answer`` in the above "
"example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the "
"configuration machinery, but passed to the callable as-is."
msgstr ""
"Värdena för nycklar som ``bar``, ``spam`` och ``answer`` i exemplet ovan bör "
"inte vara konfigurationsordböcker eller referenser som ``cfg://foo`` eller "
"``ext://bar``, eftersom de inte kommer att bearbetas av "
"konfigurationsmaskineriet, utan skickas till den anropsbara som de är."

msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the "
"corresponding value is a callable."
msgstr ""
"Nyckeln ``'()'`` har använts som specialnyckel eftersom den inte är ett "
"giltigt nyckelordsparameternamn och därför inte krockar med namnen på de "
"nyckelordsargument som används i anropet.  ``'()'`` fungerar också som en "
"mnemonik för att motsvarande värde är en callable."

msgid ""
"The ``filters`` member of ``handlers`` and ``loggers`` can take filter "
"instances in addition to ids."
msgstr ""
"Medlemmen ``filters`` i ``handlers`` och ``loggers`` kan ta filterinstanser "
"utöver id:n."

msgid ""
"You can also specify a special key ``'.'`` whose value is a mapping of "
"attribute names to values. If found, the specified attributes will be set on "
"the user-defined object before it is returned. Thus, with the following "
"configuration::"
msgstr ""
"Du kan också ange en specialnyckel ``'.'`` vars värde är en mappning av "
"attributnamn till värden. Om den hittas kommer de angivna attributen att "
"ställas in på det användardefinierade objektet innan det returneras. "
"Således, med följande konfiguration::"

msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42,\n"
"  '.' {\n"
"    'foo': 'bar',\n"
"    'baz': 'bozz'\n"
"  }\n"
"}"
msgstr ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42,\n"
"  '.' {\n"
"    'foo': 'bar',\n"
"    'baz': 'bozz'\n"
"  }\n"
"}"

msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr ""
"kommer den returnerade formateraren att ha attributet ``foo`` satt till "
"``'bar'`` och attributet ``baz`` satt till ``'bozz'``."

msgid ""
"The values for attributes such as ``foo`` and ``baz`` in the above example "
"should not be configuration dictionaries or references such as ``cfg://foo`` "
"or ``ext://bar``, because they will not be processed by the configuration "
"machinery, but set as attribute values as-is."
msgstr ""
"Värdena för attribut som ``foo`` och ``baz`` i exemplet ovan bör inte vara "
"konfigurationsordböcker eller referenser som ``cfg://foo`` eller ``ext://"
"bar``, eftersom de inte kommer att bearbetas av konfigurationsmaskineriet, "
"utan anges som attributvärden som de är."

msgid "Handler configuration order"
msgstr "Konfigurationsordning för handläggare"

msgid ""
"Handlers are configured in alphabetical order of their keys, and a "
"configured handler replaces the configuration dictionary in (a working copy "
"of) the ``handlers`` dictionary in the schema. If you use a construct such "
"as ``cfg://handlers.foo``, then initially ``handlers['foo']`` points to the "
"configuration dictionary for the handler named ``foo``, and later (once that "
"handler has been configured) it points to the configured handler instance. "
"Thus, ``cfg://handlers.foo`` could resolve to either a dictionary or a "
"handler instance. In general, it is wise to name handlers in a way such that "
"dependent handlers are configured *after* any handlers they depend on; that "
"allows something like ``cfg://handlers.foo`` to be used in configuring a "
"handler that depends on handler ``foo``. If that dependent handler were "
"named ``bar``, problems would result, because the configuration of ``bar`` "
"would be attempted before that of ``foo``, and ``foo`` would not yet have "
"been configured. However, if the dependent handler were named ``foobar``, it "
"would be configured after ``foo``, with the result that ``cfg://handlers."
"foo`` would resolve to configured handler ``foo``, and not its configuration "
"dictionary."
msgstr ""
"Hanterare konfigureras i alfabetisk ordning efter sina nycklar, och en "
"konfigurerad hanterare ersätter konfigurationsordlistan i (en arbetskopia "
"av) ordlistan ``handlers`` i schemat. Om du använder en konstruktion som "
"``cfg://handlers.foo``, pekar ``handlers['foo']`` först på "
"konfigurationsordlistan för hanteraren med namnet ``foo``, och senare (när "
"den hanteraren har konfigurerats) pekar den på den konfigurerade "
"hanterarinstansen. Således kan ``cfg://handlers.foo`` peka på antingen en "
"ordbok eller en hanterarinstans. I allmänhet är det klokt att namnge "
"hanterare på ett sådant sätt att beroende hanterare konfigureras *efter* "
"alla hanterare som de är beroende av. Det gör att något som ``cfg://handlers."
"foo`` kan användas för att konfigurera en hanterare som är beroende av "
"hanteraren ``foo``. Om den beroende hanteraren hette ``bar`` skulle det "
"uppstå problem, eftersom konfigurationen av ``bar`` skulle försöka göras "
"före konfigurationen av ``foo``, och ``foo`` skulle ännu inte ha "
"konfigurerats. Om den beroende hanteraren däremot hette ``foobar`` skulle "
"den konfigureras efter ``foo``, vilket skulle leda till att ``cfg://handlers."
"foo`` skulle lösa upp till den konfigurerade hanteraren ``foo``, och inte "
"till dess konfigurationsordbok."

msgid "Access to external objects"
msgstr "Tillgång till externa objekt"

msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is "
"constructed using Python code, this is straightforward, but a problem arises "
"when the configuration is provided via a text file (e.g. JSON, YAML).  In a "
"text file, there is no standard way to distinguish ``sys.stderr`` from the "
"literal string ``'sys.stderr'``.  To facilitate this distinction, the "
"configuration system looks for certain special prefixes in string values and "
"treat them specially.  For example, if the literal string ``'ext://sys."
"stderr'`` is provided as a value in the configuration, then the ``ext://`` "
"will be stripped off and the remainder of the value processed using normal "
"import mechanisms."
msgstr ""
"Det finns tillfällen då en konfiguration behöver hänvisa till objekt utanför "
"konfigurationen, till exempel ``sys.stderr``.  Om konfigurationsdikten är "
"konstruerad med Python-kod är detta enkelt, men ett problem uppstår när "
"konfigurationen tillhandahålls via en textfil (t.ex. JSON, YAML).  I en "
"textfil finns det inget standardiserat sätt att skilja ``sys.stderr`` från "
"den bokstavliga strängen ``'sys.stderr``.  För att underlätta denna "
"distinktion letar konfigurationssystemet efter vissa speciella prefix i "
"strängvärden och behandlar dem på ett speciellt sätt.  Om till exempel den "
"bokstavliga strängen ``'ext://sys.stderr'`` anges som ett värde i "
"konfigurationen, kommer ``ext://`` att tas bort och resten av värdet "
"behandlas med normala importmekanismer."

msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the "
"``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent "
"manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"Hanteringen av sådana prefix sker på ett sätt som är analogt med "
"protokollhantering: det finns en generisk mekanism för att leta efter prefix "
"som matchar det reguljära uttrycket ``^(?P<prefix>[a-z]+)://(?P<suffix>."
"*)$`` varvid, om ``prefixet`` känns igen, ``uffixet`` bearbetas på ett "
"prefixberoende sätt och resultatet av bearbetningen ersätter strängvärdet.  "
"Om prefixet inte känns igen kommer strängvärdet att lämnas som det är."

msgid "Access to internal objects"
msgstr "Tillgång till interna objekt"

msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"Förutom externa objekt finns det ibland också behov av att hänvisa till "
"objekt i konfigurationen.  Detta görs implicit av konfigurationssystemet för "
"saker som det känner till.  Till exempel konverteras strängvärdet ``'DEBUG`` "
"för en ``nivå`` i en logger eller hanterare automatiskt till värdet "
"``logging.DEBUG``, och posterna ``handlers``, ``filters`` och ``formatter`` "
"tar ett objekt-ID och löser upp till lämpligt destinationsobjekt."

msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider :class:"
"`logging.handlers.MemoryHandler`, which takes a ``target`` argument which is "
"another handler to delegate to. Since the system already knows about this "
"class, then in the configuration, the given ``target`` just needs to be the "
"object id of the relevant target handler, and the system will resolve to the "
"handler from the id.  If, however, a user defines a ``my.package.MyHandler`` "
"which has an ``alternate`` handler, the configuration system would not know "
"that the ``alternate`` referred to a handler.  To cater for this, a generic "
"resolution system allows the user to specify:"
msgstr ""
"Det behövs dock en mer generisk mekanism för användardefinierade objekt som "
"inte är kända av modulen :mod:`logging`.  Tänk till exempel på :class:"
"`logging.handlers.MemoryHandler`, som tar ett ``target``-argument som är en "
"annan hanterare att delegera till. Eftersom systemet redan känner till den "
"här klassen behöver det angivna ``target`` i konfigurationen bara vara "
"objekt-id för den relevanta målhanteraren, och systemet kommer att lösa upp "
"till hanteraren från id.  Om en användare däremot definierar en ``my.package."
"MyHandler`` som har en ``alternativ`` hanterare, skulle "
"konfigurationssystemet inte veta att ``alternativ`` refererar till en "
"hanterare.  För att tillgodose detta tillåter ett generiskt "
"upplösningssystem användaren att ange:"

msgid ""
"handlers:\n"
"  file:\n"
"    # configuration of file handler goes here\n"
"\n"
"  custom:\n"
"    (): my.package.MyHandler\n"
"    alternate: cfg://handlers.file"
msgstr ""
"handlers:\n"
"  file:\n"
"    # configuration of file handler goes here\n"
"\n"
"  custom:\n"
"    (): my.package.MyHandler\n"
"    alternate: cfg://handlers.file"

msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows "
"access by dot or by index, in a similar way to that provided by ``str."
"format``.  Thus, given the following snippet:"
msgstr ""
"Den bokstavliga strängen ``'cfg://handlers.file'`` kommer att lösas på ett "
"analogt sätt som strängar med prefixet ``ext://``, men letar i själva "
"konfigurationen snarare än i importnamnrymden.  Mekanismen tillåter åtkomst "
"via punkt eller index, på ett liknande sätt som det som tillhandahålls av "
"``str.format``.  Således, givet följande utdrag:"

msgid ""
"handlers:\n"
"  email:\n"
"    class: logging.handlers.SMTPHandler\n"
"    mailhost: localhost\n"
"    fromaddr: my_app@domain.tld\n"
"    toaddrs:\n"
"      - support_team@domain.tld\n"
"      - dev_team@domain.tld\n"
"    subject: Houston, we have a problem."
msgstr ""
"handlers:\n"
"  email:\n"
"    class: logging.handlers.SMTPHandler\n"
"    mailhost: localhost\n"
"    fromaddr: my_app@domain.tld\n"
"    toaddrs:\n"
"      - support_team@domain.tld\n"
"      - dev_team@domain.tld\n"
"    subject: Houston, we have a problem."

msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on.  "
"The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to "
"``'dev_team@domain.tld'`` and the string ``'cfg://handlers.email."
"toaddrs[0]'`` would resolve to the value ``'support_team@domain.tld'``. The "
"``subject`` value could be accessed using either ``'cfg://handlers.email."
"subject'`` or, equivalently, ``'cfg://handlers.email[subject]'``.  The "
"latter form only needs to be used if the key contains spaces or non-"
"alphanumeric characters. Please note that the characters ``[`` and ``]`` are "
"not allowed in the keys. If an index value consists only of decimal digits, "
"access will be attempted using the corresponding integer value, falling back "
"to the string value if needed."
msgstr ""
"i konfigurationen, skulle strängen ``'cfg://handlers`` lösas upp mot "
"diktatet med nyckeln ``handlers``, strängen ``'cfg://handlers.email`` skulle "
"lösas upp mot diktatet med nyckeln ``email`` i diktatet ``handlers``, och så "
"vidare.  Strängen ``'cfg://handlers.email.toaddrs[1]`` skulle upplösas till "
"``'dev_team@domain.tld'`` och strängen ``'cfg://handlers.email.toaddrs[0]'`` "
"skulle upplösas till värdet ``'support_team@domain.tld'``. Värdet "
"``subject`` kan nås med antingen ``'cfg://handlers.email.subject'`` eller, "
"på motsvarande sätt, ``'cfg://handlers.email[subject]'``.  Den senare formen "
"behöver endast användas om nyckeln innehåller mellanslag eller icke-"
"alfanumeriska tecken. Observera att tecknen ``[`` och ``]`` inte är tillåtna "
"i nycklarna. Om ett indexvärde endast består av decimala siffror kommer "
"åtkomstförsök att göras med hjälp av motsvarande heltalsvärde, med återgång "
"till strängvärdet vid behov."

msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, and fall back to ``config_dict['handlers']['myhandler']"
"['mykey']['123']`` if that fails."
msgstr ""
"Med en sträng ``cfg://handlers.myhandler.mykey.123`` kommer detta att lösas "
"upp till ``config_dict['handlers']['myhandler']['mykey']['123']``. Om "
"strängen anges som ``cfg://handlers.myhandler.mykey[123]`` kommer systemet "
"att försöka hämta värdet från ``config_dict['handlers']['myhandler']['mykey']"
"[123]``, och återgå till ``config_dict['handlers']['myhandler']['mykey']"
"['123']`` om det misslyckas."

msgid "Import resolution and custom importers"
msgstr "Importupplösning och anpassade importörer"

msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the :"
"class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to "
"do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"Importresolution använder som standard den inbyggda funktionen :func:"
"`__import__` för att göra sin import. Du kanske vill ersätta detta med din "
"egen importmekanism: i så fall kan du ersätta attributet :attr:`importer` i :"
"class:`DictConfigurator` eller dess superklass, :class:`BaseConfigurator`. "
"Du måste dock vara försiktig på grund av hur funktioner nås från klasser via "
"deskriptorer. Om du använder en Python callable för att göra din import, och "
"du vill definiera den på klassnivå snarare än instansnivå, måste du linda in "
"den med :func:`staticmethod`. Till exempel::"

msgid ""
"from importlib import import_module\n"
"from logging.config import BaseConfigurator\n"
"\n"
"BaseConfigurator.importer = staticmethod(import_module)"
msgstr ""
"from importlib import import_module\n"
"from logging.config import BaseConfigurator\n"
"\n"
"BaseConfigurator.importer = staticmethod(import_module)"

msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr ""
"Du behöver inte omsluta med :func:`staticmethod` om du ställer in "
"importkallelsen på en konfigurator *instans*."

msgid "Configuring QueueHandler and QueueListener"
msgstr "Konfigurera QueueHandler och QueueListener"

msgid ""
"If you want to configure a :class:`~logging.handlers.QueueHandler`, noting "
"that this is normally used in conjunction with a :class:`~logging.handlers."
"QueueListener`, you can configure both together. After the configuration, "
"the ``QueueListener`` instance will be available as the :attr:`~logging."
"handlers.QueueHandler.listener` attribute of the created handler, and that "
"in turn will be available to you using :func:`~logging.getHandlerByName` and "
"passing the name you have used for the ``QueueHandler`` in your "
"configuration. The dictionary schema for configuring the pair is shown in "
"the example YAML snippet below."
msgstr ""
"Om du vill konfigurera en :class:`~logging.handlers.QueueHandler`, och "
"observera att denna normalt används tillsammans med en :class:`~logging."
"handlers.QueueListener`, kan du konfigurera båda tillsammans. Efter "
"konfigurationen kommer ``QueueListener``-instansen att vara tillgänglig som "
"attributet :attr:`~logging.handlers.QueueHandler.listener`` för den skapade "
"hanteraren, och den kommer i sin tur att vara tillgänglig för dig genom att "
"använda :func:`~logging.getHandlerByName` och skicka det namn du har använt "
"för ``QueueHandler`` i din konfiguration. Ordboksschemat för konfigurering "
"av paret visas i YAML-exemplet nedan."

msgid ""
"handlers:\n"
"  qhand:\n"
"    class: logging.handlers.QueueHandler\n"
"    queue: my.module.queue_factory\n"
"    listener: my.package.CustomListener\n"
"    handlers:\n"
"      - hand_name_1\n"
"      - hand_name_2\n"
"      ..."
msgstr ""
"handlers:\n"
"  qhand:\n"
"    class: logging.handlers.QueueHandler\n"
"    queue: my.module.queue_factory\n"
"    listener: my.package.CustomListener\n"
"    handlers:\n"
"      - hand_name_1\n"
"      - hand_name_2\n"
"      ..."

msgid "The ``queue`` and ``listener`` keys are optional."
msgstr "Nycklarna ``queue`` och ``listener`` är valfria."

msgid ""
"If the ``queue`` key is present, the corresponding value can be one of the "
"following:"
msgstr ""
"Om nyckeln ``queue`` finns, kan motsvarande värde vara något av följande:"

msgid ""
"An object implementing the :meth:`Queue.put_nowait <queue.Queue.put_nowait>` "
"and :meth:`Queue.get <queue.Queue.get>` public API. For instance, this may "
"be an actual instance of :class:`queue.Queue` or a subclass thereof, or a "
"proxy obtained by :meth:`multiprocessing.managers.SyncManager.Queue`."
msgstr ""
"Ett objekt som implementerar de publika API:erna :meth:`Queue.put_nowait "
"<queue.Queue.put_nowait>` och :meth:`Queue.get <queue.Queue.get>`. Det kan t."
"ex. vara en faktisk instans av :class:`queue.Queue` eller en underklass av "
"denna, eller en proxy som erhålls av :meth:`multiprocessing.managers."
"SyncManager.Queue`."

msgid ""
"This is of course only possible if you are constructing or modifying the "
"configuration dictionary in code."
msgstr ""
"Detta är naturligtvis bara möjligt om du konstruerar eller ändrar "
"konfigurationsordlistan i kod."

msgid ""
"A string that resolves to a callable which, when called with no arguments, "
"returns the queue instance to use. That callable could be a :class:`queue."
"Queue` subclass or a function which returns a suitable queue instance, such "
"as ``my.module.queue_factory()``."
msgstr ""
"En sträng som löser upp till en anropsbar som, när den anropas utan "
"argument, returnerar den köinstans som ska användas. Denna anropsbarhet kan "
"vara en :class:`queue.Queue`-underklass eller en funktion som returnerar en "
"lämplig köinstans, till exempel ``my.module.queue_factory()``."

msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a :class:`queue.Queue` instance."
msgstr ""
"En dict med en ``'()'`` nyckel som är konstruerad på vanligt sätt som "
"beskrivs i :ref:`logging-config-dict-userdef`. Resultatet av denna "
"konstruktion bör vara en instans av :class:`queue.Queue`."

msgid ""
"If the  ``queue`` key is absent, a standard unbounded :class:`queue.Queue` "
"instance is created and used."
msgstr ""
"Om nyckeln ``queue`` saknas skapas och används en standardiserad obegränsad :"
"class:`queue.Queue`-instans."

msgid ""
"If the ``listener`` key is present, the corresponding value can be one of "
"the following:"
msgstr ""
"Om nyckeln ``listener`` finns, kan motsvarande värde vara något av följande:"

msgid ""
"A subclass of :class:`logging.handlers.QueueListener`. This is of course "
"only possible if you are constructing or modifying the configuration "
"dictionary in code."
msgstr ""
"En underklass till :class:`logging.handlers.QueueListener`. Detta är "
"naturligtvis bara möjligt om du konstruerar eller ändrar "
"konfigurationsordlistan i kod."

msgid ""
"A string which resolves to a class which is a subclass of ``QueueListener``, "
"such as ``'my.package.CustomListener'``."
msgstr ""
"En sträng som motsvarar en klass som är en underklass till "
"``QueueListener``, t.ex. ``'my.package.CustomListener'``."

msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a callable with the same signature as the "
"``QueueListener`` initializer."
msgstr ""
"En dict med en ``'()'`` nyckel som är konstruerad på det vanliga sättet som "
"diskuteras i :ref:`logging-config-dict-userdef`. Resultatet av denna "
"konstruktion bör vara en callable med samma signatur som initialiseraren för "
"``QueueListener``."

msgid ""
"If the ``listener`` key is absent, :class:`logging.handlers.QueueListener` "
"is used."
msgstr ""
"Om nyckeln ``listener`` saknas används :class:`logging.handlers."
"QueueListener`."

msgid ""
"The values under the ``handlers`` key are the names of other handlers in the "
"configuration (not shown in the above snippet) which will be passed to the "
"queue listener."
msgstr ""
"Värdena under nyckeln ``handlers`` är namnen på andra handlers i "
"konfigurationen (visas inte i utdraget ovan) som kommer att skickas till "
"kölyssnaren."

msgid ""
"Any custom queue handler and listener classes will need to be defined with "
"the same initialization signatures as :class:`~logging.handlers."
"QueueHandler` and :class:`~logging.handlers.QueueListener`."
msgstr ""
"Alla anpassade köhanterings- och lyssnarklasser måste definieras med samma "
"initialiseringssignaturer som :class:`~logging.handlers.QueueHandler` och :"
"class:`~logging.handlers.QueueListener`."

msgid "Configuration file format"
msgstr "Format för konfigurationsfil"

msgid ""
"The configuration file format understood by :func:`fileConfig` is based on :"
"mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
"Konfigurationsfilens format som förstås av :func:`fileConfig` är baserat på :"
"mod:`configparser` funktionalitet. Filen måste innehålla avsnitt kallade "
"``[loggers]``, ``[handlers]`` och ``[formatters]`` som identifierar de "
"entiteter av varje typ som definieras i filen. För varje sådan entitet finns "
"ett separat avsnitt som anger hur den entiteten konfigureras.  För en logger "
"med namnet ``log01`` i avsnittet ``[loggers]`` finns alltså relevanta "
"konfigurationsdetaljer i avsnittet ``[logger_log01]``. På samma sätt kommer "
"en hanterare som heter ``hand01`` i avsnittet ``[handlers]`` att ha sin "
"konfiguration i ett avsnitt som heter ``[handler_hand01]``, medan en "
"formaterare som heter ``form01`` i avsnittet ``[formaterare]`` kommer att ha "
"sin konfiguration angiven i ett avsnitt som heter ``[formaterare_form01]``. "
"Konfigurationen för rotloggaren måste anges i ett avsnitt som heter "
"``[logger_root]``."

msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does "
"not provide functionality to cover certain aspects of logging. For example, "
"you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using :func:"
"`fileConfig`. If you need to have instances of :class:`~logging.Filter` in "
"your logging configuration, you will need to use :func:`dictConfig`. Note "
"that future enhancements to configuration functionality will be added to :"
"func:`dictConfig`, so it's worth considering transitioning to this newer API "
"when it's convenient to do so."
msgstr ""
"API:et :func:`fileConfig` är äldre än API:et :func:`dictConfig` och "
"innehåller inte funktioner som täcker vissa aspekter av loggning. Du kan t."
"ex. inte konfigurera :class:`~logging.Filter`-objekt, som möjliggör "
"filtrering av meddelanden utöver enkla heltalsnivåer, med hjälp av :func:"
"`fileConfig`. Om du behöver ha instanser av :class:`~logging.Filter` i din "
"loggningskonfiguration måste du använda :func:`dictConfig`. Observera att "
"framtida förbättringar av konfigurationsfunktionaliteten kommer att läggas "
"till i :func:`dictConfig`, så det är värt att överväga att övergå till detta "
"nyare API när det är lämpligt att göra det."

msgid "Examples of these sections in the file are given below."
msgstr "Exempel på dessa avsnitt i filen ges nedan."

msgid ""
"[loggers]\n"
"keys=root,log02,log03,log04,log05,log06,log07\n"
"\n"
"[handlers]\n"
"keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09\n"
"\n"
"[formatters]\n"
"keys=form01,form02,form03,form04,form05,form06,form07,form08,form09"
msgstr ""
"[loggers]\n"
"keys=root,log02,log03,log04,log05,log06,log07\n"
"\n"
"[handlers]\n"
"keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09\n"
"\n"
"[formatters]\n"
"keys=form01,form02,form03,form04,form05,form06,form07,form08,form09"

msgid ""
"The root logger must specify a level and a list of handlers. An example of a "
"root logger section is given below."
msgstr ""
"Rotloggaren måste ange en nivå och en lista över hanterare. Ett exempel på "
"ett root logger-avsnitt ges nedan."

msgid ""
"[logger_root]\n"
"level=NOTSET\n"
"handlers=hand01"
msgstr ""
"[logger_root]\n"
"level=NOTSET\n"
"handlers=hand01"

msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :ref:`evaluated <func-eval>` in the context "
"of the ``logging`` package's namespace."
msgstr ""
"Posten ``level`` kan vara en av ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"eller ``NOTSET``. Endast för rotloggaren innebär ``NOTSET`` att alla "
"meddelanden loggas. Nivåvärden :ref:``utvärderas <func-eval>`` i kontexten "
"av ``logging``-paketets namnrymd."

msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr ""
"Posten ``handlers`` är en kommaseparerad lista med namn på hanterare som "
"måste finnas i avsnittet ``[handlers]``. Dessa namn måste finnas i avsnittet "
"``[handlers]`` och ha motsvarande avsnitt i konfigurationsfilen."

msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr ""
"För andra loggrar än rotloggaren krävs viss ytterligare information. Detta "
"illustreras av följande exempel."

msgid ""
"[logger_parser]\n"
"level=DEBUG\n"
"handlers=hand01\n"
"propagate=1\n"
"qualname=compiler.parser"
msgstr ""
"[logger_parser]\n"
"level=DEBUG\n"
"handlers=hand01\n"
"propagate=1\n"
"qualname=compiler.parser"

msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``, "
"the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the "
"application to get the logger."
msgstr ""
"Posterna ``level`` och ``handlers`` tolkas som för rotloggaren, förutom att "
"om nivån för en logger som inte är rotloggare anges som ``NOTSET``, "
"konsulterar systemet loggar högre upp i hierarkin för att fastställa "
"loggarens faktiska nivå. Posten ``propagate`` är satt till 1 för att ange "
"att meddelanden måste spridas till handläggare högre upp i loggerhierarkin "
"från denna logger, eller 0 för att ange att meddelanden **inte** sprids till "
"handläggare högre upp i hierarkin. Posten ``qualname`` är loggarens "
"hierarkiska kanalnamn, det vill säga det namn som används av programmet för "
"att hämta loggern."

msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr ""
"Avsnitt som specificerar konfigurationen av handläggaren exemplifieras av "
"följande."

msgid ""
"[handler_hand01]\n"
"class=StreamHandler\n"
"level=NOTSET\n"
"formatter=form01\n"
"args=(sys.stdout,)"
msgstr ""
"[handler_hand01]\n"
"class=StreamHandler\n"
"level=NOTSET\n"
"formatter=form01\n"
"args=(sys.stdout,)"

msgid ""
"The ``class`` entry indicates the handler's class (as determined by :func:"
"`eval` in the ``logging`` package's namespace). The ``level`` is interpreted "
"as for loggers, and ``NOTSET`` is taken to mean 'log everything'."
msgstr ""
"Objektet ``class`` anger hanterarens klass (som bestäms av :func:`eval` i "
"``logging``-paketets namnrymd). ``level`` tolkas som för loggare och "
"``NOTSET`` tolkas som \"logga allt\"."

msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section "
"and have a corresponding section in the configuration file."
msgstr ""
"Posten ``formatter`` anger nyckelnamnet på formateraren för denna hanterare. "
"Om den är tom används en standardformattering (``logging."
"_defaultFormatter``). Om ett namn anges måste det finnas i avsnittet "
"``[formatters]`` och ha ett motsvarande avsnitt i konfigurationsfilen."

msgid ""
"The ``args`` entry, when :ref:`evaluated <func-eval>` in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor "
"for the handler class. Refer to the constructors for the relevant handlers, "
"or to the examples below, to see how typical entries are constructed. If not "
"provided, it defaults to ``()``."
msgstr ""
"Posten ``args``, när :ref:``evaluated <func-eval>`` i samband med "
"``logging``-paketets namnrymd, är listan över argument till konstruktören "
"för klassen handler. Se konstruktörerna för de relevanta hanterarna, eller "
"exemplen nedan, för att se hur typiska poster konstrueras. Om den inte anges "
"är standardvärdet ``()``."

msgid ""
"The optional ``kwargs`` entry, when :ref:`evaluated <func-eval>` in the "
"context of the ``logging`` package's namespace, is the keyword argument dict "
"to the constructor for the handler class. If not provided, it defaults to "
"``{}``."
msgstr ""
"Den valfria ``kwargs`` posten, när :ref:``evaluated <func-eval>`` i "
"kontexten av ``logging`` paketets namnrymd, är nyckelordsargumentet dict "
"till konstruktören för hanterarklassen. Om det inte anges, är standardvärdet "
"``{}``."

msgid ""
"[handler_hand02]\n"
"class=FileHandler\n"
"level=DEBUG\n"
"formatter=form02\n"
"args=('python.log', 'w')\n"
"\n"
"[handler_hand03]\n"
"class=handlers.SocketHandler\n"
"level=INFO\n"
"formatter=form03\n"
"args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"\n"
"[handler_hand04]\n"
"class=handlers.DatagramHandler\n"
"level=WARN\n"
"formatter=form04\n"
"args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)\n"
"\n"
"[handler_hand05]\n"
"class=handlers.SysLogHandler\n"
"level=ERROR\n"
"formatter=form05\n"
"args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler."
"LOG_USER)\n"
"\n"
"[handler_hand06]\n"
"class=handlers.NTEventLogHandler\n"
"level=CRITICAL\n"
"formatter=form06\n"
"args=('Python Application', '', 'Application')\n"
"\n"
"[handler_hand07]\n"
"class=handlers.SMTPHandler\n"
"level=WARN\n"
"formatter=form07\n"
"args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger "
"Subject')\n"
"kwargs={'timeout': 10.0}\n"
"\n"
"[handler_hand08]\n"
"class=handlers.MemoryHandler\n"
"level=NOTSET\n"
"formatter=form08\n"
"target=\n"
"args=(10, ERROR)\n"
"\n"
"[handler_hand09]\n"
"class=handlers.HTTPHandler\n"
"level=NOTSET\n"
"formatter=form09\n"
"args=('localhost:9022', '/log', 'GET')\n"
"kwargs={'secure': True}"
msgstr ""
"[handler_hand02]\n"
"class=FileHandler\n"
"level=DEBUG\n"
"formatter=form02\n"
"args=('python.log', 'w')\n"
"\n"
"[handler_hand03]\n"
"class=handlers.SocketHandler\n"
"level=INFO\n"
"formatter=form03\n"
"args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"\n"
"[handler_hand04]\n"
"class=handlers.DatagramHandler\n"
"level=WARN\n"
"formatter=form04\n"
"args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)\n"
"\n"
"[handler_hand05]\n"
"class=handlers.SysLogHandler\n"
"level=ERROR\n"
"formatter=form05\n"
"args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler."
"LOG_USER)\n"
"\n"
"[handler_hand06]\n"
"class=handlers.NTEventLogHandler\n"
"level=CRITICAL\n"
"formatter=form06\n"
"args=('Python Application', '', 'Application')\n"
"\n"
"[handler_hand07]\n"
"class=handlers.SMTPHandler\n"
"level=WARN\n"
"formatter=form07\n"
"args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger "
"Subject')\n"
"kwargs={'timeout': 10.0}\n"
"\n"
"[handler_hand08]\n"
"class=handlers.MemoryHandler\n"
"level=NOTSET\n"
"formatter=form08\n"
"target=\n"
"args=(10, ERROR)\n"
"\n"
"[handler_hand09]\n"
"class=handlers.HTTPHandler\n"
"level=NOTSET\n"
"formatter=form09\n"
"args=('localhost:9022', '/log', 'GET')\n"
"kwargs={'secure': True}"

msgid ""
"Sections which specify formatter configuration are typified by the following."
msgstr "Avsnitt som anger formatteringskonfiguration kännetecknas av följande."

msgid ""
"[formatter_form01]\n"
"format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s\n"
"datefmt=\n"
"style=%\n"
"validate=True\n"
"defaults={'customfield': 'defaultvalue'}\n"
"class=logging.Formatter"
msgstr ""
"[formatter_form01]\n"
"format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s\n"
"datefmt=\n"
"style=%\n"
"validate=True\n"
"defaults={'customfield': 'defaultvalue'}\n"
"class=logging.Formatter"

msgid ""
"The arguments for the formatter configuration are the same as the keys in "
"the dictionary schema :ref:`formatters section <logging-config-dictschema-"
"formatters>`."
msgstr ""
"Argumenten för formatteringskonfigurationen är desamma som nycklarna i "
"ordboksschemat :ref:`formatters section <logging-config-dictschema-"
"formatters>`."

msgid ""
"The ``defaults`` entry, when :ref:`evaluated <func-eval>` in the context of "
"the ``logging`` package's namespace, is a dictionary of default values for "
"custom formatting fields. If not provided, it defaults to ``None``."
msgstr ""
"Posten ``defaults``, när :ref:``evaluated <func-eval>`` i kontexten av "
"``logging``-paketets namnrymd, är en ordbok med standardvärden för anpassade "
"formateringsfält. Om den inte tillhandahålls är standardvärdet ``None``."

msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the :func:"
"`listen` documentation for more information."
msgstr ""
"På grund av användningen av :func:`eval` enligt beskrivningen ovan finns det "
"potentiella säkerhetsrisker som uppstår när :func:`listen` används för att "
"skicka och ta emot konfigurationer via sockets. Riskerna är begränsade till "
"när flera användare utan ömsesidigt förtroende kör kod på samma maskin; se "
"dokumentationen för :func:`listen` för mer information."

msgid "Module :mod:`logging`"
msgstr "Modul :mod:`logging`"

msgid "API reference for the logging module."
msgstr "API-referens för loggningsmodulen."

msgid "Module :mod:`logging.handlers`"
msgstr "Modul :mod:`logging.handlers`"

msgid "Useful handlers included with the logging module."
msgstr "Användbara hanterare som ingår i loggningsmodulen."
