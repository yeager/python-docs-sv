# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!concurrent.interpreters` --- Multiple interpreters in the same process"
msgstr ":mod:`!concurrent.interpreters` --- Flera tolkar i samma process"

msgid "**Source code:** :source:`Lib/concurrent/interpreters`"
msgstr "**Källkod:** :källa:`Lib/concurrent/interpreters`"

msgid ""
"The :mod:`!concurrent.interpreters` module constructs higher-level "
"interfaces on top of the lower level :mod:`!_interpreters` module."
msgstr ""
"Modulen :mod:`!concurrent.interpreters` konstruerar gränssnitt på högre nivå "
"ovanpå modulen :mod:`!_interpreters` på lägre nivå."

msgid ""
"The module is primarily meant to provide a basic API for managing "
"interpreters (AKA \"subinterpreters\") and running things in them. Running "
"mostly involves switching to an interpreter (in the current thread) and "
"calling a function in that execution context."
msgstr ""
"Modulen är främst avsedd att tillhandahålla ett grundläggande API för att "
"hantera tolkar (även kallade \"undertolkar\") och köra saker i dem. Att köra "
"saker innebär oftast att man växlar till en tolk (i den aktuella tråden) och "
"anropar en funktion i det exekveringssammanhanget."

msgid ""
"For concurrency, interpreters themselves (and this module) don't provide "
"much more than isolation, which on its own isn't useful. Actual concurrency "
"is available separately through :mod:`threads <threading>`  See `below "
"<interp-concurrency_>`_"
msgstr ""
"För samtidighet tillhandahåller tolkarna själva (och den här modulen) inte "
"mycket mer än isolering, vilket i sig inte är användbart. Faktisk "
"samtidighet är tillgänglig separat genom :mod:`threads <threading>` Se "
"`under <interp-concurrency_>`_"

msgid ":class:`~concurrent.futures.InterpreterPoolExecutor`"
msgstr ":class:`~concurrent.futures.InterpreterPoolExecutor`"

msgid "combines threads with interpreters in a familiar interface."
msgstr "kombinerar trådar med tolkar i ett välbekant gränssnitt."

msgid ":ref:`isolating-extensions-howto`"
msgstr ":ref:`isolating-extensions-howto`"

msgid "how to update an extension module to support multiple interpreters"
msgstr "så här uppdaterar du en tilläggsmodul för att stödja flera tolkar"

msgid ":pep:`554`"
msgstr ":pep:`554``"

msgid ":pep:`734`"
msgstr ":pep:`734``"

msgid ":pep:`684`"
msgstr ":pep:`684``"

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid "Key details"
msgstr "Information om nyckel"

msgid ""
"Before we dive in further, there are a small number of details to keep in "
"mind about using multiple interpreters:"
msgstr ""
"Innan vi går vidare finns det ett antal detaljer att tänka på när det gäller "
"att använda flera tolkar:"

msgid "`isolated <interp-isolation_>`_, by default"
msgstr "`isolated <interp-isolation_>`_, som standard"

msgid "no implicit threads"
msgstr "inga implicita trådar"

msgid "not all PyPI packages support use in multiple interpreters yet"
msgstr "inte alla PyPI-paket stöder användning i flera tolkar ännu"

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"An \"interpreter\" is effectively the execution context of the Python "
"runtime.  It contains all of the state the runtime needs to execute a "
"program.  This includes things like the import state and builtins. (Each "
"thread, even if there's only the main thread, has some extra runtime state, "
"in addition to the current interpreter, related to the current exception and "
"the bytecode eval loop.)"
msgstr ""
"En \"tolk\" är i själva verket exekveringskontexten för Pythons runtime.  "
"Den innehåller allt tillstånd som körtiden behöver för att exekvera ett "
"program.  Detta inkluderar saker som importstatus och builtins. (Varje tråd, "
"även om det bara finns en huvudtråd, har lite extra körtidstillstånd, utöver "
"den aktuella tolken, relaterat till det aktuella undantaget och bytecode "
"eval-loopen)"

msgid ""
"The concept and functionality of the interpreter have been a part of Python "
"since version 2.2, but the feature was only available through the C-API and "
"not well known, and the `isolation <interp-isolation_>`_ was relatively "
"incomplete until version 3.12."
msgstr ""
"Konceptet och funktionaliteten för tolken har varit en del av Python sedan "
"version 2.2, men funktionen var endast tillgänglig via C-API och inte "
"särskilt välkänd, och `isoleringen <interp-isolation_>`_ var relativt "
"ofullständig fram till version 3.12."

msgid "Multiple Interpreters and Isolation"
msgstr "Flera tolkar och isolering"

msgid ""
"A Python implementation may support using multiple interpreters in the same "
"process.  CPython has this support.  Each interpreter is effectively "
"isolated from the others (with a limited number of carefully managed process-"
"global exceptions to the rule)."
msgstr ""
"En Python-implementation kan stödja användning av flera tolkar i samma "
"process.  CPython har detta stöd.  Varje tolk är effektivt isolerad från de "
"andra (med ett begränsat antal noggrant hanterade processglobala undantag "
"från regeln)."

msgid ""
"That isolation is primarily useful as a strong separation between distinct "
"logical components of a program, where you want to have careful control of "
"how those components interact."
msgstr ""
"Denna isolering är främst användbar som en stark separation mellan distinkta "
"logiska komponenter i ett program, där du vill ha noggrann kontroll över hur "
"dessa komponenter interagerar."

msgid ""
"Interpreters in the same process can technically never be strictly isolated "
"from one another since there are few restrictions on memory access within "
"the same process.  The Python runtime makes a best effort at isolation but "
"extension modules may easily violate that. Therefore, do not use multiple "
"interpreters in security-sensitive situations, where they shouldn't have "
"access to each other's data."
msgstr ""
"Tolkar i samma process kan tekniskt sett aldrig vara strikt isolerade från "
"varandra eftersom det finns få restriktioner för minnesåtkomst inom samma "
"process.  Pythons runtime gör sitt bästa för att isolera, men "
"tilläggsmoduler kan lätt bryta mot detta. Använd därför inte flera tolkar i "
"säkerhetskänsliga situationer, där de inte bör ha tillgång till varandras "
"data."

msgid "Running in an Interpreter"
msgstr "Att köra in en tolk"

msgid ""
"Running in a different interpreter involves switching to it in the current "
"thread and then calling some function.  The runtime will execute the "
"function using the current interpreter's state.  The :mod:`!concurrent."
"interpreters` module provides a basic API for creating and managing "
"interpreters, as well as the switch-and-call operation."
msgstr ""
"Att köra i en annan tolk innebär att man växlar till den i den aktuella "
"tråden och sedan anropar någon funktion.  Runtime kommer att exekvera "
"funktionen med hjälp av den aktuella tolkens tillstånd.  Modulen :mod:`!"
"concurrent.interpreters` tillhandahåller ett grundläggande API för att skapa "
"och hantera tolkar, samt för att växla och anropa."

msgid ""
"No other threads are automatically started for the operation. There is `a "
"helper <interp-call-in-thread_>`_ for that though. There is another "
"dedicated helper for calling the builtin :func:`exec` in an interpreter."
msgstr ""
"Inga andra trådar startas automatiskt för operationen. Det finns dock `en "
"hjälpare <interp-call-in-thread_>`_ för det. Det finns en annan dedikerad "
"hjälp för att anropa den inbyggda :func:`exec` i en tolk."

msgid ""
"When :func:`exec` (or :func:`eval`) are called in an interpreter, they run "
"using the interpreter's :mod:`!__main__` module as the \"globals\" "
"namespace.  The same is true for functions that aren't associated with any "
"module.  This is the same as how scripts invoked from the command-line run "
"in the :mod:`!__main__` module."
msgstr ""
"När :func:`exec` (eller :func:`eval`) anropas i en tolk, körs de med "
"tolkens :mod:`!__main__`-modul som \"globals\"-namnrymd.  Detsamma gäller "
"för funktioner som inte är associerade med någon modul.  Detta är samma sak "
"som att skript som anropas från kommandoraden körs i modulen :mod:`!"
"__main__`."

msgid "Concurrency and Parallelism"
msgstr "Samtidighet och parallellism"

msgid ""
"As noted earlier, interpreters do not provide any concurrency on their own.  "
"They strictly represent the isolated execution context the runtime will use "
"*in the current thread*.  That isolation makes them similar to processes, "
"but they still enjoy in-process efficiency, like threads."
msgstr ""
"Som tidigare nämnts tillhandahåller tolkar inte någon samtidighet i sig "
"själva.  De representerar strikt den isolerade exekveringskontext som "
"körtiden kommer att använda * i den aktuella tråden*.  Denna isolering gör "
"att de liknar processer, men de har fortfarande effektivitet i processen, "
"precis som trådar."

msgid ""
"All that said, interpreters do naturally support certain flavors of "
"concurrency. There's a powerful side effect of that isolation.  It enables a "
"different approach to concurrency than you can take with async or threads.  "
"It's a similar concurrency model to CSP or the actor model, a model which is "
"relatively easy to reason about."
msgstr ""
"Allt detta sagt, tolkar stöder naturligtvis vissa varianter av samtidighet. "
"Det finns en kraftfull bieffekt av den isoleringen.  Det möjliggör ett annat "
"tillvägagångssätt för samtidighet än du kan ta med async eller trådar.  Det "
"är en liknande samtidighetsmodell som CSP eller aktormodellen, en modell som "
"är relativt lätt att resonera om."

msgid ""
"You can take advantage of that concurrency model in a single thread, "
"switching back and forth between interpreters, Stackless-style. However, "
"this model is more useful when you combine interpreters with multiple "
"threads.  This mostly involves starting a new thread, where you switch to "
"another interpreter and run what you want there."
msgstr ""
"Du kan dra nytta av den här samtidighetsmodellen i en enda tråd genom att "
"växla fram och tillbaka mellan tolkarna på samma sätt som Stackless. Den här "
"modellen är dock mer användbar när du kombinerar tolkar med flera trådar.  "
"Detta innebär oftast att man startar en ny tråd, där man växlar till en "
"annan tolk och kör det man vill där."

msgid ""
"Each actual thread in Python, even if you're only running in the main "
"thread, has its own *current* execution context.  Multiple threads can use "
"the same interpreter or different ones."
msgstr ""
"Varje faktisk tråd i Python, även om du bara kör i huvudtråden, har sin egen "
"*aktuella* exekveringskontext.  Flera trådar kan använda samma tolk eller "
"olika."

msgid ""
"At a high level, you can think of the combination of threads and "
"interpreters as threads with opt-in sharing."
msgstr ""
"På en hög nivå kan man tänka sig kombinationen av trådar och tolkar som "
"trådar med opt-in-delning."

msgid ""
"As a significant bonus, interpreters are sufficiently isolated that they do "
"not share the :term:`GIL`, which means combining threads with multiple "
"interpreters enables full multi-core parallelism. (This has been the case "
"since Python 3.12.)"
msgstr ""
"Som en betydande bonus är tolkarna tillräckligt isolerade för att de inte "
"delar :term:`GIL`, vilket innebär att kombinera trådar med flera tolkar "
"möjliggör full parallellism med flera kärnor. (Detta har varit fallet sedan "
"Python 3.12.)"

msgid "Communication Between Interpreters"
msgstr "Kommunikation mellan tolkar"

msgid ""
"In practice, multiple interpreters are useful only if we have a way to "
"communicate between them.  This usually involves some form of message "
"passing, but can even mean sharing data in some carefully managed way."
msgstr ""
"I praktiken är flera tolkar bara användbara om vi har ett sätt att "
"kommunicera mellan dem.  Detta innebär vanligtvis någon form av "
"meddelandepassning, men kan även innebära att data delas på något noggrant "
"hanterat sätt."

msgid ""
"With this in mind, the :mod:`!concurrent.interpreters` module provides a :"
"class:`queue.Queue` implementation, available through :func:`create_queue`."
msgstr ""
"Med detta i åtanke tillhandahåller modulen :mod:`!concurrent.interpreters` "
"en implementation av :class:`queue.Queue`, tillgänglig via :func:"
"`create_queue`."

msgid "\"Sharing\" Objects"
msgstr "\"Delning\" av objekt"

msgid ""
"Any data actually shared between interpreters loses the thread-safety "
"provided by the :term:`GIL`.  There are various options for dealing with "
"this in extension modules.  However, from Python code the lack of thread-"
"safety means objects can't actually be shared, with a few exceptions.  "
"Instead, a copy must be created, which means mutable objects won't stay in "
"sync."
msgstr ""
"Alla data som faktiskt delas mellan tolkar förlorar den trådsäkerhet som "
"tillhandahålls av :term:`GIL`.  Det finns olika alternativ för att hantera "
"detta i tilläggsmoduler.  Från Python-kod innebär dock bristen på "
"trådsäkerhet att objekt faktiskt inte kan delas, med några få undantag.  "
"Istället måste en kopia skapas, vilket innebär att föränderliga objekt inte "
"förblir synkroniserade."

msgid ""
"By default, most objects are copied with :mod:`pickle` when they are passed "
"to another interpreter.  Nearly all of the immutable builtin objects are "
"either directly shared or copied efficiently.  For example:"
msgstr ""
"Som standard kopieras de flesta objekt med :mod:`pickle` när de skickas till "
"en annan tolk.  Nästan alla oföränderliga inbyggda objekt delas antingen "
"direkt eller kopieras på ett effektivt sätt.  Till exempel:"

msgid ":const:`None`"
msgstr ":const:`None`"

msgid ":class:`bool` (:const:`True` and :const:`False`)"
msgstr ":class:`bool` (:const:`True` och :const:`False`)"

msgid ":class:`bytes`"
msgstr ":class:`bytes`"

msgid ":class:`str`"
msgstr ":class:`str`"

msgid ":class:`int`"
msgstr ":class:`int`"

msgid ":class:`float`"
msgstr ":class:`float`"

msgid ":class:`tuple` (of similarly supported objects)"
msgstr ":class:`tuple` (av objekt som stöds på liknande sätt)"

msgid ""
"There is a small number of Python types that actually share mutable data "
"between interpreters:"
msgstr ""
"Det finns ett litet antal Python-typer som faktiskt delar föränderliga data "
"mellan tolkare:"

msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

msgid ":class:`Queue`"
msgstr ":class:`Queue`"

msgid "Reference"
msgstr "Referens"

msgid "This module defines the following functions:"
msgstr "Denna modul definierar följande funktioner:"

msgid ""
"Return a :class:`list` of :class:`Interpreter` objects, one for each "
"existing interpreter."
msgstr ""
"Returnerar en :class:`list` av :class:`Interpreter`-objekt, ett för varje "
"befintlig tolk."

msgid ""
"Return an :class:`Interpreter` object for the currently running interpreter."
msgstr ""
"Returnerar ett :class:`Interpreter`-objekt för den tolk som körs för "
"tillfället."

msgid ""
"Return an :class:`Interpreter` object for the main interpreter. This is the "
"interpreter the runtime created to run the :term:`REPL` or the script given "
"at the command-line.  It is usually the only one."
msgstr ""
"Returnerar ett :class:`Interpreter`-objekt för huvudtolken. Detta är den "
"tolk som körtiden skapade för att köra :term:`REPL` eller det skript som "
"gavs på kommandoraden.  Det är vanligtvis den enda."

msgid ""
"Initialize a new (idle) Python interpreter and return a :class:`Interpreter` "
"object for it."
msgstr ""
"Initiera en ny (inaktiv) Python-tolk och returnera ett :class:`Interpreter`-"
"objekt för den."

msgid ""
"Initialize a new cross-interpreter queue and return a :class:`Queue` object "
"for it."
msgstr ""
"Initiera en ny tolköverskridande kö och returnera ett :class:`Queue`-objekt "
"för den."

msgid "Interpreter objects"
msgstr "Tolkningsobjekt"

msgid "A single interpreter in the current process."
msgstr "En enda tolk i den aktuella processen."

msgid ""
"Generally, :class:`Interpreter` shouldn't be called directly. Instead, use :"
"func:`create` or one of the other module functions."
msgstr ""
"Generellt sett bör inte :class:`Interpreter` anropas direkt. Använd "
"istället :func:`create` eller någon av de andra modulfunktionerna."

msgid "(read-only)"
msgstr "(skrivskyddad)"

msgid "The underlying interpreter's ID."
msgstr "Den underliggande tolkens ID."

msgid "A string describing where the interpreter came from."
msgstr "En sträng som beskriver varifrån tolken kommer."

msgid ""
"Return ``True`` if the interpreter is currently executing code in its :mod:`!"
"__main__` module and ``False`` otherwise."
msgstr ""
"Returnerar ``True`` om tolken för närvarande exekverar kod i sin :mod:`!"
"__main__`-modul och ``False`` i annat fall."

msgid "Finalize and destroy the interpreter."
msgstr "Slutför och förstör tolken."

msgid "Bind objects in the interpreter's :mod:`!__main__` module."
msgstr "Binda objekt i tolkens :mod:`!__main__`-modul."

msgid ""
"Some objects are actually shared and some are copied efficiently, but most "
"are copied via :mod:`pickle`.  See :ref:`interp-object-sharing`."
msgstr ""
"Vissa objekt delas faktiskt och vissa kopieras på ett effektivt sätt, men de "
"flesta kopieras via :mod:`pickle`.  Se :ref:`interp-object-sharing`."

msgid "Run the given source code in the interpreter (in the current thread)."
msgstr "Kör den angivna källkoden i tolken (i den aktuella tråden)."

msgid ""
"Return the result of calling running the given function in the interpreter "
"(in the current thread)."
msgstr ""
"Returnerar resultatet av att anropa och köra den angivna funktionen i tolken "
"(i den aktuella tråden)."

msgid "Run the given function in the interpreter (in a new thread)."
msgstr "Kör den angivna funktionen i tolken (i en ny tråd)."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"This exception, a subclass of :exc:`Exception`, is raised when an "
"interpreter-related error happens."
msgstr ""
"Detta undantag, som är en underklass till :exc:`Exception`, uppstår när ett "
"tolkningsrelaterat fel inträffar."

msgid ""
"This exception, a subclass of :exc:`InterpreterError`, is raised when the "
"targeted interpreter no longer exists."
msgstr ""
"Detta undantag, som är en underklass till :exc:`InterpreterError`, uppstår "
"när den avsedda tolken inte längre finns."

msgid ""
"This exception, a subclass of :exc:`InterpreterError`, is raised when the "
"running code raised an uncaught exception."
msgstr ""
"Detta undantag, som är en underklass till :exc:`InterpreterError`, uppstår "
"när den löpande koden har orsakat ett undantag som inte fångats upp."

msgid "A basic snapshot of the exception raised in the other interpreter."
msgstr ""
"En enkel ögonblicksbild av det undantag som uppstod i den andra tolken."

msgid ""
"This exception, a subclass of :exc:`TypeError`, is raised when an object "
"cannot be sent to another interpreter."
msgstr ""
"Detta undantag, som är en underklass till :exc:`TypeError`, uppstår när ett "
"objekt inte kan skickas till en annan tolk."

msgid "Communicating Between Interpreters"
msgstr "Kommunikation mellan tolkar"

msgid ""
"A wrapper around a low-level, cross-interpreter queue, which implements the :"
"class:`queue.Queue` interface.  The underlying queue can only be created "
"through :func:`create_queue`."
msgstr ""
"En wrapper runt en lågnivå, tolkningsöverskridande kö, som implementerar :"
"class:`queue.Queue`-gränssnittet.  Den underliggande kön kan endast skapas "
"genom :func:`create_queue`."

msgid "The queue's ID."
msgstr "Köns ID."

msgid ""
"This exception, a subclass of :exc:`queue.Empty`, is raised from :meth:`!"
"Queue.get` and :meth:`!Queue.get_nowait` when the queue is empty."
msgstr ""
"Detta undantag, en subklass av :exc:`queue.Empty`, uppstår från :meth:`!"
"Queue.get` och :meth:`!Queue.get_nowait` när kön är tom."

msgid ""
"This exception, a subclass of :exc:`queue.Full`, is raised from :meth:`!"
"Queue.put` and :meth:`!Queue.put_nowait` when the queue is full."
msgstr ""
"Detta undantag, en subklass av :exc:`queue.Full`, uppstår från :meth:`!Queue."
"put` och :meth:`!Queue.put_nowait` när kön är full."

msgid "Basic usage"
msgstr "Grundläggande användning"

msgid "Creating an interpreter and running code in it::"
msgstr "Skapa en tolk och köra kod i den::"

msgid ""
"from concurrent import interpreters\n"
"\n"
"interp = interpreters.create()\n"
"\n"
"# Run in the current OS thread.\n"
"\n"
"interp.exec('print(\"spam!\")')\n"
"\n"
"interp.exec(\"\"\"if True:\n"
"    print('spam!')\n"
"    \"\"\")\n"
"\n"
"from textwrap import dedent\n"
"interp.exec(dedent(\"\"\"\n"
"    print('spam!')\n"
"    \"\"\"))\n"
"\n"
"def run(arg):\n"
"    return arg\n"
"\n"
"res = interp.call(run, 'spam!')\n"
"print(res)\n"
"\n"
"def run():\n"
"    print('spam!')\n"
"\n"
"interp.call(run)\n"
"\n"
"# Run in new OS thread.\n"
"\n"
"t = interp.call_in_thread(run)\n"
"t.join()"
msgstr ""
"från samtidiga importtolkar\n"
"\n"
"interp = tolkar.skapa()\n"
"\n"
"# Kör i den aktuella OS-tråden.\n"
"\n"
"interp.exec('print(\"spam!\")')\n"
"\n"
"interp.exec(\"\"\"if True:\n"
"    print('spam!')\n"
"    \"\"\")\n"
"\n"
"från textwrap import dedent\n"
"interp.exec(dedent(\"\"\"\n"
"    print('skräppost!')\n"
"    \"\"\"))\n"
"\n"
"def run(arg):\n"
"    returnerar arg\n"
"\n"
"res = interp.call(run, 'spam!')\n"
"print(res)\n"
"\n"
"def run():\n"
"    print('skräppost!')\n"
"\n"
"interp.call(run)\n"
"\n"
"# Kör i en ny OS-tråd.\n"
"\n"
"t = interp.call_in_thread(run)\n"
"t.join()"
