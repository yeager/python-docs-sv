# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!pickle` --- Python object serialization"
msgstr ":mod:`!pickle` --- Python-objektserialisering"

msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**Källkod:** :source:`Lib/pickle.py`"

msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"Modulen :mod:`pickle` implementerar binära protokoll för serialisering och "
"de-serialisering av en Python-objektstruktur.  *\"Pickling\"* är processen "
"där en Python-objekthierarki konverteras till en byte-ström, och "
"*\"unpickling\"* är den omvända operationen, där en byte-ström (från en :"
"term:`binär fil` eller :term:`bytesliknande objekt`) konverteras tillbaka "
"till en objekthierarki.  Pickling (och unpickling) kallas även "
"\"serialization\", \"marshalling\", [#]_ eller \"flattening\", men för att "
"undvika förvirring används här termerna \"pickling\" och \"unpickling\"."

msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""
"Modulen ``pickle`` är **inte säker**. Plocka endast upp data som du litar på."

msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"Det är möjligt att konstruera skadlig pickle-data som **exekverar godtycklig "
"kod under uppackning**. Plocka aldrig upp data som kan ha kommit från en "
"icke betrodd källa eller som kan ha manipulerats."

msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""
"Överväg att signera data med :mod:`hmac` om du behöver försäkra dig om att "
"de inte har manipulerats."

msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"Säkrare serialiseringsformat som :mod:`json` kan vara lämpligare om du "
"bearbetar otillförlitliga data. Se :ref:`jämförelse-med-json`."

msgid "Relationship to other Python modules"
msgstr "Förhållande till andra Python-moduler"

msgid "Comparison with ``marshal``"
msgstr "Jämförelse med ``marshal``"

msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python har en mer primitiv serialiseringsmodul som heter :mod:`marshal`, men "
"i allmänhet bör :mod:`pickle` alltid vara det föredragna sättet att "
"serialisera Python-objekt. :mod:`marshal` finns främst för att stödja "
"Pythons :file:`.pyc`-filer."

msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
"Modulen :mod:`pickle` skiljer sig från :mod:`marshal` på flera viktiga sätt:"

msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
"Modulen :mod:`pickle` håller reda på de objekt som den redan har "
"serialiserat, så att senare referenser till samma objekt inte behöver "
"serialiseras igen. :mod:`marshal` gör inte detta."

msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"Detta har konsekvenser för både rekursiva objekt och objektdelning.  "
"Rekursiva objekt är objekt som innehåller referenser till sig själva.  Dessa "
"hanteras inte av marshal, och i själva verket kommer försök att marshalera "
"rekursiva objekt att krascha din Python-tolk.  Objektdelning sker när det "
"finns flera referenser till samma objekt på olika platser i objekthierarkin "
"som serialiseras. :mod:`pickle` lagrar sådana objekt endast en gång och ser "
"till att alla andra referenser pekar på huvudkopian.  Delade objekt förblir "
"delade, vilket kan vara mycket viktigt för föränderliga objekt."

msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` kan inte användas för att serialisera användardefinierade "
"klasser och deras instanser. :mod:`pickle` kan spara och återställa "
"klassinstanser på ett transparent sätt, men klassdefinitionen måste vara "
"importerbar och finnas i samma modul som när objektet lagrades."

msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"Serialiseringsformatet :mod:`marshal` garanteras inte att vara portabelt "
"mellan olika Python-versioner.  Eftersom dess primära uppgift är att stödja :"
"file:`.pyc`-filer, förbehåller sig Python-implementatörerna rätten att ändra "
"serialiseringsformatet på icke-bakåtkompatibla sätt om behov skulle uppstå. "
"Serialiseringsformatet :mod:`pickle` är garanterat bakåtkompatibelt mellan "
"Python-versioner förutsatt att ett kompatibelt pickle-protokoll väljs och "
"att pickling- och unpickling-koden hanterar typskillnader mellan Python 2 "
"och Python 3 om dina data passerar den unika språkgränsen."

msgid "Comparison with ``json``"
msgstr "Jämförelse med ``json``"

msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"
msgstr ""
"Det finns grundläggande skillnader mellan pickle-protokollen och `JSON "
"(JavaScript Object Notation) <https://json.org>`_:"

msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON är ett serialiseringsformat för text (det matar ut unicode-text, även "
"om det för det mesta sedan kodas till ``utf-8``), medan pickle är ett binärt "
"serialiseringsformat;"

msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON är läsbart för människor, medan pickle inte är det;"

msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON är interoperabelt och används ofta utanför Python-ekosystemet, medan "
"pickle är Python-specifikt;"

msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""
"JSON kan som standard bara representera en delmängd av Pythons inbyggda "
"typer, och inga anpassade klasser; pickle kan representera ett extremt stort "
"antal Python-typer (många av dem automatiskt, genom smart användning av "
"Pythons introspektionsmöjligheter; komplexa fall kan hanteras genom att "
"implementera :ref:`specifika objekt-API:er <pickle-inst>`);"

msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""
"Till skillnad från pickle skapar deserialisering av icke betrodda JSON inte "
"i sig en sårbarhet för godtycklig kodkörning."

msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
"Modulen :mod:`json`: en standardbiblioteksmodul som möjliggör serialisering "
"och deserialisering av JSON."

msgid "Data stream format"
msgstr "Format för dataström"

msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON (which can't represent pointer sharing); however it means that non-"
"Python programs may not be able to reconstruct pickled Python objects."
msgstr ""
"Dataformatet som används av :mod:`pickle` är Python-specifikt.  Fördelen med "
"detta är att det inte finns några begränsningar från externa standarder som "
"JSON (som inte kan representera delning av pekare), men det innebär att "
"program som inte är Python-program kanske inte kan rekonstruera Python-"
"objekt med pickles."

msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"Som standard använder :mod:`pickle` dataformatet en relativt kompakt binär "
"representation.  Om du behöver optimala storleksegenskaper kan du på ett "
"effektivt sätt :doc:`komprimera <archiving>` pickled data."

msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"Modulen :mod:`pickletools` innehåller verktyg för att analysera dataströmmar "
"som genereras av :mod:`pickle`. Källkoden till :mod:`pickletools` har "
"omfattande kommentarer om opkoder som används av pickle-protokoll."

msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"Det finns för närvarande 6 olika protokoll som kan användas för betning. Ju "
"högre protokoll som används, desto nyare version av Python behövs för att "
"läsa den pickle som produceras."

msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"Protokollversion 0 är det ursprungliga \"mänskligt läsbara\" protokollet och "
"är bakåtkompatibelt med tidigare versioner av Python."

msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"Protokollversion 1 är ett gammalt binärt format som också är kompatibelt med "
"tidigare versioner av Python."

msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style classes <new-style class>`.  Refer "
"to :pep:`307` for information about improvements brought by protocol 2."
msgstr ""
"Protokollversion 2 introducerades i Python 2.3.  Det ger mycket effektivare "
"betning av :term:`nya stilklasser <new-style class>`.  Se :pep:`307` för "
"information om förbättringar som protokoll 2 medför."

msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"Protokollversion 3 lades till i Python 3.0.  Det har uttryckligt stöd för :"
"class:`bytes`-objekt och kan inte avplockas av Python 2.x. Detta var "
"standardprotokollet i Python 3.0--3.7."

msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  This was the default protocol in Python 3.8--3.13. Refer to :"
"pep:`3154` for information about improvements brought by protocol 4."
msgstr ""
"Protokollversion 4 lades till i Python 3.4.  Det lägger till stöd för mycket "
"stora objekt, pickling av fler typer av objekt och vissa "
"dataformatoptimeringar.  Detta var standardprotokollet i Python 3.8--3.13. "
"Se :pep:`3154` för information om förbättringar som protokoll 4 medför."

msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  It is the default protocol starting with "
"Python 3.14.  Refer to :pep:`574` for information about improvements brought "
"by protocol 5."
msgstr ""
"Protokollversion 5 lades till i Python 3.8.  Det ger stöd för data utanför "
"bandet och ökad hastighet för data inom bandet.  Det är standardprotokollet "
"från och med Python 3.14.  Se :pep:`574` för information om förbättringar "
"som protokoll 5 medför."

msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"Serialisering är ett mer primitivt begrepp än persistens; även om :mod:"
"`pickle` läser och skriver filobjekt, hanterar den inte frågan om "
"namngivning av persistenta objekt eller den (ännu mer komplicerade) frågan "
"om samtidig åtkomst till persistenta objekt.  Modulen :mod:`pickle` kan "
"omvandla ett komplext objekt till en byte-ström och den kan omvandla byte-"
"strömmen till ett objekt med samma interna struktur.  Det kanske mest "
"uppenbara att göra med dessa byteflöden är att skriva dem till en fil, men "
"det är också tänkbart att skicka dem över ett nätverk eller lagra dem i en "
"databas.  Modulen :mod:`shelve` ger ett enkelt gränssnitt för att plocka och "
"plocka upp objekt på DBM-liknande databasfiler."

msgid "Module Interface"
msgstr "Modulgränssnitt"

msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"För att serialisera en objekthierarki anropar du helt enkelt funktionen :"
"func:`dumps`. På samma sätt anropar du funktionen :func:`loads` för att "
"avserialisera en dataström. Men om du vill ha mer kontroll över "
"serialisering och de-serialisering kan du skapa ett :class:`Pickler`- "
"respektive ett :class:`Unpickler`-objekt."

msgid "The :mod:`pickle` module provides the following constants:"
msgstr "Modulen :mod:`pickle` tillhandahåller följande konstanter:"

msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"Ett heltal, den högsta :ref:`protocol version <pickle-protocols>` som finns "
"tillgänglig.  Detta värde kan skickas som ett *protocol*-värde till "
"funktionerna :func:`dump` och :func:`dumps` samt till :class:`Pickler`-"
"konstruktören."

msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 5, introduced in Python 3.8 and incompatible with previous "
"versions. This version introduces support for out-of-band buffers, where :"
"pep:`3118`-compatible data can be transmitted separately from the main "
"pickle stream."
msgstr ""
"Ett heltal, standard :ref:``protokollversion <pickle-protocols>` som används "
"för betning.  Kan vara mindre än :data:`HIGHEST_PROTOCOL`.  För närvarande "
"är standardprotokollet 5, introducerat i Python 3.8 och inkompatibelt med "
"tidigare versioner. Denna version introducerar stöd för out-of-band-"
"buffertar, där :pep:`3118`-kompatibla data kan överföras separat från "
"huvudflödet i pickle."

msgid "The default protocol is 3."
msgstr "Standardprotokollet är 3."

msgid "The default protocol is 4."
msgstr "Standardprotokollet är 4."

msgid "The default protocol is 5."
msgstr "Standardprotokollet är 5."

msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"Modulen :mod:`pickle` tillhandahåller följande funktioner för att göra "
"betningsprocessen mer bekväm:"

msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"Skriver den picklade representationen av objektet *obj* till det öppna :term:"
"`filobjektet` *fil*.  Detta är likvärdigt med ``Pickler(file, protocol)."
"dump(obj)``."

msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"Argumenten *file*, *protocol*, *fix_imports* och *buffer_callback* har samma "
"betydelse som i :class:`Pickler`-konstruktorn."

msgid "The *buffer_callback* argument was added."
msgstr "Argumentet *buffer_callback* har lagts till."

msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"Returnerar den betade representationen av objektet *obj* som ett :class:"
"`bytes`-objekt, istället för att skriva det till en fil."

msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"Argumenten *protocol*, *fix_imports* och *buffer_callback* har samma "
"betydelse som i :class:`Pickler`-konstruktorn."

msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"Läser in den inlagda representationen av ett objekt från den öppna :term:"
"`file object` *file* och returnerar den rekonstruerade objekthierarkin som "
"anges där. Detta är ekvivalent med ``Unpickler(file).load()``."

msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"Protokollversionen av pickle upptäcks automatiskt, så inget "
"protokollargument behövs.  Bytes som ligger efter objektets picklade "
"representation ignoreras."

msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Argumenten *file*, *fix_imports*, *encoding*, *errors*, *strict* och "
"*buffers* har samma betydelse som i konstruktören :class:`Unpickler`."

msgid "The *buffers* argument was added."
msgstr "Argumentet *buffertar* har lagts till."

msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"Returnerar den rekonstituerade objekthierarkin för den betade "
"representationen *data* av ett objekt. *data* måste vara en :term:"
"`bytesliknande objekt`."

msgid ""
"Arguments *fix_imports*, *encoding*, *errors*, *strict* and *buffers* have "
"the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Argumenten *fix_imports*, *encoding*, *errors*, *strict* och *buffers* har "
"samma betydelse som i konstruktören :class:`Unpickler`."

msgid "The :mod:`pickle` module defines three exceptions:"
msgstr "Modulen :mod:`pickle` definierar tre undantag:"

msgid ""
"Common base class for the other pickling exceptions.  It inherits from :exc:"
"`Exception`."
msgstr ""
"Gemensam basklass för de andra betningsundantagen.  Den ärver från :exc:"
"`Exception`."

msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits from :exc:`PickleError`."
msgstr ""
"Fel som uppstår när ett objekt som inte går att plocka upp påträffas av :"
"class:`Pickler`. Det ärver från :exc:`PickleError`."

msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"Se :ref:`pickle-picklable` för att lära dig vilka typer av objekt som kan "
"picklas."

msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits from :exc:`PickleError`."
msgstr ""
"Fel som uppstår när det finns ett problem med att plocka upp ett objekt, t."
"ex. datakorruption eller säkerhetsöverträdelse.  Det ärver från :exc:"
"`PickleError`."

msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"Observera att andra undantag också kan uppstå under unpickling, inklusive "
"(men inte nödvändigtvis begränsat till) AttributeError, EOFError, "
"ImportError och IndexError."

msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
"Modulen :mod:`pickle` exporterar tre klasser, :class:`Pickler`, :class:"
"`Unpickler` och :class:`PickleBuffer`:"

msgid "This takes a binary file for writing a pickle data stream."
msgstr "Detta tar en binär fil för att skriva en pickle-dataström."

msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"Det valfria argumentet *protocol*, ett heltal, talar om för betningsmaskinen "
"att den ska använda det angivna protokollet; protokoll som stöds är 0 till :"
"data:`HIGHEST_PROTOCOL`. Om det inte anges är standardvärdet :data:"
"`DEFAULT_PROTOCOL`.  Om ett negativt tal anges väljs :data:"
"`HIGHEST_PROTOCOL`."

msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"Argumentet *file* måste ha en write()-metod som accepterar ett enda bytes-"
"argument.  Det kan alltså vara en fil på disken som är öppen för binär "
"skrivning, en :class:`io.BytesIO`-instans eller något annat anpassat objekt "
"som uppfyller detta gränssnitt."

msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"Om *fix_imports* är true och *protocol* är mindre än 3, kommer pickle att "
"försöka mappa de nya Python 3-namnen till de gamla modulnamnen som används i "
"Python 2, så att pickle-dataflödet kan läsas med Python 2."

msgid ""
"If *buffer_callback* is ``None`` (the default), buffer views are serialized "
"into *file* as part of the pickle stream."
msgstr ""
"Om *buffer_callback* är ``None`` (standard), serialiseras buffertvyer till "
"*file* som en del av pickle-strömmen."

msgid ""
"If *buffer_callback* is not ``None``, then it can be called any number of "
"times with a buffer view.  If the callback returns a false value (such as "
"``None``), the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise "
"the buffer is serialized in-band, i.e. inside the pickle stream."
msgstr ""
"Om *buffer_callback* inte är ``None`` kan den anropas hur många gånger som "
"helst med en buffertvy.  Om callbacken returnerar ett falskt värde (t.ex. "
"``None``), är den givna bufferten :ref:``out-of-band <pickle-oob>``; annars "
"serialiseras bufferten in-band, dvs. inuti pickle-strömmen."

msgid ""
"It is an error if *buffer_callback* is not ``None`` and *protocol* is "
"``None`` or smaller than 5."
msgstr ""
"Det är ett fel om *buffer_callback* inte är ``None`` och *protocol* är "
"``None`` eller mindre än 5."

msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"Skriv den betade representationen av *obj* till open file-objektet som anges "
"i konstruktören."

msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"Gör ingenting som standard.  Detta finns så att en underklass kan åsidosätta "
"det."

msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"Om :meth:`persistent_id` returnerar ``None`` betas *obj* som vanligt.  Alla "
"andra värden gör att :class:`Pickler` skickar ut det returnerade värdet som "
"ett persistent ID för *obj*.  Betydelsen av detta persistenta ID bör "
"definieras av :meth:`Unpickler.persistent_load`.  Observera att det värde "
"som returneras av :meth:`persistent_id` inte själv kan ha ett persistent ID."

msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr ""
"Se :ref:`pickle-persistent` för detaljer och exempel på användningsområden."

msgid ""
"Add the default implementation of this method in the C implementation of :"
"class:`!Pickler`."
msgstr ""
"Lägg till standardimplementationen av den här metoden i C-implementationen "
"av :class:`!Pickler`."

msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`~object.__reduce__` method."
msgstr ""
"Ett picklerobjekts dispatch table är ett register över "
"*reduktionsfunktioner* av den typ som kan deklareras med :func:`copyreg."
"pickle`.  Det är en mappning vars nycklar är klasser och vars värden är "
"reduktionsfunktioner.  En reduktionsfunktion tar ett enda argument från den "
"associerade klassen och bör överensstämma med samma gränssnitt som en :meth:"
"`~object.__reduce__`-metod."

msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"Som standard kommer ett pickler-objekt inte att ha ett :attr:"
"`dispatch_table`-attribut, och det kommer istället att använda den globala "
"dispatch-tabellen som hanteras av :mod:`copyreg`-modulen. För att anpassa "
"betningen för ett specifikt betningsobjekt kan man dock ställa in "
"attributet :attr:`dispatch_table` till ett diktliknande objekt.  "
"Alternativt, om en underklass av :class:`Pickler` har ett :attr:"
"`dispatch_table` attribut så kommer detta att användas som standard dispatch "
"table för instanser av den klassen."

msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "Se :ref:`pickle-dispatch` för användningsexempel."

msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`~object.__reduce__` method, "
"and can optionally return :data:`NotImplemented` to fallback on :attr:"
"`dispatch_table`-registered reducers to pickle ``obj``."
msgstr ""
"Speciell reducerare som kan definieras i :class:`Pickler` subklasser. Denna "
"metod har prioritet över alla reducerare i :attr:`dispatch_table`.  Den bör "
"överensstämma med samma gränssnitt som en :meth:`~object.__reduce__`-metod, "
"och kan eventuellt returnera :data:`NotImplemented` för att fallbacka på :"
"attr:`dispatch_table`-registrerade reducerare för att plocka ``obj``."

msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "För ett detaljerat exempel, se :ref:`reducer_override`."

msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"Föråldrad. Aktiverar snabbläge om det sätts till ett sant värde.  Det snabba "
"läget inaktiverar användningen av memo, vilket påskyndar betningsprocessen "
"genom att inte generera överflödiga PUT-opkoder.  Det bör inte användas med "
"självrefererande objekt, annars kommer :class:`Pickler` att rekursera "
"oändligt."

msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"Använd :func:`pickletools.optimize` om du behöver mer kompakta pickles."

msgid "Clears the pickler's \"memo\"."
msgstr "Rensar picklerns \"memo\"."

msgid ""
"The memo is the data structure that remembers which objects the pickler has "
"already seen, so that shared or recursive objects are pickled by reference "
"and not by value.  This method is useful when re-using picklers."
msgstr ""
"Memot är den datastruktur som kommer ihåg vilka objekt som picklern redan "
"har sett, så att delade eller rekursiva objekt picklas per referens och inte "
"per värde.  Denna metod är användbar vid återanvändning av picklers."

msgid "This takes a binary file for reading a pickle data stream."
msgstr "Detta tar en binär fil för att läsa en pickle-dataström."

msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"Protokollversionen av pickle identifieras automatiskt, så inget "
"protokollargument behövs."

msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"Argumentet *file* måste ha tre metoder, en read()-metod som tar ett "
"heltalsargument, en readinto()-metod som tar ett buffertargument och en "
"readline()-metod som inte kräver några argument, som i gränssnittet :class:"
"`io.BufferedIOBase`.  Således kan *file* vara en diskfil som öppnas för "
"binär läsning, ett :class:`io.BytesIO`-objekt eller något annat anpassat "
"objekt som uppfyller detta gränssnitt."

msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""
"De valfria argumenten *fix_imports*, *encoding* och *errors* används för att "
"styra kompatibilitetsstödet för pickle-strömmar som genererats av Python 2. "
"Om *fix_imports* är true kommer pickle att försöka mappa de gamla Python 2-"
"namnen till de nya namn som används i Python 3.  *encoding* och *errors* "
"talar om för pickle hur man avkodar 8-bitars stränginstanser som plockats "
"upp av Python 2; dessa är standardiserade till 'ASCII' respektive 'strict'.  "
"*encoding* kan vara 'bytes' för att läsa dessa 8-bitars stränginstanser som "
"bytes-objekt. Användning av ``encoding='latin1'`` krävs för att avplocka "
"NumPy-arrayer och instanser av :class:`~datetime.datetime`, :class:"
"`~datetime.date` och :class:`~datetime.time` som avplockats av Python 2."

msgid ""
"If *buffers* is ``None`` (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was ``None`` when a :class:`Pickler` was "
"instantiated (or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"Om *buffers* är ``None`` (standard) måste all data som behövs för "
"deserialisering finnas i pickle-strömmen.  Detta innebär att argumentet "
"*buffer_callback* var ``None`` när en :class:`Pickler` instantierades (eller "
"när :func:`dump` eller :func:`dumps` anropades)."

msgid ""
"If *buffers* is not ``None``, it should be an iterable of buffer-enabled "
"objects that is consumed each time the pickle stream references an :ref:`out-"
"of-band <pickle-oob>` buffer view.  Such buffers have been given in order to "
"the *buffer_callback* of a Pickler object."
msgstr ""
"Om *buffers* inte är ``None``, bör det vara en iterabel av buffertaktiverade "
"objekt som konsumeras varje gång pickle-strömmen refererar till en :ref:"
"``out-of-band <pickle-oob>` buffertvy.  Sådana buffertar har givits i "
"ordning till *buffer_callback* för ett Pickler-objekt."

msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"Läser den betade representationen av ett objekt från det öppna filobjektet "
"som anges i konstruktören och returnerar den rekonstruerade objekthierarkin "
"som anges däri.  Byte efter den betade representationen av objektet "
"ignoreras."

msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "Ger som standard upphov till ett :exc:`UnpicklingError`."

msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"Om definierat bör :meth:`persistent_load` returnera det objekt som anges av "
"det beständiga ID:t *pid*.  Om ett ogiltigt beständigt ID påträffas bör ett :"
"exc:`UnpicklingError` uppstå."

msgid ""
"Add the default implementation of this method in the C implementation of :"
"class:`!Unpickler`."
msgstr ""
"Lägg till standardimplementationen av denna metod i C-implementationen av :"
"class:`!Unpickler`."

msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"Importera *modul* om det behövs och returnera objektet som heter *namn* från "
"den, där argumenten *modul* och *namn* är :class:`str`-objekt.  Observera "
"att, till skillnad från vad namnet antyder, används :meth:`find_class` också "
"för att hitta funktioner."

msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"Underklasser kan åsidosätta detta för att få kontroll över vilken typ av "
"objekt och hur de kan laddas, vilket potentiellt kan minska "
"säkerhetsriskerna. Se :ref:`pickle-restrict` för mer information."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``pickle.find_class`` med "
"argumenten ``module``, ``name``."

msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"Ett omslag för en buffert som representerar betningsbar data.  *buffer* "
"måste vara ett :ref:``buffer-providing <bufferobjects>`-objekt, t.ex. ett :"
"term:`bytesliknande objekt` eller en N-dimensionell array."

msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""
":class:`PickleBuffer` är i sig en buffertleverantör, därför är det möjligt "
"att skicka den till andra API:er som förväntar sig ett buffertlevererande "
"objekt, t.ex. :class:`memoryview`."

msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
":class:`PickleBuffer`-objekt kan endast serialiseras med pickle protokoll 5 "
"eller högre.  De är kvalificerade för :ref:``out-of-band serialization "
"<pickle-oob>`."

msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"Returnerar en :class:`memoryview` av minnesområdet som ligger bakom denna "
"buffert. Det returnerade objektet är en endimensionell, C-sluten minnesvy "
"med format ``B`` (osignerade byte). :exc:`BufferError` uppstår om bufferten "
"varken är C- eller Fortran-sluten."

msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr ""
"Frigör den underliggande bufferten som exponeras av PickleBuffer-objektet."

msgid "What can be pickled and unpickled?"
msgstr "Vad kan vara inlagt och oinlagt?"

msgid "The following types can be pickled:"
msgstr "Följande typer kan picklas:"

msgid ""
"built-in constants (``None``, ``True``, ``False``, ``Ellipsis``, and :data:"
"`NotImplemented`);"
msgstr ""
"inbyggda konstanter (``None``, ``True``, ``False``, ``Ellipsis`` och :data:"
"`NotImplemented`);"

msgid "integers, floating-point numbers, complex numbers;"
msgstr "heltal, flyttal, komplexa tal;"

msgid "strings, bytes, bytearrays;"
msgstr "strängar, byte, bytearrayer;"

msgid ""
"tuples, lists, sets, and dictionaries containing only picklable objects;"
msgstr ""
"tupler, listor, mängder och lexikon som endast innehåller plockbara objekt;"

msgid ""
"functions (built-in and user-defined) accessible from the top level of a "
"module (using :keyword:`def`, not :keyword:`lambda`);"
msgstr ""
"funktioner (inbyggda och användardefinierade) som är tillgängliga från den "
"översta nivån i en modul (med :keyword:`def`, inte :keyword:`lambda`);"

msgid "classes accessible from the top level of a module;"
msgstr "klasser som är tillgängliga från den översta nivån i en modul;"

msgid ""
"instances of such classes whose the result of calling :meth:`~object."
"__getstate__` is picklable  (see section :ref:`pickle-inst` for details)."
msgstr ""
"instanser av sådana klasser vars resultat av anropet :meth:`~object."
"__getstate__` är picklable (se avsnitt :ref:`pickle-inst` för detaljer)."

msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"Försök att plocka ut icke-plockbara objekt kommer att ge upphov till "
"undantaget :exc:`PicklingError`; när detta händer kan ett ospecificerat "
"antal byte redan ha skrivits till den underliggande filen.  Att försöka "
"plocka en mycket rekursiv datastruktur kan överskrida det maximala "
"rekursionsdjupet, ett :exc:`RecursionError` kommer att uppstå i detta fall.  "
"Du kan försiktigt höja denna gräns med :func:`sys.setrecursionlimit`."

msgid ""
"Note that functions (built-in and user-defined) are pickled by fully :term:"
"`qualified name`, not by value. [#]_  This means that only the function name "
"is pickled, along with the name of the containing module and classes.  "
"Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"Observera att funktioner (inbyggda och användardefinierade) betas med fullt :"
"term:`kvalificerat namn`, inte med värde. [#]_ Detta innebär att endast "
"funktionsnamnet betas, tillsammans med namnet på den modul och de klasser "
"som innehåller funktionen.  Varken funktionens kod eller några av dess "
"funktionsattribut betas.  Den definierande modulen måste alltså vara "
"importerbar i unpickling-miljön, och modulen måste innehålla det namngivna "
"objektet, annars kommer ett undantag att uppstå. [#]_"

msgid ""
"Similarly, classes are pickled by fully qualified name, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"På samma sätt betas klasser med fullt kvalificerat namn, så samma "
"restriktioner i betningsmiljön gäller.  Observera att ingen av klassens kod "
"eller data betas in, så i följande exempel återställs inte klassattributet "
"``attr`` i unpickling-miljön::"

msgid ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"
msgstr ""
"class Foo:\n"
"    attr = 'A class attribute'\n"
"\n"
"picklestring = pickle.dumps(Foo)"

msgid ""
"These restrictions are why picklable functions and classes must be defined "
"at the top level of a module."
msgstr ""
"Dessa begränsningar är skälet till att picklbara funktioner och klasser "
"måste definieras på den översta nivån i en modul."

msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`~object."
"__setstate__` method."
msgstr ""
"På samma sätt, när klassinstanser betas, betas inte deras klass kod och data "
"tillsammans med dem.  Det är bara instansens data som syltas.  Detta görs "
"med avsikt, så att du kan åtgärda buggar i en klass eller lägga till metoder "
"i klassen och fortfarande ladda objekt som skapades med en tidigare version "
"av klassen.  Om du planerar att ha långlivade objekt som kommer att se många "
"versioner av en klass kan det vara värt att lägga in ett versionsnummer i "
"objekten så att lämpliga konverteringar kan göras av klassens :meth:`~object."
"__setstate__`-metod."

msgid "Pickling Class Instances"
msgstr "Beizning av klassinstanser"

msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"I det här avsnittet beskriver vi de allmänna mekanismer som finns "
"tillgängliga för att definiera, anpassa och styra hur klassinstanser ska "
"picklas och unpicklas."

msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`~object."
"__init__` method is usually *not* invoked.  The default behaviour first "
"creates an uninitialized instance and then restores the saved attributes.  "
"The following code shows an implementation of this behaviour::"
msgstr ""
"I de flesta fall behövs ingen ytterligare kod för att göra instanser "
"plockbara.  Som standard kommer pickle att hämta klassen och attributen för "
"en instans via introspektion. När en klassinstans avplockas anropas dess :"
"meth:`~object.__init__`-metod vanligtvis *inte*.  Standardbeteendet skapar "
"först en oinitialiserad instans och återställer sedan de sparade "
"attributen.  Följande kod visar en implementering av detta beteende::"

msgid ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"
msgstr ""
"def save(obj):\n"
"    return (obj.__class__, obj.__dict__)\n"
"\n"
"def restore(cls, attributes):\n"
"    obj = cls.__new__(cls)\n"
"    obj.__dict__.update(attributes)\n"
"    return obj"

msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"Klasser kan ändra standardbeteendet genom att tillhandahålla en eller flera "
"specialmetoder:"

msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"I protokoll 2 och nyare kan klasser som implementerar metoden :meth:"
"`__getnewargs_ex__` diktera de värden som skickas till metoden :meth:"
"`__new__` vid unpickling.  Metoden måste returnera ett par ``(args, "
"kwargs)`` där *args* är en tupel av positionella argument och *kwargs* en "
"dictionary av namngivna argument för att konstruera objektet.  Dessa kommer "
"att skickas till :meth:`__new__`-metoden vid uppplockning."

msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"Du bör implementera denna metod om metoden :meth:`__new__` i din klass "
"kräver argument som endast innehåller nyckelord.  I annat fall rekommenderas "
"det av kompatibilitetsskäl att implementera :meth:`__getnewargs__`."

msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` används nu i protokoll 2 och 3."

msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Denna metod tjänar ett liknande syfte som :meth:`__getnewargs_ex__`, men "
"stöder endast positionella argument.  Den måste returnera en tupel av "
"argument ``args`` som kommer att skickas till :meth:`__new__`` metoden vid "
"uppplockning."

msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
":meth:`__getnewargs__` kommer inte att anropas om :meth:`__getnewargs_ex__` "
"är definierad."

msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"Före Python 3.6 anropades :meth:`__getnewargs__` i stället för :meth:"
"`__getnewargs_ex__` i protokoll 2 och 3."

msgid ""
"Classes can further influence how their instances are pickled by overriding "
"the method :meth:`__getstate__`.  It is called and the returned object is "
"pickled as the contents for the instance, instead of a default state. There "
"are several cases:"
msgstr ""
"Klasser kan ytterligare påverka hur deras instanser picklas genom att "
"åsidosätta metoden :meth:`__getstate__`.  Den anropas och det returnerade "
"objektet picklas som innehåll för instansen, istället för ett "
"standardtillstånd. Det finns flera fall:"

msgid ""
"For a class that has no instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``None``."
msgstr ""
"För en klass som inte har någon instans :attr:`~object.__dict__` och ingen :"
"attr:`~object.__slots__` är standardtillståndet ``None``."

msgid ""
"For a class that has an instance :attr:`~object.__dict__` and no :attr:"
"`~object.__slots__`, the default state is ``self.__dict__``."
msgstr ""
"För en klass som har en instans :attr:`~object.__dict__` och ingen :attr:"
"`~object.__slots__`, är standardtillståndet ``self.__dict__``."

msgid ""
"For a class that has an instance :attr:`~object.__dict__` and :attr:`~object."
"__slots__`, the default state is a tuple consisting of two dictionaries:  "
"``self.__dict__``, and a dictionary mapping slot names to slot values.  Only "
"slots that have a value are included in the latter."
msgstr ""
"För en klass som har en instans :attr:`~object.__dict__` och :attr:`~object."
"__slots__` är standardtillståndet en tupel som består av två lexikon:  "
"``self.__dict__`` och en ordbok som mappar slotnamn till slotvärden.  Endast "
"slots som har ett värde ingår i den senare."

msgid ""
"For a class that has :attr:`~object.__slots__` and no instance :attr:"
"`~object.__dict__`, the default state is a tuple whose first item is "
"``None`` and whose second item is a dictionary mapping slot names to slot "
"values described in the previous bullet."
msgstr ""
"För en klass som har :attr:`~object.__slots__` och ingen instans :attr:"
"`~object.__dict__`, är standardtillståndet en tupel vars första post är "
"``None`` och vars andra post är en ordbok som mappar slotnamn till "
"slotvärden som beskrivs i föregående punkt."

msgid ""
"Added the default implementation of the ``__getstate__()`` method in the :"
"class:`object` class."
msgstr ""
"Lade till standardimplementeringen av metoden ``__getstate__()`` i klassen :"
"class:`object`."

msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"Vid unpickling, om klassen definierar :meth:`__setstate__`, anropas den med "
"det unpicklade tillståndet.  I det fallet finns det inget krav på att state-"
"objektet ska vara en dictionary.  Annars måste det inlagda tillståndet vara "
"en ordbok och dess objekt tilldelas den nya instansens ordbok."

msgid ""
"If :meth:`__reduce__` returns a state with value ``None`` at pickling, the :"
"meth:`__setstate__` method will not be called upon unpickling."
msgstr ""
"Om :meth:`__reduce__` returnerar ett tillstånd med värdet ``None`` vid "
"pickling, kommer metoden :meth:`__setstate__` inte att anropas vid "
"unpickling."

msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`~object.__getstate__` and :meth:`~object."
"__setstate__`."
msgstr ""
"Se avsnittet :ref:`pickle-state` för mer information om hur du använder "
"metoderna :meth:`~object.__getstate__` och :meth:`~object.__setstate__`."

msgid ""
"At unpickling time, some methods like :meth:`~object.__getattr__`, :meth:"
"`~object.__getattribute__`, or :meth:`~object.__setattr__` may be called "
"upon the instance.  In case those methods rely on some internal invariant "
"being true, the type should implement :meth:`~object.__new__` to establish "
"such an invariant, as :meth:`~object.__init__` is not called when unpickling "
"an instance."
msgstr ""
"Vid unpickling-tiden kan vissa metoder som :meth:`~object.__getattr__`, :"
"meth:`~object.__getattribute__` eller :meth:`~object.__setattr__` anropas på "
"instansen.  Om dessa metoder är beroende av att någon intern invariant är "
"sann, bör typen implementera :meth:`~object.__new__` för att etablera en "
"sådan invariant, eftersom :meth:`~object.__init__` inte anropas när en "
"instans plockas upp."

msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`~object.__reduce__` special method.  The copy protocol provides a "
"unified interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"Som vi kommer att se använder pickle inte direkt de metoder som beskrivs "
"ovan.  I själva verket är dessa metoder en del av kopieringsprotokollet som "
"implementerar specialmetoden :meth:`~object.__reduce__`.  "
"Kopieringsprotokollet ger ett enhetligt gränssnitt för att hämta de data som "
"behövs för att plocka och kopiera objekt. [#]_"

msgid ""
"Although powerful, implementing :meth:`~object.__reduce__` directly in your "
"classes is error prone.  For this reason, class designers should use the "
"high-level interface (i.e., :meth:`~object.__getnewargs_ex__`, :meth:"
"`~object.__getstate__` and :meth:`~object.__setstate__`) whenever possible.  "
"We will show, however, cases where using :meth:`!__reduce__` is the only "
"option or leads to more efficient pickling or both."
msgstr ""
"Även om :meth:`~object.__reduce__` är kraftfull är det felbenäget att "
"implementera den direkt i dina klasser.  Av denna anledning bör "
"klassutvecklare använda högnivågränssnittet (dvs. :meth:`~object."
"__getnewargs_ex__`, :meth:`~object.__getstate__` och :meth:`~object."
"__setstate__`) när det är möjligt.  Vi kommer dock att visa fall där "
"användning av :meth:`!__reduce__` är det enda alternativet eller leder till "
"effektivare betning eller bådadera."

msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"Gränssnittet är för närvarande definierat enligt följande.  Metoden :meth:"
"`__reduce__` tar inget argument och skall returnera antingen en sträng eller "
"helst en tupel (det returnerade objektet kallas ofta för "
"\"reduktionsvärdet\")."

msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"Om en sträng returneras ska strängen tolkas som namnet på en global "
"variabel.  Det bör vara objektets lokala namn i förhållande till dess modul; "
"pickle-modulen söker i modulnamnrymden för att fastställa objektets modul.  "
"Detta beteende är typiskt användbart för singletons."

msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"När en tupel returneras måste den vara mellan två och sex poster lång. "
"Valfria objekt kan antingen utelämnas, eller så kan ``None`` anges som "
"värde.  Semantiken för varje objekt är i ordning:"

msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""
"Ett anropsbart objekt som kommer att anropas för att skapa den första "
"versionen av objektet."

msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"En tupel av argument för det anropbara objektet.  En tom tupel måste anges "
"om det anropbara objektet inte accepterar något argument."

msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"Eventuellt objektets tillstånd, som kommer att skickas till objektets :meth:"
"`__setstate__`-metod enligt tidigare beskrivning.  Om objektet inte har "
"någon sådan metod måste värdet vara en dictionary och det kommer att läggas "
"till i objektets attribut :attr:`~object.__dict__`."

msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"ref:`append and extend methods <typesseq-common>` with the appropriate "
"signature.  (Whether :meth:`!append` or :meth:`!extend` is used depends on "
"which pickle protocol version is used as well as the number of items to "
"append, so both must be supported.)"
msgstr ""
"Eventuellt en iterator (och inte en sekvens) som ger successiva objekt. "
"Dessa objekt kommer att läggas till objektet antingen med hjälp av ``obj."
"append(item)`` eller, i batch, med hjälp av ``obj.extend(list_of_items)``. "
"Detta används främst för list-subklasser, men kan användas av andra klasser "
"så länge de har :ref:`append och extend metoder <typesseq-common>` med "
"lämplig signatur.  (Om :meth:`!append` eller :meth:`!extend` används beror "
"på vilken version av pickle-protokollet som används samt antalet objekt som "
"ska läggas till, så båda måste stödjas)"

msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"Eventuellt en iterator (inte en sekvens) som ger successiva nyckel-värde-"
"par.  Dessa objekt kommer att lagras i objektet med ``obj[key] = value``.  "
"Detta används främst för dictionary-subklasser, men kan användas av andra "
"klasser så länge de implementerar :meth:`__setitem__`."

msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""
"Eventuellt en anropbar funktion med signaturen ``(obj, state)``. Denna "
"anropsbarhet tillåter användaren att programmatiskt kontrollera "
"tillståndsuppdateringsbeteendet för ett specifikt objekt, istället för att "
"använda ``obj`` statiska :meth:`__setstate__` metod. Om inte ``None``, "
"kommer denna anropsbarhet att ha prioritet över ``obj`` :meth:`__setstate__`."

msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "Det valfria sjätte tuple-objektet, ``(obj, state)``, lades till."

msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"Alternativt kan en :meth:`__reduce_ex__`-metod definieras.  Den enda "
"skillnaden är att denna metod ska ta ett enda heltalsargument, "
"protokollversionen.  När den definieras kommer pickle att föredra den "
"framför :meth:`__reduce__`-metoden.  Dessutom blir :meth:`__reduce__` "
"automatiskt en synonym för den utökade versionen.  Huvudanvändningen för "
"denna metod är att tillhandahålla bakåtkompatibla reduce-värden för äldre "
"Python-versioner."

msgid "Persistence of External Objects"
msgstr "Persistens för externa objekt"

msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"För att underlätta objektets beständighet stöder modulen :mod:`pickle` "
"begreppet referens till ett objekt utanför den betade dataströmmen.  Sådana "
"objekt refereras till med ett beständigt ID, som antingen bör vara en sträng "
"med alfanumeriska tecken (för protokoll 0) [#]_ eller bara ett godtyckligt "
"objekt (för alla nyare protokoll)."

msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
"Upplösningen av sådana persistenta ID:n definieras inte av modulen :mod:"
"`pickle`; den delegerar denna upplösning till de användardefinierade "
"metoderna på picklern och unpickllern, :meth:`~Pickler.persistent_id` "
"respektive :meth:`~Unpickler.persistent_load`."

msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"För att plocka objekt som har ett externt beständigt ID måste plockaren ha "
"en egen :meth:`~Pickler.persistent_id`-metod som tar ett objekt som argument "
"och returnerar antingen ``None`` eller det beständiga ID:t för objektet. När "
"``None`` returneras betar betaren helt enkelt objektet som normalt. När en "
"persistent ID-sträng returneras kommer picklern att pickla det objektet, "
"tillsammans med en markör så att unpickllern känner igen det som ett "
"persistent ID."

msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"För att unpickla externa objekt måste unpicklern ha en anpassad :meth:"
"`~Unpickler.persistent_load`-metod som tar ett persistent ID-objekt och "
"returnerar det refererade objektet."

msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"Här följer ett omfattande exempel som visar hur persistent ID kan användas "
"för att plocka externa objekt genom referens."

msgid ""
"# Simple example presenting how persistent ID can be used to pickle\n"
"# external objects by reference.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Simple class representing a record in our database.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Instead of pickling MemoRecord as a regular class instance, we "
"emit a\n"
"        # persistent ID.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Here, our persistent ID is simply a tuple, containing a tag "
"and a\n"
"            # key, which refers to a specific record in the database.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # If obj does not have a persistent ID, return None. This means "
"obj\n"
"            # needs to be pickled as usual.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # This method is invoked whenever a persistent ID is encountered.\n"
"        # Here, pid is the tuple returned by DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Fetch the referenced record from the database and return it.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", "
"(str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Always raises an error if you cannot return the correct "
"object.\n"
"            # Otherwise, the unpickler will think None is the object "
"referenced\n"
"            # by the persistent ID.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Initialize and populate our database.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task "
"TEXT)\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Fetch the records to be pickled.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Save the records using our custom DBPickler.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Update a record, just for good measure.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # Load the records from the pickle data stream.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"# Enkelt exempel som visar hur persistent ID kan användas för att plocka\n"
"# externa objekt genom referens.\n"
"\n"
"import pickle\n"
"import sqlite3\n"
"from collections import namedtuple\n"
"\n"
"# Simple class representing a record in our database.\n"
"MemoRecord = namedtuple(\"MemoRecord\", \"key, task\")\n"
"\n"
"class DBPickler(pickle.Pickler):\n"
"\n"
"    def persistent_id(self, obj):\n"
"        # Instead of pickling MemoRecord as a regular class instance, we "
"emit a\n"
"        # persistent ID.\n"
"        if isinstance(obj, MemoRecord):\n"
"            # Here, our persistent ID is simply a tuple, containing a tag "
"and a\n"
"            # key, which refers to a specific record in the database.\n"
"            return (\"MemoRecord\", obj.key)\n"
"        else:\n"
"            # If obj does not have a persistent ID, return None. This means "
"obj\n"
"            # needs to be pickled as usual.\n"
"            return None\n"
"\n"
"\n"
"class DBUnpickler(pickle.Unpickler):\n"
"\n"
"    def __init__(self, file, connection):\n"
"        super().__init__(file)\n"
"        self.connection = connection\n"
"\n"
"    def persistent_load(self, pid):\n"
"        # This method is invoked whenever a persistent ID is encountered.\n"
"        # Here, pid is the tuple returned by DBPickler.\n"
"        cursor = self.connection.cursor()\n"
"        type_tag, key_id = pid\n"
"        if type_tag == \"MemoRecord\":\n"
"            # Fetch the referenced record from the database and return it.\n"
"            cursor.execute(\"SELECT * FROM memos WHERE key=?\", "
"(str(key_id),))\n"
"            key, task = cursor.fetchone()\n"
"            return MemoRecord(key, task)\n"
"        else:\n"
"            # Always raises an error if you cannot return the correct "
"object.\n"
"            # Otherwise, the unpickler will think None is the object "
"referenced\n"
"            # by the persistent ID.\n"
"            raise pickle.UnpicklingError(\"unsupported persistent object\")\n"
"\n"
"\n"
"def main():\n"
"    import io\n"
"    import pprint\n"
"\n"
"    # Initialize and populate our database.\n"
"    conn = sqlite3.connect(\":memory:\")\n"
"    cursor = conn.cursor()\n"
"    cursor.execute(\"CREATE TABLE memos(key INTEGER PRIMARY KEY, task "
"TEXT)\")\n"
"    tasks = (\n"
"        'give food to fish',\n"
"        'prepare group meeting',\n"
"        'fight with a zebra',\n"
"        )\n"
"    for task in tasks:\n"
"        cursor.execute(\"INSERT INTO memos VALUES(NULL, ?)\", (task,))\n"
"\n"
"    # Fetch the records to be pickled.\n"
"    cursor.execute(\"SELECT * FROM memos\")\n"
"    memos = [MemoRecord(key, task) for key, task in cursor]\n"
"    # Save the records using our custom DBPickler.\n"
"    file = io.BytesIO()\n"
"    DBPickler(file).dump(memos)\n"
"\n"
"    print(\"Pickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"    # Update a record, just for good measure.\n"
"    cursor.execute(\"UPDATE memos SET task='learn italian' WHERE key=1\")\n"
"\n"
"    # Load the records from the pickle data stream.\n"
"    file.seek(0)\n"
"    memos = DBUnpickler(file, conn).load()\n"
"\n"
"    print(\"Unpickled records:\")\n"
"    pprint.pprint(memos)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

msgid "Dispatch Tables"
msgstr "Expeditionsbord"

msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"Om man vill anpassa betningen av vissa klasser utan att störa någon annan "
"kod som är beroende av betningen, kan man skapa en betare med en privat "
"dispatch-tabell."

msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`!copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`!copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"Den globala dispatch-tabellen som hanteras av modulen :mod:`copyreg` är "
"tillgänglig som :data:`!copyreg.dispatch_table`.  Därför kan man välja att "
"använda en modifierad kopia av :data:`!copyreg.dispatch_table` som en privat "
"dispatch-tabell."

msgid "For example ::"
msgstr "Till exempel ::"

msgid ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"
msgstr ""
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)\n"
"p.dispatch_table = copyreg.dispatch_table.copy()\n"
"p.dispatch_table[SomeClass] = reduce_SomeClass"

msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"skapar en instans av :class:`pickle.Pickler` med en privat dispatch-tabell "
"som hanterar klassen ``SomeClass`` speciellt.  Alternativt kan koden ::"

msgid ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"
msgstr ""
"class MyPickler(pickle.Pickler):\n"
"    dispatch_table = copyreg.dispatch_table.copy()\n"
"    dispatch_table[SomeClass] = reduce_SomeClass\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)"

msgid ""
"does the same but all instances of ``MyPickler`` will by default share the "
"private dispatch table.  On the other hand, the code ::"
msgstr ""
"gör samma sak men alla instanser av ``MyPickler`` kommer som standard att "
"dela den privata dispatch-tabellen.  Å andra sidan, koden ::"

msgid ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"
msgstr ""
"copyreg.pickle(SomeClass, reduce_SomeClass)\n"
"f = io.BytesIO()\n"
"p = pickle.Pickler(f)"

msgid ""
"modifies the global dispatch table shared by all users of the :mod:`copyreg` "
"module."
msgstr ""
"ändrar den globala fördelningstabellen som delas av alla användare av "
"modulen :mod:`copyreg`."

msgid "Handling Stateful Objects"
msgstr "Hantering av Stateful-objekt"

msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`!TextReader` class below opens a text file, and returns the line "
"number and line contents each time its :meth:`!readline` method is called. "
"If a :class:`!TextReader` instance is pickled, all attributes *except* the "
"file object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:`!"
"__setstate__` and :meth:`!__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"Här är ett exempel som visar hur man ändrar pickling-beteendet för en klass. "
"Klassen :class:`!TextReader` nedan öppnar en textfil och returnerar "
"radnummer och radinnehåll varje gång dess metod :meth:`!readline` anropas. "
"Om en :class:`!TextReader`-instans är picklad sparas alla attribut *utom* "
"objektmedlemmen file. När instansen avpicklas öppnas filen igen och "
"läsningen återupptas från den senaste platsen. Metoderna :meth:`!"
"__setstate__` och :meth:`!__getstate__` används för att implementera detta "
"beteende. ::"

msgid ""
"class TextReader:\n"
"    \"\"\"Print and number lines in a text file.\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # Copy the object's state from self.__dict__ which contains\n"
"        # all our instance attributes. Always use the dict.copy()\n"
"        # method to avoid modifying the original state.\n"
"        state = self.__dict__.copy()\n"
"        # Remove the unpicklable entries.\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # Restore instance attributes (i.e., filename and lineno).\n"
"        self.__dict__.update(state)\n"
"        # Restore the previously opened file's state. To do so, we need to\n"
"        # reopen it and read from it until the line count is restored.\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # Finally, save the file.\n"
"        self.file = file"
msgstr ""
"class TextReader:\n"
"    \"\"\"Print and number lines in a text file.\"\"\"\n"
"\n"
"    def __init__(self, filename):\n"
"        self.filename = filename\n"
"        self.file = open(filename)\n"
"        self.lineno = 0\n"
"\n"
"    def readline(self):\n"
"        self.lineno += 1\n"
"        line = self.file.readline()\n"
"        if not line:\n"
"            return None\n"
"        if line.endswith('\\n'):\n"
"            line = line[:-1]\n"
"        return \"%i: %s\" % (self.lineno, line)\n"
"\n"
"    def __getstate__(self):\n"
"        # Copy the object's state from self.__dict__ which contains\n"
"        # all our instance attributes. Always use the dict.copy()\n"
"        # method to avoid modifying the original state.\n"
"        state = self.__dict__.copy()\n"
"        # Remove the unpicklable entries.\n"
"        del state['file']\n"
"        return state\n"
"\n"
"    def __setstate__(self, state):\n"
"        # Restore instance attributes (i.e., filename and lineno).\n"
"        self.__dict__.update(state)\n"
"        # Restore the previously opened file's state. To do so, we need to\n"
"        # reopen it and read from it until the line count is restored.\n"
"        file = open(self.filename)\n"
"        for _ in range(self.lineno):\n"
"            file.readline()\n"
"        # Finally, save the file.\n"
"        self.file = file"

msgid "A sample usage might be something like this::"
msgstr "Ett exempel på användning kan vara ungefär så här::"

msgid ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"
msgstr ""
">>> reader = TextReader(\"hello.txt\")\n"
">>> reader.readline()\n"
"'1: Hello world!'\n"
">>> reader.readline()\n"
"'2: I am line number two.'\n"
">>> new_reader = pickle.loads(pickle.dumps(reader))\n"
">>> new_reader.readline()\n"
"'3: Goodbye!'"

msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "Anpassad reduktion för typer, funktioner och andra objekt"

msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
"Ibland kanske :attr:`~Pickler.dispatch_table` inte är tillräckligt flexibel. "
"I synnerhet kanske vi vill anpassa betningen baserat på ett annat kriterium "
"än objektets typ, eller så kanske vi vill anpassa betningen av funktioner "
"och klasser."

msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`~object.__reduce__`). It can "
"alternatively return :data:`NotImplemented` to fallback to the traditional "
"behavior."
msgstr ""
"För dessa fall är det möjligt att subklassa från :class:`Pickler`-klassen "
"och implementera en :meth:`~Pickler.reducer_override`-metod. Denna metod kan "
"returnera en godtycklig reduktionstupel (se :meth:`~object.__reduce__`). Den "
"kan alternativt returnera :data:`NotImplemented` för att återgå till det "
"traditionella beteendet."

msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""
"Om både :attr:`~Pickler.dispatch_table` och :meth:`~Pickler."
"reducer_override` är definierade, så har metoden :meth:`~Pickler."
"reducer_override` prioritet."

msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""
"Av prestandaskäl får :meth:`~Pickler.reducer_override` inte anropas för "
"följande objekt: ``None``, ``True``, ``False`` och exakta instanser av :"
"class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :class:`dict`, :"
"class:`set`, :class:`frozenset`, :class:`list` och :class:`tuple`."

msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr ""
"Här är ett enkelt exempel där vi tillåter betning och rekonstruktion av en "
"given klass::"

msgid ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Custom reducer for MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # For any other object, fallback to usual reduction\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"
msgstr ""
"import io\n"
"import pickle\n"
"\n"
"class MyClass:\n"
"    my_attribute = 1\n"
"\n"
"class MyPickler(pickle.Pickler):\n"
"    def reducer_override(self, obj):\n"
"        \"\"\"Custom reducer for MyClass.\"\"\"\n"
"        if getattr(obj, \"__name__\", None) == \"MyClass\":\n"
"            return type, (obj.__name__, obj.__bases__,\n"
"                          {'my_attribute': obj.my_attribute})\n"
"        else:\n"
"            # For any other object, fallback to usual reduction\n"
"            return NotImplemented\n"
"\n"
"f = io.BytesIO()\n"
"p = MyPickler(f)\n"
"p.dump(MyClass)\n"
"\n"
"del MyClass\n"
"\n"
"unpickled_class = pickle.loads(f.getvalue())\n"
"\n"
"assert isinstance(unpickled_class, type)\n"
"assert unpickled_class.__name__ == \"MyClass\"\n"
"assert unpickled_class.my_attribute == 1"

msgid "Out-of-band Buffers"
msgstr "Buffertar utanför bandet"

msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"I vissa sammanhang används modulen :mod:`pickle` för att överföra stora "
"mängder data.  Därför kan det vara viktigt att minimera antalet minneskopior "
"för att bevara prestanda och resursförbrukning.  Normal användning av "
"modulen :mod:`pickle`, som omvandlar en grafliknande struktur av objekt till "
"en sekventiell ström av bytes, innebär dock i sig att data kopieras till och "
"från pickle-strömmen."

msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"Denna begränsning kan undvikas om både *provider* (implementationen av de "
"objekttyper som ska överföras) och *consumer* (implementationen av "
"kommunikationssystemet) stöder de överföringsmöjligheter utanför bandet som "
"tillhandahålls av pickle protocol 5 och högre."

msgid "Provider API"
msgstr "Leverantörs-API"

msgid ""
"The large data objects to be pickled must implement a :meth:`~object."
"__reduce_ex__` method specialized for protocol 5 and higher, which returns "
"a :class:`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) "
"for any large data."
msgstr ""
"De stora dataobjekt som ska betas måste implementera en :meth:`~object."
"__reduce_ex__`-metod som är specialiserad för protokoll 5 och högre, som "
"returnerar en :class:`PickleBuffer`-instans (i stället för t.ex. ett :class:"
"`bytes`-objekt) för alla stora data."

msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
"Ett :class:`PickleBuffer`-objekt *signalerar* att den underliggande "
"bufferten är kvalificerad för dataöverföring utanför bandet.  Dessa objekt "
"förblir kompatibla med normal användning av modulen :mod:`pickle`.  Men "
"konsumenter kan också välja att tala om för :mod:`pickle` att de kommer att "
"hantera dessa buffertar själva."

msgid "Consumer API"
msgstr "API för konsumenter"

msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"Ett kommunikationssystem kan möjliggöra anpassad hantering av :class:"
"`PickleBuffer`-objekt som genereras vid serialisering av en objektgraf."

msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""
"På sändningssidan måste den skicka ett *buffer_callback*-argument till :"
"class:`Pickler` (eller till :func:`dump` eller :func:`dumps`-funktionen), "
"som kommer att anropas med varje :class:`PickleBuffer` som genereras när "
"objektgrafen plockas.  Buffertar som ackumuleras av *buffer_callback* kommer "
"inte att få sina data kopierade till pickle-strömmen, endast en billig "
"markör kommer att infogas."

msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""
"På mottagarsidan måste den skicka ett *buffers*-argument till :class:"
"`Unpickler` (eller till funktionen :func:`load` eller :func:`loads`), som är "
"en iterabel av de buffertar som skickades till *buffer_callback*. Denna "
"iterabel bör producera buffertar i samma ordning som de skickades till "
"*buffer_callback*.  Dessa buffertar kommer att tillhandahålla de data som "
"förväntas av rekonstruktörerna av de objekt vars betning producerade de "
"ursprungliga :class:`PickleBuffer`-objekten."

msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""
"Mellan sändar- och mottagarsidan är kommunikationssystemet fritt att "
"implementera sin egen överföringsmekanism för buffertar utanför bandet. "
"Potentiella optimeringar inkluderar användning av delat minne eller "
"datatypberoende komprimering."

msgid "Example"
msgstr "Exempel"

msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""
"Här är ett trivialt exempel där vi implementerar en :class:`bytearray`-"
"underklass som kan delta i buffer pickling utanför bandet::"

msgid ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer is forbidden with pickle protocols <= 4.\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # Get a handle over the original buffer object\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # Original buffer object is a ZeroCopyByteArray, return it\n"
"                # as-is.\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"
msgstr ""
"class ZeroCopyByteArray(bytearray):\n"
"\n"
"    def __reduce_ex__(self, protocol):\n"
"        if protocol >= 5:\n"
"            return type(self)._reconstruct, (PickleBuffer(self),), None\n"
"        else:\n"
"            # PickleBuffer is forbidden with pickle protocols <= 4.\n"
"            return type(self)._reconstruct, (bytearray(self),)\n"
"\n"
"    @classmethod\n"
"    def _reconstruct(cls, obj):\n"
"        with memoryview(obj) as m:\n"
"            # Get a handle over the original buffer object\n"
"            obj = m.obj\n"
"            if type(obj) is cls:\n"
"                # Original buffer object is a ZeroCopyByteArray, return it\n"
"                # as-is.\n"
"                return obj\n"
"            else:\n"
"                return cls(obj)"

msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"Rekonstruktören (klassmetoden ``_reconstruct``) returnerar buffertens "
"tillhandahållande objekt om det har rätt typ.  Detta är ett enkelt sätt att "
"simulera nollkopieringsbeteende i detta leksaksexempel."

msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""
"På konsumentsidan kan vi plocka upp dessa objekt på vanligt sätt, vilket när "
"det är oserialiserat ger oss en kopia av det ursprungliga objektet::"

msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: a copy was made"
msgstr ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"data = pickle.dumps(b, protocol=5)\n"
"new_b = pickle.loads(data)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # False: a copy was made"

msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"Men om vi skickar en *buffer_callback* och sedan ger tillbaka de "
"ackumulerade buffertarna när vi unserialiserar, kan vi få tillbaka det "
"ursprungliga objektet::"

msgid ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: no copy was made"
msgstr ""
"b = ZeroCopyByteArray(b\"abc\")\n"
"buffers = []\n"
"data = pickle.dumps(b, protocol=5, buffer_callback=buffers.append)\n"
"new_b = pickle.loads(data, buffers=buffers)\n"
"print(b == new_b)  # True\n"
"print(b is new_b)  # True: no copy was made"

msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"Detta exempel begränsas av det faktum att :class:`bytearray` allokerar sitt "
"eget minne: du kan inte skapa en :class:`bytearray`-instans som backas upp "
"av ett annat objekts minne.  Tredjepartsdatatyper som NumPy-arrays har dock "
"inte denna begränsning och tillåter användning av zero-copy pickling (eller "
"att göra så få kopior som möjligt) vid överföring mellan olika processer "
"eller system."

msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- Pickle protokoll 5 med data utanför bandet"

msgid "Restricting Globals"
msgstr "Begränsning av globaler"

msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"Som standard importerar unpickling alla klasser eller funktioner som den "
"hittar i pickle-data.  För många applikationer är detta beteende "
"oacceptabelt eftersom det tillåter unpickling att importera och anropa "
"godtycklig kod.  Tänk bara på vad den här handgjorda pickle-dataströmmen gör "
"när den laddas::"

msgid ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"
msgstr ""
">>> import pickle\n"
">>> pickle.loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"hello world\n"
"0"

msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"I det här exemplet importerar unpickler funktionen :func:`os.system` och "
"använder sedan strängargumentet \"echo hello world\".  Även om detta exempel "
"är ofarligt är det inte svårt att föreställa sig ett exempel som kan skada "
"ditt system."

msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"Av denna anledning kanske du vill kontrollera vad som blir unpickled genom "
"att anpassa :meth:`Unpickler.find_class`.  Till skillnad från vad namnet "
"antyder anropas :meth:`Unpickler.find_class` när en global (dvs. en klass "
"eller en funktion) begärs.  Det är alltså möjligt att antingen helt förbjuda "
"globaler eller begränsa dem till en säker delmängd."

msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""
"Här är ett exempel på en unpickler som tillåter att endast ett fåtal säkra "
"klasser från modulen :mod:`builtins` laddas::"

msgid ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # Only allow safe classes from builtins.\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # Forbid everything else.\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"
msgstr ""
"import builtins\n"
"import io\n"
"import pickle\n"
"\n"
"safe_builtins = {\n"
"    'range',\n"
"    'complex',\n"
"    'set',\n"
"    'frozenset',\n"
"    'slice',\n"
"}\n"
"\n"
"class RestrictedUnpickler(pickle.Unpickler):\n"
"\n"
"    def find_class(self, module, name):\n"
"        # Only allow safe classes from builtins.\n"
"        if module == \"builtins\" and name in safe_builtins:\n"
"            return getattr(builtins, name)\n"
"        # Forbid everything else.\n"
"        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n"
"                                     (module, name))\n"
"\n"
"def restricted_loads(s):\n"
"    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n"
"    return RestrictedUnpickler(io.BytesIO(s)).load()"

msgid "A sample usage of our unpickler working as intended::"
msgstr "Ett exempel på användning av vår unpickler som fungerar som avsett::"

msgid ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"
msgstr ""
">>> restricted_loads(pickle.dumps([1, 2, range(15)]))\n"
"[1, 2, range(0, 15)]\n"
">>> restricted_loads(b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\")\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'os.system' is forbidden\n"
">>> restricted_loads(b'cbuiltins\\neval\\n'\n"
"...                  b'(S\\'getattr(__import__(\"os\"), \"system\")'\n"
"...                  b'(\"echo hello world\")\\'\\ntR.')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"pickle.UnpicklingError: global 'builtins.eval' is forbidden"

msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"Som våra exempel visar måste du vara försiktig med vad du tillåter att bli "
"unpickled.  Om säkerhet är ett problem kan du därför överväga alternativ som "
"marshalling API i :mod:`xmlrpc.client` eller tredjepartslösningar."

msgid "Performance"
msgstr "Prestanda"

msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"De senaste versionerna av pickle-protokollet (från protokoll 2 och uppåt) "
"har effektiva binära kodningar för flera vanliga funktioner och inbyggda "
"typer. Dessutom har modulen :mod:`pickle` en transparent optimerare skriven "
"i C."

msgid "Examples"
msgstr "Exempel"

msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""
"För den enklaste koden, använd funktionerna :func:`dump` och :func:`load`. ::"

msgid ""
"import pickle\n"
"\n"
"# An arbitrary collection of objects supported by pickle.\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # Pickle the 'data' dictionary using the highest protocol available.\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"
msgstr ""
"import pickle\n"
"\n"
"# An arbitrary collection of objects supported by pickle.\n"
"data = {\n"
"    'a': [1, 2.0, 3+4j],\n"
"    'b': (\"character string\", b\"byte string\"),\n"
"    'c': {None, True, False}\n"
"}\n"
"\n"
"with open('data.pickle', 'wb') as f:\n"
"    # Pickle the 'data' dictionary using the highest protocol available.\n"
"    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)"

msgid "The following example reads the resulting pickled data. ::"
msgstr "I följande exempel läses den resulterande picklade datan. ::"

msgid ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # The protocol version used is detected automatically, so we do not\n"
"    # have to specify it.\n"
"    data = pickle.load(f)"
msgstr ""
"import pickle\n"
"\n"
"with open('data.pickle', 'rb') as f:\n"
"    # The protocol version used is detected automatically, so we do not\n"
"    # have to specify it.\n"
"    data = pickle.load(f)"

msgid "Command-line interface"
msgstr "Kommandoradsgränssnitt"

msgid ""
"The :mod:`pickle` module can be invoked as a script from the command line, "
"it will display contents of the pickle files. However, when the pickle file "
"that you want to examine comes from an untrusted source, ``-m pickletools`` "
"is a safer option because it does not execute pickle bytecode, see :ref:"
"`pickletools CLI usage <pickletools-cli>`."
msgstr ""
"Modulen :mod:`pickle` kan anropas som ett skript från kommandoraden och "
"visar innehållet i pickle-filerna. Men när pickle-filen som du vill "
"undersöka kommer från en opålitlig källa är ``-m pickletools`` ett säkrare "
"alternativ eftersom den inte exekverar pickle-bytekod, se :ref:`pickletools "
"CLI usage <pickletools-cli>``."

msgid "python -m pickle pickle_file [pickle_file ...]"
msgstr "python -m pickle pickle_file [pickle_file ...]"

msgid "The following option is accepted:"
msgstr "Följande alternativ accepteras:"

msgid ""
"A pickle file to read, or ``-`` to indicate reading from standard input."
msgstr ""
"En pickle-fil som ska läsas, eller ``-`` för att ange läsning från "
"standardinmatning."

msgid "Module :mod:`copyreg`"
msgstr "Modul :mod:`copyreg`"

msgid "Pickle interface constructor registration for extension types."
msgstr "Registrering av Pickle-gränssnittskonstruktörer för tilläggstyper."

msgid "Module :mod:`pickletools`"
msgstr "Modul :mod:`pickletools`"

msgid "Tools for working with and analyzing pickled data."
msgstr "Verktyg för att arbeta med och analysera betade data."

msgid "Module :mod:`shelve`"
msgstr "Modul :mod:`shelve`"

msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "Indexerade databaser med objekt; använder :mod:`pickle`."

msgid "Module :mod:`copy`"
msgstr "Modul :mod:`copy`"

msgid "Shallow and deep object copying."
msgstr "Kopiering av grunda och djupa objekt."

msgid "Module :mod:`marshal`"
msgstr "Modul :mod:`marshal`"

msgid "High-performance serialization of built-in types."
msgstr "Högpresterande serialisering av inbyggda typer."

msgid "Footnotes"
msgstr "Fotnoter"

msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "Förväxla inte detta med modulen :mod:`marshal`"

msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"Det är därför som :keyword:`lambda` funktioner inte kan picklas: alla :"
"keyword:`!lambda` funktioner har samma namn: ``<lambda>``."

msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"Det undantag som tas upp kommer troligen att vara ett :exc:`ImportError` "
"eller ett :exc:`AttributeError`, men det kan vara något annat."

msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
"Modulen :mod:`copy` använder detta protokoll för ytliga och djupa "
"kopieringsoperationer."

msgid ""
"The limitation on alphanumeric characters is due to the fact that persistent "
"IDs in protocol 0 are delimited by the newline character.  Therefore if any "
"kind of newline characters occurs in persistent IDs, the resulting pickled "
"data will become unreadable."
msgstr ""
"Begränsningen av alfanumeriska tecken beror på att beständiga ID i protokoll "
"0 avgränsas av tecknet newline.  Om det förekommer någon form av tecken för "
"nya rader i beständiga ID:n blir därför de betade data som blir resultatet "
"oläsliga."

msgid "persistence"
msgstr "bestående"

msgid "persistent"
msgstr "ihållande"

msgid "objects"
msgstr "objekt"

msgid "serializing"
msgstr "serialisering"

msgid "marshalling"
msgstr "marshalling"

msgid "flattening"
msgstr "tillplattning"

msgid "pickling"
msgstr "inläggning"

msgid "External Data Representation"
msgstr "Extern datarepresentation"

msgid "copy"
msgstr "kopiera"

msgid "protocol"
msgstr "protokoll"

msgid "persistent_id (pickle protocol)"
msgstr "persistent_id (pickle-protokoll)"

msgid "persistent_load (pickle protocol)"
msgstr "persistent_load (pickle-protokoll)"

msgid "__getstate__() (copy protocol)"
msgstr "__getstate__() (kopiera protokoll)"

msgid "__setstate__() (copy protocol)"
msgstr "__setstate__() (kopiera protokoll)"

msgid "find_class() (pickle protocol)"
msgstr "find_class() (pickle-protokoll)"
