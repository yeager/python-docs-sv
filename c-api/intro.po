# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"The Application Programmer's Interface to Python gives C and C++ programmers "
"access to the Python interpreter at a variety of levels.  The API is equally "
"usable from C++, but for brevity it is generally referred to as the Python/C "
"API.  There are two fundamentally different reasons for using the Python/C "
"API. The first reason is to write *extension modules* for specific purposes; "
"these are C modules that extend the Python interpreter.  This is probably "
"the most common use.  The second reason is to use Python as a component in a "
"larger application; this technique is generally referred to as :dfn:"
"`embedding` Python in an application."
msgstr ""
"Application Programmer's Interface to Python ger C- och C++-programmerare "
"tillgång till Python-tolken på en mängd olika nivåer.  API:et är lika "
"användbart från C++, men för korthetens skull kallas det i allmänhet för "
"Python/C API.  Det finns två fundamentalt olika anledningar till att använda "
"Python/C API. Det första skälet är att skriva *extension modules* för "
"specifika ändamål; dessa är C-moduler som utökar Python-tolken.  Detta är "
"förmodligen den vanligaste användningen.  Det andra skälet är att använda "
"Python som en komponent i en större applikation; denna teknik kallas i "
"allmänhet :dfn:`embedding` Python i en applikation."

msgid ""
"Writing an extension module is a relatively well-understood process, where a "
"\"cookbook\" approach works well.  There are several tools that automate the "
"process to some extent.  While people have embedded Python in other "
"applications since its early existence, the process of embedding Python is "
"less straightforward than writing an extension."
msgstr ""
"Att skriva en tilläggsmodul är en relativt välkänd process, där en "
"\"kokboks\"-metod fungerar bra.  Det finns flera verktyg som automatiserar "
"processen i viss utsträckning.  Även om människor har bäddat in Python i "
"andra applikationer sedan dess tidiga existens, är processen att bädda in "
"Python mindre okomplicerad än att skriva ett tillägg."

msgid ""
"Many API functions are useful independent of whether you're embedding  or "
"extending Python; moreover, most applications that embed Python  will need "
"to provide a custom extension as well, so it's probably a  good idea to "
"become familiar with writing an extension before  attempting to embed Python "
"in a real application."
msgstr ""
"Många API-funktioner är användbara oberoende av om du bäddar in eller utökar "
"Python; dessutom kommer de flesta applikationer som bäddar in Python att "
"behöva tillhandahålla ett anpassat tillägg också, så det är förmodligen en "
"bra idé att bekanta sig med att skriva ett tillägg innan du försöker bädda "
"in Python i en riktig applikation."

msgid "Language version compatibility"
msgstr "Kompatibilitet med språkversioner"

msgid "Python's C API is compatible with C11 and C++11 versions of C and C++."
msgstr ""
"Pythons C API är kompatibelt med C11- och C++11-versionerna av C och C++."

msgid ""
"This is a lower limit: the C API does not require features from later C/C++ "
"versions. You do *not* need to enable your compiler's \"c11 mode\"."
msgstr ""
"Detta är en nedre gräns: C API kräver inte funktioner från senare C/C++-"
"versioner. Du behöver *inte* aktivera din kompilators \"c11-läge\"."

msgid "Coding standards"
msgstr "Kodningsstandarder"

msgid ""
"If you're writing C code for inclusion in CPython, you **must** follow the "
"guidelines and standards defined in :PEP:`7`.  These guidelines apply "
"regardless of the version of Python you are contributing to.  Following "
"these conventions is not necessary for your own third party extension "
"modules, unless you eventually expect to contribute them to Python."
msgstr ""
"Om du skriver C-kod som ska ingå i CPython måste du **följa** de riktlinjer "
"och standarder som definieras i :PEP:`7`.  Dessa riktlinjer gäller oavsett "
"vilken version av Python du bidrar till.  Att följa dessa konventioner är "
"inte nödvändigt för dina egna tilläggsmoduler från tredje part, såvida du "
"inte så småningom förväntar dig att bidra med dem till Python."

msgid "Include Files"
msgstr "Inkludera filer"

msgid ""
"All function, type and macro definitions needed to use the Python/C API are "
"included in your code by the following line::"
msgstr ""
"Alla funktions-, typ- och makrodefinitioner som behövs för att använda "
"Python/C API inkluderas i din kod med följande rad::"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#inkludera <Python.h>"

msgid ""
"This implies inclusion of the following standard headers: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` and ``<stdlib."
"h>`` (if available)."
msgstr ""
"Detta innebär att följande standardrubriker måste inkluderas: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>``, ``<limits.h>``, ``<assert.h>`` och ``<stdlib."
"h>` (om tillgängligt)."

msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"Eftersom Python kan definiera vissa preprocessordefinitioner som påverkar "
"standardrubrikerna på vissa system, måste du *inkludera* :file:`Python.h` "
"innan några standardrubriker inkluderas."

msgid ""
"It is recommended to always define ``PY_SSIZE_T_CLEAN`` before including "
"``Python.h``.  See :ref:`arg-parsing` for a description of this macro."
msgstr ""
"Det rekommenderas att alltid definiera ``PY_SSIZE_T_CLEAN`` innan man "
"inkluderar ``Python.h``.  Se :ref:`arg-parsing` för en beskrivning av detta "
"makro."

msgid ""
"All user visible names defined by Python.h (except those defined by the "
"included standard headers) have one of the prefixes ``Py`` or ``_Py``.  "
"Names beginning with ``_Py`` are for internal use by the Python "
"implementation and should not be used by extension writers. Structure member "
"names do not have a reserved prefix."
msgstr ""
"Alla användarsynliga namn som definieras av Python.h (utom de som definieras "
"av de inkluderade standardheadern) har ett av prefixen ``Py`` eller "
"``_Py``.  Namn som börjar med ``_Py`` är för internt bruk av Python-"
"implementationen och bör inte användas av tilläggsskrivare. "
"Strukturmedlemsnamn har inget reserverat prefix."

msgid ""
"User code should never define names that begin with ``Py`` or ``_Py``. This "
"confuses the reader, and jeopardizes the portability of the user code to "
"future Python versions, which may define additional names beginning with one "
"of these prefixes."
msgstr ""
"Användarkod bör aldrig definiera namn som börjar med ``Py`` eller ``_Py``. "
"Detta förvirrar läsaren och äventyrar portabiliteten av användarkoden till "
"framtida Python-versioner, som kan definiera ytterligare namn som börjar med "
"något av dessa prefix."

msgid ""
"The header files are typically installed with Python.  On Unix, these  are "
"located in the directories :file:`{prefix}/include/pythonversion/` and :file:"
"`{exec_prefix}/include/pythonversion/`, where :option:`prefix <--prefix>` "
"and :option:`exec_prefix <--exec-prefix>` are defined by the corresponding "
"parameters to Python's :program:`configure` script and *version* is ``'%d."
"%d' % sys.version_info[:2]``.  On Windows, the headers are installed in :"
"file:`{prefix}/include`, where ``prefix`` is the installation directory "
"specified to the installer."
msgstr ""
"Huvudfilerna installeras vanligtvis med Python.  På Unix finns dessa i "
"katalogerna :file:`{prefix}/include/pythonversion/` och :file:`{exec_prefix}/"
"include/pythonversion/`, där :option:`prefix <--prefix>` och :option:"
"`exec_prefix <--exec-prefix>` definieras av motsvarande parametrar i Pythons "
"skript :program:`configure` och *version* är ``'%d.%d' % sys."
"version_info[:2]``.  I Windows installeras sidhuvudet i :file:`{prefix}/"
"include`, där ``prefix`` är den installationskatalog som anges i "
"installationsprogrammet."

msgid ""
"To include the headers, place both directories (if different) on your "
"compiler's search path for includes.  Do *not* place the parent directories "
"on the search path and then use ``#include <pythonX.Y/Python.h>``; this will "
"break on multi-platform builds since the platform independent headers under :"
"option:`prefix <--prefix>` include the platform specific headers from :"
"option:`exec_prefix <--exec-prefix>`."
msgstr ""
"För att inkludera rubrikerna, placera båda katalogerna (om de är olika) på "
"kompilatorns sökväg för inkluderingar.  Placera *inte* de överordnade "
"katalogerna på sökvägen och använd sedan ``#include &lt;pythonX.Y/Python."
"h&gt;``; detta kommer att gå sönder på multiplattformsbyggen eftersom de "
"plattformsoberoende rubrikerna under :option:`prefix <--prefix>` inkluderar "
"de plattformsspecifika rubrikerna från :option:`exec_prefix <--exec-prefix>`."

msgid ""
"C++ users should note that although the API is defined entirely using C, the "
"header files properly declare the entry points to be ``extern \"C\"``. As a "
"result, there is no need to do anything special to use the API from C++."
msgstr ""
"C++-användare bör notera att även om API:et är definierat helt i C, "
"deklarerar rubrikfilerna korrekt att ingångspunkterna är ``extern \"C\"``. "
"Det finns därför inget behov av att göra något speciellt för att använda API:"
"et från C++."

msgid "Useful macros"
msgstr "Användbara makron"

msgid ""
"Several useful macros are defined in the Python header files.  Many are "
"defined closer to where they are useful (for example, :c:macro:"
"`Py_RETURN_NONE`, :c:macro:`PyMODINIT_FUNC`). Others of a more general "
"utility are defined here.  This is not necessarily a complete listing."
msgstr ""
"Flera användbara makron finns definierade i Pythons header-filer.  Många är "
"definierade närmare där de är användbara (till exempel :c:macro:"
"`Py_RETURN_NONE`, :c:macro:`PyMODINIT_FUNC`). Andra som är mer allmänt "
"användbara definieras här.  Detta är inte nödvändigtvis en fullständig lista."

msgid "Return the absolute value of ``x``."
msgstr "Returnera det absoluta värdet av ``x``."

msgid ""
"Ask the compiler to always inline a static inline function. The compiler can "
"ignore it and decide to not inline the function."
msgstr ""
"Be kompilatorn att alltid inlinea en statisk inline-funktion. Kompilatorn "
"kan ignorera det och bestämma sig för att inte inline-funktionen."

msgid ""
"It can be used to inline performance critical static inline functions when "
"building Python in debug mode with function inlining disabled. For example, "
"MSC disables function inlining when building in debug mode."
msgstr ""
"Den kan användas för att inline prestandakritiska statiska inline-funktioner "
"när Python byggs i felsökningsläge med funktionsinlining inaktiverad. MSC "
"inaktiverar till exempel inlining av funktioner när Python byggs i "
"felsökningsläge."

msgid ""
"Marking blindly a static inline function with Py_ALWAYS_INLINE can result in "
"worse performances (due to increased code size for example). The compiler is "
"usually smarter than the developer for the cost/benefit analysis."
msgstr ""
"Att blint markera en statisk inline-funktion med Py_ALWAYS_INLINE kan leda "
"till sämre prestanda (till exempel på grund av ökad kodstorlek). Kompilatorn "
"är vanligtvis smartare än utvecklaren när det gäller kostnads-/nyttoanalysen."

msgid ""
"If Python is :ref:`built in debug mode <debug-build>` (if the :c:macro:"
"`Py_DEBUG` macro is defined), the :c:macro:`Py_ALWAYS_INLINE` macro does "
"nothing."
msgstr ""
"Om Python är :ref:`byggd i debugläge <debug-build>` (om makrot :c:macro:"
"`Py_DEBUG` är definierat), gör makrot :c:macro:`Py_ALWAYS_INLINE` ingenting."

msgid "It must be specified before the function return type. Usage::"
msgstr "Den måste anges före funktionens returtyp. Användning::"

msgid "static inline Py_ALWAYS_INLINE int random(void) { return 4; }"
msgstr "statisk inline Py_ALWAYS_INLINE int random(void) { return 4; }"

msgid ""
"Argument must be a character or an integer in the range [-128, 127] or [0, "
"255].  This macro returns ``c`` cast to an ``unsigned char``."
msgstr ""
"Argumentet måste vara ett tecken eller ett heltal i intervallet [-128, 127] "
"eller [0, 255].  Detta makro returnerar ``c`` som kastats till en ``unsigned "
"char``."

msgid ""
"Use this for deprecated declarations.  The macro must be placed before the "
"symbol name."
msgstr ""
"Använd detta för föråldrade deklarationer.  Makrot måste placeras före "
"symbolnamnet."

msgid "Example::"
msgstr "Exempel::"

msgid "Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);"
msgstr "Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);"

msgid "MSVC support was added."
msgstr "Stöd för MSVC har lagts till."

msgid ""
"Like ``getenv(s)``, but returns ``NULL`` if :option:`-E` was passed on the "
"command line (see :c:member:`PyConfig.use_environment`)."
msgstr ""
"Som ``getenv(s)``, men returnerar ``NULL`` om :option:`-E` angavs på "
"kommandoraden (se :c:member:`PyConfig.use_environment`)."

msgid "Return the maximum value between ``x`` and ``y``."
msgstr "Returnerar det maximala värdet mellan ``x`` och ``y``."

msgid "Return the size of a structure (``type``) ``member`` in bytes."
msgstr "Returnerar storleken på en struktur (``typ``) ``medlem`` i bytes."

msgid "Return the minimum value between ``x`` and ``y``."
msgstr "Returnerar det minsta värdet mellan ``x`` och ``y``."

msgid ""
"Disable inlining on a function. For example, it reduces the C stack "
"consumption: useful on LTO+PGO builds which heavily inline code (see :issue:"
"`33720`)."
msgstr ""
"Inaktivera inlining på en funktion. Det minskar till exempel C-stackens "
"förbrukning: användbart på LTO+PGO-byggnader som innehåller mycket inline-"
"kod (se :issue:`33720`)."

msgid "Usage::"
msgstr "Användning::"

msgid "Py_NO_INLINE static int random(void) { return 4; }"
msgstr "Py_NO_INLINE statisk int random(void) { return 4; }"

msgid ""
"Convert ``x`` to a C string.  E.g. ``Py_STRINGIFY(123)`` returns ``\"123\"``."
msgstr ""
"Konvertera ``x`` till en C-sträng.  T.ex. ``Py_STRINGIFY(123)`` returnerar "
"``\"123\"``."

msgid ""
"Use this when you have a code path that cannot be reached by design. For "
"example, in the ``default:`` clause in a ``switch`` statement for which all "
"possible values are covered in ``case`` statements.  Use this in places "
"where you might be tempted to put an ``assert(0)`` or ``abort()`` call."
msgstr ""
"Använd detta när du har en kodväg som inte kan nås genom design. Till "
"exempel i klausulen ``default:`` i en ``witch``-sats för vilken alla möjliga "
"värden täcks av ``case``-satser.  Använd detta på platser där du kan frestas "
"att lägga till ett ``assert(0)`` eller ``abort()``-anrop."

msgid ""
"In release mode, the macro helps the compiler to optimize the code, and "
"avoids a warning about unreachable code.  For example, the macro is "
"implemented with ``__builtin_unreachable()`` on GCC in release mode."
msgstr ""
"I release-läge hjälper makrot kompilatorn att optimera koden och undviker en "
"varning om onåbar kod.  Makrot implementeras t.ex. med "
"``__builtin_unreachable()`` i GCC i release-läge."

msgid ""
"A use for ``Py_UNREACHABLE()`` is following a call a function that never "
"returns but that is not declared :c:macro:`_Py_NO_RETURN`."
msgstr ""
"En användning för ``Py_UNREACHABLE()`` är att följa ett anrop av en funktion "
"som aldrig returnerar men som inte är deklarerad :c:macro:`_Py_NO_RETURN`."

msgid ""
"If a code path is very unlikely code but can be reached under exceptional "
"case, this macro must not be used.  For example, under low memory condition "
"or if a system call returns a value out of the expected range.  In this "
"case, it's better to report the error to the caller.  If the error cannot be "
"reported to caller, :c:func:`Py_FatalError` can be used."
msgstr ""
"Om en kodväg är mycket osannolik men kan nås i undantagsfall, får detta "
"makro inte användas.  Till exempel vid låg minneskapacitet eller om ett "
"systemanrop returnerar ett värde som inte ligger inom det förväntade "
"intervallet.  I så fall är det bättre att rapportera felet till anroparen.  "
"Om felet inte kan rapporteras till anroparen kan :c:func:`Py_FatalError` "
"användas."

msgid ""
"Use this for unused arguments in a function definition to silence compiler "
"warnings. Example: ``int func(int a, int Py_UNUSED(b)) { return a; }``."
msgstr ""
"Använd detta för oanvända argument i en funktionsdefinition för att tysta "
"kompilatorvarningar. Exempel: ``int func(int a, int Py_UNUSED(b)) { return "
"a; }``."

msgid ""
"Creates a variable with name ``name`` that can be used in docstrings. If "
"Python is built without docstrings, the value will be empty."
msgstr ""
"Skapar en variabel med namnet ``name`` som kan användas i docstrings. Om "
"Python byggs utan dokumentsträngar kommer värdet att vara tomt."

msgid ""
"Use :c:macro:`PyDoc_STRVAR` for docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Använd :c:macro:`PyDoc_STRVAR` för docstrings för att stödja byggandet av "
"Python utan docstrings, enligt specifikationen i :pep:`7`."

msgid ""
"PyDoc_STRVAR(pop_doc, \"Remove and return the rightmost element.\");\n"
"\n"
"static PyMethodDef deque_methods[] = {\n"
"    // ...\n"
"    {\"pop\", (PyCFunction)deque_pop, METH_NOARGS, pop_doc},\n"
"    // ...\n"
"}"
msgstr ""
"PyDoc_STRVAR(pop_doc, \"Ta bort och returnera elementet längst till höger."
"\");\n"
"\n"
"statisk PyMethodDef deque_methods[] = {\n"
"    // ...\n"
"    {\"pop\", (PyCFunction)deque_pop, METH_NOARGS, pop_doc},\n"
"    // ...\n"
"}"

msgid ""
"Creates a docstring for the given input string or an empty string if "
"docstrings are disabled."
msgstr ""
"Skapar en docstring för den angivna indatasträngen eller en tom sträng om "
"docstrings är inaktiverade."

msgid ""
"Use :c:macro:`PyDoc_STR` in specifying docstrings to support building Python "
"without docstrings, as specified in :pep:`7`."
msgstr ""
"Använd :c:macro:`PyDoc_STR` vid angivande av dokumentsträngar för att stödja "
"byggandet av Python utan dokumentsträngar, enligt :pep:`7`."

msgid ""
"static PyMethodDef pysqlite_row_methods[] = {\n"
"    {\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS,\n"
"        PyDoc_STR(\"Returns the keys of the row.\")},\n"
"    {NULL, NULL}\n"
"};"
msgstr ""
"static PyMethodDef pysqlite_row_methods[] = {\n"
"    {\"keys\", (PyCFunction)pysqlite_row_keys, METH_NOARGS,\n"
"        PyDoc_STR(\"Returnerar nycklarna för raden.\")},\n"
"    {NULL, NULL}\n"
"};"

msgid "Objects, Types and Reference Counts"
msgstr "Objekt, typer och referensräkningar"

msgid ""
"Most Python/C API functions have one or more arguments as well as a return "
"value of type :c:expr:`PyObject*`.  This type is a pointer to an opaque data "
"type representing an arbitrary Python object.  Since all Python object types "
"are treated the same way by the Python language in most situations (e.g., "
"assignments, scope rules, and argument passing), it is only fitting that "
"they should be represented by a single C type.  Almost all Python objects "
"live on the heap: you never declare an automatic or static variable of type :"
"c:type:`PyObject`, only pointer variables of type :c:expr:`PyObject*` can  "
"be declared.  The sole exception are the type objects; since these must "
"never be deallocated, they are typically static :c:type:`PyTypeObject` "
"objects."
msgstr ""
"De flesta Python/C API-funktioner har ett eller flera argument samt ett "
"returvärde av typen :c:expr:`PyObject*`.  Denna typ är en pekare till en "
"opak datatyp som representerar ett godtyckligt Python-objekt.  Eftersom alla "
"Python-objekttyper behandlas på samma sätt av Python-språket i de flesta "
"situationer (t.ex. tilldelningar, scope-regler och argumentpassning) är det "
"bara passande att de representeras av en enda C-typ.  Nästan alla Python-"
"objekt lever på högen: du kan aldrig deklarera en automatisk eller statisk "
"variabel av typen :c:type:`PyObject`, endast pekarvariabler av typen :c:expr:"
"`PyObject*` kan deklareras.  Det enda undantaget är typobjekten; eftersom "
"dessa aldrig får avallokeras är de typiskt statiska :c:type:`PyTypeObject`-"
"objekt."

msgid ""
"All Python objects (even Python integers) have a :dfn:`type` and a :dfn:"
"`reference count`.  An object's type determines what kind of object it is (e."
"g., an integer, a list, or a user-defined function; there are many more as "
"explained in :ref:`types`).  For each of the well-known types there is a "
"macro to check whether an object is of that type; for instance, "
"``PyList_Check(a)`` is true if (and only if) the object pointed to by *a* is "
"a Python list."
msgstr ""
"Alla Python-objekt (även Pythons heltal) har en :dfn:`typ` och ett :dfn:"
"`referensantal`.  Ett objekts typ avgör vilken typ av objekt det är (t.ex. "
"ett heltal, en lista eller en användardefinierad funktion; det finns många "
"fler som förklaras i :ref:`types`).  För var och en av de välkända typerna "
"finns det ett makro för att kontrollera om ett objekt är av den typen; till "
"exempel är ``PyList_Check(a)`` sant om (och endast om) det objekt som *a* "
"pekar på är en Python-lista."

msgid "Reference Counts"
msgstr "Referensräkningar"

msgid ""
"The reference count is important because today's computers have a  finite "
"(and often severely limited) memory size; it counts how many different "
"places there are that have a :term:`strong reference` to an object. Such a "
"place could be another object, or a global (or static) C variable, or a "
"local variable in some C function. When the last :term:`strong reference` to "
"an object is released (i.e. its reference count becomes zero), the object is "
"deallocated. If it contains references to other objects, those references "
"are released. Those other objects may be deallocated in turn, if there are "
"no more references to them, and so on.  (There's an obvious problem  with "
"objects that reference each other here; for now, the solution is \"don't do "
"that.\")"
msgstr ""
"Referensräkningen är viktig eftersom dagens datorer har en ändlig (och ofta "
"starkt begränsad) minnesstorlek; den räknar hur många olika platser det "
"finns som har en :term:`strong referens` till ett objekt. En sådan plats kan "
"vara ett annat objekt, eller en global (eller statisk) C-variabel, eller en "
"lokal variabel i någon C-funktion. När den sista :term:`strong-referensen` "
"till ett objekt släpps (d.v.s. dess referensantal blir noll), deallokeras "
"objektet. Om det innehåller referenser till andra objekt, frigörs dessa "
"referenser. Dessa andra objekt kan i sin tur deallokeras om det inte finns "
"några fler referenser till dem, och så vidare.  (Det finns ett uppenbart "
"problem med objekt som refererar till varandra här; för tillfället är "
"lösningen \"gör inte det.\")"

msgid ""
"Reference counts are always manipulated explicitly.  The normal way is to "
"use the macro :c:func:`Py_INCREF` to take a new reference to an object (i.e. "
"increment its reference count by one), and :c:func:`Py_DECREF` to release "
"that reference (i.e. decrement the reference count by one).  The :c:func:"
"`Py_DECREF` macro is considerably more complex than the incref one, since it "
"must check whether the reference count becomes zero and then cause the "
"object's deallocator to be called.  The deallocator is a function pointer "
"contained in the object's type structure.  The type-specific deallocator "
"takes care of releasing references for other objects contained in the object "
"if this is a compound object type, such as a list, as well as performing any "
"additional finalization that's needed.  There's no chance that the reference "
"count can overflow; at least as many bits are used to hold the reference "
"count as there are distinct memory locations in virtual memory (assuming "
"``sizeof(Py_ssize_t) >= sizeof(void*)``). Thus, the reference count "
"increment is a simple operation."
msgstr ""
"Referensräkningar manipuleras alltid explicit.  Det normala sättet är att "
"använda makrot :c:func:`Py_INCREF` för att ta en ny referens till ett objekt "
"(dvs. öka dess referensantal med ett) och :c:func:`Py_DECREF` för att släppa "
"den referensen (dvs. minska referensantalet med ett).  Makrot :c:func:"
"`Py_DECREF` är betydligt mer komplext än incref, eftersom det måste "
"kontrollera om referensantalet blir noll och därefter anropa objektets "
"deallocator.  Deallokatorn är en funktionspoängare som ingår i objektets "
"typstruktur.  Den typspecifika deallokatorn tar hand om att frigöra "
"referenser för andra objekt som ingår i objektet om detta är en sammansatt "
"objekttyp, till exempel en lista, samt utför ytterligare slutbehandling som "
"behövs.  Det finns ingen chans att referensantalet kan överskridas; minst "
"lika många bitar används för att hålla referensantalet som det finns "
"distinkta minnesplatser i det virtuella minnet (förutsatt att "
"``sizeof(Py_ssize_t) >= sizeof(void*)``). Således är ökningen av "
"referensantalet en enkel operation."

msgid ""
"It is not necessary to hold a :term:`strong reference` (i.e. increment the "
"reference count) for every local variable that contains a pointer to an "
"object.  In theory, the  object's reference count goes up by one when the "
"variable is made to  point to it and it goes down by one when the variable "
"goes out of  scope.  However, these two cancel each other out, so at the end "
"the  reference count hasn't changed.  The only real reason to use the  "
"reference count is to prevent the object from being deallocated as  long as "
"our variable is pointing to it.  If we know that there is at  least one "
"other reference to the object that lives at least as long as our variable, "
"there is no need to take a new :term:`strong reference` (i.e. increment the "
"reference count) temporarily. An important situation where this arises is in "
"objects  that are passed as arguments to C functions in an extension module  "
"that are called from Python; the call mechanism guarantees to hold a  "
"reference to every argument for the duration of the call."
msgstr ""
"Det är inte nödvändigt att hålla en :term:`strong reference` (d.v.s. öka "
"referensantalet) för varje lokal variabel som innehåller en pekare till ett "
"objekt.  I teorin ökar objektets referensantal med ett när variabeln pekar "
"på det och det minskar med ett när variabeln försvinner ur räckvidden.  "
"Dessa två tar dock ut varandra, så i slutändan har referensantalet inte "
"ändrats.  Det enda egentliga skälet till att använda referensantalet är att "
"förhindra att objektet avallokeras så länge vår variabel pekar på det.  Om "
"vi vet att det finns minst en annan referens till objektet som lever minst "
"lika länge som vår variabel, finns det inget behov av att tillfälligt ta en "
"ny :term:`strong reference` (dvs. öka referensantalet). En viktig situation "
"där detta uppstår är i objekt som skickas som argument till C-funktioner i "
"en tilläggsmodul som anropas från Python; anropsmekanismen garanterar att "
"hålla en referens till varje argument så länge anropet varar."

msgid ""
"However, a common pitfall is to extract an object from a list and hold on to "
"it for a while without taking a new reference.  Some other operation might "
"conceivably remove the object from the list, releasing that reference, and "
"possibly deallocating it. The real danger is that innocent-looking "
"operations may invoke arbitrary Python code which could do this; there is a "
"code path which allows control to flow back to the user from a :c:func:"
"`Py_DECREF`, so almost any operation is potentially dangerous."
msgstr ""
"En vanlig fallgrop är dock att extrahera ett objekt från en lista och "
"behålla det ett tag utan att ta en ny referens.  Någon annan operation kan "
"tänkas ta bort objektet från listan, släppa referensen och eventuellt "
"avallokera den. Den verkliga faran är att oskyldigt utseende operationer kan "
"åberopa godtycklig Python-kod som kan göra detta; det finns en kodväg som "
"gör att kontrollen kan flöda tillbaka till användaren från en :c:func:"
"`Py_DECREF`, så nästan alla operationer är potentiellt farliga."

msgid ""
"A safe approach is to always use the generic operations (functions  whose "
"name begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or "
"``PyMapping_``). These operations always create a new :term:`strong "
"reference` (i.e. increment the reference count) of the object they return. "
"This leaves the caller with the responsibility to call :c:func:`Py_DECREF` "
"when they are done with the result; this soon becomes second nature."
msgstr ""
"Ett säkert tillvägagångssätt är att alltid använda de generiska "
"operationerna (funktioner vars namn börjar med ``PyObject_``, ``PyNumber_``, "
"``PySequence_`` eller ``PyMapping_``). Dessa operationer skapar alltid en "
"ny :term:`strong reference` (dvs. ökar referensantalet) för det objekt som "
"de returnerar. Detta lämnar anroparen med ansvaret att anropa :c:func:"
"`Py_DECREF` när de är klara med resultatet; detta blir snart en andra natur."

msgid "Reference Count Details"
msgstr "Referensräkning Detaljer"

msgid ""
"The reference count behavior of functions in the Python/C API is best  "
"explained in terms of *ownership of references*.  Ownership pertains to "
"references, never to objects (objects are not owned: they are always "
"shared).  \"Owning a reference\" means being responsible for calling "
"Py_DECREF on it when the reference is no longer needed.  Ownership can also "
"be transferred, meaning that the code that receives ownership of the "
"reference then becomes responsible for eventually releasing it by calling :c:"
"func:`Py_DECREF` or :c:func:`Py_XDECREF` when it's no longer needed---or "
"passing on this responsibility (usually to its caller). When a function "
"passes ownership of a reference on to its caller, the caller is said to "
"receive a *new* reference.  When no ownership is transferred, the caller is "
"said to *borrow* the reference. Nothing needs to be done for a :term:"
"`borrowed reference`."
msgstr ""
"Referensräkningsbeteendet för funktioner i Python/C API förklaras bäst i "
"termer av *ägarskap av referenser*.  Äganderätten gäller referenser, aldrig "
"objekt (objekt ägs inte, de delas alltid).  att \"äga en referens\" innebär "
"att man är ansvarig för att anropa Py_DECREF på den när referensen inte "
"längre behövs.  Ägandet kan också överföras, vilket innebär att den kod som "
"får ägandet av referensen sedan blir ansvarig för att så småningom släppa "
"den genom att anropa :c:func:`Py_DECREF` eller :c:func:`Py_XDECREF` när den "
"inte längre behövs---eller överföra detta ansvar (vanligtvis till dess "
"anropare). När en funktion överför ägandet av en referens till sin anropare, "
"sägs anroparen få en *ny* referens.  När inget ägande överförs sägs den som "
"anropar *låna* referensen. Ingenting behöver göras för en :term:`lånad "
"referens`."

msgid ""
"Conversely, when a calling function passes in a reference to an  object, "
"there are two possibilities: the function *steals* a  reference to the "
"object, or it does not.  *Stealing a reference* means that when you pass a "
"reference to a function, that function assumes that it now owns that "
"reference, and you are not responsible for it any longer."
msgstr ""
"Omvänt, när en anropande funktion skickar en referens till ett objekt, finns "
"det två möjligheter: funktionen *stjäl* en referens till objektet, eller så "
"gör den det inte.  *Att stjäla en referens* innebär att när du skickar en "
"referens till en funktion, antar den funktionen att den nu äger referensen "
"och att du inte längre är ansvarig för den."

msgid ""
"Few functions steal references; the two notable exceptions are :c:func:"
"`PyList_SetItem` and :c:func:`PyTuple_SetItem`, which  steal a reference to "
"the item (but not to the tuple or list into which the item is put!).  These "
"functions were designed to steal a reference because of a common idiom for "
"populating a tuple or list with newly created objects; for example, the code "
"to create the tuple ``(1, 2, \"three\")`` could look like this (forgetting "
"about error handling for the moment; a better way to code this is shown "
"below)::"
msgstr ""
"Få funktioner stjäl referenser; de två anmärkningsvärda undantagen är :c:"
"func:`PyList_SetItem` och :c:func:`PyTuple_SetItem`, som stjäl en referens "
"till objektet (men inte till den tupel eller lista som objektet läggs i!).  "
"Dessa funktioner utformades för att stjäla en referens på grund av ett "
"vanligt idiom för att fylla en tupel eller lista med nyskapade objekt; till "
"exempel skulle koden för att skapa tupeln ``(1, 2, \"three\")`` kunna se ut "
"så här (vi glömmer bort felhantering för tillfället; ett bättre sätt att "
"koda detta visas nedan)::"

msgid ""
"PyObject *t;\n"
"\n"
"t = PyTuple_New(3);\n"
"PyTuple_SetItem(t, 0, PyLong_FromLong(1L));\n"
"PyTuple_SetItem(t, 1, PyLong_FromLong(2L));\n"
"PyTuple_SetItem(t, 2, PyUnicode_FromString(\"three\"));"
msgstr ""
"PyObject *t;\n"
"\n"
"t = PyTuple_New(3);\n"
"PyTuple_SetItem(t, 0, PyLong_FromLong(1L));\n"
"PyTuple_SetItem(t, 1, PyLong_FromLong(2L));\n"
"PyTuple_SetItem(t, 2, PyUnicode_FromString(\"tre\"));"

msgid ""
"Here, :c:func:`PyLong_FromLong` returns a new reference which is immediately "
"stolen by :c:func:`PyTuple_SetItem`.  When you want to keep using an object "
"although the reference to it will be stolen, use :c:func:`Py_INCREF` to grab "
"another reference before calling the reference-stealing function."
msgstr ""
"Här returnerar :c:func:`PyLong_FromLong` en ny referens som omedelbart "
"stjäls av :c:func:`PyTuple_SetItem`.  När du vill fortsätta använda ett "
"objekt trots att referensen till det kommer att stjälas, använd :c:func:"
"`Py_INCREF` för att ta en annan referens innan du anropar den "
"referensstjälande funktionen."

msgid ""
"Incidentally, :c:func:`PyTuple_SetItem` is the *only* way to set tuple "
"items; :c:func:`PySequence_SetItem` and :c:func:`PyObject_SetItem` refuse to "
"do this since tuples are an immutable data type.  You should only use :c:"
"func:`PyTuple_SetItem` for tuples that you are creating yourself."
msgstr ""
"För övrigt är :c:func:`PyTuple_SetItem` det *endaste* sättet att ställa in "
"tupelobjekt; :c:func:`PySequence_SetItem` och :c:func:`PyObject_SetItem` "
"vägrar att göra detta eftersom tuplar är en oföränderlig datatyp.  Du bör "
"endast använda :c:func:`PyTuple_SetItem` för tuples som du skapar själv."

msgid ""
"Equivalent code for populating a list can be written using :c:func:"
"`PyList_New` and :c:func:`PyList_SetItem`."
msgstr ""
"Motsvarande kod för att fylla på en lista kan skrivas med :c:func:"
"`PyList_New` och :c:func:`PyList_SetItem`."

msgid ""
"However, in practice, you will rarely use these ways of creating and "
"populating a tuple or list.  There's a generic function, :c:func:"
"`Py_BuildValue`, that can create most common objects from C values, directed "
"by a :dfn:`format string`. For example, the above two blocks of code could "
"be replaced by the following (which also takes care of the error checking)::"
msgstr ""
"I praktiken kommer du dock sällan att använda dessa sätt att skapa och fylla "
"i en tupel eller lista.  Det finns en generisk funktion, :c:func:"
"`Py_BuildValue`, som kan skapa de flesta vanliga objekt från C-värden, "
"styrda av en :dfn:`formatsträng`. Till exempel kan de två ovanstående "
"kodblocken ersättas av följande (som också tar hand om felkontrollen)::"

msgid ""
"PyObject *tuple, *list;\n"
"\n"
"tuple = Py_BuildValue(\"(iis)\", 1, 2, \"three\");\n"
"list = Py_BuildValue(\"[iis]\", 1, 2, \"three\");"
msgstr ""
"PyObject *tuple, *list;\n"
"\n"
"tuple = Py_BuildValue(\"(iis)\", 1, 2, \"three\");\n"
"list = Py_BuildValue(\"[iis]\", 1, 2, \"three\");"

msgid ""
"It is much more common to use :c:func:`PyObject_SetItem` and friends with "
"items whose references you are only borrowing, like arguments that were "
"passed in to the function you are writing.  In that case, their behaviour "
"regarding references is much saner, since you don't have to take a new "
"reference just so you can give that reference away (\"have it be stolen\").  "
"For example, this function sets all items of a list (actually, any mutable "
"sequence) to a given item::"
msgstr ""
"Det är mycket vanligare att använda :c:func:`PyObject_SetItem` och vänner "
"med objekt vars referenser du bara lånar, som argument som skickades in till "
"den funktion du skriver.  I så fall är deras beteende när det gäller "
"referenser mycket sundare, eftersom du inte behöver ta en ny referens bara "
"för att kunna ge bort den referensen (\"låta den bli stulen\").  Den här "
"funktionen ställer till exempel in alla objekt i en lista (egentligen vilken "
"mutabel sekvens som helst) till ett givet objekt::"

msgid ""
"int\n"
"set_all(PyObject *target, PyObject *item)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"\n"
"    n = PyObject_Length(target);\n"
"    if (n < 0)\n"
"        return -1;\n"
"    for (i = 0; i < n; i++) {\n"
"        PyObject *index = PyLong_FromSsize_t(i);\n"
"        if (!index)\n"
"            return -1;\n"
"        if (PyObject_SetItem(target, index, item) < 0) {\n"
"            Py_DECREF(index);\n"
"            return -1;\n"
"        }\n"
"        Py_DECREF(index);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"int\n"
"set_all(PyObject *target, PyObject *item)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"\n"
"    n = PyObject_Length(mål);\n"
"    if (n < 0)\n"
"        returnera -1;\n"
"    for (i = 0; i < n; i++) {\n"
"        PyObject *index = PyLong_FromSsize_t(i);\n"
"        if (!index)\n"
"            returnera -1;\n"
"        if (PyObject_SetItem(target, index, item) < 0) {\n"
"            Py_DECREF(index);\n"
"            return -1;\n"
"        }\n"
"        Py_DECREF(index);\n"
"    }\n"
"    return 0;\n"
"}"

msgid ""
"The situation is slightly different for function return values.   While "
"passing a reference to most functions does not change your  ownership "
"responsibilities for that reference, many functions that  return a reference "
"to an object give you ownership of the reference. The reason is simple: in "
"many cases, the returned object is created  on the fly, and the reference "
"you get is the only reference to the  object.  Therefore, the generic "
"functions that return object references, like :c:func:`PyObject_GetItem` "
"and  :c:func:`PySequence_GetItem`, always return a new reference (the caller "
"becomes the owner of the reference)."
msgstr ""
"Situationen är något annorlunda för funktioners returvärden.   Att skicka en "
"referens till de flesta funktioner ändrar inte ditt ägaransvar för den "
"referensen, men många funktioner som returnerar en referens till ett objekt "
"ger dig äganderätten till referensen. Anledningen är enkel: i många fall "
"skapas det returnerade objektet i farten, och den referens du får är den "
"enda referensen till objektet.  Därför returnerar de generiska funktioner "
"som returnerar objektreferenser, som :c:func:`PyObject_GetItem` och :c:func:"
"`PySequence_GetItem`, alltid en ny referens (den som anropar blir ägare till "
"referensen)."

msgid ""
"It is important to realize that whether you own a reference returned  by a "
"function depends on which function you call only --- *the plumage* (the type "
"of the object passed as an argument to the function) *doesn't enter into it!"
"* Thus, if you  extract an item from a list using :c:func:`PyList_GetItem`, "
"you don't own the reference --- but if you obtain the same item from the "
"same list using :c:func:`PySequence_GetItem` (which happens to take exactly "
"the same arguments), you do own a reference to the returned object."
msgstr ""
"Det är viktigt att inse att om du äger en referens som returneras av en "
"funktion beror på vilken funktion du anropar --- *fjäderdräkten* (typen av "
"objekt som skickas som argument till funktionen) *inte spelar någon roll!* "
"Om du extraherar ett objekt från en lista med hjälp av :c:func:"
"`PyList_GetItem`, äger du inte referensen --- men om du hämtar samma objekt "
"från samma lista med hjälp av :c:func:`PySequence_GetItem` (som råkar ta "
"exakt samma argument), äger du en referens till det returnerade objektet."

msgid ""
"Here is an example of how you could write a function that computes the sum "
"of the items in a list of integers; once using  :c:func:`PyList_GetItem`, "
"and once using :c:func:`PySequence_GetItem`. ::"
msgstr ""
"Här är ett exempel på hur du kan skriva en funktion som beräknar summan av "
"posterna i en lista med heltal; en gång med :c:func:`PyList_GetItem` och en "
"gång med :c:func:`PySequence_GetItem`. ::"

msgid ""
"long\n"
"sum_list(PyObject *list)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"\n"
"    n = PyList_Size(list);\n"
"    if (n < 0)\n"
"        return -1; /* Not a list */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PyList_GetItem(list, i); /* Can't fail */\n"
"        if (!PyLong_Check(item)) continue; /* Skip non-integers */\n"
"        value = PyLong_AsLong(item);\n"
"        if (value == -1 && PyErr_Occurred())\n"
"            /* Integer too big to fit in a C long, bail out */\n"
"            return -1;\n"
"        total += value;\n"
"    }\n"
"    return total;\n"
"}"
msgstr ""
"lång\n"
"sum_list(PyObject *lista)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, värde;\n"
"    PyObjekt *objekt;\n"
"\n"
"    n = PyList_Size(lista);\n"
"    if (n < 0)\n"
"        return -1; /* Inte en lista */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PyList_GetItem(list, i); /* Får inte misslyckas */\n"
"        if (!PyLong_Check(item)) continue; /* Hoppa över icke-integraler */\n"
"        värde = PyLong_AsLong(item);\n"
"        if (värde == -1 && PyErr_Occurred())\n"
"            /* Heltalet är för stort för att rymmas i en C-long, hoppa av "
"*/\n"
"            returnera -1;\n"
"        total += värde;\n"
"    }\n"
"    return total;\n"
"}"

msgid ""
"long\n"
"sum_sequence(PyObject *sequence)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, value;\n"
"    PyObject *item;\n"
"    n = PySequence_Length(sequence);\n"
"    if (n < 0)\n"
"        return -1; /* Has no length */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PySequence_GetItem(sequence, i);\n"
"        if (item == NULL)\n"
"            return -1; /* Not a sequence, or other failure */\n"
"        if (PyLong_Check(item)) {\n"
"            value = PyLong_AsLong(item);\n"
"            Py_DECREF(item);\n"
"            if (value == -1 && PyErr_Occurred())\n"
"                /* Integer too big to fit in a C long, bail out */\n"
"                return -1;\n"
"            total += value;\n"
"        }\n"
"        else {\n"
"            Py_DECREF(item); /* Discard reference ownership */\n"
"        }\n"
"    }\n"
"    return total;\n"
"}"
msgstr ""
"lång\n"
"sum_sequence(PyObject *sequence)\n"
"{\n"
"    Py_ssize_t i, n;\n"
"    long total = 0, värde;\n"
"    PyObjekt *item;\n"
"    n = PySequence_Length(sekvens);\n"
"    if (n < 0)\n"
"        return -1; /* Har ingen längd */\n"
"    for (i = 0; i < n; i++) {\n"
"        item = PySequence_GetItem(sekvens, i);\n"
"        if (objekt == NULL)\n"
"            return -1; /* Inte en sekvens, eller annat fel */\n"
"        if (PyLong_Check(item)) {\n"
"            värde = PyLong_AsLong(item);\n"
"            Py_DECREF(objekt);\n"
"            if (värde == -1 && PyErr_Occurred())\n"
"                /* Heltalet är för stort för att rymmas i en C-long, avbryt "
"*/\n"
"                returnera -1;\n"
"            total += värde;\n"
"        }\n"
"        else {\n"
"            Py_DECREF(item); /* Kassera referensägande */\n"
"        }\n"
"    }\n"
"    returnera totalt;\n"
"}"

msgid "Types"
msgstr "Typer"

msgid ""
"There are few other data types that play a significant role in  the Python/C "
"API; most are simple C types such as :c:expr:`int`,  :c:expr:`long`, :c:expr:"
"`double` and :c:expr:`char*`.  A few structure types  are used to describe "
"static tables used to list the functions exported  by a module or the data "
"attributes of a new object type, and another is used to describe the value "
"of a complex number.  These will  be discussed together with the functions "
"that use them."
msgstr ""
"Det finns få andra datatyper som spelar en viktig roll i Python/C API; de "
"flesta är enkla C-typer som :c:expr:`int`, :c:expr:`long`, :c:expr:`double` "
"och :c:expr:`char*`.  Några strukturtyper används för att beskriva statiska "
"tabeller som används för att lista de funktioner som exporteras av en modul "
"eller dataattributen för en ny objekttyp, och en annan används för att "
"beskriva värdet av ett komplext tal.  Dessa kommer att diskuteras "
"tillsammans med de funktioner som använder dem."

msgid ""
"A signed integral type such that ``sizeof(Py_ssize_t) == sizeof(size_t)``. "
"C99 doesn't define such a thing directly (size_t is an unsigned integral "
"type). See :pep:`353` for details. ``PY_SSIZE_T_MAX`` is the largest "
"positive value of type :c:type:`Py_ssize_t`."
msgstr ""
"En signerad integraltyp som är sådan att ``sizeof(Py_ssize_t) == "
"sizeof(size_t)``. C99 definierar inte en sådan sak direkt (size_t är en "
"osignerad integraltyp). Se :pep:`353` för detaljer. ``PY_SSIZE_T_MAX`` är "
"det största positiva värdet av typen :c:type:`Py_ssize_t`."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"The Python programmer only needs to deal with exceptions if specific  error "
"handling is required; unhandled exceptions are automatically  propagated to "
"the caller, then to the caller's caller, and so on, until they reach the top-"
"level interpreter, where they are reported to the  user accompanied by a "
"stack traceback."
msgstr ""
"Python-programmeraren behöver bara hantera undantag om specifik felhantering "
"krävs; ohanterade undantag sprids automatiskt till anroparen, sedan till "
"anroparens anropar och så vidare, tills de når tolken på högsta nivån, där "
"de rapporteras till användaren tillsammans med en stack-traceback."

msgid ""
"For C programmers, however, error checking always has to be explicit.  All "
"functions in the Python/C API can raise exceptions, unless an explicit claim "
"is made otherwise in a function's documentation.  In general, when a "
"function encounters an error, it sets an exception, discards any object "
"references that it owns, and returns an error indicator.  If not documented "
"otherwise, this indicator is either ``NULL`` or ``-1``, depending on the "
"function's return type. A few functions return a Boolean true/false result, "
"with false indicating an error.  Very few functions return no explicit error "
"indicator or have an ambiguous return value, and require explicit testing "
"for errors with :c:func:`PyErr_Occurred`.  These exceptions are always "
"explicitly documented."
msgstr ""
"För C-programmerare måste dock felkontrollen alltid vara explicit.  Alla "
"funktioner i Python/C API kan skapa undantag, såvida inte något annat "
"uttryckligen anges i en funktions dokumentation.  I allmänhet, när en "
"funktion stöter på ett fel, ställer den in ett undantag, kasserar alla "
"objektreferenser som den äger och returnerar en felindikator.  Om inte annat "
"dokumenteras är denna indikator antingen ``NULL`` eller ``-1``, beroende på "
"funktionens returtyp. Ett fåtal funktioner returnerar ett booleskt sant/"
"falskt resultat, där false indikerar ett fel.  Mycket få funktioner "
"returnerar ingen explicit felindikator eller har ett tvetydigt returvärde, "
"och kräver explicit testning för fel med :c:func:`PyErr_Occurred`.  Dessa "
"undantag är alltid explicit dokumenterade."

msgid ""
"Exception state is maintained in per-thread storage (this is  equivalent to "
"using global storage in an unthreaded application).  A  thread can be in one "
"of two states: an exception has occurred, or not. The function :c:func:"
"`PyErr_Occurred` can be used to check for this: it returns a borrowed "
"reference to the exception type object when an exception has occurred, and "
"``NULL`` otherwise.  There are a number of functions to set the exception "
"state: :c:func:`PyErr_SetString` is the most common (though not the most "
"general) function to set the exception state, and :c:func:`PyErr_Clear` "
"clears the exception state."
msgstr ""
"Undantagstillstånd lagras per tråd (detta motsvarar att använda global "
"lagring i ett otrådat program).  En tråd kan befinna sig i ett av två "
"tillstånd: ett undantag har inträffat eller inte. Funktionen :c:func:"
"`PyErr_Occurred` kan användas för att kontrollera detta: den returnerar en "
"lånad referens till undantagstypsobjektet när ett undantag har inträffat, "
"och ``NULL`` annars.  Det finns ett antal funktioner för att ställa in "
"undantagstillståndet: :c:func:`PyErr_SetString` är den vanligaste (men inte "
"den mest allmänna) funktionen för att ställa in undantagstillståndet, och :c:"
"func:`PyErr_Clear` rensar undantagstillståndet."

msgid ""
"The full exception state consists of three objects (all of which can  be "
"``NULL``): the exception type, the corresponding exception  value, and the "
"traceback.  These have the same meanings as the Python result of ``sys."
"exc_info()``; however, they are not the same: the Python objects represent "
"the last exception being handled by a Python  :keyword:`try` ... :keyword:"
"`except` statement, while the C level exception state only exists while an "
"exception is being passed on between C functions until it reaches the Python "
"bytecode interpreter's  main loop, which takes care of transferring it to "
"``sys.exc_info()`` and friends."
msgstr ""
"Det fullständiga undantagstillståndet består av tre objekt (som alla kan "
"vara ``NULL``): undantagstypen, det motsvarande undantagsvärdet och "
"spårningen.  Dessa har samma betydelser som Python-resultatet av ``sys."
"exc_info()``; men de är inte desamma: Python-objekten representerar det "
"sista undantaget som hanteras av en Python :keyword:`try` ... :keyword:"
"`except`-sats, medan undantagstillståndet på C-nivå bara existerar medan ett "
"undantag skickas vidare mellan C-funktioner tills det når Python-"
"bytekodtolkarens huvudslinga, som tar hand om att överföra det till ``sys."
"exc_info()`` och vänner."

msgid ""
"Note that starting with Python 1.5, the preferred, thread-safe way to access "
"the exception state from Python code is to call the function :func:`sys."
"exc_info`, which returns the per-thread exception state for Python code.  "
"Also, the semantics of both ways to access the exception state have changed "
"so that a function which catches an exception will save and restore its "
"thread's exception state so as to preserve the exception state of its "
"caller.  This prevents common bugs in exception handling code caused by an "
"innocent-looking function overwriting the exception being handled; it also "
"reduces the often unwanted lifetime extension for objects that are "
"referenced by the stack frames in the traceback."
msgstr ""
"Observera att från och med Python 1.5 är det föredragna, trådsäkra sättet "
"att komma åt undantagstillståndet från Python-kod att anropa funktionen :"
"func:`sys.exc_info`, som returnerar undantagstillståndet per tråd för Python-"
"kod.  Semantiken för båda sätten att komma åt undantagstillståndet har också "
"ändrats så att en funktion som fångar upp ett undantag sparar och "
"återställer trådens undantagstillstånd så att anroparens undantagstillstånd "
"bevaras.  Detta förhindrar vanliga buggar i undantagshanteringskod som "
"orsakas av att en oskyldig funktion skriver över det undantag som hanteras; "
"det minskar också den ofta oönskade livstidsförlängningen för objekt som "
"refereras till av stackramarna i spårningen."

msgid ""
"As a general principle, a function that calls another function to  perform "
"some task should check whether the called function raised an  exception, and "
"if so, pass the exception state on to its caller.  It  should discard any "
"object references that it owns, and return an  error indicator, but it "
"should *not* set another exception --- that would overwrite the exception "
"that was just raised, and lose important information about the exact cause "
"of the error."
msgstr ""
"Som en allmän princip bör en funktion som anropar en annan funktion för att "
"utföra någon uppgift kontrollera om den anropade funktionen gav upphov till "
"ett undantag och i så fall vidarebefordra undantagstillståndet till sin "
"anropare.  Den bör kasta bort alla objektreferenser som den äger och "
"returnera en felindikator, men den bör *inte* ställa in ett annat undantag "
"--- det skulle skriva över det undantag som just har uppstått och förlora "
"viktig information om den exakta orsaken till felet."

msgid ""
"A simple example of detecting exceptions and passing them on is shown in "
"the :c:func:`!sum_sequence` example above.  It so happens that this example "
"doesn't need to clean up any owned references when it detects an error.  The "
"following example function shows some error cleanup.  First, to remind you "
"why you like Python, we show the equivalent Python code::"
msgstr ""
"Ett enkelt exempel på hur man upptäcker undantag och skickar dem vidare "
"visas i :c:func:`!sum_sequence`-exemplet ovan.  Det råkar vara så att det "
"här exemplet inte behöver rensa upp några ägda referenser när det upptäcker "
"ett fel.  Följande exempel på funktion visar en del felrensning.  Först, för "
"att påminna dig om varför du gillar Python, visar vi motsvarande Python-kod::"

msgid ""
"def incr_item(dict, key):\n"
"    try:\n"
"        item = dict[key]\n"
"    except KeyError:\n"
"        item = 0\n"
"    dict[key] = item + 1"
msgstr ""
"def incr_item(dict, nyckel):\n"
"    try:\n"
"        item = dict[nyckel]\n"
"    except KeyError:\n"
"        objekt = 0\n"
"    dict[nyckel] = objekt + 1"

msgid "Here is the corresponding C code, in all its glory::"
msgstr "Här är motsvarande C-kod, i all sin prakt::"

msgid ""
"int\n"
"incr_item(PyObject *dict, PyObject *key)\n"
"{\n"
"    /* Objects all initialized to NULL for Py_XDECREF */\n"
"    PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;\n"
"    int rv = -1; /* Return value initialized to -1 (failure) */\n"
"\n"
"    item = PyObject_GetItem(dict, key);\n"
"    if (item == NULL) {\n"
"        /* Handle KeyError only: */\n"
"        if (!PyErr_ExceptionMatches(PyExc_KeyError))\n"
"            goto error;\n"
"\n"
"        /* Clear the error and use zero: */\n"
"        PyErr_Clear();\n"
"        item = PyLong_FromLong(0L);\n"
"        if (item == NULL)\n"
"            goto error;\n"
"    }\n"
"    const_one = PyLong_FromLong(1L);\n"
"    if (const_one == NULL)\n"
"        goto error;\n"
"\n"
"    incremented_item = PyNumber_Add(item, const_one);\n"
"    if (incremented_item == NULL)\n"
"        goto error;\n"
"\n"
"    if (PyObject_SetItem(dict, key, incremented_item) < 0)\n"
"        goto error;\n"
"    rv = 0; /* Success */\n"
"    /* Continue with cleanup code */\n"
"\n"
" error:\n"
"    /* Cleanup code, shared by success and failure path */\n"
"\n"
"    /* Use Py_XDECREF() to ignore NULL references */\n"
"    Py_XDECREF(item);\n"
"    Py_XDECREF(const_one);\n"
"    Py_XDECREF(incremented_item);\n"
"\n"
"    return rv; /* -1 for error, 0 for success */\n"
"}"
msgstr ""
"int\n"
"incr_item(PyObject *dict, PyObject *key)\n"
"{\n"
"    /* Alla objekt initialiseras till NULL för Py_XDECREF */\n"
"    PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;\n"
"    int rv = -1; /* Returvärde initialiserat till -1 (misslyckande) */\n"
"\n"
"    item = PyObject_GetItem(dict, nyckel);\n"
"    if (item == NULL) {\n"
"        /* Hantera endast KeyError: */\n"
"        if (!PyErr_ExceptionMatches(PyExc_KeyError))\n"
"            goto fel;\n"
"\n"
"        /* Rensa felet och använd noll: */\n"
"        PyErr_Clear();\n"
"        objekt = PyLong_FromLong(0L);\n"
"        if (objekt == NULL)\n"
"            goto fel;\n"
"    }\n"
"    const_one = PyLong_FromLong(1L);\n"
"    om (const_one == NULL)\n"
"        gå till fel;\n"
"\n"
"    incremented_item = PyNumber_Add(item, const_one);\n"
"    if (incremented_item == NULL)\n"
"        goto fel;\n"
"\n"
"    if (PyObject_SetItem(dict, key, incremented_item) < 0)\n"
"        goto fel;\n"
"    rv = 0; /* Framgång */\n"
"    /* Fortsätt med uppstädningskod */\n"
"\n"
" error (fel):\n"
"    /* Uppstädningskod, delas av framgångs- och felväg */\n"
"\n"
"    /* Använd Py_XDECREF() för att ignorera NULL-referenser */\n"
"    Py_XDECREF(objekt);\n"
"    Py_XDECREF(const_one);\n"
"    Py_XDECREF(incremented_item);\n"
"\n"
"    return rv; /* -1 för fel, 0 för framgång */\n"
"}"

msgid ""
"This example represents an endorsed use of the ``goto`` statement  in C! It "
"illustrates the use of :c:func:`PyErr_ExceptionMatches` and :c:func:"
"`PyErr_Clear` to handle specific exceptions, and the use of :c:func:"
"`Py_XDECREF` to dispose of owned references that may be ``NULL`` (note the "
"``'X'`` in the name; :c:func:`Py_DECREF` would crash when confronted with a "
"``NULL`` reference).  It is important that the variables used to hold owned "
"references are initialized to ``NULL`` for this to work; likewise, the "
"proposed return value is initialized to ``-1`` (failure) and only set to "
"success after the final call made is successful."
msgstr ""
"Detta exempel representerar en godkänd användning av ``goto``-satsen i C! "
"Det illustrerar användningen av :c:func:`PyErr_ExceptionMatches` och :c:func:"
"`PyErr_Clear` för att hantera specifika undantag, och användningen av :c:"
"func:`Py_XDECREF` för att göra sig av med ägda referenser som kan vara "
"``NULL`` (notera ``'X'`` i namnet; :c:func:`Py_DECREF` skulle krascha när "
"den konfronteras med en ``NULL``-referens).  Det är viktigt att de variabler "
"som används för att hålla ägda referenser initialiseras till ``NULL`` för "
"att detta ska fungera; på samma sätt initialiseras det föreslagna "
"returvärdet till ``-1`` (misslyckande) och sätts först till framgång efter "
"att det sista anropet som görs är framgångsrikt."

msgid "Embedding Python"
msgstr "Inbäddning av Python"

msgid ""
"The one important task that only embedders (as opposed to extension writers) "
"of the Python interpreter have to worry about is the initialization, and "
"possibly the finalization, of the Python interpreter.  Most functionality of "
"the interpreter can only be used after the interpreter has been initialized."
msgstr ""
"Den enda viktiga uppgift som endast inbäddare (i motsats till författare av "
"tillägg) av Python-tolken behöver bekymra sig om är initialiseringen, och "
"eventuellt slutförandet, av Python-tolken.  De flesta funktioner i tolken "
"kan bara användas efter att tolken har initialiserats."

msgid ""
"The basic initialization function is :c:func:`Py_Initialize`. This "
"initializes the table of loaded modules, and creates the fundamental "
"modules :mod:`builtins`, :mod:`__main__`, and :mod:`sys`.  It also "
"initializes the module search path (``sys.path``)."
msgstr ""
"Den grundläggande initialiseringsfunktionen är :c:func:`Py_Initialize`. Den "
"initierar tabellen över inlästa moduler och skapar de grundläggande "
"modulerna :mod:`builtins`, :mod:`__main__` och :mod:`sys`.  Den "
"initialiserar också sökvägen för modulerna (``sys.path``)."

msgid ""
":c:func:`Py_Initialize` does not set the \"script argument list\"  (``sys."
"argv``). If this variable is needed by Python code that will be executed "
"later, setting :c:member:`PyConfig.argv` and :c:member:`PyConfig.parse_argv` "
"must be set: see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
":c:func:`Py_Initialize` ställer inte in \"script argument list\" (``sys."
"argv``). Om denna variabel behövs av Python-kod som kommer att exekveras "
"senare, måste :c:member:`PyConfig.argv` och :c:member:`PyConfig.parse_argv` "
"sättas: se :ref:`Python Initialization Configuration <init-config>`."

msgid ""
"On most systems (in particular, on Unix and Windows, although the details "
"are slightly different), :c:func:`Py_Initialize` calculates the module "
"search path based upon its best guess for the location of the standard "
"Python interpreter executable, assuming that the Python library is found in "
"a fixed location relative to the Python interpreter executable.  In "
"particular, it looks for a directory named :file:`lib/python{X.Y}` relative "
"to the parent directory where the executable named :file:`python` is found "
"on the shell command search path (the environment variable :envvar:`PATH`)."
msgstr ""
"På de flesta system (i synnerhet på Unix och Windows, även om detaljerna är "
"något annorlunda) beräknar :c:func:`Py_Initialize` modulens sökväg baserat "
"på sin bästa gissning om platsen för Python-tolkens körbara standardprogram, "
"förutsatt att Python-biblioteket finns på en fast plats i förhållande till "
"Python-tolkens körbara program.  I synnerhet letar den efter en katalog med "
"namnet :file:`lib/python{X.Y}` i förhållande till den överordnade katalog "
"där den körbara filen med namnet :file:`python` finns i sökvägen för "
"skalkommandon (miljövariabeln :envvar:`PATH`)."

msgid ""
"For instance, if the Python executable is found in :file:`/usr/local/bin/"
"python`, it will assume that the libraries are in :file:`/usr/local/lib/"
"python{X.Y}`.  (In fact, this particular path is also the \"fallback\" "
"location, used when no executable file named :file:`python` is found along :"
"envvar:`PATH`.)  The user can override this behavior by setting the "
"environment variable :envvar:`PYTHONHOME`, or insert additional directories "
"in front of the standard path by setting :envvar:`PYTHONPATH`."
msgstr ""
"Om till exempel den körbara Python-filen finns i :file:`/usr/local/bin/"
"python`, kommer den att anta att biblioteken finns i :file:`/usr/local/lib/"
"python{X.Y}`.  (Faktum är att den här sökvägen också är \"fallback\"-"
"platsen, som används när ingen körbar fil med namnet :file:`python` hittas "
"längs :envvar:`PATH`)  Användaren kan åsidosätta detta beteende genom att "
"ställa in miljövariabeln :envvar:`PYTHONHOME`, eller lägga till ytterligare "
"kataloger framför standardsökvägen genom att ställa in :envvar:`PYTHONPATH`."

msgid ""
"The embedding application can steer the search by setting :c:member:"
"`PyConfig.program_name` *before* calling :c:func:`Py_InitializeFromConfig`. "
"Note that :envvar:`PYTHONHOME` still overrides this and :envvar:`PYTHONPATH` "
"is still inserted in front of the standard path.  An application that "
"requires total control has to provide its own implementation of :c:func:"
"`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, and :c:"
"func:`Py_GetProgramFullPath` (all defined in :file:`Modules/getpath.c`)."
msgstr ""
"Den inbäddande applikationen kan styra sökningen genom att ställa in :c:"
"member:`PyConfig.program_name` *innan* anropa :c:func:"
"`Py_InitializeFromConfig`. Observera att :envvar:`PYTHONHOME` fortfarande "
"åsidosätter detta och att :envvar:`PYTHONPATH` fortfarande infogas framför "
"standardsökvägen.  En applikation som kräver total kontroll måste "
"tillhandahålla sin egen implementation av :c:func:`Py_GetPath`, :c:func:"
"`Py_GetPrefix`, :c:func:`Py_GetExecPrefix` och :c:func:"
"`Py_GetProgramFullPath` (alla definierade i :file:`Modules/getpath.c`)."

msgid ""
"Sometimes, it is desirable to \"uninitialize\" Python.  For instance,  the "
"application may want to start over (make another call to :c:func:"
"`Py_Initialize`) or the application is simply done with its  use of Python "
"and wants to free memory allocated by Python.  This can be accomplished by "
"calling :c:func:`Py_FinalizeEx`.  The function :c:func:`Py_IsInitialized` "
"returns true if Python is currently in the initialized state.  More "
"information about these functions is given in a later chapter. Notice that :"
"c:func:`Py_FinalizeEx` does *not* free all memory allocated by the Python "
"interpreter, e.g. memory allocated by extension modules currently cannot be "
"released."
msgstr ""
"Ibland är det önskvärt att \"avinitialisera\" Python.  Till exempel kan "
"programmet vilja börja om från början (göra ett nytt anrop till :c:func:"
"`Py_Initialize`) eller så är programmet helt enkelt färdigt med att använda "
"Python och vill frigöra minne som allokerats av Python.  Detta kan "
"åstadkommas genom att anropa :c:func:`Py_FinalizeEx`.  Funktionen :c:func:"
"`Py_IsInitialized` returnerar true om Python för närvarande är i det "
"initialiserade tillståndet.  Mer information om dessa funktioner ges i ett "
"senare kapitel. Observera att :c:func:`Py_FinalizeEx` *inte* frigör allt "
"minne som allokerats av Python-tolken, t.ex. minne som allokerats av "
"tilläggsmoduler kan för närvarande inte frigöras."

msgid "Debugging Builds"
msgstr "Felsökning av byggnader"

msgid ""
"Python can be built with several macros to enable extra checks of the "
"interpreter and extension modules.  These checks tend to add a large amount "
"of overhead to the runtime so they are not enabled by default."
msgstr ""
"Python kan byggas med flera makron för att aktivera extra kontroller av "
"tolken och tilläggsmoduler.  Dessa kontroller tenderar att lägga till en "
"stor mängd overhead till körtiden så de är inte aktiverade som standard."

msgid ""
"A full list of the various types of debugging builds is in the file :file:"
"`Misc/SpecialBuilds.txt` in the Python source distribution. Builds are "
"available that support tracing of reference counts, debugging the memory "
"allocator, or low-level profiling of the main interpreter loop.  Only the "
"most frequently used builds will be described in the remainder of this "
"section."
msgstr ""
"En fullständig lista över de olika typerna av felsökningsbyggnader finns i "
"filen :file:`Misc/SpecialBuilds.txt` i Python-källdistributionen. Det finns "
"builds som stöder spårning av referensräkningar, felsökning av "
"minnesallokeraren eller lågnivåprofilering av huvudtolkens loop.  I resten "
"av detta avsnitt beskrivs endast de mest frekvent använda byggnaderna."

msgid ""
"Compiling the interpreter with the :c:macro:`!Py_DEBUG` macro defined "
"produces what is generally meant by :ref:`a debug build of Python <debug-"
"build>`. :c:macro:`!Py_DEBUG` is enabled in the Unix build by adding :option:"
"`--with-pydebug` to the :file:`./configure` command. It is also implied by "
"the presence of the not-Python-specific :c:macro:`!_DEBUG` macro.  When :c:"
"macro:`!Py_DEBUG` is enabled in the Unix build, compiler optimization is "
"disabled."
msgstr ""
"Kompilering av tolken med makrot :c:macro:`!Py_DEBUG` definierat ger vad som "
"i allmänhet menas med :ref:``en debug-byggnad av Python <debug-build>`. :c:"
"macro:`!Py_DEBUG` aktiveras i Unix-byggnaden genom att lägga till :option:`--"
"with-pydebug` till kommandot :file:`./configure`. Det är också underförstått "
"genom närvaron av det icke-Python-specifika :c:macro:`!_DEBUG`-makrot.  När :"
"c:macro:`!Py_DEBUG` är aktiverat i Unix-versionen är kompilatoroptimeringen "
"inaktiverad."

msgid ""
"In addition to the reference count debugging described below, extra checks "
"are performed, see :ref:`Python Debug Build <debug-build>`."
msgstr ""
"Utöver den felsökning av referensantal som beskrivs nedan utförs extra "
"kontroller, se :ref:`Python Debug Build <debug-build>`."

msgid ""
"Defining :c:macro:`Py_TRACE_REFS` enables reference tracing (see the :option:"
"`configure --with-trace-refs option <--with-trace-refs>`). When defined, a "
"circular doubly linked list of active objects is maintained by adding two "
"extra fields to every :c:type:`PyObject`.  Total allocations are tracked as "
"well.  Upon exit, all existing references are printed.  (In interactive mode "
"this happens after every statement run by the interpreter.)"
msgstr ""
"Genom att definiera :c:macro:`Py_TRACE_REFS` aktiveras referensspårning (se :"
"option:`configure --with-trace-refs option <--with-trace-refs>`). När den "
"definieras upprätthålls en cirkulär dubbellänkad lista över aktiva objekt "
"genom att lägga till två extra fält till varje :c:type:`PyObject`.  Totala "
"allokeringar spåras också.  Vid avslut skrivs alla befintliga referenser "
"ut.  (I interaktivt läge sker detta efter varje sats som körs av tolken)"

msgid ""
"Please refer to :file:`Misc/SpecialBuilds.txt` in the Python source "
"distribution for more detailed information."
msgstr ""
"Se :file:`Misc/SpecialBuilds.txt` i Python-källdistributionen för mer "
"detaljerad information."

msgid "Recommended third party tools"
msgstr "Rekommenderade verktyg från tredje part"

msgid ""
"The following third party tools offer both simpler and more sophisticated "
"approaches to creating C, C++ and Rust extensions for Python:"
msgstr ""
"Följande verktyg från tredje part erbjuder både enklare och mer "
"sofistikerade metoder för att skapa C-, C++- och Rust-tillägg för Python:"

msgid "`Cython <https://cython.org/>`_"
msgstr "`Cython <https://cython.org/>`_"

msgid "`cffi <https://cffi.readthedocs.io>`_"
msgstr "`cffi <https://cffi.readthedocs.io>`_"

msgid "`HPy <https://hpyproject.org/>`_"
msgstr "`HPy <https://hpyproject.org/>`__"

msgid "`nanobind <https://github.com/wjakob/nanobind>`_ (C++)"
msgstr "`nanobind <https://github.com/wjakob/nanobind>`_ (C++)"

msgid "`Numba <https://numba.pydata.org/>`_"
msgstr "`Numba <https://numba.pydata.org/>`_"

msgid "`pybind11 <https://pybind11.readthedocs.io/>`_ (C++)"
msgstr "`pybind11 <https://pybind11.readthedocs.io/>`_ (C++)"

msgid "`PyO3 <https://pyo3.rs/>`_ (Rust)"
msgstr "`PyO3 <https://pyo3.rs/>`_ (Rust)"

msgid "`SWIG <https://www.swig.org>`_"
msgstr "`SWIG <https://www.swig.org>`_"

msgid ""
"Using tools such as these can help avoid writing code that is tightly bound "
"to a particular version of CPython, avoid reference counting errors, and "
"focus more on your own code than on using the CPython API. In general, new "
"versions of Python can be supported by updating the tool, and your code will "
"often use newer and more efficient APIs automatically. Some tools also "
"support compiling for other implementations of Python from a single set of "
"sources."
msgstr ""
"Genom att använda verktyg som dessa kan du undvika att skriva kod som är "
"tätt bunden till en viss version av CPython, undvika referensräkningsfel och "
"fokusera mer på din egen kod än på att använda CPython API. I allmänhet kan "
"nya versioner av Python stödjas genom att uppdatera verktyget, och din kod "
"kommer ofta att använda nyare och effektivare API:er automatiskt. Vissa "
"verktyg stöder också kompilering för andra implementeringar av Python från "
"en enda uppsättning källor."

msgid ""
"These projects are not supported by the same people who maintain Python, and "
"issues need to be raised with the projects directly. Remember to check that "
"the project is still maintained and supported, as the list above may become "
"outdated."
msgstr ""
"Dessa projekt stöds inte av samma personer som underhåller Python, och "
"frågor måste tas upp med projekten direkt. Kom ihåg att kontrollera att "
"projektet fortfarande underhålls och stöds, eftersom listan ovan kan bli "
"föråldrad."

msgid ""
"`Python Packaging User Guide: Binary Extensions <https://packaging.python."
"org/guides/packaging-binary-extensions/>`_"
msgstr ""
"`Python Packaging Användarhandbok: Binära tillägg <https://packaging.python."
"org/guides/packaging-binary-extensions/>`_"

msgid ""
"The Python Packaging User Guide not only covers several available tools that "
"simplify the creation of binary extensions, but also discusses the various "
"reasons why creating an extension module may be desirable in the first place."
msgstr ""
"Python Packaging User Guide beskriver inte bara flera tillgängliga verktyg "
"som förenklar skapandet av binära tillägg, utan diskuterar också de olika "
"anledningarna till varför det kan vara önskvärt att skapa en tilläggsmodul i "
"första hand."

msgid "object"
msgstr "objekt"

msgid "type"
msgstr "typ"

msgid "Py_INCREF (C function)"
msgstr "Py_INCREF (C-funktion)"

msgid "Py_DECREF (C function)"
msgstr "Py_DECREF (C-funktion)"

msgid "PyList_SetItem (C function)"
msgstr "PyList_SetItem (C-funktion)"

msgid "PyTuple_SetItem (C function)"
msgstr "PyTuple_SetItem (C-funktion)"

msgid "set_all()"
msgstr "set_all()"

msgid "PyList_GetItem (C function)"
msgstr "PyList_GetItem (C-funktion)"

msgid "PySequence_GetItem (C function)"
msgstr "PySequence_GetItem (C-funktion)"

msgid "sum_list()"
msgstr "sum_list()"

msgid "sum_sequence()"
msgstr "sum_sequence()"

msgid "PyErr_Occurred (C function)"
msgstr "PyErr_Occurred (C-funktion)"

msgid "PyErr_SetString (C function)"
msgstr "PyErr_SetString (C-funktion)"

msgid "PyErr_Clear (C function)"
msgstr "PyErr_Clear (C-funktion)"

msgid "exc_info (in module sys)"
msgstr "exc_info (i modul sys)"

msgid "incr_item()"
msgstr "incr_item()"

msgid "PyErr_ExceptionMatches (C function)"
msgstr "PyErr_ExceptionMatches (C-funktion)"

msgid "Py_XDECREF (C function)"
msgstr "Py_XDECREF (C-funktion)"

msgid "Py_Initialize (C function)"
msgstr "Py_Initialize (C-funktion)"

msgid "module"
msgstr "modul"

msgid "builtins"
msgstr "inbyggda"

msgid "__main__"
msgstr "__main__"

msgid "sys"
msgstr "system"

msgid "search"
msgstr "sök"

msgid "path"
msgstr "väg"

msgid "path (in module sys)"
msgstr "sökväg (i modul sys)"

msgid "Py_GetPath (C function)"
msgstr "Py_GetPath (C-funktion)"

msgid "Py_GetPrefix (C function)"
msgstr "Py_GetPrefix (C-funktion)"

msgid "Py_GetExecPrefix (C function)"
msgstr "Py_GetExecPrefix (C-funktion)"

msgid "Py_GetProgramFullPath (C function)"
msgstr "Py_GetProgramFullPath (C-funktion)"

msgid "Py_IsInitialized (C function)"
msgstr "Py_IsInitialized (C-funktion)"
