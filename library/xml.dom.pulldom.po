# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!xml.dom.pulldom` --- Support for building partial DOM trees"
msgstr ":mod:`!xml.dom.pulldom` --- Stöd för att bygga partiella DOM-träd"

msgid "**Source code:** :source:`Lib/xml/dom/pulldom.py`"
msgstr "**Källkod:** :source:`Lib/xml/dom/pulldom.py`"

msgid ""
"The :mod:`xml.dom.pulldom` module provides a \"pull parser\" which can also "
"be asked to produce DOM-accessible fragments of the document where "
"necessary. The basic concept involves pulling \"events\" from a stream of "
"incoming XML and processing them. In contrast to SAX which also employs an "
"event-driven processing model together with callbacks, the user of a pull "
"parser is responsible for explicitly pulling events from the stream, looping "
"over those events until either processing is finished or an error condition "
"occurs."
msgstr ""
"Modulen :mod:`xml.dom.pulldom` tillhandahåller en \"pull-parser\" som också "
"kan ombes att producera DOM-åtkomliga fragment av dokumentet vid behov. "
"Grundkonceptet innebär att \"händelser\" hämtas från en ström av inkommande "
"XML och bearbetas. Till skillnad från SAX, som också använder en "
"händelsestyrd bearbetningsmodell tillsammans med callbacks, är användaren av "
"en pull-parser ansvarig för att uttryckligen hämta händelser från strömmen "
"och loopa över dessa händelser tills antingen bearbetningen är klar eller "
"ett feltillstånd uppstår."

msgid ""
"If you need to parse untrusted or unauthenticated data, see :ref:`xml-"
"security`."
msgstr ""
"Om du behöver analysera otillförlitliga eller oautentiserade data, se :ref:"
"`xml-security`."

msgid ""
"The SAX parser no longer processes general external entities by default to "
"increase security by default. To enable processing of external entities, "
"pass a custom parser instance in::"
msgstr ""
"SAX-parsern bearbetar inte längre allmänna externa enheter som standard för "
"att öka säkerheten som standard. För att aktivera behandling av externa "
"enheter, skicka en anpassad parser-instans i::"

msgid ""
"from xml.dom.pulldom import parse\n"
"from xml.sax import make_parser\n"
"from xml.sax.handler import feature_external_ges\n"
"\n"
"parser = make_parser()\n"
"parser.setFeature(feature_external_ges, True)\n"
"parse(filename, parser=parser)"
msgstr ""
"from xml.dom.pulldom import parse\n"
"from xml.sax import make_parser\n"
"from xml.sax.handler import feature_external_ges\n"
"\n"
"parser = make_parser()\n"
"parser.setFeature(feature_external_ges, True)\n"
"parse(filename, parser=parser)"

msgid "Example::"
msgstr "Exempel::"

msgid ""
"from xml.dom import pulldom\n"
"\n"
"doc = pulldom.parse('sales_items.xml')\n"
"for event, node in doc:\n"
"    if event == pulldom.START_ELEMENT and node.tagName == 'item':\n"
"        if int(node.getAttribute('price')) > 50:\n"
"            doc.expandNode(node)\n"
"            print(node.toxml())"
msgstr ""
"från xml.dom import pulldom\n"
"\n"
"doc = pulldom.parse('försäljning_items.xml')\n"
"för event, nod i doc:\n"
"    if event == pulldom.START_ELEMENT och node.tagName == 'item':\n"
"        if int(node.getAttribute('price')) > 50:\n"
"            doc.expandNode(node)\n"
"            print(node.toxml())"

msgid "``event`` is a constant and can be one of:"
msgstr "``event`` är en konstant och kan vara en av:"

msgid ":data:`START_ELEMENT`"
msgstr ":data:`START_ELEMENT`"

msgid ":data:`END_ELEMENT`"
msgstr ":data:`END_ELEMENT`"

msgid ":data:`COMMENT`"
msgstr ":data:`KOMMENTAR`"

msgid ":data:`START_DOCUMENT`"
msgstr ":data:`START_DOKUMENT`"

msgid ":data:`END_DOCUMENT`"
msgstr ":data:`END_DOCUMENT`"

msgid ":data:`CHARACTERS`"
msgstr ":data:`CHARACTERS`"

msgid ":data:`PROCESSING_INSTRUCTION`"
msgstr ":data:`PROCESSING_INSTRUCTION`"

msgid ":data:`IGNORABLE_WHITESPACE`"
msgstr ":data:`IGNORABLE_WHITESPACE`"

msgid ""
"``node`` is an object of type :class:`xml.dom.minidom.Document`, :class:`xml."
"dom.minidom.Element` or :class:`xml.dom.minidom.Text`."
msgstr ""
"``node`` är ett objekt av typen :class:`xml.dom.minidom.Document`, :class:"
"`xml.dom.minidom.Element` eller :class:`xml.dom.minidom.Text`."

msgid ""
"Since the document is treated as a \"flat\" stream of events, the document "
"\"tree\" is implicitly traversed and the desired elements are found "
"regardless of their depth in the tree. In other words, one does not need to "
"consider hierarchical issues such as recursive searching of the document "
"nodes, although if the context of elements were important, one would either "
"need to maintain some context-related state (i.e. remembering where one is "
"in the document at any given point) or to make use of the :func:"
"`DOMEventStream.expandNode` method and switch to DOM-related processing."
msgstr ""
"Eftersom dokumentet behandlas som en \"platt\" ström av händelser, "
"genomkorsas dokumentets \"träd\" implicit och de önskade elementen hittas "
"oavsett djup i trädet. Med andra ord behöver man inte ta hänsyn till "
"hierarkiska frågor som rekursiv sökning i dokumentets noder, men om "
"elementens sammanhang var viktigt skulle man antingen behöva upprätthålla "
"ett sammanhangsrelaterat tillstånd (dvs. komma ihåg var man befinner sig i "
"dokumentet vid en viss tidpunkt) eller använda :func:`DOMEventStream."
"expandNode`-metoden och övergå till DOM-relaterad bearbetning."

msgid "Subclass of :class:`xml.sax.handler.ContentHandler`."
msgstr "Underklass till :class:`xml.sax.handler.ContentHandler`."

msgid ""
"Return a :class:`DOMEventStream` from the given input. *stream_or_string* "
"may be either a file name, or a file-like object. *parser*, if given, must "
"be an :class:`~xml.sax.xmlreader.XMLReader` object. This function will "
"change the document handler of the parser and activate namespace support; "
"other parser configuration (like setting an entity resolver) must have been "
"done in advance."
msgstr ""
"Returnerar en :class:`DOMEventStream` från den givna indata. "
"*stream_or_string* kan vara antingen ett filnamn eller ett filliknande "
"objekt. *parser*, om det anges, måste vara ett :class:`~xml.sax.xmlreader."
"XMLReader`-objekt. Denna funktion ändrar dokumenthanteraren för parsern och "
"aktiverar stöd för namnrymder; annan parserkonfiguration (som att ställa in "
"en entitetsresolver) måste ha gjorts i förväg."

msgid ""
"If you have XML in a string, you can use the :func:`parseString` function "
"instead:"
msgstr ""
"Om du har XML i en sträng kan du använda funktionen :func:`parseString` "
"istället:"

msgid ""
"Return a :class:`DOMEventStream` that represents the (Unicode) *string*."
msgstr ""
"Returnerar en :class:`DOMEventStream` som representerar (Unicode) *strängen*."

msgid "Default value for the *bufsize* parameter to :func:`parse`."
msgstr "Standardvärde för parametern *bufsize* i :func:`parse`."

msgid ""
"The value of this variable can be changed before calling :func:`parse` and "
"the new value will take effect."
msgstr ""
"Värdet på denna variabel kan ändras innan :func:`parse` anropas och det nya "
"värdet träder i kraft."

msgid "DOMEventStream Objects"
msgstr "DOMEventStream-objekt"

msgid "Support for :meth:`~object.__getitem__` method has been removed."
msgstr "Stöd för metoden :meth:`~object.__getitem__` har tagits bort."

msgid ""
"Return a tuple containing *event* and the current *node* as :class:`xml.dom."
"minidom.Document` if event equals :data:`START_DOCUMENT`, :class:`xml.dom."
"minidom.Element` if event equals :data:`START_ELEMENT` or :data:"
"`END_ELEMENT` or :class:`xml.dom.minidom.Text` if event equals :data:"
"`CHARACTERS`. The current node does not contain information about its "
"children, unless :func:`expandNode` is called."
msgstr ""
"Returnerar en tupel innehållande *event* och den aktuella *noden* som :class:"
"`xml.dom.minidom.Document` om event är lika med :data:`START_DOCUMENT`, :"
"class:`xml.dom.minidom.Element` om event är lika med :data:`START_ELEMENT` "
"eller :data:`END_ELEMENT` eller :class:`xml.dom.minidom.Text` om event är "
"lika med :data:`CHARACTERS`. Den aktuella noden innehåller inte information "
"om sina barn, såvida inte :func:`expandNode` anropas."

msgid "Expands all children of *node* into *node*. Example::"
msgstr "Expanderar alla barn till *node* till *node*. Exempel::"

msgid ""
"from xml.dom import pulldom\n"
"\n"
"xml = '<html><title>Foo</title> <p>Some text <div>and more</div></p> </"
"html>'\n"
"doc = pulldom.parseString(xml)\n"
"for event, node in doc:\n"
"    if event == pulldom.START_ELEMENT and node.tagName == 'p':\n"
"        # Following statement only prints '<p/>'\n"
"        print(node.toxml())\n"
"        doc.expandNode(node)\n"
"        # Following statement prints node with all its children '<p>Some "
"text <div>and more</div></p>'\n"
"        print(node.toxml())"
msgstr ""
"från xml.dom import pulldom\n"
"\n"
"xml = '<html><title>Foo</title> <p>Lite text och <div>mer</div></p> </"
"html>'\n"
"doc = pulldom.parseString(xml)\n"
"för händelse, nod i doc:\n"
"    if event == pulldom.START_ELEMENT och node.tagName == 'p':\n"
"        # Följande sats skriver bara ut '<p/>'\n"
"        print(node.toxml())\n"
"        doc.expandNode(nod)\n"
"        # Följande sats skriver ut noden med alla dess barn '<p>Lite text "
"och <div>mer</div></p>'\n"
"        print(node.toxml())"
