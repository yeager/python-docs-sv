# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!shutil` --- High-level file operations"
msgstr ":mod:`!shutil` --- Filoperationer på hög nivå"

msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**Källkod:** :source:`Lib/shutil.py`"

msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
"Modulen :mod:`shutil` erbjuder ett antal funktioner på hög nivå för filer "
"och samlingar av filer.  I synnerhet finns funktioner som stöder kopiering "
"och borttagning av filer. För operationer på enskilda filer, se även "
"modulen :mod:`os`."

msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, :func:"
"`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"Inte ens filkopieringsfunktionerna på högre nivå (:func:`shutil.copy`, :func:"
"`shutil.copy2`) kan kopiera alla filmetadata."

msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as "
"ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not "
"copied."
msgstr ""
"På POSIX-plattformar innebär detta att filägare och grupp försvinner, liksom "
"ACL:er.  På Mac OS används inte resursgaffeln och andra metadata. Det "
"innebär att resurser går förlorade och att filtyp och skaparkod inte blir "
"korrekta. På Windows kopieras inte filägare, ACL:er och alternativa "
"dataströmmar."

msgid "Directory and files operations"
msgstr "Katalog- och filoperationer"

msgid ""
"Copy the contents of the :term:`file-like object <file object>` *fsrc* to "
"the file-like object *fdst*. The integer *length*, if given, is the buffer "
"size. In particular, a negative *length* value means to copy the data "
"without looping over the source data in chunks; by default the data is read "
"in chunks to avoid uncontrolled memory consumption. Note that if the current "
"file position of the *fsrc* object is not 0, only the contents from the "
"current file position to the end of the file will be copied."
msgstr ""
"Kopierar innehållet i :term:`filliknande objekt <file object>` *fsrc* till "
"det filliknande objektet *fdst*. Heltalet *length*, om det anges, är "
"buffertstorleken. Ett negativt *length*-värde innebär att data kopieras utan "
"att källdata loopas i bitar; som standard läses data i bitar för att undvika "
"okontrollerad minnesförbrukning. Observera att om den aktuella filpositionen "
"för *fsrc*-objektet inte är 0, kommer endast innehållet från den aktuella "
"filpositionen till slutet av filen att kopieras."

msgid ""
":func:`copyfileobj` will *not* guarantee that the destination stream has "
"been flushed on completion of the copy. If you want to read from the "
"destination at the completion of the copy operation (for example, reading "
"the contents of a temporary file that has been copied from a HTTP stream), "
"you must ensure that you have called :func:`~io.IOBase.flush` or :func:`~io."
"IOBase.close` on the file-like object before attempting to read the "
"destination file."
msgstr ""
":func:`copyfileobj` kommer *inte* att garantera att målströmmen har tömts "
"när kopieringen är klar. Om du vill läsa från destinationen när kopieringen "
"är klar (t.ex. läsa innehållet i en temporär fil som har kopierats från en "
"HTTP-ström), måste du se till att du har anropat :func:`~io.IOBase.flush` "
"eller :func:`~io.IOBase.close` på det filliknande objektet innan du försöker "
"läsa destinationsfilen."

msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are :term:`path-like objects <path-like object>` or path names given as "
"strings."
msgstr ""
"Kopiera innehållet (inga metadata) i filen med namnet *src* till en fil med "
"namnet *dst* och returnera *dst* på effektivast möjliga sätt. *src* och "
"*dst* är :term:`sökvägsliknande objekt <path-like object>` eller sökvägsnamn "
"angivna som strängar."

msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify "
"the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* måste vara det fullständiga målfilsnamnet; se :func:`~shutil.copy` för "
"en kopiering som accepterar en målkatalogsökväg.  Om *src* och *dst* anger "
"samma fil, uppstår :exc:`SameFileError`."

msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"Destinationsplatsen måste vara skrivbar, annars kommer ett :exc:`OSError` "
"undantag att uppstå. Om *dst* redan finns kommer den att ersättas. "
"Specialfiler som tecken- eller blockenheter och pipes kan inte kopieras med "
"den här funktionen."

msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"Om *follow_symlinks* är false och *src* är en symbolisk länk, skapas en ny "
"symbolisk länk i stället för att kopiera filen som *src* pekar på."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copyfile`` med "
"argumenten ``src``, ``dst``."

msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
":exc:`IOError` brukade visas istället för :exc:`OSError`. Argumentet "
"*follow_symlinks* lades till. Returnerar nu *dst*."

msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
"Utlös :exc:`SameFileError` istället för :exc:`Error`.  Eftersom den förra är "
"en subklass av den senare är denna ändring bakåtkompatibel."

msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy "
"the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"Plattformsspecifika syscalls för snabbkopiering kan användas internt för att "
"kopiera filen mer effektivt. Se avsnittet :ref:`shutil-plattformsberoende-"
"effektiva-kopieringsoperationer`."

msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr ""
"Detta undantag uppstår om källan och destinationen i :func:`copyfile` är "
"samma fil."

msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are :term:`path-like objects <path-"
"like object>` or path names given as strings. If *follow_symlinks* is false, "
"and both *src* and *dst* are symbolic links, :func:`copymode` will attempt "
"to modify the mode of *dst* itself (rather than the file it points to).  "
"This functionality is not available on every platform; please see :func:"
"`copystat` for more information.  If :func:`copymode` cannot modify symbolic "
"links on the local platform, and it is asked to do so, it will do nothing "
"and return."
msgstr ""
"Kopiera behörighetsbitarna från *src* till *dst*.  Filens innehåll, ägare "
"och grupp påverkas inte.  *src* och *dst* är :term:`sökvägsliknande objekt "
"<path-like object>` eller sökvägsnamn angivna som strängar. Om "
"*follow_symlinks* är false och både *src* och *dst* är symboliska länkar, "
"kommer :func:`copymode` att försöka ändra läget för *dst* själv (snarare än "
"filen den pekar på).  Denna funktion är inte tillgänglig på alla "
"plattformar; se :func:`copystat` för mer information.  Om :func:`copymode` "
"inte kan modifiera symboliska länkar på den lokala plattformen, och den "
"ombeds att göra det, kommer den inte att göra någonting och returnera."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copymode`` med "
"argumenten ``src``, ``dst``."

msgid "Added *follow_symlinks* argument."
msgstr "Lagt till argumentet *follow_symlinks*."

msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group "
"are unaffected.  *src* and *dst* are :term:`path-like objects <path-like "
"object>` or path names given as strings."
msgstr ""
"Kopierar behörighetsbitar, senaste åtkomsttid, senaste ändringstid och "
"flaggor från *src* till *dst*.  På Linux kopierar :func:`copystat` även de "
"\"utökade attributen\" där så är möjligt.  Filinnehåll, ägare och grupp "
"påverkas inte.  *src* och *dst* är :term:`sökvägsliknande objekt <path-like "
"object>` eller sökvägsnamn angivna som strängar."

msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather "
"than the files the symbolic links refer to—reading the information from the "
"*src* symbolic link, and writing the information to the *dst* symbolic link."
msgstr ""
"Om *follow_symlinks* är false, och *src* och *dst* båda hänvisar till "
"symboliska länkar, kommer :func:`copystat` att arbeta med de symboliska "
"länkarna själva snarare än med de filer som de symboliska länkarna hänvisar "
"till - läsa informationen från den symboliska länken *src* och skriva "
"informationen till den symboliska länken *dst*."

msgid ""
"Not all platforms provide the ability to examine and modify symbolic links.  "
"Python itself can tell you what functionality is locally available."
msgstr ""
"Det är inte alla plattformar som ger möjlighet att undersöka och ändra "
"symboliska länkar.  Python själv kan berätta vilken funktionalitet som är "
"lokalt tillgänglig."

msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the permission bits of a symbolic link."
msgstr ""
"Om ``os.chmod in os.supports_follow_symlinks`` är ``True``, kan :func:"
"`copystat` ändra behörighetsbitarna för en symbolisk länk."

msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the last access and modification times of a symbolic link."
msgstr ""
"Om ``os.utime in os.supports_follow_symlinks`` är ``True``, kan :func:"
"`copystat` ändra den senaste åtkomst- och ändringstiden för en symbolisk "
"länk."

msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, :func:"
"`copystat` can modify the flags of a symbolic link.  (``os.chflags`` is not "
"available on all platforms.)"
msgstr ""
"Om ``os.chflags in os.supports_follow_symlinks`` är ``True`` kan :func:"
"`copystat` ändra flaggorna för en symbolisk länk.  (``os.chflags`` är inte "
"tillgänglig på alla plattformar)"

msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"På plattformar där en del av eller all denna funktionalitet inte är "
"tillgänglig, kommer :func:`copystat` att kopiera allt den kan när den ombeds "
"att ändra en symbolisk länk. :func:`copystat` returnerar aldrig fel."

msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "Se :data:`os.supports_follow_symlinks` för mer information."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copystat`` med "
"argumenten ``src``, ``dst``."

msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr ""
"Argumentet *follow_symlinks* och stöd för Linux utökade attribut har lagts "
"till."

msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst* "
"specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"Kopierar filen *src* till filen eller katalogen *dst*.  *src* och *dst* bör "
"vara :term:`path-liknande objekt <path-like object>` eller strängar.  Om "
"*dst* anger en katalog kommer filen att kopieras till *dst* med hjälp av "
"basfilnamnet från *src*. Om *dst* anger en fil som redan finns kommer den "
"att ersättas. Returnerar sökvägen till den nyskapade filen."

msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"Om *follow_symlinks* är false och *src* är en symbolisk länk kommer *dst* "
"att skapas som en symbolisk länk.  Om *follow_symlinks* är true och *src* är "
"en symbolisk länk, blir *dst* en kopia av den fil som *src* hänvisar till."

msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the "
"original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` kopierar filinformationen och filens behörighetsläge "
"(se :func:`os.chmod`).  Andra metadata, t.ex. filens skapelse- och "
"ändringstid, bevaras inte. Om du vill bevara alla filmetadata från "
"originalet använder du istället :func:`~shutil.copy2`."

msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created file."
msgstr ""
"Lagt till argumentet *follow_symlinks*. Returnerar nu sökvägen till den "
"nyskapade filen."

msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to "
"preserve file metadata."
msgstr ""
"Identisk med :func:`~shutil.copy` förutom att :func:`copy2` också försöker "
"bevara metadata för filer."

msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2` "
"attempts to copy all metadata from the *src* symbolic link to the newly "
"created *dst* symbolic link. However, this functionality is not available on "
"all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; :func:"
"`copy2` never raises an exception because it cannot preserve file metadata."
msgstr ""
"När *follow_symlinks* är false och *src* är en symbolisk länk försöker :func:"
"`copy2` att kopiera alla metadata från den symboliska länken *src* till den "
"nyskapade symboliska länken *dst*. Denna funktion är dock inte tillgänglig "
"på alla plattformar. På plattformar där hela eller delar av denna "
"funktionalitet inte är tillgänglig kommer :func:`copy2` att bevara alla "
"metadata den kan; :func:`copy2` ger aldrig upphov till ett undantag för att "
"den inte kan bevara filmetadata."

msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see :"
"func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` använder :func:`copystat` för att kopiera filens metadata. Se :"
"func:`copystat` för mer information om plattformsstöd för modifiering av "
"metadata för symboliska länkar."

msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created "
"file."
msgstr ""
"Lagt till *follow_symlinks*-argument, försök att kopiera utökade "
"filsystemattribut också (för närvarande endast Linux). Returnerar nu "
"sökvägen till den nyskapade filen."

msgid ""
"This factory function creates a function that can be used as a callable for :"
"func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"Denna fabriksfunktion skapar en funktion som kan användas som en anropbar "
"funktion för :func:`copytree`'s *ignore*-argument, och ignorerar filer och "
"kataloger som matchar ett av de *mönster* i glob-stil som anges.  Se "
"exemplet nedan."

msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"Kopiera rekursivt ett helt katalogträd med rot i *src* till en katalog med "
"namnet *dst* och returnera destinationskatalogen.  Alla mellanliggande "
"kataloger som behövs för att innehålla *dst* kommer också att skapas som "
"standard."

msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"Behörigheter och tider för kataloger kopieras med :func:`copystat`, enskilda "
"filer kopieras med :func:`~shutil.copy2`."

msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"Om *symlinks* är true representeras symboliska länkar i källträdet som "
"symboliska länkar i det nya trädet och metadata för de ursprungliga länkarna "
"kopieras så långt som plattformen tillåter; om false eller utelämnas "
"kopieras innehållet och metadata för de länkade filerna till det nya trädet."

msgid ""
"When *symlinks* is false, if the file pointed to by the symlink doesn't "
"exist, an exception will be added in the list of errors raised in an :exc:"
"`Error` exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"När *symlinks* är false, om filen som symlänken pekar på inte finns, kommer "
"ett undantag att läggas till i listan över fel som tas upp i ett :exc:"
"`Error`-undantag i slutet av kopieringsprocessen. Du kan sätta den valfria "
"flaggan *ignore_dangling_symlinks* till true om du vill tysta detta "
"undantag. Observera att det här alternativet inte har någon effekt på "
"plattformar som inte stöder :func:`os.symlink`."

msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its "
"contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items "
"in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that "
"ignores names based on glob-style patterns."
msgstr ""
"Om *ignore* anges, måste det vara en anropbar funktion som får som argument "
"den katalog som besöks av :func:`copytree`, och en lista över dess innehåll, "
"som returneras av :func:`os.listdir`.  Eftersom :func:`copytree` anropas "
"rekursivt, kommer anropet *ignore* att anropas en gång för varje katalog som "
"kopieras.  Anropet måste returnera en sekvens av katalog- och filnamn i "
"förhållande till den aktuella katalogen (dvs. en delmängd av objekten i dess "
"andra argument); dessa namn kommer sedan att ignoreras i "
"kopieringsprocessen. :func:`ignore_patterns` kan användas för att skapa ett "
"sådant anrop som ignorerar namn baserade på glob-liknande mönster."

msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr ""
"Om ett eller flera undantag inträffar genereras ett :exc:`Error` med en "
"lista över orsaker."

msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy "
"each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"Om *copy_function* anges måste det vara en anropsbar funktion som används "
"för att kopiera varje fil. Den kommer att anropas med källsökvägen och "
"destinationssökvägen som argument. Som standard används :func:`~shutil."
"copy2`, men alla funktioner som stöder samma signatur (som :func:`~shutil."
"copy`) kan användas."

msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a :exc:"
"`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"Om *dirs_exist_ok* är false (standard) och *dst* redan existerar, uppstår "
"ett :exc:`FileExistsError`. Om *dirs_exist_ok* är true fortsätter "
"kopieringen om den stöter på befintliga kataloger, och filer i *dst*-trädet "
"skrivs över av motsvarande filer från *src*-trädet."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.copytree`` med "
"argumenten ``src``, ``dst``."

msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"Lagt till argumentet *copy_function* för att kunna tillhandahålla en "
"anpassad kopieringsfunktion. Lagt till argumentet *ignore_dangling_symlinks* "
"för att dämpa fel med dinglande symlänkar när *symlinks* är false."

msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "Kopiera metadata när *symlinks* är false. Returnerar nu *dst*."

msgid "Added the *dirs_exist_ok* parameter."
msgstr "Parametern *dirs_exist_ok* har lagts till."

msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a "
"symbolic link to a directory).  If *ignore_errors* is true, errors resulting "
"from failed removals will be ignored; if false or omitted, such errors are "
"handled by calling a handler specified by *onexc* or *onerror* or, if both "
"are omitted, exceptions are propagated to the caller."
msgstr ""
"Ta bort ett helt katalogträd; *path* måste peka på en katalog (men inte på "
"en symbolisk länk till en katalog).  Om *ignore_errors* är true ignoreras "
"fel som uppstår vid misslyckade borttagningar; om false eller utelämnas "
"hanteras sådana fel genom att anropa en hanterare som specificeras av "
"*onexc* eller *onerror* eller, om båda utelämnas, sprids undantag till den "
"som anropar."

msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"Den här funktionen kan stödja :ref:`sökvägar som är relativa till "
"katalogbeskrivare <dir_fd>`."

msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms, "
"the :func:`rmtree` implementation is susceptible to a symlink attack: given "
"proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"På plattformar som stöder de nödvändiga fd-baserade funktionerna används som "
"standard en version av :func:`rmtree` som är motståndskraftig mot "
"symlänkattacker.  På andra plattformar är implementeringen av :func:`rmtree` "
"känslig för en symlänk-attack: med rätt timing och omständigheter kan "
"angripare manipulera symlinks i filsystemet för att radera filer som de "
"annars inte skulle ha tillgång till.  Program kan använda "
"funktionsattributet :data:`rmtree.avoids_symlink_attacks` för att avgöra "
"vilket fall som gäller."

msgid ""
"If *onexc* is provided, it must be a callable that accepts three parameters: "
"*function*, *path*, and *excinfo*."
msgstr ""
"Om *onexc* anges måste det vara en callable som accepterar tre parametrar: "
"*funktion*, *sökväg* och *excinfo*."

msgid ""
"The first parameter, *function*, is the function which raised the exception; "
"it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, is the exception that was raised. Exceptions raised by *onexc* "
"will not be caught."
msgstr ""
"Den första parametern, *function*, är den funktion som orsakade undantaget; "
"den beror på plattform och implementering.  Den andra parametern, *path*, är "
"det sökvägsnamn som skickas till *function*.  Den tredje parametern, "
"*excinfo*, är det undantag som uppstod. Undantag som orsakas av *onexc* "
"kommer inte att fångas upp."

msgid ""
"The deprecated *onerror* is similar to *onexc*, except that the third "
"parameter it receives is the tuple returned from :func:`sys.exc_info`."
msgstr ""
"Den föråldrade *onerror* liknar *onexc*, förutom att den tredje parametern "
"den tar emot är den tupel som returneras från :func:`sys.exc_info`."

msgid ""
":ref:`shutil-rmtree-example` for an example of handling the removal of a "
"directory tree that contains read-only files."
msgstr ""
":ref:`shutil-rmtree-example` för ett exempel på hur man hanterar "
"borttagningen av ett katalogträd som innehåller skrivskyddade filer."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.rmtree`` med argumenten "
"``path``, ``dir_fd``."

msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr ""
"Lagt till en version som är motståndskraftig mot symlink-attacker och som "
"används automatiskt om plattformen stöder fd-baserade funktioner."

msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr ""
"I Windows tas inte längre innehållet i en katalogövergång bort innan "
"övergången tas bort."

msgid "Added the *dir_fd* parameter."
msgstr "Parametern *dir_fd* har lagts till."

msgid "Added the *onexc* parameter, deprecated *onerror*."
msgstr "Parametern *onexc* tillagd, *onerror* borttagen."

msgid ""
":func:`!rmtree` now ignores :exc:`FileNotFoundError` exceptions for all but "
"the top-level path. Exceptions other than :exc:`OSError` and subclasses of :"
"exc:`!OSError` are now always propagated to the caller."
msgstr ""
":func:`!rmtree` ignorerar nu :exc:`FileNotFoundError`-undantag för alla utom "
"sökvägen på högsta nivån. Andra undantag än :exc:`OSError` och underklasser "
"till :exc:`!OSError` sprids nu alltid till den som anropar."

msgid ""
"Indicates whether the current platform and implementation provides a symlink "
"attack resistant version of :func:`rmtree`.  Currently this is only true for "
"platforms supporting fd-based directory access functions."
msgstr ""
"Anger om den aktuella plattformen och implementationen tillhandahåller en "
"version av :func:`rmtree` som är motståndskraftig mot symlink-attacker.  För "
"närvarande gäller detta endast för plattformar som stöder fd-baserade "
"funktioner för katalogåtkomst."

msgid ""
"Recursively move a file or directory (*src*) to another location and return "
"the destination."
msgstr ""
"Flytta rekursivt en fil eller katalog (*src*) till en annan plats och "
"returnera destinationen."

msgid ""
"If *dst* is an existing directory or a symlink to a directory, then *src* is "
"moved inside that directory. The destination path in that directory must not "
"already exist."
msgstr ""
"Om *dst* är en befintlig katalog eller en symlänk till en katalog, flyttas "
"*src* till den katalogen. Målsökvägen i den katalogen får inte redan "
"existera."

msgid ""
"If *dst* already exists but is not a directory, it may be overwritten "
"depending on :func:`os.rename` semantics."
msgstr ""
"Om *dst* redan finns men inte är en katalog kan den komma att skrivas över "
"beroende på :func:`os.rename` semantik."

msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to the destination using *copy_function* "
"and then removed.  In case of symlinks, a new symlink pointing to the target "
"of *src* will be created as the destination and *src* will be removed."
msgstr ""
"Om destinationen finns i det aktuella filsystemet används :func:`os.rename`. "
"Annars kopieras *src* till destinationen med hjälp av *copy_function* och "
"tas sedan bort.  Om det gäller symlinks skapas en ny symlink som pekar på "
"målet för *src* som destination och *src* tas bort."

msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments, "
"*src* and the destination, and will be used to copy *src* to the destination "
"if :func:`os.rename` cannot be used.  If the source is a directory, :func:"
"`copytree` is called, passing it the *copy_function*. The default "
"*copy_function* is :func:`copy2`.  Using :func:`~shutil.copy` as the "
"*copy_function* allows the move to succeed when it is not possible to also "
"copy the metadata, at the expense of not copying any of the metadata."
msgstr ""
"Om *copy_function* anges måste det vara en anropsbar funktion som tar två "
"argument, *src* och destinationen, och som kommer att användas för att "
"kopiera *src* till destinationen om :func:`os.rename` inte kan användas.  Om "
"källan är en katalog anropas :func:`copytree` som får *copy_function*. "
"Standard *copy_function* är :func:`copy2`.  Genom att använda :func:`~shutil."
"copy` som *copy_function* kan flytten lyckas när det inte är möjligt att "
"även kopiera metadata, på bekostnad av att inga metadata kopieras."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.move`` med argumenten "
"``src``, ``dst``."

msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to "
"the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"Lade till explicit symlänkhantering för utländska filsystem och anpassade "
"den därmed till beteendet i GNU:s :program:`mv`. Returnerar nu *dst*."

msgid "Added the *copy_function* keyword argument."
msgstr "Lagt till nyckelordsargumentet *copy_function*."

msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "Accepterar en :term:`path-like object` för både *src* och *dst*."

msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"Returnerar diskanvändningsstatistik för den angivna sökvägen som en :term:"
"`named tuple` med attributen *total*, *used* och *free*, som är mängden "
"totalt, använt och ledigt utrymme i byte. *path* kan vara en fil eller en "
"katalog."

msgid ""
"On Unix filesystems, *path* must point to a path within a **mounted** "
"filesystem partition. On those platforms, CPython doesn't attempt to "
"retrieve disk usage information from non-mounted filesystems."
msgstr ""
"På Unix-filsystem måste *path* peka på en sökväg inom en **monterad** "
"filsystemspartition. På dessa plattformar försöker CPython inte att hämta "
"information om diskanvändning från icke monterade filsystem."

msgid "On Windows, *path* can now be a file or directory."
msgstr "I Windows kan *path* nu vara en fil eller katalog."

msgid "Availability"
msgstr "Tillgänglighet"

msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "Ändra ägare *user* och/eller *group* för den angivna *path*."

msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr ""
"*user* kan vara ett systemanvändarnamn eller ett uid; samma sak gäller för "
"*group*. Minst ett argument krävs."

msgid "See also :func:`os.chown`, the underlying function."
msgstr "Se även :func:`os.chown`, den underliggande funktionen."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"Utlöser en :ref:`auditing-händelse <auditing>` ``shutil.chown`` med "
"argumenten ``path``, ``user``, ``group``."

msgid "Added *dir_fd* and *follow_symlinks* parameters."
msgstr "Parametrarna *dir_fd* och *follow_symlinks* har lagts till."

msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"Returnerar sökvägen till en körbar fil som skulle köras om den angivna *cmd* "
"anropades.  Om ingen *cmd* skulle anropas returneras ``None``."

msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and is executable."
msgstr ""
"*mode* är en behörighetsmask som skickas till :func:`os.access`, som "
"standard avgör den om filen finns och är körbar."

msgid ""
"*path* is a \"``PATH`` string\" specifying the directories to look in, "
"delimited by :data:`os.pathsep`. When no *path* is specified, the :envvar:"
"`PATH` environment variable is read from :data:`os.environ`, falling back "
"to :data:`os.defpath` if it is not set."
msgstr ""
"*path* är en \"``PATH``-sträng\" som anger de kataloger som ska sökas i, "
"avgränsad av :data:`os.pathsep`. Om ingen *path* anges, läses "
"miljövariabeln :envvar:`PATH` från :data:`os.environ`, och faller tillbaka "
"till :data:`os.defpath` om den inte är inställd."

msgid ""
"If *cmd* contains a directory component, :func:`!which` only checks the "
"specified path directly and does not search the directories listed in *path* "
"or in the system's :envvar:`PATH` environment variable."
msgstr ""
"Om *cmd* innehåller en katalogkomponent kontrollerar :func:`!which` endast "
"den angivna sökvägen direkt och söker inte i de kataloger som anges i *path* "
"eller i systemets miljövariabel :envvar:`PATH`."

msgid ""
"On Windows, the current directory is prepended to the *path* if *mode* does "
"not include ``os.X_OK``. When the *mode* does include ``os.X_OK``, the "
"Windows API ``NeedCurrentDirectoryForExePathW`` will be consulted to "
"determine if the current directory should be prepended to *path*. To avoid "
"consulting the current working directory for executables: set the "
"environment variable ``NoDefaultCurrentDirectoryInExePath``."
msgstr ""
"I Windows prependlas den aktuella katalogen till *path* om *mode* inte "
"innehåller ``os.X_OK``. När *mode* innehåller ``os.X_OK``, kommer Windows "
"API ``NeedCurrentDirectoryForExePathW`` att konsulteras för att avgöra om "
"den aktuella katalogen ska läggas till *path*. För att undvika att den "
"aktuella arbetskatalogen konsulteras för körbara filer: ställ in "
"miljövariabeln ``NoDefaultCurrentDirectoryInExePath``."

msgid ""
"Also on Windows, the :envvar:`PATHEXT` environment variable is used to "
"resolve commands that may not already include an extension. For example, if "
"you call ``shutil.which(\"python\")``, :func:`which` will search ``PATHEXT`` "
"to know that it should look for ``python.exe`` within the *path* "
"directories. For example, on Windows::"
msgstr ""
"I Windows används även miljövariabeln :envvar:`PATHEXT` för att lösa "
"kommandon som kanske inte redan innehåller ett tillägg. Om du till exempel "
"anropar ``shutil.which(\"python\")``, kommer :func:`which` att söka i "
"``PATHEXT`` för att veta att den ska leta efter ``python.exe`` i katalogerna "
"*path*. Till exempel på Windows::"

msgid ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

msgid ""
"This is also applied when *cmd* is a path that contains a directory "
"component::"
msgstr ""
"Detta gäller även när *cmd* är en sökväg som innehåller en katalogkomponent::"

msgid ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
"Typen :class:`bytes` accepteras nu.  Om *cmd*-typen är :class:`bytes`, är "
"resultattypen också :class:`bytes`."

msgid ""
"On Windows, the current directory is no longer prepended to the search path "
"if *mode* includes ``os.X_OK`` and WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` is false, else the current "
"directory is prepended even if it is already in the search path; ``PATHEXT`` "
"is used now even when *cmd* includes a directory component or ends with an "
"extension that is in ``PATHEXT``; and filenames that have no extension can "
"now be found."
msgstr ""
"I Windows läggs inte längre den aktuella katalogen till i sökvägen om *mode* "
"innehåller ``os.X_OK`` och WinAPI ``NeedCurrentDirectoryForExePathW(cmd)`` "
"är false, annars läggs den aktuella katalogen till även om den redan finns i "
"sökvägen; ``PATHEXT`` används nu även när *cmd* innehåller en "
"katalogkomponent eller slutar med ett tillägg som finns i ``PATHEXT``; och "
"filnamn som inte har något tillägg kan nu hittas."

msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of 3-"
"tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"Detta undantag samlar in undantag som uppstår under en operation med flera "
"filer. För :func:`copytree` är undantagsargumentet en lista med 3-tuples "
"(*srcname*, *dstname*, *exception*)."

msgid "Platform-dependent efficient copy operations"
msgstr "Plattformsberoende effektiva kopieringsoperationer"

msgid ""
"Starting from Python 3.8, all functions involving a file copy (:func:"
"`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, and :func:"
"`move`) may use platform-specific \"fast-copy\" syscalls in order to copy "
"the file more efficiently (see :issue:`33671`). \"fast-copy\" means that the "
"copying operation occurs within the kernel, avoiding the use of userspace "
"buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"Från och med Python 3.8 kan alla funktioner som involverar en filkopiering (:"
"func:`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, och :"
"func:`move`) använda plattformsspecifika \"fast-copy\" syscalls för att "
"kopiera filen mer effektivt (se :issue:`33671`). \"Fast-copy\" innebär att "
"kopieringsoperationen sker i kärnan, vilket undviker användning av userspace-"
"buffertar i Python som i \"``outfd.write(infd.read())``\"."

msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr ""
"På macOS används `fcopyfile`_ för att kopiera filinnehållet (inte metadata)."

msgid "On Linux :func:`os.copy_file_range` or :func:`os.sendfile` is used."
msgstr "På Linux används :func:`os.copy_file_range` eller :func:`os.sendfile`."

msgid "On Solaris :func:`os.sendfile` is used."
msgstr "På Solaris används :func:`os.sendfile`."

msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of :func:`shutil."
"copyfileobj` is used."
msgstr ""
"I Windows använder :func:`shutil.copyfile` en större standardbuffertstorlek "
"(1 MiB istället för 64 KiB) och en :func:`memoryview`-baserad variant av :"
"func:`shutil.copyfileobj` används."

msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient :func:"
"`copyfileobj` function internally."
msgstr ""
"Om snabbkopieringen misslyckas och inga data skrevs i målfilen kommer shutil "
"att tyst fallbacka till att använda den mindre effektiva :func:`copyfileobj`-"
"funktionen internt."

msgid "Solaris now uses :func:`os.sendfile`."
msgstr "Solaris använder nu :func:`os.sendfile`."

msgid ""
"Copy-on-write or server-side copy may be used internally via :func:`os."
"copy_file_range` on supported Linux filesystems."
msgstr ""
"Copy-on-write eller kopiering på serversidan kan användas internt via :func:"
"`os.copy_file_range` på Linux-filsystem som stöds."

msgid "copytree example"
msgstr "exempel på copytree"

msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "Ett exempel som använder hjälpen :func:`ignore_patterns`::"

msgid ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"
msgstr ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"

msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""
"Detta kopierar allt utom ``.pyc``-filer och filer eller kataloger vars namn "
"börjar med ``tmp``."

msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr ""
"Ett annat exempel som använder *ignore*-argumentet för att lägga till ett "
"loggningsanrop::"

msgid ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"
msgstr ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"

msgid "rmtree example"
msgstr "exempel på rmtree"

msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onexc callback to clear "
"the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""
"Det här exemplet visar hur man tar bort ett katalogträd i Windows där vissa "
"av filerna har skrivskyddad bit inställd. Det använder onexc callback för "
"att rensa den skrivskyddade biten och göra ett nytt försök att ta bort. "
"Eventuella efterföljande fel kommer att sprida sig. ::"

msgid ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"
msgstr ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"

msgid "Archiving operations"
msgstr "Arkiveringsverksamhet"

msgid "Added support for the *xztar* format."
msgstr "Stöd för formatet *xztar* har lagts till."

msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"Verktyg på hög nivå för att skapa och läsa komprimerade och arkiverade filer "
"tillhandahålls också.  De förlitar sig på modulerna :mod:`zipfile` och :mod:"
"`tarfile`."

msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "Skapa en arkivfil (t.ex. zip eller tar) och ange dess namn."

msgid ""
"*base_name* is the name of the file to create, including the path, minus any "
"format-specific extension."
msgstr ""
"*base_name* är namnet på den fil som ska skapas, inklusive sökvägen, minus "
"eventuella formatspecifika tillägg."

msgid ""
"*format* is the archive format: one of \"zip\" (if the :mod:`zlib` module is "
"available), \"tar\", \"gztar\" (if the :mod:`zlib` module is available), "
"\"bztar\" (if the :mod:`bz2` module is available), \"xztar\" (if the :mod:"
"`lzma` module is available), or \"zstdtar\" (if the :mod:`compression.zstd` "
"module is available)."
msgstr ""
"*format* är arkivformatet: ett av följande: \"zip\" (om modulen :mod:`zlib` "
"finns tillgänglig), \"tar\", \"gztar\" (om modulen :mod:`zlib` finns "
"tillgänglig), \"bztar\" (om modulen :mod:`bz2` finns tillgänglig), "
"\"xztar\" (om modulen :mod:`lzma` finns tillgänglig) eller \"zstdtar\" (om "
"modulen :mod:`compression.zstd` finns tillgänglig)."

msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* är en katalog som kommer att vara arkivets rotkatalog, alla "
"sökvägar i arkivet kommer att vara relativa till den; vi brukar t.ex. chdir:"
"a till *root_dir* innan vi skapar arkivet."

msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-archiving-"
"example-with-basedir` for how to use *base_dir* and *root_dir* together."
msgstr ""
"*base_dir* är den katalog där vi börjar arkivera från, dvs. *base_dir* "
"kommer att vara det gemensamma prefixet för alla filer och kataloger i "
"arkivet.  *base_dir* måste anges i förhållande till *root_dir*.  Se :ref:"
"`shutil-archiving-example-with-basedir` för hur man använder *base_dir* och "
"*root_dir* tillsammans."

msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr ""
"*root_dir* och *base_dir* är båda förvalda till den aktuella katalogen."

msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr ""
"Om *dry_run* är true skapas inget arkiv, men de operationer som skulle ha "
"utförts loggas i *logger*."

msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*owner* och *group* används när ett tar-arkiv skapas. Som standard används "
"den aktuella ägaren och gruppen."

msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* måste vara ett objekt som är kompatibelt med :pep:`282`, vanligtvis "
"en instans av :class:`logging.Logger`."

msgid "The *verbose* argument is unused and deprecated."
msgstr "Argumentet *verbose* är oanvänt och föråldrat."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"Utlöser en :ref:`auditing-händelse <auditing>` ``shutil.make_archive`` med "
"argumenten ``base_name``, ``format``, ``root_dir``, ``base_dir``."

msgid ""
"This function is not thread-safe when custom archivers registered with :func:"
"`register_archive_format` do not support the *root_dir* argument.  In this "
"case it temporarily changes the current working directory of the process to "
"*root_dir* to perform archiving."
msgstr ""
"Den här funktionen är inte trådsäker när anpassade arkiverare som "
"registrerats med :func:`register_archive_format` inte stöder argumentet "
"*root_dir*.  I så fall ändras processens aktuella arbetskatalog tillfälligt "
"till *root_dir* för att utföra arkivering."

msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"Det moderna pax-formatet (POSIX.1-2001) används nu i stället för det äldre "
"GNU-formatet för arkiv som skapats med ``format=\"tar\"``."

msgid ""
"This function is now made thread-safe during creation of standard ``.zip`` "
"and tar archives."
msgstr ""
"Denna funktion är nu trådsäker under skapandet av standardarkiv av typen ``."
"zip`` och tar."

msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"Returnerar en lista över format som stöds för arkivering. Varje element i "
"den returnerade sekvensen är en tupel ``(namn, beskrivning)``."

msgid "By default :mod:`shutil` provides these formats:"
msgstr "Som standard tillhandahåller :mod:`shutil` dessa format:"

msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: ZIP-fil (om modulen :mod:`zlib` är tillgänglig)."

msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr ""
"*tar*: Okomprimerad tar-fil. Använder POSIX.1-2001 pax-format för nya arkiv."

msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr "*gztar*: gzip'ed tar-fil (om modulen :mod:`zlib` är tillgänglig)."

msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr ""
"*bztar*: bzip2-behandlad tar-fil (om modulen :mod:`bz2` är tillgänglig)."

msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr "*xztar*: xz'ed tar-fil (om modulen :mod:`lzma` är tillgänglig)."

msgid ""
"*zstdtar*: Zstandard compressed tar-file (if the :mod:`compression.zstd` "
"module is available)."
msgstr ""
"*zstdtar*: Zstandardkomprimerad tar-fil (om modulen :mod:`compression.zstd` "
"är tillgänglig)."

msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
"Du kan registrera nya format eller tillhandahålla din egen arkiverare för "
"befintliga format genom att använda :func:`register_archive_format`."

msgid "Register an archiver for the format *name*."
msgstr "Registrera en arkiverare för formatet *namn*."

msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the "
"*base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function* är den anropbara funktion som kommer att användas för att packa "
"upp arkiv. Anropsfunktionen tar emot *base_name* för filen som ska skapas, "
"följt av *base_dir* (som standard är :data:`os.curdir`) för att starta "
"arkiveringen från. Ytterligare argument skickas som nyckelordsargument: "
"*owner*, *group*, *dry_run* och *logger* (som skickas i :func:"
"`make_archive`)."

msgid ""
"If *function* has the custom attribute ``function.supports_root_dir`` set to "
"``True``, the *root_dir* argument is passed as a keyword argument. Otherwise "
"the current working directory of the process is temporarily changed to "
"*root_dir* before calling *function*. In this case :func:`make_archive` is "
"not thread-safe."
msgstr ""
"Om *function* har det anpassade attributet ``function.supports_root_dir`` "
"inställt på ``True``, skickas *root_dir*-argumentet som ett "
"nyckelordsargument. Annars ändras processens aktuella arbetskatalog "
"tillfälligt till *root_dir* innan *function* anropas. I det här fallet är :"
"func:`make_archive` inte trådsäker."

msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be "
"used as extra keywords arguments when the archiver callable is used."
msgstr ""
"Om *extra_args* anges är det en sekvens av par av ``(namn, värde)`` som "
"kommer att användas som extra nyckelordsargument när arkiverarens "
"anropsbarhet används."

msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*description* används av :func:`get_archive_formats` som returnerar en lista "
"över arkivbildare.  Standardvärdet är en tom sträng."

msgid "Added support for functions supporting the *root_dir* argument."
msgstr "Lagt till stöd för funktioner som stöder argumentet *root_dir*."

msgid "Remove the archive format *name* from the list of supported formats."
msgstr "Ta bort arkivformatet *name* från listan över format som stöds."

msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr ""
"Packa upp ett arkiv. *filnamn* är den fullständiga sökvägen till arkivet."

msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""
"*extract_dir* är namnet på den målkatalog där arkivet ska packas upp. Om det "
"inte anges används den aktuella arbetskatalogen."

msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", \"xztar\", or \"zstdtar\".  Or any other format registered with :"
"func:`register_unpack_format`.  If not provided, :func:`unpack_archive` will "
"use the archive file name extension and see if an unpacker was registered "
"for that extension.  In case none is found, a :exc:`ValueError` is raised."
msgstr ""
"*format* är arkivformatet: ett av \"zip\", \"tar\", \"gztar\", \"bztar\", "
"\"xztar\" eller \"zstdtar\".  Eller något annat format som registrerats med :"
"func:`register_unpack_format`.  Om inget anges kommer :func:`unpack_archive` "
"att använda arkivets filnamnstillägg och se om en uppackare har registrerats "
"för det tillägget.  Om ingen hittas, kommer ett :exc:`ValueError` att uppstå."

msgid ""
"The keyword-only *filter* argument is passed to the underlying unpacking "
"function. For zip files, *filter* is not accepted. For tar files, it is "
"recommended to use ``'data'`` (default since Python 3.14), unless using "
"features specific to tar and UNIX-like filesystems. (See :ref:`tarfile-"
"extraction-filter` for details.)"
msgstr ""
"Argumentet *filter*, som endast innehåller nyckelord, skickas till den "
"underliggande uppackningsfunktionen. För zip-filer accepteras inte *filter*. "
"För tar-filer rekommenderas det att använda ``'data'`` (standard sedan "
"Python 3.14), såvida man inte använder funktioner som är specifika för tar "
"och UNIX-liknande filsystem. (Se :ref:`tarfile-extraction-filter` för "
"detaljer)"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``shutil.unpack_archive`` med "
"argumenten ``filename``, ``extract_dir``, ``format``."

msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"Extrahera aldrig arkiv från otillförlitliga källor utan föregående "
"inspektion. Det är möjligt att filer skapas utanför den sökväg som anges i "
"argumentet *extract_dir*, t.ex. medlemmar som har absoluta filnamn som "
"börjar med \"/\" eller filnamn med två punkter \"...\"."

msgid ""
"Since Python 3.14, the defaults for both built-in formats (zip and tar "
"files) will prevent the most dangerous of such security issues, but will not "
"prevent *all* unintended behavior. Read the :ref:`tarfile-further-"
"verification` section for tar-specific details."
msgstr ""
"Sedan Python 3.14 kommer standardinställningarna för båda de inbyggda "
"formaten (zip- och tar-filer) att förhindra de farligaste av sådana "
"säkerhetsproblem, men kommer inte att förhindra *alla* oavsiktliga "
"beteenden. Läs avsnittet :ref:`tarfile-further-verification` för tar-"
"specifika detaljer."

msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr ""
"Accepterar en :term:`path-liknande objekt` för *filnamn* och *extract_dir*."

msgid "Added the *filter* argument."
msgstr "Lagt till argumentet *filter*."

msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like ``."
"zip`` for Zip files."
msgstr ""
"Registrerar ett uppackningsformat. *name* är namnet på formatet och "
"*extensions* är en lista med tillägg som motsvarar formatet, t.ex. ``.zip`` "
"för Zip-filer."

msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive:"
msgstr ""
"*function* är den anropbara funktion som kommer att användas för att packa "
"upp arkiv. Den anropsbara funktionen kommer att ta emot:"

msgid "the path of the archive, as a positional argument;"
msgstr "sökvägen till arkivet, som ett positionellt argument;"

msgid ""
"the directory the archive must be extracted to, as a positional argument;"
msgstr ""
"den katalog som arkivet måste extraheras till, som ett positionellt argument;"

msgid ""
"possibly a *filter* keyword argument, if it was given to :func:"
"`unpack_archive`;"
msgstr ""
"eventuellt ett *filter* nyckelordsargument, om det gavs till :func:"
"`unpack_archive`;"

msgid ""
"additional keyword arguments, specified by *extra_args* as a sequence of "
"``(name, value)`` tuples."
msgstr ""
"ytterligare nyckelordsargument, specificerade av *extra_args* som en sekvens "
"av ``(namn, värde)``-tupler."

msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"*description* kan anges för att beskriva formatet och kommer att returneras "
"av funktionen :func:`get_unpack_formats`."

msgid "Unregister an unpack format. *name* is the name of the format."
msgstr "Avregistrera ett uppackningsformat. *name* är namnet på formatet."

msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"Returnerar en lista över alla registrerade format för uppackning. Varje "
"element i den returnerade sekvensen är en tupel ``(name, extensions, "
"description)``."

msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr ""
"*zip*: ZIP-fil (uppackning av komprimerade filer fungerar endast om "
"motsvarande modul finns tillgänglig)."

msgid "*tar*: uncompressed tar file."
msgstr "*tar*: okomprimerad tar-fil."

msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
"Du kan registrera nya format eller tillhandahålla din egen uppackare för "
"befintliga format genom att använda :func:`register_unpack_format`."

msgid "Archiving example"
msgstr "Exempel på arkivering"

msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"I det här exemplet skapar vi ett gzip-komprimerat tar-filarkiv som "
"innehåller alla filer som finns i :file:`.ssh`-katalogen för användaren::"

msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"
msgstr ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"

msgid "The resulting archive contains:"
msgstr "Det resulterande arkivet innehåller:"

msgid ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"
msgstr ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"

msgid "Archiving example with *base_dir*"
msgstr "Exempel på arkivering med *base_dir*"

msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we "
"show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"I det här exemplet, som liknar exemplet ovan <shutil-archiving-example_>`_, "
"visar vi hur man använder :func:`make_archive`, men den här gången med "
"*base_dir*.  Vi har nu följande katalogstruktur:"

msgid ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"
msgstr ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"

msgid ""
"In the final archive, :file:`please_add.txt` should be included, but :file:"
"`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"I det slutliga arkivet ska :file:`please_add.txt` ingå, men :file:"
"`do_not_add.txt` ska inte ingå.  Därför använder vi följande::"

msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/my_archive.tar'"
msgstr ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/my_archive.tar'"

msgid "Listing the files in the resulting archive gives us:"
msgstr "En lista över filerna i det resulterande arkivet ger oss:"

msgid ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"
msgstr ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"

msgid "Querying the size of the output terminal"
msgstr "Fråga om storleken på utdataterminalen"

msgid "Get the size of the terminal window."
msgstr "Hämta storleken på terminalfönstret."

msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value "
"is a positive integer, it is used."
msgstr ""
"För var och en av de två dimensionerna kontrolleras miljövariabeln "
"``COLUMNS`` respektive ``LINES``. Om variabeln är definierad och värdet är "
"ett positivt heltal används den."

msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking :func:"
"`os.get_terminal_size`."
msgstr ""
"När ``COLUMNS`` eller ``LINES`` inte är definierade, vilket är det vanliga "
"fallet, frågas terminalen som är ansluten till :data:`sys.__stdout__` genom "
"att anropa :func:`os.get_terminal_size`."

msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"Om det inte går att fråga efter terminalstorleken, antingen för att systemet "
"inte stöder en sådan fråga eller för att vi inte är anslutna till en "
"terminal, används det värde som anges i parametern ``fallback``. "
"standardvärdet för ``fallback`` är ``(80, 24)``, vilket är den "
"standardstorlek som används av många terminalemulatorer."

msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr ""
"Det värde som returneras är en namngiven tupel av typen :class:`os."
"terminal_size`."

msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"Se även: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."

msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr ""
"``fallback``-värdena används också om :func:`os.get_terminal_size` "
"returnerar noll."

msgid "file"
msgstr "fil"

msgid "copying"
msgstr "kopiering"

msgid "copying files"
msgstr "kopiering av filer"

msgid "directory"
msgstr "katalog"

msgid "deleting"
msgstr "radering"
