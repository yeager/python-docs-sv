# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!unittest.mock` --- mock object library"
msgstr ":mod:`!unittest.mock` --- mock-objektbibliotek"

msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**Källkod:** :source:`Lib/unittest/mock.py`"

msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` är ett bibliotek för testning i Python. Det låter dig "
"ersätta delar av ditt system under test med mock-objekt och göra påståenden "
"om hur de har använts."

msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` tillhandahåller en grundläggande :class:`Mock`-klass "
"som tar bort behovet av att skapa en mängd stubbar i hela din testsvit. När "
"du har utfört en åtgärd kan du göra påståenden om vilka metoder/attribut som "
"användes och vilka argument de anropades med. Du kan också ange returvärden "
"och ställa in nödvändiga attribut på vanligt sätt."

msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with :"
"const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and :func:"
"`patch`."
msgstr ""
"Dessutom tillhandahåller mock en :func:`patch`-dekorator som hanterar "
"patchning av attribut på modul- och klassnivå inom ramen för ett test, "
"tillsammans med :const:`sentinel` för att skapa unika objekt. Se `quick "
"guide`_ för några exempel på hur man använder :class:`Mock`, :class:"
"`MagicMock` och :func:`patch`."

msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action -> "
"assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"Mock är utformat för att användas med :mod:`unittest` och baseras på "
"mönstret \"action -> assertion\" istället för \"record -> replay\" som "
"används av många mocking-ramverk."

msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as :pypi:`mock` on PyPI."
msgstr ""
"Det finns en bakåtport av :mod:`unittest.mock` för tidigare versioner av "
"Python, tillgänglig som :pypi:`mock` på PyPI."

msgid "Quick Guide"
msgstr "Snabbguide"

msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You "
"can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
"objekten :class:`Mock` och :class:`MagicMock` skapar alla attribut och "
"metoder när du använder dem och lagrar information om hur de har använts. Du "
"kan konfigurera dem för att ange returvärden eller begränsa vilka attribut "
"som är tillgängliga, och sedan göra påståenden om hur de har använts:"

msgid ""
":attr:`~Mock.side_effect` allows you to perform side effects, including "
"raising an exception when a mock is called:"
msgstr ""
":attr:`~Mock.side_effect` gör att du kan utföra sidoeffekter, inklusive att "
"skapa ett undantag när en mock anropas:"

msgid ""
"Mock has many other ways you can configure it and control its behaviour. For "
"example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"Mock har många andra sätt som du kan konfigurera och styra dess beteende på. "
"Till exempel konfigurerar argumentet *spec* mock så att den hämtar sin "
"specifikation från ett annat objekt. Försök att komma åt attribut eller "
"metoder på mocken som inte finns i specifikationen kommer att misslyckas med "
"ett :exc:`AttributeError`."

msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
"Dekoratorn/kontexthanteraren :func:`patch` gör det enkelt att mocka klasser "
"eller objekt i en modul som testas. Det objekt du anger kommer att ersättas "
"med en mock (eller annat objekt) under testet och återställas när testet "
"avslutas:"

msgid ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"
msgstr ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"

msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"När du nestar patch-dekoratorer skickas mockarna in till den dekorerade "
"funktionen i samma ordning som de tillämpas (den normala *Python*-ordningen "
"som dekoratorer tillämpas). Detta betyder nerifrån och upp, så i exemplet "
"ovan skickas mocken för ``module.ClassName1`` in först."

msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"Med :func:`patch` är det viktigt att du patchar objekt i den namnrymd där de "
"söks upp. Detta är normalt enkelt, men för en snabb guide läs :ref:``where "
"to patch <where-to-patch>``."

msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr ""
"Liksom en dekorator kan :func:`patch` användas som en kontexthanterare i en "
"with-sats:"

msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Det finns också :func:`patch.dict` för att ställa in värden i en ordbok bara "
"under ett scope och återställa ordboken till dess ursprungliga tillstånd när "
"testet avslutas:"

msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class. "
"It allows you to do things like:"
msgstr ""
"Mock stöder mockning av Python :ref:`magiska metoder <magic-methods>`. Det "
"enklaste sättet att använda magiska metoder är med :class:`MagicMock`-"
"klassen. Det gör att du kan göra saker som:"

msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you "
"(well, all the useful ones anyway)."
msgstr ""
"Med Mock kan du tilldela funktioner (eller andra Mock-instanser) till "
"magiska metoder och de kommer att anropas på lämpligt sätt. Klassen :class:"
"`MagicMock` är bara en Mock-variant som har alla de magiska metoderna "
"förskapade åt dig (i alla fall alla användbara)."

msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr ""
"Nedan följer ett exempel på hur man använder magiska metoder med den vanliga "
"Mock-klassen:"

msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"För att säkerställa att mock-objekten i dina tester har samma api som de "
"objekt de ersätter kan du använda :ref:`auto-speccing <auto-speccing>`. Auto-"
"speccing kan göras genom *autospec*-argumentet till patch, eller funktionen :"
"func:`create_autospec`. Auto-speccing skapar låtsasobjekt som har samma "
"attribut och metoder som de objekt de ersätter, och alla funktioner och "
"metoder (inklusive konstruktörer) har samma anropssignatur som det riktiga "
"objektet."

msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr ""
"Detta säkerställer att dina mocks kommer att misslyckas på samma sätt som "
"din produktionskod om de används felaktigt:"

msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec` kan också användas på klasser, där den kopierar "
"signaturen för metoden ``__init__``, och på anropsbara objekt där den "
"kopierar signaturen för metoden ``__call__``."

msgid "The Mock Class"
msgstr "Den låtsasklassen"

msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs "
"and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` är ett flexibelt mock-objekt som är avsett att ersätta "
"användningen av stubbar och testdubblar i hela din kod. Mockar är anropsbara "
"och skapar attribut som nya mockar när du använder dem [#]_. Att komma åt "
"samma attribut kommer alltid att returnera samma mock. Mocks registrerar hur "
"du använder dem, så att du kan göra påståenden om vad din kod har gjort med "
"dem."

msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods "
"pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: :class:"
"`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` är en subklass av :class:`Mock` med alla magiska metoder "
"förskapade och redo att användas. Det finns också icke anropsbara varianter, "
"användbara när du mockar ut objekt som inte är anropsbara: :class:"
"`NonCallableMock` och :class:`NonCallableMagicMock`"

msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in "
"a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
"Dekoratorn :func:`patch` gör det enkelt att tillfälligt ersätta klasser i en "
"viss modul med ett :class:`Mock`-objekt. Som standard kommer :func:`patch` "
"att skapa en :class:`MagicMock` åt dig. Du kan ange en alternativ klass "
"till :class:`Mock` med hjälp av argumentet *new_callable* till :func:`patch`."

msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr ""
"Skapa ett nytt :class:`Mock`-objekt. :class:`Mock` tar flera valfria "
"argument som anger beteendet hos Mock-objektet:"

msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass "
"in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*spec*: Detta kan vara antingen en lista med strängar eller ett befintligt "
"objekt (en klass eller instans) som fungerar som specifikation för mock-"
"objektet. Om du skickar in ett objekt bildas en lista med strängar genom att "
"anropa dir på objektet (exklusive magiska attribut och metoder som inte "
"stöds). Åtkomst till ett attribut som inte finns i listan kommer att ge "
"upphov till ett :exc:`AttributeError`."

msgid ""
"If *spec* is an object (rather than a list of strings) then :attr:`~object."
"__class__` returns the class of the spec object. This allows mocks to pass :"
"func:`isinstance` tests."
msgstr ""
"Om *spec* är ett objekt (snarare än en lista med strängar) returnerar :attr:"
"`~object.__class__` klassen för spec-objektet. Detta gör att låtsasobjekt "
"kan klara :func:`isinstance`-tester."

msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*: En striktare variant av *spec*. Om den används kommer försök att "
"*set* eller hämta ett attribut på mock som inte finns på objektet som "
"skickas som *spec_set* att ge upphov till ett :exc:`AttributeError`."

msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the :"
"attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect*: En funktion som ska anropas när Mock anropas. Se attributet :"
"attr:`~Mock.side_effect`. Användbar för att skapa undantag eller dynamiskt "
"ändra returvärden. Funktionen anropas med samma argument som mock, och om "
"den inte returnerar :data:`DEFAULT`, används returvärdet för denna funktion "
"som returvärde."

msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr ""
"Alternativt kan *side_effect* vara en undantagsklass eller -instans. I detta "
"fall kommer undantaget att uppstå när mocken anropas."

msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr ""
"Om *side_effect* är en iterabel kommer varje anrop till mock att returnera "
"nästa värde från iterabeln."

msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "En *side_effect* kan raderas genom att den sätts till ``None``."

msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value*: Det värde som returneras när mocken anropas. Som standard är "
"detta en ny Mock (skapas vid första åtkomst). Se attributet :attr:"
"`return_value`."

msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an :exc:"
"`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""
"*osäker*: Som standard kommer åtkomst till alla attribut vars namn börjar "
"med *assert*, *assret*, *asert*, *aseert* eller *assrt* att ge upphov till "
"ett :exc:`AttributeError`. Om du anger ``unsafe=True`` tillåts åtkomst till "
"dessa attribut."

msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning "
"the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an :exc:"
"`AttributeError`)."
msgstr ""
"*omsluter*: Objekt för det låtsasobjekt som ska omslutas. Om *wraps* inte är "
"``None`` kommer anropet till Mock att skicka anropet vidare till det "
"omslutna objektet (och returnera det verkliga resultatet). Attributåtkomst "
"på mocken kommer att returnera ett Mock-objekt som omsluter motsvarande "
"attribut för det omslutna objektet (så försök att komma åt ett attribut som "
"inte finns kommer att ge upphov till ett :exc:`AttributeError`)."

msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr ""
"Om mock har ett explicit *return_value* inställt skickas inte anrop till det "
"inkapslade objektet och *return_value* returneras istället."

msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock. "
"This can be useful for debugging. The name is propagated to child mocks."
msgstr ""
"*namn*: Om mocken har ett namn kommer det att användas i mockens repr. Detta "
"kan vara användbart för felsökning. Namnet sprids till underordnade mockar."

msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the :meth:"
"`configure_mock` method for details."
msgstr ""
"Mocks kan också anropas med godtyckliga nyckelordsargument. Dessa kommer att "
"användas för att ställa in attribut på mocken efter att den har skapats. Se "
"metoden :meth:`configure_mock` för mer information."

msgid "Assert that the mock was called at least once."
msgstr "Försäkra dig om att mocken har anropats minst en gång."

msgid "Assert that the mock was called exactly once."
msgstr "Försäkra dig om att mock anropades exakt en gång."

msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr ""
"Denna metod är ett bekvämt sätt att försäkra sig om att det sista anropet "
"har gjorts på ett visst sätt:"

msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr ""
"Försäkra dig om att mock anropades exakt en gång och att anropet gjordes med "
"de angivna argumenten."

msgid "assert the mock has been called with the specified arguments."
msgstr "bekräftar att mock har anropats med de angivna argumenten."

msgid ""
"The assert passes if the mock has *ever* been called, unlike :meth:"
"`assert_called_with` and :meth:`assert_called_once_with` that only pass if "
"the call is the most recent one, and in the case of :meth:"
"`assert_called_once_with` it must also be the only call."
msgstr ""
"Assertet godkänns om mocken *alltid* har anropats, till skillnad från :meth:"
"`assert_called_with` och :meth:`assert_called_once_with` som bara godkänns "
"om anropet är det senaste, och i fallet med :meth:`assert_called_once_with` "
"måste det också vara det enda anropet."

msgid ""
"assert the mock has been called with the specified calls. The :attr:"
"`mock_calls` list is checked for the calls."
msgstr ""
"försäkrar att mocken har anropats med de angivna anropen. Listan :attr:"
"`mock_calls` kontrolleras för anropen."

msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr ""
"Om *any_order* är false måste anropen vara sekventiella. Det kan finnas "
"extra anrop före eller efter de angivna anropen."

msgid ""
"If *any_order* is true then the calls can be in any order, but they must all "
"appear in :attr:`mock_calls`."
msgstr ""
"Om *any_order* är true kan anropen vara i vilken ordning som helst, men de "
"måste alla visas i :attr:`mock_calls`."

msgid "Assert the mock was never called."
msgstr "Påstå att mocken aldrig kallades."

msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "Metoden reset_mock återställer alla anropsattribut på ett mock-objekt:"

msgid ""
">>> mock = Mock(return_value=None)\n"
">>> mock('hello')\n"
">>> mock.called\n"
"True\n"
">>> mock.reset_mock()\n"
">>> mock.called\n"
"False"
msgstr ""
">>> mock = Mock(return_value=None)\n"
">>> mock('hallå')\n"
">>> mock.kallas\n"
"Sant\n"
">>> mock.reset_mock()\n"
">>> mock.kallas\n"
"Falskt"

msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object."
msgstr ""
"Detta kan vara användbart om du vill göra en serie påståenden som "
"återanvänder samma objekt."

msgid ""
"*return_value* parameter when set to ``True`` resets :attr:`return_value`:"
msgstr ""
"*return_value* parameter när den sätts till ``True`` återställer :attr:"
"`return_value`:"

msgid ""
">>> mock = Mock(return_value=5)\n"
">>> mock('hello')\n"
"5\n"
">>> mock.reset_mock(return_value=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""
"&gt;&gt;&gt; mock = Mock(return_value=5)\n"
"&gt;&gt;&gt; mock('hallå')\n"
"5\n"
"&gt;&gt;&gt; mock.reset_mock(return_value=True)\n"
"&gt;&gt;&gt; mock('hallå')\n"
"<Mock name='mock()' id='...'>"

msgid ""
"*side_effect* parameter when set to ``True`` resets :attr:`side_effect`:"
msgstr ""
"*side_effect* parameter när den sätts till ``True`` återställer :attr:"
"`side_effect`:"

msgid ""
">>> mock = Mock(side_effect=ValueError)\n"
">>> mock('hello')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError\n"
">>> mock.reset_mock(side_effect=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""
"&gt;&gt;&gt; mock = Mock(side_effect=ValueError)\n"
"&gt;&gt;&gt; mock('hello')\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"VärdeFel\n"
"&gt;&gt;&gt; mock.reset_mock(side_effect=True)\n"
"&gt;&gt;&gt; mock('hallå')\n"
"<Mock name='mock()' id='...'>"

msgid ""
"Note that :meth:`reset_mock` *doesn't* clear the :attr:`return_value`, :attr:"
"`side_effect` or any child attributes you have set using normal assignment "
"by default."
msgstr ""
"Observera att :meth:`reset_mock` *inte* rensar :attr:`return_value`, :attr:"
"`side_effect` eller några underordnade attribut som du har ställt in med "
"normal tilldelning som standard."

msgid "Child mocks are reset as well."
msgstr "Child mocks återställs också."

msgid "Added two keyword-only arguments to the reset_mock function."
msgstr ""
"Lagt till två argument som endast är nyckelord till reset_mock-funktionen."

msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr ""
"Lägg till en specifikation till en mock. *spec* kan antingen vara ett objekt "
"eller en lista med strängar. Endast attribut på *spec* kan hämtas som "
"attribut från mock."

msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr ""
"Om *spec_set* är true kan endast attribut i specifikationen ställas in."

msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and :"
"attr:`mock_calls` attributes of this one."
msgstr ""
"Bifogar en mock som ett attribut till den här, och ersätter dess namn och "
"förälder. Anrop till den bifogade mocken kommer att registreras i "
"attributen :attr:`method_calls` och :attr:`mock_calls` för denna."

msgid "Set attributes on the mock through keyword arguments."
msgstr "Ställ in attribut på mock genom nyckelordsargument."

msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr ""
"Attribut, returvärden och bieffekter kan ställas in på underordnade mocks "
"med hjälp av standardpunktnotation och uppackning av en ordbok i "
"metodanropet:"

msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "Samma sak kan uppnås i konstruktörsanropet till mocks:"

msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ""
":meth:`configure_mock` finns för att göra det enklare att konfigurera efter "
"att mocken har skapats."

msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
":class:`Mock`-objekt begränsar resultaten av ``dir(some_mock)`` till "
"användbara resultat. För låtsasobjekt med en *spec* inkluderar detta alla "
"tillåtna attribut för låtsasobjektet."

msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr ""
"Se :data:`FILTER_DIR` för vad denna filtrering gör och hur du stänger av den."

msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr ""
"Skapa de underordnade mockarna för attribut och returvärde. Som standard "
"kommer underordnade mocks att vara av samma typ som den överordnade. "
"Subklasser av Mock kan vilja åsidosätta detta för att anpassa hur "
"underordnade mocks skapas."

msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr ""
"För icke anropsbara mocks kommer den anropsbara varianten att användas "
"(snarare än någon anpassad subklass)."

msgid "A boolean representing whether or not the mock object has been called:"
msgstr "En boolean som anger om mock-objektet har anropats eller inte:"

msgid "An integer telling you how many times the mock object has been called:"
msgstr "Ett heltal som talar om hur många gånger mock-objektet har anropats:"

msgid "Set this to configure the value returned by calling the mock:"
msgstr ""
"Ställ in detta för att konfigurera det värde som returneras när du anropar "
"mock:"

msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr ""
"Standardreturvärdet är ett mock-objekt och du kan konfigurera det på vanligt "
"sätt:"

msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` kan också ställas in i konstruktorn:"

msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr ""
"Detta kan antingen vara en funktion som ska anropas när mock anropas, en "
"iterabel eller ett undantag (klass eller instans) som ska tas upp."

msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from "
"the :attr:`return_value`)."
msgstr ""
"Om du skickar in en funktion kommer den att anropas med samma argument som "
"mock och om inte funktionen returnerar :data:`DEFAULT` singleton kommer "
"anropet till mock att returnera det som funktionen returnerar. Om funktionen "
"returnerar :data:`DEFAULT` så kommer mock att returnera sitt normala värde "
"(från :attr:`return_value`)."

msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance "
"to be raised, or a value to be returned from the call to the mock (:data:"
"`DEFAULT` handling is identical to the function case)."
msgstr ""
"Om du skickar in en iterable används den för att hämta en iterator som måste "
"ge ett värde vid varje anrop.  Detta värde kan antingen vara en "
"undantagsinstans som ska aktiveras eller ett värde som ska returneras från "
"anropet till mock (:data:`DEFAULT`-hanteringen är identisk med "
"funktionsfallet)."

msgid ""
"An example of a mock that raises an exception (to test exception handling of "
"an API):"
msgstr ""
"Ett exempel på en mock som ger upphov till ett undantag (för att testa "
"undantagshanteringen i ett API):"

msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr "Använda :attr:`side_effect` för att returnera en sekvens av värden:"

msgid "Using a callable:"
msgstr "Använda en köpbar enhet:"

msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ""
":attr:`side_effect` kan ställas in i konstruktören. Här är ett exempel som "
"lägger till en till det värde som mocken anropas med och returnerar det:"

msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr "Om du ställer in :attr:`side_effect` till ``None`` raderas den:"

msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the "
"first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""
"Detta är antingen ``None`` (om mock inte har anropats), eller de argument "
"som mock senast anropades med. Detta kommer att vara i form av en tupel: den "
"första medlemmen, som också kan nås via egenskapen ``args``, är alla ordnade "
"argument som mocken anropades med (eller en tom tupel) och den andra "
"medlemmen, som också kan nås via egenskapen ``kwargs``, är alla "
"nyckelordsargument (eller en tom ordbok)."

msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, :"
"attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args`, tillsammans med medlemmar av listorna :attr:"
"`call_args_list`, :attr:`method_calls` och :attr:`mock_calls` är :data:"
"`call`-objekt. Dessa är tupler, så de kan packas upp för att komma åt de "
"enskilda argumenten och göra mer komplexa påståenden. Se :ref:`calls as "
"tuples <calls-as-tuples>`."

msgid "Added ``args`` and ``kwargs`` properties."
msgstr "Lagt till egenskaperna ``args`` och ``kwargs``."

msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with :attr:"
"`call_args_list`."
msgstr ""
"Detta är en lista över alla anrop som gjorts till mock-objektet i sekvens "
"(så längden på listan är antalet gånger det har anropats). Innan några anrop "
"har gjorts är det en tom lista. Objektet :data:`call` kan användas för att "
"på ett enkelt sätt konstruera listor över anrop som kan jämföras med :attr:"
"`call_args_list`."

msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Medlemmar i :attr:`call_args_list` är :data:`call`-objekt. Dessa kan packas "
"upp som tupler för att komma åt de enskilda argumenten. Se :ref:``anrop som "
"tuvor <calls-as-tuples>`."

msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr ""
"Förutom att spåra anrop till sig själva, spårar mocks också anrop till "
"metoder och attribut, och *deras* metoder och attribut:"

msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Medlemmar i :attr:`method_calls` är :data:`call`-objekt. Dessa kan packas "
"upp som tupler för att komma åt de enskilda argumenten. Se :ref:`calls som "
"tuvor <calls-as-tuples>`."

msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ""
":attr:`mock_calls` registrerar *alla* anrop till mock-objektet, dess "
"metoder, magiska metoder *och* return value mocks."

msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Medlemmar i :attr:`mock_calls` är :data:`call`-objekt. Dessa kan packas upp "
"som tupler för att komma åt de enskilda argumenten. Se :ref:`calls som tuvor "
"<calls-as-tuples>`."

msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ""
"Sättet som :attr:`mock_calls` registreras på innebär att när nästlade anrop "
"görs, registreras inte parametrarna för förfädernas anrop och de kommer "
"därför alltid att jämföras lika:"

msgid ""
"Normally the :attr:`!__class__` attribute of an object will return its type. "
"For a mock object with a :attr:`!spec`, :attr:`!__class__` returns the spec "
"class instead. This allows mock objects to pass :func:`isinstance` tests for "
"the object they are replacing / masquerading as:"
msgstr ""
"Normalt kommer attributet :attr:`!__class__` för ett objekt att returnera "
"dess typ. För ett låtsasobjekt med :attr:`!spec` returnerar :attr:`!"
"__class__` istället spec-klassen. Detta gör att låtsasobjekt kan klara :func:"
"`isinstance`-tester för det objekt som de ersätter/maskerar sig som:"

msgid ""
":attr:`!__class__` is assignable to, this allows a mock to pass an :func:"
"`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`!__class__` är tilldelningsbar till, tillåter detta en mock att klara "
"en :func:`isinstance` kontroll utan att tvinga dig att använda en spec:"

msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the "
"same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
"En icke anropsbar version av :class:`Mock`. Parametrarna i konstruktören har "
"samma betydelse som i :class:`Mock`, med undantag för *return_value* och "
"*side_effect* som inte har någon betydelse för en icke anropsbar mock."

msgid ""
"Mock objects that use a class or an instance as a :attr:`!spec` or :attr:`!"
"spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"Låtsasobjekt som använder en klass eller en instans som :attr:`!spec` eller :"
"attr:`!spec_set` kan klara :func:`isinstance`-tester:"

msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See :ref:"
"`magic methods <magic-methods>` for the full details."
msgstr ""
"Klasserna :class:`Mock` har stöd för mocking av magiska metoder. Se :ref:"
"`magiska metoder <magic-methods>` för fullständiga detaljer."

msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword "
"arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"Mock-klasserna och :func:`patch`-dekoratorerna tar alla godtyckliga "
"nyckelordsargument för konfiguration. För :func:`patch`-dekoratorerna "
"skickas nyckelorden till konstruktören för den mock som skapas. "
"Nyckelordsargumenten är till för att konfigurera attribut hos låtsasobjektet:"

msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"Returvärdet och bieffekten för underordnade mocks kan anges på samma sätt, "
"med hjälp av prickad notation. Eftersom du inte kan använda punktnamn direkt "
"i ett anrop måste du skapa en ordbok och packa upp den med ``**``:"

msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"En anropsbar mock som skapades med en *spec* (eller en *spec_set*) kommer "
"att introspektera specifikationsobjektets signatur när den matchar anrop "
"till mocken.  Därför kan den matcha det faktiska anropets argument oavsett "
"om de skickades positionellt eller med namn::"

msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
"&gt;&gt;&gt; def f(a, b, c): pass\n"
"...\n"
"&gt;&gt;&gt; mock = Mock(spec=f)\n"
"&gt;&gt;&gt; mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
"&gt;&gt;&gt; mock.assert_called_with(1, 2, 3)\n"
"&gt;&gt;&gt; mock.assert_called_with(a=1, b=2, c=3)"

msgid ""
"This applies to :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call`.  When :ref:`auto-speccing`, it will also apply to method "
"calls on the mock object."
msgstr ""
"Detta gäller för :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` och :meth:`~Mock."
"assert_any_call`.  När :ref:`auto-speccing`, kommer det också att gälla för "
"metodanrop på mock-objektet."

msgid "Added signature introspection on specced and autospecced mock objects."
msgstr ""
"Lagt till signaturintrospektion på specificerade och autospecerade mock-"
"objekt."

msgid ""
"A mock intended to be used as a :class:`property`, or other :term:"
"`descriptor`, on a class. :class:`PropertyMock` provides :meth:`~object."
"__get__` and :meth:`~object.__set__` methods so you can specify a return "
"value when it is fetched."
msgstr ""
"En mock avsedd att användas som en :class:`property`, eller annan :term:"
"`descriptor`, på en klass. :class:`PropertyMock` tillhandahåller metoderna :"
"meth:`~object.__get__` och :meth:`~object.__set__` så att du kan ange ett "
"returvärde när den hämtas."

msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"Att hämta en :class:`PropertyMock`-instans från ett objekt anropar mocken, "
"utan args. Om den ställs in anropas mocken med det värde som ställs in. ::"

msgid ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"
msgstr ""
">>> klass Foo:\n"
"...     @egenskap\n"
"... def foo(self):\n"
"... return 'något'\n"
"...     @foo.setter\n"
"... def foo(self, värde):\n"
"... pass\n"
"...\n"
">>> med patch('__main__.Foo.foo', new_callable=PropertyMock) som mock_foo:\n"
"... mock_foo.return_value = 'mockity-mock'\n"
"... detta_foo = Foo()\n"
"... print(this_foo.foo)\n"
"... this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"

msgid ""
"Because of the way mock attributes are stored you can't directly attach a :"
"class:`PropertyMock` to a mock object. Instead you can attach it to the mock "
"type object::"
msgstr ""
"På grund av det sätt som mock-attribut lagras kan du inte direkt koppla en :"
"class:`PropertyMock` till ett mock-objekt. Istället kan du koppla det till "
"mock-objektet::"

msgid ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"
msgstr ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> typ(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"

msgid ""
"If an :exc:`AttributeError` is raised by :class:`PropertyMock`, it will be "
"interpreted as a missing descriptor and :meth:`~object.__getattr__` will be "
"called on the parent mock::"
msgstr ""
"Om ett :exc:`AttributeError` uppstår i :class:`PropertyMock` tolkas det som "
"att en deskriptor saknas och :meth:`~object.__getattr__` anropas på den "
"överordnade mock::"

msgid ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"
msgstr ""
"&gt;&gt;&gt; m = MagicMock()\n"
"&gt;&gt;&gt; no_attribute = PropertyMock(side_effect=AttributeError)\n"
"&gt;&gt;&gt; typ(m).my_property = no_attribute\n"
"&gt;&gt;&gt; m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"

msgid "See :meth:`~object.__getattr__` for details."
msgstr "Se :meth:`~object.__getattr__` för mer information."

msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object "
"will behave so the object is recognized as an async function, and the result "
"of a call is an awaitable."
msgstr ""
"En asynkron version av :class:`MagicMock`. Objektet :class:`AsyncMock` "
"kommer att bete sig så att objektet känns igen som en asynkron funktion och "
"resultatet av ett anrop är en awaitable."

msgid ""
"The result of ``mock()`` is an async function which will have the outcome of "
"``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""
"Resultatet av ``mock()`` är en asynkron funktion som kommer att få "
"resultatet ``side_effect`` eller ``return_value`` efter att den har väntat:"

msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr ""
"om ``side_effect`` är en funktion, kommer async-funktionen att returnera "
"resultatet av den funktionen,"

msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr ""
"om ``side_effect`` är ett undantag, kommer async-funktionen att lyfta "
"undantaget,"

msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""
"om ``side_effect`` är en iterabel, kommer async-funktionen att returnera "
"nästa värde i iterabeln, men om resultatsekvensen är uttömd, kommer "
"``StopAsyncIteration`` att aktiveras omedelbart,"

msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a "
"new :class:`AsyncMock` object."
msgstr ""
"om ``side_effect`` inte är definierad, kommer async-funktionen att returnera "
"det värde som definieras av ``return_value``, därför returnerar async-"
"funktionen som standard ett nytt :class:`AsyncMock`-objekt."

msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr ""
"Om du anger *spec* för en :class:`Mock` eller :class:`MagicMock` till en "
"asynkron funktion kommer ett coroutine-objekt att returneras efter anropet."

msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or :class:"
"`AsyncMock` to a class with asynchronous and synchronous functions will "
"automatically detect the synchronous functions and set them as :class:"
"`MagicMock` (if the parent mock is :class:`AsyncMock` or :class:`MagicMock`) "
"or :class:`Mock` (if the parent mock is :class:`Mock`). All asynchronous "
"functions will be :class:`AsyncMock`."
msgstr ""
"Om du anger *spec* för en :class:`Mock`, :class:`MagicMock` eller :class:"
"`AsyncMock` till en klass med asynkrona och synkrona funktioner kommer "
"synkrona funktioner automatiskt att identifieras och anges som :class:"
"`MagicMock` (om den överordnade mocken är :class:`AsyncMock` eller :class:"
"`MagicMock`) eller :class:`Mock` (om den överordnade mocken är :class:"
"`Mock`). Alla asynkrona funktioner kommer att vara :class:`AsyncMock`."

msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr ""
"Bekräftar att mocken var väntad minst en gång. Observera att detta är "
"separat från att objektet har anropats, nyckelordet ``await`` måste användas:"

msgid "Assert that the mock was awaited exactly once."
msgstr "Påstå att mocken väntades exakt en gång."

msgid "Assert that the last await was with the specified arguments."
msgstr "Försäkra dig om att den senaste await var med de angivna argumenten."

msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr ""
"Bekräftar att mocken väntades exakt en gång och med de angivna argumenten."

msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr "Bekräfta att mock någonsin har väntats med de angivna argumenten."

msgid ""
"Assert the mock has been awaited with the specified calls. The :attr:"
"`await_args_list` list is checked for the awaits."
msgstr ""
"Bekräftar att mock har blivit awaited med de angivna anropen. Listan :attr:"
"`await_args_list` kontrolleras för awaits."

msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr ""
"Om *any_order* är false måste väntetiderna vara sekventiella. Det kan finnas "
"extra anrop före eller efter den angivna väntan."

msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr ""
"Om *any_order* är true kan awaits vara i vilken ordning som helst, men de "
"måste alla finnas med i :attr:`await_args_list`."

msgid "Assert that the mock was never awaited."
msgstr "Påstå att spottet aldrig var väntat."

msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, :attr:"
"`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
"Se :func:`Mock.reset_mock`. Sätter även :attr:`await_count` till 0, :attr:"
"`await_args` till None, och rensar :attr:`await_args_list`."

msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr ""
"Ett heltal som håller reda på hur många gånger mock-objektet har väntats på."

msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as :attr:`Mock."
"call_args`."
msgstr ""
"Detta är antingen ``None`` (om mocken inte har väntats på), eller de "
"argument som mocken senast väntades på med. Fungerar på samma sätt som :attr:"
"`Mock.call_args`."

msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the "
"length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr ""
"Detta är en lista över alla väntan som gjorts på mock-objektet i sekvens (så "
"längden på listan är antalet gånger det har väntat). Innan någon väntan har "
"gjorts är det en tom lista."

msgid ""
"A version of :class:`MagicMock` for multithreading tests. The :class:"
"`ThreadingMock` object provides extra methods to wait for a call to be "
"invoked, rather than assert on it immediately."
msgstr ""
"En version av :class:`MagicMock` för multithreading-tester. Objektet :class:"
"`ThreadingMock` tillhandahåller extra metoder för att vänta på att ett anrop "
"ska anropas, i stället för att göra en assert på det omedelbart."

msgid ""
"The default timeout is specified by the ``timeout`` argument, or if unset by "
"the :attr:`ThreadingMock.DEFAULT_TIMEOUT` attribute, which defaults to "
"blocking (``None``)."
msgstr ""
"Standardtimeouten anges av argumentet ``timeout``, eller om den inte anges "
"av attributet :attr:`ThreadingMock.DEFAULT_TIMEOUT`, som har blockering "
"(``None``) som standard."

msgid ""
"You can configure the global default timeout by setting :attr:`ThreadingMock."
"DEFAULT_TIMEOUT`."
msgstr ""
"Du kan konfigurera den globala standardtimeouten genom att ställa in :attr:"
"`ThreadingMock.DEFAULT_TIMEOUT`."

msgid "Waits until the mock is called."
msgstr "Väntar tills mocken anropas."

msgid ""
"If a timeout was passed at the creation of the mock or if a timeout argument "
"is passed to this function, the function raises an :exc:`AssertionError` if "
"the call is not performed in time."
msgstr ""
"Om en timeout angavs när mock skapades eller om ett timeout-argument anges "
"till denna funktion, ger funktionen upphov till ett :exc:`AssertionError` om "
"anropet inte utförs i tid."

msgid "Waits until the mock is called with the specified arguments."
msgstr "Väntar tills mock anropas med de angivna argumenten."

msgid ""
"If a timeout was passed at the creation of the mock the function raises an :"
"exc:`AssertionError` if the call is not performed in time."
msgstr ""
"Om en tidsgräns angavs vid skapandet av mocken ger funktionen upphov till "
"ett :exc:`AssertionError` om anropet inte utförs i tid."

msgid ""
"Global default timeout in seconds to create instances of :class:"
"`ThreadingMock`."
msgstr ""
"Global standardtimeout i sekunder för att skapa instanser av :class:"
"`ThreadingMock`."

msgid "Calling"
msgstr "Ringer"

msgid ""
"Mock objects are callable. The call will return the value set as the :attr:"
"`~Mock.return_value` attribute. The default return value is a new Mock "
"object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"Mock-objekt är anropsbara. Anropet kommer att returnera det värde som anges "
"som attributet :attr:`~Mock.return_value`. Standardreturvärdet är ett nytt "
"Mock-objekt; det skapas första gången returvärdet används (antingen explicit "
"eller genom att anropa Mock) - men det lagras och samma värde returneras "
"varje gång."

msgid ""
"Calls made to the object will be recorded in the attributes like :attr:"
"`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"Anrop som görs till objektet registreras i attribut som :attr:`~Mock."
"call_args` och :attr:`~Mock.call_args_list`."

msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`!side_effect` raises an exception the call "
"is still recorded."
msgstr ""
"Om :attr:`~Mock.side_effect` är inställd kommer den att anropas efter att "
"anropet har spelats in, så om :attr:`!side_effect` ger upphov till ett "
"undantag spelas anropet fortfarande in."

msgid ""
"The simplest way to make a mock raise an exception when called is to make :"
"attr:`~Mock.side_effect` an exception class or instance:"
msgstr ""
"Det enklaste sättet att få en mock att skapa ett undantag när den anropas är "
"att göra :attr:`~Mock.side_effect` till en undantagsklass eller -instans:"

msgid ""
"If :attr:`~Mock.side_effect` is a function then whatever that function "
"returns is what calls to the mock return. The :attr:`!side_effect` function "
"is called with the same arguments as the mock. This allows you to vary the "
"return value of the call dynamically, based on the input:"
msgstr ""
"Om :attr:`~Mock.side_effect` är en funktion så är det som funktionen "
"returnerar det som anrop till mock returnerar. Funktionen :attr:`!"
"side_effect` anropas med samma argument som mock. Detta gör att du kan "
"variera anropets returvärde dynamiskt, baserat på indata:"

msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`~Mock.return_value` from inside :attr:`~Mock.side_effect`, or "
"return :data:`DEFAULT`:"
msgstr ""
"Om du vill att mocken fortfarande ska returnera standardreturvärdet (en ny "
"mock), eller något inställt returvärde, finns det två sätt att göra detta. "
"Antingen returnera :attr:`~Mock.return_value` från insidan av :attr:`~Mock."
"side_effect`, eller returnera :data:`DEFAULT`:"

msgid ""
"To remove a :attr:`~Mock.side_effect`, and return to the default behaviour, "
"set the :attr:`!side_effect` to ``None``:"
msgstr ""
"För att ta bort en :attr:`~Mock.side_effect` och återgå till "
"standardbeteendet, sätt :attr:`!side_effect` till ``None``:"

msgid ""
"The :attr:`~Mock.side_effect` can also be any iterable object. Repeated "
"calls to the mock will return values from the iterable (until the iterable "
"is exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`~Mock.side_effect` kan också vara ett valfritt iterabelt objekt. "
"Upprepade anrop till mocken kommer att returnera värden från iterabeln "
"(tills iterabeln är uttömd och en :exc:`StopIteration` utlöses):"

msgid ""
"If any members of the iterable are exceptions they will be raised instead of "
"returned::"
msgstr ""
"Om några medlemmar i iterable är undantag kommer de att tas upp istället för "
"returneras::"

msgid ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"
msgstr ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (senaste anropet senast):\n"
" ...\n"
"VärdeFel\n"
">>> m()\n"
"66"

msgid "Deleting Attributes"
msgstr "Radering av attribut"

msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr ""
"Mock-objekt skapar attribut på begäran. Detta gör att de kan låtsas vara "
"objekt av vilken typ som helst."

msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or "
"raise an :exc:`AttributeError` when an attribute is fetched. You can do this "
"by providing an object as a :attr:`!spec` for a mock, but that isn't always "
"convenient."
msgstr ""
"Du kanske vill att ett mock-objekt ska returnera ``False`` till ett :func:"
"`hasattr`-anrop, eller ge upphov till ett :exc:`AttributeError` när ett "
"attribut hämtas. Du kan göra detta genom att tillhandahålla ett objekt som "
"en :attr:`!spec` för en mock, men det är inte alltid bekvämt."

msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr ""
"Du \"blockerar\" attribut genom att radera dem. När ett attribut har tagits "
"bort kommer åtkomst till det att ge upphov till ett :exc:`AttributeError`."

msgid "Mock names and the name attribute"
msgstr "Låtsasnamn och name-attributet"

msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use :meth:`~Mock."
"configure_mock`::"
msgstr ""
"Eftersom \"name\" är ett argument till :class:`Mock`-konstruktören kan du "
"inte bara skicka in det vid skapandet om du vill att ditt mock-objekt ska ha "
"ett \"name\"-attribut. Det finns två alternativ. Ett alternativ är att "
"använda :meth:`~Mock.configure_mock`::"

msgid ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='mitt_namn')\n"
">>> mock.namn\n"
"'mitt_namn'"

msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr ""
"Ett enklare alternativ är att helt enkelt ställa in attributet \"name\" "
"efter skapandet av mock::"

msgid ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""

msgid "Attaching Mocks as Attributes"
msgstr "Bifoga mocks som attribut"

msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of "
"the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"När du lägger till en mock som ett attribut till en annan mock (eller som "
"returvärde) blir den ett \"barn\" till den mocken. Anrop till barnet "
"registreras i attributen :attr:`~Mock.method_calls` och :attr:`~Mock."
"mock_calls` hos föräldern. Detta är användbart för att konfigurera "
"barnsocklar och sedan koppla dem till föräldern, eller för att kopplaocklar "
"till en förälder som registrerar alla anrop till barnen och låter dig göra "
"påståenden om anropsordningen mellanocklar:"

msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr ""
"Undantaget till detta är om mock har ett namn. Detta gör att du kan "
"förhindra \"föräldraskapet\" om du av någon anledning inte vill att det ska "
"hända."

msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the :meth:`~Mock."
"attach_mock` method::"
msgstr ""
"Mockar som skapas åt dig av :func:`patch` får automatiskt namn. För att "
"koppla mockar som har namn till en förälder använder du metoden :meth:`~Mock."
"attach_mock`::"

msgid ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"
msgstr ""
">>> sak1 = objekt()\n"
">>> sak2 = objekt()\n"
">>> förälder = MagicMock()\n"
">>> med patch('__main__.thing1', return_value=None) som barn1:\n"
"... med patch('__main__.thing2', return_value=None) som barn2:\n"
"... parent.attach_mock(child1, 'child1')\n"
"... förälder.attach_mock(barn2, 'barn2')\n"
"... barn1('ett')\n"
"... barn2('två')\n"
"...\n"
">>> förälder.mock_calls\n"
"[call.child1('ett'), call.child2('två')]"

msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get "
"a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"De enda undantagen är magiska metoder och attribut (de som har inledande och "
"avslutande dubbla understrykningar). Mock skapar inte dessa utan ger "
"istället upphov till ett :exc:`AttributeError`. Detta beror på att tolken "
"ofta implicit begär dessa metoder, och blir *mycket* förvirrad av att få ett "
"nytt Mock-objekt när den förväntar sig en magisk metod. Om du behöver stöd "
"för magiska metoder, se :ref:``magiska metoder <magic-methods>``."

msgid "The patchers"
msgstr "Lapparna"

msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"Patch-dekoratorerna används för att patcha objekt endast inom ramen för den "
"funktion som de dekorerar. De hanterar automatiskt avpatchningen åt dig, "
"även om undantag uppstår. Alla dessa funktioner kan också användas i with-"
"satser eller som klassdekoratorer."

msgid "patch"
msgstr "lappa"

msgid ""
"The key is to do the patching in the right namespace. See the section `where "
"to patch`_."
msgstr ""
"Nyckeln är att göra patchningen i rätt namnrymd. Se avsnittet `Var ska man "
"patcha`_."

msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` fungerar som en funktionsdekorator, klassdekorator eller en "
"kontexthanterare. Inuti funktionens kropp eller med-satsen patchas *målet* "
"med ett *nytt* objekt. När funktionen/med-satsen avslutas ångras patchen."

msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the "
"created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""
"Om *new* utelämnas, ersätts målet med en :class:`AsyncMock` om det patchade "
"objektet är en asynkron funktion eller en :class:`MagicMock` annars. Om :"
"func:`patch` används som en dekorator och *new* utelämnas, skickas den "
"skapade mocken in som ett extra argument till den dekorerade funktionen. Om :"
"func:`patch` används som en kontexthanterare returneras den skapade "
"attrappen av kontexthanteraren."

msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target* ska vara en sträng i formen ``'package.module.ClassName'``. "
"*target* importeras och det angivna objektet ersätts med det *nya* objektet, "
"så *target* måste vara importerbart från den miljö du anropar :func:`patch` "
"från. Målet importeras när den dekorerade funktionen exekveras, inte vid "
"dekorationstillfället."

msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the :class:"
"`MagicMock` if patch is creating one for you."
msgstr ""
"Nyckelordsargumenten *spec* och *spec_set* skickas till :class:`MagicMock` "
"om patch skapar en åt dig."

msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"Dessutom kan du skicka ``spec=True`` eller ``spec_set=True``, vilket gör att "
"patch skickar in objektet som mockas som spec/spec_set-objektet."

msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default :class:"
"`AsyncMock` is used for async functions and :class:`MagicMock` for the rest."
msgstr ""
"*new_callable* låter dig ange en annan klass, eller ett anropbart objekt, "
"som kommer att anropas för att skapa det *nya* objektet. Som standard "
"används :class:`AsyncMock` för asynkrona funktioner och :class:`MagicMock` "
"för resten."

msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the :"
"func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"En mer kraftfull form av *spec* är *autospec*. Om du anger ``autospec=True`` "
"kommer mock att skapas med en specifikation från det objekt som ersätts. "
"Alla attribut i mocken kommer också att ha specifikationen för motsvarande "
"attribut i det objekt som ersätts. Metoder och funktioner som mockas kommer "
"att få sina argument kontrollerade och kommer att ge upphov till ett :exc:"
"`TypeError` om de anropas med fel signatur. För mockar som ersätter en klass "
"kommer deras returvärde (instansen) att ha samma specifikation som klassen. "
"Se funktionen :func:`create_autospec` och :ref:`auto-speccing`."

msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an "
"arbitrary object as the spec instead of the one being replaced."
msgstr ""
"Istället för ``autospec=True`` kan du skicka ``autospec=some_object`` för "
"att använda ett godtyckligt objekt som specifikation istället för det som "
"ersätts."

msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete "
"it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is "
"off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""
"Som standard kommer :func:`patch` att misslyckas med att ersätta attribut "
"som inte existerar. Om du skickar in ``create=True``, och attributet inte "
"existerar, kommer patch att skapa attributet åt dig när den patchade "
"funktionen anropas, och ta bort det igen efter att den patchade funktionen "
"har avslutats. Detta är användbart för att skriva tester mot attribut som "
"din produktionskod skapar vid körning. Det är avstängt som standard eftersom "
"det kan vara farligt. Med den påslagen kan du skriva passande tester mot API:"
"er som faktiskt inte existerar!"

msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr ""
"Om du patchar inbyggda program i en modul behöver du inte ange "
"``create=True``, det läggs till som standard."

msgid ""
"Patch can be used as a :class:`~unittest.TestCase` class decorator. It works "
"by decorating each test method in the class. This reduces the boilerplate "
"code when your test methods share a common patchings set. :func:`patch` "
"finds tests by looking for method names that start with ``patch."
"TEST_PREFIX``. By default this is ``'test'``, which matches the way :mod:"
"`unittest` finds tests. You can specify an alternative prefix by setting "
"``patch.TEST_PREFIX``."
msgstr ""
"Patch kan användas som en :class:`~unittest.TestCase` klassdekorator. Den "
"fungerar genom att dekorera varje testmetod i klassen. Detta minskar "
"boilerplate-koden när dina testmetoder delar en gemensam "
"patchningsuppsättning. :func:`patch` hittar tester genom att leta efter "
"metodnamn som börjar med ``patch.TEST_PREFIX``. Som standard är detta "
"``'test'``, vilket matchar det sätt som :mod:`unittest` hittar tester på. Du "
"kan ange ett alternativt prefix genom att ställa in ``patch.TEST_PREFIX``."

msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"Patch kan användas som en kontexthanterare, med with-satsen. Här gäller "
"patchen det indragna blocket efter with-satsen. Om du använder \"as\" kommer "
"det patchade objektet att bindas till namnet efter \"as\"; mycket användbart "
"om :func:`patch` skapar ett mock-objekt åt dig."

msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to :"
"class:`AsyncMock` if the patched object is asynchronous, to :class:"
"`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch` tar godtyckliga nyckelordsargument. Dessa kommer att skickas "
"till :class:`AsyncMock` om det patchade objektet är asynkront, till :class:"
"`MagicMock` annars eller till *new_callable* om det anges."

msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"``patch.dict(...)``, ``patch.multiple(...)`` och ``patch.object(...)`` finns "
"tillgängliga för alternativa användningsfall."

msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ""
":func:`patch` som funktionsdekorator, skapar mock åt dig och skickar den "
"till den dekorerade funktionen::"

msgid ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"
msgstr ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"... print(mock_class är SomeClass)\n"
"...\n"
">>> function(None)\n"
"Sant"

msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If "
"the class is instantiated in the code under test then it will be the :attr:"
"`~Mock.return_value` of the mock that will be used."
msgstr ""
"Patching av en klass ersätter klassen med en :class:`MagicMock` *instans*. "
"Om klassen instansieras i koden som testas kommer det att vara :attr:`~Mock."
"return_value` i mocken som kommer att användas."

msgid ""
"If the class is instantiated multiple times you could use :attr:`~Mock."
"side_effect` to return a new mock each time. Alternatively you can set the "
"*return_value* to be anything you want."
msgstr ""
"Om klassen instansieras flera gånger kan du använda :attr:`~Mock."
"side_effect` för att returnera en ny mock varje gång. Alternativt kan du "
"ställa in *return_value* till att vara vad du vill."

msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`~Mock.return_value`. For example::"
msgstr ""
"För att konfigurera returvärden på metoder för *instances* på den patchade "
"klassen måste du göra detta på :attr:`~Mock.return_value`. Till exempel::"

msgid ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."
msgstr ""
">>> klass Klass Klass:\n"
"... def method(self):\n"
"... pass\n"
"...\n"
">>> med patch('__main__.Class') som MockClass:\n"
"... instance = MockClass.return_value\n"
"... instance.method.return_value = 'foo'\n"
"... assert Class() är instans\n"
"... assert Class().method() == 'foo'\n"
"..."

msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"Om du använder *spec* eller *spec_set* och :func:`patch` ersätter en "
"*class*, kommer returvärdet för den skapade mocken att ha samma spec. ::"

msgid ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"
msgstr ""
">>> Original = Klass\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instans = MockClass()\n"
">>> assert isinstance(instans, Original)\n"
">>> patcher.stop()"

msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"Argumentet *new_callable* är användbart om du vill använda en alternativ "
"klass till standardklassen :class:`MagicMock` för den skapade mocken. Till "
"exempel, om du vill att en :class:`NonCallableMock` ska användas::"

msgid ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as "
"mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"
msgstr ""
">>> sak = objekt()\n"
">>> med patch('__main__.thing', new_callable=NonCallableMock) som "
"mock_thing:\n"
"... assert thing är mock_thing\n"
"... sak()\n"
"...\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: Objektet 'NonCallableMock' är inte anropsbart"

msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr ""
"Ett annat användningsfall kan vara att ersätta ett objekt med en :class:`io."
"StringIO`-instans::"

msgid ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"
msgstr ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"

msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
"När :func:`patch` skapar en mock åt dig är det vanligt att det första du "
"behöver göra är att konfigurera mocken. En del av den konfigurationen kan "
"göras i anropet till patch. Alla godtyckliga nyckelord som du skickar in i "
"anropet kommer att användas för att ställa in attribut på den skapade mock::"

msgid ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"
msgstr ""
">>> patcher = patch('__main__.thing', första='ett', andra='två')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'ett'\n"
">>> mock_thing.andra\n"
"'två'"

msgid ""
"As well as attributes on the created mock attributes, like the :attr:`~Mock."
"return_value` and :attr:`~Mock.side_effect`, of child mocks can also be "
"configured. These aren't syntactically valid to pass in directly as keyword "
"arguments, but a dictionary with these as keys can still be expanded into a :"
"func:`patch` call using ``**``::"
msgstr ""
"Förutom attribut på den skapade mocken kan även attribut, som :attr:`~Mock."
"return_value` och :attr:`~Mock.side_effect`, för underliggande mockar "
"konfigureras. Dessa är inte syntaktiskt giltiga att skicka in direkt som "
"nyckelordsargument, men en dictionary med dessa som nycklar kan ändå "
"expanderas till ett :func:`patch`-anrop med hjälp av ``**``::"

msgid ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"
msgstr ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"NyckelFel"

msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with :exc:"
"`AttributeError`::"
msgstr ""
"Som standard kommer försök att patcha en funktion i en modul (eller en metod "
"eller ett attribut i en klass) som inte finns att misslyckas med :exc:"
"`AttributeError`::"

msgid ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute "
"'non_existing_attribute'"
msgstr ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"... assert sys.icke_existerande_attribut == 42\n"
"...\n"
">>> test()\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"Attributfel: <modulen 'sys' (inbyggd)> har inte attributet "
"'non_existing_attribute'"

msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr ""
"men genom att lägga till ``create=True`` i anropet till :func:`patch` kommer "
"det föregående exemplet att fungera som förväntat::"

msgid ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"... assert sys.icke_existerande_attribut == 42\n"
"...\n"
">>> test()"

msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr ""
":func:`patch` returnerar nu en :class:`AsyncMock` om målet är en asynkron "
"funktion."

msgid "patch.object"
msgstr "patch.objekt"

msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr ""
"patch den namngivna medlemmen (*attribut*) på ett objekt (*mål*) med ett "
"låtsasobjekt."

msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like :func:"
"`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` kan användas som en dekorator, klassdekorator eller "
"kontexthanterare. Argumenten *new*, *spec*, *create*, *spec_set*, *autospec* "
"och *new_callable* har samma betydelse som för :func:`patch`. Precis som :"
"func:`patch` tar :func:`patch.object` godtyckliga nyckelordsargument för att "
"konfigurera det låtsasobjekt som skapas."

msgid ""
"When used as a class decorator :func:`patch.object` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"När det används som en klassdekorator :func:`patch.object` hedrar ``patch."
"TEST_PREFIX`` för att välja vilka metoder som ska omslutas."

msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
"Du kan antingen anropa :func:`patch.object` med tre argument eller med två "
"argument. Formen med tre argument tar objektet som ska patchas, "
"attributnamnet och objektet som ska ersätta attributet med."

msgid ""
"When calling with the two argument form you omit the replacement object, and "
"a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr ""
"När du anropar med tvåargumentformen utelämnar du ersättningsobjektet, och "
"en mock skapas åt dig och skickas in som ett extra argument till den "
"dekorerade funktionen:"

msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr ""
"*spec*, *create* och de andra argumenten till :func:`patch.object` har samma "
"betydelse som de har för :func:`patch`."

msgid "patch.dict"
msgstr "patch.dict"

msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to "
"its original state after the test, where the restored dictionary is a copy "
"of the dictionary as it was before the test."
msgstr ""
"Patch en ordbok, eller ett ordboksliknande objekt, och återställ ordboken "
"till dess ursprungliga skick efter testet, där den återställda ordboken är "
"en kopia av ordboken som den såg ut före testet."

msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr ""
"*in_dict* kan vara en ordbok eller en mappningsliknande behållare. Om det är "
"en mappning måste den åtminstone stödja hämtning, inställning och "
"borttagning av objekt samt iterering över nycklar."

msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr ""
"*in_dict* kan också vara en sträng som anger namnet på ordboken, som sedan "
"hämtas genom att importera den."

msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values* kan vara en ordlista med värden som ska anges i ordlistan. *values* "
"kan också vara en iterabel av paren ``(nyckel, värde)``."

msgid ""
"If *clear* is true then the dictionary will be cleared before the new values "
"are set."
msgstr ""
"Om *clear* är true kommer ordlistan att tömmas innan de nya värdena sätts."

msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr ""
":func:`patch.dict` kan också anropas med godtyckliga nyckelordsargument för "
"att ställa in värden i ordlistan."

msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context "
"manager."
msgstr ""
":func:`patch.dict` returnerar nu den patchade ordlistan när den används som "
"en kontexthanterare."

msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ""
":func:`patch.dict` kan användas som en kontexthanterare, dekorator eller "
"klassdekorator:"

msgid ""
"When used as a class decorator :func:`patch.dict` honours ``patch."
"TEST_PREFIX`` (default to ``'test'``) for choosing which methods to wrap:"
msgstr ""
"När det används som en klassdekorator :func:`patch.dict` hedrar ``patch."
"TEST_PREFIX`` (standard till ``'test'``) för att välja vilka metoder som ska "
"omslutas:"

msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"Om du vill använda ett annat prefix för ditt test kan du informera patcharna "
"om det genom att ställa in ``patch.TEST_PREFIX``. För mer information om hur "
"du ändrar värdet på se :ref:`test-prefix`."

msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let "
"a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ""
":func:`patch.dict` kan användas för att lägga till medlemmar i en ordbok, "
"eller helt enkelt låta ett test ändra en ordbok och se till att ordboken "
"återställs när testet avslutas."

msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr ""
"Nyckelord kan användas i :func:`patch.dict`-anropet för att ange värden i "
"ordlistan:"

msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__` and either :meth:`~container."
"__iter__` or :meth:`~object.__contains__`."
msgstr ""
":func:`patch.dict` kan användas med ordboksliknande objekt som egentligen "
"inte är ordböcker. De måste åtminstone stödja hämtning, inställning och "
"borttagning av objekt samt antingen iteration eller medlemskapstest. Detta "
"motsvarar de magiska metoderna :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__` och antingen :meth:`~container."
"__iter__` eller :meth:`~object.__contains__`."

msgid "patch.multiple"
msgstr "patch.multiple"

msgid ""
"Perform multiple patches in a single call. It takes the object to be patched "
"(either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr ""
"Utför flera patchar i ett enda anrop. Det tar objektet som ska patchas "
"(antingen som ett objekt eller en sträng för att hämta objektet genom "
"import) och nyckelordsargument för patcharna::"

msgid ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."
msgstr ""
"med patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."

msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when :func:"
"`patch.multiple` is used as a context manager."
msgstr ""
"Använd :data:`DEFAULT` som värde om du vill att :func:`patch.multiple` ska "
"skapa mocks åt dig. I detta fall skickas de skapade mockarna till en "
"dekorerad funktion med nyckelord, och en dictionary returneras när :func:"
"`patch.multiple` används som kontexthanterare."

msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` kan användas som en dekorator, klassdekorator eller "
"kontexthanterare. Argumenten *spec*, *spec_set*, *create*, *autospec* och "
"*new_callable* har samma betydelse som för :func:`patch`. Dessa argument "
"kommer att tillämpas på *alla* patchar som görs av :func:`patch.multiple`."

msgid ""
"When used as a class decorator :func:`patch.multiple` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"När det används som en klassdekorator :func:`patch.multiple` hedrar ``patch."
"TEST_PREFIX`` när det gäller att välja vilka metoder som ska omslutas."

msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
"Om du vill att :func:`patch.multiple` ska skapa mocks åt dig, kan du "
"använda :data:`DEFAULT` som värde. Om du använder :func:`patch.multiple` som "
"en dekorator så skickas de skapade mockarna in i den dekorerade funktionen "
"med nyckelordet ::"

msgid ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> sak = objekt()\n"
">>> annan = objekt()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(sak, annan):\n"
"... assert isinstance(sak, MagicMock)\n"
"... assert isinstance(annan, MagicMock)\n"
"...\n"
">>> test_funktion()"

msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` kan nästlas med andra ``patch`` dekoratorer, men "
"lägger argument som skickas med nyckelord *efter* något av de "
"standardargument som skapas av :func:`patch`::"

msgid ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', sak=DEFAULT, annan=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"... assert 'other' i repr(other)\n"
"... assert 'thing' i repr(thing)\n"
"... assert 'exit' i repr(mock_exit)\n"
"...\n"
">>> test_funktion()"

msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr ""
"Om :func:`patch.multiple` används som kontexthanterare är det värde som "
"returneras av kontexthanteraren en ordbok där skapade mockar har nyckelordet "
"name::"

msgid ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as "
"values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."
msgstr ""
">>> med patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) som "
"värden:\n"
"... assert 'other' in repr(värden['other'])\n"
"... assert 'thing' i repr(värden['thing'])\n"
"... assert värden['sak'] är sak\n"
"... assert värden['annat'] är annat\n"
"..."

msgid "patch methods: start and stop"
msgstr "patchmetoder: start och stopp"

msgid ""
"All the patchers have :meth:`!start` and :meth:`!stop` methods. These make "
"it simpler to do patching in ``setUp`` methods or where you want to do "
"multiple patches without nesting decorators or with statements."
msgstr ""
"Alla patchers har metoderna :meth:`!start` och :meth:`!stop`. Dessa gör det "
"enklare att göra patchar i ``setUp`` metoder eller där man vill göra flera "
"patchar utan att nesta dekoratorer eller med statements."

msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`!start` to put the patch in place and :meth:`!stop` to undo "
"it."
msgstr ""
"För att använda dem anropa :func:`patch`, :func:`patch.object` eller :func:"
"`patch.dict` som vanligt och behåll en referens till det returnerade "
"``patcher``-objektet. Du kan sedan anropa :meth:`!start` för att sätta "
"patchen på plats och :meth:`!stop` för att ångra den."

msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr ""
"Om du använder :func:`patch` för att skapa en mock åt dig så kommer den att "
"returneras av anropet till ``patcher.start``. ::"

msgid ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"
msgstr ""
">>> patcher = patch('paket.modul.Klassnamn')\n"
">>> from package import modul\n"
">>> original = modul.klassnamn\n"
">>> new_mock = patcher.start()\n"
">>> assert modul.klassnamn är inte original\n"
">>> assert modul.klassnamn är new_mock\n"
">>> patcher.stop()\n"
">>> assert modul.klassnamn är original\n"
">>> assert modul.klassnamn är inte new_mock"

msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`~unittest.TestCase`::"
msgstr ""
"Ett typiskt användningsfall för detta kan vara att göra flera korrigeringar "
"i metoden ``setUp`` i en :class:`~unittest.TestCase`::"

msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"
msgstr ""
">>> klass MyTest(unittest.TestCase):\n"
"... def setUp(self):\n"
"... self.patcher1 = patch('package.module.Class1')\n"
"... self.patcher2 = patch('package.module.Class2')\n"
"... self.MockClass1 = self.patcher1.start()\n"
"... self.MockClass2 = self.patcher2.start()\n"
"...\n"
"... def tearDown(self):\n"
"... self.patcher1.stop()\n"
"... self.patcher2.stop()\n"
"...\n"
"... def test_something(self):\n"
"... assert paket.modul.Class1 är self.MockClass1\n"
"... assert package.module.Class2 är self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"

msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Om du använder den här tekniken måste du se till att patchningen \"ångras\" "
"genom att anropa ``stop``. Detta kan vara krångligare än du kanske tror, för "
"om ett undantag uppstår i ``setUp`` så anropas inte ``tearDown``. :meth:"
"`unittest.TestCase.addCleanup` gör detta enklare::"

msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."
msgstr ""
">>> klass MyTest(unittest.TestCase):\n"
"... def setUp(self):\n"
"... patcher = patch('paket.modul.Klass')\n"
"... self.MockClass = patcher.start()\n"
"... self.addCleanup(patcher.stop)\n"
"...\n"
"... def test_something(self):\n"
"... assert paket.modul.Klass är self.MockClass\n"
"..."

msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr ""
"Som en extra bonus behöver du inte längre behålla en referens till "
"``patcher``-objektet."

msgid ""
"It is also possible to stop all patches which have been started by using :"
"func:`patch.stopall`."
msgstr ""
"Det är också möjligt att stoppa alla patchar som har startats genom att "
"använda :func:`patch.stopall`."

msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr ""
"Stoppar alla aktiva patchar. Stoppar endast patchar som startats med "
"``start``."

msgid "patch builtins"
msgstr "patch inbyggda komponenter"

msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr ""
"Du kan patcha alla builtins i en modul. Följande exempel patchar inbyggda :"
"func:`ord`::"

msgid ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"
msgstr ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"... mock_ord.return_value = 101\n"
"... print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"

msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"Alla patchers kan användas som klassdekoratorer. När de används på detta "
"sätt omsluter de varje testmetod i klassen. Patcherna känner igen metoder "
"som börjar med ``'test'`` som testmetoder. Detta är på samma sätt som :class:"
"`unittest.TestLoader` hittar testmetoder som standard."

msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting ``patch."
"TEST_PREFIX``::"
msgstr ""
"Det är möjligt att du vill använda ett annat prefix för dina tester. Du kan "
"informera patcharna om det olika prefixet genom att ställa in ``patch."
"TEST_PREFIX``::"

msgid ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"
msgstr ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> värde = 3\n"
">>>\n"
">>> @patch('__main__.value', 'inte tre')\n"
"... klass Thing:\n"
"... def foo_one(self):\n"
"... print(värde)\n"
"... def foo_two(self):\n"
"... print(värde)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"inte tre\n"
">>> Thing().foo_two()\n"
"inte tre\n"
">>> värde\n"
"3"

msgid "Nesting Patch Decorators"
msgstr "Nesting Patch Dekoratörer"

msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr ""
"Om du vill utföra flera patchar kan du helt enkelt stapla dekoratorerna på "
"varandra."

msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "Du kan stapla upp flera patchdekorationer med hjälp av detta mönster:"

msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr ""
"Observera att dekoratorerna appliceras nedifrån och upp. Detta är det "
"vanliga sättet som Python tillämpar dekoratorer på. Ordningen på de skapade "
"mockarna som skickas in i din testfunktion matchar denna ordning."

msgid "Where to patch"
msgstr "Var ska man lappa"

msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` fungerar genom att (tillfälligt) byta ut det objekt som ett "
"*namn* pekar på mot ett annat. Det kan finnas många namn som pekar på ett "
"enskilt objekt, så för att patching ska fungera måste du se till att du "
"patchar det namn som används av det system som testas."

msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr ""
"Grundprincipen är att man patchar där ett objekt *söks upp*, vilket inte "
"nödvändigtvis är samma plats som där det definieras. Ett par exempel kan "
"hjälpa till att förtydliga detta."

msgid ""
"Imagine we have a project that we want to test with the following structure::"
msgstr ""
"Tänk dig att vi har ett projekt som vi vill testa med följande struktur::"

msgid ""
"a.py\n"
"    -> Defines SomeClass\n"
"\n"
"b.py\n"
"    -> from a import SomeClass\n"
"    -> some_function instantiates SomeClass"
msgstr ""
"a.py\n"
"    -> Definierar SomeClass\n"
"\n"
"b.py\n"
"    -> från a import SomeClass\n"
"    -> some_function instansierar SomeClass"

msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do when it imports ``SomeClass`` from module a. If we use :func:"
"`patch` to mock out ``a.SomeClass`` then it will have no effect on our test; "
"module b already has a reference to the *real* ``SomeClass`` and it looks "
"like our patching had no effect."
msgstr ""
"Nu vill vi testa ``some_function`` men vi vill mocka ut ``SomeClass`` med "
"hjälp av :func:`patch`. Problemet är att när vi importerar modul b, vilket "
"vi kommer att behöva göra när den importerar ``SomeClass`` från modul a. Om "
"vi använder :func:`patch` för att mocka ut ``a.SomeClass`` så kommer det "
"inte att ha någon effekt på vårt test; modul b har redan en referens till "
"den *verkliga* ``SomeClass`` och det ser ut som om vår patchning inte hade "
"någon effekt."

msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"Nyckeln är att patcha ut ``SomeClass`` där den används (eller där den slås "
"upp). I det här fallet kommer ``some_function`` faktiskt att leta upp "
"``SomeClass`` i modul b, där vi har importerat den. Patchen bör se ut som::"

msgid "@patch('b.SomeClass')"
msgstr "@patch('b.SomeClass')"

msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses ``a."
"SomeClass``. Both of these import forms are common. In this case the class "
"we want to patch is being looked up in the module and so we have to patch "
"``a.SomeClass`` instead::"
msgstr ""
"Tänk dock på det alternativa scenariot där modul b istället för ``from a "
"import SomeClass`` gör ``import a`` och ```som_funktion`` använder ``a."
"SomeClass``. Båda dessa importformer är vanliga. I det här fallet söks den "
"klass vi vill patcha upp i modulen och därför måste vi patcha ``a."
"SomeClass`` istället::"

msgid "@patch('a.SomeClass')"
msgstr "@patch('a.SomeClass')"

msgid "Patching Descriptors and Proxy Objects"
msgstr "Patchning av deskriptorer och proxyobjekt"

msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class "
"methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object <https://web."
"archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"Både patch_ och patch.object_ patchar och återställer deskriptorer korrekt: "
"klassmetoder, statiska metoder och egenskaper. Du bör patcha dessa på "
"*klassen* snarare än på en instans. De fungerar också med *vissa* objekt som "
"proxy-attributåtkomst, som `django settings object <https://web.archive.org/"
"web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."

msgid "MagicMock and magic method support"
msgstr "Stöd för MagicMock och magiska metoder"

msgid "Mocking Magic Methods"
msgstr "Mocking av magiska metoder"

msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as :"
"term:`\"magic methods\" <magic method>`. This allows mock objects to replace "
"containers or other objects that implement Python protocols."
msgstr ""
":class:`Mock` stöder mocking av Python-protokollets metoder, även kända som :"
"term:`\"magic methods\" <magic method>`. Detta gör att mock-objekt kan "
"ersätta containers eller andra objekt som implementerar Python-protokoll."

msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"Eftersom magiska metoder slås upp på ett annat sätt än vanliga metoder [#]_ "
"har detta stöd implementerats på ett speciellt sätt. Detta innebär att "
"endast specifika magiska metoder stöds. Listan över metoder som stöds "
"innehåller *nästan* alla. Om det är någon som saknas som du behöver, "
"vänligen meddela oss."

msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take "
"``self`` as the first argument [#]_."
msgstr ""
"Du mockar magiska metoder genom att ställa in den metod du är intresserad av "
"till en funktion eller en mock-instans. Om du använder en funktion så "
"*måste* den ta ``self`` som första argument [#]_."

msgid ""
"One use case for this is for mocking objects used as context managers in a :"
"keyword:`with` statement:"
msgstr ""
"Ett användningsfall för detta är för mocking-objekt som används som "
"kontexthanterare i en :keyword:`with`-sats:"

msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they "
"are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"Anrop till magiska metoder visas inte i :attr:`~Mock.method_calls`, men de "
"registreras i :attr:`~Mock.mock_calls`."

msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an :exc:"
"`AttributeError`."
msgstr ""
"Om du använder nyckelordsargumentet *spec* för att skapa en mock kommer "
"försök att ställa in en magisk metod som inte finns i specifikationen att ge "
"upphov till ett :exc:`AttributeError`."

msgid "The full list of supported magic methods is:"
msgstr "Den fullständiga listan över magiska metoder som stöds är:"

msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``, ``__sizeof__``, ``__repr__`` och ``str__``"

msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``, ``__format__`` och ``__subklasser__``"

msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "\"rund\", \"golv\", \"trunk\" och \"tak"

msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr ""
"Jämförelser: ``__lt__``, ``__gt__``, ``__le__``, ``ge__``, ``eq__`` och "
"``ne__``"

msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"Container-metoder: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` och "
"``__missing__``"

msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr ""
"Kontexthanterare: ``__enter__``, ``__exit__``, ``__aenter__`` och "
"``__aexit__``"

msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "Unära numeriska metoder: ``__neg__``, ``__pos__`` och ``__invert__``"

msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"De numeriska metoderna (inklusive högerhands- och in-place-varianter): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``or__`` och ``__pow__``"

msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr ""
"Numeriska omvandlingsmetoder: ``__complex__``, ``__int__``, ``__float__`` "
"och ``__index__``"

msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "Deskriptormetoder: ``__get__``, ``__set__`` och ``__delete__``"

msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"Betning: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``getnewargs__``, ``getstate__`` och ``setstate__``"

msgid "File system path representation: ``__fspath__``"
msgstr "Representation av filsystemets sökväg: ``__fspath__``"

msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "Asynkrona iterationsmetoder: ``__aiter__`` och ``__anext__``"

msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr "Lagt till stöd för :func:`os.PathLike.__fspath__`."

msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""
"Lagt till stöd för ``__aenter__``, ``__aexit__``, ``__aiter__`` och "
"``__anext__``."

msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr ""
"Följande metoder finns men stöds *inte* eftersom de antingen används av "
"mock, inte kan ställas in dynamiskt eller kan orsaka problem:"

msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``, ``__setattr__``, ``__init__`` och ``new__``"

msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``del__``"

msgid "Magic Mock"
msgstr "Magic Mock"

msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and :class:"
"`NonCallableMagicMock`."
msgstr ""
"Det finns två varianter av ``MagicMock``: :class:`MagicMock` och :class:"
"`NonCallableMagicMock`."

msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of "
"most of the :term:`magic methods <magic method>`. You can use ``MagicMock`` "
"without having to configure the magic methods yourself."
msgstr ""
"``MagicMock`` är en subklass av :class:`Mock` med standardimplementationer "
"av de flesta av :term:`magiska metoder <magic method>`. Du kan använda "
"``MagicMock`` utan att behöva konfigurera de magiska metoderna själv."

msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr ""
"Parametrarna för konstruktören har samma betydelse som för :class:`Mock`."

msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that "
"exist in the spec will be created."
msgstr ""
"Om du använder argumenten *spec* eller *spec_set* kommer *endast* magiska "
"metoder som finns i specifikationen att skapas."

msgid "A non-callable version of :class:`MagicMock`."
msgstr "En icke anropsbar version av :class:`MagicMock`."

msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning "
"on a non-callable mock."
msgstr ""
"Parametrarna i konstruktorn har samma betydelse som för :class:`MagicMock`, "
"med undantag för *return_value* och *side_effect* som inte har någon "
"betydelse för en icke anropsbar mock."

msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr ""
"De magiska metoderna konfigureras med :class:`MagicMock`-objekt, så att du "
"kan konfigurera dem och använda dem på vanligt sätt:"

msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"Som standard krävs att många av protokollets metoder returnerar objekt av en "
"viss typ. Dessa metoder är förkonfigurerade med ett standardreturvärde, så "
"att de kan användas utan att du behöver göra något om du inte är intresserad "
"av returvärdet. Du kan fortfarande *ställa* in returvärdet manuellt om du "
"vill ändra standardvärdet."

msgid "Methods and their defaults:"
msgstr "Metoder och deras standardvärden:"

msgid "``__lt__``: :data:`NotImplemented`"
msgstr "``__lt__``: :data:`Inte genomförd`"

msgid "``__gt__``: :data:`!NotImplemented`"
msgstr "``__gt__``: :data:`!NotImplemented`"

msgid "``__le__``: :data:`!NotImplemented`"
msgstr "``__le__``: :data:`!NotImplemented`"

msgid "``__ge__``: :data:`!NotImplemented`"
msgstr "``__ge__``: :data:`!NotImplemented`"

msgid "``__int__``: ``1``"
msgstr "``__int__``: ``1``"

msgid "``__contains__``: ``False``"
msgstr "``__contains__``: ``False``"

msgid "``__len__``: ``0``"
msgstr "``__len__``: ``0``"

msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``: ``iter([])``"

msgid "``__exit__``: ``False``"
msgstr "``__exit__``: ``False``"

msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``: ``False``"

msgid "``__complex__``: ``1j``"
msgstr "``__komplex__``: ``1j``"

msgid "``__float__``: ``1.0``"
msgstr "``__float__``: ``1,0``"

msgid "``__bool__``: ``True``"
msgstr "``__bool__``: ``True``"

msgid "``__index__``: ``1``"
msgstr "``__index__``: ``1``"

msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``: standardhash för mock"

msgid "``__str__``: default str for the mock"
msgstr "``__str__``: standardstr för mock"

msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``: standardstorlek för mock"

msgid "For example:"
msgstr "Till exempel:"

msgid ""
"The two equality methods, :meth:`!__eq__` and :meth:`!__ne__`, are special. "
"They do the default equality comparison on identity, using the :attr:`~Mock."
"side_effect` attribute, unless you change their return value to return "
"something else::"
msgstr ""
"De två metoderna för likhet, :meth:`!__eq__` och :meth:`!__ne__`, är "
"speciella. De gör standardjämförelsen av likhet på identitet, med hjälp av "
"attributet :attr:`~Mock.side_effect`, om du inte ändrar deras returvärde "
"till att returnera något annat::"

msgid ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"
msgstr ""
">>> MagicMock() == 3\n"
"Falsk\n"
">>> MagicMock() != 3\n"
"Sant\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"

msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ""
"Returvärdet för :meth:`MagicMock.__iter__` kan vara vilket iterabelt objekt "
"som helst och behöver inte vara en iterator:"

msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr ""
"Om returvärdet *är* en iterator kommer den att förbrukas om man itererar "
"över den en gång, och efterföljande iterationer kommer att resultera i en "
"tom lista:"

msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr ""
"``MagicMock`` har alla magiska metoder som stöds konfigurerade förutom några "
"av de obskyra och föråldrade. Du kan fortfarande ställa in dessa om du vill."

msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr ""
"Magiska metoder som stöds men inte konfigureras som standard i ``MagicMock`` "
"är:"

msgid "``__subclasses__``"
msgstr "``__underklasser__``"

msgid "``__dir__``"
msgstr "``__dir__```"

msgid "``__format__``"
msgstr "``__format__```"

msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``, ``__set__`` och ``__delete__``"

msgid "``__reversed__`` and ``__missing__``"
msgstr "``__omvända__`` och ``__ saknas__``"

msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``getnewargs__``, "
"``getstate__`` och ``setstate__``"

msgid "``__getformat__``"
msgstr "``__getformat__``"

msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of Python."
msgstr ""
"Magiska metoder *bör* slås upp på klassen snarare än på instansen. Olika "
"versioner av Python är inkonsekventa när det gäller att tillämpa denna "
"regel. De protokollmetoder som stöds bör fungera med alla versioner av "
"Python som stöds."

msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance "
"is kept isolated from the others."
msgstr ""
"Funktionen är i princip kopplad till klassen, men varje ``Mock``-instans "
"hålls isolerad från de andra."

msgid "Helpers"
msgstr "Hjälpmedel"

msgid "sentinel"
msgstr "vaktpost"

msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr ""
"Objektet ``sentinel`` ger ett bekvämt sätt att tillhandahålla unika objekt "
"för dina tester."

msgid ""
"Attributes are created on demand when you access them by name. Accessing the "
"same attribute will always return the same object. The objects returned have "
"a sensible repr so that test failure messages are readable."
msgstr ""
"Attribut skapas på begäran när du använder deras namn. Om man använder samma "
"attribut returneras alltid samma objekt. De objekt som returneras har en "
"vettig repr så att meddelanden om testfel är läsbara."

msgid ""
"The ``sentinel`` attributes now preserve their identity when they are :mod:"
"`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"Attributen ``sentinel`` behåller nu sin identitet när de är :mod:`copied "
"<copy>` eller :mod:`pickled <pickle>`."

msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named "
"sentinel objects to test this. :data:`sentinel` provides a convenient way of "
"creating and testing the identity of objects like this."
msgstr ""
"Ibland när man testar behöver man testa att ett specifikt objekt skickas som "
"ett argument till en annan metod, eller returneras. Det kan vara vanligt att "
"skapa namngivna sentinel-objekt för att testa detta. :data:`sentinel` ger "
"ett bekvämt sätt att skapa och testa identiteten hos objekt som detta."

msgid ""
"In this example we monkey patch ``method`` to return ``sentinel."
"some_object``:"
msgstr ""
"I det här exemplet apar vi ``method`` så att den returnerar ```sentinel."
"some_object``:"

msgid "DEFAULT"
msgstr "STANDARD"

msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually ``sentinel."
"DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions to "
"indicate that the normal return value should be used."
msgstr ""
"Objektet :data:`DEFAULT` är en förskapad sentinel (egentligen ``sentinel."
"DEFAULT``). Det kan användas av :attr:`~Mock.side_effect` funktioner för att "
"indikera att det normala returvärdet skall användas."

msgid "call"
msgstr "ring upp"

msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing "
"with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:`~Mock."
"mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be used "
"with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call` är ett hjälpobjekt för att göra enklare påståenden, för "
"jämförelse med :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:"
"`~Mock.mock_calls` och :attr:`~Mock.method_calls`. :func:`call` kan också "
"användas med :meth:`~Mock.assert_has_calls`."

msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr ""
"För ett anropsobjekt som representerar flera anrop returnerar :meth:"
"`call_list` en lista över alla mellanliggande anrop samt det slutliga "
"anropet."

msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` är särskilt användbart för att göra påståenden om "
"\"kedjeanrop\". Ett kedjeanrop är flera anrop på en enda kodrad. Detta "
"resulterar i flera poster i :attr:`~Mock.mock_calls` på en mock. Att "
"manuellt konstruera sekvensen av anrop kan vara tråkigt."

msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ""
":meth:`~call.call_list` kan konstruera en sekvens av anrop från samma "
"kedjeanrop:"

msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, :attr:`Mock."
"call_args_list` and :attr:`Mock.mock_calls` attributes can be introspected "
"to get at the individual arguments they contain."
msgstr ""
"Ett ``call``-objekt är antingen en tupel av (positional args, keyword args) "
"eller (name, positional args, keyword args) beroende på hur det "
"konstruerades. När du konstruerar dem själv är detta inte särskilt "
"intressant, men de ``call``-objekt som finns i attributen :attr:`Mock."
"call_args`, :attr:`Mock.call_args_list` och :attr:`Mock.mock_calls` kan "
"introspekteras för att komma åt de enskilda argument de innehåller."

msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and :attr:`Mock."
"call_args_list` are two-tuples of (positional args, keyword args) whereas "
"the ``call`` objects in :attr:`Mock.mock_calls`, along with ones you "
"construct yourself, are three-tuples of (name, positional args, keyword "
"args)."
msgstr ""
"Objekten ``call`` i :attr:`Mock.call_args`` och :attr:`Mock.call_args_list`` "
"är tvådubbletter av (positional args, keyword args) medan objekten ``call`` "
"i :attr:`Mock.mock_calls``, tillsammans med dem du konstruerar själv, är "
"tredubbletter av (name, positional args, keyword args)."

msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr ""
"Du kan använda deras \"tupleness\" för att dra ut de enskilda argumenten för "
"mer komplex introspektion och påståenden. De positionella argumenten är en "
"tupel (en tom tupel om det inte finns några positionella argument) och "
"nyckelordsargumenten är en ordbok:"

msgid "create_autospec"
msgstr "skapa_autospec"

msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr ""
"Skapa ett mock-objekt som använder ett annat objekt som spec. Attribut på "
"mock-objektet kommer att använda motsvarande attribut på *spec*-objektet som "
"sin spec."

msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr ""
"Funktioner eller metoder som hånas kommer att få sina argument kontrollerade "
"för att säkerställa att de anropas med rätt signatur."

msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist "
"on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"Om *spec_set* är ``True`` kommer försök att ange attribut som inte finns på "
"spec-objektet att ge upphov till ett :exc:`AttributeError`."

msgid ""
"If a class is used as a spec then the return value of the mock (the instance "
"of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only "
"be callable if instances of the mock are callable."
msgstr ""
"Om en klass används som specifikation kommer returvärdet för mocken "
"(instansen av klassen) att ha samma specifikation. Du kan använda en klass "
"som specifikation för ett instansobjekt genom att ange ``instance=True``. "
"Den returnerade mocken kommer endast att vara anropsbar om instanser av "
"mocken är anropsbara."

msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ""
":func:`create_autospec` tar också godtyckliga nyckelordsargument som skickas "
"till konstruktören för den skapade attrappen."

msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with :func:"
"`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
"Se :ref:`auto-speccing` för exempel på hur man använder auto-speccing med :"
"func:`create_autospec` och *autospec*-argumentet till :func:`patch`."

msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr ""
":func:`create_autospec` returnerar nu en :class:`AsyncMock` om målet är en "
"asynkron funktion."

msgid "ANY"
msgstr "ALLA"

msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a "
"call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"Ibland kan du behöva göra påståenden om *några* av argumenten i ett anrop "
"till mock, men antingen inte bry dig om några av argumenten eller vilja dra "
"ut dem individuellt ur :attr:`~Mock.call_args` och göra mer komplexa "
"påståenden om dem."

msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and :meth:`~Mock."
"assert_called_once_with` will then succeed no matter what was passed in."
msgstr ""
"För att ignorera vissa argument kan du skicka in objekt som jämför lika med "
"*allt*. Anrop till :meth:`~Mock.assert_called_with` och :meth:`~Mock."
"assert_called_once_with` kommer då att lyckas oavsett vad som skickades in."

msgid ""
":data:`ANY` can also be used in comparisons with call lists like :attr:"
"`~Mock.mock_calls`:"
msgstr ""
":data:`ANY` kan också användas i jämförelser med anropslistor som :attr:"
"`~Mock.mock_calls`:"

msgid ""
":data:`ANY` is not limited to comparisons with call objects and so can also "
"be used in test assertions::"
msgstr ""
":data:`ANY` är inte begränsad till jämförelser med anropsobjekt och kan "
"därför också användas i testassertions::"

msgid ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"
msgstr ""
"klass TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hej världen'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"

msgid "FILTER_DIR"
msgstr "FILTER_DIR"

msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set ``mock."
"FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` är en variabel på modulnivå som styr hur låtsasobjekt "
"svarar på :func:`dir`. Standardvärdet är ``True``, som använder filtreringen "
"som beskrivs nedan, för att bara visa användbara medlemmar. Om du inte "
"gillar denna filtrering, eller behöver stänga av den för diagnostiska "
"ändamål, ställ då in ``mock.FILTER_DIR = False``."

msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the "
"attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"Med filtrering aktiverad visar ``dir(some_mock)`` endast användbara attribut "
"och inkluderar alla dynamiskt skapade attribut som normalt inte skulle "
"visas. Om låtsasobjektet skapades med en *spec* (eller *autospec* förstås) "
"visas alla attribut från originalet, även om de inte har använts ännu:"

msgid ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."
msgstr ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once', 'assert_called_once'\n"
" 'assert_called_once_with', 'assert_called_once_with'\n"
" \"assert_called_with\", \"assert_called_with\n"
" \"assert_has_calls\",\n"
" \"assert_not_called\", \"assert_not_called\",\n"
" \"attach_mock\",\n"
" ...\n"
">>> från urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."

msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been "
"filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"Många av de inte särskilt användbara (privata för :class:`Mock` snarare än "
"för det som mockas) understreckade och dubbelt understreckade "
"prefixattributen har filtrerats bort från resultatet av anropet :func:`dir` "
"på en :class:`Mock`. Om du inte gillar det här beteendet kan du stänga av "
"det genom att ställa in modulnivåomkopplaren :data:`FILTER_DIR`:"

msgid ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."
msgstr ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."

msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :const:`FILTER_DIR`."
msgstr ""
"Alternativt kan du bara använda ``vars(my_mock)`` (instansmedlemmar) och "
"``dir(type(my_mock))`` (typmedlemmar) för att kringgå filtreringen oavsett :"
"const:`FILTER_DIR`."

msgid "mock_open"
msgstr "mock_open"

msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr ""
"En hjälpfunktion för att skapa en mock för att ersätta användningen av :func:"
"`open`. Den fungerar för :func:`open` som anropas direkt eller används som "
"en kontexthanterare."

msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"Argumentet *mock* är det mock-objekt som ska konfigureras. Om ``None`` "
"(standard) så kommer en :class:`MagicMock` att skapas åt dig, med API "
"begränsat till metoder eller attribut som är tillgängliga på standard "
"filhandtag."

msgid ""
"*read_data* is a string for the :meth:`~io.RawIOBase.read`, :meth:`~io."
"IOBase.readline`, and :meth:`~io.IOBase.readlines` methods of the file "
"handle to return.  Calls to those methods will take data from *read_data* "
"until it is depleted.  The mock of these methods is pretty simplistic: every "
"time the *mock* is called, the *read_data* is rewound to the start.  If you "
"need more control over the data that you are feeding to the tested code you "
"will need to customize this mock for yourself.  When that is insufficient, "
"one of the in-memory filesystem packages on `PyPI <https://pypi.org>`_ can "
"offer a realistic filesystem for testing."
msgstr ""
"*read_data* är en sträng för metoderna :meth:`~io.RawIOBase.read`, :meth:"
"`~io.IOBase.readline` och :meth:`~io.IOBase.readlines` i filhandtaget som "
"ska returneras.  Anrop till dessa metoder kommer att ta data från "
"*read_data* tills den är tömd.  Mockningen av dessa metoder är ganska enkel: "
"varje gång *mock* anropas spolas *read_data* tillbaka till början.  Om du "
"behöver mer kontroll över de data som du matar in i den testade koden måste "
"du anpassa den här mocken för dig själv.  När det inte räcker kan ett av "
"paketen med filsystem i minnet på `PyPI <https://pypi.org>`_ erbjuda ett "
"realistiskt filsystem för testning."

msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.RawIOBase.read` changed to consume *read_data* rather "
"than returning it on each call."
msgstr ""
"Lagt till stöd för :meth:`~io.IOBase.readline` och :meth:`~io.IOBase."
"readlines`. Mock av :meth:`~io.RawIOBase.read` ändrad till att konsumera "
"*read_data* istället för att returnera den vid varje anrop."

msgid "*read_data* is now reset on each call to the *mock*."
msgstr "*read_data* nollställs nu vid varje anrop till *mock*."

msgid ""
"Added :meth:`~container.__iter__` to implementation so that iteration (such "
"as in for loops) correctly consumes *read_data*."
msgstr ""
"Lade till :meth:`~container.__iter__` till implementationen så att iteration "
"(t.ex. i for-loopar) korrekt förbrukar *read_data*."

msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr ""
"Att använda :func:`open` som en kontexthanterare är ett bra sätt att "
"säkerställa att dina filhandtag stängs ordentligt och blir allt vanligare::"

msgid ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"
msgstr ""
"med open('/some/sökväg', 'w') som f:\n"
"    f.write(\"något\")"

msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has :meth:`~object."
"__enter__` and :meth:`~object.__exit__` called)."
msgstr ""
"Problemet är att även om du mockar ut anropet till :func:`open` är det det "
"*återlämnade objektet* som används som en kontexthanterare (och har :meth:"
"`~object.__enter__` och :meth:`~object.__exit__` anropade)."

msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr ""
"Att mocka kontexthanterare med en :class:`MagicMock` är tillräckligt vanligt "
"och krångligt för att en hjälpfunktion är användbar. ::"

msgid ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"
msgstr ""
">>> m = mock_open()\n"
">>> med patch('__main__.open', m):\n"
"... med open('foo', 'w') som h:\n"
"... h.write(\"lite grejer\")\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('lite grejer'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handtag = m()\n"
">>> handle.write.assert_called_once_with('lite grejer')"

msgid "And for reading files::"
msgstr "Och för att läsa filer::"

msgid ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"
msgstr ""
">>> med patch('__main__.open', mock_open(read_data='bibble')) som m:\n"
"... med open('foo') som h:\n"
"... resultat = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert resultat == 'bibble'"

msgid "Autospeccing"
msgstr "Autospeccing"

msgid ""
"Autospeccing is based on the existing :attr:`!spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a :exc:"
"`TypeError` if they are called incorrectly."
msgstr ""
"Autospeccing baseras på den befintliga funktionen :attr:`!spec` i mock. Den "
"begränsar api för mocks till api för ett originalobjekt (spec), men den är "
"rekursiv (implementeras lättsinnigt) så att attribut för mocks endast har "
"samma api som attributen för spec. Dessutom har mockade funktioner / metoder "
"samma anropssignatur som originalet så att de ger upphov till ett :exc:"
"`TypeError` om de anropas felaktigt."

msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr ""
"Innan jag förklarar hur autospeccing fungerar ska du få veta varför det "
"behövs."

msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from a "
"flaw which is general to mocking. If you refactor some of your code, rename "
"members and so on, any tests for code that is still using the *old api* but "
"uses mocks instead of the real objects will still pass. This means your "
"tests can all pass even though your code is broken."
msgstr ""
":class:`Mock` är ett mycket kraftfullt och flexibelt objekt, men det lider "
"av ett fel som är generellt för mocking. Om du refaktoriserar en del av din "
"kod, byter namn på medlemmar och så vidare, kommer alla tester för kod som "
"fortfarande använder det *gamla api* men använder mocks istället för de "
"riktiga objekten fortfarande att godkännas. Detta innebär att alla dina "
"tester kan godkännas även om din kod är trasig."

msgid ""
"Before 3.5, tests with a typo in the word assert would silently pass when "
"they should raise an error. You can still achieve this behavior by passing "
"``unsafe=True`` to Mock."
msgstr ""
"Före 3.5 kunde tester med ett stavfel i ordet assert godkännas i tysthet när "
"de borde ge upphov till ett fel. Du kan fortfarande uppnå detta beteende "
"genom att skicka ``unsafe=True`` till Mock."

msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"Observera att detta är ytterligare ett skäl till varför du behöver "
"integrationstester såväl som enhetstester. Det är bra att testa allting "
"isolerat, men om du inte testar hur dina enheter är \"ihopkopplade\" finns "
"det fortfarande gott om utrymme för buggar som testerna kanske hade fångat "
"upp."

msgid ""
":mod:`unittest.mock` already provides a feature to help with this, called "
"speccing. If you use a class or instance as the :attr:`!spec` for a mock "
"then you can only access attributes on the mock that exist on the real class:"
msgstr ""
":mod:`unittest.mock` tillhandahåller redan en funktion som hjälper till med "
"detta, kallad speccing. Om du använder en klass eller instans som :attr:`!"
"spec` för en mock så kan du bara komma åt attribut på mocken som finns på "
"den riktiga klassen:"

msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr ""
"Specifikationen gäller bara för själva mocken, så vi har fortfarande samma "
"problem med alla metoder på mocken:"

msgid ""
">>> mock.header_items()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.header_items.assret_called_with()  # Intentional typo!"
msgstr ""
">>> mock.header_items()\n"
"<mock.mock-objekt på 0x...> >>> mock.header_items.assret_called_with()\n"
">>> mock.header_items.assret_called_with() # Avsiktligt skrivfel!"

msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to :"
"func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"Auto-specificering löser detta problem. Du kan antingen skicka "
"``autospec=True`` till :func:`patch` / :func:`patch.object` eller använda "
"funktionen :func:`create_autospec` för att skapa en mock med en spec. Om du "
"använder argumentet ``autospec=True`` till :func:`patch` så kommer objektet "
"som ersätts att användas som spec-objekt. Eftersom specifikationen görs "
"\"lazily\" (specifikationen skapas när attribut på mocken nås) kan du "
"använda den med mycket komplexa eller djupt nästlade objekt (som moduler som "
"importerar moduler som importerar moduler) utan en stor prestandahit."

msgid "Here's an example of it in use::"
msgstr "Här är ett exempel på hur det används::"

msgid ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"
msgstr ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"

msgid ""
"You can see that :class:`!request.Request` has a spec. :class:`!request."
"Request` takes two arguments in the constructor (one of which is *self*). "
"Here's what happens if we try to call it incorrectly::"
msgstr ""
"Du kan se att :class:`!request.Request` har en spec. :class:`!request."
"Request` tar två argument i konstruktorn (varav ett är *self*). Här är vad "
"som händer om vi försöker anropa den felaktigt::"

msgid ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"
msgstr ""
"&gt;&gt;&gt; req = begäran.begäran()\n"
"Traceback (senaste anropet senast):\n"
" ...\n"
"TypeError: <lambda>() tar minst 2 argument (1 givet)"

msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr ""
"Specifikationen gäller också för instansierade klasser (dvs. returvärdet för "
"specificerade mocks)::"

msgid ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"
msgstr ""
"&gt;&gt;&gt; req = begäran.begäran('foo')\n"
"&gt;&gt;&gt; req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"

msgid ""
":class:`!Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`!request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct "
"error::"
msgstr ""
":class:`!Request`-objekt är inte anropsbara, så returvärdet för "
"instantiering av vår mockade :class:`!request.Request` är en icke anropsbar "
"mock. Med specifikationen på plats kommer eventuella typfel i våra asserts "
"att ge upphov till rätt fel::"

msgid ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # Intentional typo!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"
msgstr ""
"&gt;&gt;&gt; req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
"&gt;&gt;&gt; req.add_header.assret_called_with # Avsiktligt skrivfel!\n"
"Traceback (senaste anropet senast):\n"
" ...\n"
"Attributfel (AttributeError): Låtsasobjektet har inget attribut "
"'assret_called_with'\n"
"&gt;&gt;&gt; req.add_header.assert_called_with('spam', 'ägg')"

msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos "
"and api changes."
msgstr ""
"I många fall kommer du bara att kunna lägga till ``autospec=True`` till dina "
"befintliga :func:`patch`-anrop och sedan vara skyddad mot buggar på grund av "
"typfel och api-ändringar."

msgid ""
"As well as using *autospec* through :func:`patch` there is a :func:"
"`create_autospec` for creating autospecced mocks directly:"
msgstr ""
"Förutom att använda *autospec* genom :func:`patch` finns det en :func:"
"`create_autospec` för att skapa autospecade mockar direkt:"

msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the "
"spec object, autospec has to introspect (access attributes) the spec. As you "
"traverse attributes on the mock a corresponding traversal of the original "
"object is happening under the hood. If any of your specced objects have "
"properties or descriptors that can trigger code execution then you may not "
"be able to use autospec. On the other hand it is much better to design your "
"objects so that introspection is safe [#]_."
msgstr ""
"Detta är dock inte utan förbehåll och begränsningar, vilket är anledningen "
"till att det inte är standardbeteendet. För att veta vilka attribut som är "
"tillgängliga på spec-objektet måste autospec introspektera (få tillgång till "
"attribut) spec. När du traverserar attribut på mock sker en motsvarande "
"traversering av det ursprungliga objektet under huven. Om något av dina "
"specificerade objekt har egenskaper eller deskriptorer som kan utlösa "
"kodkörning kanske du inte kan använda autospec. Å andra sidan är det mycket "
"bättre att utforma dina objekt så att introspektion är säker [#]_."

msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`~object.__init__` method and not to exist on the class "
"at all. *autospec* can't know about any dynamically created attributes and "
"restricts the api to visible attributes. ::"
msgstr ""
"Ett allvarligare problem är att det är vanligt att instansattribut skapas i "
"metoden :meth:`~object.__init__` och inte alls finns i klassen. *autospec* "
"kan inte känna till några dynamiskt skapade attribut och begränsar api:et "
"till synliga attribut. ::"

msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"
msgstr ""
">>> klass Något:\n"
"... def __init__(self):\n"
"... self.a = 33\n"
"...\n"
">>> med patch('__main__.Something', autospec=True):\n"
"... sak = Something()\n"
"... sak.a\n"
"...\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"Attributfel: Låtsasobjektet har inget attribut 'a'"

msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow "
"you to fetch attributes that don't exist on the spec it doesn't prevent you "
"setting them::"
msgstr ""
"Det finns några olika sätt att lösa detta problem. Det enklaste, men inte "
"nödvändigtvis det minst irriterande, sättet är att helt enkelt ställa in de "
"nödvändiga attributen på mock efter skapandet. Bara för att *autospec* inte "
"tillåter dig att hämta attribut som inte finns i specifikationen hindrar det "
"inte dig från att ställa in dem::"

msgid ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."
msgstr ""
">>> med patch('__main__.Something', autospec=True):\n"
"... sak = Something()\n"
"... thing.a = 33\n"
"..."

msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does* "
"prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents "
"this particular scenario:"
msgstr ""
"Det finns en mer aggressiv version av både *spec* och *autospec* som "
"*förhindrar* att du anger icke-existerande attribut. Detta är användbart om "
"du vill se till att din kod bara *ställer in* giltiga attribut också, men "
"det förhindrar naturligtvis just detta scenario:"

msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`~object.__init__`. "
"Note that if you are only setting default attributes in :meth:`!__init__` "
"then providing them via class attributes (shared between instances of "
"course) is faster too. e.g."
msgstr ""
"Förmodligen är det bästa sättet att lösa problemet att lägga till "
"klassattribut som standardvärden för instansmedlemmar som initieras i :meth:"
"`~object.__init__`. Observera att om du bara ställer in standardattribut i :"
"meth:`!__init__` är det också snabbare att tillhandahålla dem via "
"klassattribut (som naturligtvis delas mellan instanser). t.ex."

msgid ""
"class Something:\n"
"    a = 33"
msgstr ""
"klass Något:\n"
"    a = 33"

msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access "
"*any* attributes or methods on it. As ``None`` is *never* going to be useful "
"as a spec, and probably indicates a member that will normally of some other "
"type, autospec doesn't use a spec for members that are set to ``None``. "
"These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"Detta ger upphov till en annan fråga. Det är relativt vanligt att "
"tillhandahålla ett standardvärde av ``None`` för medlemmar som senare kommer "
"att vara ett objekt av en annan typ. ``None`` skulle vara värdelös som en "
"specifikation eftersom det inte skulle låta dig komma åt * några * attribut "
"eller metoder på den. Eftersom ``None`` *aldrig* kommer att vara användbar "
"som specifikation, och förmodligen indikerar en medlem som normalt kommer "
"att vara av någon annan typ, använder autospec inte en specifikation för "
"medlemmar som är inställda på ``None``. Dessa kommer bara att vara vanliga "
"mocks (ja - MagicMocks):"

msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"Om du inte gillar att ändra dina produktionsklasser för att lägga till "
"standardvärden finns det fler alternativ. Ett av dessa är att helt enkelt "
"använda en instans som specifikation i stället för klassen. Det andra är att "
"skapa en underklass av produktionsklassen och lägga till standardvärdena i "
"underklassen utan att påverka produktionsklassen. Båda dessa kräver att du "
"använder ett alternativt objekt som spec. Tack och lov stöder :func:`patch` "
"detta - du kan helt enkelt skicka det alternativa objektet som *autospec*-"
"argument::"

msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"
msgstr ""
"&gt;&gt;&gt; klass Något:\n"
"... def __init__(self):\n"
"... self.a = 33\n"
"...\n"
"&gt;&gt;&gt; klass SomethingForTest(Something):\n"
"... a = 33\n"
"...\n"
"&gt;&gt;&gt; p = patch('__main__.Something', autospec=SomethingForTest)\n"
"&gt;&gt;&gt; mock = p.start()\n"
"&gt;&gt;&gt; mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"

msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It "
"is only attribute lookups - along with calls to :func:`dir` - that are done."
msgstr ""
"Detta gäller endast klasser eller redan instantierade objekt. Att anropa en "
"mockad klass för att skapa en mockad instans *skapar* inte en riktig "
"instans. Det är bara attributuppslagningar - tillsammans med anrop till :"
"func:`dir` - som görs."

msgid "Sealing mocks"
msgstr "Försegling av mockar"

msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already "
"mocks recursively."
msgstr ""
"Seal inaktiverar det automatiska skapandet av mockar vid åtkomst till ett "
"attribut för den mock som förseglas eller något av dess attribut som redan "
"är mockar rekursivt."

msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr ""
"Om en låtsasinstans med ett namn eller en specifikation tilldelas ett "
"attribut kommer den inte att beaktas i tätningskedjan. Detta gör att man kan "
"förhindra att seal fixar en del av mock-objektet:"

msgid ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # This will raise AttributeError.\n"
">>> mock.submock.attribute2  # This will raise AttributeError.\n"
">>> mock.not_submock.attribute2  # This won't raise."
msgstr ""
">>> mock = Mock()\n"
">>> mock.submock.attribut1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute # Detta kommer att ge upphov till AttributeError.\n"
">>> mock.submock.attribute2 # Detta kommer att ge upphov till "
"AttributeError.\n"
">>> mock.not_submock.attribute2 # Detta kommer inte att ge upphov till."

msgid ""
"Order of precedence of :attr:`!side_effect`, :attr:`!return_value` and "
"*wraps*"
msgstr ""
"Prioritetsordning för :attr:`!side_effect`, :attr:`!return_value` och *wraps*"

msgid "The order of their precedence is:"
msgstr "Ordningen på deras företräde är:"

msgid ":attr:`~Mock.side_effect`"
msgstr ":attr:`~Mock.side_effect`"

msgid ":attr:`~Mock.return_value`"
msgstr ":attr:`~Mock.return_value`"

msgid "*wraps*"
msgstr "*wraps*"

msgid ""
"If all three are set, mock will return the value from :attr:`~Mock."
"side_effect`, ignoring :attr:`~Mock.return_value` and the wrapped object "
"altogether. If any two are set, the one with the higher precedence will "
"return the value. Regardless of the order of which was set first, the order "
"of precedence remains unchanged."
msgstr ""
"Om alla tre är inställda kommer mock att returnera värdet från :attr:`~Mock."
"side_effect` och ignorera :attr:`~Mock.return_value` och det omslutna "
"objektet helt och hållet. Om två är inställda, kommer den med högst "
"prioritet att returnera värdet. Oavsett vilken som angavs först förblir "
"prioritetsordningen oförändrad."

msgid ""
"As ``None`` is the default value of :attr:`~Mock.side_effect`, if you "
"reassign its value back to ``None``, the order of precedence will be checked "
"between :attr:`~Mock.return_value` and the wrapped object, ignoring :attr:"
"`~Mock.side_effect`."
msgstr ""
"Eftersom ``None`` är standardvärdet för :attr:`~Mock.side_effect`, om du "
"tilldelar dess värde tillbaka till ``None``, kommer prioritetsordningen att "
"kontrolleras mellan :attr:`~Mock.return_value` och det inlindade objektet, "
"utan hänsyn till :attr:`~Mock.side_effect`."

msgid ""
"If the value being returned by :attr:`~Mock.side_effect` is :data:`DEFAULT`, "
"it is ignored and the order of precedence moves to the successor to obtain "
"the value to return."
msgstr ""
"Om det värde som returneras av :attr:`~Mock.side_effect` är :data:`DEFAULT` "
"ignoreras det och prioritetsordningen flyttas till efterföljaren för att få "
"det värde som ska returneras."

msgid ""
"When :class:`Mock` wraps an object, the default value of :attr:`~Mock."
"return_value` will be :data:`DEFAULT`."
msgstr ""
"När :class:`Mock` omsluter ett objekt kommer standardvärdet för :attr:`~Mock."
"return_value` att vara :data:`DEFAULT`."

msgid ""
"The order of precedence will ignore this value and it will move to the last "
"successor which is the wrapped object."
msgstr ""
"Prioritetsordningen ignorerar detta värde och går vidare till den sista "
"efterträdaren, vilket är det inplastade objektet."

msgid ""
"As the real call is being made to the wrapped object, creating an instance "
"of this mock will return the real instance of the class. The positional "
"arguments, if any, required by the wrapped object must be passed."
msgstr ""
"Eftersom det verkliga anropet görs till det inlindade objektet, kommer "
"skapandet av en instans av denna mock att returnera den verkliga instansen "
"av klassen. De eventuella positionella argument som krävs av det inkapslade "
"objektet måste skickas."

msgid ""
"But if you assign ``None`` to it, this will not be ignored as it is an "
"explicit assignment. So, the order of precedence will not move to the "
"wrapped object."
msgstr ""
"Men om du tilldelar ``None`` till det, kommer detta inte att ignoreras "
"eftersom det är en explicit tilldelning. Så prioritetsordningen kommer inte "
"att flyttas till det inplastade objektet."

msgid ""
"Even if you set all three at once when initializing the mock, the order of "
"precedence remains the same:"
msgstr ""
"Även om du ställer in alla tre på en gång när du initierar mocken, förblir "
"prioritetsordningen densamma:"

msgid ""
"If :attr:`~Mock.side_effect` is exhausted, the order of precedence will not "
"cause a value to be obtained from the successors. Instead, ``StopIteration`` "
"exception is raised."
msgstr ""
"Om :attr:`~Mock.side_effect` är uttömd, kommer rangordningen inte att leda "
"till att ett värde erhålls från efterföljarna. Istället utlöses undantaget "
"``StopIteration``."
