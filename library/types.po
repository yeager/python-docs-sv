# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!types` --- Dynamic type creation and names for built-in types"
msgstr ""
":mod:`!types` --- Dynamiskt skapande av typer och namn för inbyggda typer"

msgid "**Source code:** :source:`Lib/types.py`"
msgstr "**Källkod:** :source:`Lib/types.py`"

msgid ""
"This module defines utility functions to assist in dynamic creation of new "
"types."
msgstr ""
"Denna modul definierar verktygsfunktioner för att underlätta dynamiskt "
"skapande av nya typer."

msgid ""
"It also defines names for some object types that are used by the standard "
"Python interpreter, but not exposed as builtins like :class:`int` or :class:"
"`str` are."
msgstr ""
"Den definierar också namn för vissa objekttyper som används av Pythons "
"standardtolk, men som inte exponeras som inbyggda objekt som :class:`int` "
"eller :class:`str`."

msgid ""
"Finally, it provides some additional type-related utility classes and "
"functions that are not fundamental enough to be builtins."
msgstr ""
"Slutligen innehåller den några ytterligare typrelaterade verktygsklasser och "
"funktioner som inte är tillräckligt grundläggande för att vara inbyggda."

msgid "Dynamic Type Creation"
msgstr "Skapande av dynamisk typ"

msgid "Creates a class object dynamically using the appropriate metaclass."
msgstr "Skapar ett klassobjekt dynamiskt med hjälp av lämplig metaklass."

msgid ""
"The first three arguments are the components that make up a class definition "
"header: the class name, the base classes (in order), the keyword arguments "
"(such as ``metaclass``)."
msgstr ""
"De tre första argumenten är de komponenter som utgör ett "
"klassdefinitionshuvud: klassnamnet, basklasserna (i ordning), "
"nyckelordsargumenten (t.ex. ``metaclass``)."

msgid ""
"The *exec_body* argument is a callback that is used to populate the freshly "
"created class namespace. It should accept the class namespace as its sole "
"argument and update the namespace directly with the class contents. If no "
"callback is provided, it has the same effect as passing in ``lambda ns: "
"None``."
msgstr ""
"Argumentet *exec_body* är en callback som används för att fylla på den nyss "
"skapade klassnamnrymden. Den bör acceptera klassens namnrymd som sitt enda "
"argument och uppdatera namnrymden direkt med klassens innehåll. Om ingen "
"återuppringning anges har det samma effekt som att skicka in ``lambda ns: "
"None``."

msgid "Calculates the appropriate metaclass and creates the class namespace."
msgstr "Beräknar lämplig metaklass och skapar klassens namnrymd."

msgid ""
"The arguments are the components that make up a class definition header: the "
"class name, the base classes (in order) and the keyword arguments (such as "
"``metaclass``)."
msgstr ""
"Argumenten är de komponenter som ingår i ett klassdefinitionshuvud: "
"klassnamnet, basklasserna (i ordning) och nyckelordsargumenten (t.ex. "
"``metaclass``)."

msgid "The return value is a 3-tuple: ``metaclass, namespace, kwds``"
msgstr "Returvärdet är en 3-tupel: ``metaklass, namnområde, kwds``"

msgid ""
"*metaclass* is the appropriate metaclass, *namespace* is the prepared class "
"namespace and *kwds* is an updated copy of the passed in *kwds* argument "
"with any ``'metaclass'`` entry removed. If no *kwds* argument is passed in, "
"this will be an empty dict."
msgstr ""
"*metaclass* är den lämpliga metaklassen, *namespace* är det förberedda "
"klassnamnområdet och *kwds* är en uppdaterad kopia av det passerade *kwds*-"
"argumentet med alla ``'metaclass'``-poster borttagna. Om inget *kwds*-"
"argument skickas in kommer detta att vara en tom dict."

msgid ""
"The default value for the ``namespace`` element of the returned tuple has "
"changed.  Now an insertion-order-preserving mapping is used when the "
"metaclass does not have a ``__prepare__`` method."
msgstr ""
"Standardvärdet för ``namespace``-elementet i den returnerade tupeln har "
"ändrats.  Nu används en mappning som bevarar insättningsordningen när "
"metaklassen inte har någon metod ``__prepare__``."

msgid ":ref:`metaclasses`"
msgstr ":ref:`metaclasses`"

msgid "Full details of the class creation process supported by these functions"
msgstr ""
"Fullständiga detaljer om processen för att skapa klasser med stöd av dessa "
"funktioner"

msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaklasser i Python 3000"

msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Införde namnrymdshaken ``__prepare__``"

msgid "Resolve MRO entries dynamically as specified by :pep:`560`."
msgstr "Löser MRO-poster dynamiskt enligt specifikationen i :pep:`560`."

msgid ""
"This function looks for items in *bases* that are not instances of :class:"
"`type`, and returns a tuple where each such object that has an :meth:"
"`~object.__mro_entries__` method is replaced with an unpacked result of "
"calling this method.  If a *bases* item is an instance of :class:`type`, or "
"it doesn't have an :meth:`!__mro_entries__` method, then it is included in "
"the return tuple unchanged."
msgstr ""
"Den här funktionen letar efter objekt i *bases* som inte är instanser av :"
"class:`type` och returnerar en tupel där varje sådant objekt som har en :"
"meth:`~object.__mro_entries__`-metod ersätts med ett uppackat resultat av "
"anropet av den här metoden.  Om ett *bases*-objekt är en instans av :class:"
"`type`, eller om det inte har en :meth:`!__mro_entries__`-metod, ingår det "
"oförändrat i retur-tupeln."

msgid ""
"Return the tuple of objects originally given as the bases of *cls* before "
"the :meth:`~object.__mro_entries__` method has been called on any bases "
"(following the mechanisms laid out in :pep:`560`). This is useful for "
"introspecting :ref:`Generics <user-defined-generics>`."
msgstr ""
"Returnerar den tupel av objekt som ursprungligen angavs som baser för *cls* "
"innan metoden :meth:`~object.__mro_entries__` har anropats på några baser "
"(enligt de mekanismer som beskrivs i :pep:`560`). Detta är användbart för "
"introspektion av :ref:``Generics <user-defined-generics>`."

msgid ""
"For classes that have an ``__orig_bases__`` attribute, this function returns "
"the value of ``cls.__orig_bases__``. For classes without the "
"``__orig_bases__`` attribute, :attr:`cls.__bases__ <type.__bases__>` is "
"returned."
msgstr ""
"För klasser som har attributet ``__orig_bases__`` returnerar denna funktion "
"värdet av ``cls.__orig_bases__``. För klasser utan attributet "
"``__orig_bases__`` returneras :attr:`cls.__bases__ <type.__bases__>`."

msgid "Examples::"
msgstr "Exempel::"

msgid ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"
msgstr ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"

msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ":pep:`560` - Kärnstöd för typning av moduler och generiska typer"

msgid "Standard Interpreter Types"
msgstr "Standardtolktyper"

msgid ""
"This module provides names for many of the types that are required to "
"implement a Python interpreter. It deliberately avoids including some of the "
"types that arise only incidentally during processing such as the "
"``listiterator`` type."
msgstr ""
"Denna modul ger namn på många av de typer som krävs för att implementera en "
"Python-tolk. Den undviker avsiktligt att inkludera några av de typer som "
"bara uppstår av en slump under bearbetningen, till exempel typen "
"``listiterator``."

msgid ""
"Typical use of these names is for :func:`isinstance` or :func:`issubclass` "
"checks."
msgstr ""
"Typisk användning av dessa namn är för :func:`isinstance` eller :func:"
"`issubclass` kontroller."

msgid ""
"If you instantiate any of these types, note that signatures may vary between "
"Python versions."
msgstr ""
"Om du instansierar någon av dessa typer, observera att signaturerna kan "
"variera mellan olika Python-versioner."

msgid "Standard names are defined for the following types:"
msgstr "Standardnamn har definierats för följande typer:"

msgid "The type of :data:`None`."
msgstr "Typ av :data:`None`."

msgid ""
"The type of user-defined functions and functions created by :keyword:"
"`lambda`  expressions."
msgstr ""
"Typ av användardefinierade funktioner och funktioner som skapas av :keyword:"
"`lambda`-uttryck."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``function.__new__`` with "
"argument ``code``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``function.__new__`` med "
"argumentet ``code``."

msgid ""
"The audit event only occurs for direct instantiation of function objects, "
"and is not raised for normal compilation."
msgstr ""
"Revisionshändelsen inträffar endast vid direkt instansiering av "
"funktionsobjekt och inte vid normal kompilering."

msgid ""
"The type of :term:`generator`-iterator objects, created by generator "
"functions."
msgstr ""
"Typ av :term:`generator`-iteratorobjekt som skapas av generatorfunktioner."

msgid ""
"The type of :term:`coroutine` objects, created by :keyword:`async def` "
"functions."
msgstr ""
"Typ av :term:`coroutine`-objekt, skapade av :keyword:`async def`-funktioner."

msgid ""
"The type of :term:`asynchronous generator`-iterator objects, created by "
"asynchronous generator functions."
msgstr ""
"Typ av :term:`asynkron generator`-iteratorobjekt, skapade av asynkrona "
"generatorfunktioner."

msgid ""
"The type of :ref:`code objects <code-objects>` such as returned by :func:"
"`compile`."
msgstr ""
"Typen av :ref:`kodobjekt <code-objects>` som t.ex. returneras av :func:"
"`compile`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``code.__new__`` with arguments "
"``code``, ``filename``, ``name``, ``argcount``, ``posonlyargcount``, "
"``kwonlyargcount``, ``nlocals``, ``stacksize``, ``flags``."
msgstr ""
"Utlöser en :ref:`auditing-händelse <auditing>` ``code.__new__`` med "
"argumenten ``code``, ``filnamn``, ``namn``, ``argcount``, "
"``posonlyargcount``, ``kwonlyargcount``, ``nlocals``, ``stacksize``, "
"``flags``."

msgid ""
"Note that the audited arguments may not match the names or positions "
"required by the initializer.  The audit event only occurs for direct "
"instantiation of code objects, and is not raised for normal compilation."
msgstr ""
"Observera att de granskade argumenten kanske inte matchar de namn eller "
"positioner som krävs av initieraren.  Granskningshändelsen inträffar endast "
"vid direkt instansiering av kodobjekt och inte vid normal kompilering."

msgid ""
"The type for cell objects: such objects are used as containers for a "
"function's :term:`closure variables <closure variable>`."
msgstr ""
"Typen för cellobjekt: sådana objekt används som behållare för en funktions :"
"term:`closure variables <closure variable>`."

msgid "The type of methods of user-defined class instances."
msgstr "Typen av metoder för användardefinierade klassinstanser."

msgid ""
"The type of built-in functions like :func:`len` or :func:`sys.exit`, and "
"methods of built-in classes.  (Here, the term \"built-in\" means \"written "
"in C\".)"
msgstr ""
"Typen av inbyggda funktioner som :func:`len` eller :func:`sys.exit`, och "
"metoder för inbyggda klasser.  (Här betyder termen \"inbyggd\" \"skriven i "
"C\")"

msgid ""
"The type of methods of some built-in data types and base classes such as :"
"meth:`object.__init__` or :meth:`object.__lt__`."
msgstr ""
"Typen av metoder för vissa inbyggda datatyper och basklasser, t.ex. :meth:"
"`object.__init__` eller :meth:`object.__lt__`."

msgid ""
"The type of *bound* methods of some built-in data types and base classes. "
"For example it is the type of :code:`object().__str__`."
msgstr ""
"Typen av *bundna* metoder för vissa inbyggda datatyper och basklasser. Det "
"är t.ex. typen av :code:`object().__str__`."

msgid "The type of :data:`NotImplemented`."
msgstr "Typen av :data:`NotImplemented`."

msgid ""
"The type of methods of some built-in data types such as :meth:`str.join`."
msgstr "Typen av metoder för vissa inbyggda datatyper, t.ex. :meth:`str.join`."

msgid ""
"The type of *unbound* class methods of some built-in data types such as "
"``dict.__dict__['fromkeys']``."
msgstr ""
"Typen av *obundna* klassmetoder för vissa inbyggda datatyper, t.ex. ``dict."
"__dict__['fromkeys']``."

msgid ""
"The type of :term:`modules <module>`. The constructor takes the name of the "
"module to be created and optionally its :term:`docstring`."
msgstr ""
"Typen av :term:`moduler <module>`. Konstruktören tar namnet på den modul som "
"ska skapas och eventuellt dess :term:`docstring`."

msgid ":ref:`Documentation on module objects <module-objects>`"
msgstr ":ref:`Dokumentation om modulobjekt <module-objects>`"

msgid ""
"Provides details on the special attributes that can be found on instances "
"of :class:`!ModuleType`."
msgstr ""
"Ger information om de specialattribut som finns på instanser av :class:`!"
"ModuleType`."

msgid ":func:`importlib.util.module_from_spec`"
msgstr ":func:`importlib.util.module_from_spec`"

msgid ""
"Modules created using the :class:`!ModuleType` constructor are created with "
"many of their special attributes unset or set to default values. :func:`!"
"module_from_spec` provides a more robust way of creating :class:`!"
"ModuleType` instances which ensures the various attributes are set "
"appropriately."
msgstr ""
"Moduler som skapas med hjälp av :class:`!ModuleType`-konstruktören skapas "
"med många av sina specialattribut oinställda eller inställda på "
"standardvärden. :func:`!module_from_spec` ger ett mer robust sätt att skapa :"
"class:`!ModuleType`-instanser som säkerställer att de olika attributen "
"ställs in på rätt sätt."

msgid "The type of :data:`Ellipsis`."
msgstr "Typ av :data:`Ellipsis`."

msgid ""
"The type of :ref:`parameterized generics <types-genericalias>` such as "
"``list[int]``."
msgstr ""
"Typen av :ref:``parameteriserade generiska <types-genericalias>`` såsom "
"``list[int]``."

msgid ""
"``t_origin`` should be a non-parameterized generic class, such as ``list``, "
"``tuple`` or ``dict``.  ``t_args`` should be a :class:`tuple` (possibly of "
"length 1) of types which parameterize ``t_origin``::"
msgstr ""
"``t_origin`` skall vara en icke-parameteriserad generisk klass, t.ex. "
"``list``, ``tuple`` eller ``dict``.  ``t_args`` skall vara en :class:`tuple` "
"(eventuellt av längd 1) av typer som parametriserar ``t_origin``::"

msgid ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"
msgstr ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"

msgid "This type can now be subclassed."
msgstr "Denna typ kan nu underklassificeras."

msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Generiska alias-typer<types-genericalias>`"

msgid "In-depth documentation on instances of :class:`!types.GenericAlias`"
msgstr "Fördjupad dokumentation av instanser av :class:`!types.GenericAlias`"

msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Typhintning av generiska gener i standardsamlingar"

msgid "Introducing the :class:`!types.GenericAlias` class"
msgstr "Vi introducerar :class:`!types.GenericAlias`-klassen"

msgid "The type of :ref:`union type expressions<types-union>`."
msgstr "Typen av :ref:`unionstyputtryck<types-union>`."

msgid "This is now an alias for :class:`typing.Union`."
msgstr "Detta är nu ett alias för :class:`typing.Union`."

msgid ""
"The type of traceback objects such as found in ``sys.exception()."
"__traceback__``."
msgstr ""
"Typen av spårningsobjekt som finns i ``sys.exception().__traceback__``."

msgid ""
"See :ref:`the language reference <traceback-objects>` for details of the "
"available attributes and operations, and guidance on creating tracebacks "
"dynamically."
msgstr ""
"Se :ref:``språkreferensen <traceback-objects>` för mer information om "
"tillgängliga attribut och operationer samt vägledning om hur man skapar "
"dynamiska spårningar."

msgid ""
"The type of :ref:`frame objects <frame-objects>` such as found in :attr:`tb."
"tb_frame <traceback.tb_frame>` if ``tb`` is a traceback object."
msgstr ""
"Typen av :ref:`frame objects <frame-objects>` som finns i :attr:`tb.tb_frame "
"<traceback.tb_frame>` om ``tb`` är ett traceback-objekt."

msgid ""
"The type of objects defined in extension modules with ``PyGetSetDef``, such "
"as :attr:`FrameType.f_locals <frame.f_locals>` or ``array.array.typecode``. "
"This type is used as descriptor for object attributes; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"Typen av objekt som definieras i tilläggsmoduler med ``PyGetSetDef``, t.ex. :"
"attr:`FrameType.f_locals <frame.f_locals>` eller ``array.array.typecode``. "
"Den här typen används som deskriptor för objektattribut; den har samma syfte "
"som typen :class:`property`, men för klasser som definieras i "
"tilläggsmoduler."

msgid ""
"The type of objects defined in extension modules with ``PyMemberDef``, such "
"as ``datetime.timedelta.days``.  This type is used as descriptor for simple "
"C data members which use standard conversion functions; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"Typen av objekt som definieras i tilläggsmoduler med ``PyMemberDef``, t.ex. "
"``datetime.timedelta.days``.  Den här typen används som deskriptor för enkla "
"C-datamedlemmar som använder standardkonverteringsfunktioner; den har samma "
"syfte som typen :class:`property`, men för klasser som definieras i "
"tilläggsmoduler."

msgid ""
"In addition, when a class is defined with a :attr:`~object.__slots__` "
"attribute, then for each slot, an instance of :class:`!MemberDescriptorType` "
"will be added as an attribute on the class. This allows the slot to appear "
"in the class's :attr:`~type.__dict__`."
msgstr ""
"Dessutom, när en klass definieras med attributet :attr:`~object.__slots__`, "
"kommer en instans av :class:`!MemberDescriptorType` att läggas till som "
"attribut för varje slot i klassen. Detta gör att platsen kan visas i "
"klassens :attr:`~type.__dict__`."

msgid ""
"In other implementations of Python, this type may be identical to "
"``GetSetDescriptorType``."
msgstr ""
"I andra implementationer av Python kan denna typ vara identisk med "
"``GetSetDescriptorType``."

msgid ""
"Read-only proxy of a mapping. It provides a dynamic view on the mapping's "
"entries, which means that when the mapping changes, the view reflects these "
"changes."
msgstr ""
"Skrivskyddad proxy för en mappning. Den ger en dynamisk vy över mappningens "
"poster, vilket innebär att när mappningen ändras återspeglas dessa ändringar "
"i vyn."

msgid ""
"Updated to support the new union (``|``) operator from :pep:`584`, which "
"simply delegates to the underlying mapping."
msgstr ""
"Uppdaterad för att stödja den nya operatorn union (``|``) från :pep:`584`, "
"som helt enkelt delegerar till den underliggande mappningen."

msgid ""
"Return ``True`` if the underlying mapping has a key *key*, else ``False``."
msgstr ""
"Returnerar ``True`` om den underliggande mappningen har en nyckel *key*, "
"annars ``False``."

msgid ""
"Return the item of the underlying mapping with key *key*.  Raises a :exc:"
"`KeyError` if *key* is not in the underlying mapping."
msgstr ""
"Returnerar objektet i den underliggande mappningen med nyckel *key*.  "
"Utlöser ett :exc:`KeyError` om *key* inte finns i den underliggande "
"mappningen."

msgid ""
"Return an iterator over the keys of the underlying mapping.  This is a "
"shortcut for ``iter(proxy.keys())``."
msgstr ""
"Returnerar en iterator över nycklarna i den underliggande mappningen.  Detta "
"är en genväg till ``iter(proxy.keys())``."

msgid "Return the number of items in the underlying mapping."
msgstr "Returnerar antalet objekt i den underliggande mappningen."

msgid "Return a shallow copy of the underlying mapping."
msgstr "Returnerar en ytlig kopia av den underliggande mappningen."

msgid ""
"Return the value for *key* if *key* is in the underlying mapping, else "
"*default*.  If *default* is not given, it defaults to ``None``, so that this "
"method never raises a :exc:`KeyError`."
msgstr ""
"Returnerar värdet för *key* om *key* finns i den underliggande mappningen, "
"annars *default*.  Om *default* inte anges är standardvärdet ``None``, så "
"att den här metoden aldrig ger upphov till ett :exc:`KeyError`."

msgid ""
"Return a new view of the underlying mapping's items (``(key, value)`` pairs)."
msgstr ""
"Returnerar en ny vy av den underliggande mappningens objekt (par av typen "
"``(nyckel, värde)``)."

msgid "Return a new view of the underlying mapping's keys."
msgstr "Returnerar en ny vy av den underliggande mappningens nycklar."

msgid "Return a new view of the underlying mapping's values."
msgstr "Returnerar en ny vy av den underliggande mappningens värden."

msgid "Return a reverse iterator over the keys of the underlying mapping."
msgstr ""
"Returnerar en omvänd iterator över nycklarna i den underliggande mappningen."

msgid "Return a hash of the underlying mapping."
msgstr "Returnerar en hash av den underliggande mappningen."

msgid "The type of :ref:`capsule objects <capsules>`."
msgstr "Typ av :ref:`kapselobjekt <capsules>`."

msgid "Additional Utility Classes and Functions"
msgstr "Ytterligare verktygsklasser och funktioner"

msgid ""
"A simple :class:`object` subclass that provides attribute access to its "
"namespace, as well as a meaningful repr."
msgstr ""
"En enkel :class:`object`-underklass som ger attributåtkomst till dess "
"namnrymd, samt en meningsfull repr."

msgid ""
"Unlike :class:`object`, with :class:`!SimpleNamespace` you can add and "
"remove attributes."
msgstr ""
"Till skillnad från :class:`object` kan du med :class:`!SimpleNamespace` "
"lägga till och ta bort attribut."

msgid ""
":py:class:`SimpleNamespace` objects may be initialized in the same way as :"
"class:`dict`: either with keyword arguments, with a single positional "
"argument, or with both. When initialized with keyword arguments, those are "
"directly added to the underlying namespace. Alternatively, when initialized "
"with a positional argument, the underlying namespace will be updated with "
"key-value pairs from that argument (either a mapping object or an :term:"
"`iterable` object producing key-value pairs). All such keys must be strings."
msgstr ""
":py:class:`SimpleNamespace`-objekt kan initieras på samma sätt som :class:"
"`dict`: antingen med nyckelordsargument, med ett enda positionellt argument "
"eller med båda. När de initieras med nyckelordsargument läggs de direkt till "
"i den underliggande namnrymden. Alternativt, när den initieras med ett "
"positionellt argument, kommer den underliggande namnrymden att uppdateras "
"med nyckel-värde-par från det argumentet (antingen ett mappningsobjekt eller "
"ett :term:`iterable`-objekt som producerar nyckel-värde-par). Alla sådana "
"nycklar måste vara strängar."

msgid "The type is roughly equivalent to the following code::"
msgstr "Typen motsvarar ungefär följande kod::"

msgid ""
"class SimpleNamespace:\n"
"    def __init__(self, mapping_or_iterable=(), /, **kwargs):\n"
"        self.__dict__.update(mapping_or_iterable)\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, "
"SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"
msgstr ""
"class SimpleNamespace:\n"
"    def __init__(self, mapping_or_iterable=(), /, **kwargs):\n"
"        self.__dict__.update(mapping_or_iterable)\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, "
"SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"

msgid ""
"``SimpleNamespace`` may be useful as a replacement for ``class NS: pass``. "
"However, for a structured record type use :func:`~collections.namedtuple` "
"instead."
msgstr ""
"``SimpleNamespace`` kan vara användbart som ersättning för ``class NS: "
"pass``. Men för en strukturerad posttyp använd :func:`~collections."
"namedtuple` istället."

msgid ""
":class:`!SimpleNamespace` objects are supported by :func:`copy.replace`."
msgstr ":class:`!SimpleNamespace`-objekt stöds av :func:`copy.replace`."

msgid ""
"Attribute order in the repr changed from alphabetical to insertion (like "
"``dict``)."
msgstr ""
"Attributordningen i repr ändrades från alfabetisk till insertion (som "
"``dict``)."

msgid "Added support for an optional positional argument."
msgstr "Stöd för ett valfritt positionellt argument har lagts till."

msgid "Route attribute access on a class to __getattr__."
msgstr "Dirigera attributåtkomst för en klass till __getattr__."

msgid ""
"This is a descriptor, used to define attributes that act differently when "
"accessed through an instance and through a class.  Instance access remains "
"normal, but access to an attribute through a class will be routed to the "
"class's __getattr__ method; this is done by raising AttributeError."
msgstr ""
"Detta är en deskriptor som används för att definiera attribut som fungerar "
"olika när de nås via en instans och via en klass.  Instansåtkomst förblir "
"normal, men åtkomst till ett attribut via en klass kommer att dirigeras till "
"klassens __getattr__-metod; detta görs genom att AttributeError utlöses."

msgid ""
"This allows one to have properties active on an instance, and have virtual "
"attributes on the class with the same name (see :class:`enum.Enum` for an "
"example)."
msgstr ""
"Detta gör att man kan ha egenskaper aktiva på en instans och ha virtuella "
"attribut på klassen med samma namn (se :class:`enum.Enum` för ett exempel)."

msgid "Coroutine Utility Functions"
msgstr "Verktygsfunktioner för Coroutine"

msgid ""
"This function transforms a :term:`generator` function into a :term:"
"`coroutine function` which returns a generator-based coroutine. The "
"generator-based coroutine is still a :term:`generator iterator`, but is also "
"considered to be a :term:`coroutine` object and is :term:`awaitable`.  "
"However, it may not necessarily implement the :meth:`~object.__await__` "
"method."
msgstr ""
"Denna funktion omvandlar en :term:`generator`-funktion till en :term:"
"`coroutine-funktion` som returnerar en generatorbaserad coroutine. Den "
"generatorbaserade coroutinen är fortfarande en :term:`generator iterator`, "
"men anses också vara ett :term:`coroutine`-objekt och är :term:`awaitable`.  "
"Den behöver dock inte nödvändigtvis implementera metoden :meth:`~object."
"__await__`."

msgid "If *gen_func* is a generator function, it will be modified in-place."
msgstr ""
"Om *gen_func* är en generatorfunktion kommer den att modifieras på plats."

msgid ""
"If *gen_func* is not a generator function, it will be wrapped. If it returns "
"an instance of :class:`collections.abc.Generator`, the instance will be "
"wrapped in an *awaitable* proxy object.  All other types of objects will be "
"returned as is."
msgstr ""
"Om *gen_func* inte är en generatorfunktion kommer den att paketeras. Om den "
"returnerar en instans av :class:`collections.abc.Generator`, kommer "
"instansen att packas in i ett *awaitable* proxyobjekt.  Alla andra typer av "
"objekt kommer att returneras som de är."

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "compile"
msgstr "compile"
