# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Regular Expression HOWTO"
msgstr "Reguljära uttryck HOWTO"

msgid "Author"
msgstr "Författare"

msgid "A.M. Kuchling <amk@amk.ca>"
msgstr "A.M. Kuchling <amk@amk.ca>"

msgid "Abstract"
msgstr "Abstrakt"

msgid ""
"This document is an introductory tutorial to using regular expressions in "
"Python with the :mod:`re` module.  It provides a gentler introduction than "
"the corresponding section in the Library Reference."
msgstr ""
"Detta dokument är en inledande handledning i hur man använder reguljära "
"uttryck i Python med modulen :mod:`re`.  Det ger en mildare introduktion än "
"motsvarande avsnitt i Library Reference."

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"Regular expressions (called REs, or regexes, or regex patterns) are "
"essentially a tiny, highly specialized programming language embedded inside "
"Python and made available through the :mod:`re` module. Using this little "
"language, you specify the rules for the set of possible strings that you "
"want to match; this set might contain English sentences, or e-mail "
"addresses, or TeX commands, or anything you like.  You can then ask "
"questions such as \"Does this string match the pattern?\", or \"Is there a "
"match for the pattern anywhere in this string?\".  You can also use REs to "
"modify a string or to split it apart in various ways."
msgstr ""
"Reguljära uttryck (kallade RE, regex eller regexmönster) är i huvudsak ett "
"litet, mycket specialiserat programmeringsspråk som är inbäddat i Python och "
"görs tillgängligt via modulen :mod:`re`. Med hjälp av detta lilla språk "
"specificerar du reglerna för den uppsättning möjliga strängar som du vill "
"matcha; denna uppsättning kan innehålla engelska meningar, e-postadresser, "
"TeX-kommandon eller vad du vill.  Sedan kan man ställa frågor som \"Matchar "
"den här strängen mönstret?\" eller \"Finns det en matchning för mönstret "
"någonstans i den här strängen?\".  Du kan också använda RE:er för att "
"modifiera en sträng eller dela upp den på olika sätt."

msgid ""
"Regular expression patterns are compiled into a series of bytecodes which "
"are then executed by a matching engine written in C.  For advanced use, it "
"may be necessary to pay careful attention to how the engine will execute a "
"given RE, and write the RE in a certain way in order to produce bytecode "
"that runs faster. Optimization isn't covered in this document, because it "
"requires that you have a good understanding of the matching engine's "
"internals."
msgstr ""
"Reguljära uttrycksmönster kompileras till en serie bytekoder som sedan "
"exekveras av en matchningsmotor skriven i C. För avancerad användning kan "
"det vara nödvändigt att vara noga med hur motorn kommer att exekvera en viss "
"RE och skriva RE på ett visst sätt för att producera bytekoder som körs "
"snabbare. Optimering behandlas inte i det här dokumentet, eftersom det "
"kräver att du har en god förståelse för matchningsmotorns interna funktioner."

msgid ""
"The regular expression language is relatively small and restricted, so not "
"all possible string processing tasks can be done using regular expressions.  "
"There are also tasks that *can* be done with regular expressions, but the "
"expressions turn out to be very complicated.  In these cases, you may be "
"better off writing Python code to do the processing; while Python code will "
"be slower than an elaborate regular expression, it will also probably be "
"more understandable."
msgstr ""
"Språket för reguljära uttryck är relativt litet och begränsat, så alla "
"möjliga strängbehandlingsuppgifter kan inte utföras med reguljära uttryck.  "
"Det finns också uppgifter som *kan* utföras med reguljära uttryck, men "
"uttrycken visar sig vara mycket komplicerade.  I dessa fall kan det vara "
"bättre att skriva Python-kod för att göra bearbetningen; även om Python-kod "
"kommer att vara långsammare än ett utarbetat reguljärt uttryck, kommer den "
"förmodligen också att vara mer begriplig."

msgid "Simple Patterns"
msgstr "Enkla mönster"

msgid ""
"We'll start by learning about the simplest possible regular expressions.  "
"Since regular expressions are used to operate on strings, we'll begin with "
"the most common task: matching characters."
msgstr ""
"Vi börjar med att lära oss om de enklaste möjliga reguljära uttrycken.  "
"Eftersom reguljära uttryck används för att operera på strängar börjar vi med "
"den vanligaste uppgiften: att matcha tecken."

msgid ""
"For a detailed explanation of the computer science underlying regular "
"expressions (deterministic and non-deterministic finite automata), you can "
"refer to almost any textbook on writing compilers."
msgstr ""
"För en detaljerad förklaring av den datavetenskap som ligger bakom reguljära "
"uttryck (deterministiska och icke-deterministiska finita automater) kan du "
"hänvisa till nästan vilken lärobok som helst om att skriva kompilatorer."

msgid "Matching Characters"
msgstr "Matchande tecken"

msgid ""
"Most letters and characters will simply match themselves.  For example, the "
"regular expression ``test`` will match the string ``test`` exactly.  (You "
"can enable a case-insensitive mode that would let this RE match ``Test`` or "
"``TEST`` as well; more about this later.)"
msgstr ""
"De flesta bokstäver och tecken matchar helt enkelt sig själva.  Till exempel "
"kommer det reguljära uttrycket ``test`` att matcha strängen ``test`` exakt.  "
"(Du kan aktivera ett skiftlägesokänsligt läge som låter RE matcha ``Test`` "
"eller ``TEST`` också; mer om detta senare)"

msgid ""
"There are exceptions to this rule; some characters are special :dfn:"
"`metacharacters`, and don't match themselves.  Instead, they signal that "
"some out-of-the-ordinary thing should be matched, or they affect other "
"portions of the RE by repeating them or changing their meaning.  Much of "
"this document is devoted to discussing various metacharacters and what they "
"do."
msgstr ""
"Det finns undantag från denna regel; vissa tecken är speciella :dfn:"
"`metatecken`, och matchar inte sig själva.  Istället signalerar de att något "
"utöver det vanliga ska matchas, eller så påverkar de andra delar av RE genom "
"att upprepa dem eller ändra deras betydelse.  En stor del av det här "
"dokumentet ägnas åt att diskutera olika metatecken och vad de gör."

msgid ""
"Here's a complete list of the metacharacters; their meanings will be "
"discussed in the rest of this HOWTO."
msgstr ""
"Här är en fullständig lista över metatecken; deras betydelser kommer att "
"diskuteras i resten av denna HOWTO."

msgid ". ^ $ * + ? { } [ ] \\ | ( )"
msgstr ". ^ $ * + ? { } [ ] \\ | ( )"

msgid ""
"The first metacharacters we'll look at are ``[`` and ``]``. They're used for "
"specifying a character class, which is a set of characters that you wish to "
"match.  Characters can be listed individually, or a range of characters can "
"be indicated by giving two characters and separating them by a ``'-'``.  For "
"example, ``[abc]`` will match any of the characters ``a``, ``b``, or ``c``; "
"this is the same as ``[a-c]``, which uses a range to express the same set of "
"characters.  If you wanted to match only lowercase letters, your RE would be "
"``[a-z]``."
msgstr ""
"De första metatecknen vi tittar på är ``[`` och ``]``. De används för att "
"ange en teckenklass, vilket är en uppsättning tecken som du vill matcha.  "
"Tecken kan listas individuellt, eller så kan ett intervall av tecken anges "
"genom att ange två tecken och separera dem med en ``'-'``.  Till exempel "
"kommer ``[abc]`` att matcha vilket som helst av tecknen ``a``, ``b`` eller "
"``c``; detta är samma sak som ``[a-c]``, som använder ett intervall för att "
"uttrycka samma uppsättning tecken.  Om du bara vill matcha gemena bokstäver "
"skulle RE vara ``[a-z]``."

msgid ""
"Metacharacters (except ``\\``) are not active inside classes.  For example, "
"``[akm$]`` will match any of the characters ``'a'``, ``'k'``, ``'m'``, or "
"``'$'``; ``'$'`` is usually a metacharacter, but inside a character class "
"it's stripped of its special nature."
msgstr ""
"Metatecken (utom `````) är inte aktiva inuti klasser.  Till exempel kommer "
"``[akm$]`` att matcha vilket som helst av tecknen ``'a'``, ``'k'``, ``'m'`` "
"eller ``'$'``; ``'$'`` är vanligtvis ett metatecken, men inuti en "
"teckenklass är det avskalat från sin speciella natur."

msgid ""
"You can match the characters not listed within the class by :dfn:"
"`complementing` the set.  This is indicated by including a ``'^'`` as the "
"first character of the class. For example, ``[^5]`` will match any character "
"except ``'5'``.  If the caret appears elsewhere in a character class, it "
"does not have special meaning. For example: ``[5^]`` will match either a "
"``'5'`` or a ``'^'``."
msgstr ""
"Du kan matcha de tecken som inte listas inom klassen genom att :dfn:"
"`komplettera` uppsättningen.  Detta indikeras genom att inkludera en ``'^'`` "
"som första tecken i klassen. Till exempel kommer ``[^5]`` att matcha alla "
"tecken utom ``'5'``.  Om caretten förekommer någon annanstans i en "
"teckenklass har den ingen speciell betydelse. Till exempel: ``[5^]`` kommer "
"att matcha antingen en ``'5'`` eller en ``'^'``."

msgid ""
"Perhaps the most important metacharacter is the backslash, ``\\``.   As in "
"Python string literals, the backslash can be followed by various characters "
"to signal various special sequences.  It's also used to escape all the "
"metacharacters so you can still match them in patterns; for example, if you "
"need to match a ``[`` or  ``\\``, you can precede them with a backslash to "
"remove their special meaning: ``\\[`` or ``\\\\``."
msgstr ""
"Det kanske viktigaste metatecknet är det bakre snedstrecket, `````.   Precis "
"som i Pythons stränglitteraler kan backslash följas av olika tecken för att "
"signalera olika specialsekvenser.  Det används också för att undkomma alla "
"metatecken så att du fortfarande kan matcha dem i mönster; till exempel, om "
"du behöver matcha en ``[`` eller `````, kan du föregå dem med en backslash "
"för att ta bort deras speciella betydelse: ``\\[`` eller ```````."

msgid ""
"Some of the special sequences beginning with ``'\\'`` represent predefined "
"sets of characters that are often useful, such as the set of digits, the set "
"of letters, or the set of anything that isn't whitespace."
msgstr ""
"Vissa av de specialsekvenser som börjar med ``'\\'`` representerar "
"fördefinierade uppsättningar av tecken som ofta är användbara, t.ex. "
"uppsättningen av siffror, uppsättningen av bokstäver eller uppsättningen av "
"allt som inte är blanksteg."

msgid ""
"Let's take an example: ``\\w`` matches any alphanumeric character.  If the "
"regex pattern is expressed in bytes, this is equivalent to the class ``[a-zA-"
"Z0-9_]``.  If the regex pattern is a string, ``\\w`` will match all the "
"characters marked as letters in the Unicode database provided by the :mod:"
"`unicodedata` module.  You can use the more restricted definition of ``\\w`` "
"in a string pattern by supplying the :const:`re.ASCII` flag when compiling "
"the regular expression."
msgstr ""
"Låt oss ta ett exempel: ``\\w`` matchar alla alfanumeriska tecken.  Om regex-"
"mönstret uttrycks i byte motsvarar detta klassen ``[a-zA-Z0-9_]``.  Om regex-"
"mönstret är en sträng kommer ``w`` att matcha alla tecken som markerats som "
"bokstäver i Unicode-databasen som tillhandahålls av modulen :mod:"
"`unicodedata`.  Du kan använda den mer begränsade definitionen av ``\\w`` i "
"ett strängmönster genom att ange flaggan :const:`re.ASCII` när du kompilerar "
"det reguljära uttrycket."

msgid ""
"The following list of special sequences isn't complete. For a complete list "
"of sequences and expanded class definitions for Unicode string patterns, see "
"the last part of :ref:`Regular Expression Syntax <re-syntax>` in the "
"Standard Library reference.  In general, the Unicode versions match any "
"character that's in the appropriate category in the Unicode database."
msgstr ""
"Följande lista över specialsekvenser är inte fullständig. En fullständig "
"lista över sekvenser och utökade klassdefinitioner för Unicode-strängmönster "
"finns i den sista delen av :ref:``Regular Expression Syntax <re-syntax>`` i "
"Standard Library-referensen.  I allmänhet matchar Unicode-versionerna alla "
"tecken som finns i lämplig kategori i Unicode-databasen."

msgid "``\\d``"
msgstr "``\\d``"

msgid "Matches any decimal digit; this is equivalent to the class ``[0-9]``."
msgstr "Matchar alla decimalsiffror; detta motsvarar klassen ``[0-9]``."

msgid "``\\D``"
msgstr "``\\D``"

msgid ""
"Matches any non-digit character; this is equivalent to the class ``[^0-9]``."
msgstr ""
"Motsvarar alla icke-siffriga tecken; detta motsvarar klassen ``[^0-9]``."

msgid "``\\s``"
msgstr "``\\s``"

msgid ""
"Matches any whitespace character; this is equivalent to the class "
"``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Matchar alla tecken för blanksteg; detta motsvarar klassen "
"``[ \\t\\n\\r\\f\\v]``."

msgid "``\\S``"
msgstr "``\\S``"

msgid ""
"Matches any non-whitespace character; this is equivalent to the class ``[^ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"Matchar alla tecken som inte är blanksteg; detta motsvarar klassen ``[^ "
"\\t\\n\\r\\f\\v]``."

msgid "``\\w``"
msgstr "``\\w``"

msgid ""
"Matches any alphanumeric character; this is equivalent to the class ``[a-zA-"
"Z0-9_]``."
msgstr ""
"Matchar alla alfanumeriska tecken; detta är likvärdigt med klassen ``[a-zA-"
"Z0-9_]``."

msgid "``\\W``"
msgstr "``\\W``"

msgid ""
"Matches any non-alphanumeric character; this is equivalent to the class "
"``[^a-zA-Z0-9_]``."
msgstr ""
"Matchar alla icke-alfanumeriska tecken; detta motsvarar klassen ``[^a-zA-"
"Z0-9_]``."

msgid ""
"These sequences can be included inside a character class.  For example, "
"``[\\s,.]`` is a character class that will match any whitespace character, "
"or ``','`` or ``'.'``."
msgstr ""
"Dessa sekvenser kan inkluderas i en teckenklass.  Till exempel är "
"``[\\s,.]`` en teckenklass som matchar alla blankstegstecken, eller ``','`` "
"eller ``'.'``."

msgid ""
"The final metacharacter in this section is ``.``.  It matches anything "
"except a newline character, and there's an alternate mode (:const:`re."
"DOTALL`) where it will match even a newline.  ``.`` is often used where you "
"want to match \"any character\"."
msgstr ""
"Det sista metatecknet i det här avsnittet är ``.``.  Det matchar allt utom "
"en ny rad, och det finns ett alternativt läge (:const:`re.DOTALL`) där det "
"matchar även en ny rad.  ``.`` används ofta där man vill matcha \"alla "
"tecken\"."

msgid "Repeating Things"
msgstr "Upprepning av saker"

msgid ""
"Being able to match varying sets of characters is the first thing regular "
"expressions can do that isn't already possible with the methods available on "
"strings.  However, if that was the only additional capability of regexes, "
"they wouldn't be much of an advance. Another capability is that you can "
"specify that portions of the RE must be repeated a certain number of times."
msgstr ""
"Att kunna matcha varierande uppsättningar av tecken är det första som "
"reguljära uttryck kan göra som inte redan är möjligt med de metoder som "
"finns tillgängliga för strängar.  Men om det var den enda ytterligare "
"förmågan hos regexes, skulle de inte vara mycket av ett framsteg. En annan "
"möjlighet är att du kan ange att delar av RE måste upprepas ett visst antal "
"gånger."

msgid ""
"The first metacharacter for repeating things that we'll look at is ``*``.  "
"``*`` doesn't match the literal character ``'*'``; instead, it specifies "
"that the previous character can be matched zero or more times, instead of "
"exactly once."
msgstr ""
"Det första metatecknet för upprepning av saker som vi ska titta på är "
"``*``.  ``*`` matchar inte det bokstavliga tecknet ``'*'``; istället anger "
"det att det föregående tecknet kan matchas noll eller flera gånger, istället "
"för exakt en gång."

msgid ""
"For example, ``ca*t`` will match ``'ct'`` (0 ``'a'`` characters), ``'cat'`` "
"(1 ``'a'``), ``'caaat'`` (3 ``'a'`` characters), and so forth."
msgstr ""
"Till exempel kommer ``ca*t`` att matcha ``'ct'`` (0 ``'a'`` tecken), "
"``'cat'`` (1 ``'a'``), ``'caaat'`` (3 ``'a'`` tecken), och så vidare."

msgid ""
"Repetitions such as ``*`` are :dfn:`greedy`; when repeating a RE, the "
"matching engine will try to repeat it as many times as possible. If later "
"portions of the pattern don't match, the matching engine will then back up "
"and try again with fewer repetitions."
msgstr ""
"Upprepningar som ``*`` är :dfn:`greedy`; när en RE upprepas försöker "
"matchningsmotorn upprepa den så många gånger som möjligt. Om senare delar av "
"mönstret inte matchar, backar matchningsmotorn och försöker igen med färre "
"upprepningar."

msgid ""
"A step-by-step example will make this more obvious.  Let's consider the "
"expression ``a[bcd]*b``.  This matches the letter ``'a'``, zero or more "
"letters from the class ``[bcd]``, and finally ends with a ``'b'``.  Now "
"imagine matching this RE against the string ``'abcbd'``."
msgstr ""
"Ett steg-för-steg exempel gör detta mer uppenbart.  Låt oss betrakta "
"uttrycket ``a[bcd]*b``.  Detta matchar bokstaven ``'a'``, noll eller fler "
"bokstäver från klassen ``[bcd]``, och slutar slutligen med ``'b'``.  Tänk "
"dig nu att du matchar denna RE mot strängen ``'abcbd``."

msgid "Step"
msgstr "Steg"

msgid "Matched"
msgstr "Matchad"

msgid "Explanation"
msgstr "Förklaring"

msgid "1"
msgstr "1"

msgid "``a``"
msgstr "``a``"

msgid "The ``a`` in the RE matches."
msgstr "\"A\" i \"RE\" stämmer överens."

msgid "2"
msgstr "2"

msgid "``abcbd``"
msgstr "``abcbd``"

msgid ""
"The engine matches ``[bcd]*``, going as far as it can, which is to the end "
"of the string."
msgstr ""
"Motorn matchar ``[bcd]*`` och går så långt den kan, vilket är till slutet av "
"strängen."

msgid "3"
msgstr "3"

msgid "*Failure*"
msgstr "*Fel*"

msgid ""
"The engine tries to match ``b``, but the current position is at the end of "
"the string, so it fails."
msgstr ""
"Motorn försöker matcha ``b``, men den aktuella positionen är i slutet av "
"strängen, så det misslyckas."

msgid "4"
msgstr "4"

msgid "``abcb``"
msgstr "``abcb``"

msgid "Back up, so that  ``[bcd]*`` matches one less character."
msgstr "Backa, så att ``[bcd]*`` matchar ett tecken mindre."

msgid "5"
msgstr "5"

msgid ""
"Try ``b`` again, but the current position is at the last character, which is "
"a ``'d'``."
msgstr ""
"Försök med ``b`` igen, men den aktuella positionen är vid det sista tecknet, "
"som är en ``'d'``."

msgid "6"
msgstr "6"

msgid "``abc``"
msgstr "``abc``"

msgid "Back up again, so that ``[bcd]*`` is only matching ``bc``."
msgstr "Tillbaka upp igen, så att ``[bcd]*`` bara matchar ``bc``."

msgid ""
"Try ``b`` again.  This time the character at the current position is "
"``'b'``, so it succeeds."
msgstr ""
"Försök med ``b`` igen.  Den här gången är tecknet vid den aktuella "
"positionen ``'b'``, så det lyckas."

msgid ""
"The end of the RE has now been reached, and it has matched ``'abcb'``.  This "
"demonstrates how the matching engine goes as far as it can at first, and if "
"no match is found it will then progressively back up and retry the rest of "
"the RE again and again.  It will back up until it has tried zero matches for "
"``[bcd]*``, and if that subsequently fails, the engine will conclude that "
"the string doesn't match the RE at all."
msgstr ""
"Slutet av RE har nu nåtts, och den har matchat ``'abcb``.  Detta visar hur "
"matchningsmotorn först går så långt den kan, och om ingen matchning hittas "
"kommer den sedan successivt att backa tillbaka och försöka resten av RE om "
"och om igen.  Den kommer att backa tills den har försökt noll matchningar "
"för ``[bcd]*``, och om det därefter misslyckas kommer motorn att dra "
"slutsatsen att strängen inte alls matchar RE."

msgid ""
"Another repeating metacharacter is ``+``, which matches one or more times.  "
"Pay careful attention to the difference between ``*`` and ``+``; ``*`` "
"matches *zero* or more times, so whatever's being repeated may not be "
"present at all, while ``+`` requires at least *one* occurrence.  To use a "
"similar example, ``ca+t`` will match ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``\\ s), but won't match ``'ct'``."
msgstr ""
"Ett annat upprepande metatecken är ``+``, som matchar en eller flera "
"gånger.  Var noga med skillnaden mellan ``*`` och ``+``; ``*`` matchar "
"*noll* eller fler gånger, så det som upprepas kanske inte finns med alls, "
"medan ``+`` kräver minst *en* förekomst.  För att använda ett liknande "
"exempel, ``ca+t`` kommer att matcha ``'cat'`` (1 ``'a'``), ``'caaat'`` (3 "
"``'a'``), men kommer inte att matcha ``'ct'``."

msgid ""
"There are two more repeating operators or quantifiers.  The question mark "
"character, ``?``, matches either once or zero times; you can think of it as "
"marking something as being optional.  For example, ``home-?brew`` matches "
"either ``'homebrew'`` or ``'home-brew'``."
msgstr ""
"Det finns ytterligare två upprepande operatorer eller kvantifierare.  "
"Frågetecknet, ``?``, matchar antingen en eller noll gånger; du kan tänka på "
"det som att markera att något är valfritt.  Till exempel, ``home-?brew`` "
"matchar antingen ``'homebrew'`` eller ``'home-brew'``."

msgid ""
"The most complicated quantifier is ``{m,n}``, where *m* and *n* are decimal "
"integers.  This quantifier means there must be at least *m* repetitions, and "
"at most *n*.  For example, ``a/{1,3}b`` will match ``'a/b'``, ``'a//b'``, "
"and ``'a///b'``.  It won't match ``'ab'``, which has no slashes, or ``'a////"
"b'``, which has four."
msgstr ""
"Den mest komplicerade kvantifieringen är ``{m,n}``, där *m* och *n* är "
"decimala heltal.  Denna kvantifierare innebär att det måste finnas minst *m* "
"upprepningar och högst *n*.  Till exempel kommer ``a/{1,3}b`` att matcha "
"``'a/b'``, ``'a//b'`` och ``'a///b'``.  Det kommer inte att matcha ``'ab'``, "
"som inte har några snedstreck, eller ``'a////b'``, som har fyra."

msgid ""
"You can omit either *m* or *n*; in that case, a reasonable value is assumed "
"for the missing value.  Omitting *m* is interpreted as a lower limit of 0, "
"while omitting *n* results in an upper bound of infinity."
msgstr ""
"Du kan utelämna antingen *m* eller *n*; i så fall antas ett rimligt värde "
"för det saknade värdet.  Att utelämna *m* tolkas som en nedre gräns på 0, "
"medan att utelämna *n* resulterar i en övre gräns på oändlighet."

msgid ""
"The simplest case ``{m}`` matches the preceding item exactly *m* times. For "
"example, ``a/{2}b`` will only match ``'a//b'``."
msgstr ""
"Det enklaste fallet ``{m}`` matchar föregående objekt exakt *m* gånger. Till "
"exempel kommer ``a/{2}b`` bara att matcha ``'a//b'``."

msgid ""
"Readers of a reductionist bent may notice that the three other quantifiers "
"can all be expressed using this notation.  ``{0,}`` is the same as ``*``, "
"``{1,}`` is equivalent to ``+``, and ``{0,1}`` is the same as ``?``.  It's "
"better to use ``*``, ``+``, or ``?`` when you can, simply because they're "
"shorter and easier to read."
msgstr ""
"Läsare med en reduktionistisk böjelse kan notera att de tre andra "
"kvantifierarna alla kan uttryckas med denna notation.  ``{0,}`` är detsamma "
"som ``*``, ``{1,}`` är ekvivalent med ``+`` och ``{0,1}`` är detsamma som ``?"
"``.  Det är bättre att använda ``*``, ``+`` eller ``?`` när du kan, helt "
"enkelt för att de är kortare och lättare att läsa."

msgid "Using Regular Expressions"
msgstr "Använda reguljära uttryck"

msgid ""
"Now that we've looked at some simple regular expressions, how do we actually "
"use them in Python?  The :mod:`re` module provides an interface to the "
"regular expression engine, allowing you to compile REs into objects and then "
"perform matches with them."
msgstr ""
"Nu när vi har tittat på några enkla reguljära uttryck, hur använder vi dem "
"egentligen i Python?  Modulen :mod:`re` tillhandahåller ett gränssnitt till "
"motorn för reguljära uttryck, så att du kan sammanställa RE:er till objekt "
"och sedan utföra matchningar med dem."

msgid "Compiling Regular Expressions"
msgstr "Kompilera reguljära uttryck"

msgid ""
"Regular expressions are compiled into pattern objects, which have methods "
"for various operations such as searching for pattern matches or performing "
"string substitutions. ::"
msgstr ""
"Reguljära uttryck sammanställs till mönsterobjekt, som har metoder för olika "
"operationer som att söka efter mönstermatchningar eller utföra "
"strängersättningar:"

msgid ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"
msgstr ""
">>> import re\n"
">>> p = re.compile('ab*')\n"
">>> p\n"
"re.compile('ab*')"

msgid ""
":func:`re.compile` also accepts an optional *flags* argument, used to enable "
"various special features and syntax variations.  We'll go over the available "
"settings later, but for now a single example will do::"
msgstr ""
":func:`re.compile` accepterar också ett valfritt *flags*-argument, som "
"används för att aktivera olika specialfunktioner och syntaxvariationer.  Vi "
"kommer att gå igenom de tillgängliga inställningarna senare, men nu räcker "
"det med ett exempel::"

msgid ">>> p = re.compile('ab*', re.IGNORECASE)"
msgstr ">>> p = re.compile('ab*', re.IGNORECASE)"

msgid ""
"The RE is passed to :func:`re.compile` as a string.  REs are handled as "
"strings because regular expressions aren't part of the core Python language, "
"and no special syntax was created for expressing them.  (There are "
"applications that don't need REs at all, so there's no need to bloat the "
"language specification by including them.) Instead, the :mod:`re` module is "
"simply a C extension module included with Python, just like the :mod:"
"`socket` or :mod:`zlib` modules."
msgstr ""
"RE:n skickas till :func:`re.compile` som en sträng.  REs hanteras som "
"strängar eftersom reguljära uttryck inte är en del av Pythons kärnspråk och "
"ingen speciell syntax skapades för att uttrycka dem.  (Det finns "
"applikationer som inte behöver REs alls, så det finns ingen anledning att "
"uppblåsa språkspecifikationen genom att inkludera dem) Istället är modulen :"
"mod:`re` helt enkelt en C-tilläggsmodul som ingår i Python, precis som "
"modulerna :mod:`socket` eller :mod:`zlib`."

msgid ""
"Putting REs in strings keeps the Python language simpler, but has one "
"disadvantage which is the topic of the next section."
msgstr ""
"Att lägga RE:er i strängar gör Python-språket enklare, men det har en "
"nackdel som behandlas i nästa avsnitt."

msgid "The Backslash Plague"
msgstr "Backslash-pesten"

msgid ""
"As stated earlier, regular expressions use the backslash character "
"(``'\\'``) to indicate special forms or to allow special characters to be "
"used without invoking their special meaning. This conflicts with Python's "
"usage of the same character for the same purpose in string literals."
msgstr ""
"Som tidigare nämnts använder reguljära uttryck tecknet backslash (``'\\'``) "
"för att ange speciella former eller för att tillåta att specialtecken "
"används utan att deras speciella betydelse åberopas. Detta står i konflikt "
"med Pythons användning av samma tecken för samma ändamål i stränglitteraler."

msgid ""
"Let's say you want to write a RE that matches the string ``\\section``, "
"which might be found in a LaTeX file.  To figure out what to write in the "
"program code, start with the desired string to be matched.  Next, you must "
"escape any backslashes and other metacharacters by preceding them with a "
"backslash, resulting in the string ``\\\\section``.  The resulting string "
"that must be passed to :func:`re.compile` must be ``\\\\section``.  However, "
"to express this as a Python string literal, both backslashes must be escaped "
"*again*."
msgstr ""
"Låt oss säga att du vill skriva en RE som matchar strängen ``sektion``, som "
"kan finnas i en LaTeX-fil.  För att räkna ut vad som ska skrivas i "
"programkoden börjar du med den önskade strängen som ska matchas.  Därefter "
"måste du undkomma eventuella backslash och andra metatecken genom att föregå "
"dem med ett backslash, vilket resulterar i strängen ``section``.  Den "
"resulterande strängen som måste skickas till :func:`re.compile` måste vara "
"``section``.  Men för att uttrycka detta som en Python-stränglitteral måste "
"båda backslasharna escapas *igen*."

msgid "Characters"
msgstr "Tecken"

msgid "Stage"
msgstr "Scen"

msgid "``\\section``"
msgstr "\"sektion"

msgid "Text string to be matched"
msgstr "Textsträng som ska matchas"

msgid "``\\\\section``"
msgstr "\"snitt"

msgid "Escaped backslash for :func:`re.compile`"
msgstr "Undangömd backslash för :func:`re.compile`"

msgid "``\"\\\\\\\\section\"``"
msgstr "``\"\\\\\\\\section\"``"

msgid "Escaped backslashes for a string literal"
msgstr "Escaped backslashes för en strängbördal"

msgid ""
"In short, to match a literal backslash, one has to write ``'\\\\\\\\'`` as "
"the RE string, because the regular expression must be ``\\\\``, and each "
"backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal.  In REs that feature backslashes repeatedly, this leads to lots of "
"repeated backslashes and makes the resulting strings difficult to understand."
msgstr ""
"Kort sagt, för att matcha ett bokstavligt backslash måste man skriva ``'\\\\"
"\\\\'`` som RE-sträng, eftersom det reguljära uttrycket måste vara ````, och "
"varje backslash måste uttryckas som ````` inuti en reguljär Python-sträng.  "
"I RE:er som innehåller backslash upprepade gånger leder detta till många "
"upprepade backslash och gör de resulterande strängarna svåra att förstå."

msgid ""
"The solution is to use Python's raw string notation for regular expressions; "
"backslashes are not handled in any special way in a string literal prefixed "
"with ``'r'``, so ``r\"\\n\"`` is a two-character string containing ``'\\'`` "
"and ``'n'``, while ``\"\\n\"`` is a one-character string containing a "
"newline. Regular expressions will often be written in Python code using this "
"raw string notation."
msgstr ""
"Lösningen är att använda Pythons råa strängnotation för reguljära uttryck; "
"backslasher hanteras inte på något speciellt sätt i en stränglitual med "
"prefixet ``'r'``, så ``r\"\\n\"`` är en tvåteckenssträng som innehåller "
"``'\\'`` och ``'n'``, medan ``\"\\n\"`` är en enteckenssträng som innehåller "
"en ny rad. Reguljära uttryck skrivs ofta i Python-kod med hjälp av denna råa "
"strängnotation."

msgid ""
"In addition, special escape sequences that are valid in regular expressions, "
"but not valid as Python string literals, now result in a :exc:"
"`DeprecationWarning` and will eventually become a :exc:`SyntaxError`, which "
"means the sequences will be invalid if raw string notation or escaping the "
"backslashes isn't used."
msgstr ""
"Dessutom resulterar nu speciella escape-sekvenser som är giltiga i reguljära "
"uttryck, men inte giltiga som Python-stränglitteraler, i en :exc:"
"`DeprecationWarning` och kommer så småningom att bli en :exc:`SyntaxError`, "
"vilket innebär att sekvenserna kommer att vara ogiltiga om rå strängnotation "
"eller escaping av backslashes inte används."

msgid "Regular String"
msgstr "Vanlig sträng"

msgid "Raw string"
msgstr "Rå sträng"

msgid "``\"ab*\"``"
msgstr "``\"ab*\"```"

msgid "``r\"ab*\"``"
msgstr "``r\"ab*\"```"

msgid "``r\"\\\\section\"``"
msgstr "``r\"\\\\section\"``"

msgid "``\"\\\\w+\\\\s+\\\\1\"``"
msgstr "\"\\\\w+\\\\s+\\\\1\"``"

msgid "``r\"\\w+\\s+\\1\"``"
msgstr "``r\"\\w+\\s+\\1\"``"

msgid "Performing Matches"
msgstr "Utföra matchningar"

msgid ""
"Once you have an object representing a compiled regular expression, what do "
"you do with it?  Pattern objects have several methods and attributes. Only "
"the most significant ones will be covered here; consult the :mod:`re` docs "
"for a complete listing."
msgstr ""
"När du har ett objekt som representerar ett kompilerat reguljärt uttryck, "
"vad gör du med det?  Mönsterobjekt har flera metoder och attribut. Endast de "
"mest betydelsefulla kommer att tas upp här; se :mod:`re`-dokumenten för en "
"fullständig lista."

msgid "Method/Attribute"
msgstr "Metod/Attribut"

msgid "Purpose"
msgstr "Syfte"

msgid "``match()``"
msgstr "``match()```"

msgid "Determine if the RE matches at the beginning of the string."
msgstr "Avgör om RE matchar i början av strängen."

msgid "``search()``"
msgstr "``search()```"

msgid "Scan through a string, looking for any location where this RE matches."
msgstr ""
"Skanna igenom en sträng och leta efter alla platser där denna RE matchar."

msgid "``findall()``"
msgstr "``findall()``"

msgid "Find all substrings where the RE matches, and returns them as a list."
msgstr "Hitta alla delsträngar där RE matchar och returnera dem som en lista."

msgid "``finditer()``"
msgstr "``finditer()```"

msgid ""
"Find all substrings where the RE matches, and returns them as an :term:"
"`iterator`."
msgstr ""
"Hitta alla substrängar där RE matchar och returnera dem som en :term:"
"`iterator`."

msgid ""
":meth:`~re.Pattern.match` and :meth:`~re.Pattern.search` return ``None`` if "
"no match can be found.  If they're successful, a :ref:`match object <match-"
"objects>` instance is returned, containing information about the match: "
"where it starts and ends, the substring it matched, and more."
msgstr ""
":meth:`~re.Pattern.match` och :meth:`~re.Pattern.search` returnerar ``None`` "
"om ingen matchning kan hittas.  Om de lyckas returneras en :ref:`match "
"object <match-objects>`-instans som innehåller information om matchningen: "
"var den börjar och slutar, den delsträng som matchades med mera."

msgid ""
"You can learn about this by interactively experimenting with the :mod:`re` "
"module."
msgstr ""
"Du kan lära dig mer om detta genom att interaktivt experimentera med "
"modulen :mod:`re`."

msgid ""
"This HOWTO uses the standard Python interpreter for its examples. First, run "
"the Python interpreter, import the :mod:`re` module, and compile a RE::"
msgstr ""
"Denna HOWTO använder standardtolken Python för sina exempel. Kör först "
"Python-tolken, importera modulen :mod:`re` och kompilera en RE::"

msgid ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"
msgstr ""
">>> import re\n"
">>> p = re.compile('[a-z]+')\n"
">>> p\n"
"re.compile('[a-z]+')"

msgid ""
"Now, you can try matching various strings against the RE ``[a-z]+``.  An "
"empty string shouldn't match at all, since ``+`` means 'one or more "
"repetitions'. :meth:`~re.Pattern.match` should return ``None`` in this case, "
"which will cause the interpreter to print no output.  You can explicitly "
"print the result of :meth:`!match` to make this clear. ::"
msgstr ""
"Nu kan du försöka matcha olika strängar mot RE ``[a-z]+``.  En tom sträng "
"bör inte matchas alls, eftersom ``+`` betyder \"en eller flera "
"upprepningar\". :meth:`~re.Pattern.match` bör returnera ``None`` i det här "
"fallet, vilket gör att tolken inte skriver ut något.  Du kan uttryckligen "
"skriva ut resultatet av :meth:`!match` för att tydliggöra detta. ::"

msgid ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"None"
msgstr ""
">>> p.match(\"\")\n"
">>> print(p.match(\"\"))\n"
"Ingen"

msgid ""
"Now, let's try it on a string that it should match, such as ``tempo``.  In "
"this case, :meth:`~re.Pattern.match` will return a :ref:`match object <match-"
"objects>`, so you should store the result in a variable for later use. ::"
msgstr ""
"Låt oss nu prova det på en sträng som det ska matcha, till exempel "
"``tempo``.  I det här fallet kommer :meth:`~re.Pattern.match` att returnera "
"en :ref:`match object <match-objects>`, så du bör lagra resultatet i en "
"variabel för senare användning. ::"

msgid ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match object; span=(0, 5), match='tempo'>"
msgstr ""
">>> m = p.match('tempo')\n"
">>> m\n"
"<re.Match-objekt; span=(0, 5), match='tempo'>"

msgid ""
"Now you can query the :ref:`match object <match-objects>` for information "
"about the matching string.  Match object instances also have several methods "
"and attributes; the most important ones are:"
msgstr ""
"Nu kan du fråga :ref:`match object <match-objects>` efter information om den "
"matchande strängen.  Match-objektinstanser har också flera metoder och "
"attribut; de viktigaste är:"

msgid "``group()``"
msgstr "``group()```"

msgid "Return the string matched by the RE"
msgstr "Returnera den sträng som matchas av RE"

msgid "``start()``"
msgstr "``start()```"

msgid "Return the starting position of the match"
msgstr "Returnera startpositionen för matchen"

msgid "``end()``"
msgstr "``slut()```"

msgid "Return the ending position of the match"
msgstr "Returnera slutpositionen för matchen"

msgid "``span()``"
msgstr "``span()```"

msgid "Return a tuple containing the (start, end) positions  of the match"
msgstr ""
"Returnera en tupel som innehåller matchningens (start, slut) positioner"

msgid "Trying these methods will soon clarify their meaning::"
msgstr "Att prova dessa metoder kommer snart att klargöra deras betydelse::"

msgid ""
">>> m.group()\n"
"'tempo'\n"
">>> m.start(), m.end()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"
msgstr ""
">>> m.grupp()\n"
"'tempo'\n"
">>> m.start(), m.slut()\n"
"(0, 5)\n"
">>> m.span()\n"
"(0, 5)"

msgid ""
":meth:`~re.Match.group` returns the substring that was matched by the RE.  :"
"meth:`~re.Match.start` and :meth:`~re.Match.end` return the starting and "
"ending index of the match. :meth:`~re.Match.span` returns both start and end "
"indexes in a single tuple.  Since the :meth:`~re.Pattern.match` method only "
"checks if the RE matches at the start of a string, :meth:`!start` will "
"always be zero.  However, the :meth:`~re.Pattern.search` method of patterns "
"scans through the string, so  the match may not start at zero in that "
"case. ::"
msgstr ""
":meth:`~re.Match.group` returnerar den delsträng som matchades av RE. :meth:"
"`~re.Match.start` och :meth:`~re.Match.end` returnerar start- och slutindex "
"för matchningen. :meth:`~re.Match.span` returnerar både start- och slutindex "
"i en enda tupel.  Eftersom metoden :meth:`~re.Pattern.match` endast "
"kontrollerar om RE matchar i början av en sträng, kommer :meth:`!start` "
"alltid att vara noll.  Men metoden :meth:`~re.Pattern.search` i patterns "
"skannar igenom strängen, så det är inte säkert att matchningen börjar vid "
"noll i det fallet. ::"

msgid ""
">>> print(p.match('::: message'))\n"
"None\n"
">>> m = p.search('::: message'); print(m)\n"
"<re.Match object; span=(4, 11), match='message'>\n"
">>> m.group()\n"
"'message'\n"
">>> m.span()\n"
"(4, 11)"
msgstr ""
">>> print(p.match(':::: meddelande'))\n"
"Ingen\n"
">>> m = p.search(':::: meddelande'); print(m)\n"
"<re.match-objekt; span=(4, 11), match='meddelande'> >>> m.group()\n"
">>> m.group()\n"
"'meddelande'\n"
">>> m.span()\n"
"(4, 11)"

msgid ""
"In actual programs, the most common style is to store the :ref:`match object "
"<match-objects>` in a variable, and then check if it was ``None``.  This "
"usually looks like::"
msgstr ""
"I faktiska program är det vanligaste sättet att lagra :ref:`matchobjekt "
"<match-objects>` i en variabel och sedan kontrollera om det var ``None``.  "
"Detta ser vanligtvis ut som::"

msgid ""
"p = re.compile( ... )\n"
"m = p.match( 'string goes here' )\n"
"if m:\n"
"    print('Match found: ', m.group())\n"
"else:\n"
"    print('No match')"
msgstr ""
"p = re.compile( ... )\n"
"m = p.match( 'strängen går här' )\n"
"if m:\n"
"    print('Matchning hittades: ', m.group())\n"
"else:\n"
"    print('Ingen matchning')"

msgid ""
"Two pattern methods return all of the matches for a pattern. :meth:`~re."
"Pattern.findall` returns a list of matching strings::"
msgstr ""
"Två mönstermetoder returnerar alla matchningar för ett mönster. :meth:`~re."
"Pattern.findall` returnerar en lista med matchande strängar::"

msgid ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')\n"
"['12', '11', '10']"
msgstr ""
">>> p = re.compile(r'\\d+')\n"
">>> p.findall('12 trummisar som trummar, 11 pipare som pipar, 10 herrar som "
"hoppar')\n"
"['12', '11', '10']"

msgid ""
"The ``r`` prefix, making the literal a raw string literal, is needed in this "
"example because escape sequences in a normal \"cooked\" string literal that "
"are not recognized by Python, as opposed to regular expressions, now result "
"in a :exc:`DeprecationWarning` and will eventually become a :exc:"
"`SyntaxError`.  See :ref:`the-backslash-plague`."
msgstr ""
"Prefixet ``r``, som gör literalen till en rå sträng-literal, behövs i detta "
"exempel eftersom escape-sekvenser i en normal \"tillagad\" sträng-literal "
"som inte känns igen av Python, till skillnad från reguljära uttryck, nu "
"resulterar i en :exc:`DeprecationWarning` och kommer så småningom att bli "
"en :exc:`SyntaxError`.  Se :ref:`the-backslash-plague`."

msgid ""
":meth:`~re.Pattern.findall` has to create the entire list before it can be "
"returned as the result.  The :meth:`~re.Pattern.finditer` method returns a "
"sequence of :ref:`match object <match-objects>` instances as an :term:"
"`iterator`::"
msgstr ""
":meth:`~re.Pattern.findall` måste skapa hela listan innan den kan returneras "
"som resultat.  Metoden :meth:`~re.Pattern.finditer` returnerar en sekvens "
"av :ref:`match object <match-objects>` instanser som en :term:`iterator`::"

msgid ""
">>> iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')\n"
">>> iterator\n"
"<callable_iterator object at 0x...>\n"
">>> for match in iterator:\n"
"...     print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"
msgstr ""
">>> iterator = p.finditer('12 trummisar trummar, 11 ... 10 ...')\n"
">>> iterator\n"
"<anropsbart_iterator-objekt på 0x...> >>> för match i iterator\n"
">>> för match i iterator:\n"
"... print(match.span())\n"
"...\n"
"(0, 2)\n"
"(22, 24)\n"
"(29, 31)"

msgid "Module-Level Functions"
msgstr "Funktioner på modulnivå"

msgid ""
"You don't have to create a pattern object and call its methods; the :mod:"
"`re` module also provides top-level functions called :func:`~re.match`, :"
"func:`~re.search`, :func:`~re.findall`, :func:`~re.sub`, and so forth.  "
"These functions take the same arguments as the corresponding pattern method "
"with the RE string added as the first argument, and still return either "
"``None`` or a :ref:`match object <match-objects>` instance. ::"
msgstr ""
"Du behöver inte skapa ett pattern-objekt och anropa dess metoder; modulen :"
"mod:`re` tillhandahåller även funktioner på högsta nivå som heter :func:`~re."
"match`, :func:`~re.search`, :func:`~re.findall`, :func:`~re.sub` och så "
"vidare.  Dessa funktioner tar samma argument som motsvarande pattern-metod "
"med RE-strängen tillagd som första argument, och returnerar fortfarande "
"antingen ``None`` eller ett :ref:`match-objekt <match-objects>` instance. ::"

msgid ""
">>> print(re.match(r'From\\s+', 'Fromage amk'))\n"
"None\n"
">>> re.match(r'From\\s+', 'From amk Thu May 14 19:12:10 1998')\n"
"<re.Match object; span=(0, 5), match='From '>"
msgstr ""
">>> print(re.match(r'From\\s+','Fromage amk'))\n"
"Ingen\n"
">>> re.match(r'From\\s+','From amk Thu May 14 19:12:10 1998')\n"
"<re.Match-objekt; span=(0, 5), match='From'>"

msgid ""
"Under the hood, these functions simply create a pattern object for you and "
"call the appropriate method on it.  They also store the compiled object in a "
"cache, so future calls using the same RE won't need to parse the pattern "
"again and again."
msgstr ""
"Under huven skapar dessa funktioner helt enkelt ett mönsterobjekt åt dig och "
"anropar lämplig metod på det.  De lagrar också det kompilerade objektet i en "
"cache, så att framtida anrop med samma RE inte behöver analysera mönstret om "
"och om igen."

msgid ""
"Should you use these module-level functions, or should you get the pattern "
"and call its methods yourself?  If you're accessing a regex within a loop, "
"pre-compiling it will save a few function calls. Outside of loops, there's "
"not much difference thanks to the internal cache."
msgstr ""
"Ska du använda dessa funktioner på modulnivå, eller ska du hämta mönstret "
"och anropa dess metoder själv?  Om du kommer åt en regex i en loop sparar du "
"några funktionsanrop genom att förkompilera den. Utanför loopar är det inte "
"så stor skillnad tack vare den interna cachen."

msgid "Compilation Flags"
msgstr "Kompileringsflaggor"

msgid ""
"Compilation flags let you modify some aspects of how regular expressions "
"work. Flags are available in the :mod:`re` module under two names, a long "
"name such as :const:`IGNORECASE` and a short, one-letter form such as :const:"
"`I`.  (If you're familiar with Perl's pattern modifiers, the one-letter "
"forms use the same letters; the short form of :const:`re.VERBOSE` is :const:"
"`re.X`, for example.) Multiple flags can be specified by bitwise OR-ing "
"them; ``re.I | re.M`` sets both the :const:`I` and :const:`M` flags, for "
"example."
msgstr ""
"Med kompileringsflaggor kan du ändra vissa aspekter av hur reguljära uttryck "
"fungerar. Flaggor finns tillgängliga i modulen :mod:`re` under två namn, ett "
"långt namn som :const:`IGNORECASE` och en kort form med en bokstav som :"
"const:`I`.  (Om du är bekant med Perls mönstermodifierare använder formerna "
"med en bokstav samma bokstäver; kortformen av :const:`re.VERBOSE` är till "
"exempel :const:`re.X`) Flera flaggor kan anges genom bitvis OR-ning av dem; "
"``re.I | re.M`` anger till exempel både flaggorna :const:`I` och :const:`M`."

msgid ""
"Here's a table of the available flags, followed by a more detailed "
"explanation of each one."
msgstr ""
"Här är en tabell över tillgängliga flaggor, följt av en mer detaljerad "
"förklaring av var och en."

msgid "Flag"
msgstr "Flagga"

msgid "Meaning"
msgstr "Betydelse"

msgid ":const:`ASCII`, :const:`A`"
msgstr ":const:`ASCII`, :const:`A`"

msgid ""
"Makes several escapes like ``\\w``, ``\\b``, ``\\s`` and ``\\d`` match only "
"on ASCII characters with the respective property."
msgstr ""
"Gör att flera escapes som ``\\w``, ``b``, ``s`` och ``d`` endast matchar "
"ASCII-tecken med respektive egenskap."

msgid ":const:`DOTALL`, :const:`S`"
msgstr ":const:`DOTALL`, :const:`S`"

msgid "Make ``.`` match any character, including newlines."
msgstr "Låt ``.``` matcha alla tecken, inklusive nya rader."

msgid ":const:`IGNORECASE`, :const:`I`"
msgstr ":const:`IGNORECASE`, :const:`I`"

msgid "Do case-insensitive matches."
msgstr "Gör matchningar utan hänsyn till skiftlägeskänslighet."

msgid ":const:`LOCALE`, :const:`L`"
msgstr ":const:`LOCALE`, :const:`L`"

msgid "Do a locale-aware match."
msgstr "Gör en lokalanpassad matchning."

msgid ":const:`MULTILINE`, :const:`M`"
msgstr ":const:`MULTILINE`, :const:`M`"

msgid "Multi-line matching, affecting ``^`` and ``$``."
msgstr "Matchning av flera rader, påverkar ``^`` och ``$``."

msgid ":const:`VERBOSE`, :const:`X` (for 'extended')"
msgstr ":const:`VERBOSE`, :const:`X` (för 'extended')"

msgid ""
"Enable verbose REs, which can be organized more cleanly and understandably."
msgstr ""
"Aktivera verbose RE:s, som kan organiseras på ett mer överskådligt och "
"begripligt sätt."

msgid ""
"Perform case-insensitive matching; character class and literal strings will "
"match letters by ignoring case.  For example, ``[A-Z]`` will match lowercase "
"letters, too. Full Unicode matching also works unless the :const:`ASCII` "
"flag is used to disable non-ASCII matches.  When the Unicode patterns ``[a-"
"z]`` or ``[A-Z]`` are used in combination with the :const:`IGNORECASE` flag, "
"they will match the 52 ASCII letters and 4 additional non-ASCII letters: "
"'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin "
"small letter dotless i), 'ſ' (U+017F, Latin small letter long s) and "
"'K' (U+212A, Kelvin sign).  ``Spam`` will match ``'Spam'``, ``'spam'``, "
"``'spAM'``, or ``'ſpam'`` (the latter is matched only in Unicode mode). This "
"lowercasing doesn't take the current locale into account; it will if you "
"also set the :const:`LOCALE` flag."
msgstr ""
"Utför matchning som inte är skiftlägeskänslig; teckenklasser och "
"bokstavssträngar matchar bokstäver genom att ignorera skiftlägeskänslighet. "
"Till exempel matchar ``[A-Z]`` även gemener. Fullständig Unicode-matchning "
"fungerar också om inte flaggan :const:`ASCII` används för att inaktivera "
"matchningar som inte är ASCII. När Unicode-mönstren ``[a-z]`` eller ``[A-"
"Z]`` används i kombination med flaggan :const:`IGNORECASE` matchar de de 52 "
"ASCII-bokstäverna och 4 ytterligare icke-ASCII-bokstäver: 'İ' (U+0130, "
"latinsk versal I med punkt ovanför), ’ı’ (U+0131, latinsk gemen i utan "
"punkt), ’ſ’ (U+017F, latinsk gemen lång s) och ’K’ (U+212A, Kelvin-tecken). "
"``Spam`` matchar ``'Spam'``, ``'spam'``, ``'spAM'`` eller ``'ſpam'`` (det "
"senare matchas endast i Unicode-läge). Denna omvandling till gemener tar "
"inte hänsyn till den aktuella lokaliseringen; det gör den om du också anger "
"flaggan :const:`LOCALE`."

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale instead of the Unicode database."
msgstr ""
"Gör ``w``, ``W``, ``b``, ``B`` och skiftlägesokänslig matchning beroende av "
"aktuell locale istället för Unicode-databasen."

msgid ""
"Locales are a feature of the C library intended to help in writing programs "
"that take account of language differences.  For example, if you're "
"processing encoded French text, you'd want to be able to write ``\\w+`` to "
"match words, but ``\\w`` only matches the character class ``[A-Za-z]`` in "
"bytes patterns; it won't match bytes corresponding to ``é`` or ``ç``. If "
"your system is configured properly and a French locale is selected, certain "
"C functions will tell the program that the byte corresponding to ``é`` "
"should also be considered a letter. Setting the :const:`LOCALE` flag when "
"compiling a regular expression will cause the resulting compiled object to "
"use these C functions for ``\\w``; this is slower, but also enables ``\\w+`` "
"to match French words as you'd expect. The use of this flag is discouraged "
"in Python 3 as the locale mechanism is very unreliable, it only handles one "
"\"culture\" at a time, and it only works with 8-bit locales.  Unicode "
"matching is already enabled by default in Python 3 for Unicode (str) "
"patterns, and it is able to handle different locales/languages."
msgstr ""
"Locales är en funktion i C-biblioteket som är avsedd att hjälpa till att "
"skriva program som tar hänsyn till språkskillnader.  Om du till exempel "
"bearbetar kodad fransk text skulle du vilja kunna skriva ``\\w+`` för att "
"matcha ord, men ``\\w`` matchar bara teckenklassen ``[A-Za-z]`` i "
"bytesmönster; den matchar inte bytes som motsvarar ``é`` eller ``ç``. Om "
"ditt system är korrekt konfigurerat och en fransk språkdräkt är vald, kommer "
"vissa C-funktioner att tala om för programmet att byten som motsvarar ``é`` "
"också ska betraktas som en bokstav. Om du anger flaggan :const:`LOCALE` när "
"du kompilerar ett reguljärt uttryck kommer det resulterande kompilerade "
"objektet att använda dessa C-funktioner för ``w``; detta är långsammare, men "
"gör också att ``w+`` kan matcha franska ord som du förväntar dig. "
"Användningen av denna flagga är avrådd i Python 3 eftersom locale-mekanismen "
"är mycket opålitlig, den hanterar bara en \"kultur\" åt gången och den "
"fungerar bara med 8-bitars locales.  Unicode-matchning är redan aktiverad "
"som standard i Python 3 för Unicode (str)-mönster, och den kan hantera olika "
"lokala språk."

msgid ""
"(``^`` and ``$`` haven't been explained yet;  they'll be introduced in "
"section :ref:`more-metacharacters`.)"
msgstr ""
"(``^`` och ``$`` har inte förklarats ännu; de kommer att introduceras i "
"avsnitt :ref:`fler-metakaraktärer`.)"

msgid ""
"Usually ``^`` matches only at the beginning of the string, and ``$`` matches "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. When this flag is specified, ``^`` matches at the "
"beginning of the string and at the beginning of each line within the string, "
"immediately following each newline.  Similarly, the ``$`` metacharacter "
"matches either at the end of the string and at the end of each line "
"(immediately preceding each newline)."
msgstr ""
"Vanligtvis matchar ``^`` endast i början av strängen, och ``$`` matchar "
"endast i slutet av strängen och omedelbart före den nya raden (om någon) i "
"slutet av strängen. När denna flagga anges matchar ``^`` i början av "
"strängen och i början av varje rad i strängen, omedelbart efter varje ny "
"rad.  På samma sätt matchar metatecknet ``$`` antingen i slutet av strängen "
"eller i slutet av varje rad (omedelbart före varje ny rad)."

msgid ""
"Makes the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Gör att specialtecknet ``'.'`` matchar vilket tecken som helst, inklusive en "
"ny rad; utan denna flagga matchar ``'.'`` allt *utom* en ny rad."

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` perform ASCII-"
"only matching instead of full Unicode matching. This is only meaningful for "
"Unicode patterns, and is ignored for byte patterns."
msgstr ""
"Få ``w``, ``W``, ``b``, ``B``, ``s`` och ``S`` att utföra matchning med "
"enbart ASCII istället för fullständig Unicode-matchning. Detta är endast "
"meningsfullt för Unicode-mönster och ignoreras för bytemönster."

msgid ""
"This flag allows you to write regular expressions that are more readable by "
"granting you more flexibility in how you can format them.  When this flag "
"has been specified, whitespace within the RE string is ignored, except when "
"the whitespace is in a character class or preceded by an unescaped "
"backslash; this lets you organize and indent the RE more clearly.  This flag "
"also lets you put comments within a RE that will be ignored by the engine; "
"comments are marked by a ``'#'`` that's neither in a character class or "
"preceded by an unescaped backslash."
msgstr ""
"Med den här flaggan kan du skriva reguljära uttryck som är mer läsbara genom "
"att du får mer flexibilitet i hur du kan formatera dem.  När den här flaggan "
"har angetts ignoreras blanksteg i RE-strängen, utom när blanksteget är i en "
"teckenklass eller föregås av en obegränsad backslash; detta gör att du kan "
"organisera och indentera RE mer tydligt.  Med den här flaggan kan du också "
"lägga in kommentarer i en RE som ignoreras av motorn; kommentarer markeras "
"med en ``'#'`` som varken är i en teckenklass eller föregås av ett okapslat "
"backslash."

msgid ""
"For example, here's a RE that uses :const:`re.VERBOSE`; see how much easier "
"it is to read? ::"
msgstr ""
"Här är till exempel en RE som använder :const:`re.VERBOSE`; ser du hur "
"mycket lättare den är att läsa? ::"

msgid ""
"charref = re.compile(r\"\"\"\n"
" &[#]                # Start of a numeric entity reference\n"
" (\n"
"     0[0-7]+         # Octal form\n"
"   | [0-9]+          # Decimal form\n"
"   | x[0-9a-fA-F]+   # Hexadecimal form\n"
" )\n"
" ;                   # Trailing semicolon\n"
"\"\"\", re.VERBOSE)"
msgstr ""
"charref = re.compile(r\"\"\"\n"
" &[#] # Början på en numerisk enhetsreferens\n"
" (\n"
"     0[0-7]+ # oktal form\n"
"   | [0-9]+ # Decimalform\n"
"   | x[0-9a-fA-F]+ # Hexadecimal form\n"
" )\n"
" ; # Efterföljande semikolon\n"
"\"\"\", re.VERBOSE)"

msgid "Without the verbose setting, the RE would look like this::"
msgstr "Utan verbose-inställningen skulle RE se ut så här::"

msgid ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"
msgstr ""
"charref = re.compile(\"&#(0[0-7]+\"\n"
"                     \"|[0-9]+\"\n"
"                     \"|x[0-9a-fA-F]+);\")"

msgid ""
"In the above example, Python's automatic concatenation of string literals "
"has been used to break up the RE into smaller pieces, but it's still more "
"difficult to understand than the version using :const:`re.VERBOSE`."
msgstr ""
"I exemplet ovan har Pythons automatiska konkatenering av stränglitteraler "
"använts för att bryta upp RE i mindre bitar, men det är fortfarande svårare "
"att förstå än den version som använder :const:`re.VERBOSE`."

msgid "More Pattern Power"
msgstr "Mer mönsterkraft"

msgid ""
"So far we've only covered a part of the features of regular expressions.  In "
"this section, we'll cover some new metacharacters, and how to use groups to "
"retrieve portions of the text that was matched."
msgstr ""
"Hittills har vi bara gått igenom en del av funktionerna i reguljära "
"uttryck.  I det här avsnittet går vi igenom några nya metatecken och hur man "
"använder grupper för att hämta delar av den text som matchades."

msgid "More Metacharacters"
msgstr "Fler metakaraktärer"

msgid ""
"There are some metacharacters that we haven't covered yet.  Most of them "
"will be covered in this section."
msgstr ""
"Det finns några metakaraktärer som vi inte har gått igenom ännu.  De flesta "
"av dem kommer att tas upp i detta avsnitt."

msgid ""
"Some of the remaining metacharacters to be discussed are :dfn:`zero-width "
"assertions`.  They don't cause the engine to advance through the string; "
"instead, they consume no characters at all, and simply succeed or fail.  For "
"example, ``\\b`` is an assertion that the current position is located at a "
"word boundary; the position isn't changed by the ``\\b`` at all.  This means "
"that zero-width assertions should never be repeated, because if they match "
"once at a given location, they can obviously be matched an infinite number "
"of times."
msgstr ""
"Några av de återstående metatecken som skall diskuteras är :dfn:`zero-width "
"assertions`.  De gör inte att motorn avancerar genom strängen, utan de "
"förbrukar inga tecken alls och lyckas eller misslyckas helt enkelt.  Till "
"exempel är ``b`` ett påstående om att den aktuella positionen ligger vid en "
"ordgräns; positionen ändras inte alls av ``b``.  Detta innebär att "
"påståenden med nollbredd aldrig bör upprepas, för om de matchar en gång på "
"en given plats kan de uppenbarligen matchas ett oändligt antal gånger."

msgid "``|``"
msgstr "``|``"

msgid ""
"Alternation, or the \"or\" operator.   If *A* and *B* are regular "
"expressions, ``A|B`` will match any string that matches either *A* or *B*. "
"``|`` has very low precedence in order to make it work reasonably when "
"you're alternating multi-character strings. ``Crow|Servo`` will match either "
"``'Crow'`` or ``'Servo'``, not ``'Cro'``, a ``'w'`` or an ``'S'``, and "
"``'ervo'``."
msgstr ""
"Alternation, eller operatorn \"eller\".   Om *A* och *B* är reguljära "
"uttryck kommer ``A|B`` att matcha alla strängar som matchar antingen *A* "
"eller *B*. ``|`` har mycket låg prioritet för att det ska fungera på ett "
"rimligt sätt när du växlar strängar med flera tecken. ``Crow|Servo`` kommer "
"att matcha antingen ``'Crow'`` eller ``'Servo'``, inte ``'Cro'``, ett "
"``'w'`` eller ett ``'S'``, och ``'ervo'``."

msgid ""
"To match a literal ``'|'``, use ``\\|``, or enclose it inside a character "
"class, as in ``[|]``."
msgstr ""
"Om du vill matcha en bokstavlig ``'|'`` använder du ``\\|` eller omsluter "
"den i en teckenklass, som i ``[|]``."

msgid "``^``"
msgstr "``^``"

msgid ""
"Matches at the beginning of lines.  Unless the :const:`MULTILINE` flag has "
"been set, this will only match at the beginning of the string.  In :const:"
"`MULTILINE` mode, this also matches immediately after each newline within "
"the string."
msgstr ""
"Matchar i början av raderna.  Om inte flaggan :const:`MULTILINE` har "
"angetts, matchar detta endast i början av strängen.  I :const:`MULTILINE`-"
"läget matchar detta även omedelbart efter varje ny rad i strängen."

msgid ""
"For example, if you wish to match the word ``From`` only at the beginning of "
"a line, the RE to use is ``^From``. ::"
msgstr ""
"Om du till exempel vill matcha ordet ``From`` endast i början av en rad, är "
"RE att använda ``^From``. ::"

msgid ""
">>> print(re.search('^From', 'From Here to Eternity'))\n"
"<re.Match object; span=(0, 4), match='From'>\n"
">>> print(re.search('^From', 'Reciting From Memory'))\n"
"None"
msgstr ""
">>> print(re.search('^From', 'Härifrån till evigheten'))\n"
"<re.Match-objekt; span=(0, 4), match='From'> >>> print(re.search('^From'), "
"'Reciting From Memory')\n"
">>> print(re.search('^From', 'Reciterar ur minnet'))\n"
"Ingen"

msgid "To match a literal ``'^'``, use ``\\^``."
msgstr "Om du vill matcha en bokstavlig ``'^'`` använder du ``^``."

msgid "``$``"
msgstr "``$``"

msgid ""
"Matches at the end of a line, which is defined as either the end of the "
"string, or any location followed by a newline character.     ::"
msgstr ""
"Matchar i slutet av en rad, vilket definieras som antingen slutet av "
"strängen eller en plats som följs av ett tecken för ny rad. ::"

msgid ""
">>> print(re.search('}$', '{block}'))\n"
"<re.Match object; span=(6, 7), match='}'>\n"
">>> print(re.search('}$', '{block} '))\n"
"None\n"
">>> print(re.search('}$', '{block}\\n'))\n"
"<re.Match object; span=(6, 7), match='}'>"
msgstr ""
">>> print(re.search('}$', '{block}'))\n"
"<re.Match-objekt; span=(6, 7), match='}'> >>> print(re.search('}$', '{block} "
"')\n"
">>> print(re.search('}$', '{block} '))\n"
"Ingen\n"
">>> print(re.search('}$', '{block}\\n'))\n"
"<re.match-objekt; span=(6, 7), match='}'>"

msgid ""
"To match a literal ``'$'``, use ``\\$`` or enclose it inside a character "
"class, as in  ``[$]``."
msgstr ""
"Om du vill matcha en bokstavlig ``'$'`` använder du ``\\$`` eller omsluter "
"den med en teckenklass, som i ``[$]``."

msgid "``\\A``"
msgstr "``\\A``"

msgid ""
"Matches only at the start of the string.  When not in :const:`MULTILINE` "
"mode, ``\\A`` and ``^`` are effectively the same.  In :const:`MULTILINE` "
"mode, they're different: ``\\A`` still matches only at the beginning of the "
"string, but ``^`` may match at any location inside the string that follows a "
"newline character."
msgstr ""
"Matchar endast i början av strängen.  När det inte är i :const:`MULTILINE`-"
"läge är ``A`` och ``^`` i praktiken samma sak.  I :const:`MULTILINE`-läget "
"är de olika: ``A`` matchar fortfarande bara i början av strängen, men ``^`` "
"kan matcha på vilken plats som helst i strängen som följer efter ett newline-"
"tecken."

msgid "``\\z``"
msgstr "``\\z``"

msgid "Matches only at the end of the string."
msgstr "Matchar endast i slutet av strängen."

msgid "``\\Z``"
msgstr "``\\Z``"

msgid "The same as ``\\z``.  For compatibility with old Python versions."
msgstr "Samma som ``z``.  För kompatibilitet med gamla Python-versioner."

msgid "``\\b``"
msgstr "``\\b``"

msgid ""
"Word boundary.  This is a zero-width assertion that matches only at the "
"beginning or end of a word.  A word is defined as a sequence of alphanumeric "
"characters, so the end of a word is indicated by whitespace or a non-"
"alphanumeric character."
msgstr ""
"Ordgräns.  Detta är en assertion med noll bredd som endast matchar i början "
"eller slutet av ett ord.  Ett ord definieras som en sekvens av alfanumeriska "
"tecken, så slutet av ett ord indikeras av blanksteg eller ett icke-"
"alfanumeriskt tecken."

msgid ""
"The following example matches ``class`` only when it's a complete word; it "
"won't match when it's contained inside another word. ::"
msgstr ""
"Följande exempel matchar ``class`` endast när det är ett helt ord; det "
"kommer inte att matcha när det ingår i ett annat ord. ::"

msgid ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"<re.Match object; span=(3, 8), match='class'>\n"
">>> print(p.search('the declassified algorithm'))\n"
"None\n"
">>> print(p.search('one subclass is'))\n"
"None"
msgstr ""
">>> p = re.compile(r'\\bclass\\b')\n"
">>> print(p.search('ingen klass alls'))\n"
"<re.Match-objekt; span=(3, 8), match='class'>\n"
">>> print(p.search('den avklassificerade algoritmen'))\n"
"Ingen\n"
">>> print(p.search('en underklass är'))\n"
"Ingen"

msgid ""
"There are two subtleties you should remember when using this special "
"sequence. First, this is the worst collision between Python's string "
"literals and regular expression sequences.  In Python's string literals, "
"``\\b`` is the backspace character, ASCII value 8.  If you're not using raw "
"strings, then Python will convert the ``\\b`` to a backspace, and your RE "
"won't match as you expect it to. The following example looks the same as our "
"previous RE, but omits the ``'r'`` in front of the RE string. ::"
msgstr ""
"Det finns två saker du bör komma ihåg när du använder den här speciella "
"sekvensen. För det första är detta den värsta kollisionen mellan Pythons "
"stränglitteraler och sekvenser för reguljära uttryck.  I Pythons "
"stränglitteraler är ``b`` backspace-tecknet, ASCII-värde 8.  Om du inte "
"använder råa strängar kommer Python att konvertera ``b`` till ett backsteg, "
"och din RE kommer inte att matcha som du förväntar dig att den ska göra. "
"Följande exempel ser likadant ut som vår föregående RE, men utelämnar ``'r`` "
"framför RE-strängen. ::"

msgid ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('no class at all'))\n"
"None\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match object; span=(0, 7), match='\\x08class\\x08'>"
msgstr ""
">>> p = re.compile('\\bclass\\b')\n"
">>> print(p.search('ingen klass alls'))\n"
"Ingen\n"
">>> print(p.search('\\b' + 'class' + '\\b'))\n"
"<re.Match-objekt; span=(0, 7), match='\\x08class\\x08'>"

msgid ""
"Second, inside a character class, where there's no use for this assertion, "
"``\\b`` represents the backspace character, for compatibility with Python's "
"string literals."
msgstr ""
"För det andra, i en teckenklass, där det inte finns någon användning för "
"detta påstående, representerar ``b`` backspace-tecknet, för kompatibilitet "
"med Pythons stränglitteraler."

msgid "``\\B``"
msgstr "``\\B``"

msgid ""
"Another zero-width assertion, this is the opposite of ``\\b``, only matching "
"when the current position is not at a word boundary."
msgstr ""
"Detta är motsatsen till ``b`` och matchar bara när den aktuella positionen "
"inte ligger vid en ordgräns."

msgid "Grouping"
msgstr "Gruppering"

msgid ""
"Frequently you need to obtain more information than just whether the RE "
"matched or not.  Regular expressions are often used to dissect strings by "
"writing a RE divided into several subgroups which match different components "
"of interest. For example, an RFC-822 header line is divided into a header "
"name and a value, separated by a ``':'``, like this:"
msgstr ""
"Ofta behöver man mer information än bara om RE:n matchar eller inte.  "
"Reguljära uttryck används ofta för att dissekera strängar genom att skriva "
"en RE som är uppdelad i flera undergrupper som matchar olika komponenter av "
"intresse. En rubrikrad i RFC-822 delas t.ex. upp i ett rubriknamn och ett "
"värde, åtskilda av ett ``':'``, så här:"

msgid ""
"From: author@example.com\n"
"User-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-Version: 1.0\n"
"To: editor@example.com"
msgstr ""
"Från: author@example.com\n"
"Användar-Agent: Thunderbird 1.5.0.9 (X11/20061227)\n"
"MIME-version: 1.0\n"
"Till: editor@example.com"

msgid ""
"This can be handled by writing a regular expression which matches an entire "
"header line, and has one group which matches the header name, and another "
"group which matches the header's value."
msgstr ""
"Detta kan hanteras genom att skriva ett reguljärt uttryck som matchar en hel "
"rubrikrad och har en grupp som matchar rubrikens namn och en annan grupp som "
"matchar rubrikens värde."

msgid ""
"Groups are marked by the ``'('``, ``')'`` metacharacters. ``'('`` and "
"``')'`` have much the same meaning as they do in mathematical expressions; "
"they group together the expressions contained inside them, and you can "
"repeat the contents of a group with a quantifier, such as ``*``, ``+``, ``?"
"``, or ``{m,n}``.  For example, ``(ab)*`` will match zero or more "
"repetitions of ``ab``. ::"
msgstr ""
"Grupper markeras med metatecknen ``'('``, ``')'``. ``'('`` och ``')'`` har "
"ungefär samma betydelse som de har i matematiska uttryck; de grupperar de "
"uttryck som finns inuti dem, och du kan upprepa innehållet i en grupp med en "
"kvantifierare, till exempel ``*``, ``+``, ``?`` eller ``{m,n}``.  Till "
"exempel kommer ``(ab)*`` att matcha noll eller fler upprepningar av "
"``ab``. ::"

msgid ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"
msgstr ""
">>> p = re.compile('(ab)*')\n"
">>> print(p.match('ababababab').span())\n"
"(0, 10)"

msgid ""
"Groups indicated with ``'('``, ``')'`` also capture the starting and ending "
"index of the text that they match; this can be retrieved by passing an "
"argument to :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re."
"Match.end`, and :meth:`~re.Match.span`.  Groups are numbered starting with "
"0.  Group 0 is always present; it's the whole RE, so :ref:`match object "
"<match-objects>` methods all have group 0 as their default argument.  Later "
"we'll see how to express groups that don't capture the span of text that "
"they match. ::"
msgstr ""
"Grupper som indikeras med ``'('``, ``')'`` fångar också start- och slutindex "
"för texten som de matchar; detta kan hämtas genom att skicka ett argument "
"till :meth:`~re.Match.group`, :meth:`~re.Match.start`, :meth:`~re.Match."
"end`, och :meth:`~re.Match.span`.  Grupperna är numrerade med början på 0. "
"Grupp 0 finns alltid; det är hela RE, så :ref:`match object <match-objects>` "
"-metoderna har alla grupp 0 som standardargument.  Senare ska vi se hur man "
"uttrycker grupper som inte fångar det textavsnitt som de matchar. ::"

msgid ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.group(0)\n"
"'ab'"
msgstr ""
">>> p = re.compile('(a)b')\n"
">>> m = p.match('ab')\n"
">>> m.group()\n"
"'ab'\n"
">>> m.grupp(0)\n"
"'ab'"

msgid ""
"Subgroups are numbered from left to right, from 1 upward.  Groups can be "
"nested; to determine the number, just count the opening parenthesis "
"characters, going from left to right. ::"
msgstr ""
"Undergrupperna numreras från vänster till höger, från 1 och uppåt.  Grupper "
"kan vara kapslade; för att bestämma antalet räknar man bara de inledande "
"parentestecknen från vänster till höger. ::"

msgid ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.group(1)\n"
"'abc'\n"
">>> m.group(2)\n"
"'b'"
msgstr ""
">>> p = re.compile('(a(b)c)d')\n"
">>> m = p.match('abcd')\n"
">>> m.group(0)\n"
"'abcd'\n"
">>> m.grupp(1)\n"
"'abc'\n"
">>> m.grupp(2)\n"
"'b'"

msgid ""
":meth:`~re.Match.group` can be passed multiple group numbers at a time, in "
"which case it will return a tuple containing the corresponding values for "
"those groups. ::"
msgstr ""
":meth:`~re.Match.group` kan ges flera gruppnummer åt gången, i vilket fall "
"den kommer att returnera en tupel som innehåller motsvarande värden för "
"dessa grupper. ::"

msgid ""
">>> m.group(2,1,2)\n"
"('b', 'abc', 'b')"
msgstr ""
">>> m.grupp(2,1,2)\n"
"('b', 'abc', 'b')"

msgid ""
"The :meth:`~re.Match.groups` method returns a tuple containing the strings "
"for all the subgroups, from 1 up to however many there are. ::"
msgstr ""
"Metoden :meth:`~re.Match.groups` returnerar en tupel som innehåller "
"strängarna för alla undergrupper, från 1 upp till hur många som helst. ::"

msgid ""
">>> m.groups()\n"
"('abc', 'b')"
msgstr ""
">>> m.grupper()\n"
"('abc', 'b')"

msgid ""
"Backreferences in a pattern allow you to specify that the contents of an "
"earlier capturing group must also be found at the current location in the "
"string.  For example, ``\\1`` will succeed if the exact contents of group 1 "
"can be found at the current position, and fails otherwise.  Remember that "
"Python's string literals also use a backslash followed by numbers to allow "
"including arbitrary characters in a string, so be sure to use a raw string "
"when incorporating backreferences in a RE."
msgstr ""
"Med hjälp av bakåtreferenser i ett mönster kan du ange att innehållet i en "
"tidigare fångad grupp också måste finnas på den aktuella platsen i "
"strängen.  Till exempel kommer ``1`` att lyckas om det exakta innehållet i "
"grupp 1 kan hittas på den aktuella positionen, och misslyckas annars.  Kom "
"ihåg att Pythons stränglitteraler också använder ett backslash följt av "
"siffror för att tillåta att godtyckliga tecken inkluderas i en sträng, så se "
"till att använda en rå sträng när du införlivar bakåtreferenser i en RE."

msgid "For example, the following RE detects doubled words in a string. ::"
msgstr "Följande RE upptäcker till exempel dubbla ord i en sträng: ::"

msgid ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
">>> p = re.compile(r'\\b(\\w+)\\s+\\1\\b')\n"
">>> p.search('Paris under våren').group()\n"
"'den den'"

msgid ""
"Backreferences like this aren't often useful for just searching through a "
"string --- there are few text formats which repeat data in this way --- but "
"you'll soon find out that they're *very* useful when performing string "
"substitutions."
msgstr ""
"Sådana här backreferenser är inte ofta användbara för att bara söka igenom "
"en sträng --- det finns få textformat som upprepar data på det här sättet "
"--- men du kommer snart att upptäcka att de är *mycket* användbara när du "
"utför strängsubstitutioner."

msgid "Non-capturing and Named Groups"
msgstr "Icke-fångande och namngivna grupper"

msgid ""
"Elaborate REs may use many groups, both to capture substrings of interest, "
"and to group and structure the RE itself.  In complex REs, it becomes "
"difficult to keep track of the group numbers.  There are two features which "
"help with this problem.  Both of them use a common syntax for regular "
"expression extensions, so we'll look at that first."
msgstr ""
"I komplicerade RE:er kan många grupper användas, både för att fånga upp "
"intressanta delsträngar och för att gruppera och strukturera själva RE:n.  I "
"komplexa RE:er blir det svårt att hålla reda på gruppnumren.  Det finns två "
"funktioner som hjälper till att lösa detta problem.  Båda använder en "
"gemensam syntax för tillägg till reguljära uttryck, så vi tittar på det "
"först."

msgid ""
"Perl 5 is well known for its powerful additions to standard regular "
"expressions. For these new features the Perl developers couldn't choose new "
"single-keystroke metacharacters or new special sequences beginning with "
"``\\`` without making Perl's regular expressions confusingly different from "
"standard REs.  If they chose ``&`` as a new metacharacter, for example, old "
"expressions would be assuming that ``&`` was a regular character and "
"wouldn't have escaped it by writing ``\\&`` or ``[&]``."
msgstr ""
"Perl 5 är välkänt för sina kraftfulla tillägg till reguljära "
"standarduttryck. För dessa nya funktioner kunde Perl-utvecklarna inte välja "
"nya metatecken för enstaka tangenttryckningar eller nya specialsekvenser som "
"börjar med ````` utan att göra Perls reguljära uttryck förvirrande "
"annorlunda än standard REs.  Om de till exempel valde ``&`` som ett nytt "
"metatecken, skulle gamla uttryck anta att ``&`` var ett reguljärt tecken och "
"skulle inte ha undkommit det genom att skriva ``&`` eller ``[&]``."

msgid ""
"The solution chosen by the Perl developers was to use ``(?...)`` as the "
"extension syntax.  ``?`` immediately after a parenthesis was a syntax error "
"because the ``?`` would have nothing to repeat, so this didn't introduce any "
"compatibility problems.  The characters immediately after the ``?``  "
"indicate what extension is being used, so ``(?=foo)`` is one thing (a "
"positive lookahead assertion) and ``(?:foo)`` is something else (a non-"
"capturing group containing the subexpression ``foo``)."
msgstr ""
"Den lösning som Perl-utvecklarna valde var att använda ``(?...)`` som "
"utvidgningssyntax.  ``?`` omedelbart efter en parentes var ett syntaxfel "
"eftersom ``?`` inte skulle ha något att upprepa, så detta medförde inga "
"kompatibilitetsproblem.  Tecknen omedelbart efter ``?`` anger vilket tillägg "
"som används, så ``(?=foo)`` är en sak (ett positivt lookahead-assertion) och "
"``(?:foo)`` är något annat (en icke-fångande grupp som innehåller "
"underuttrycket ``foo``)."

msgid ""
"Python supports several of Perl's extensions and adds an extension syntax to "
"Perl's extension syntax.  If the first character after the question mark is "
"a ``P``, you know that it's an extension that's specific to Python."
msgstr ""
"Python stöder flera av Perls tillägg och lägger till en tilläggssyntax till "
"Perls tilläggssyntax.  Om det första tecknet efter frågetecknet är ett ``P`` "
"vet du att det är ett tillägg som är specifikt för Python."

msgid ""
"Now that we've looked at the general extension syntax, we can return to the "
"features that simplify working with groups in complex REs."
msgstr ""
"Nu när vi har tittat på den allmänna syntaxen för tillägg kan vi återgå till "
"de funktioner som förenklar arbetet med grupper i komplexa RE:er."

msgid ""
"Sometimes you'll want to use a group to denote a part of a regular "
"expression, but aren't interested in retrieving the group's contents. You "
"can make this fact explicit by using a non-capturing group: ``(?:...)``, "
"where you can replace the ``...`` with any other regular expression. ::"
msgstr ""
"Ibland vill du använda en grupp för att beteckna en del av ett reguljärt "
"uttryck, men du är inte intresserad av att hämta gruppens innehåll. Du kan "
"göra detta faktum explicit genom att använda en icke-fångande grupp: "
"``(?:...)``, där du kan ersätta ``...`` med vilket annat reguljärt uttryck "
"som helst. ::"

msgid ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.groups()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.groups()\n"
"()"
msgstr ""
">>> m = re.match(\"([abc])+\", \"abc\")\n"
">>> m.grupper()\n"
"('c',)\n"
">>> m = re.match(\"(?:[abc])+\", \"abc\")\n"
">>> m.grupper()\n"
"()"

msgid ""
"Except for the fact that you can't retrieve the contents of what the group "
"matched, a non-capturing group behaves exactly the same as a capturing "
"group; you can put anything inside it, repeat it with a repetition "
"metacharacter such as ``*``, and nest it within other groups (capturing or "
"non-capturing). ``(?:...)`` is particularly useful when modifying an "
"existing pattern, since you can add new groups without changing how all the "
"other groups are numbered.  It should be mentioned that there's no "
"performance difference in searching between capturing and non-capturing "
"groups; neither form is any faster than the other."
msgstr ""
"Förutom det faktum att du inte kan hämta innehållet i det som gruppen "
"matchade, beter sig en icke-fångande grupp exakt likadant som en fångande "
"grupp; du kan lägga in vad som helst i den, upprepa den med ett metatecken "
"för upprepning som ``*`` och nesta den i andra grupper (fångande eller icke-"
"fångande). ``(?:...)`` är särskilt användbart när du ändrar ett befintligt "
"mönster, eftersom du kan lägga till nya grupper utan att ändra hur alla "
"andra grupper är numrerade.  Det bör nämnas att det inte finns någon "
"prestandaskillnad i sökningen mellan fångande och icke-fångande grupper; "
"ingen av formerna är snabbare än den andra."

msgid ""
"A more significant feature is named groups: instead of referring to them by "
"numbers, groups can be referenced by a name."
msgstr ""
"En mer betydelsefull funktion är namngivna grupper: i stället för att "
"hänvisa till dem med nummer kan grupper hänvisas till med ett namn."

msgid ""
"The syntax for a named group is one of the Python-specific extensions: ``(?"
"P<name>...)``.  *name* is, obviously, the name of the group.  Named groups "
"behave exactly like capturing groups, and additionally associate a name with "
"a group.  The :ref:`match object <match-objects>` methods that deal with "
"capturing groups all accept either integers that refer to the group by "
"number or strings that contain the desired group's name.  Named groups are "
"still given numbers, so you can retrieve information about a group in two "
"ways::"
msgstr ""
"Syntaxen för en namngiven grupp är ett av de Python-specifika tilläggen: ``(?"
"P<name>...)``.  *name* är naturligtvis namnet på gruppen.  Namngivna grupper "
"beter sig precis som fångande grupper, och associerar dessutom ett namn med "
"en grupp.  Metoderna :ref:`match object <match-objects>` som hanterar "
"fångande grupper accepterar alla antingen heltal som hänvisar till gruppen "
"med nummer eller strängar som innehåller den önskade gruppens namn.  "
"Namngivna grupper ges fortfarande nummer, så du kan hämta information om en "
"grupp på två sätt::"

msgid ""
">>> p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
">>> m = p.search( '(((( Lots of punctuation )))' )\n"
">>> m.group('word')\n"
"'Lots'\n"
">>> m.group(1)\n"
"'Lots'"
msgstr ""
"&gt;&gt;&gt; p = re.compile(r'(?P<word>\\b\\w+\\b)')\n"
"&gt;&gt;&gt; m = p.search( '(((( Massor av skiljetecken )))' )\n"
"&gt;&gt;&gt; m.group('ord')\n"
"'Massor'\n"
"&gt;&gt;&gt; m.grupp(1)\n"
"'Massor'"

msgid ""
"Additionally, you can retrieve named groups as a dictionary with :meth:`~re."
"Match.groupdict`::"
msgstr ""
"Dessutom kan du hämta namngivna grupper som en ordbok med :meth:`~re.Match."
"groupdict`::"

msgid ""
">>> m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
">>> m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"
msgstr ""
"&gt;&gt;&gt; m = re.match(r'(?P<first>\\w+) (?P<last>\\w+)', 'Jane Doe')\n"
"&gt;&gt;&gt; m.groupdict()\n"
"{'first': 'Jane', 'last': 'Doe'}"

msgid ""
"Named groups are handy because they let you use easily remembered names, "
"instead of having to remember numbers.  Here's an example RE from the :mod:"
"`imaplib` module::"
msgstr ""
"Namngivna grupper är praktiska eftersom de låter dig använda namn som är "
"lätta att komma ihåg, istället för att behöva komma ihåg siffror.  Här är "
"ett exempel på RE från modulen :mod:`imaplib`::"

msgid ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9])'\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"
msgstr ""
"InternalDate = re.compile(r'INTERNALDATE \"'\n"
"        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'\n"
"        r'(?P<year>[0-9][0-9][0-9][0-9][0-9])''\n"
"        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'\n"
"        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'\n"
"        r'\"')"

msgid ""
"It's obviously much easier to retrieve ``m.group('zonem')``, instead of "
"having to remember to retrieve group 9."
msgstr ""
"Det är uppenbarligen mycket enklare att hämta ``m.group('zonem')``, istället "
"för att behöva komma ihåg att hämta grupp 9."

msgid ""
"The syntax for backreferences in an expression such as ``(...)\\1`` refers "
"to the number of the group.  There's naturally a variant that uses the group "
"name instead of the number. This is another Python extension: ``(?P=name)`` "
"indicates that the contents of the group called *name* should again be "
"matched at the current point.  The regular expression for finding doubled "
"words, ``\\b(\\w+)\\s+\\1\\b`` can also be written as ``\\b(?"
"P<word>\\w+)\\s+(?P=word)\\b``::"
msgstr ""
"Syntaxen för backreferenser i ett uttryck som ``(...)\\1`` hänvisar till "
"gruppens nummer.  Det finns naturligtvis en variant som använder gruppnamnet "
"i stället för numret. Detta är ett annat Python-tillägg: ``(?P=namn)`` "
"indikerar att innehållet i gruppen som heter *namn* återigen ska matchas vid "
"den aktuella punkten.  Det reguljära uttrycket för att hitta dubblerade ord, "
"``\\b(\\w+)\\s+\\1\\b`` kan också skrivas som ``\\b(?P<word>\\w+)\\s+(?"
"P=ord)\\b``::"

msgid ""
">>> p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=word)\\b')\n"
">>> p.search('Paris in the the spring').group()\n"
"'the the'"
msgstr ""
"&gt;&gt;&gt; p = re.compile(r'\\b(?P<word>\\w+)\\s+(?P=ord)\\b')\n"
"&gt;&gt;&gt; p.search('Paris på våren').group()\n"
"'den den'"

msgid "Lookahead Assertions"
msgstr "Förutseende påståenden"

msgid ""
"Another zero-width assertion is the lookahead assertion.  Lookahead "
"assertions are available in both positive and negative form, and  look like "
"this:"
msgstr ""
"Ett annat nollbreddsassertion är lookahead-assertion.  Lookahead-assertions "
"finns i både positiv och negativ form och ser ut så här:"

msgid "``(?=...)``"
msgstr "``(?=...)``"

msgid ""
"Positive lookahead assertion.  This succeeds if the contained regular "
"expression, represented here by ``...``, successfully matches at the current "
"location, and fails otherwise. But, once the contained expression has been "
"tried, the matching engine doesn't advance at all; the rest of the pattern "
"is tried right where the assertion started."
msgstr ""
"Positivt påstående om lookahead.  Detta lyckas om det ingående reguljära "
"uttrycket, som här representeras av ``...``, framgångsrikt matchar på den "
"aktuella platsen, och misslyckas annars. Men när det inneslutna uttrycket "
"har prövats går matchningsmotorn inte vidare alls; resten av mönstret prövas "
"precis där påståendet började."

msgid "``(?!...)``"
msgstr "``(?!...)``"

msgid ""
"Negative lookahead assertion.  This is the opposite of the positive "
"assertion; it succeeds if the contained expression *doesn't* match at the "
"current position in the string."
msgstr ""
"Negativt framåtblickande påstående.  Detta är motsatsen till det positiva "
"påståendet; det lyckas om det ingående uttrycket *inte* matchar vid den "
"aktuella positionen i strängen."

msgid ""
"To make this concrete, let's look at a case where a lookahead is useful. "
"Consider a simple pattern to match a filename and split it apart into a base "
"name and an extension, separated by a ``.``.  For example, in ``news.rc``, "
"``news`` is the base name, and ``rc`` is the filename's extension."
msgstr ""
"För att konkretisera detta ska vi titta på ett fall där en lookahead är "
"användbar. Tänk på ett enkelt mönster för att matcha ett filnamn och dela "
"upp det i ett basnamn och ett tillägg, åtskilda av en ``.``.  I till exempel "
"``news.rc`` är ``news`` basnamnet och ``rc`` är filnamnets tillägg."

msgid "The pattern to match this is quite simple:"
msgstr "Mönstret för att matcha detta är ganska enkelt:"

msgid "``.*[.].*$``"
msgstr "``.*[.].*$``"

msgid ""
"Notice that the ``.`` needs to be treated specially because it's a "
"metacharacter, so it's inside a character class to only match that specific "
"character.  Also notice the trailing ``$``; this is added to ensure that all "
"the rest of the string must be included in the extension.  This regular "
"expression matches ``foo.bar`` and ``autoexec.bat`` and ``sendmail.cf`` and "
"``printers.conf``."
msgstr ""
"Lägg märke till att ``.`` måste behandlas speciellt eftersom det är ett "
"metatecken, så det är inuti en teckenklass som bara matchar det specifika "
"tecknet.  Lägg också märke till det efterföljande ``$``; detta läggs till "
"för att säkerställa att resten av strängen måste inkluderas i tillägget.  "
"Detta reguljära uttryck matchar ``foo.bar`` och ``autoexec.bat`` och "
"``endmail.cf`` och ``printers.conf``."

msgid ""
"Now, consider complicating the problem a bit; what if you want to match "
"filenames where the extension is not ``bat``? Some incorrect attempts:"
msgstr ""
"Tänk nu på att komplicera problemet lite; vad händer om du vill matcha "
"filnamn där tillägget inte är ``bat``? Några felaktiga försök:"

msgid "``.*[.][^b].*$``"
msgstr "``.*[.][^b].*$``"

msgid ""
"The first attempt above tries to exclude ``bat`` by requiring that the first "
"character of the extension is not a ``b``.  This is wrong, because the "
"pattern also doesn't match ``foo.bar``."
msgstr ""
"Det första försöket ovan försöker utesluta ``bat`` genom att kräva att det "
"första tecknet i tillägget inte är ett ``b``.  Detta är fel, eftersom "
"mönstret inte heller matchar ``foo.bar``."

msgid "``.*[.]([^b]..|.[^a].|..[^t])$``"
msgstr "``.*[.]([^b]..|.[^a].|..[^t])$``"

msgid ""
"The expression gets messier when you try to patch up the first solution by "
"requiring one of the following cases to match: the first character of the "
"extension isn't ``b``; the second character isn't ``a``; or the third "
"character isn't ``t``.  This accepts ``foo.bar`` and rejects ``autoexec."
"bat``, but it requires a three-letter extension and won't accept a filename "
"with a two-letter extension such as ``sendmail.cf``.  We'll complicate the "
"pattern again in an effort to fix it."
msgstr ""
"Uttrycket blir rörigare när du försöker lappa ihop den första lösningen "
"genom att kräva att något av följande fall ska matcha: det första tecknet i "
"tillägget är inte ``b``; det andra tecknet är inte ``a``; eller det tredje "
"tecknet är inte ``t``.  Detta accepterar ``foo.bar`` och avvisar ``autoexec."
"bat``, men det kräver ett tillägg på tre bokstäver och accepterar inte ett "
"filnamn med ett tillägg på två bokstäver som ``endmail.cf``.  Vi ska "
"komplicera mönstret igen i ett försök att lösa det."

msgid "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"
msgstr "``.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$``"

msgid ""
"In the third attempt, the second and third letters are all made optional in "
"order to allow matching extensions shorter than three characters, such as "
"``sendmail.cf``."
msgstr ""
"I det tredje försöket görs den andra och tredje bokstaven valfria för att "
"möjliggöra matchning av tillägg som är kortare än tre tecken, t.ex. "
"``sendmail.cf``."

msgid ""
"The pattern's getting really complicated now, which makes it hard to read "
"and understand.  Worse, if the problem changes and you want to exclude both "
"``bat`` and ``exe`` as extensions, the pattern would get even more "
"complicated and confusing."
msgstr ""
"Mönstret börjar bli riktigt komplicerat nu, vilket gör det svårt att läsa "
"och förstå.  Än värre, om problemet ändras och du vill utesluta både ``bat`` "
"och ``exe`` som tillägg, skulle mönstret bli ännu mer komplicerat och "
"förvirrande."

msgid "A negative lookahead cuts through all this confusion:"
msgstr "En negativ framåtblickande prognos skär igenom all denna förvirring:"

msgid "``.*[.](?!bat$)[^.]*$``"
msgstr "``.*[.](?!bat$)[^.]*$```"

msgid ""
"The negative lookahead means: if the expression ``bat`` doesn't match at "
"this point, try the rest of the pattern; if ``bat$`` does match, the whole "
"pattern will fail.  The trailing ``$`` is required to ensure that something "
"like ``sample.batch``, where the extension only starts with ``bat``, will be "
"allowed.  The ``[^.]*`` makes sure that the pattern works when there are "
"multiple dots in the filename."
msgstr ""
"Den negativa lookahead betyder: om uttrycket ``bat`` inte matchar vid denna "
"punkt, prova resten av mönstret; om ``bat$`` matchar, kommer hela mönstret "
"att misslyckas.  Den efterföljande ``$`` krävs för att säkerställa att något "
"som ``sample.batch``, där tillägget endast börjar med ``bat``, tillåts.  "
"``[^.]*`` ser till att mönstret fungerar när det finns flera punkter i "
"filnamnet."

msgid ""
"Excluding another filename extension is now easy; simply add it as an "
"alternative inside the assertion.  The following pattern excludes filenames "
"that end in either ``bat`` or ``exe``:"
msgstr ""
"Det är nu enkelt att utesluta ett annat filnamnstillägg; lägg bara till det "
"som ett alternativ i påståendet.  Följande mönster utesluter filnamn som "
"slutar på antingen ``bat`` eller ``exe``:"

msgid "``.*[.](?!bat$|exe$)[^.]*$``"
msgstr "``.*[.](?!bat$|exe$)[^.]*$```"

msgid "Modifying Strings"
msgstr "Modifiera strängar"

msgid ""
"Up to this point, we've simply performed searches against a static string. "
"Regular expressions are also commonly used to modify strings in various "
"ways, using the following pattern methods:"
msgstr ""
"Hittills har vi bara gjort sökningar mot en statisk sträng. Reguljära "
"uttryck används också ofta för att modifiera strängar på olika sätt, med "
"hjälp av följande mönstermetoder:"

msgid "``split()``"
msgstr "``split()```"

msgid "Split the string into a list, splitting it wherever the RE matches"
msgstr "Dela upp strängen i en lista och dela upp den där RE matchar"

msgid "``sub()``"
msgstr "```sub()```"

msgid ""
"Find all substrings where the RE matches, and replace them with a different "
"string"
msgstr ""
"Hitta alla delsträngar där RE matchar och ersätt dem med en annan sträng"

msgid "``subn()``"
msgstr "```subn()```"

msgid ""
"Does the same thing as :meth:`!sub`,  but returns the new string and the "
"number of replacements"
msgstr ""
"Gör samma sak som :meth:`!sub`, men returnerar den nya strängen och antalet "
"ersättningar"

msgid "Splitting Strings"
msgstr "Delning av strängar"

msgid ""
"The :meth:`~re.Pattern.split` method of a pattern splits a string apart "
"wherever the RE matches, returning a list of the pieces. It's similar to "
"the :meth:`~str.split` method of strings but provides much more generality "
"in the delimiters that you can split by; string :meth:`!split` only supports "
"splitting by whitespace or by a fixed string.  As you'd expect, there's a "
"module-level :func:`re.split` function, too."
msgstr ""
"Metoden :meth:`~re.Pattern.split` för ett mönster delar upp en sträng där RE "
"matchar och returnerar en lista över delarna. Den liknar metoden :meth:`~str."
"split` för strängar men är mycket mer generell när det gäller de avgränsare "
"som du kan dela upp med; sträng :meth:`!split` stöder bara uppdelning med "
"blanksteg eller med en fast sträng.  Som du kan förvänta dig finns det också "
"en funktion på modulnivå :func:`re.split`."

msgid ""
"Split *string* by the matches of the regular expression.  If capturing "
"parentheses are used in the RE, then their contents will also be returned as "
"part of the resulting list.  If *maxsplit* is nonzero, at most *maxsplit* "
"splits are performed."
msgstr ""
"Dela upp *sträng* efter matchningarna i det reguljära uttrycket.  Om "
"fångande parenteser används i RE, kommer deras innehåll också att returneras "
"som en del av den resulterande listan.  Om *maxsplit* är ett annat värde än "
"noll utförs högst *maxsplit* uppdelningar."

msgid ""
"You can limit the number of splits made, by passing a value for *maxsplit*. "
"When *maxsplit* is nonzero, at most *maxsplit* splits will be made, and the "
"remainder of the string is returned as the final element of the list.  In "
"the following example, the delimiter is any sequence of non-alphanumeric "
"characters. ::"
msgstr ""
"Du kan begränsa antalet uppdelningar som görs genom att ange ett värde för "
"*maxsplit*. När *maxsplit* inte är noll görs högst *maxsplit* uppdelningar "
"och resten av strängen returneras som det sista elementet i listan.  I "
"följande exempel är avgränsaren en valfri sekvens av icke-alfanumeriska "
"tecken. ::"

msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('This is a test, short and sweet, of split().')\n"
"['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']\n"
">>> p.split('This is a test, short and sweet, of split().', 3)\n"
"['This', 'is', 'a', 'test, short and sweet, of split().']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p.split('Detta är ett test, kort och gott, av split().')\n"
"['Detta', 'är', 'ett', 'test', 'kort', 'och', 'sött', 'av', 'split', '']\n"
">>> p.split('Detta är ett test, kort och gott, av split().', 3)\n"
"['Detta', 'är', 'ett', 'test, kort och gott, av split().']"

msgid ""
"Sometimes you're not only interested in what the text between delimiters is, "
"but also need to know what the delimiter was.  If capturing parentheses are "
"used in the RE, then their values are also returned as part of the list.  "
"Compare the following calls::"
msgstr ""
"Ibland är man inte bara intresserad av vad texten mellan avgränsarna är, "
"utan behöver också veta vad avgränsaren var.  Om fångande parenteser används "
"i RE returneras även deras värden som en del av listan.  Jämför följande "
"anrop::"

msgid ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('This... is a test.')\n"
"['This', 'is', 'a', 'test', '']\n"
">>> p2.split('This... is a test.')\n"
"['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']"
msgstr ""
">>> p = re.compile(r'\\W+')\n"
">>> p2 = re.compile(r'(\\W+)')\n"
">>> p.split('Det här... är ett test.')\n"
"['Detta', 'är', 'ett', 'test', '']\n"
">>> p2.split('Det här... är ett test.')\n"
"['Detta', '...', 'är', ' ', 'a', ' ', 'test', '.', '']"

msgid ""
"The module-level function :func:`re.split` adds the RE to be used as the "
"first argument, but is otherwise the same.   ::"
msgstr ""
"Funktionen på modulnivå :func:`re.split` lägger till den RE som ska användas "
"som första argument, men är i övrigt densamma. ::"

msgid ""
">>> re.split(r'[\\W]+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'([\\W]+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'[\\W]+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']"
msgstr ""
">>> re.split(r'[\\W]+', 'Ord, ord, ord.')\n"
"['Ord', 'ord', 'ord', 'ord', '']\n"
">>> re.split(r'([\\W]+)', 'Ord, ord, ord.')\n"
"['Ord', ', ', 'ord', ', ', 'ord', '.', ''] >>> re.split(r'([\\W]+)', 'Ord, "
"ord, ord')\n"
">>> re.split(r'[\\W]+', 'Ord, ord, ord.', 1)\n"
"['Ord', 'ord, ord.']"

msgid "Search and Replace"
msgstr "Sök och ersätt"

msgid ""
"Another common task is to find all the matches for a pattern, and replace "
"them with a different string.  The :meth:`~re.Pattern.sub` method takes a "
"replacement value, which can be either a string or a function, and the "
"string to be processed."
msgstr ""
"En annan vanlig uppgift är att hitta alla matchningar för ett mönster och "
"ersätta dem med en annan sträng.  Metoden :meth:`~re.Pattern.sub` tar ett "
"ersättningsvärde, som kan vara antingen en sträng eller en funktion, och den "
"sträng som ska bearbetas."

msgid ""
"Returns the string obtained by replacing the leftmost non-overlapping "
"occurrences of the RE in *string* by the replacement *replacement*.  If the "
"pattern isn't found, *string* is returned unchanged."
msgstr ""
"Returnerar strängen som erhålls genom att ersätta de längst till vänster "
"liggande icke-överlappande förekomsterna av RE i *sträng* med ersättningen "
"*replacement*.  Om mönstret inte hittas returneras *sträng* oförändrad."

msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  The default value "
"of 0 means to replace all occurrences."
msgstr ""
"Det valfria argumentet *count* är det maximala antalet mönsterförekomster "
"som ska ersättas; *count* måste vara ett icke-negativt heltal.  "
"Standardvärdet 0 innebär att alla förekomster ersätts."

msgid ""
"Here's a simple example of using the :meth:`~re.Pattern.sub` method.  It "
"replaces colour names with the word ``colour``::"
msgstr ""
"Här är ett enkelt exempel på användning av metoden :meth:`~re.Pattern.sub`.  "
"Den ersätter färgnamn med ordet ``colour``::"

msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.sub('colour', 'blue socks and red shoes')\n"
"'colour socks and colour shoes'\n"
">>> p.sub('colour', 'blue socks and red shoes', count=1)\n"
"'colour socks and red shoes'"
msgstr ""
">>> p = re.compile('(blå|vit|röd)')\n"
">>> p.sub('färg', 'blå strumpor och röda skor')\n"
"'färgade strumpor och färgade skor'\n"
">>> p.sub('färg', 'blå strumpor och röda skor', count=1)\n"
"\"färgade strumpor och röda skor"

msgid ""
"The :meth:`~re.Pattern.subn` method does the same work, but returns a 2-"
"tuple containing the new string value and the number of replacements  that "
"were performed::"
msgstr ""
"Metoden :meth:`~re.Pattern.subn` gör samma sak, men returnerar en 2-tupel "
"som innehåller det nya strängvärdet och antalet ersättningar som utfördes::"

msgid ""
">>> p = re.compile('(blue|white|red)')\n"
">>> p.subn('colour', 'blue socks and red shoes')\n"
"('colour socks and colour shoes', 2)\n"
">>> p.subn('colour', 'no colours at all')\n"
"('no colours at all', 0)"
msgstr ""
">>> p = re.compile('(blå|vit|röd)')\n"
">>> p.subn('färg', 'blå strumpor och röda skor')\n"
"('färgade strumpor och färgade skor', 2)\n"
">>> p.subn('färg', 'inga färger alls')\n"
"('inga färger alls', 0)"

msgid ""
"Empty matches are replaced only when they're not adjacent to a previous "
"empty match. ::"
msgstr ""
"Tomma tändstickor ersätts endast om de inte ligger intill en tidigare tom "
"tändsticka:"

msgid ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"
msgstr ""
">>> p = re.compile('x*')\n"
">>> p.sub('-', 'abxd')\n"
"'-a-b--d-'"

msgid ""
"If *replacement* is a string, any backslash escapes in it are processed.  "
"That is, ``\\n`` is converted to a single newline character, ``\\r`` is "
"converted to a carriage return, and so forth. Unknown escapes such as "
"``\\&`` are left alone. Backreferences, such as ``\\6``, are replaced with "
"the substring matched by the corresponding group in the RE.  This lets you "
"incorporate portions of the original text in the resulting replacement "
"string."
msgstr ""
"Om *replacement* är en sträng behandlas alla backslash-escapes i den.  Det "
"innebär att ``\\n`` konverteras till ett enda tecken för ny rad, ``\\r`` "
"konverteras till en vagnsretur och så vidare. Okända escape-tecken som ``&`` "
"lämnas därhän. Bakreferenser, t.ex. ``6``, ersätts med den delsträng som "
"matchas av motsvarande grupp i RE.  Detta gör att du kan införliva delar av "
"originaltexten i den resulterande ersättningssträngen."

msgid ""
"This example matches the word ``section`` followed by a string enclosed in "
"``{``, ``}``, and changes ``section`` to ``subsection``::"
msgstr ""
"Detta exempel matchar ordet ``section`` följt av en sträng innesluten i "
"``{``, ``}`` och ändrar ``section`` till ``subsection``::"

msgid ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First} section{second}')\n"
"'subsection{First} subsection{second}'"
msgstr ""
">>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'underavsnitt{\\1}','avsnitt{First} avsnitt{second}')\n"
"'underavsnitt{First} underavsnitt{second}'"

msgid ""
"There's also a syntax for referring to named groups as defined by the ``(?"
"P<name>...)`` syntax.  ``\\g<name>`` will use the substring matched by the "
"group named ``name``, and  ``\\g<number>``  uses the corresponding group "
"number. ``\\g<2>`` is therefore equivalent to ``\\2``,  but isn't ambiguous "
"in a replacement string such as ``\\g<2>0``.  (``\\20`` would be interpreted "
"as a reference to group 20, not a reference to group 2 followed by the "
"literal character ``'0'``.)  The following substitutions are all equivalent, "
"but use all three variations of the replacement string. ::"
msgstr ""
"Det finns också en syntax för att hänvisa till namngivna grupper som "
"definieras av syntaxen ``(?P<name>...)``.  ``\\g<name>`` kommer att använda "
"den delsträng som matchas av gruppen med namnet ``namn``, och ``g<number>`` "
"använder motsvarande gruppnummer. ``\\g<2>`` är därför likvärdigt med ``2``, "
"men är inte tvetydigt i en ersättningssträng som ``\\g<2>0``.  (``20`` "
"skulle tolkas som en referens till grupp 20, inte som en referens till grupp "
"2 följt av det bokstavliga tecknet ``'0``)  Följande ersättningar är alla "
"likvärdiga, men använd alla tre varianterna av ersättningssträngen:"

msgid ""
">>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
">>> p.sub(r'subsection{\\1}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<1>}','section{First}')\n"
"'subsection{First}'\n"
">>> p.sub(r'subsection{\\g<name>}','section{First}')\n"
"'subsection{First}'"
msgstr ""
"&gt;&gt;&gt; p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)\n"
"&gt;&gt;&gt; p.sub(r'underavsnitt{\\1}','avsnitt{First}')\n"
"'underavdelning{First}'\n"
"&gt;&gt;&gt; p.sub(r'underavdelning{\\g<1>}','avsnitt{First}')\n"
"'underavdelning{First}'\n"
"&gt;&gt;&gt; p.sub(r'underavdelning{\\g<name>}','avsnitt{First}')\n"
"\"underavdelning{First}"

msgid ""
"*replacement* can also be a function, which gives you even more control.  If "
"*replacement* is a function, the function is called for every non-"
"overlapping occurrence of *pattern*.  On each call, the function is passed "
"a :ref:`match object <match-objects>` argument for the match and can use "
"this information to compute the desired replacement string and return it."
msgstr ""
"*replacement* kan också vara en funktion, vilket ger dig ännu mer kontroll.  "
"Om *replacement* är en funktion anropas funktionen för varje icke-"
"överlappande förekomst av *pattern*.  Vid varje anrop får funktionen ett :"
"ref:`match-objekt <match-objects>`-argument för matchningen och kan använda "
"denna information för att beräkna den önskade ersättningssträngen och "
"returnera den."

msgid ""
"In the following example, the replacement function translates decimals into "
"hexadecimal::"
msgstr ""
"I följande exempel översätter ersättningsfunktionen decimaler till "
"hexadecimal::"

msgid ""
">>> def hexrepl(match):\n"
"...     \"Return the hex string for a decimal number\"\n"
"...     value = int(match.group())\n"
"...     return hex(value)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')\n"
"'Call 0xffd2 for printing, 0xc000 for user code.'"
msgstr ""
">>> def hexrepl(match):\n"
"...     \"Returnera hex-strängen för ett decimaltal\"\n"
"... värde = int(match.group())\n"
"... returnera hex(värde)\n"
"...\n"
">>> p = re.compile(r'\\d+')\n"
">>> p.sub(hexrepl, 'Anropa 65490 för utskrift, 49152 för användarkod.')\n"
"'Anropa 0xffd2 för utskrift, 0xc000 för användarkod.'"

msgid ""
"When using the module-level :func:`re.sub` function, the pattern is passed "
"as the first argument.  The pattern may be provided as an object or as a "
"string; if you need to specify regular expression flags, you must either use "
"a pattern object as the first parameter, or use embedded modifiers in the "
"pattern string, e.g. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""
"När funktionen :func:`re.sub` används på modulnivå skickas mönstret som det "
"första argumentet.  Mönstret kan anges som ett objekt eller som en sträng; "
"om du behöver ange flaggor för reguljära uttryck måste du antingen använda "
"ett mönsterobjekt som första parameter eller använda inbäddade modifierare i "
"mönstersträngen, t.ex. ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")``` returnerar "
"``'x x'``."

msgid "Common Problems"
msgstr "Vanliga problem"

msgid ""
"Regular expressions are a powerful tool for some applications, but in some "
"ways their behaviour isn't intuitive and at times they don't behave the way "
"you may expect them to.  This section will point out some of the most common "
"pitfalls."
msgstr ""
"Reguljära uttryck är ett kraftfullt verktyg för vissa tillämpningar, men på "
"vissa sätt är deras beteende inte intuitivt och ibland beter de sig inte på "
"det sätt som du kanske förväntar dig att de ska göra.  I det här avsnittet "
"pekar vi på några av de vanligaste fallgroparna."

msgid "Use String Methods"
msgstr "Använda strängmetoder"

msgid ""
"Sometimes using the :mod:`re` module is a mistake.  If you're matching a "
"fixed string, or a single character class, and you're not using any :mod:"
"`re` features such as the :const:`~re.IGNORECASE` flag, then the full power "
"of regular expressions may not be required. Strings have several methods for "
"performing operations with fixed strings and they're usually much faster, "
"because the implementation is a single small C loop that's been optimized "
"for the purpose, instead of the large, more generalized regular expression "
"engine."
msgstr ""
"Ibland är det ett misstag att använda modulen :mod:`re`.  Om du matchar en "
"fast sträng, eller en klass med ett enda tecken, och inte använder några :"
"mod:`re`-funktioner som t.ex. flaggan :const:`~re.IGNORECASE`, kanske du "
"inte behöver använda reguljära uttryck fullt ut. Strings har flera metoder "
"för att utföra operationer med fasta strängar och de är vanligtvis mycket "
"snabbare, eftersom implementeringen är en enda liten C-loop som har "
"optimerats för ändamålet, istället för den stora, mer generaliserade "
"reguljära uttrycksmotorn."

msgid ""
"One example might be replacing a single fixed string with another one; for "
"example, you might replace ``word`` with ``deed``.  :func:`re.sub` seems "
"like the function to use for this, but consider the :meth:`~str.replace` "
"method.  Note that :meth:`!replace` will also replace ``word`` inside words, "
"turning ``swordfish`` into ``sdeedfish``, but the  naive RE ``word`` would "
"have done that, too.  (To avoid performing the substitution on parts of "
"words, the pattern would have to be ``\\bword\\b``, in order to require that "
"``word`` have a word boundary on either side.  This takes the job beyond  :"
"meth:`!replace`'s abilities.)"
msgstr ""
"Ett exempel kan vara att ersätta en enda fast sträng med en annan; till "
"exempel kan du ersätta ``word`` med ``deed``. :func:`re.sub` verkar vara den "
"funktion som ska användas för detta, men överväg :meth:`~str.replace`-"
"metoden.  Observera att :meth:`!replace` också kommer att ersätta ``word`` "
"inuti ord, vilket gör ``wordfish`` till ``deedfish``, men den naiva RE "
"``word`` skulle ha gjort det också.  (För att undvika att utföra "
"substitutionen på delar av ord, skulle mönstret behöva vara ``bword\\b``, "
"för att kräva att ``word`` har en ordgräns på vardera sidan.  Detta tar "
"jobbet bortom :meth:`!replace` förmågor)"

msgid ""
"Another common task is deleting every occurrence of a single character from "
"a string or replacing it with another single character.  You might do this "
"with something like ``re.sub('\\n', ' ', S)``, but :meth:`~str.translate` is "
"capable of doing both tasks and will be faster than any regular expression "
"operation can be."
msgstr ""
"En annan vanlig uppgift är att ta bort varje förekomst av ett enda tecken "
"från en sträng eller ersätta det med ett annat enda tecken.  Du kan göra "
"detta med något som ``re.sub('\\n', ' ', S)``, men :meth:`~str.translate` "
"kan göra båda uppgifterna och kommer att vara snabbare än någon operation "
"med reguljära uttryck kan vara."

msgid ""
"In short, before turning to the :mod:`re` module, consider whether your "
"problem can be solved with a faster and simpler string method."
msgstr ""
"Kort sagt, innan du vänder dig till :mod:`re`-modulen bör du överväga om "
"ditt problem kan lösas med en snabbare och enklare strängmetod."

msgid "match() versus search()"
msgstr "match() kontra search()"

msgid ""
"The :func:`~re.match` function only checks if the RE matches at the "
"beginning of the string while :func:`~re.search` will scan forward through "
"the string for a match. It's important to keep this distinction in mind.  "
"Remember,  :func:`!match` will only report a successful match which will "
"start at 0; if the match wouldn't start at zero,  :func:`!match` will *not* "
"report it. ::"
msgstr ""
"Funktionen :func:`~re.match` kontrollerar bara om RE matchar i början av "
"strängen medan :func:`~re.search` söker framåt genom strängen efter en "
"matchning. Det är viktigt att hålla denna distinktion i minnet.  Kom ihåg "
"att :func:`!match` endast kommer att rapportera en lyckad matchning som "
"börjar på 0; om matchningen inte skulle börja på noll kommer :func:`!match` "
"*inte* att rapportera den. ::"

msgid ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'insuperable'))\n"
"None"
msgstr ""
">>> print(re.match('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.match('super', 'oövervinnelig'))\n"
"Ingen"

msgid ""
"On the other hand, :func:`~re.search` will scan forward through the string, "
"reporting the first match it finds. ::"
msgstr ""
"Å andra sidan kommer :func:`~re.search` att skanna framåt genom strängen och "
"rapportera den första matchningen den hittar. ::"

msgid ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'insuperable').span())\n"
"(2, 7)"
msgstr ""
">>> print(re.search('super', 'superstition').span())\n"
"(0, 5)\n"
">>> print(re.search('super', 'oövervinnelig').span())\n"
"(2, 7)"

msgid ""
"Sometimes you'll be tempted to keep using :func:`re.match`, and just add ``."
"*`` to the front of your RE.  Resist this temptation and use :func:`re."
"search` instead.  The regular expression compiler does some analysis of REs "
"in order to speed up the process of looking for a match.  One such analysis "
"figures out what the first character of a match must be; for example, a "
"pattern starting with ``Crow`` must match starting with a ``'C'``.  The "
"analysis lets the engine quickly scan through the string looking for the "
"starting character, only trying the full match if a ``'C'`` is found."
msgstr ""
"Ibland frestas du att fortsätta använda :func:`re.match`, och bara lägga "
"till ``.*`` framför din RE.  Motstå denna frestelse och använd :func:`re."
"search` istället.  Kompilatorn för reguljära uttryck gör en del analyser av "
"RE:er för att snabba upp processen med att leta efter en matchning.  En "
"sådan analys räknar ut vad det första tecknet i en matchning måste vara; "
"till exempel måste ett mönster som börjar med ``Crow`` matcha som börjar med "
"en ``'C'``.  Analysen gör att sökmotorn snabbt kan skanna igenom strängen "
"och leta efter starttecknet, och bara försöka få en fullständig matchning om "
"ett ``'C`` hittas."

msgid ""
"Adding ``.*`` defeats this optimization, requiring scanning to the end of "
"the string and then backtracking to find a match for the rest of the RE.  "
"Use :func:`re.search` instead."
msgstr ""
"Att lägga till ``.*`` motverkar denna optimering och kräver att man skannar "
"till slutet av strängen och sedan går tillbaka för att hitta en matchning "
"för resten av RE.  Använd :func:`re.search` istället."

msgid "Greedy versus Non-Greedy"
msgstr "Girig kontra icke-girig"

msgid ""
"When repeating a regular expression, as in ``a*``, the resulting action is "
"to consume as much of the pattern as possible.  This fact often bites you "
"when you're trying to match a pair of balanced delimiters, such as the angle "
"brackets surrounding an HTML tag.  The naive pattern for matching a single "
"HTML tag doesn't work because of the greedy nature of ``.*``. ::"
msgstr ""
"När man upprepar ett reguljärt uttryck, som i ``a*``, blir resultatet att så "
"mycket som möjligt av mönstret konsumeras.  Detta faktum slår ofta fel när "
"man försöker matcha ett par balanserade avgränsare, t.ex. de "
"vinkelparenteser som omger en HTML-tagg.  Det naiva mönstret för att matcha "
"en enda HTML-tagg fungerar inte på grund av den giriga karaktären hos ``."
"*``. ::"

msgid ""
">>> s = '<html><head><title>Title</title>'\n"
">>> len(s)\n"
"32\n"
">>> print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
">>> print(re.match('<.*>', s).group())\n"
"<html><head><title>Title</title>"
msgstr ""
"&gt;&gt;&gt; s = '<html><head><title>Titel</title>'\n"
"&gt;&gt;&gt; len(s)\n"
"32\n"
"&gt;&gt;&gt; print(re.match('<.*>', s).span())\n"
"(0, 32)\n"
"&gt;&gt;&gt; print(re.match('<.*>', s).group())\n"
"<html><head><title>Titel</title>"

msgid ""
"The RE matches the ``'<'`` in ``'<html>'``, and the ``.*`` consumes the rest "
"of the string.  There's still more left in the RE, though, and the ``>`` "
"can't match at the end of the string, so the regular expression engine has "
"to backtrack character by character until it finds a match for the ``>``.   "
"The final match extends from the ``'<'`` in ``'<html>'`` to the ``'>'`` in "
"``'</title>'``, which isn't what you want."
msgstr ""
"RE matchar ``'&lt;'`` i ``'<html>'``, och ``.*`` förbrukar resten av "
"strängen.  Det finns dock fortfarande mer kvar i RE, och ``&gt;`` kan inte "
"matcha i slutet av strängen, så motorn för reguljära uttryck måste backa "
"tecken för tecken tills den hittar en matchning för ``&gt;``.   Den slutliga "
"matchningen sträcker sig från ``'&lt;'`` i ``'<html>'`` till ``'&gt;'`` i "
"``'</title>'``, vilket inte är vad du vill."

msgid ""
"In this case, the solution is to use the non-greedy quantifiers ``*?``, ``+?"
"``, ``??``, or ``{m,n}?``, which match as *little* text as possible.  In the "
"above example, the ``'>'`` is tried immediately after the first ``'<'`` "
"matches, and when it fails, the engine advances a character at a time, "
"retrying the ``'>'`` at every step.  This produces just the right result::"
msgstr ""
"I det här fallet är lösningen att använda de icke-greedy kvantifierarna ``*?"
"``, ``+?``, ``??`` eller ``{m,n}?``, som matchar så *lite* text som "
"möjligt.  I exemplet ovan prövas ``'>'`` omedelbart efter den första ``'<'``-"
"matchningen, och när den misslyckas avancerar sökmotorn ett tecken i taget "
"och försöker ``'>'`` på nytt i varje steg.  Detta ger precis rätt resultat::"

msgid ""
">>> print(re.match('<.*?>', s).group())\n"
"<html>"
msgstr ""
"&gt;&gt;&gt; print(re.match('<.*?>', s).group())\n"
"<html>"

msgid ""
"(Note that parsing HTML or XML with regular expressions is painful. Quick-"
"and-dirty patterns will handle common cases, but HTML and XML have special "
"cases that will break the obvious regular expression; by the time you've "
"written a regular expression that handles all of the possible cases, the "
"patterns will be *very* complicated.  Use an HTML or XML parser module for "
"such tasks.)"
msgstr ""
"(Observera att parsning av HTML eller XML med reguljära uttryck är "
"smärtsamt. Snabba och enkla mönster hanterar vanliga fall, men HTML och XML "
"har specialfall som bryter mot det uppenbara reguljära uttrycket; när du väl "
"har skrivit ett reguljärt uttryck som hanterar alla möjliga fall kommer "
"mönstren att vara *mycket* komplicerade.  Använd en HTML- eller XML-"
"parsermodul för sådana uppgifter)"

msgid "Using re.VERBOSE"
msgstr "Använda re.VERBOSE"

msgid ""
"By now you've probably noticed that regular expressions are a very compact "
"notation, but they're not terribly readable.  REs of moderate complexity can "
"become lengthy collections of backslashes, parentheses, and metacharacters, "
"making them difficult to read and understand."
msgstr ""
"Vid det här laget har du förmodligen märkt att reguljära uttryck är en "
"mycket kompakt notation, men de är inte särskilt läsbara.  RE med måttlig "
"komplexitet kan bli långa samlingar av bindestreck, parenteser och "
"metatecken, vilket gör dem svåra att läsa och förstå."

msgid ""
"For such REs, specifying the :const:`re.VERBOSE` flag when compiling the "
"regular expression can be helpful, because it allows you to format the "
"regular expression more clearly."
msgstr ""
"För sådana RE:s kan det vara till hjälp att ange flaggan :const:`re.VERBOSE` "
"vid kompilering av det reguljära uttrycket, eftersom det gör att du kan "
"formatera det reguljära uttrycket tydligare."

msgid ""
"The ``re.VERBOSE`` flag has several effects.  Whitespace in the regular "
"expression that *isn't* inside a character class is ignored.  This means "
"that an expression such as ``dog | cat`` is equivalent to the less readable "
"``dog|cat``, but ``[a b]`` will still match the characters ``'a'``, ``'b'``, "
"or a space.  In addition, you can also put comments inside a RE; comments "
"extend from a ``#`` character to the next newline.  When used with triple-"
"quoted strings, this enables REs to be formatted more neatly::"
msgstr ""
"Flaggan ``re.VERBOSE`` har flera effekter.  Whitespace i det reguljära "
"uttrycket som *inte* är inom en teckenklass ignoreras.  Detta innebär att "
"ett uttryck som ``hund | katt`` motsvarar det mindre läsbara ``hund|katt``, "
"men ``[a b]`` kommer fortfarande att matcha tecknen ``'a'``, ``'b'`` eller "
"ett mellanslag.  Dessutom kan du lägga in kommentarer inuti en RE; "
"kommentarer sträcker sig från ett ``#``-tecken till nästa nya rad.  När "
"detta används med strängar med trippelcitat kan RE:er formateras på ett "
"snyggare sätt::"

msgid ""
"pat = re.compile(r\"\"\"\n"
" \\s*                 # Skip leading whitespace\n"
" (?P<header>[^:]+)   # Header name\n"
" \\s* :               # Whitespace, and a colon\n"
" (?P<value>.*?)      # The header's value -- *? used to\n"
"                     # lose the following trailing whitespace\n"
" \\s*$                # Trailing whitespace to end-of-line\n"
"\"\"\", re.VERBOSE)"
msgstr ""
"pat = re.compile(r\"\"\"\n"
" \\s* # Hoppa över ledande blanksteg\n"
" (?P<header>[^:]+) # Huvudnamn\n"
" \\s* :               # Blanksteg, och ett kolon\n"
" (?P<value>.*?) # Huvudets värde -- *? används för att\n"
"                     # förlora följande efterföljande blanksteg\n"
" \\s*$ # Efterföljande blanksteg till slutet av raden\n"
"\"\"\", re.VERBOSE)"

msgid "This is far more readable than::"
msgstr "Detta är mycket mer läsbart än::"

msgid "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"
msgstr "pat = re.compile(r\"\\s*(?P<header>[^:]+)\\s*:(?P<value>.*?)\\s*$\")"

msgid "Feedback"
msgstr "Feedback"

msgid ""
"Regular expressions are a complicated topic.  Did this document help you "
"understand them?  Were there parts that were unclear, or Problems you "
"encountered that weren't covered here?  If so, please send suggestions for "
"improvements to the author."
msgstr ""
"Reguljära uttryck är ett komplicerat ämne.  Hjälpte det här dokumentet dig "
"att förstå dem?  Fanns det delar som var oklara, eller problem som du stötte "
"på som inte täcktes här?  Om så är fallet, skicka gärna förslag på "
"förbättringar till författaren."

msgid ""
"The most complete book on regular expressions is almost certainly Jeffrey "
"Friedl's Mastering Regular Expressions, published by O'Reilly.  "
"Unfortunately, it exclusively concentrates on Perl and Java's flavours of "
"regular expressions, and doesn't contain any Python material at all, so it "
"won't be useful as a reference for programming in Python.  (The first "
"edition covered Python's now-removed :mod:`!regex` module, which won't help "
"you much.)  Consider checking it out from your library."
msgstr ""
"Den mest kompletta boken om reguljära uttryck är nästan säkert Jeffrey "
"Friedls Mastering Regular Expressions, utgiven av O'Reilly.  Tyvärr "
"koncentrerar den sig uteslutande på Perl och Javas smaker av reguljära "
"uttryck och innehåller inte något Python-material alls, så det kommer inte "
"att vara användbart som referens för programmering i Python.  (Den första "
"utgåvan täckte Pythons nu borttagna :mod:`!regex`-modul, vilket inte kommer "
"att hjälpa dig mycket.)  Överväg att kolla in det från ditt bibliotek."
