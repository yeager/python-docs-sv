# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!statistics` --- Mathematical statistics functions"
msgstr ":mod:`!statistics` --- Matematiska statistikfunktioner"

msgid "**Source code:** :source:`Lib/statistics.py`"
msgstr "**Källkod:** :source:`Lib/statistics.py`"

msgid ""
"This module provides functions for calculating mathematical statistics of "
"numeric (:class:`~numbers.Real`-valued) data."
msgstr ""
"Denna modul innehåller funktioner för att beräkna matematisk statistik för "
"numeriska (:class:`~numbers.Real`-värderade) data."

msgid ""
"The module is not intended to be a competitor to third-party libraries such "
"as `NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_, or "
"proprietary full-featured statistics packages aimed at professional "
"statisticians such as Minitab, SAS and Matlab. It is aimed at the level of "
"graphing and scientific calculators."
msgstr ""
"Modulen är inte avsedd att vara en konkurrent till tredjepartsbibliotek som "
"`NumPy <https://numpy.org>`_, `SciPy <https://scipy.org/>`_, eller "
"egenutvecklade statistikpaket med fullständiga funktioner som riktar sig "
"till professionella statistiker som Minitab, SAS och Matlab. Programmet är "
"anpassat för grafräknare och vetenskapliga räknare."

msgid ""
"Unless explicitly noted, these functions support :class:`int`, :class:"
"`float`, :class:`~decimal.Decimal` and :class:`~fractions.Fraction`. "
"Behaviour with other types (whether in the numeric tower or not) is "
"currently unsupported.  Collections with a mix of types are also undefined "
"and implementation-dependent.  If your input data consists of mixed types, "
"you may be able to use :func:`map` to ensure a consistent result, for "
"example: ``map(float, input_data)``."
msgstr ""
"Om inte annat uttryckligen anges, stöder dessa funktioner :class:`int`, :"
"class:`float`, :class:`~decimal.Decimal` och :class:`~fractions.Fraction`. "
"Beteende med andra typer (oavsett om de finns i det numeriska tornet eller "
"inte) stöds för närvarande inte.  Samlingar med en blandning av typer är "
"också odefinierade och beroende av implementering.  Om dina indata består av "
"blandade typer kan du kanske använda :func:`map` för att säkerställa ett "
"konsekvent resultat, till exempel: ``map(float, input_data)``."

msgid ""
"Some datasets use ``NaN`` (not a number) values to represent missing data. "
"Since NaNs have unusual comparison semantics, they cause surprising or "
"undefined behaviors in the statistics functions that sort data or that count "
"occurrences.  The functions affected are ``median()``, ``median_low()``, "
"``median_high()``, ``median_grouped()``, ``mode()``, ``multimode()``, and "
"``quantiles()``.  The ``NaN`` values should be stripped before calling these "
"functions::"
msgstr ""
"I vissa dataset används NaN-värden (not a number) för att representera "
"saknade data. Eftersom NaN-värden har en ovanlig jämförelsesemantik orsakar "
"de överraskande eller odefinierade beteenden i statistikfunktioner som "
"sorterar data eller räknar förekomster.  De funktioner som påverkas är "
"``median()``, ``median_low()``, ``median_high()``, ``median_grouped()``, "
"``mode()``, ``multimode()`` och ``quantiles()``.  ``NaN``-värdena bör tas "
"bort innan du anropar dessa funktioner::"

msgid ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'),19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # This has surprising behavior\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # This result is unexpected\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # Number of missing values\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # Strip NaN values\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # Sorting now works as expected\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # This result is now well defined\n"
"18.75"
msgstr ""
">>> from statistics import median\n"
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
"\n"
">>> data = [20.7, float('NaN'),19.2, 18.3, float('NaN'), 14.4]\n"
">>> sorted(data)  # This has surprising behavior\n"
"[20.7, nan, 14.4, 18.3, 19.2, nan]\n"
">>> median(data)  # This result is unexpected\n"
"16.35\n"
"\n"
">>> sum(map(isnan, data))    # Number of missing values\n"
"2\n"
">>> clean = list(filterfalse(isnan, data))  # Strip NaN values\n"
">>> clean\n"
"[20.7, 19.2, 18.3, 14.4]\n"
">>> sorted(clean)  # Sorting now works as expected\n"
"[14.4, 18.3, 19.2, 20.7]\n"
">>> median(clean)       # This result is now well defined\n"
"18.75"

msgid "Averages and measures of central location"
msgstr "Medelvärden och mått på centralt läge"

msgid ""
"These functions calculate an average or typical value from a population or "
"sample."
msgstr ""
"Dessa funktioner beräknar ett genomsnittligt eller typiskt värde från en "
"population eller ett urval."

msgid ":func:`mean`"
msgstr ":func:`medelvärde`"

msgid "Arithmetic mean (\"average\") of data."
msgstr "Aritmetiskt medelvärde (\"average\") av data."

msgid ":func:`fmean`"
msgstr ":func:`fmean`"

msgid "Fast, floating-point arithmetic mean, with optional weighting."
msgstr "Snabbt aritmetiskt medelvärde med flyttal, med valfri viktning."

msgid ":func:`geometric_mean`"
msgstr ":func:`geometriskt_medelvärde`"

msgid "Geometric mean of data."
msgstr "Geometriskt medelvärde av data."

msgid ":func:`harmonic_mean`"
msgstr ":func:`harmoniskt_medelvärde`"

msgid "Harmonic mean of data."
msgstr "Harmoniskt medelvärde av data."

msgid ":func:`kde`"
msgstr ":func:`kde`"

msgid "Estimate the probability density distribution of the data."
msgstr "Uppskatta sannolikhetstäthetsfördelningen för data."

msgid ":func:`kde_random`"
msgstr ":func:`kde_random`"

msgid "Random sampling from the PDF generated by kde()."
msgstr "Slumpmässigt urval från den PDF som genereras av kde()."

msgid ":func:`median`"
msgstr ":func:`median`"

msgid "Median (middle value) of data."
msgstr "Median (medelvärde) av data."

msgid ":func:`median_low`"
msgstr ":func:`median_låg`"

msgid "Low median of data."
msgstr "Låg median av data."

msgid ":func:`median_high`"
msgstr ":func:`median_high`"

msgid "High median of data."
msgstr "Hög median av data."

msgid ":func:`median_grouped`"
msgstr ":func:`median_grupperad`"

msgid "Median (50th percentile) of grouped data."
msgstr "Median (50:e percentilen) för grupperade data."

msgid ":func:`mode`"
msgstr ":func:`mode`"

msgid "Single mode (most common value) of discrete or nominal data."
msgstr "Single mode (vanligaste värdet) av diskreta eller nominella data."

msgid ":func:`multimode`"
msgstr ":func:`multimode`"

msgid "List of modes (most common values) of discrete or nominal data."
msgstr ""
"Lista över lägen (de vanligaste värdena) för diskreta eller nominella data."

msgid ":func:`quantiles`"
msgstr ":func:`kvantiler`"

msgid "Divide data into intervals with equal probability."
msgstr "Dela in data i intervall med lika stor sannolikhet."

msgid "Measures of spread"
msgstr "Mått på spridning"

msgid ""
"These functions calculate a measure of how much the population or sample "
"tends to deviate from the typical or average values."
msgstr ""
"Dessa funktioner beräknar ett mått på hur mycket populationen eller urvalet "
"tenderar att avvika från de typiska eller genomsnittliga värdena."

msgid ":func:`pstdev`"
msgstr ":func:`pstdev`"

msgid "Population standard deviation of data."
msgstr "Standardavvikelse för data i populationen."

msgid ":func:`pvariance`"
msgstr ":func:`pvariance`"

msgid "Population variance of data."
msgstr "Populationsvarians för data."

msgid ":func:`stdev`"
msgstr ":func:`stdev`"

msgid "Sample standard deviation of data."
msgstr "Standardavvikelse för data."

msgid ":func:`variance`"
msgstr ":func:`varians`"

msgid "Sample variance of data."
msgstr "Provvarians av data."

msgid "Statistics for relations between two inputs"
msgstr "Statistik för relationer mellan två inmatningar"

msgid ""
"These functions calculate statistics regarding relations between two inputs."
msgstr ""
"Dessa funktioner beräknar statistik avseende relationer mellan två indata."

msgid ":func:`covariance`"
msgstr ":func:`kovarians`"

msgid "Sample covariance for two variables."
msgstr "Provkovarians för två variabler."

msgid ":func:`correlation`"
msgstr ":func:`korrelation`"

msgid "Pearson and Spearman's correlation coefficients."
msgstr "Pearson och Spearmans korrelationskoefficienter."

msgid ":func:`linear_regression`"
msgstr ":func:`lineär_regression`"

msgid "Slope and intercept for simple linear regression."
msgstr "Lutning och intercept för enkel linjär regression."

msgid "Function details"
msgstr "Funktionsdetaljer"

msgid ""
"Note: The functions do not require the data given to them to be sorted. "
"However, for reading convenience, most of the examples show sorted sequences."
msgstr ""
"Observera: Funktionerna kräver inte att de data som ges till dem är "
"sorterade. För att underlätta läsningen visas dock sorterade sekvenser i de "
"flesta exemplen."

msgid ""
"Return the sample arithmetic mean of *data* which can be a sequence or "
"iterable."
msgstr ""
"Returnerar det aritmetiska medelvärdet för *data* som kan vara en sekvens "
"eller iterabel."

msgid ""
"The arithmetic mean is the sum of the data divided by the number of data "
"points.  It is commonly called \"the average\", although it is only one of "
"many different mathematical averages.  It is a measure of the central "
"location of the data."
msgstr ""
"Det aritmetiska medelvärdet är summan av data dividerat med antalet "
"datapunkter.  Det kallas ofta för \"genomsnittet\", även om det bara är ett "
"av många olika matematiska genomsnitt.  Det är ett mått på den centrala "
"placeringen av data."

msgid "If *data* is empty, :exc:`StatisticsError` will be raised."
msgstr "Om *data* är tom, kommer :exc:`StatisticsError` att uppstå."

msgid "Some examples of use:"
msgstr "Några exempel på användning:"

msgid ""
">>> mean([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> mean([-1.0, 2.5, 3.25, 5.75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraction(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\n"
"Decimal('0.5625')"
msgstr ""
">>> medelvärde([1, 2, 3, 4, 4])\n"
"2.8\n"
">>> medelvärde([-1,0, 2,5, 3,25, 5,75])\n"
"2.625\n"
"\n"
">>> from fractions import Fraktion as F\n"
">>> medelvärde([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\n"
"Fraktion(13, 21)\n"
"\n"
">>> from decimal import Decimal as D\n"
">>> mean([D(\"0,5\"), D(\"0,75\"), D(\"0,625\"), D(\"0,375\")])\n"
"Decimal('0,5625')"

msgid ""
"The mean is strongly affected by `outliers <https://en.wikipedia.org/wiki/"
"Outlier>`_ and is not necessarily a typical example of the data points. For "
"a more robust, although less efficient, measure of `central tendency "
"<https://en.wikipedia.org/wiki/Central_tendency>`_, see :func:`median`."
msgstr ""
"Medelvärdet påverkas starkt av \"extremvärden\" <https://en.wikipedia.org/"
"wiki/Outlier>`_ och är inte nödvändigtvis ett typiskt exempel på "
"datapunkterna. För ett mer robust, men mindre effektivt, mått på \"central "
"tendens\" <https://en.wikipedia.org/wiki/Central_tendency>`_, se :func:"
"`median`."

msgid ""
"The sample mean gives an unbiased estimate of the true population mean, so "
"that when taken on average over all the possible samples, ``mean(sample)`` "
"converges on the true mean of the entire population.  If *data* represents "
"the entire population rather than a sample, then ``mean(data)`` is "
"equivalent to calculating the true population mean μ."
msgstr ""
"Medelvärdet för urvalet ger en opartisk uppskattning av det sanna "
"populationsmedelvärdet, så att när det tas som ett genomsnitt över alla "
"möjliga urval, konvergerar ``medelvärde(urval)`` mot det sanna medelvärdet "
"för hela populationen.  Om *data* representerar hela populationen snarare än "
"ett urval, är ``medel(data)`` likvärdigt med att beräkna det sanna "
"populationsmedelvärdet μ."

msgid "Convert *data* to floats and compute the arithmetic mean."
msgstr ""
"Konvertera *data* till flyttal och beräkna det aritmetiska medelvärdet."

msgid ""
"This runs faster than the :func:`mean` function and it always returns a :"
"class:`float`.  The *data* may be a sequence or iterable.  If the input "
"dataset is empty, raises a :exc:`StatisticsError`."
msgstr ""
"Detta går snabbare än funktionen :func:`mean` och returnerar alltid en :"
"class:`float`.  *Data* kan vara en sekvens eller iterabel.  Om "
"indatauppsättningen är tom, returneras ett :exc:`StatisticsError`."

msgid ""
">>> fmean([3.5, 4.0, 5.25])\n"
"4.25"
msgstr ""
">>> fmean([3,5, 4,0, 5,25])\n"
"4.25"

msgid ""
"Optional weighting is supported.  For example, a professor assigns a grade "
"for a course by weighting quizzes at 20%, homework at 20%, a midterm exam at "
"30%, and a final exam at 30%:"
msgstr ""
"Valfri viktning stöds.  En professor kan till exempel sätta betyg på en kurs "
"genom att vikta frågesporter med 20 %, hemuppgifter med 20 %, en "
"halvtidstentamen med 30 % och en sluttentamen med 30 %:"

msgid ""
">>> grades = [85, 92, 83, 91]\n"
">>> weights = [0.20, 0.20, 0.30, 0.30]\n"
">>> fmean(grades, weights)\n"
"87.6"
msgstr ""
">>> betyg = [85, 92, 83, 91]\n"
">>> vikter = [0,20, 0,20, 0,30, 0,30]\n"
">>> fmean(betyg, vikter)\n"
"87.6"

msgid ""
"If *weights* is supplied, it must be the same length as the *data* or a :exc:"
"`ValueError` will be raised."
msgstr ""
"Om *weights* anges måste den vara lika lång som *data*, annars uppstår ett :"
"exc:`ValueError`."

msgid "Added support for *weights*."
msgstr "Lagt till stöd för *vikter*."

msgid "Convert *data* to floats and compute the geometric mean."
msgstr ""
"Konvertera *data* till flyttal och beräkna det geometriska medelvärdet."

msgid ""
"The geometric mean indicates the central tendency or typical value of the "
"*data* using the product of the values (as opposed to the arithmetic mean "
"which uses their sum)."
msgstr ""
"Det geometriska medelvärdet anger den centrala tendensen eller det typiska "
"värdet för *data* genom att använda produkten av värdena (i motsats till det "
"aritmetiska medelvärdet som använder summan av värdena)."

msgid ""
"Raises a :exc:`StatisticsError` if the input dataset is empty, if it "
"contains a zero, or if it contains a negative value. The *data* may be a "
"sequence or iterable."
msgstr ""
"Utlöser ett :exc:`StatisticsError` om indatadatasetet är tomt, om det "
"innehåller en nolla eller om det innehåller ett negativt värde. *Data* kan "
"vara en sekvens eller iterabel."

msgid ""
"No special efforts are made to achieve exact results. (However, this may "
"change in the future.)"
msgstr ""
"Inga särskilda ansträngningar görs för att uppnå exakta resultat. (Detta kan "
"dock komma att ändras i framtiden.)"

msgid ""
">>> round(geometric_mean([54, 24, 36]), 1)\n"
"36.0"
msgstr ""
">>> runda(geometriskt_medelvärde([54, 24, 36]), 1)\n"
"36.0"

msgid ""
"Return the harmonic mean of *data*, a sequence or iterable of real-valued "
"numbers.  If *weights* is omitted or ``None``, then equal weighting is "
"assumed."
msgstr ""
"Returnerar det harmoniska medelvärdet av *data*, en sekvens eller iterabel "
"av realvärdesberäknade tal.  Om *weights* utelämnas eller ``None``, antas "
"lika viktning."

msgid ""
"The harmonic mean is the reciprocal of the arithmetic :func:`mean` of the "
"reciprocals of the data. For example, the harmonic mean of three values *a*, "
"*b* and *c* will be equivalent to ``3/(1/a + 1/b + 1/c)``.  If one of the "
"values is zero, the result will be zero."
msgstr ""
"Det harmoniska medelvärdet är reciprokvärdet av det aritmetiska :func:"
"`medelvärdet` av de reciproka värdena i data. Till exempel kommer det "
"harmoniska medelvärdet av tre värden *a*, *b* och *c* att motsvara ``3/(1/a "
"+ 1/b + 1/c)``.  Om ett av värdena är noll blir resultatet noll."

msgid ""
"The harmonic mean is a type of average, a measure of the central location of "
"the data.  It is often appropriate when averaging ratios or rates, for "
"example speeds."
msgstr ""
"Det harmoniska medelvärdet är en typ av medelvärde, ett mått på den centrala "
"platsen för data.  Det är ofta lämpligt vid medelvärdesberäkning av "
"förhållanden eller hastigheter, t.ex. hastigheter."

msgid ""
"Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. "
"What is the average speed?"
msgstr ""
"Antag att en bil färdas 10 km i 40 km/tim och sedan ytterligare 10 km i 60 "
"km/tim. Vad är medelhastigheten?"

msgid ""
">>> harmonic_mean([40, 60])\n"
"48.0"
msgstr ""
">>> harmonisk_medelvärde([40, 60])\n"
"48.0"

msgid ""
"Suppose a car travels 40 km/hr for 5 km, and when traffic clears, speeds-up "
"to 60 km/hr for the remaining 30 km of the journey. What is the average "
"speed?"
msgstr ""
"Antag att en bil kör 40 km/tim i 5 km och när trafiken släpper ökar "
"hastigheten till 60 km/tim under de återstående 30 km av färden. Vad är den "
"genomsnittliga hastigheten?"

msgid ""
">>> harmonic_mean([40, 60], weights=[5, 30])\n"
"56.0"
msgstr ""
">>> harmonisk_medelvärde([40, 60], vikter=[5, 30])\n"
"56.0"

msgid ""
":exc:`StatisticsError` is raised if *data* is empty, any element is less "
"than zero, or if the weighted sum isn't positive."
msgstr ""
":exc:`StatisticsError` uppstår om *data* är tomt, om något element är mindre "
"än noll eller om den viktade summan inte är positiv."

msgid ""
"The current algorithm has an early-out when it encounters a zero in the "
"input.  This means that the subsequent inputs are not tested for validity.  "
"(This behavior may change in the future.)"
msgstr ""
"Den nuvarande algoritmen har en tidig utgång när den stöter på en nolla i "
"indata.  Detta innebär att de efterföljande inmatningarna inte testas för "
"giltighet.  (Detta beteende kan komma att ändras i framtiden)"

msgid ""
"`Kernel Density Estimation (KDE) <https://www.itm-conferences.org/articles/"
"itmconf/pdf/2018/08/itmconf_sam2018_00037.pdf>`_: Create a continuous "
"probability density function or cumulative distribution function from "
"discrete samples."
msgstr ""
"kDE (Kernel Density Estimation) <https://www.itm-conferences.org/articles/"
"itmconf/pdf/2018/08/itmconf_sam2018_00037.pdf>`_: Skapa en kontinuerlig "
"sannolikhetstäthetsfunktion eller kumulativ fördelningsfunktion från "
"diskreta prov."

msgid ""
"The basic idea is to smooth the data using `a kernel function <https://en."
"wikipedia.org/wiki/Kernel_(statistics)>`_. to help draw inferences about a "
"population from a sample."
msgstr ""
"Grundtanken är att jämna ut data med hjälp av en kärnfunktion <https://en."
"wikipedia.org/wiki/Kernel_(statistik)>`_. för att hjälpa till att dra "
"slutsatser om en population från ett urval."

msgid ""
"The degree of smoothing is controlled by the scaling parameter *h* which is "
"called the bandwidth.  Smaller values emphasize local features while larger "
"values give smoother results."
msgstr ""
"Graden av utjämning styrs av skalningsparametern *h*, som kallas bandbredd.  "
"Mindre värden framhäver lokala särdrag medan större värden ger ett jämnare "
"resultat."

msgid ""
"The *kernel* determines the relative weights of the sample data points.  "
"Generally, the choice of kernel shape does not matter as much as the more "
"influential bandwidth smoothing parameter."
msgstr ""
"*Kärnan* bestämmer de relativa vikterna för datapunkterna i urvalet.  I "
"allmänhet har valet av kärnform inte lika stor betydelse som den mer "
"inflytelserika parametern för utjämning av bandbredd."

msgid ""
"Kernels that give some weight to every sample point include *normal* "
"(*gauss*), *logistic*, and *sigmoid*."
msgstr ""
"Kärnor som ger viss vikt åt varje provpunkt inkluderar *normal* (*gauss*), "
"*logistisk* och *sigmoid*."

msgid ""
"Kernels that only give weight to sample points within the bandwidth include "
"*rectangular* (*uniform*), *triangular*, *parabolic* (*epanechnikov*), "
"*quartic* (*biweight*), *triweight*, and *cosine*."
msgstr ""
"Kärnor som bara ger vikt åt provpunkter inom bandbredden inkluderar "
"*rektangulär* (*uniform*), *triangulär*, *parabolisk* (*epanechnikov*), "
"*kvadratisk* (*bivikt*), *trivikt* och *cosinus*."

msgid ""
"If *cumulative* is true, will return a cumulative distribution function."
msgstr "Om *cumulative* är true, returneras en kumulativ fördelningsfunktion."

msgid ""
"A :exc:`StatisticsError` will be raised if the *data* sequence is empty."
msgstr ""
"Ett :exc:`StatisticsError` kommer att uppstå om *data*-sekvensen är tom."

msgid ""
"`Wikipedia has an example <https://en.wikipedia.org/wiki/"
"Kernel_density_estimation#Example>`_ where we can use :func:`kde` to "
"generate and plot a probability density function estimated from a small "
"sample:"
msgstr ""
"wikipedia har ett exempel <https://en.wikipedia.org/wiki/"
"Kernel_density_estimation#Example>`_ där vi kan använda :func:`kde` för att "
"generera och plotta en sannolikhetstäthetsfunktion som uppskattats från ett "
"litet urval:"

msgid ""
">>> sample = [-2.1, -1.3, -0.4, 1.9, 5.1, 6.2]\n"
">>> f_hat = kde(sample, h=1.5)\n"
">>> xarr = [i/100 for i in range(-750, 1100)]\n"
">>> yarr = [f_hat(x) for x in xarr]"
msgstr ""
">>> prov = [-2,1, -1,3, -0,4, 1,9, 5,1, 6,2]\n"
">>> f_hat = kde(prov, h=1,5)\n"
">>> xarr = [i/100 för i i intervallet(-750, 1100)]\n"
">>> yarr = [f_hat(x) för x i xarr]"

msgid "The points in ``xarr`` and ``yarr`` can be used to make a PDF plot:"
msgstr ""
"Punkterna i ``xarr`` och ``yarr`` kan användas för att göra en PDF-plott:"

msgid "Scatter plot of the estimated probability density function."
msgstr "Spridningsdiagram över den uppskattade sannolikhetstäthetsfunktionen."

msgid ""
"Return a function that makes a random selection from the estimated "
"probability density function produced by ``kde(data, h, kernel)``."
msgstr ""
"Returnerar en funktion som gör ett slumpmässigt urval från den skattade "
"sannolikhetstäthetsfunktionen som produceras av ``kde(data, h, kernel)``."

msgid ""
"Providing a *seed* allows reproducible selections. In the future, the values "
"may change slightly as more accurate kernel inverse CDF estimates are "
"implemented.  The seed may be an integer, float, str, or bytes."
msgstr ""
"Genom att tillhandahålla ett *frö* möjliggörs reproducerbara urval. I "
"framtiden kan värdena ändras något i takt med att mer exakta inversa CDF-"
"estimat för kärnor implementeras.  Seed kan vara ett heltal, float, str "
"eller bytes."

msgid ""
"Continuing the example for :func:`kde`, we can use :func:`kde_random` to "
"generate new random selections from an estimated probability density "
"function:"
msgstr ""
"Om vi fortsätter med exemplet för :func:`kde` kan vi använda :func:"
"`kde_random` för att generera nya slumpmässiga val från en uppskattad "
"sannolikhetstäthetsfunktion:"

msgid ""
"Return the median (middle value) of numeric data, using the common \"mean of "
"middle two\" method.  If *data* is empty, :exc:`StatisticsError` is raised. "
"*data* can be a sequence or iterable."
msgstr ""
"Returnerar medianen (mittvärdet) för numeriska data med hjälp av den vanliga "
"metoden \"medelvärdet av de två mittersta\".  Om *data* är tomt kommer :exc:"
"`StatisticsError` att returneras. *data* kan vara en sekvens eller en "
"iterabel."

msgid ""
"The median is a robust measure of central location and is less affected by "
"the presence of outliers.  When the number of data points is odd, the middle "
"data point is returned:"
msgstr ""
"Medianen är ett robust mått på central placering och påverkas mindre av "
"förekomsten av avvikande värden.  När antalet datapunkter är udda returneras "
"den mittersta datapunkten:"

msgid ""
">>> median([1, 3, 5])\n"
"3"
msgstr ""
">>> median([1, 3, 5])\n"
"3"

msgid ""
"When the number of data points is even, the median is interpolated by taking "
"the average of the two middle values:"
msgstr ""
"När antalet datapunkter är jämnt interpoleras medianen genom att ta "
"medelvärdet av de två mellersta värdena:"

msgid ""
">>> median([1, 3, 5, 7])\n"
"4.0"
msgstr ""
">>> median([1, 3, 5, 7])\n"
"4.0"

msgid ""
"This is suited for when your data is discrete, and you don't mind that the "
"median may not be an actual data point."
msgstr ""
"Detta är lämpligt när dina data är diskreta och du inte bryr dig om att "
"medianen kanske inte är en faktisk datapunkt."

msgid ""
"If the data is ordinal (supports order operations) but not numeric (doesn't "
"support addition), consider using :func:`median_low` or :func:`median_high` "
"instead."
msgstr ""
"Om data är ordinala (stöder orderoperationer) men inte numeriska (stöder "
"inte addition) kan du överväga att använda :func:`median_low` eller :func:"
"`median_high` i stället."

msgid ""
"Return the low median of numeric data.  If *data* is empty, :exc:"
"`StatisticsError` is raised.  *data* can be a sequence or iterable."
msgstr ""
"Returnerar den låga medianen för numeriska data.  Om *data* är tomt kommer :"
"exc:`StatisticsError` att returneras.  *data* kan vara en sekvens eller en "
"iterabel."

msgid ""
"The low median is always a member of the data set.  When the number of data "
"points is odd, the middle value is returned.  When it is even, the smaller "
"of the two middle values is returned."
msgstr ""
"Den låga medianen ingår alltid i datauppsättningen.  När antalet datapunkter "
"är udda returneras det mittersta värdet.  Om det är jämnt returneras det "
"minsta av de två mittvärdena."

msgid ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_low([1, 3, 5, 7])\n"
"3"
msgstr ""
">>> median_low([1, 3, 5])\n"
"3\n"
">>> median_låg([1, 3, 5, 7])\n"
"3"

msgid ""
"Use the low median when your data are discrete and you prefer the median to "
"be an actual data point rather than interpolated."
msgstr ""
"Använd den låga medianen när dina data är diskreta och du föredrar att "
"medianen är en faktisk datapunkt snarare än interpolerad."

msgid ""
"Return the high median of data.  If *data* is empty, :exc:`StatisticsError` "
"is raised.  *data* can be a sequence or iterable."
msgstr ""
"Returnerar den höga medianen för data.  Om *data* är tomt, :exc:"
"`StatisticsError` tas upp.  *data* kan vara en sekvens eller en iterabel."

msgid ""
"The high median is always a member of the data set.  When the number of data "
"points is odd, the middle value is returned.  When it is even, the larger of "
"the two middle values is returned."
msgstr ""
"Den höga medianen ingår alltid i datauppsättningen.  När antalet datapunkter "
"är udda returneras det mittersta värdet.  Om det är jämnt returneras det "
"största av de två mittvärdena."

msgid ""
">>> median_high([1, 3, 5])\n"
"3\n"
">>> median_high([1, 3, 5, 7])\n"
"5"
msgstr ""
">>> median_höjd([1, 3, 5])\n"
"3\n"
">>> median_höjd([1, 3, 5, 7])\n"
"5"

msgid ""
"Use the high median when your data are discrete and you prefer the median to "
"be an actual data point rather than interpolated."
msgstr ""
"Använd den höga medianen när dina data är diskreta och du föredrar att "
"medianen är en faktisk datapunkt snarare än interpolerad."

msgid ""
"Estimates the median for numeric data that has been `grouped or binned "
"<https://en.wikipedia.org/wiki/Data_binning>`_ around the midpoints of "
"consecutive, fixed-width intervals."
msgstr ""
"Beräknar medianen för numeriska data som har \"grupperats\" eller "
"\"binnats\" <https://en.wikipedia.org/wiki/Data_binning>`_ runt "
"mittpunkterna i på varandra följande intervall med fast bredd."

msgid ""
"The *data* can be any iterable of numeric data with each value being exactly "
"the midpoint of a bin.  At least one value must be present."
msgstr ""
"*Data* kan vara vilken iterabel som helst av numeriska data där varje värde "
"är exakt mittpunkten i en bin.  Åtminstone ett värde måste finnas."

msgid "The *interval* is the width of each bin."
msgstr "*Intervall* är bredden på varje bin."

msgid ""
"For example, demographic information may have been summarized into "
"consecutive ten-year age groups with each group being represented by the 5-"
"year midpoints of the intervals:"
msgstr ""
"Demografisk information kan t.ex. ha sammanfattats i på varandra följande "
"tioåriga åldersgrupper där varje grupp representeras av intervallens 5-åriga "
"mittpunkter:"

msgid ""
">>> from collections import Counter\n"
">>> demographics = Counter({\n"
"...    25: 172,   # 20 to 30 years old\n"
"...    35: 484,   # 30 to 40 years old\n"
"...    45: 387,   # 40 to 50 years old\n"
"...    55:  22,   # 50 to 60 years old\n"
"...    65:   6,   # 60 to 70 years old\n"
"... })\n"
"..."
msgstr ""
">>> from collections import Räknare\n"
">>> demographics = Räknare({\n"
"...    25: 172, # 20 till 30 år gammal\n"
"...    35: 484, # 30 till 40 år gammal\n"
"...    45: 387, # 40 till 50 år gammal\n"
"...    55: 22, # 50 till 60 år gammal\n"
"...    65: 6, # 60 till 70 år gammal\n"
"... })\n"
"..."

msgid ""
"The 50th percentile (median) is the 536th person out of the 1071 member "
"cohort.  That person is in the 30 to 40 year old age group."
msgstr ""
"Den 50:e percentilen (medianen) är den 536:e personen av de 1071 medlemmarna "
"i kohorten.  Den personen är i åldersgruppen 30 till 40 år."

msgid ""
"The regular :func:`median` function would assume that everyone in the "
"tricenarian age group was exactly 35 years old.  A more tenable assumption "
"is that the 484 members of that age group are evenly distributed between 30 "
"and 40.  For that, we use :func:`median_grouped`:"
msgstr ""
"Den vanliga funktionen :func:`median` skulle anta att alla i åldersgruppen "
"tricenarianer var exakt 35 år gamla.  Ett mer hållbart antagande är att de "
"484 medlemmarna i den åldersgruppen är jämnt fördelade mellan 30 och 40.  "
"För det använder vi :func:`median_grouped`:"

msgid ""
">>> data = list(demographics.elements())\n"
">>> median(data)\n"
"35\n"
">>> round(median_grouped(data, interval=10), 1)\n"
"37.5"
msgstr ""
">>> data = lista(demografi.element())\n"
">>> median(data)\n"
"35\n"
">>> runda(median_grupperad(data, intervall=10), 1)\n"
"37.5"

msgid ""
"The caller is responsible for making sure the data points are separated by "
"exact multiples of *interval*.  This is essential for getting a correct "
"result.  The function does not check this precondition."
msgstr ""
"Anroparen ansvarar för att datapunkterna är åtskilda med exakta multiplar av "
"*intervall*.  Detta är viktigt för att få ett korrekt resultat.  Funktionen "
"kontrollerar inte detta förhandsvillkor."

msgid ""
"Inputs may be any numeric type that can be coerced to a float during the "
"interpolation step."
msgstr ""
"Ingångarna kan vara av vilken numerisk typ som helst som kan omvandlas till "
"en float under interpoleringssteget."

msgid ""
"Return the single most common data point from discrete or nominal *data*. "
"The mode (when it exists) is the most typical value and serves as a measure "
"of central location."
msgstr ""
"Returnerar den enskilt vanligaste datapunkten från diskreta eller nominella "
"*data*. Läget (när det finns) är det mest typiska värdet och fungerar som "
"ett mått på central placering."

msgid ""
"If there are multiple modes with the same frequency, returns the first one "
"encountered in the *data*.  If the smallest or largest of those is desired "
"instead, use ``min(multimode(data))`` or ``max(multimode(data))``. If the "
"input *data* is empty, :exc:`StatisticsError` is raised."
msgstr ""
"Om det finns flera lägen med samma frekvens returneras det första som "
"påträffas i *data*.  Om den minsta eller största av dessa önskas istället, "
"använd ``min(multimode(data))`` eller ``max(multimode(data))``. Om indata "
"*data* är tomt, kommer :exc:`StatisticsError` att visas."

msgid ""
"``mode`` assumes discrete data and returns a single value. This is the "
"standard treatment of the mode as commonly taught in schools:"
msgstr ""
"``mode`` förutsätter diskreta data och returnerar ett enda värde. Detta är "
"standardbehandlingen av mode som vanligtvis lärs ut i skolorna:"

msgid ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n"
"3"
msgstr ""
">>> mode([1, 1, 2, 3, 3, 3, 3, 3, 4])\n"
"3"

msgid ""
"The mode is unique in that it is the only statistic in this package that "
"also applies to nominal (non-numeric) data:"
msgstr ""
"Mode är unikt eftersom det är den enda statistiken i det här paketet som "
"även gäller för nominella (icke-numeriska) data:"

msgid ""
">>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", "
"\"red\"])\n"
"'red'"
msgstr ""
">>> mode([\"röd\", \"blå\", \"blå\", \"röd\", \"grön\", \"röd\", \"röd\"])\n"
"\"röd"

msgid ""
"Only hashable inputs are supported.  To handle type :class:`set`, consider "
"casting to :class:`frozenset`.  To handle type :class:`list`, consider "
"casting to :class:`tuple`.  For mixed or nested inputs, consider using this "
"slower quadratic algorithm that only depends on equality tests: ``max(data, "
"key=data.count)``."
msgstr ""
"Endast hashbara indata stöds.  För att hantera typen :class:`set`, överväg "
"att casta till :class:`frozenset`.  För att hantera typen :class:`list`, "
"överväg att casta till :class:`tuple`.  För blandade eller nästlade indata "
"kan du överväga att använda den här långsammare kvadratiska algoritmen som "
"bara beror på likhetstester: ``max(data, key=data.count)``."

msgid ""
"Now handles multimodal datasets by returning the first mode encountered. "
"Formerly, it raised :exc:`StatisticsError` when more than one mode was found."
msgstr ""
"Hanterar nu multimodala dataset genom att returnera det första läget som "
"påträffas. Tidigare gav den :exc:`StatisticsError` när mer än ett läge "
"hittades."

msgid ""
"Return a list of the most frequently occurring values in the order they were "
"first encountered in the *data*.  Will return more than one result if there "
"are multiple modes or an empty list if the *data* is empty:"
msgstr ""
"Returnerar en lista med de mest frekvent förekommande värdena i den ordning "
"de först påträffades i *data*.  Returnerar mer än ett resultat om det finns "
"flera lägen eller en tom lista om *data* är tom:"

msgid ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"
msgstr ""
">>> multimode('aabbbbccddddeeffffgg')\n"
"['b', 'd', 'f']\n"
">>> multimode('')\n"
"[]"

msgid ""
"Return the population standard deviation (the square root of the population "
"variance).  See :func:`pvariance` for arguments and other details."
msgstr ""
"Returnerar populationens standardavvikelse (kvadratroten av populationens "
"varians).  Se :func:`pvariance` för argument och andra detaljer."

msgid ""
">>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"0.986893273527251"
msgstr ""
">>> pstdev([1,5, 2,5, 2,5, 2,75, 3,25, 4,75])\n"
"0.986893273527251"

msgid ""
"Return the population variance of *data*, a non-empty sequence or iterable "
"of real-valued numbers.  Variance, or second moment about the mean, is a "
"measure of the variability (spread or dispersion) of data.  A large variance "
"indicates that the data is spread out; a small variance indicates it is "
"clustered closely around the mean."
msgstr ""
"Returnerar populationsvariansen för *data*, en icke-tom sekvens eller "
"iterabel av realvärdesberäknade tal.  Varians, eller andra momentet kring "
"medelvärdet, är ett mått på variabiliteten (spridningen) i data.  En stor "
"varians indikerar att data är utspridda; en liten varians indikerar att de "
"är grupperade tätt runt medelvärdet."

msgid ""
"If the optional second argument *mu* is given, it should be the *population* "
"mean of the *data*.  It can also be used to compute the second moment around "
"a point that is not the mean.  If it is missing or ``None`` (the default), "
"the arithmetic mean is automatically calculated."
msgstr ""
"Om det valfria andra argumentet *mu* anges bör det vara *populationens* "
"medelvärde för *data*.  Det kan också användas för att beräkna det andra "
"momentet runt en punkt som inte är medelvärdet.  Om det saknas eller är "
"``None`` (standard) beräknas det aritmetiska medelvärdet automatiskt."

msgid ""
"Use this function to calculate the variance from the entire population.  To "
"estimate the variance from a sample, the :func:`variance` function is "
"usually a better choice."
msgstr ""
"Använd denna funktion för att beräkna variansen från hela populationen.  För "
"att uppskatta variansen från ett urval är funktionen :func:`variance` "
"vanligtvis ett bättre val."

msgid "Raises :exc:`StatisticsError` if *data* is empty."
msgstr "Utlöser :exc:`StatisticsError` om *data* är tomt."

msgid "Examples:"
msgstr "Exempel:"

msgid ""
">>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n"
">>> pvariance(data)\n"
"1.25"
msgstr ""
">>> data = [0,0, 0,25, 0,25, 1,25, 1,5, 1,75, 2,75, 3,25]\n"
">>> pvariance(data)\n"
"1.25"

msgid ""
"If you have already calculated the mean of your data, you can pass it as the "
"optional second argument *mu* to avoid recalculation:"
msgstr ""
"Om du redan har beräknat medelvärdet för dina data kan du skicka det som det "
"valfria andra argumentet *mu* för att undvika omberäkning:"

msgid ""
">>> mu = mean(data)\n"
">>> pvariance(data, mu)\n"
"1.25"
msgstr ""
">>> mu = medelvärde(data)\n"
">>> pvariance(data, mu)\n"
"1.25"

msgid "Decimals and Fractions are supported:"
msgstr "Decimaler och bråk stöds:"

msgid ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('24.815')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraction(13, 72)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> pvariance([D(\"27,5\"), D(\"30,25\"), D(\"30,25\"), D(\"34,5\"), "
"D(\"41,75\")])\n"
"Decimal('24,815')\n"
"\n"
">>> from fractions import Fraktion as F\n"
">>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\n"
"Fraktion(13, 72)"

msgid ""
"When called with the entire population, this gives the population variance "
"σ².  When called on a sample instead, this is the biased sample variance s², "
"also known as variance with N degrees of freedom."
msgstr ""
"När detta kallas med hela populationen ger det populationsvariansen σ².  När "
"det i stället gäller ett urval är detta den partiska urvalsvariansen s², "
"även känd som varians med N frihetsgrader."

msgid ""
"If you somehow know the true population mean μ, you may use this function to "
"calculate the variance of a sample, giving the known population mean as the "
"second argument.  Provided the data points are a random sample of the "
"population, the result will be an unbiased estimate of the population "
"variance."
msgstr ""
"Om du på något sätt känner till det sanna populationsmedelvärdet μ, kan du "
"använda denna funktion för att beräkna variansen för ett urval, med det "
"kända populationsmedelvärdet som andra argument.  Förutsatt att "
"datapunkterna är ett slumpmässigt urval av populationen blir resultatet en "
"väntevärdesriktig skattning av populationsvariansen."

msgid ""
"Return the sample standard deviation (the square root of the sample "
"variance).  See :func:`variance` for arguments and other details."
msgstr ""
"Returnerar standardavvikelsen för urvalet (kvadratroten av variansen för "
"urvalet).  Se :func:`variance` för argument och andra detaljer."

msgid ""
">>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n"
"1.0810874155219827"
msgstr ""
">>> stdev([1,5, 2,5, 2,5, 2,75, 3,25, 4,75])\n"
"1.0810874155219827"

msgid ""
"Return the sample variance of *data*, an iterable of at least two real-"
"valued numbers.  Variance, or second moment about the mean, is a measure of "
"the variability (spread or dispersion) of data.  A large variance indicates "
"that the data is spread out; a small variance indicates it is clustered "
"closely around the mean."
msgstr ""
"Returnerar urvalsvariansen för *data*, en iterabel med minst två "
"realvärdestal.  Varians, eller andra momentet kring medelvärdet, är ett mått "
"på variabiliteten (spridningen) i data.  En stor varians indikerar att data "
"är utspridda, medan en liten varians indikerar att de är grupperade tätt "
"kring medelvärdet."

msgid ""
"If the optional second argument *xbar* is given, it should be the *sample* "
"mean of *data*.  If it is missing or ``None`` (the default), the mean is "
"automatically calculated."
msgstr ""
"Om det valfria andra argumentet *xbar* anges bör det vara medelvärdet för "
"*data* för *provet*.  Om det saknas eller är ``None`` (standard) beräknas "
"medelvärdet automatiskt."

msgid ""
"Use this function when your data is a sample from a population. To calculate "
"the variance from the entire population, see :func:`pvariance`."
msgstr ""
"Använd den här funktionen när dina data är ett urval från en population. För "
"att beräkna variansen från hela populationen, se :func:`pvariance`."

msgid "Raises :exc:`StatisticsError` if *data* has fewer than two values."
msgstr "Utlöser :exc:`StatisticsError` om *data* har färre än två värden."

msgid ""
">>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n"
">>> variance(data)\n"
"1.3720238095238095"
msgstr ""
">>> data = [2,75, 1,75, 1,25, 0,25, 0,5, 1,25, 3,5]\n"
">>> varians(data)\n"
"1.3720238095238095"

msgid ""
"If you have already calculated the sample mean of your data, you can pass it "
"as the optional second argument *xbar* to avoid recalculation:"
msgstr ""
"Om du redan har beräknat urvalsmedelvärdet för dina data kan du skicka det "
"som det valfria andra argumentet *xbar* för att undvika omräkning:"

msgid ""
">>> m = mean(data)\n"
">>> variance(data, m)\n"
"1.3720238095238095"
msgstr ""
">>> m = medelvärde(data)\n"
">>> varians(data, m)\n"
"1.3720238095238095"

msgid ""
"This function does not attempt to verify that you have passed the actual "
"mean as *xbar*.  Using arbitrary values for *xbar* can lead to invalid or "
"impossible results."
msgstr ""
"Denna funktion försöker inte verifiera att du har angett det faktiska "
"medelvärdet som *xbar*.  Om du använder godtyckliga värden för *xbar* kan "
"det leda till ogiltiga eller omöjliga resultat."

msgid "Decimal and Fraction values are supported:"
msgstr "Decimal- och fraktionsvärden stöds:"

msgid ""
">>> from decimal import Decimal as D\n"
">>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), "
"D(\"41.75\")])\n"
"Decimal('31.01875')\n"
"\n"
">>> from fractions import Fraction as F\n"
">>> variance([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraction(67, 108)"
msgstr ""
">>> from decimal import Decimal as D\n"
">>> varians([D(\"27,5\"), D(\"30,25\"), D(\"30,25\"), D(\"34,5\"), "
"D(\"41,75\")])\n"
"Decimal('31,01875')\n"
"\n"
">>> from fractions import Fraktion as F\n"
">>> varians([F(1, 6), F(1, 2), F(5, 3)])\n"
"Fraktion(67, 108)"

msgid ""
"This is the sample variance s² with Bessel's correction, also known as "
"variance with N-1 degrees of freedom.  Provided that the data points are "
"representative (e.g. independent and identically distributed), the result "
"should be an unbiased estimate of the true population variance."
msgstr ""
"Detta är urvalsvariansen s² med Bessels korrigering, även känd som varians "
"med N-1 frihetsgrader.  Förutsatt att datapunkterna är representativa (t.ex. "
"oberoende och identiskt fördelade) bör resultatet vara en väntevärdesriktig "
"skattning av den verkliga populationsvariansen."

msgid ""
"If you somehow know the actual population mean μ you should pass it to the :"
"func:`pvariance` function as the *mu* parameter to get the variance of a "
"sample."
msgstr ""
"Om du på något sätt känner till det faktiska populationsmedelvärdet μ bör du "
"skicka det till funktionen :func:`pvariance` som parametern *mu* för att få "
"variansen för ett urval."

msgid ""
"Divide *data* into *n* continuous intervals with equal probability. Returns "
"a list of ``n - 1`` cut points separating the intervals."
msgstr ""
"Dela upp *data* i *n* kontinuerliga intervall med samma sannolikhet. "
"Returnerar en lista med ``n - 1`` skärningspunkter som separerar intervallen."

msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.  Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate "
"*data* into 100 equal sized groups.  Raises :exc:`StatisticsError` if *n* is "
"not least 1."
msgstr ""
"Ställ in *n* på 4 för kvartiler (standard).  Ställ in *n* till 10 för "
"deciler.  Ställ in *n* på 100 för percentiler, vilket ger de 99 snittpunkter "
"som delar in *data* i 100 lika stora grupper.  Utlöser :exc:"
"`StatisticsError` om *n* inte är minst 1."

msgid ""
"The *data* can be any iterable containing sample data.  For meaningful "
"results, the number of data points in *data* should be larger than *n*. "
"Raises :exc:`StatisticsError` if there is not at least one data point."
msgstr ""
"*data* kan vara vilken iterabel som helst som innehåller exempeldata.  För "
"meningsfulla resultat bör antalet datapunkter i *data* vara större än *n*. "
"Utlöser :exc:`StatisticsError` om det inte finns minst en datapunkt."

msgid ""
"The cut points are linearly interpolated from the two nearest data points.  "
"For example, if a cut point falls one-third of the distance between two "
"sample values, ``100`` and ``112``, the cut-point will evaluate to ``104``."
msgstr ""
"Skärningspunkterna interpoleras linjärt från de två närmaste datapunkterna.  "
"Om en skärningspunkt t.ex. ligger en tredjedel av avståndet mellan två "
"provvärden, \"100\" och \"112\", kommer skärningspunkten att utvärderas till "
"\"104\"."

msgid ""
"The *method* for computing quantiles can be varied depending on whether the "
"*data* includes or excludes the lowest and highest possible values from the "
"population."
msgstr ""
"*Metoden* för att beräkna kvantiler kan varieras beroende på om *data* "
"inkluderar eller exkluderar de lägsta och högsta möjliga värdena från "
"populationen."

msgid ""
"The default *method* is \"exclusive\" and is used for data sampled from a "
"population that can have more extreme values than found in the samples.  The "
"portion of the population falling below the *i-th* of *m* sorted data points "
"is computed as ``i / (m + 1)``.  Given nine sample values, the method sorts "
"them and assigns the following percentiles: 10%, 20%, 30%, 40%, 50%, 60%, "
"70%, 80%, 90%."
msgstr ""
"Standardmetoden *method* är \"exclusive\" och används för data som samlats "
"in från en population som kan ha mer extrema värden än vad som finns i "
"urvalet.  Den del av populationen som faller under *i-th* av *m* sorterade "
"datapunkter beräknas som ``i / (m + 1)``.  Med nio urvalsvärden sorterar "
"metoden dem och tilldelar följande percentiler: 10%, 20%, 30%, 40%, 50%, "
"60%, 70%, 80%, 90%."

msgid ""
"Setting the *method* to \"inclusive\" is used for describing population data "
"or for samples that are known to include the most extreme values from the "
"population.  The minimum value in *data* is treated as the 0th percentile "
"and the maximum value is treated as the 100th percentile. The portion of the "
"population falling below the *i-th* of *m* sorted data points is computed as "
"``(i - 1) / (m - 1)``.  Given 11 sample values, the method sorts them and "
"assigns the following percentiles: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, "
"80%, 90%, 100%."
msgstr ""
"Om *method* är inställd på \"inclusive\" används den för att beskriva "
"populationsdata eller för stickprov som man vet innehåller de mest extrema "
"värdena från populationen.  Minimivärdet i *data* behandlas som den 0:e "
"percentilen och maximivärdet behandlas som den 100:e percentilen. Den del av "
"populationen som faller under *i-th* av *m* sorterade datapunkter beräknas "
"som ``(i - 1) / (m - 1)``.  Givet 11 provvärden sorterar metoden dem och "
"tilldelar följande percentiler: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, "
"90%, 100%."

msgid ""
"# Decile cut points for empirically sampled data\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"
msgstr ""
"# Decile cut points för empiriskt insamlade data\n"
">>> data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,\n"
"...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,\n"
"...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,\n"
"...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,\n"
"...         103, 107, 101, 81, 109, 104]\n"
">>> [round(q, 1) for q in quantiles(data, n=10)]\n"
"[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]"

msgid ""
"No longer raises an exception for an input with only a single data point. "
"This allows quantile estimates to be built up one sample point at a time "
"becoming gradually more refined with each new data point."
msgstr ""
"Det uppstår inte längre något undantag för en indata med endast en enda "
"datapunkt. Detta gör att kvantilskattningar kan byggas upp med en provpunkt "
"i taget och gradvis bli mer förfinade med varje ny datapunkt."

msgid ""
"Return the sample covariance of two inputs *x* and *y*. Covariance is a "
"measure of the joint variability of two inputs."
msgstr ""
"Returnerar sampelkovariansen för två indata *x* och *y*. Kovarians är ett "
"mått på den gemensamma variabiliteten hos två indata."

msgid ""
"Both inputs must be of the same length (no less than two), otherwise :exc:"
"`StatisticsError` is raised."
msgstr ""
"Båda inmatningarna måste vara lika långa (inte mindre än två), annars :exc:"
"`StatisticsError` tas upp."

msgid ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> covariance(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> covariance(x, z)\n"
"-7.5\n"
">>> covariance(z, x)\n"
"-7.5"
msgstr ""
">>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n"
">>> kovarians(x, y)\n"
"0.75\n"
">>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n"
">>> kovarians(x, z)\n"
"-7.5\n"
">>> kovarians(z, x)\n"
"-7.5"

msgid ""
"Return the `Pearson's correlation coefficient <https://en.wikipedia.org/wiki/"
"Pearson_correlation_coefficient>`_ for two inputs. Pearson's correlation "
"coefficient *r* takes values between -1 and +1. It measures the strength and "
"direction of a linear relationship."
msgstr ""
"Returnerar `Pearsons korrelationskoefficient <https://en.wikipedia.org/wiki/"
"Pearson_correlation_coefficient>`_ för två indata. Pearsons "
"korrelationskoefficient *r* tar värden mellan -1 och +1. Den mäter styrkan "
"och riktningen i ett linjärt förhållande."

msgid ""
"If *method* is \"ranked\", computes `Spearman's rank correlation coefficient "
"<https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient>`_ "
"for two inputs. The data is replaced by ranks.  Ties are averaged so that "
"equal values receive the same rank.  The resulting coefficient measures the "
"strength of a monotonic relationship."
msgstr ""
"Om *method* är \"ranked\", beräknas `Spearmans rangkorrelationskoefficient "
"<https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient>`_ "
"för två indata. Data ersätts av rangordningar.  Oavgjorda värden får ett "
"genomsnitt så att lika värden får samma rangordning.  Den resulterande "
"koefficienten mäter styrkan i ett monotont förhållande."

msgid ""
"Spearman's correlation coefficient is appropriate for ordinal data or for "
"continuous data that doesn't meet the linear proportion requirement for "
"Pearson's correlation coefficient."
msgstr ""
"Spearmans korrelationskoefficient är lämplig för ordinaldata eller för "
"kontinuerliga data som inte uppfyller kravet på linjär proportion för "
"Pearsons korrelationskoefficient."

msgid ""
"Both inputs must be of the same length (no less than two), and need not to "
"be constant, otherwise :exc:`StatisticsError` is raised."
msgstr ""
"Båda indata måste vara lika långa (minst två), och behöver inte vara "
"konstanta, annars :exc:`StatisticsError` tas upp."

msgid ""
"Example with `Kepler's laws of planetary motion <https://en.wikipedia.org/"
"wiki/Kepler's_laws_of_planetary_motion>`_:"
msgstr ""
"Exempel med `Kepler's lagar för planetrörelse <https://en.wikipedia.org/wiki/"
"Kepler's_laws_of_planetary_motion>`_:"

msgid ""
">>> # Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and  Neptune\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190]    # "
"days\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # million "
"km\n"
"\n"
">>> # Show that a perfect monotonic relationship exists\n"
">>> correlation(orbital_period, dist_from_sun, method='ranked')\n"
"1.0\n"
"\n"
">>> # Observe that a linear relationship is imperfect\n"
">>> round(correlation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # Demonstrate Kepler's third law: There is a linear correlation\n"
">>> # between the square of the orbital period and the cube of the\n"
">>> # distance from the sun.\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d for d in dist_from_sun]\n"
">>> round(correlation(period_squared, dist_cubed), 4)\n"
"1.0"
msgstr ""
">>> # Merkurius, Venus, jorden, Mars, Jupiter, Saturnus, Uranus och "
"Neptunus\n"
">>> orbital_period = [88, 225, 365, 687, 4331, 10_756, 30_687, 60_190] # "
"dagar\n"
">>> dist_from_sun = [58, 108, 150, 228, 778, 1_400, 2_900, 4_500] # miljoner "
"km\n"
"\n"
">>> # Visa att det finns ett perfekt monotont förhållande\n"
">>> korrelation(orbital_period, dist_from_sun, metod='ranked')\n"
"1.0\n"
"\n"
">>> # Observera att ett linjärt samband är ofullkomligt\n"
">>> round(korrelation(orbital_period, dist_from_sun), 4)\n"
"0.9882\n"
"\n"
">>> # Demonstrera Keplers tredje lag: Det finns en linjär korrelation\n"
">>> # mellan kvadraten av omloppstiden och kuben av avståndet\n"
">>> # avståndet från solen.\n"
">>> period_squared = [p * p for p in orbital_period]\n"
">>> dist_cubed = [d * d * d för d i dist_from_sun]\n"
">>> round(korrelation(period_squared, dist_cubed), 4)\n"
"1.0"

msgid "Added support for Spearman's rank correlation coefficient."
msgstr "Stöd för Spearmans rangkorrelationskoefficient har lagts till."

msgid ""
"Return the slope and intercept of `simple linear regression <https://en."
"wikipedia.org/wiki/Simple_linear_regression>`_ parameters estimated using "
"ordinary least squares. Simple linear regression describes the relationship "
"between an independent variable *x* and a dependent variable *y* in terms of "
"this linear function:"
msgstr ""
"Returnerar lutningen och interceptet för parametrar för enkel linjär "
"regression <https://en.wikipedia.org/wiki/Simple_linear_regression>`_ som "
"uppskattats med hjälp av vanliga minsta kvadratmetoden. Enkel linjär "
"regression beskriver förhållandet mellan en oberoende variabel *x* och en "
"beroende variabel *y* i termer av denna linjära funktion:"

msgid "*y = slope \\* x + intercept + noise*"
msgstr "*y = lutning \\* x + intercept + brus*"

msgid ""
"where ``slope`` and ``intercept`` are the regression parameters that are "
"estimated, and ``noise`` represents the variability of the data that was not "
"explained by the linear regression (it is equal to the difference between "
"predicted and actual values of the dependent variable)."
msgstr ""
"där \"lutning\" och \"intercept\" är de regressionsparametrar som "
"uppskattas, och \"brus\" representerar variationen i data som inte förklaras "
"av den linjära regressionen (det är lika med skillnaden mellan förutsagda "
"och faktiska värden för den beroende variabeln)."

msgid ""
"Both inputs must be of the same length (no less than two), and the "
"independent variable *x* cannot be constant; otherwise a :exc:"
"`StatisticsError` is raised."
msgstr ""
"Båda indata måste vara lika långa (minst två) och den oberoende variabeln "
"*x* får inte vara konstant, annars uppstår ett :exc:`StatisticsError`."

msgid ""
"For example, we can use the `release dates of the Monty Python films "
"<https://en.wikipedia.org/wiki/Monty_Python#Films>`_ to predict the "
"cumulative number of Monty Python films that would have been produced by "
"2019 assuming that they had kept the pace."
msgstr ""
"Vi kan till exempel använda \"premiärdatum för Monty Python-filmerna "
"<https://en.wikipedia.org/wiki/Monty_Python#Films>`_\" för att förutsäga det "
"kumulativa antalet Monty Python-filmer som skulle ha producerats fram till "
"2019, förutsatt att de hade hållit samma takt."

msgid ""
">>> year = [1971, 1975, 1979, 1982, 1983]\n"
">>> films_total = [1, 2, 3, 4, 5]\n"
">>> slope, intercept = linear_regression(year, films_total)\n"
">>> round(slope * 2019 + intercept)\n"
"16"
msgstr ""
">>> år = [1971, 1975, 1979, 1982, 1983]\n"
">>> filmer_total = [1, 2, 3, 4, 5]\n"
">>> lutning, intercept = linjär_regression(år, filmer_total)\n"
">>> runda(lutning * 2019 + intercept)\n"
"16"

msgid ""
"If *proportional* is true, the independent variable *x* and the dependent "
"variable *y* are assumed to be directly proportional. The data is fit to a "
"line passing through the origin. Since the *intercept* will always be 0.0, "
"the underlying linear function simplifies to:"
msgstr ""
"Om *proportional* är sant antas den oberoende variabeln *x* och den beroende "
"variabeln *y* vara direkt proportionella. Data anpassas till en linje som "
"går genom origo. Eftersom *skärningspunkten* alltid kommer att vara 0,0 "
"förenklas den underliggande linjära funktionen till:"

msgid "*y = slope \\* x + noise*"
msgstr "*y = lutning \\* x + brus*"

msgid ""
"Continuing the example from :func:`correlation`, we look to see how well a "
"model based on major planets can predict the orbital distances for dwarf "
"planets:"
msgstr ""
"Vi fortsätter med exemplet från :func:`correlation` och undersöker hur väl "
"en modell som baseras på större planeter kan förutsäga omloppsavståndet för "
"dvärgplaneter:"

msgid ""
">>> model = linear_regression(period_squared, dist_cubed, "
"proportional=True)\n"
">>> slope = model.slope\n"
"\n"
">>> # Dwarf planets:   Pluto,  Eris,    Makemake, Haumea, Ceres\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680]  # days\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) for p in orbital_periods]\n"
">>> list(map(round, predicted_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414]  # actual distance in million km\n"
"[5906, 10152, 6796, 6450, 414]"
msgstr ""
">>> modell = linjär_regression(period_kvadrat, dist_cubed, "
"proportionell=True)\n"
">>> lutning = modell.lutning\n"
"\n"
">>> # Dvärgplaneter:   Pluto, Eris, Makemake, Haumea, Ceres\n"
">>> orbital_periods = [90_560, 204_199, 111_845, 103_410, 1_680] # dagar\n"
">>> predicted_dist = [math.cbrt(slope * (p * p)) för p i orbital_periods]\n"
">>> list(map(runda, predikterad_dist))\n"
"[5912, 10166, 6806, 6459, 414]\n"
"\n"
">>> [5_906, 10_152, 6_796, 6_450, 414] # faktiskt avstånd i miljoner km\n"
"[5906, 10152, 6796, 6450, 414]"

msgid "Added support for *proportional*."
msgstr "Stöd för *proportionell* har lagts till."

msgid "Exceptions"
msgstr "Undantag"

msgid "A single exception is defined:"
msgstr "Ett enda undantag definieras:"

msgid "Subclass of :exc:`ValueError` for statistics-related exceptions."
msgstr "Underklass till :exc:`ValueError` för statistikrelaterade undantag."

msgid ":class:`NormalDist` objects"
msgstr ":class:`NormalDist` objekt"

msgid ""
":class:`NormalDist` is a tool for creating and manipulating normal "
"distributions of a `random variable <http://www.stat.yale.edu/"
"Courses/1997-98/101/ranvar.htm>`_.  It is a class that treats the mean and "
"standard deviation of data measurements as a single entity."
msgstr ""
":class:`NormalDist` är ett verktyg för att skapa och manipulera "
"normalfördelningar av en `slumpmässig variabel <http://www.stat.yale.edu/"
"Courses/1997-98/101/ranvar.htm>`_.  Det är en klass som behandlar "
"medelvärdet och standardavvikelsen för datamätningar som en enda enhet."

msgid ""
"Normal distributions arise from the `Central Limit Theorem <https://en."
"wikipedia.org/wiki/Central_limit_theorem>`_ and have a wide range of "
"applications in statistics."
msgstr ""
"Normalfördelningar härrör från \"Central Limit Theorem\" <https://en."
"wikipedia.org/wiki/Central_limit_theorem>`_ och har ett brett spektrum av "
"tillämpningar inom statistik."

msgid ""
"Returns a new *NormalDist* object where *mu* represents the `arithmetic mean "
"<https://en.wikipedia.org/wiki/Arithmetic_mean>`_ and *sigma* represents the "
"`standard deviation <https://en.wikipedia.org/wiki/Standard_deviation>`_."
msgstr ""
"Returnerar ett nytt *NormalDist*-objekt där *mu* representerar det "
"\"aritmetiska medelvärdet <https://en.wikipedia.org/wiki/Arithmetic_mean>`_ "
"och *sigma* representerar \"standardavvikelsen <https://en.wikipedia.org/"
"wiki/Standard_deviation>`_."

msgid "If *sigma* is negative, raises :exc:`StatisticsError`."
msgstr "Om *sigma* är negativ, uppstår :exc:`StatisticsError`."

msgid ""
"A read-only property for the `arithmetic mean <https://en.wikipedia.org/wiki/"
"Arithmetic_mean>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för det aritmetiska medelvärdet <https://en."
"wikipedia.org/wiki/Arithmetic_mean>`_ för en normalfördelning."

msgid ""
"A read-only property for the `median <https://en.wikipedia.org/wiki/"
"Median>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för `median <https://en.wikipedia.org/wiki/"
"Median>`_ för en normalfördelning."

msgid ""
"A read-only property for the `mode <https://en.wikipedia.org/wiki/"
"Mode_(statistics)>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för `mode <https://en.wikipedia.org/wiki/"
"Mode_(statistics)>`_ för en normalfördelning."

msgid ""
"A read-only property for the `standard deviation <https://en.wikipedia.org/"
"wiki/Standard_deviation>`_ of a normal distribution."
msgstr ""
"En skrivskyddad egenskap för `standardavvikelsen <https://en.wikipedia.org/"
"wiki/Standard_deviation>`_ för en normalfördelning."

msgid ""
"A read-only property for the `variance <https://en.wikipedia.org/wiki/"
"Variance>`_ of a normal distribution. Equal to the square of the standard "
"deviation."
msgstr ""
"En skrivskyddad egenskap för variansen <https://en.wikipedia.org/wiki/"
"Variance>`_ i en normalfördelning. Lika med kvadraten på standardavvikelsen."

msgid ""
"Makes a normal distribution instance with *mu* and *sigma* parameters "
"estimated from the *data* using :func:`fmean` and :func:`stdev`."
msgstr ""
"Skapar en normalfördelningsinstans med parametrarna *mu* och *sigma* "
"uppskattade från *data* med hjälp av :func:`fmean` och :func:`stdev`."

msgid ""
"The *data* can be any :term:`iterable` and should consist of values that can "
"be converted to type :class:`float`.  If *data* does not contain at least "
"two elements, raises :exc:`StatisticsError` because it takes at least one "
"point to estimate a central value and at least two points to estimate "
"dispersion."
msgstr ""
"*data* kan vara valfri :term:`iterable` och bör bestå av värden som kan "
"konverteras till typen :class:`float`.  Om *data* inte innehåller minst två "
"element, uppstår :exc:`StatisticsError` eftersom det krävs minst en punkt "
"för att skatta ett centralt värde och minst två punkter för att skatta "
"spridningen."

msgid ""
"Generates *n* random samples for a given mean and standard deviation. "
"Returns a :class:`list` of :class:`float` values."
msgstr ""
"Genererar *n* slumpmässiga stickprov för ett givet medelvärde och "
"standardavvikelse. Returnerar en :class:`list` av :class:`float`-värden."

msgid ""
"If *seed* is given, creates a new instance of the underlying random number "
"generator.  This is useful for creating reproducible results, even in a "
"multi-threading context."
msgstr ""
"Om *seed* anges skapas en ny instans av den underliggande "
"slumptalsgeneratorn.  Detta är användbart för att skapa reproducerbara "
"resultat, även i ett sammanhang med flera trådar."

msgid ""
"Switched to a faster algorithm.  To reproduce samples from previous "
"versions, use :func:`random.seed` and :func:`random.gauss`."
msgstr ""
"Bytte till en snabbare algoritm.  För att återskapa exempel från tidigare "
"versioner, använd :func:`random.seed` och :func:`random.gauss`."

msgid ""
"Using a `probability density function (pdf) <https://en.wikipedia.org/wiki/"
"Probability_density_function>`_, compute the relative likelihood that a "
"random variable *X* will be near the given value *x*.  Mathematically, it is "
"the limit of the ratio ``P(x <= X < x+dx) / dx`` as *dx* approaches zero."
msgstr ""
"Med hjälp av en `sannolikhetstäthetsfunktion (pdf) <https://en.wikipedia.org/"
"wiki/Probability_density_function>`_, beräkna den relativa sannolikheten för "
"att en slumpmässig variabel *X* kommer att ligga nära det givna värdet *x*.  "
"Matematiskt sett är det gränsen för förhållandet ``P(x <= X < x+dx) / dx`` "
"när *dx* närmar sig noll."

msgid ""
"The relative likelihood is computed as the probability of a sample occurring "
"in a narrow range divided by the width of the range (hence the word "
"\"density\").  Since the likelihood is relative to other points, its value "
"can be greater than ``1.0``."
msgstr ""
"Den relativa sannolikheten beräknas som sannolikheten för att ett prov "
"förekommer inom ett smalt område dividerat med områdets bredd (därav ordet "
"\"densitet\").  Eftersom sannolikheten är relativ i förhållande till andra "
"punkter kan dess värde vara större än \"1,0\"."

msgid ""
"Using a `cumulative distribution function (cdf) <https://en.wikipedia.org/"
"wiki/Cumulative_distribution_function>`_, compute the probability that a "
"random variable *X* will be less than or equal to *x*.  Mathematically, it "
"is written ``P(X <= x)``."
msgstr ""
"Med hjälp av en `cumulative distribution function (cdf) <https://en."
"wikipedia.org/wiki/Cumulative_distribution_function>`_, beräkna "
"sannolikheten för att en slumpmässig variabel *X* kommer att vara mindre än "
"eller lika med *x*.  Matematiskt skrivs det ``P(X <= x)``."

msgid ""
"Compute the inverse cumulative distribution function, also known as the "
"`quantile function <https://en.wikipedia.org/wiki/Quantile_function>`_ or "
"the `percent-point <https://web.archive.org/web/20190203145224/https://www."
"statisticshowto.datasciencecentral.com/inverse-distribution-function/>`_ "
"function.  Mathematically, it is written ``x : P(X <= x) = p``."
msgstr ""
"Beräkna den inversa kumulativa fördelningsfunktionen, även känd som "
"\"kvantielfunktionen\" <https://en.wikipedia.org/wiki/Quantile_function>`_ "
"eller \"procentpunktsfunktionen\" <https://web.archive.org/"
"web/20190203145224/https://www.statisticshowto.datasciencecentral.com/"
"inverse-distribution-function/>`_.  Matematiskt skrivs den ``x : P(X <= x) = "
"p``."

msgid ""
"Finds the value *x* of the random variable *X* such that the probability of "
"the variable being less than or equal to that value equals the given "
"probability *p*."
msgstr ""
"Tar reda på värdet *x* för den slumpmässiga variabeln *X* så att "
"sannolikheten för att variabeln är mindre än eller lika med detta värde är "
"lika med den givna sannolikheten *p*."

msgid ""
"Measures the agreement between two normal probability distributions. Returns "
"a value between 0.0 and 1.0 giving `the overlapping area for the two "
"probability density functions <https://www.rasch.org/rmt/rmt101r.htm>`_."
msgstr ""
"Mäter överensstämmelsen mellan två normala sannolikhetsfördelningar. "
"Returnerar ett värde mellan 0,0 och 1,0 som anger \"överlappningsområdet för "
"de två sannolikhetstäthetsfunktionerna <https://www.rasch.org/rmt/rmt101r."
"htm>`_\"."

msgid ""
"Divide the normal distribution into *n* continuous intervals with equal "
"probability.  Returns a list of (n - 1) cut points separating the intervals."
msgstr ""
"Dela upp normalfördelningen i *n* kontinuerliga intervall med samma "
"sannolikhet.  Returnerar en lista med (n - 1) skärningspunkter som separerar "
"intervallen."

msgid ""
"Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles. Set "
"*n* to 100 for percentiles which gives the 99 cuts points that separate the "
"normal distribution into 100 equal sized groups."
msgstr ""
"Ställ in *n* på 4 för kvartiler (standard).  Ställ in *n* till 10 för "
"deciler. Ställ in *n* på 100 för percentiler, vilket ger de 99 "
"skärningspunkter som delar upp normalfördelningen i 100 lika stora grupper."

msgid ""
"Compute the `Standard Score <https://www.statisticshowto.com/probability-and-"
"statistics/z-score/>`_ describing *x* in terms of the number of standard "
"deviations above or below the mean of the normal distribution: ``(x - "
"mean) / stdev``."
msgstr ""
"Beräkna `Standardpoäng <https://www.statisticshowto.com/probability-and-"
"statistics/z-score/>`_ som beskriver *x* i termer av antalet "
"standardavvikelser över eller under normalfördelningens medelvärde: ``(x - "
"medelvärde) / stdev``."

msgid ""
"Instances of :class:`NormalDist` support addition, subtraction, "
"multiplication and division by a constant.  These operations are used for "
"translation and scaling.  For example:"
msgstr ""
"Instanser av :class:`NormalDist` stöder addition, subtraktion, "
"multiplikation och division med en konstant.  Dessa operationer används för "
"översättning och skalning.  Ett exempel:"

msgid ""
">>> temperature_february = NormalDist(5, 2.5)             # Celsius\n"
">>> temperature_february * (9/5) + 32                     # Fahrenheit\n"
"NormalDist(mu=41.0, sigma=4.5)"
msgstr ""
">>> temperatur_februari = NormalDist(5, 2,5) # Celsius\n"
">>> temperatur_februari * (9/5) + 32 # Fahrenheit\n"
"NormalDist(mu=41,0, sigma=4,5)"

msgid ""
"Dividing a constant by an instance of :class:`NormalDist` is not supported "
"because the result wouldn't be normally distributed."
msgstr ""
"Att dividera en konstant med en instans av :class:`NormalDist` stöds inte "
"eftersom resultatet inte skulle vara normalfördelat."

msgid ""
"Since normal distributions arise from additive effects of independent "
"variables, it is possible to `add and subtract two independent normally "
"distributed random variables <https://en.wikipedia.org/wiki/"
"Sum_of_normally_distributed_random_variables>`_ represented as instances of :"
"class:`NormalDist`.  For example:"
msgstr ""
"Eftersom normalfördelningar uppstår genom additiva effekter av oberoende "
"variabler, är det möjligt att \"addera och subtrahera två oberoende "
"normalfördelade slumpmässiga variabler <https://en.wikipedia.org/wiki/"
"Sum_of_normally_distributed_random_variables>`_ representerade som instanser "
"av :class:`NormalDist`.  Till exempel"

msgid ""
">>> birth_weights = NormalDist.from_samples([2.5, 3.1, 2.1, 2.4, 2.7, 3.5])\n"
">>> drug_effects = NormalDist(0.4, 0.15)\n"
">>> combined = birth_weights + drug_effects\n"
">>> round(combined.mean, 1)\n"
"3.1\n"
">>> round(combined.stdev, 1)\n"
"0.5"
msgstr ""
">>> födelsevikter = NormalDist.from_samples([2,5, 3,1, 2,1, 2,4, 2,7, 3,5])\n"
">>> läkemedelseffekter = NormalDist(0,4, 0,15)\n"
">>> kombinerat = födelsevikter + läkemedelseffekter\n"
">>> round(kombinerat.medelvärde, 1)\n"
"3.1\n"
">>> runda(kombinerad.stdev, 1)\n"
"0.5"

msgid "Examples and Recipes"
msgstr "Exempel och recept"

msgid "Classic probability problems"
msgstr "Klassiska sannolikhetsproblem"

msgid ":class:`NormalDist` readily solves classic probability problems."
msgstr ":class:`NormalDist` löser enkelt klassiska sannolikhetsproblem."

msgid ""
"For example, given `historical data for SAT exams <https://nces.ed.gov/"
"programs/digest/d17/tables/dt17_226.40.asp>`_ showing that scores are "
"normally distributed with a mean of 1060 and a standard deviation of 195, "
"determine the percentage of students with test scores between 1100 and 1200, "
"after rounding to the nearest whole number:"
msgstr ""
"Om du till exempel har \"historiska data för SAT-prov <https://nces.ed.gov/"
"programs/digest/d17/tables/dt17_226.40.asp>`_\" som visar att resultaten är "
"normalfördelade med ett medelvärde på 1060 och en standardavvikelse på 195, "
"kan du bestämma andelen elever med provresultat mellan 1100 och 1200, efter "
"avrundning till närmaste heltal:"

msgid ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraction = sat.cdf(1200 + 0.5) - sat.cdf(1100 - 0.5)\n"
">>> round(fraction * 100.0, 1)\n"
"18.4"
msgstr ""
">>> sat = NormalDist(1060, 195)\n"
">>> fraktion = sat.cdf(1200 + 0,5) - sat.cdf(1100 - 0,5)\n"
">>> runda(fraktion * 100,0, 1)\n"
"18.4"

msgid ""
"Find the `quartiles <https://en.wikipedia.org/wiki/Quartile>`_ and `deciles "
"<https://en.wikipedia.org/wiki/Decile>`_ for the SAT scores:"
msgstr ""
"Hitta \"kvartilerna\" <https://en.wikipedia.org/wiki/Quartile>`_ och "
"\"decilerna\" <https://en.wikipedia.org/wiki/Decile>`_ för SAT-poängen:"

msgid ""
">>> list(map(round, sat.quantiles()))\n"
"[928, 1060, 1192]\n"
">>> list(map(round, sat.quantiles(n=10)))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"
msgstr ""
">>> list(map(runda, sat.kvantiler()))\n"
"[928, 1060, 1192]\n"
">>> list(karta(runda, sat.kvantiler(n=10))))\n"
"[810, 896, 958, 1011, 1060, 1109, 1162, 1224, 1310]"

msgid "Monte Carlo inputs for simulations"
msgstr "Monte Carlo-ingångar för simuleringar"

msgid ""
"To estimate the distribution for a model that isn't easy to solve "
"analytically, :class:`NormalDist` can generate input samples for a `Monte "
"Carlo simulation <https://en.wikipedia.org/wiki/Monte_Carlo_method>`_:"
msgstr ""
"För att uppskatta fördelningen för en modell som inte är lätt att lösa "
"analytiskt kan :class:`NormalDist` generera indataprov för en `Monte Carlo-"
"simulering <https://en.wikipedia.org/wiki/Monte_Carlo_method>`_:"

msgid ""
">>> def model(x, y, z):\n"
"...     return (3*x + 7*x*y - 5*y) / (11 * z)\n"
"...\n"
">>> n = 100_000\n"
">>> X = NormalDist(10, 2.5).samples(n, seed=3652260728)\n"
">>> Y = NormalDist(15, 1.75).samples(n, seed=4582495471)\n"
">>> Z = NormalDist(50, 1.25).samples(n, seed=6582483453)\n"
">>> quantiles(map(model, X, Y, Z))\n"
"[1.4591308524824727, 1.8035946855390597, 2.175091447274739]"
msgstr ""
">>> def modell(x, y, z):\n"
"... return (3*x + 7*x*y - 5*y) / (11 * z)\n"
"...\n"
">>> n = 100_000\n"
">>> X = NormalDist(10, 2,5).samples(n, seed=3652260728)\n"
">>> Y = NormalDist(15, 1,75).samples(n, seed=4582495471)\n"
">>> Z = NormalDist(50, 1,25).samples(n, seed=6582483453)\n"
">>> kvantiler(map(modell, X, Y, Z))\n"
"[1.4591308524824727, 1.8035946855390597, 2.175091447274739]"

msgid "Approximating binomial distributions"
msgstr "Approximation av binomialfördelningar"

msgid ""
"Normal distributions can be used to approximate `Binomial distributions "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_ when the sample "
"size is large and when the probability of a successful trial is near 50%."
msgstr ""
"Normalfördelningar kan användas för att approximera binomialfördelningar "
"<https://mathworld.wolfram.com/BinomialDistribution.html>`_ när "
"urvalsstorleken är stor och när sannolikheten för ett lyckat försök är nära "
"50%."

msgid ""
"For example, an open source conference has 750 attendees and two rooms with "
"a 500 person capacity.  There is a talk about Python and another about Ruby. "
"In previous conferences, 65% of the attendees preferred to listen to Python "
"talks.  Assuming the population preferences haven't changed, what is the "
"probability that the Python room will stay within its capacity limits?"
msgstr ""
"Till exempel har en konferens om öppen källkod 750 deltagare och två rum med "
"en kapacitet på 500 personer.  Det finns ett föredrag om Python och ett "
"annat om Ruby. Vid tidigare konferenser föredrog 65% of av deltagarna att "
"lyssna på Python-samtal.  Om vi antar att deltagarnas preferenser inte har "
"ändrats, hur stor är sannolikheten att Python-rummet håller sig inom "
"kapacitetsgränserna?"

msgid ""
">>> n = 750             # Sample size\n"
">>> p = 0.65            # Preference for Python\n"
">>> q = 1.0 - p         # Preference for Ruby\n"
">>> k = 500             # Room capacity\n"
"\n"
">>> # Approximation using the cumulative normal distribution\n"
">>> from math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0.5), 4)\n"
"0.8402\n"
"\n"
">>> # Exact solution using the cumulative binomial distribution\n"
">>> from math import comb, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # Approximation using a simulation\n"
">>> from random import seed, binomialvariate\n"
">>> seed(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"
msgstr ""
">>> n = 750 # Provstorlek\n"
">>> p = 0,65 # Preferens för Python\n"
">>> q = 1,0 - p # Preferens för Ruby\n"
">>> k = 500 # Kapacitet i rummet\n"
"\n"
">>> # Approximation med hjälp av den kumulativa normalfördelningen\n"
">>> från math import sqrt\n"
">>> round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + 0,5), 4)\n"
"0.8402\n"
"\n"
">>> # Exakt lösning med hjälp av den kumulativa binomialfördelningen\n"
">>> från math import kam, fsum\n"
">>> round(fsum(comb(n, r) * p**r * q**(n-r) for r in range(k+1)), 4)\n"
"0.8402\n"
"\n"
">>> # Approximation med hjälp av en simulering\n"
">>> from random import frö, binomialvariabel\n"
">>> frö(8675309)\n"
">>> mean(binomialvariate(n, p) <= k for i in range(10_000))\n"
"0.8406"

msgid "Naive bayesian classifier"
msgstr "Naiv bayesiansk klassificerare"

msgid "Normal distributions commonly arise in machine learning problems."
msgstr "Normalfördelningar är vanligt förekommande i maskininlärningsproblem."

msgid ""
"Wikipedia has a `nice example of a Naive Bayesian Classifier <https://en."
"wikipedia.org/wiki/Naive_Bayes_classifier#Person_classification>`_. The "
"challenge is to predict a person's gender from measurements of normally "
"distributed features including height, weight, and foot size."
msgstr ""
"Wikipedia har ett \"trevligt exempel på en Naive Bayesian Classifier "
"<https://en.wikipedia.org/wiki/"
"Naive_Bayes_classifier#Person_classification>`_. Utmaningen är att förutsäga "
"en persons kön från mätningar av normalfördelade egenskaper, inklusive "
"längd, vikt och fotstorlek."

msgid ""
"We're given a training dataset with measurements for eight people.  The "
"measurements are assumed to be normally distributed, so we summarize the "
"data with :class:`NormalDist`:"
msgstr ""
"Vi får en träningsdatauppsättning med mätningar för åtta personer.  Måtten "
"antas vara normalfördelade, så vi sammanfattar data med :class:`NormalDist`:"

msgid ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"
msgstr ""
">>> height_male = NormalDist.from_samples([6, 5.92, 5.58, 5.92])\n"
">>> height_female = NormalDist.from_samples([5, 5.5, 5.42, 5.75])\n"
">>> weight_male = NormalDist.from_samples([180, 190, 170, 165])\n"
">>> weight_female = NormalDist.from_samples([100, 150, 130, 150])\n"
">>> foot_size_male = NormalDist.from_samples([12, 11, 12, 10])\n"
">>> foot_size_female = NormalDist.from_samples([6, 8, 7, 9])"

msgid ""
"Next, we encounter a new person whose feature measurements are known but "
"whose gender is unknown:"
msgstr ""
"Därefter möter vi en ny person vars funktionsmätningar är kända men vars kön "
"är okänt:"

msgid ""
">>> ht = 6.0        # height\n"
">>> wt = 130        # weight\n"
">>> fs = 8          # foot size"
msgstr ""
">>> ht = 6.0        # höjd\n"
">>> wt = 130        # bredd\n"
">>> fs = 8          # fotstorlek"

msgid ""
"Starting with a 50% `prior probability <https://en.wikipedia.org/wiki/"
"Prior_probability>`_ of being male or female, we compute the posterior as "
"the prior times the product of likelihoods for the feature measurements "
"given the gender:"
msgstr ""
"Med utgångspunkt från en 50% prior sannolikhet <https://en.wikipedia.org/"
"wiki/Prior_probability>`_ för att vara man eller kvinna, beräknar vi "
"posterior som prior gånger produkten av sannolikheter för "
"funktionsmätningarna med tanke på kön:"

msgid ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"
msgstr ""
">>> prior_male = 0.5\n"
">>> prior_female = 0.5\n"
">>> posterior_male = (prior_male * height_male.pdf(ht) *\n"
"...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))\n"
"\n"
">>> posterior_female = (prior_female * height_female.pdf(ht) *\n"
"...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))"

msgid ""
"The final prediction goes to the largest posterior. This is known as the "
"`maximum a posteriori <https://en.wikipedia.org/wiki/"
"Maximum_a_posteriori_estimation>`_ or MAP:"
msgstr ""
"Den slutliga prediktionen går till den största posterior. Detta kallas för "
"maximal a posteriori <https://en.wikipedia.org/wiki/"
"Maximum_a_posteriori_estimation>`_ eller MAP:"

msgid ""
">>> 'male' if posterior_male > posterior_female else 'female'\n"
"'female'"
msgstr ""
">>> 'male' if posterior_male > posterior_female else 'female'\n"
"'female'"
