# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!timeit` --- Measure execution time of small code snippets"
msgstr ":mod:`!timeit` --- Mät exekveringstid för små kodsnuttar"

msgid "**Source code:** :source:`Lib/timeit.py`"
msgstr "**Källkod:** :source:`Lib/timeit.py`"

msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both a :ref:`timeit-command-line-interface` as well as a :ref:`callable "
"<python-interface>` one.  It avoids a number of common traps for measuring "
"execution times. See also Tim Peters' introduction to the \"Algorithms\" "
"chapter in the second edition of *Python Cookbook*, published by O'Reilly."
msgstr ""
"Denna modul ger ett enkelt sätt att tidsinställa små bitar av Python-kod. "
"Den har både ett :ref:`timeit-command-line-interface` och ett :ref:`callable "
"<python-interface>`.  Det undviker ett antal vanliga fällor för att mäta "
"exekveringstider. Se även Tim Peters introduktion till kapitlet "
"\"Algorithms\" i den andra upplagan av *Python Cookbook*, utgiven av "
"O'Reilly."

msgid "Basic Examples"
msgstr "Grundläggande exempel"

msgid ""
"The following example shows how the :ref:`timeit-command-line-interface` can "
"be used to compare three different expressions:"
msgstr ""
"Följande exempel visar hur :ref:`timeit-command-line-interface` kan användas "
"för att jämföra tre olika uttryck:"

msgid ""
"$ python -m timeit \"'-'.join(str(n) for n in range(100))\"\n"
"10000 loops, best of 5: 30.2 usec per loop\n"
"$ python -m timeit \"'-'.join([str(n) for n in range(100)])\"\n"
"10000 loops, best of 5: 27.5 usec per loop\n"
"$ python -m timeit \"'-'.join(map(str, range(100)))\"\n"
"10000 loops, best of 5: 23.2 usec per loop"
msgstr ""
"$ python -m timeit \"'-'.join(str(n) for n in range(100))\"\n"
"10000 loops, best of 5: 30.2 usec per loop\n"
"$ python -m timeit \"'-'.join([str(n) for n in range(100)])\"\n"
"10000 loops, best of 5: 27.5 usec per loop\n"
"$ python -m timeit \"'-'.join(map(str, range(100)))\"\n"
"10000 loops, best of 5: 23.2 usec per loop"

msgid "This can be achieved from the :ref:`python-interface` with::"
msgstr "Detta kan uppnås från :ref:`python-interface` med::"

msgid ""
">>> import timeit\n"
">>> timeit.timeit('\"-\".join(str(n) for n in range(100))', number=10000)\n"
"0.3018611848820001\n"
">>> timeit.timeit('\"-\".join([str(n) for n in range(100)])', number=10000)\n"
"0.2727368790656328\n"
">>> timeit.timeit('\"-\".join(map(str, range(100)))', number=10000)\n"
"0.23702679807320237"
msgstr ""
">>> import timeit\n"
">>> timeit.timeit('\"-\".join(str(n) for n in range(100))', number=10000)\n"
"0.3018611848820001\n"
">>> timeit.timeit('\"-\".join([str(n) for n in range(100)])', number=10000)\n"
"0.2727368790656328\n"
">>> timeit.timeit('\"-\".join(map(str, range(100)))', number=10000)\n"
"0.23702679807320237"

msgid "A callable can also be passed from the :ref:`python-interface`::"
msgstr "En anropsbar kan också skickas från :ref:`python-interface`::"

msgid ""
">>> timeit.timeit(lambda: \"-\".join(map(str, range(100))), number=10000)\n"
"0.19665591977536678"
msgstr ""
">>> timeit.timeit(lambda: \"-\".join(map(str, range(100))), number=10000)\n"
"0.19665591977536678"

msgid ""
"Note however that :func:`.timeit` will automatically determine the number of "
"repetitions only when the command-line interface is used.  In the :ref:"
"`timeit-examples` section you can find more advanced examples."
msgstr ""
"Observera dock att :func:`.timeit` automatiskt kommer att bestämma antalet "
"repetitioner endast när kommandoradsgränssnittet används.  I avsnittet :ref:"
"`timeit-examples` kan du hitta mer avancerade exempel."

msgid "Python Interface"
msgstr "Python-gränssnitt"

msgid "The module defines three convenience functions and a public class:"
msgstr "Modulen definierar tre bekvämlighetsfunktioner och en publik klass:"

msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.timeit` method with *number* "
"executions. The optional *globals* argument specifies a namespace in which "
"to execute the code."
msgstr ""
"Skapa en instans av :class:`Timer` med den angivna satsen, *setup*-koden och "
"*timer*-funktionen och kör dess :meth:`.timeit`-metod med *antal* "
"exekveringar. Det valfria argumentet *globals* anger ett namnområde där "
"koden ska exekveras."

msgid "The optional *globals* parameter was added."
msgstr "Den valfria parametern *globals* har lagts till."

msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.repeat` method with the given *repeat* "
"count and *number* executions.  The optional *globals* argument specifies a "
"namespace in which to execute the code."
msgstr ""
"Skapa en instans av :class:`Timer` med den angivna satsen, *setup*-koden och "
"*timer*-funktionen och kör dess :meth:`.repeat`-metod med det angivna "
"*repeat*-antalet och *antalet* exekveringar.  Det valfria argumentet "
"*globals* anger ett namnområde där koden ska exekveras."

msgid "Default value of *repeat* changed from 3 to 5."
msgstr "Standardvärdet för *repeat* har ändrats från 3 till 5."

msgid ""
"The default timer, which is always time.perf_counter(), returns float "
"seconds. An alternative, time.perf_counter_ns, returns integer nanoseconds."
msgstr ""
"Standardtimern, som alltid är time.perf_counter(), returnerar float-"
"sekunder. Ett alternativ, time.perf_counter_ns, returnerar heltalet "
"nanosekunder."

msgid ":func:`time.perf_counter` is now the default timer."
msgstr ":func:`time.perf_counter` är nu standardtimern."

msgid "Class for timing execution speed of small code snippets."
msgstr "Klass för att mäta exekveringshastigheten för små kodsnuttar."

msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the "
"timer function is platform-dependent (see the module doc string). *stmt* and "
"*setup* may also contain multiple statements separated by ``;`` or newlines, "
"as long as they don't contain multi-line string literals.  The statement "
"will by default be executed within timeit's namespace; this behavior can be "
"controlled by passing a namespace to *globals*."
msgstr ""
"Konstruktören tar ett uttalande som ska tidsbestämmas, ett ytterligare "
"uttalande som används för inställning och en timerfunktion.  Båda satserna "
"har ``'pass'`` som standard; timerfunktionen är plattformsberoende (se "
"modulens dokumentsträng). *stmt* och *setup* kan också innehålla flera "
"satser åtskilda av ``;`` eller nya rader, så länge de inte innehåller "
"stränglitteraler på flera rader.  Satsen kommer som standard att exekveras "
"inom timeits namnrymd; detta beteende kan kontrolleras genom att skicka en "
"namnrymd till *globals*."

msgid ""
"To measure the execution time of the first statement, use the :meth:`."
"timeit` method.  The :meth:`.repeat` and :meth:`.autorange` methods are "
"convenience methods to call :meth:`.timeit` multiple times."
msgstr ""
"För att mäta exekveringstiden för den första satsen använder du metoden :"
"meth:`.timeit`.  Metoderna :meth:`.repeat` och :meth:`.autorange` är "
"bekvämlighetsmetoder för att anropa :meth:`.timeit` flera gånger."

msgid ""
"The execution time of *setup* is excluded from the overall timed execution "
"run."
msgstr ""
"Exekveringstiden för *setup* är exkluderad från den totala tidsbestämda "
"körningen."

msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable "
"without arguments.  This will embed calls to them in a timer function that "
"will then be executed by :meth:`.timeit`.  Note that the timing overhead is "
"a little larger in this case because of the extra function calls."
msgstr ""
"Parametrarna *stmt* och *setup* kan också ta objekt som är anropsbara utan "
"argument.  Detta kommer att bädda in anrop till dem i en timerfunktion som "
"sedan kommer att utföras av :meth:`.timeit`.  Observera att tidsöverskottet "
"är lite större i det här fallet på grund av de extra funktionsanropen."

msgid ""
"Time *number* executions of the main statement.  This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times.  The default timer returns seconds as a float. "
"The argument is the number of times through the loop, defaulting to one "
"million.  The main statement, the setup statement and the timer function to "
"be used are passed to the constructor."
msgstr ""
"Tid *antal* exekveringar av huvudsatsen.  Detta exekverar setup-satsen en "
"gång och returnerar sedan den tid det tar att exekvera huvudsatsen ett antal "
"gånger.  Standardtimern returnerar sekunder som en flottör. Argumentet är "
"antalet gånger genom slingan, med standardvärdet en miljon.  Main-satsen, "
"setup-satsen och den timerfunktion som ska användas skickas till "
"konstruktören."

msgid ""
"By default, :meth:`.timeit` temporarily turns off :term:`garbage collection` "
"during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  The disadvantage is that GC may be an "
"important component of the performance of the function being measured.  If "
"so, GC can be re-enabled as the first statement in the *setup* string.  For "
"example::"
msgstr ""
"Som standard stänger :meth:`.timeit` tillfälligt av :term:`garbage "
"collection` under tidtagningen.  Fördelen med detta tillvägagångssätt är att "
"det gör oberoende tidtagningar mer jämförbara.  Nackdelen är att GC kan vara "
"en viktig komponent i prestandan för den funktion som mäts.  Om så är fallet "
"kan GC återaktiveras som det första uttalandet i *setup*-strängen.  Till "
"exempel::"

msgid "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"
msgstr "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"

msgid "Automatically determine how many times to call :meth:`.timeit`."
msgstr "Bestäm automatiskt hur många gånger du ska anropa :meth:`.timeit`."

msgid ""
"This is a convenience function that calls :meth:`.timeit` repeatedly so that "
"the total time >= 0.2 second, returning the eventual (number of loops, time "
"taken for that number of loops). It calls :meth:`.timeit` with increasing "
"numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the time taken is "
"at least 0.2 seconds."
msgstr ""
"Detta är en bekvämlighetsfunktion som anropar :meth:`.timeit` upprepade "
"gånger så att den totala tiden >= 0,2 sekunder och returnerar resultatet "
"(antal loopar, tidsåtgång för detta antal loopar). Den anropar :meth:`."
"timeit` med ökande nummer från sekvensen 1, 2, 5, 10, 20, 50, ... tills den "
"totala tiden är minst 0,2 sekunder."

msgid ""
"If *callback* is given and is not ``None``, it will be called after each "
"trial with two arguments: ``callback(number, time_taken)``."
msgstr ""
"Om *callback* anges och inte är ``None``, kommer den att anropas efter varje "
"försök med två argument: ``callback(number, time_taken)``."

msgid "Call :meth:`.timeit` a few times."
msgstr "Anropa :meth:`.timeit` några gånger."

msgid ""
"This is a convenience function that calls the :meth:`.timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to "
"call :meth:`.timeit`.  The second argument specifies the *number* argument "
"for :meth:`.timeit`."
msgstr ""
"Detta är en bekvämlighetsfunktion som anropar :meth:`.timeit` upprepade "
"gånger och returnerar en lista med resultat.  Det första argumentet anger "
"hur många gånger :meth:`.timeit` ska anropas.  Det andra argumentet anger "
"*number*-argumentet för :meth:`.timeit`."

msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful. In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run "
"the given code snippet; higher values in the result vector are typically not "
"caused by variability in Python's speed, but by other processes interfering "
"with your timing accuracy. So the :func:`min` of the result is probably the "
"only number you should be interested in.  After that, you should look at the "
"entire vector and apply common sense rather than statistics."
msgstr ""
"Det är frestande att beräkna medelvärde och standardavvikelse från "
"resultatvektorn och rapportera dessa.  Detta är dock inte särskilt "
"användbart. I ett typiskt fall ger det lägsta värdet en nedre gräns för hur "
"snabbt din maskin kan köra det givna kodavsnittet; högre värden i "
"resultatvektorn orsakas vanligtvis inte av variabilitet i Pythons hastighet, "
"utan av andra processer som stör din tidsnoggrannhet. Så :func:`min` av "
"resultatet är förmodligen det enda talet du bör vara intresserad av.  Efter "
"det bör du titta på hela vektorn och tillämpa sunt förnuft snarare än "
"statistik."

msgid "Helper to print a traceback from the timed code."
msgstr ""
"Hjälpmedel för att skriva ut en traceback från den tidsinställda koden."

msgid "Typical use::"
msgstr "Typisk användning::"

msgid ""
"t = Timer(...)       # outside the try/except\n"
"try:\n"
"    t.timeit(...)    # or t.repeat(...)\n"
"except Exception:\n"
"    t.print_exc()"
msgstr ""
"t = Timer(...)       # outside the try/except\n"
"try:\n"
"    t.timeit(...)    # or t.repeat(...)\n"
"except Exception:\n"
"    t.print_exc()"

msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed.  The optional *file* argument directs "
"where the traceback is sent; it defaults to :data:`sys.stderr`."
msgstr ""
"Fördelen jämfört med standardtraceback är att källkodsrader i den "
"kompilerade mallen visas.  Det valfria argumentet *file* anger vart "
"spårningen ska skickas; standardvärdet är :data:`sys.stderr`."

msgid "Command-Line Interface"
msgstr "Kommandoradsgränssnitt"

msgid ""
"When called as a program from the command line, the following form is used::"
msgstr "När ett program anropas från kommandoraden används följande form::"

msgid ""
"python -m timeit [-n N] [-r N] [-u U] [-s S] [-p] [-v] [-h] [statement ...]"
msgstr ""
"python -m timeit [-n N] [-r N] [-u U] [-s S] [-p] [-v] [-h] [statement ...]"

msgid "Where the following options are understood:"
msgstr "Där följande alternativ förstås:"

msgid "how many times to execute 'statement'"
msgstr "hur många gånger ska \"statement\" utföras"

msgid "how many times to repeat the timer (default 5)"
msgstr "hur många gånger timern ska upprepas (standard 5)"

msgid "statement to be executed once initially (default ``pass``)"
msgstr "uttalande som ska köras en gång initialt (standard ``pass``)"

msgid ""
"measure process time, not wallclock time, using :func:`time.process_time` "
"instead of :func:`time.perf_counter`, which is the default"
msgstr ""
"mäta processtid, inte väggklocktid, med :func:`time.process_time` istället "
"för :func:`time.perf_counter`, som är standard"

msgid ""
"specify a time unit for timer output; can select ``nsec``, ``usec``, "
"``msec``, or ``sec``"
msgstr ""
"ange en tidsenhet för timerutmatning; kan välja ``nsec``, ``usec``, ``msec`` "
"eller ``sec``"

msgid "print raw timing results; repeat for more digits precision"
msgstr "skriv ut råa tidsresultat; upprepa för fler siffror precision"

msgid "print a short usage message and exit"
msgstr "skriva ut ett kort användarmeddelande och avsluta"

msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""
"Ett uttalande med flera rader kan anges genom att specificera varje rad som "
"ett separat uttalandeargument; indragna rader är möjliga genom att omsluta "
"ett argument med citattecken och använda inledande mellanslag.  Flera :"
"option:`-s`-alternativ behandlas på liknande sätt."

msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until "
"the total time is at least 0.2 seconds."
msgstr ""
"Om :option:`-n` inte anges, beräknas ett lämpligt antal loopar genom att "
"prova ökande antal från sekvensen 1, 2, 5, 10, 20, 50, ... tills den totala "
"tiden är minst 0,2 sekunder."

msgid ""
":func:`default_timer` measurements can be affected by other programs running "
"on the same machine, so the best thing to do when accurate timing is "
"necessary is to repeat the timing a few times and use the best time.  The :"
"option:`-r` option is good for this; the default of 5 repetitions is "
"probably enough in most cases.  You can use :func:`time.process_time` to "
"measure CPU time."
msgstr ""
":func:`default_timer` mätningar kan påverkas av andra program som körs på "
"samma maskin, så det bästa man kan göra när exakt tidtagning är nödvändig är "
"att upprepa tidtagningen några gånger och använda den bästa tiden.  "
"Alternativet :option:`-r` är bra för detta; standardvärdet 5 repetitioner är "
"förmodligen tillräckligt i de flesta fall.  Du kan använda :func:`time."
"process_time` för att mäta CPU-tiden."

msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments, and it might differ between Python versions."
msgstr ""
"Det finns en viss baseline overhead förknippad med att köra en pass-sats. "
"Koden här försöker inte dölja det, men du bör vara medveten om det.  Den "
"grundläggande kostnaden kan mätas genom att anropa programmet utan argument, "
"och den kan skilja sig mellan olika Python-versioner."

msgid "Examples"
msgstr "Exempel"

msgid ""
"It is possible to provide a setup statement that is executed only once at "
"the beginning:"
msgstr ""
"Det är möjligt att tillhandahålla en setup-sats som bara körs en gång i "
"början:"

msgid ""
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"char in "
"text\"\n"
"5000000 loops, best of 5: 0.0877 usec per loop\n"
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"text."
"find(char)\"\n"
"1000000 loops, best of 5: 0.342 usec per loop"
msgstr ""
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"char in "
"text\"\n"
"5000000 loops, best of 5: 0.0877 usec per loop\n"
"$ python -m timeit -s \"text = 'sample string'; char = 'g'\" \"text."
"find(char)\"\n"
"1000000 loops, best of 5: 0.342 usec per loop"

msgid ""
"In the output, there are three fields. The loop count, which tells you how "
"many times the statement body was run per timing loop repetition. The "
"repetition count ('best of 5') which tells you how many times the timing "
"loop was repeated, and finally the time the statement body took on average "
"within the best repetition of the timing loop. That is, the time the fastest "
"repetition took divided by the loop count."
msgstr ""
"I utdata finns det tre fält. Loopantalet, som visar hur många gånger satsen "
"kördes per repetition av tidtagningsslingan. Upprepningsantalet (\"bäst av "
"5\"), som visar hur många gånger tidtagningsslingan upprepades, och "
"slutligen den tid som satsen i genomsnitt tog i den bästa upprepningen av "
"tidtagningsslingan. Det vill säga den tid som den snabbaste upprepningen tog "
"dividerat med loopantalet."

msgid ""
">>> import timeit\n"
">>> timeit.timeit('char in text', setup='text = \"sample string\"; char = "
"\"g\"')\n"
"0.41440500499993504\n"
">>> timeit.timeit('text.find(char)', setup='text = \"sample string\"; char = "
"\"g\"')\n"
"1.7246671520006203"
msgstr ""
">>> import timeit\n"
">>> timeit.timeit('char in text', setup='text = \"sample string\"; char = "
"\"g\"')\n"
"0.41440500499993504\n"
">>> timeit.timeit('text.find(char)', setup='text = \"sample string\"; char = "
"\"g\"')\n"
"1.7246671520006203"

msgid "The same can be done using the :class:`Timer` class and its methods::"
msgstr ""
"Detsamma kan göras med hjälp av klassen :class:`Timer` och dess metoder::"

msgid ""
">>> import timeit\n"
">>> t = timeit.Timer('char in text', setup='text = \"sample string\"; char = "
"\"g\"')\n"
">>> t.timeit()\n"
"0.3955516149999312\n"
">>> t.repeat()\n"
"[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, "
"0.3712595970846668, 0.37866875250654886]"
msgstr ""
">>> import timeit\n"
">>> t = timeit.Timer('char in text', setup='text = \"sample string\"; char = "
"\"g\"')\n"
">>> t.timeit()\n"
"0.3955516149999312\n"
">>> t.repeat()\n"
"[0.40183617287970225, 0.37027556854118704, 0.38344867356679524, "
"0.3712595970846668, 0.37866875250654886]"

msgid ""
"The following examples show how to time expressions that contain multiple "
"lines. Here we compare the cost of using :func:`hasattr` vs. :keyword:`try`/:"
"keyword:`except` to test for missing and present object attributes:"
msgstr ""
"Följande exempel visar hur man tidsbestämmer uttryck som innehåller flera "
"rader. Här jämför vi kostnaden för att använda :func:`hasattr` jämfört med :"
"keyword:`try`/:keyword:`except` för att testa om objektattribut saknas eller "
"finns:"

msgid ""
"$ python -m timeit \"try:\" \"  str.__bool__\" \"except AttributeError:\" "
"\"  pass\"\n"
"20000 loops, best of 5: 15.7 usec per loop\n"
"$ python -m timeit \"if hasattr(str, '__bool__'): pass\"\n"
"50000 loops, best of 5: 4.26 usec per loop\n"
"\n"
"$ python -m timeit \"try:\" \"  int.__bool__\" \"except AttributeError:\" "
"\"  pass\"\n"
"200000 loops, best of 5: 1.43 usec per loop\n"
"$ python -m timeit \"if hasattr(int, '__bool__'): pass\"\n"
"100000 loops, best of 5: 2.23 usec per loop"
msgstr ""
"$ python -m timeit \"try:\" \"  str.__bool__\" \"except AttributeError:\" "
"\"  pass\"\n"
"20000 loops, best of 5: 15.7 usec per loop\n"
"$ python -m timeit \"if hasattr(str, '__bool__'): pass\"\n"
"50000 loops, best of 5: 4.26 usec per loop\n"
"\n"
"$ python -m timeit \"try:\" \"  int.__bool__\" \"except AttributeError:\" "
"\"  pass\"\n"
"200000 loops, best of 5: 1.43 usec per loop\n"
"$ python -m timeit \"if hasattr(int, '__bool__'): pass\"\n"
"100000 loops, best of 5: 2.23 usec per loop"

msgid ""
">>> import timeit\n"
">>> # attribute is missing\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.9138244460009446\n"
">>> s = \"if hasattr(str, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.5829014980008651\n"
">>>\n"
">>> # attribute is present\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.04215312199994514\n"
">>> s = \"if hasattr(int, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.08588060699912603"
msgstr ""
">>> import timeit\n"
">>> # attribute is missing\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.9138244460009446\n"
">>> s = \"if hasattr(str, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.5829014980008651\n"
">>>\n"
">>> # attribute is present\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.04215312199994514\n"
">>> s = \"if hasattr(int, '__bool__'): pass\"\n"
">>> timeit.timeit(stmt=s, number=100000)\n"
"0.08588060699912603"

msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a *setup* parameter which contains an import statement::"
msgstr ""
"För att ge modulen :mod:`timeit` tillgång till funktioner som du definierar "
"kan du skicka en *setup*-parameter som innehåller en importförklaring::"

msgid ""
"def test():\n"
"    \"\"\"Stupid test function\"\"\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__ == '__main__':\n"
"    import timeit\n"
"    print(timeit.timeit(\"test()\", setup=\"from __main__ import test\"))"
msgstr ""
"def test():\n"
"    \"\"\"Stupid test function\"\"\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__ == '__main__':\n"
"    import timeit\n"
"    print(timeit.timeit(\"test()\", setup=\"from __main__ import test\"))"

msgid ""
"Another option is to pass :func:`globals` to the  *globals* parameter, which "
"will cause the code to be executed within your current global namespace.  "
"This can be more convenient than individually specifying imports::"
msgstr ""
"Ett annat alternativ är att skicka :func:`globals` till parametern "
"*globals*, vilket gör att koden exekveras inom ditt aktuella globala "
"namnområde.  Detta kan vara mer praktiskt än att individuellt ange imports::"

msgid ""
"def f(x):\n"
"    return x**2\n"
"def g(x):\n"
"    return x**4\n"
"def h(x):\n"
"    return x**8\n"
"\n"
"import timeit\n"
"print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))"
msgstr ""
"def f(x):\n"
"    return x**2\n"
"def g(x):\n"
"    return x**4\n"
"def h(x):\n"
"    return x**8\n"
"\n"
"import timeit\n"
"print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))"

msgid "Benchmarking"
msgstr "Benchmarking"

msgid "Performance"
msgstr "Prestanda"
