# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Design and History FAQ"
msgstr "Frågor och svar om design och historia"

msgid "Contents"
msgstr "Innehåll"

msgid "Why does Python use indentation for grouping of statements?"
msgstr "Varför använder Python indragning för gruppering av uttalanden?"

msgid ""
"Guido van Rossum believes that using indentation for grouping is extremely "
"elegant and contributes a lot to the clarity of the average Python program. "
"Most people learn to love this feature after a while."
msgstr ""
"Guido van Rossum anser att det är extremt elegant att använda indragning för "
"gruppering och att det bidrar mycket till tydligheten i det genomsnittliga "
"Python-programmet. De flesta lär sig att älska den här funktionen efter ett "
"tag."

msgid ""
"Since there are no begin/end brackets there cannot be a disagreement between "
"grouping perceived by the parser and the human reader.  Occasionally C "
"programmers will encounter a fragment of code like this::"
msgstr ""
"Eftersom det inte finns några start-/slutparenteser kan det inte finnas "
"någon oenighet mellan den gruppering som uppfattas av parsern och den "
"mänskliga läsaren.  Ibland kommer C-programmerare att stöta på ett fragment "
"av kod som detta::"

msgid ""
"if (x <= y)\n"
"        x++;\n"
"        y--;\n"
"z++;"
msgstr ""
"if (x <= y)\n"
"        x++;\n"
"        y--;\n"
"z++;"

msgid ""
"Only the ``x++`` statement is executed if the condition is true, but the "
"indentation leads many to believe otherwise.  Even experienced C programmers "
"will sometimes stare at it a long time wondering as to why ``y`` is being "
"decremented even for ``x > y``."
msgstr ""
"Endast ``x++``-satsen exekveras om villkoret är sant, men indragningen får "
"många att tro något annat.  Även erfarna C-programmerare kommer ibland att "
"stirra på det länge och undra varför ``y`` minskas även för ``x > y``."

msgid ""
"Because there are no begin/end brackets, Python is much less prone to coding-"
"style conflicts.  In C there are many different ways to place the braces. "
"After becoming used to reading and writing code using a particular style, it "
"is normal to feel somewhat uneasy when reading (or being required to write) "
"in a different one."
msgstr ""
"Eftersom det inte finns några början/slut-parenteser är Python mycket mindre "
"benäget för konflikter i kodningsstilen.  I C finns det många olika sätt att "
"placera parenteserna. När man har vant sig vid att läsa och skriva kod i en "
"viss stil är det normalt att känna sig lite illa till mods när man läser "
"(eller måste skriva) i en annan stil."

msgid ""
"Many coding styles place begin/end brackets on a line by themselves.  This "
"makes programs considerably longer and wastes valuable screen space, making "
"it harder to get a good overview of a program.  Ideally, a function should "
"fit on one screen (say, 20--30 lines).  20 lines of Python can do a lot more "
"work than 20 lines of C.  This is not solely due to the lack of begin/end "
"brackets -- the lack of declarations and the high-level data types are also "
"responsible -- but the indentation-based syntax certainly helps."
msgstr ""
"Många kodningsstilar placerar start- och slutparenteser på en rad för sig "
"själva.  Detta gör programmen betydligt längre och slösar bort värdefullt "
"skärmutrymme, vilket gör det svårare att få en bra överblick över ett "
"program.  Helst bör en funktion rymmas på en skärm (säg 20--30 rader).  20 "
"rader Python kan göra mycket mer arbete än 20 rader C. Detta beror inte "
"enbart på avsaknaden av begin/end-parenteser - avsaknaden av deklarationer "
"och datatyperna på hög nivå är också ansvariga - men den indragningsbaserade "
"syntaxen hjälper verkligen till."

msgid "Why am I getting strange results with simple arithmetic operations?"
msgstr "Varför får jag konstiga resultat med enkla aritmetiska operationer?"

msgid "See the next question."
msgstr "Se nästa fråga."

msgid "Why are floating-point calculations so inaccurate?"
msgstr "Varför är flyttalsberäkningar så felaktiga?"

msgid "Users are often surprised by results like this::"
msgstr "Användarna blir ofta överraskade av resultat som detta::"

msgid ""
">>> 1.2 - 1.0\n"
"0.19999999999999996"
msgstr ""
">>> 1.2 - 1.0\n"
"0.19999999999999996"

msgid ""
"and think it is a bug in Python.  It's not.  This has little to do with "
"Python, and much more to do with how the underlying platform handles "
"floating-point numbers."
msgstr ""
"och tror att det är en bugg i Python.  Men det är det inte.  Det har lite "
"att göra med Python och mycket mer att göra med hur den underliggande "
"plattformen hanterar flyttal."

msgid ""
"The :class:`float` type in CPython uses a C ``double`` for storage.  A :"
"class:`float` object's value is stored in binary floating-point with a fixed "
"precision (typically 53 bits) and Python uses C operations, which in turn "
"rely on the hardware implementation in the processor, to perform floating-"
"point operations. This means that as far as floating-point operations are "
"concerned, Python behaves like many popular languages including C and Java."
msgstr ""
"Typen :class:`float` i CPython använder en C ``double`` för lagring.  Ett :"
"class:`float`-objekts värde lagras i binär flyttalsräkning med en fast "
"precision (vanligtvis 53 bitar) och Python använder C-operationer, som i sin "
"tur förlitar sig på maskinvaruimplementeringen i processorn, för att utföra "
"flyttalsoperationer. Detta innebär att när det gäller flyttalsoperationer "
"beter sig Python som många populära språk, inklusive C och Java."

msgid ""
"Many numbers that can be written easily in decimal notation cannot be "
"expressed exactly in binary floating point.  For example, after::"
msgstr ""
"Många tal som enkelt kan skrivas i decimalnotation kan inte uttryckas exakt "
"i binär flyttal.  Till exempel efter::"

msgid ">>> x = 1.2"
msgstr ">>> x = 1.2"

msgid ""
"the value stored for ``x`` is a (very good) approximation to the decimal "
"value ``1.2``, but is not exactly equal to it.  On a typical machine, the "
"actual stored value is::"
msgstr ""
"det lagrade värdet för ``x`` är en (mycket god) approximation av "
"decimalvärdet ``1,2``, men är inte exakt lika med det.  På en typisk maskin "
"är det faktiska lagrade värdet::"

msgid "1.0011001100110011001100110011001100110011001100110011 (binary)"
msgstr "1.0011001100110011001100110011001100110011001100110011 (binary)"

msgid "which is exactly::"
msgstr "vilket är exakt::"

msgid "1.1999999999999999555910790149937383830547332763671875 (decimal)"
msgstr "1.1999999999999999555910790149937383830547332763671875 (decimal)"

msgid ""
"The typical precision of 53 bits provides Python floats with 15--16 decimal "
"digits of accuracy."
msgstr ""
"Den typiska precisionen på 53 bitar ger Python floats med 15-16 decimalers "
"noggrannhet."

msgid ""
"For a fuller explanation, please see the :ref:`floating-point arithmetic "
"<tut-fp-issues>` chapter in the Python tutorial."
msgstr ""
"För en fullständigare förklaring, se :ref:``floating-point arithmetic <tut-"
"fp-issues>` kapitlet i Python-handledningen."

msgid "Why are Python strings immutable?"
msgstr "Varför är Python-strängar oföränderliga?"

msgid "There are several advantages."
msgstr "Det finns flera fördelar."

msgid ""
"One is performance: knowing that a string is immutable means we can allocate "
"space for it at creation time, and the storage requirements are fixed and "
"unchanging.  This is also one of the reasons for the distinction between "
"tuples and lists."
msgstr ""
"Det ena är prestanda: att veta att en sträng är oföränderlig innebär att vi "
"kan allokera utrymme för den vid skapandet och att lagringskraven är fasta "
"och oföränderliga.  Detta är också en av anledningarna till skillnaden "
"mellan tupler och listor."

msgid ""
"Another advantage is that strings in Python are considered as \"elemental\" "
"as numbers.  No amount of activity will change the value 8 to anything else, "
"and in Python, no amount of activity will change the string \"eight\" to "
"anything else."
msgstr ""
"En annan fördel är att strängar i Python betraktas som lika \"elementära\" "
"som siffror.  Ingen aktivitet kan ändra värdet 8 till något annat, och i "
"Python kan ingen aktivitet ändra strängen \"åtta\" till något annat."

msgid "Why must 'self' be used explicitly in method definitions and calls?"
msgstr "Varför måste \"self\" användas explicit i metoddefinitioner och anrop?"

msgid ""
"The idea was borrowed from Modula-3.  It turns out to be very useful, for a "
"variety of reasons."
msgstr ""
"Idén har lånats från Modula-3.  Den visar sig vara mycket användbar av flera "
"olika skäl."

msgid ""
"First, it's more obvious that you are using a method or instance attribute "
"instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it "
"absolutely clear that an instance variable or method is used even if you "
"don't know the class definition by heart.  In C++, you can sort of tell by "
"the lack of a local variable declaration (assuming globals are rare or "
"easily recognizable) -- but in Python, there are no local variable "
"declarations, so you'd have to look up the class definition to be sure.  "
"Some C++ and Java coding standards call for instance attributes to have an "
"``m_`` prefix, so this explicitness is still useful in those languages, too."
msgstr ""
"För det första är det mer uppenbart att du använder en metod eller ett "
"instansattribut istället för en lokal variabel.  Att läsa ``self.x`` eller "
"``self.meth()`` gör det helt klart att en instansvariabel eller metod "
"används även om du inte kan klassdefinitionen utantill.  I C++ kan du på "
"sätt och vis se det genom att det inte finns någon lokal variabeldeklaration "
"(förutsatt att globaler är sällsynta eller lätt igenkännliga) - men i Python "
"finns det inga lokala variabeldeklarationer, så du måste slå upp "
"klassdefinitionen för att vara säker.  Vissa C++- och Java-"
"kodningsstandarder kräver att instansattribut har ett ``m_``-prefix, så "
"detta uttryck är fortfarande användbart i dessa språk också."

msgid ""
"Second, it means that no special syntax is necessary if you want to "
"explicitly reference or call the method from a particular class.  In C++, if "
"you want to use a method from a base class which is overridden in a derived "
"class, you have to use the ``::`` operator -- in Python you can write "
"``baseclass.methodname(self, <argument list>)``.  This is particularly "
"useful for :meth:`~object.__init__` methods, and in general in cases where a "
"derived class method wants to extend the base class method of the same name "
"and thus has to call the base class method somehow."
msgstr ""
"För det andra innebär det att ingen speciell syntax är nödvändig om du "
"uttryckligen vill referera till eller anropa metoden från en viss klass.  I "
"C++ måste man använda operatorn ``::`` om man vill använda en metod från en "
"basklass som åsidosätts i en härledd klass - i Python kan man skriva "
"``baseclass.methodname(self, <argument list>)``.  Detta är särskilt "
"användbart för :meth:`~object.__init__`-metoder, och i allmänhet i fall där "
"en härledd klassmetod vill utöka basklassmetoden med samma namn och därmed "
"måste anropa basklassmetoden på något sätt."

msgid ""
"Finally, for instance variables it solves a syntactic problem with "
"assignment: since local variables in Python are (by definition!) those "
"variables to which a value is assigned in a function body (and that aren't "
"explicitly declared global), there has to be some way to tell the "
"interpreter that an assignment was meant to assign to an instance variable "
"instead of to a local variable, and it should preferably be syntactic (for "
"efficiency reasons).  C++ does this through declarations, but Python doesn't "
"have declarations and it would be a pity having to introduce them just for "
"this purpose.  Using the explicit ``self.var`` solves this nicely.  "
"Similarly, for using instance variables, having to write ``self.var`` means "
"that references to unqualified names inside a method don't have to search "
"the instance's directories.  To put it another way, local variables and "
"instance variables live in two different namespaces, and you need to tell "
"Python which namespace to use."
msgstr ""
"Slutligen, för instansvariabler löser det ett syntaktiskt problem med "
"tilldelning: eftersom lokala variabler i Python är (per definition!) de "
"variabler till vilka ett värde tilldelas i en funktionskropp (och som inte "
"uttryckligen förklaras globala), måste det finnas något sätt att berätta för "
"tolken att en tilldelning var avsedd att tilldela en instansvariabel "
"istället för en lokal variabel, och det bör helst vara syntaktiskt (av "
"effektivitetsskäl).  C++ gör detta genom deklarationer, men Python har inte "
"deklarationer och det skulle vara synd att behöva införa dem bara för detta "
"ändamål.  Att använda den explicita ``self.var`` löser detta snyggt.  På "
"samma sätt, för användning av instansvariabler, innebär att behöva skriva "
"``self.var`` att referenser till okvalificerade namn i en metod inte behöver "
"söka i instansens kataloger.  För att uttrycka det på ett annat sätt lever "
"lokala variabler och instansvariabler i två olika namnrymder, och du måste "
"berätta för Python vilket namnrymd som ska användas."

msgid "Why can't I use an assignment in an expression?"
msgstr "Varför kan jag inte använda en tilldelning i ett uttryck?"

msgid "Starting in Python 3.8, you can!"
msgstr "Från och med Python 3.8 kan du göra det!"

msgid ""
"Assignment expressions using the walrus operator ``:=`` assign a variable in "
"an expression::"
msgstr ""
"Tilldelningsuttryck med hjälp av valrossoperatorn ``:=`` tilldela en "
"variabel i ett uttryck::"

msgid ""
"while chunk := fp.read(200):\n"
"   print(chunk)"
msgstr ""
"while chunk := fp.read(200):\n"
"   print(chunk)"

msgid "See :pep:`572` for more information."
msgstr "Se :pep:`572` för mer information."

msgid ""
"Why does Python use methods for some functionality (e.g. list.index()) but "
"functions for other (e.g. len(list))?"
msgstr ""
"Varför använder Python metoder för vissa funktioner (t.ex. list.index()) men "
"funktioner för andra (t.ex. len(list))?"

msgid "As Guido said:"
msgstr "Som Guido sa:"

msgid ""
"(a) For some operations, prefix notation just reads better than postfix -- "
"prefix (and infix!) operations have a long tradition in mathematics which "
"likes notations where the visuals help the mathematician thinking about a "
"problem. Compare the easy with which we rewrite a formula like x*(a+b) into "
"x*a + x*b to the clumsiness of doing the same thing using a raw OO notation."
msgstr ""
"(a) För vissa operationer är prefixnotation helt enkelt bättre än postfix -- "
"prefix (och infix!) operationer har en lång tradition inom matematiken som "
"gillar notationer där det visuella hjälper matematikern att tänka på ett "
"problem. Jämför hur lätt det är att skriva om en formel som x*(a+b) till x*a "
"+ x*b med hur klumpigt det är att göra samma sak med en rå OO-notation."

msgid ""
"(b) When I read code that says len(x) I *know* that it is asking for the "
"length of something. This tells me two things: the result is an integer, and "
"the argument is some kind of container. To the contrary, when I read x."
"len(), I have to already know that x is some kind of container implementing "
"an interface or inheriting from a class that has a standard len(). Witness "
"the confusion we occasionally have when a class that is not implementing a "
"mapping has a get() or keys() method, or something that isn't a file has a "
"write() method."
msgstr ""
"(b) När jag läser kod som säger len(x) *vet* jag att den frågar efter "
"längden på något. Detta säger mig två saker: resultatet är ett heltal, och "
"argumentet är någon form av behållare. Tvärtom, när jag läser x.len() måste "
"jag redan veta att x är någon form av container som implementerar ett "
"gränssnitt eller ärver från en klass som har en standard len(). Tänk på den "
"förvirring som ibland uppstår när en klass som inte implementerar en "
"mappning har en get()- eller keys()-metod, eller när något som inte är en "
"fil har en write()-metod."

msgid "https://mail.python.org/pipermail/python-3000/2006-November/004643.html"
msgstr ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"

msgid "Why is join() a string method instead of a list or tuple method?"
msgstr ""
"Varför är join() en strängmetod istället för en list- eller tupelmetod?"

msgid ""
"Strings became much more like other standard types starting in Python 1.6, "
"when methods were added which give the same functionality that has always "
"been available using the functions of the string module.  Most of these new "
"methods have been widely accepted, but the one which appears to make some "
"programmers feel uncomfortable is::"
msgstr ""
"Strängar blev mycket mer lika andra standardtyper från och med Python 1.6, "
"när metoder lades till som ger samma funktionalitet som alltid har varit "
"tillgänglig med hjälp av funktionerna i strängmodulen.  De flesta av dessa "
"nya metoder har blivit allmänt accepterade, men den som verkar få en del "
"programmerare att känna sig obekväma är::"

msgid "\", \".join(['1', '2', '4', '8', '16'])"
msgstr "\", \".join(['1', '2', '4', '8', '16'])"

msgid "which gives the result::"
msgstr "vilket ger resultatet::"

msgid "\"1, 2, 4, 8, 16\""
msgstr "\"1, 2, 4, 8, 16\""

msgid "There are two common arguments against this usage."
msgstr "Det finns två vanliga argument mot denna användning."

msgid ""
"The first runs along the lines of: \"It looks really ugly using a method of "
"a string literal (string constant)\", to which the answer is that it might, "
"but a string literal is just a fixed value. If the methods are to be allowed "
"on names bound to strings there is no logical reason to make them "
"unavailable on literals."
msgstr ""
"Den första går i linje med: \"Det ser riktigt fult ut att använda en metod "
"för en stränglitteral (strängkonstant)\", varpå svaret är att det kan det "
"göra, men en stränglitteral är bara ett fast värde. Om metoderna ska vara "
"tillåtna för namn som är bundna till strängar finns det ingen logisk "
"anledning att göra dem otillgängliga för bokstavliga värden."

msgid ""
"The second objection is typically cast as: \"I am really telling a sequence "
"to join its members together with a string constant\".  Sadly, you aren't.  "
"For some reason there seems to be much less difficulty with having :meth:"
"`~str.split` as a string method, since in that case it is easy to see that ::"
msgstr ""
"Den andra invändningen brukar formuleras som: \"Jag säger verkligen till en "
"sekvens att sammanfoga sina medlemmar med en strängkonstant\".  Tyvärr gör "
"du inte det.  Av någon anledning verkar det vara mycket mindre svårt att ha :"
"meth:`~str.split` som en strängmetod, eftersom det i så fall är lätt att se "
"att ::"

msgid "\"1, 2, 4, 8, 16\".split(\", \")"
msgstr "\"1, 2, 4, 8, 16\".split(\", \")"

msgid ""
"is an instruction to a string literal to return the substrings delimited by "
"the given separator (or, by default, arbitrary runs of white space)."
msgstr ""
"är en instruktion till en stränglitual att returnera delsträngarna som "
"avgränsas av den angivna separatorn (eller, som standard, godtyckliga "
"sträckor med vitt utrymme)."

msgid ""
":meth:`~str.join` is a string method because in using it you are telling the "
"separator string to iterate over a sequence of strings and insert itself "
"between adjacent elements.  This method can be used with any argument which "
"obeys the rules for sequence objects, including any new classes you might "
"define yourself. Similar methods exist for bytes and bytearray objects."
msgstr ""
":meth:`~str.join` är en strängmetod eftersom du genom att använda den säger "
"till separatorsträngen att iterera över en sekvens av strängar och infoga "
"sig själv mellan intilliggande element.  Den här metoden kan användas med "
"alla argument som följer reglerna för sekvensobjekt, inklusive alla nya "
"klasser som du själv kan definiera. Liknande metoder finns för bytes och "
"bytearray-objekt."

msgid "How fast are exceptions?"
msgstr "Hur snabba är undantagen?"

msgid ""
"A :keyword:`try`/:keyword:`except` block is extremely efficient if no "
"exceptions are raised.  Actually catching an exception is expensive.  In "
"versions of Python prior to 2.0 it was common to use this idiom::"
msgstr ""
"Ett :keyword:`try`/:keyword:`except`-block är extremt effektivt om inga "
"undantag uppstår.  Att faktiskt fånga ett undantag är dyrt.  I versioner av "
"Python före 2.0 var det vanligt att använda detta idiom::"

msgid ""
"try:\n"
"    value = mydict[key]\n"
"except KeyError:\n"
"    mydict[key] = getvalue(key)\n"
"    value = mydict[key]"
msgstr ""
"försök:\n"
"    värde = mydict[nyckel]\n"
"except KeyError:\n"
"    mydict[nyckel] = getvalue(nyckel)\n"
"    värde = mydict[nyckel]"

msgid ""
"This only made sense when you expected the dict to have the key almost all "
"the time.  If that wasn't the case, you coded it like this::"
msgstr ""
"Detta var bara meningsfullt när du förväntade dig att dict skulle ha nyckeln "
"nästan hela tiden.  Om så inte var fallet kodade du det så här::"

msgid ""
"if key in mydict:\n"
"    value = mydict[key]\n"
"else:\n"
"    value = mydict[key] = getvalue(key)"
msgstr ""
"om nyckel i mydict:\n"
"    värde = mydict[nyckel]\n"
"annat:\n"
"    värde = mydict[nyckel] = getvalue(nyckel)"

msgid ""
"For this specific case, you could also use ``value = dict.setdefault(key, "
"getvalue(key))``, but only if the ``getvalue()`` call is cheap enough "
"because it is evaluated in all cases."
msgstr ""
"För detta specifika fall kan du också använda ``value = dict.setdefault(key, "
"getvalue(key))``, men bara om ``getvalue()``-anropet är tillräckligt billigt "
"eftersom det utvärderas i alla fall."

msgid "Why isn't there a switch or case statement in Python?"
msgstr "Varför finns det inte en switch- eller case-sats i Python?"

msgid ""
"In general, structured switch statements execute one block of code when an "
"expression has a particular value or set of values. Since Python 3.10 one "
"can easily match literal values, or constants within a namespace, with a "
"``match ... case`` statement. An older alternative is a sequence of ``if... "
"elif... elif... else``."
msgstr ""
"I allmänhet exekverar strukturerade switch-satser ett kodblock när ett "
"uttryck har ett visst värde eller en viss uppsättning värden. Sedan Python "
"3.10 kan man enkelt matcha bokstavliga värden, eller konstanter inom ett "
"namnområde, med en ``match ... case``-sats. Ett äldre alternativ är en "
"sekvens av ``if... elif... elif... else``."

msgid ""
"For cases where you need to choose from a very large number of "
"possibilities, you can create a dictionary mapping case values to functions "
"to call.  For example::"
msgstr ""
"I fall där du måste välja bland ett mycket stort antal möjligheter kan du "
"skapa en ordbok som mappar fallvärden till funktioner som ska anropas.  Till "
"exempel::"

msgid ""
"functions = {'a': function_1,\n"
"             'b': function_2,\n"
"             'c': self.method_1}\n"
"\n"
"func = functions[value]\n"
"func()"
msgstr ""
"functions = {'a': funktion_1,\n"
"             'b': funktion_2,\n"
"             'c': self.method_1}\n"
"\n"
"func = funktioner[värde]\n"
"func()"

msgid ""
"For calling methods on objects, you can simplify yet further by using the :"
"func:`getattr` built-in to retrieve methods with a particular name::"
msgstr ""
"För att anropa metoder på objekt kan du förenkla ytterligare genom att "
"använda den inbyggda :func:`getattr` för att hämta metoder med ett visst "
"namn::"

msgid ""
"class MyVisitor:\n"
"    def visit_a(self):\n"
"        ...\n"
"\n"
"    def dispatch(self, value):\n"
"        method_name = 'visit_' + str(value)\n"
"        method = getattr(self, method_name)\n"
"        method()"
msgstr ""
"klass MyVisitor:\n"
"    def visit_a(self):\n"
"        ...\n"
"\n"
"    def dispatch(self, värde):\n"
"        method_name = 'visit_' + str(värde)\n"
"        method = getattr(self, method_name)\n"
"        metod()"

msgid ""
"It's suggested that you use a prefix for the method names, such as "
"``visit_`` in this example.  Without such a prefix, if values are coming "
"from an untrusted source, an attacker would be able to call any method on "
"your object."
msgstr ""
"Vi föreslår att du använder ett prefix för metodnamnen, t.ex. ``visit_`` i "
"det här exemplet.  Utan ett sådant prefix skulle en angripare kunna anropa "
"vilken metod som helst på ditt objekt om värdena kommer från en icke betrodd "
"källa."

msgid ""
"Imitating switch with fallthrough, as with C's switch-case-default, is "
"possible, much harder, and less needed."
msgstr ""
"Att imitera switch med fallthrough, som med C:s switch-case-default, är "
"möjligt, men mycket svårare och mindre nödvändigt."

msgid ""
"Can't you emulate threads in the interpreter instead of relying on an OS-"
"specific thread implementation?"
msgstr ""
"Kan du inte emulera trådar i tolken istället för att förlita dig på en OS-"
"specifik trådimplementering?"

msgid ""
"Answer 1: Unfortunately, the interpreter pushes at least one C stack frame "
"for each Python stack frame.  Also, extensions can call back into Python at "
"almost random moments.  Therefore, a complete threads implementation "
"requires thread support for C."
msgstr ""
"Svar 1: Tyvärr skjuter tolken minst en C-stackram för varje Python-"
"stackram.  Dessutom kan tillägg anropa tillbaka till Python vid nästan "
"slumpmässiga tillfällen.  Därför kräver en fullständig implementering av "
"trådar trådstöd för C."

msgid ""
"Answer 2: Fortunately, there is `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, which has a completely redesigned "
"interpreter loop that avoids the C stack."
msgstr ""
"Svar 2: Lyckligtvis finns det `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, som har en helt omdesignad tolkslinga som "
"undviker C-stacken."

msgid "Why can't lambda expressions contain statements?"
msgstr "Varför kan inte lambda-uttryck innehålla uttalanden?"

msgid ""
"Python lambda expressions cannot contain statements because Python's "
"syntactic framework can't handle statements nested inside expressions.  "
"However, in Python, this is not a serious problem.  Unlike lambda forms in "
"other languages, where they add functionality, Python lambdas are only a "
"shorthand notation if you're too lazy to define a function."
msgstr ""
"Lambdauttryck i Python kan inte innehålla satser eftersom Pythons "
"syntaktiska ramverk inte kan hantera satser som är kapslade i uttryck.  I "
"Python är detta dock inte ett allvarligt problem.  Till skillnad från lambda-"
"former i andra språk, där de lägger till funktionalitet, är Python-lambdas "
"bara en kortfattad notation om du är för lat för att definiera en funktion."

msgid ""
"Functions are already first class objects in Python, and can be declared in "
"a local scope.  Therefore the only advantage of using a lambda instead of a "
"locally defined function is that you don't need to invent a name for the "
"function -- but that's just a local variable to which the function object "
"(which is exactly the same type of object that a lambda expression yields) "
"is assigned!"
msgstr ""
"Funktioner är redan förstaklassobjekt i Python och kan deklareras i ett "
"lokalt scope.  Därför är den enda fördelen med att använda en lambda "
"istället för en lokalt definierad funktion att du inte behöver hitta på ett "
"namn för funktionen - men det är bara en lokal variabel som "
"funktionsobjektet (som är exakt samma typ av objekt som ett lambdauttryck "
"ger) tilldelas!"

msgid "Can Python be compiled to machine code, C or some other language?"
msgstr "Kan Python kompileras till maskinkod, C eller något annat språk?"

msgid ""
"`Cython <https://cython.org/>`_ compiles a modified version of Python with "
"optional annotations into C extensions.  `Nuitka <https://nuitka.net/>`_ is "
"an up-and-coming compiler of Python into C++ code, aiming to support the "
"full Python language."
msgstr ""
"`Cython <https://cython.org/>`_ kompilerar en modifierad version av Python "
"med valfria anteckningar till C-tillägg.  `Nuitka <https://nuitka.net/>`_ är "
"en kommande kompilator av Python till C++-kod, med målet att stödja hela "
"Python-språket."

msgid "How does Python manage memory?"
msgstr "Hur hanterar Python minne?"

msgid ""
"The details of Python memory management depend on the implementation.  The "
"standard implementation of Python, :term:`CPython`, uses reference counting "
"to detect inaccessible objects, and another mechanism to collect reference "
"cycles, periodically executing a cycle detection algorithm which looks for "
"inaccessible cycles and deletes the objects involved. The :mod:`gc` module "
"provides functions to perform a garbage collection, obtain debugging "
"statistics, and tune the collector's parameters."
msgstr ""
"Detaljerna i Pythons minneshantering beror på implementeringen.  "
"Standardimplementationen av Python, :term:`CPython`, använder "
"referensräkning för att upptäcka otillgängliga objekt och en annan mekanism "
"för att samla in referenscykler genom att periodiskt köra en algoritm för "
"cykeldetektering som letar efter otillgängliga cykler och raderar de "
"inblandade objekten. Modulen :mod:`gc` innehåller funktioner för att utföra "
"en skräpinsamling, få felsökningsstatistik och ställa in insamlarens "
"parametrar."

msgid ""
"Other implementations (such as `Jython <https://www.jython.org>`_ or `PyPy "
"<https://pypy.org>`_), however, can rely on a different mechanism such as a "
"full-blown garbage collector.  This difference can cause some subtle porting "
"problems if your Python code depends on the behavior of the reference "
"counting implementation."
msgstr ""
"Andra implementationer (t.ex. `Jython <https://www.jython.org>`_ eller `PyPy "
"<https://pypy.org>`_) kan dock förlita sig på en annan mekanism, t.ex. en "
"fullfjädrad skräpsamlare.  Denna skillnad kan orsaka vissa subtila "
"portningsproblem om din Python-kod är beroende av beteendet hos "
"referensräkningsimplementeringen."

msgid ""
"In some Python implementations, the following code (which is fine in "
"CPython) will probably run out of file descriptors::"
msgstr ""
"I vissa Python-implementationer kommer följande kod (som fungerar bra i "
"CPython) förmodligen att få slut på filbeskrivare::"

msgid ""
"for file in very_long_list_of_files:\n"
"    f = open(file)\n"
"    c = f.read(1)"
msgstr ""
"för file i very_long_list_of_files:\n"
"    f = öppna(fil)\n"
"    c = f.read(1)"

msgid ""
"Indeed, using CPython's reference counting and destructor scheme, each new "
"assignment to ``f`` closes the previous file.  With a traditional GC, "
"however, those file objects will only get collected (and closed) at varying "
"and possibly long intervals."
msgstr ""
"Genom att använda CPythons referensräkning och destruktorschema stänger "
"varje ny tilldelning till ``f`` den föregående filen.  Med en traditionell "
"GC kommer dock dessa filobjekt endast att samlas in (och stängas) med "
"varierande och eventuellt långa intervall."

msgid ""
"If you want to write code that will work with any Python implementation, you "
"should explicitly close the file or use the :keyword:`with` statement; this "
"will work regardless of memory management scheme::"
msgstr ""
"Om du vill skriva kod som fungerar med alla Python-implementationer bör du "
"uttryckligen stänga filen eller använda :keyword:`with`-satsen; detta "
"fungerar oavsett minneshanteringsschema::"

msgid ""
"for file in very_long_list_of_files:\n"
"    with open(file) as f:\n"
"        c = f.read(1)"
msgstr ""
"för fil i very_long_list_of_files:\n"
"    med open(file) som f:\n"
"        c = f.read(1)"

msgid "Why doesn't CPython use a more traditional garbage collection scheme?"
msgstr ""
"Varför använder inte CPython ett mer traditionellt skräpuppsamlingsschema?"

msgid ""
"For one thing, this is not a C standard feature and hence it's not portable. "
"(Yes, we know about the Boehm GC library.  It has bits of assembler code for "
"*most* common platforms, not for all of them, and although it is mostly "
"transparent, it isn't completely transparent; patches are required to get "
"Python to work with it.)"
msgstr ""
"För en sak är detta inte en C-standardfunktion och därför är den inte "
"bärbar. (Ja, vi känner till Boehm GC-biblioteket.  Det har bitar av "
"assemblerkod för * de flesta * vanliga plattformar, inte för dem alla, och "
"även om det mestadels är transparent är det inte helt transparent; patchar "
"krävs för att få Python att fungera med det)"

msgid ""
"Traditional GC also becomes a problem when Python is embedded into other "
"applications.  While in a standalone Python it's fine to replace the "
"standard ``malloc()`` and ``free()`` with versions provided by the GC "
"library, an application embedding Python may want to have its *own* "
"substitute for ``malloc()`` and ``free()``, and may not want Python's.  "
"Right now, CPython works with anything that implements ``malloc()`` and "
"``free()`` properly."
msgstr ""
"Traditionell GC blir också ett problem när Python är inbäddat i andra "
"applikationer.  Medan det i ett fristående Python går bra att ersätta "
"standard ``malloc()`` och ``free()`` med versioner som tillhandahålls av GC-"
"biblioteket, kanske en applikation som bäddar in Python vill ha sitt *egna* "
"substitut för ``malloc()`` och ``free()``, och kanske inte vill ha Pythons.  "
"Just nu fungerar CPython med allt som implementerar ``malloc()`` och "
"``free()`` på rätt sätt."

msgid "Why isn't all memory freed when CPython exits?"
msgstr "Varför frigörs inte allt minne när CPython avslutas?"

msgid ""
"Objects referenced from the global namespaces of Python modules are not "
"always deallocated when Python exits.  This may happen if there are circular "
"references.  There are also certain bits of memory that are allocated by the "
"C library that are impossible to free (e.g. a tool like Purify will complain "
"about these).  Python is, however, aggressive about cleaning up memory on "
"exit and does try to destroy every single object."
msgstr ""
"Objekt som refereras från Python-modulernas globala namnrymder avallokeras "
"inte alltid när Python avslutas.  Detta kan hända om det finns cirkulära "
"referenser.  Det finns också vissa minnesbitar som allokeras av C-"
"biblioteket som är omöjliga att frigöra (t.ex. kommer ett verktyg som Purify "
"att klaga på dessa).  Python är dock aggressiv när det gäller att städa upp "
"minnet vid avslut och försöker förstöra varje enskilt objekt."

msgid ""
"If you want to force Python to delete certain things on deallocation use "
"the :mod:`atexit` module to run a function that will force those deletions."
msgstr ""
"Om du vill tvinga Python att ta bort vissa saker vid deallokering, använd "
"modulen :mod:`atexit` för att köra en funktion som tvingar fram dessa "
"borttagningar."

msgid "Why are there separate tuple and list data types?"
msgstr "Varför finns det separata datatyper för tuplar och listor?"

msgid ""
"Lists and tuples, while similar in many respects, are generally used in "
"fundamentally different ways.  Tuples can be thought of as being similar to "
"Pascal ``records`` or C ``structs``; they're small collections of related "
"data which may be of different types which are operated on as a group.  For "
"example, a Cartesian coordinate is appropriately represented as a tuple of "
"two or three numbers."
msgstr ""
"Listor och tuplar är visserligen lika i många avseenden, men används i "
"allmänhet på fundamentalt olika sätt.  Tuples kan liknas vid Pascals "
"\"records\" eller C:s \"structures\"; de är små samlingar av relaterade data "
"som kan vara av olika typer och som hanteras som en grupp.  Till exempel kan "
"en kartesisk koordinat representeras som en tupel av två eller tre tal."

msgid ""
"Lists, on the other hand, are more like arrays in other languages.  They "
"tend to hold a varying number of objects all of which have the same type and "
"which are operated on one-by-one.  For example, :func:`os.listdir('.') <os."
"listdir>` returns a list of strings representing the files in the current "
"directory.  Functions which operate on this output would generally not break "
"if you added another file or two to the directory."
msgstr ""
"Listor, å andra sidan, är mer som matriser i andra språk.  De tenderar att "
"innehålla ett varierande antal objekt som alla har samma typ och som "
"bearbetas ett och ett.  Exempelvis returnerar :func:`os.listdir('.') <os."
"listdir>` en lista med strängar som representerar filerna i den aktuella "
"katalogen.  Funktioner som arbetar med denna utdata skulle i allmänhet inte "
"brytas om du lägger till ytterligare en fil eller två i katalogen."

msgid ""
"Tuples are immutable, meaning that once a tuple has been created, you can't "
"replace any of its elements with a new value.  Lists are mutable, meaning "
"that you can always change a list's elements.  Only immutable elements can "
"be used as dictionary keys, and hence only tuples and not lists can be used "
"as keys."
msgstr ""
"Tuplar är oföränderliga, vilket innebär att när en tupel har skapats kan du "
"inte ersätta något av dess element med ett nytt värde.  Listor är mutabla, "
"vilket innebär att du alltid kan ändra en listas element.  Endast "
"oföränderliga element kan användas som nycklar i en ordbok, och därför kan "
"endast tuplar och inte listor användas som nycklar."

msgid "How are lists implemented in CPython?"
msgstr "Hur implementeras listor i CPython?"

msgid ""
"CPython's lists are really variable-length arrays, not Lisp-style linked "
"lists. The implementation uses a contiguous array of references to other "
"objects, and keeps a pointer to this array and the array's length in a list "
"head structure."
msgstr ""
"CPythons listor är egentligen arrayer med variabel längd, inte länkade "
"listor i Lisp-stil. Implementeringen använder en sammanhängande matris med "
"referenser till andra objekt och håller en pekare till denna matris och "
"matrisens längd i en listhuvudstruktur."

msgid ""
"This makes indexing a list ``a[i]`` an operation whose cost is independent "
"of the size of the list or the value of the index."
msgstr ""
"Detta gör indexeringen av en lista ``a[i]`` till en operation vars kostnad "
"är oberoende av listans storlek eller indexets värde."

msgid ""
"When items are appended or inserted, the array of references is resized.  "
"Some cleverness is applied to improve the performance of appending items "
"repeatedly; when the array must be grown, some extra space is allocated so "
"the next few times don't require an actual resize."
msgstr ""
"När objekt läggs till eller infogas ändras storleken på referensmatrisen.  "
"En del smarthet används för att förbättra prestandan för att lägga till "
"objekt upprepade gånger; när matrisen måste växa tilldelas lite extra "
"utrymme så att de närmaste gångerna inte kräver en faktisk storleksändring."

msgid "How are dictionaries implemented in CPython?"
msgstr "Hur implementeras ordböcker i CPython?"

msgid ""
"CPython's dictionaries are implemented as resizable hash tables.  Compared "
"to B-trees, this gives better performance for lookup (the most common "
"operation by far) under most circumstances, and the implementation is "
"simpler."
msgstr ""
"CPythons ordböcker är implementerade som hashtabeller som kan ändras i "
"storlek.  Jämfört med B-träd ger detta bättre prestanda för uppslagning (den "
"överlägset vanligaste operationen) under de flesta omständigheter, och "
"implementeringen är enklare."

msgid ""
"Dictionaries work by computing a hash code for each key stored in the "
"dictionary using the :func:`hash` built-in function.  The hash code varies "
"widely depending on the key and a per-process seed; for example, "
"``'Python'`` could hash to ``-539294296`` while ``'python'``, a string that "
"differs by a single bit, could hash to ``1142331976``.  The hash code is "
"then used to calculate a location in an internal array where the value will "
"be stored.  Assuming that you're storing keys that all have different hash "
"values, this means that dictionaries take constant time -- *O*\\ (1), in Big-"
"O notation -- to retrieve a key."
msgstr ""
"Dictionaries fungerar genom att beräkna en hashkod för varje nyckel som "
"lagras i dictionariet med hjälp av den inbyggda funktionen :func:`hash`.  "
"Hashkoden varierar mycket beroende på nyckeln och ett processspecifikt frö; "
"till exempel kan ``'Python'`` hasha till ``-539294296`` medan ``'python'``, "
"en sträng som skiljer sig åt med en enda bit, kan hasha till "
"``1142331976``.  Hashkoden används sedan för att beräkna en plats i en "
"intern array där värdet kommer att lagras.  Om vi antar att du lagrar "
"nycklar som alla har olika hashvärden innebär det att det tar konstant tid - "
"*O*\\(1), i Big-O-notation - att hämta en nyckel."

msgid "Why must dictionary keys be immutable?"
msgstr "Varför måste nycklar i ordböcker vara oföränderliga?"

msgid ""
"The hash table implementation of dictionaries uses a hash value calculated "
"from the key value to find the key.  If the key were a mutable object, its "
"value could change, and thus its hash could also change.  But since whoever "
"changes the key object can't tell that it was being used as a dictionary "
"key, it can't move the entry around in the dictionary.  Then, when you try "
"to look up the same object in the dictionary it won't be found because its "
"hash value is different. If you tried to look up the old value it wouldn't "
"be found either, because the value of the object found in that hash bin "
"would be different."
msgstr ""
"Implementeringen av hashtabeller för ordböcker använder ett hashvärde som "
"beräknas utifrån nyckelvärdet för att hitta nyckeln.  Om nyckeln var ett "
"föränderligt objekt skulle dess värde kunna ändras, och därmed skulle dess "
"hashvärde också kunna ändras.  Men eftersom den som ändrar nyckelobjektet "
"inte kan se att det användes som en ordboksnyckel, kan den inte flytta runt "
"posten i ordboken.  När du sedan försöker slå upp samma objekt i ordboken "
"kommer det inte att hittas eftersom dess hashvärde är annorlunda. Om du "
"försöker slå upp det gamla värdet kommer det inte heller att hittas, "
"eftersom värdet på det objekt som finns i den hashbins skulle vara "
"annorlunda."

msgid ""
"If you want a dictionary indexed with a list, simply convert the list to a "
"tuple first; the function ``tuple(L)`` creates a tuple with the same entries "
"as the list ``L``.  Tuples are immutable and can therefore be used as "
"dictionary keys."
msgstr ""
"Om du vill ha en ordbok indexerad med en lista konverterar du helt enkelt "
"listan till en tupel först; funktionen ``tuple(L)`` skapar en tupel med "
"samma poster som listan ``L``.  Tuples är oföränderliga och kan därför "
"användas som nycklar i en ordbok."

msgid "Some unacceptable solutions that have been proposed:"
msgstr "Några oacceptabla lösningar som har föreslagits:"

msgid ""
"Hash lists by their address (object ID).  This doesn't work because if you "
"construct a new list with the same value it won't be found; e.g.::"
msgstr ""
"Hashar listor efter deras adress (objekt-ID).  Detta fungerar inte eftersom "
"om du konstruerar en ny lista med samma värde kommer den inte att hittas; t."
"ex.::"

msgid ""
"mydict = {[1, 2]: '12'}\n"
"print(mydict[[1, 2]])"
msgstr ""
"mydict = {[1, 2]: '12'}\n"
"print(mydict[[1, 2]])"

msgid ""
"would raise a :exc:`KeyError` exception because the id of the ``[1, 2]`` "
"used in the second line differs from that in the first line.  In other "
"words, dictionary keys should be compared using ``==``, not using :keyword:"
"`is`."
msgstr ""
"skulle ge upphov till ett :exc:`KeyError`-undantag eftersom id:t för ``[1, "
"2]`` som används i den andra raden skiljer sig från det i den första raden.  "
"Med andra ord bör nycklar i ordböcker jämföras med hjälp av ``==``, inte med "
"hjälp av :keyword:`is`."

msgid ""
"Make a copy when using a list as a key.  This doesn't work because the list, "
"being a mutable object, could contain a reference to itself, and then the "
"copying code would run into an infinite loop."
msgstr ""
"Gör en kopia när du använder en lista som nyckel.  Det här fungerar inte "
"eftersom listan, som är ett föränderligt objekt, kan innehålla en referens "
"till sig själv, och då skulle kopieringskoden hamna i en oändlig loop."

msgid ""
"Allow lists as keys but tell the user not to modify them.  This would allow "
"a class of hard-to-track bugs in programs when you forgot or modified a list "
"by accident. It also invalidates an important invariant of dictionaries: "
"every value in ``d.keys()`` is usable as a key of the dictionary."
msgstr ""
"Tillåt listor som nycklar men säg till användaren att inte ändra dem.  Detta "
"skulle möjliggöra en klass av svårspårade buggar i program när du glömmer "
"eller modifierar en lista av misstag. Det ogiltigförklarar också en viktig "
"invariant för ordböcker: varje värde i ``d.keys()`` kan användas som en "
"nyckel i ordboken."

msgid ""
"Mark lists as read-only once they are used as a dictionary key.  The problem "
"is that it's not just the top-level object that could change its value; you "
"could use a tuple containing a list as a key.  Entering anything as a key "
"into a dictionary would require marking all objects reachable from there as "
"read-only -- and again, self-referential objects could cause an infinite "
"loop."
msgstr ""
"Markera listor som skrivskyddade när de används som en nyckel i en ordbok.  "
"Problemet är att det inte bara är objektet på den översta nivån som kan "
"ändra sitt värde; du kan använda en tupel som innehåller en lista som "
"nyckel.  Om du anger något som nyckel i en ordbok måste du markera alla "
"objekt som kan nås därifrån som skrivskyddade - och återigen kan "
"självrefererande objekt orsaka en oändlig slinga."

msgid ""
"There is a trick to get around this if you need to, but use it at your own "
"risk: You can wrap a mutable structure inside a class instance which has "
"both a :meth:`~object.__eq__` and a :meth:`~object.__hash__` method. You "
"must then make sure that the hash value for all such wrapper objects that "
"reside in a dictionary (or other hash based structure), remain fixed while "
"the object is in the dictionary (or other structure). ::"
msgstr ""
"Det finns ett trick för att komma runt detta om du behöver, men använd det "
"på egen risk: Du kan linda in en föränderlig struktur i en klassinstans som "
"har både en :meth:`~object.__eq__`- och en :meth:`~object.__hash__`-metod. "
"Du måste då se till att hashvärdet för alla sådana omslutningsobjekt som "
"finns i en ordbok (eller annan hashbaserad struktur) förblir fixerat medan "
"objektet finns i ordboken (eller annan struktur):"

msgid ""
"class ListWrapper:\n"
"    def __init__(self, the_list):\n"
"        self.the_list = the_list\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.the_list == other.the_list\n"
"\n"
"    def __hash__(self):\n"
"        l = self.the_list\n"
"        result = 98767 - len(l)*555\n"
"        for i, el in enumerate(l):\n"
"            try:\n"
"                result = result + (hash(el) % 9999999) * 1001 + i\n"
"            except Exception:\n"
"                result = (result % 7777777) + i * 333\n"
"        return result"
msgstr ""
"klass ListWrapper:\n"
"    def __init__(self, the_list):\n"
"        self.the_list = the_list\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.the_list == other.the_list\n"
"\n"
"    def __hash__(self):\n"
"        l = self.the_list\n"
"        resultat = 98767 - len(l)*555\n"
"        för i, el i enumerate(l):\n"
"            försök:\n"
"                resultat = resultat + (hash(el) % 9999999) * 1001 + i\n"
"            utom Undantag:\n"
"                resultat = (resultat % 7777777) + i * 333\n"
"        returnera resultat"

msgid ""
"Note that the hash computation is complicated by the possibility that some "
"members of the list may be unhashable and also by the possibility of "
"arithmetic overflow."
msgstr ""
"Observera att hashberäkningen kompliceras av möjligheten att vissa medlemmar "
"i listan inte kan hashas och även av möjligheten till aritmetiskt överflöd."

msgid ""
"Furthermore it must always be the case that if ``o1 == o2`` (ie ``o1."
"__eq__(o2) is True``) then ``hash(o1) == hash(o2)`` (ie, ``o1.__hash__() == "
"o2.__hash__()``), regardless of whether the object is in a dictionary or "
"not.  If you fail to meet these restrictions dictionaries and other hash "
"based structures will misbehave."
msgstr ""
"Dessutom måste det alltid vara så att om ``o1 == o2`` (dvs. ``o1.__eq__(o2) "
"is True``) så är ``hash(o1) == hash(o2)`` (dvs. ``o1.__hash__() == o2."
"__hash__()``), oavsett om objektet finns i en ordbok eller inte.  Om du inte "
"uppfyller dessa restriktioner kommer ordböcker och andra hashbaserade "
"strukturer att bete sig illa."

msgid ""
"In the case of :class:`!ListWrapper`, whenever the wrapper object is in a "
"dictionary the wrapped list must not change to avoid anomalies.  Don't do "
"this unless you are prepared to think hard about the requirements and the "
"consequences of not meeting them correctly.  Consider yourself warned."
msgstr ""
"När det gäller :class:`!ListWrapper` får den omslutna listan inte ändras när "
"omslutningsobjektet finns i en ordbok för att undvika anomalier.  Gör inte "
"detta om du inte är beredd att fundera ordentligt över kraven och "
"konsekvenserna av att inte uppfylla dem på rätt sätt.  Betrakta dig själv "
"som varnad."

msgid "Why doesn't list.sort() return the sorted list?"
msgstr "Varför returnerar inte list.sort() den sorterade listan?"

msgid ""
"In situations where performance matters, making a copy of the list just to "
"sort it would be wasteful. Therefore, :meth:`list.sort` sorts the list in "
"place. In order to remind you of that fact, it does not return the sorted "
"list.  This way, you won't be fooled into accidentally overwriting a list "
"when you need a sorted copy but also need to keep the unsorted version "
"around."
msgstr ""
"I situationer där prestanda är viktigt skulle det vara slöseri att göra en "
"kopia av listan bara för att sortera den. Därför sorterar :meth:`list.sort` "
"listan på plats. För att påminna dig om det faktumet returnerar den inte den "
"sorterade listan.  På så sätt blir du inte lurad att av misstag skriva över "
"en lista när du behöver en sorterad kopia men också behöver behålla den "
"osorterade versionen."

msgid ""
"If you want to return a new list, use the built-in :func:`sorted` function "
"instead.  This function creates a new list from a provided iterable, sorts "
"it and returns it.  For example, here's how to iterate over the keys of a "
"dictionary in sorted order::"
msgstr ""
"Om du vill returnera en ny lista använder du istället den inbyggda "
"funktionen :func:`sorted`.  Denna funktion skapar en ny lista från en "
"tillhandahållen iterabel, sorterar den och returnerar den.  Så här gör du "
"till exempel för att iterera över nycklarna i en ordbok i sorterad ordning::"

msgid ""
"for key in sorted(mydict):\n"
"    ...  # do whatever with mydict[key]..."
msgstr ""
"för nyckel i sorterad(mydict):\n"
"    ...  # gör vad som helst med mydict[key] ..."

msgid "How do you specify and enforce an interface spec in Python?"
msgstr ""
"Hur specificerar och verkställer du en gränssnittsspecifikation i Python?"

msgid ""
"An interface specification for a module as provided by languages such as C++ "
"and Java describes the prototypes for the methods and functions of the "
"module.  Many feel that compile-time enforcement of interface specifications "
"helps in the construction of large programs."
msgstr ""
"En gränssnittsspecifikation för en modul, som tillhandahålls av språk som C+"
"+ och Java, beskriver prototyperna för modulens metoder och funktioner.  "
"Många anser att tillämpning av gränssnittsspecifikationer under "
"kompileringstiden underlättar konstruktionen av stora program."

msgid ""
"Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base "
"Classes (ABCs).  You can then use :func:`isinstance` and :func:`issubclass` "
"to check whether an instance or a class implements a particular ABC.  The :"
"mod:`collections.abc` module defines a set of useful ABCs such as :class:"
"`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and :class:"
"`~collections.abc.MutableMapping`."
msgstr ""
"Python 2.6 lägger till en :mod:`abc`-modul som låter dig definiera abstrakta "
"basklasser (ABC).  Du kan sedan använda :func:`isinstance` och :func:"
"`issubclass` för att kontrollera om en instans eller en klass implementerar "
"en viss ABC.  Modulen :mod:`collections.abc` definierar en uppsättning "
"användbara ABC:er som :class:`~collections.abc.Iterable`, :class:"
"`~collections.abc.Container` och :class:`~collections.abc.MutableMapping`."

msgid ""
"For Python, many of the advantages of interface specifications can be "
"obtained by an appropriate test discipline for components."
msgstr ""
"För Python kan många av fördelarna med gränssnittsspecifikationer uppnås "
"genom en lämplig testdisciplin för komponenter."

msgid ""
"A good test suite for a module can both provide a regression test and serve "
"as a module interface specification and a set of examples.  Many Python "
"modules can be run as a script to provide a simple \"self test.\"  Even "
"modules which use complex external interfaces can often be tested in "
"isolation using trivial \"stub\" emulations of the external interface.  The :"
"mod:`doctest` and :mod:`unittest` modules or third-party test frameworks can "
"be used to construct exhaustive test suites that exercise every line of code "
"in a module."
msgstr ""
"En bra testsvit för en modul kan både tillhandahålla ett regressionstest och "
"fungera som en specifikation för modulgränssnittet och en uppsättning "
"exempel.  Många Python-moduler kan köras som ett skript för att ge ett "
"enkelt \"självtest\"  Även moduler som använder komplexa externa gränssnitt "
"kan ofta testas isolerat med hjälp av triviala \"stub\"-emuleringar av det "
"externa gränssnittet.  Modulerna :mod:`doctest` och :mod:`unittest` eller "
"testramverk från tredje part kan användas för att konstruera uttömmande "
"testsviter som testar varje kodrad i en modul."

msgid ""
"An appropriate testing discipline can help build large complex applications "
"in Python as well as having interface specifications would.  In fact, it can "
"be better because an interface specification cannot test certain properties "
"of a program.  For example, the :meth:`!list.append` method is expected to "
"add new elements to the end of some internal list; an interface "
"specification cannot test that your :meth:`!list.append` implementation will "
"actually do this correctly, but it's trivial to check this property in a "
"test suite."
msgstr ""
"En lämplig testdisciplin kan hjälpa till att bygga stora komplexa "
"applikationer i Python lika bra som att ha gränssnittsspecifikationer.  "
"Faktum är att det kan vara bättre eftersom en gränssnittsspecifikation inte "
"kan testa vissa egenskaper hos ett program.  Till exempel förväntas :meth:`!"
"list.append`-metoden lägga till nya element i slutet av en intern lista; en "
"gränssnittsspecifikation kan inte testa att din :meth:`!list.append`-"
"implementering faktiskt gör detta korrekt, men det är trivialt att "
"kontrollera den här egenskapen i en testsvit."

msgid ""
"Writing test suites is very helpful, and you might want to design your code "
"to make it easily tested. One increasingly popular technique, test-driven "
"development, calls for writing parts of the test suite first, before you "
"write any of the actual code.  Of course Python allows you to be sloppy and "
"not write test cases at all."
msgstr ""
"Att skriva testsviter är till stor hjälp, och du kanske vill utforma din kod "
"så att den blir lätt att testa. En alltmer populär teknik, testdriven "
"utveckling, innebär att man skriver delar av testsviten först, innan man "
"skriver någon av den faktiska koden.  Med Python kan du naturligtvis vara "
"slarvig och inte skriva testfall alls."

msgid "Why is there no goto?"
msgstr "Varför finns det ingen goto?"

msgid ""
"In the 1970s people realized that unrestricted goto could lead to messy "
"\"spaghetti\" code that was hard to understand and revise. In a high-level "
"language, it is also unneeded as long as there are ways to branch (in "
"Python, with :keyword:`if` statements and :keyword:`or`, :keyword:`and`, "
"and :keyword:`if`/:keyword:`else` expressions) and loop (with :keyword:"
"`while` and :keyword:`for` statements, possibly containing :keyword:"
"`continue` and :keyword:`break`)."
msgstr ""
"På 1970-talet insåg man att obegränsad goto kunde leda till rörig "
"\"spaghetti\"-kod som var svår att förstå och revidera. I ett högnivåspråk "
"är det också onödigt så länge det finns sätt att förgrena (i Python, med :"
"keyword:`if`-satser och :keyword:`or`, :keyword:`and` och :keyword:`if`/:"
"keyword:`else`-uttryck) och loopa (med :keyword:`while` och :keyword:`for`-"
"satser, som eventuellt innehåller :keyword:`continue` och :keyword:`break`)."

msgid ""
"One can also use exceptions to provide a \"structured goto\" that works even "
"across function calls.  Many feel that exceptions can conveniently emulate "
"all reasonable uses of the ``go`` or ``goto`` constructs of C, Fortran, and "
"other languages.  For example::"
msgstr ""
"Man kan också använda undantag för att tillhandahålla ett \"strukturerat "
"goto\" som fungerar även över funktionsanrop.  Många anser att undantag på "
"ett bekvämt sätt kan emulera alla rimliga användningar av ``go``- eller "
"``goto``-konstruktionerna i C, Fortran och andra språk.  Till exempel::"

msgid ""
"class label(Exception): pass  # declare a label\n"
"\n"
"try:\n"
"    ...\n"
"    if condition: raise label()  # goto label\n"
"    ...\n"
"except label:  # where to goto\n"
"    pass\n"
"..."
msgstr ""
"class label(Exception): pass # deklarera en etikett\n"
"\n"
"try:\n"
"    ...\n"
"    if villkor: raise label() # goto label\n"
"    ...\n"
"except label:  # vart ska man gå\n"
"    passera\n"
"..."

msgid ""
"This doesn't allow you to jump into the middle of a loop, but that's usually "
"considered an abuse of ``goto`` anyway.  Use sparingly."
msgstr ""
"Detta gör att du inte kan hoppa in i mitten av en slinga, men det brukar "
"ändå betraktas som ett missbruk av ``goto``.  Använd sparsamt."

msgid "Why can't raw strings (r-strings) end with a backslash?"
msgstr "Varför kan inte råsträngar (r-strängar) sluta med ett backslash?"

msgid ""
"More precisely, they can't end with an odd number of backslashes: the "
"unpaired backslash at the end escapes the closing quote character, leaving "
"an unterminated string."
msgstr ""
"Mer exakt kan de inte sluta med ett udda antal backslash: den oparade "
"backslashen i slutet undgår det avslutande citattecknet och lämnar en "
"oavslutad sträng."

msgid ""
"Raw strings were designed to ease creating input for processors (chiefly "
"regular expression engines) that want to do their own backslash escape "
"processing. Such processors consider an unmatched trailing backslash to be "
"an error anyway, so raw strings disallow that.  In return, they allow you to "
"pass on the string quote character by escaping it with a backslash.  These "
"rules work well when r-strings are used for their intended purpose."
msgstr ""
"Råa strängar utformades för att underlätta skapandet av indata för "
"processorer (främst motorer för reguljära uttryck) som vill göra sin egen "
"backslash escape-bearbetning. Sådana processorer anser att en omatchad "
"efterföljande backslash ändå är ett fel, så råa strängar tillåter inte det.  "
"I gengäld tillåter de att du skickar vidare strängens citattecken genom att "
"escapa det med en backslash.  Dessa regler fungerar bra när r-strängar "
"används för sitt avsedda ändamål."

msgid ""
"If you're trying to build Windows pathnames, note that all Windows system "
"calls accept forward slashes too::"
msgstr ""
"Om du försöker skapa Windows-sökvägar bör du notera att alla Windows-anrop "
"också accepterar snedstreck::"

msgid "f = open(\"/mydir/file.txt\")  # works fine!"
msgstr "f = open(\"/mydir/file.txt\") # fungerar bra!"

msgid ""
"If you're trying to build a pathname for a DOS command, try e.g. one of ::"
msgstr ""
"Om du försöker skapa ett sökvägsnamn för ett DOS-kommando, prova t.ex. en "
"av ::"

msgid ""
"dir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\n"
"dir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\n"
"dir = \"\\\\this\\\\is\\\\my\\\\dos\\\\dir\\\\\""
msgstr ""
"dir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\n"
"dir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\n"
"dir = \"\\\\this\\\\is\\my\\\\dos\\\\dir\\\\\""

msgid "Why doesn't Python have a \"with\" statement for attribute assignments?"
msgstr ""
"Varför har Python inte ett \"with\"-uttalande för attributtilldelningar?"

msgid ""
"Python has a :keyword:`with` statement that wraps the execution of a block, "
"calling code on the entrance and exit from the block.  Some languages have a "
"construct that looks like this::"
msgstr ""
"Python har en :keyword:`with`-sats som omsluter exekveringen av ett block "
"och anropar kod vid ingången till och utgången från blocket.  Vissa språk "
"har en konstruktion som ser ut så här::"

msgid ""
"with obj:\n"
"    a = 1               # equivalent to obj.a = 1\n"
"    total = total + 1   # obj.total = obj.total + 1"
msgstr ""
"med obj:\n"
"    a = 1 # likvärdig med obj.a = 1\n"
"    total = total + 1 # obj.total = obj.total + 1"

msgid "In Python, such a construct would be ambiguous."
msgstr "I Python skulle en sådan konstruktion vara tvetydig."

msgid ""
"Other languages, such as Object Pascal, Delphi, and C++, use static types, "
"so it's possible to know, in an unambiguous way, what member is being "
"assigned to. This is the main point of static typing -- the compiler "
"*always* knows the scope of every variable at compile time."
msgstr ""
"Andra språk, som Object Pascal, Delphi och C++, använder statiska typer, så "
"det är möjligt att på ett otvetydigt sätt veta vilken medlem som tilldelas. "
"Detta är huvudpoängen med statisk typning - kompilatorn vet *alltid* "
"omfattningen av varje variabel vid kompileringstillfället."

msgid ""
"Python uses dynamic types. It is impossible to know in advance which "
"attribute will be referenced at runtime. Member attributes may be added or "
"removed from objects on the fly. This makes it impossible to know, from a "
"simple reading, what attribute is being referenced: a local one, a global "
"one, or a member attribute?"
msgstr ""
"Python använder dynamiska typer. Det är omöjligt att i förväg veta vilket "
"attribut som kommer att refereras till vid körning. Medlemsattribut kan "
"läggas till eller tas bort från objekt i farten. Detta gör det omöjligt att, "
"genom en enkel läsning, veta vilket attribut som refereras: ett lokalt, ett "
"globalt eller ett medlemsattribut?"

msgid "For instance, take the following incomplete snippet::"
msgstr "Ta till exempel följande ofullständiga utdrag::"

msgid ""
"def foo(a):\n"
"    with a:\n"
"        print(x)"
msgstr ""
"def foo(a):\n"
"    med a:\n"
"        print(x)"

msgid ""
"The snippet assumes that ``a`` must have a member attribute called ``x``. "
"However, there is nothing in Python that tells the interpreter this. What "
"should happen if ``a`` is, let us say, an integer?  If there is a global "
"variable named ``x``, will it be used inside the :keyword:`with` block?  As "
"you see, the dynamic nature of Python makes such choices much harder."
msgstr ""
"I utdraget antas att ``a`` måste ha ett medlemsattribut som heter ``x``. Det "
"finns dock inget i Python som säger detta till tolken. Vad skulle hända om "
"``a`` är, låt oss säga, ett heltal?  Om det finns en global variabel som "
"heter ``x``, kommer den att användas inuti :keyword:`with`-blocket?  Som du "
"ser gör Pythons dynamiska natur sådana val mycket svårare."

msgid ""
"The primary benefit of :keyword:`with` and similar language features "
"(reduction of code volume) can, however, easily be achieved in Python by "
"assignment.  Instead of::"
msgstr ""
"Den primära fördelen med :keyword:`with` och liknande språkfunktioner "
"(minskning av kodvolymen) kan dock lätt uppnås i Python genom tilldelning.  "
"Istället för::"

msgid ""
"function(args).mydict[index][index].a = 21\n"
"function(args).mydict[index][index].b = 42\n"
"function(args).mydict[index][index].c = 63"
msgstr ""
"funktion(args).mydict[index][index].a = 21\n"
"funktion(args).mydict[index][index].b = 42\n"
"funktion(args).mydict[index][index].c = 63"

msgid "write this::"
msgstr "skriv detta::"

msgid ""
"ref = function(args).mydict[index][index]\n"
"ref.a = 21\n"
"ref.b = 42\n"
"ref.c = 63"
msgstr ""
"ref = funktion(args).mydict[index][index]\n"
"ref.a = 21\n"
"ref.b = 42\n"
"ref.c = 63"

msgid ""
"This also has the side-effect of increasing execution speed because name "
"bindings are resolved at run-time in Python, and the second version only "
"needs to perform the resolution once."
msgstr ""
"Detta har också den bieffekten att körhastigheten ökar eftersom "
"namnbindningar löses vid körning i Python, och den andra versionen behöver "
"bara utföra upplösningen en gång."

msgid ""
"Similar proposals that would introduce syntax to further reduce code volume, "
"such as using a 'leading dot', have been rejected in favour of explicitness "
"(see https://mail.python.org/pipermail/python-ideas/2016-May/040070.html)."
msgstr ""
"Liknande förslag om att införa syntax för att ytterligare minska kodvolymen, "
"t.ex. genom att använda en \"ledande punkt\", har avvisats till förmån för "
"explicitet (se https://mail.python.org/pipermail/python-ideas/2016-"
"May/040070.html)."

msgid "Why don't generators support the with statement?"
msgstr "Varför stöder inte generatorer uttalandet med?"

msgid ""
"For technical reasons, a generator used directly as a context manager would "
"not work correctly.  When, as is most common, a generator is used as an "
"iterator run to completion, no closing is needed.  When it is, wrap it as :"
"func:`contextlib.closing(generator) <contextlib.closing>` in the :keyword:"
"`with` statement."
msgstr ""
"Av tekniska skäl skulle en generator som används direkt som en "
"kontexthanterare inte fungera korrekt.  När, vilket är vanligast, en "
"generator används som en iterator som körs till slut, behövs ingen "
"stängning.  När så är fallet, skriv in det som :func:`contextlib."
"closing(generator) <contextlib.closing>` i :keyword:`with`-satsen."

msgid "Why are colons required for the if/while/def/class statements?"
msgstr "Varför krävs kolon för if/while/def/class-satserna?"

msgid ""
"The colon is required primarily to enhance readability (one of the results "
"of the experimental ABC language).  Consider this::"
msgstr ""
"Kolonet är nödvändigt främst för att öka läsbarheten (ett av resultaten av "
"det experimentella ABC-språket).  Tänk på detta::"

msgid ""
"if a == b\n"
"    print(a)"
msgstr ""
"om a == b\n"
"    skriv ut(a)"

msgid "versus ::"
msgstr "mot ::"

msgid ""
"if a == b:\n"
"    print(a)"
msgstr ""
"om a == b:\n"
"    print(a)"

msgid ""
"Notice how the second one is slightly easier to read.  Notice further how a "
"colon sets off the example in this FAQ answer; it's a standard usage in "
"English."
msgstr ""
"Lägg märke till att den andra är något lättare att läsa.  Lägg också märke "
"till att exemplet i det här FAQ-svaret avslutas med ett kolon; det är ett "
"vanligt sätt att använda ord på engelska."

msgid ""
"Another minor reason is that the colon makes it easier for editors with "
"syntax highlighting; they can look for colons to decide when indentation "
"needs to be increased instead of having to do a more elaborate parsing of "
"the program text."
msgstr ""
"Ett annat mindre skäl är att kolon gör det lättare för redaktörer med "
"syntaxmarkering; de kan leta efter kolon för att avgöra när indragningen "
"behöver ökas istället för att behöva göra en mer omfattande analys av "
"programtexten."

msgid "Why does Python allow commas at the end of lists and tuples?"
msgstr "Varför tillåter Python kommatecken i slutet av listor och tupler?"

msgid ""
"Python lets you add a trailing comma at the end of lists, tuples, and "
"dictionaries::"
msgstr ""
"I Python kan du lägga till ett efterföljande kommatecken i slutet av listor, "
"tupler och ordböcker::"

msgid ""
"[1, 2, 3,]\n"
"('a', 'b', 'c',)\n"
"d = {\n"
"    \"A\": [1, 5],\n"
"    \"B\": [6, 7],  # last trailing comma is optional but good style\n"
"}"
msgstr ""
"[1, 2, 3,]\n"
"('a', 'b', 'c',)\n"
"d = {\n"
"    \"A\": [1, 5],\n"
"    \"B\": [6, 7], # sista efterföljande kommatecknet är valfritt men bra "
"stil\n"
"}"

msgid "There are several reasons to allow this."
msgstr "Det finns flera skäl att tillåta detta."

msgid ""
"When you have a literal value for a list, tuple, or dictionary spread across "
"multiple lines, it's easier to add more elements because you don't have to "
"remember to add a comma to the previous line.  The lines can also be "
"reordered without creating a syntax error."
msgstr ""
"När du har ett bokstavligt värde för en lista, tupel eller ordbok utspritt "
"på flera rader är det lättare att lägga till fler element eftersom du inte "
"behöver komma ihåg att lägga till ett kommatecken på föregående rad.  "
"Raderna kan också ordnas om utan att det uppstår ett syntaxfel."

msgid ""
"Accidentally omitting the comma can lead to errors that are hard to "
"diagnose. For example::"
msgstr ""
"Om du råkar utelämna kommatecknet kan det leda till fel som är svåra att "
"diagnostisera. Till exempel::"

msgid ""
"x = [\n"
"  \"fee\",\n"
"  \"fie\"\n"
"  \"foo\",\n"
"  \"fum\"\n"
"]"
msgstr ""
"x = [\n"
"  \"avgift\",\n"
"  \"fie\"\n"
"  \"foo\",\n"
"  \"fum\"\n"
"]"

msgid ""
"This list looks like it has four elements, but it actually contains three: "
"\"fee\", \"fiefoo\" and \"fum\".  Always adding the comma avoids this source "
"of error."
msgstr ""
"Den här listan ser ut att ha fyra element, men den innehåller i själva "
"verket tre: \"fee\", \"fiefoo\" och \"fum\".  Genom att alltid lägga till "
"ett kommatecken undviker man denna felkälla."

msgid ""
"Allowing the trailing comma may also make programmatic code generation "
"easier."
msgstr ""
"Att tillåta efterföljande kommatecken kan också göra det lättare att "
"generera programmatisk kod."
