# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- Implementeringen av :keyword:`!import`"

msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Källkod:** :källa:`Lib/importlib/__init__.py`"

msgid "Introduction"
msgstr "Introduktion"

msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr "Syftet med :mod:`importlib`-paketet är trefaldigt."

msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and "
"thus, by extension, the :func:`__import__` function) in Python source code. "
"This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier "
"to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""
"En är att tillhandahålla implementeringen av :keyword:`import`-satsen (och "
"därmed, i förlängningen, :func:`__import__`-funktionen) i Python-källkod. "
"Detta ger en implementering av :keyword:`!import` som är portabel till alla "
"Python-tolkar. Detta ger också en implementering som är lättare att förstå "
"än en implementering i ett annat programmeringsspråk än Python."

msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"För det andra exponeras komponenterna för att implementera :keyword:`import` "
"i detta paket, vilket gör det lättare för användare att skapa sina egna "
"anpassade objekt (allmänt kända som en :term:`importer`) för att delta i "
"importprocessen."

msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr ""
"Tre, paketet innehåller moduler som exponerar ytterligare funktionalitet för "
"att hantera aspekter av Python-paket:"

msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ""
":mod:`importlib.metadata` ger tillgång till metadata från "
"tredjepartsdistributioner."

msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ""
":mod:`importlib.resources` tillhandahåller rutiner för att komma åt icke-"
"kodade \"resurser\" från Python-paket."

msgid ":ref:`import`"
msgstr ":ref:`import`"

msgid "The language reference for the :keyword:`import` statement."
msgstr "Språkreferensen för :keyword:`import`-satsen."

msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`Paketspecifikation <https://www.python.org/doc/essays/packages/>`__"

msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"Ursprunglig specifikation av paket. Viss semantik har ändrats sedan detta "
"dokument skrevs (t.ex. omdirigering baserad på ``None`` i :data:`sys."
"modules`)."

msgid "The :func:`.__import__` function"
msgstr "Funktionen :func:`.__import__`"

msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr "Satsen :keyword:`import` är ett syntaktiskt socker för denna funktion."

msgid ":ref:`sys-path-init`"
msgstr ":ref:`sys-path-init`"

msgid "The initialization of :data:`sys.path`."
msgstr "Initialisering av :data:`sys.path`."

msgid ":pep:`235`"
msgstr ":pep:`235``"

msgid "Import on Case-Insensitive Platforms"
msgstr "Import på plattformar som är okänsliga för skiftlägeslägeskoder"

msgid ":pep:`263`"
msgstr ":pep:`263``"

msgid "Defining Python Source Code Encodings"
msgstr "Definiera kodning av Python-källkod"

msgid ":pep:`302`"
msgstr ":pep:`302``"

msgid "New Import Hooks"
msgstr "Hooks för ny import"

msgid ":pep:`328`"
msgstr ":pep:`328``"

msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Import: Multi-Line och Absolut/Relativ"

msgid ":pep:`366`"
msgstr ":pep:`366``"

msgid "Main module explicit relative imports"
msgstr "Huvudmodulens explicita relativa import"

msgid ":pep:`420`"
msgstr ":pep:`420``"

msgid "Implicit namespace packages"
msgstr "Implicita namnområdespaket"

msgid ":pep:`451`"
msgstr ":pep:`451``"

msgid "A ModuleSpec Type for the Import System"
msgstr "En ModuleSpec-typ för importsystemet"

msgid ":pep:`488`"
msgstr ":pep:`488``"

msgid "Elimination of PYO files"
msgstr "Eliminering av PYO-filer"

msgid ":pep:`489`"
msgstr ":pep:`489``"

msgid "Multi-phase extension module initialization"
msgstr "Initialisering av förlängningsmodul i flera faser"

msgid ":pep:`552`"
msgstr ":pep:`552``"

msgid "Deterministic pycs"
msgstr "Deterministisk pycs"

msgid ":pep:`3120`"
msgstr ":pep:`3120``"

msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Använda UTF-8 som standardkodning för källkod"

msgid ":pep:`3147`"
msgstr ":pep:`3147``"

msgid "PYC Repository Directories"
msgstr "Kataloger för PYC-förvar"

msgid "Functions"
msgstr "Funktioner"

msgid "An implementation of the built-in :func:`__import__` function."
msgstr "En implementation av den inbyggda funktionen :func:`__import__`."

msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"Programmatisk import av moduler bör använda :func:`import_module` istället "
"för denna funktion."

msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Importera en modul. Argumentet *name* anger vilken modul som ska importeras "
"i absoluta eller relativa termer (t.ex. antingen ``pkg.mod`` eller ``.."
"mod``). Om namnet anges i relativa termer måste argumentet *package* sättas "
"till namnet på det paket som ska fungera som ankare för att lösa upp "
"paketnamnet (t.ex. ``import_module('..mod', 'pkg.subpkg')`` importerar ``pkg."
"mod``)."

msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"Funktionen :func:`import_module` fungerar som ett förenklande hölje runt :"
"func:`importlib.__import__`. Detta innebär att all semantik i funktionen "
"härleds från :func:`importlib.__import__`. Den viktigaste skillnaden mellan "
"dessa två funktioner är att :func:`import_module` returnerar det angivna "
"paketet eller modulen (t.ex. ``pkg.mod``), medan :func:`__import__` "
"returnerar paketet eller modulen på högsta nivån (t.ex. ``pkg``)."

msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Om du dynamiskt importerar en modul som skapats sedan tolken började "
"exekvera (t.ex. skapade en Python-källfil), kan du behöva anropa :func:"
"`invalidate_caches` för att den nya modulen ska uppmärksammas av "
"importsystemet."

msgid "Parent packages are automatically imported."
msgstr "Föräldrapaket importeras automatiskt."

msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Invalidera de interna cacherna för sökare som lagras på :data:`sys."
"meta_path`. Om en sökare implementerar ``invalidate_caches()`` kommer den "
"att anropas för att utföra invalideringen.  Den här funktionen bör anropas "
"om moduler skapas/installeras medan ditt program körs för att garantera att "
"alla sökare märker att den nya modulen finns."

msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr ""
"Namnrymdspaket som skapats/installerats på en annan :data:`sys.path`-plats "
"efter att samma namnrymd redan importerats uppmärksammas."

msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Laddar om en tidigare importerad *modul*.  Argumentet måste vara ett "
"modulobjekt, så det måste ha importerats tidigare.  Detta är användbart om "
"du har redigerat modulens källfil med en extern editor och vill prova den "
"nya versionen utan att lämna Python-tolken.  Returvärdet är modulobjektet "
"(som kan vara annorlunda om en ny import gör att ett annat objekt placeras "
"i :data:`sys.modules`)."

msgid "When :func:`reload` is executed:"
msgstr "När :func:`reload` utförs:"

msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"Python-modulens kod kompileras om och koden på modulnivå exekveras på nytt, "
"vilket definierar en ny uppsättning objekt som är bundna till namn i "
"modulens ordbok genom att återanvända :term:`loader` som ursprungligen "
"laddade modulen.  Funktionen ``init`` för tilläggsmoduler anropas inte en "
"andra gång."

msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Som med alla andra objekt i Python återkrävs de gamla objekten först när "
"deras referensantal sjunkit till noll."

msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Namnen i modulens namnrymd uppdateras för att peka på alla nya eller ändrade "
"objekt."

msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Andra referenser till de gamla objekten (t.ex. namn utanför modulen) är inte "
"rebound för att referera till de nya objekten och måste uppdateras i varje "
"namnrymd där de förekommer om så önskas."

msgid "There are a number of other caveats:"
msgstr "Det finns ett antal andra förbehåll:"

msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"När en modul laddas om behålls dess dictionary (som innehåller modulens "
"globala variabler).  Omdefinitioner av namn kommer att åsidosätta de gamla "
"definitionerna, så detta är i allmänhet inget problem.  Om den nya versionen "
"av en modul inte definierar ett namn som definierades i den gamla versionen, "
"kvarstår den gamla definitionen.  Denna funktion kan användas till modulens "
"fördel om den upprätthåller en global tabell eller cache av objekt --- med "
"en :keyword:`try`-sats kan den testa om tabellen finns och hoppa över dess "
"initialisering om så önskas::"

msgid ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"
msgstr ""
"försök:\n"
"    cache\n"
"except NamnFel:\n"
"    cache = {}"

msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Det är i allmänhet inte särskilt användbart att ladda om inbyggda eller "
"dynamiskt laddade moduler.  Att ladda om :mod:`sys`, :mod:`__main__`, :mod:"
"`builtins` och andra nyckelmoduler rekommenderas inte.  I många fall är "
"tilläggsmoduler inte utformade för att initieras mer än en gång, och kan "
"misslyckas på godtyckliga sätt när de laddas om."

msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"Om en modul importerar objekt från en annan modul med hjälp av :keyword:"
"`from` ... :keyword:`import` ..., omdefinieras inte de objekt som "
"importerats från den andra modulen genom att anropa :func:`reload` för den "
"andra modulen --- ett sätt att komma runt detta är att utföra :keyword:`!"
"from`-satsen igen, ett annat är att använda :keyword:`!import` och "
"kvalificerade namn (*module.name*) istället."

msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Om en modul instansierar instanser av en klass påverkas inte "
"metoddefinitionerna för instanserna av att modulen som definierar klassen "
"laddas om - de fortsätter att använda den gamla klassdefinitionen.  Samma "
"sak gäller för härledda klasser."

msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` uppstår när den modul som laddas om saknar en :"
"class:`~importlib.machinery.ModuleSpec`."

msgid ""
"This function is not thread-safe. Calling it from multiple threads can "
"result in unexpected behavior. It's recommended to use the :class:`threading."
"Lock` or other synchronization primitives for thread-safe module reloading."
msgstr ""
"Denna funktion är inte trådsäker. Om den anropas från flera trådar kan det "
"leda till oväntat beteende. Vi rekommenderar att du använder :class:"
"`threading.Lock` eller andra synkroniseringsprimitiver för trådsäker "
"omladdning av moduler."

msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- Abstrakta basklasser relaterade till import"

msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Källkod:** :source:`Lib/importlib/abc.py`"

msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
"Modulen :mod:`importlib.abc` innehåller alla de centrala abstrakta "
"basklasser som används av :keyword:`import`. Vissa subklasser av de centrala "
"abstrakta basklasserna tillhandahålls också för att hjälpa till att "
"implementera de centrala ABC."

msgid "ABC hierarchy::"
msgstr "ABC-hierarkin::"

msgid ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"
msgstr ""
"objekt\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Laddare\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader --+ InspectLoader\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"

msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "En abstrakt basklass som representerar en :term:`meta path finder`."

msgid "No longer a subclass of :class:`!Finder`."
msgstr "Inte längre en underklass till :class:`!Finder`."

msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`~module.__path__` from the parent package. If a spec "
"cannot be found, ``None`` is returned. When passed in, ``target`` is a "
"module object that the finder may use to make a more educated guess about "
"what spec to return. :func:`importlib.util.spec_from_loader` may be useful "
"for implementing concrete ``MetaPathFinders``."
msgstr ""
"En abstrakt metod för att hitta en :term:`spec <module spec>` för den "
"angivna modulen.  Om detta är en import på toppnivå kommer *path* att vara "
"``None``.  Annars är detta en sökning efter ett underpaket eller en modul "
"och *path* kommer att vara värdet på :attr:`~module.__path__` från det "
"överordnade paketet. Om en specifikation inte kan hittas returneras "
"``None``. När ``target`` skickas in är det ett modulobjekt som sökaren kan "
"använda för att göra en mer kvalificerad gissning om vilken specifikation "
"som ska returneras. :func:`importlib.util.spec_from_loader` kan vara "
"användbart för att implementera konkreta ``MetaPathFinders``."

msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"En valfri metod som, när den anropas, ska ogiltigförklara alla interna "
"cacheminnen som används av sökaren. Används av :func:`importlib."
"invalidate_caches` när cachen för alla sökare på :data:`sys.meta_path` "
"ogiltigförklaras."

msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr ""
"Returnerar ``None`` när den anropas istället för :data:`NotImplemented`."

msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`importlib.machinery.PathFinder`."
msgstr ""
"En abstrakt basklass som representerar en :term:`path entry finder`.  Även "
"om den har vissa likheter med :class:`MetaPathFinder`, är "
"``PathEntryFinder`` endast avsedd att användas inom det sökvägsbaserade "
"importundersystem som tillhandahålls av :class:`importlib.machinery."
"PathFinder`."

msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"En abstrakt metod för att hitta en :term:`spec <module spec>` för den "
"angivna modulen.  Sökaren kommer att söka efter modulen endast inom :term:"
"`path entry` som den är tilldelad.  Om en specifikation inte kan hittas "
"returneras ``None``.  När ``target`` skickas in är det ett modulobjekt som "
"sökaren kan använda för att göra en mer kvalificerad gissning om vilken spec "
"som ska returneras. :func:`importlib.util.spec_from_loader` kan vara "
"användbar för att implementera konkreta ``PathEntryFinders``."

msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`importlib.machinery.PathFinder."
"invalidate_caches` when invalidating the caches of all cached finders."
msgstr ""
"En valfri metod som, när den anropas, ska ogiltigförklara alla interna "
"cacheminnen som används av sökaren. Används av :meth:`importlib.machinery."
"PathFinder.invalidate_caches` när cacheminnet för alla cachade sökare "
"ogiltigförklaras."

msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"En abstrakt basklass för en :term:`laddare`. Se :pep:`302` för den exakta "
"definitionen av en laddare."

msgid ""
"Loaders that wish to support resource reading should implement a :meth:"
"`get_resource_reader` method as specified by :class:`importlib.resources.abc."
"ResourceReader`."
msgstr ""
"Laddare som vill stödja resursläsning bör implementera en :meth:"
"`get_resource_reader`-metod som specificeras av :class:`importlib.resources."
"abc.ResourceReader`."

msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "Införde den valfria metoden :meth:`get_resource_reader`."

msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"En metod som returnerar det modulobjekt som ska användas vid import av en "
"modul.  Denna metod kan returnera ``None``, vilket indikerar att standard "
"semantik för modulskapande ska användas."

msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr ""
"Denna metod är inte längre valfri när :meth:`exec_module` är definierad."

msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, :meth:"
"`create_module` must be defined."
msgstr ""
"En abstrakt metod som exekverar modulen i dess eget namnområde när en modul "
"importeras eller laddas om.  Modulen bör redan vara initialiserad när :meth:"
"`exec_module` anropas.  När den här metoden finns måste :meth:"
"`create_module` definieras."

msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`create_module` måste också definieras."

msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"En äldre metod för att ladda en modul.  Om modulen inte kan läsas in visas :"
"exc:`ImportError`, annars returneras den inlästa modulen."

msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import.  If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone."
msgstr ""
"Om den begärda modulen redan finns i :data:`sys.modules`, bör den modulen "
"användas och laddas om. I annat fall bör laddaren skapa en ny modul och "
"infoga den i :data:`sys.modules` innan någon laddning påbörjas, för att "
"förhindra rekursion från importen.  Om laddaren har infogat en modul och "
"laddningen misslyckas, måste laddaren ta bort den från :data:`sys.modules`; "
"moduler som redan fanns i :data:`sys.modules` innan laddaren började "
"exekvera bör lämnas ifred."

msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"Laddaren ska ange flera attribut för modulen (observera att vissa av dessa "
"attribut kan ändras när en modul laddas om):"

msgid ":attr:`module.__name__`"
msgstr ":attr:`modul.__name__`"

msgid ":attr:`module.__file__`"
msgstr ":attr:`modul.__fil__`` :attr:`modul.__fil__`"

msgid ":attr:`module.__cached__` *(deprecated)*"
msgstr ":attr:`modul.__cached__` *(föråldrad)*"

msgid ":attr:`module.__path__`"
msgstr ":attr:`modul.__path__`"

msgid ":attr:`module.__package__` *(deprecated)*"
msgstr ":attr:`modul.__package__` *(föråldrad)*"

msgid ":attr:`module.__loader__` *(deprecated)*"
msgstr ":attr:`modul.__loader__` *(föråldrad)*"

msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"När :meth:`exec_module` är tillgänglig tillhandahålls bakåtkompatibel "
"funktionalitet."

msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`.  "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""
"Utlöser :exc:`ImportError` när den anropas istället för :exc:"
"`NotImplementedError`.  Funktionalitet som tillhandahålls när :meth:"
"`exec_module` är tillgänglig."

msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of :meth:"
"`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"Det rekommenderade API:et för att ladda en modul är :meth:`exec_module` "
"(och :meth:`create_module`).  Laddare bör implementera det istället för :"
"meth:`load_module`.  Importmaskineriet tar hand om alla andra ansvarsområden "
"för :meth:`load_module` när :meth:`exec_module` är implementerat."

msgid "*Superseded by TraversableResources*"
msgstr "*Ersatt av TraversableResources*"

msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
"En abstrakt basklass för en :term:`loader` som implementerar det valfria :"
"pep:`302`-protokollet för laddning av godtyckliga resurser från "
"lagringsbackenden."

msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.resources.abc.TraversableResources`. This class exists for "
"backwards compatibility only with other ABCs in this module."
msgstr ""
"Denna ABC är föråldrad och ersätts av stöd för resursladdning via :class:"
"`importlib.resources.abc.TraversableResources`. Denna klass finns endast för "
"bakåtkompatibilitet med andra ABC:er i detta modul."

msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`~module."
"__file__` attribute or an item from a package's :attr:`~module.__path__`."
msgstr ""
"En abstrakt metod för att returnera byte för data som finns på *path*. "
"Laddare som har en filliknande lagringsbackend som tillåter lagring av "
"godtyckliga data kan implementera denna abstrakta metod för att ge direkt "
"tillgång till de data som lagras. :exc:`OSError` ska tas upp om *path* inte "
"kan hittas. *Sökvägen* förväntas vara konstruerad med hjälp av en moduls "
"attribut :attr:`~module.__file__` eller ett objekt från ett pakets :attr:"
"`~module.__path__`."

msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Utlöser :exc:`OSError` istället för :exc:`NotImplementedError`."

msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
"En abstrakt basklass för en :term:`laddare` som implementerar det valfria :"
"pep:`302`-protokollet för laddare som inspekterar moduler."

msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Returnerar kodobjektet för en modul, eller ``None`` om modulen inte har "
"något kodobjekt (vilket t.ex. skulle vara fallet för en inbyggd modul).  Ger "
"ett :exc:`ImportError` om laddaren inte kan hitta den begärda modulen."

msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Metoden har en standardimplementering, men det rekommenderas att den "
"åsidosätts om det är möjligt av prestandaskäl."

msgid "No longer abstract and a concrete implementation is provided."
msgstr "Inte längre abstrakt och en konkret implementering tillhandahålls."

msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"En abstrakt metod för att returnera källan till en modul. Den returneras som "
"en textsträng med :term:`universal newlines`, som översätter alla erkända "
"radavgränsare till ``'\\n'``-tecken.  Returnerar ``None`` om ingen källa är "
"tillgänglig (t.ex. en inbyggd modul). Utlöser :exc:`ImportError` om laddaren "
"inte kan hitta den angivna modulen."

msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Utlöser :exc:`ImportError` istället för :exc:`NotImplementedError`."

msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"En valfri metod som returnerar ett sant värde om modulen är ett paket, "
"annars ett falskt värde. :exc:`ImportError` uppstår om :term:`loader` inte "
"kan hitta modulen."

msgid "Create a code object from Python source."
msgstr "Skapa ett kodobjekt från Python-källan."

msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"Argumentet *data* kan vara vad som helst som :func:`compile`-funktionen "
"stöder (t.ex. sträng eller byte). Argumentet *path* bör vara \"sökvägen\" "
"till den plats där källkoden kommer ifrån, vilket kan vara ett abstrakt "
"koncept (t.ex. plats i en zip-fil)."

msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"Med det efterföljande kodobjektet kan man exekvera det i en modul genom att "
"köra ``exec(code, module.__dict__)``."

msgid "Made the method static."
msgstr "Gjorde metoden statisk."

msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Implementering av :meth:`Loader.exec_module`."

msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Implementering av :meth:`Loader.load_module`."

msgid "use :meth:`exec_module` instead."
msgstr "använd :meth:`exec_module` istället."

msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"En abstrakt basklass som ärver från :class:`InspectLoader` som, när den "
"implementeras, hjälper en modul att exekveras som ett skript. ABC "
"representerar ett valfritt :pep:`302` protokoll."

msgid ""
"An abstract method that is to return the value of :attr:`~module.__file__` "
"for the specified module. If no path is available, :exc:`ImportError` is "
"raised."
msgstr ""
"En abstrakt metod som returnerar värdet av :attr:`~module.__file__` för den "
"angivna modulen. Om ingen sökväg är tillgänglig, :exc:`ImportError`."

msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Om källkod finns tillgänglig ska metoden returnera sökvägen till källfilen, "
"oavsett om en bytecode användes för att ladda modulen."

msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"En abstrakt basklass som ärver från :class:`ResourceLoader` och :class:"
"`ExecutionLoader` och ger konkreta implementationer av :meth:`ResourceLoader."
"get_data` och :meth:`ExecutionLoader.get_filename`."

msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"Argumentet *fullname* är ett fullständigt upplöst namn på den modul som "
"laddaren ska hantera. Argumentet *path* är sökvägen till filen för modulen."

msgid "The name of the module the loader can handle."
msgstr "Namnet på den modul som laddaren kan hantera."

msgid "Path to the file of the module."
msgstr "Sökväg till filen för modulen."

msgid "Calls super's ``load_module()``."
msgstr "Anropar super's ``load_module()``."

msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Använd :meth:`Loader.exec_module` istället."

msgid "Returns :attr:`path`."
msgstr "Returnerar :attr:`path`."

msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Läser *sökväg* som en binär fil och returnerar byte från den."

msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"En abstrakt basklass för att implementera laddning av källfiler (och "
"eventuellt bytekoder). Klassen ärver från både :class:`ResourceLoader` och :"
"class:`ExecutionLoader`, och kräver implementering av:"

msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Ska endast returnera sökvägen till källfilen; laddning utan källa stöds inte."

msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"De abstrakta metoder som definieras av denna klass är till för att lägga "
"till valfritt stöd för bytecode-filer. Om dessa valfria metoder inte "
"implementeras (eller om de ger upphov till :exc:`NotImplementedError`) "
"fungerar laddaren endast med källkod. Genom att implementera metoderna kan "
"laddaren arbeta med källkods- *och* bytecode-filer; det tillåter inte "
"*källkodslös* laddning där endast bytecode tillhandahålls.  Bytecode-filer "
"är en optimering för att påskynda laddningen genom att ta bort "
"parsningssteget i Pythons kompilator, och därför exponeras inget bytecode-"
"specifikt API."

msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Valfri abstrakt metod som returnerar en :class:`dict` som innehåller "
"metadata om den angivna sökvägen.  Nycklar i ordlistan som stöds är:"

msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (mandatory): ett heltal eller flyttal som anger "
"modifieringstiden för källkoden;"

msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (valfritt): storleken i bytes på källkoden."

msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Alla andra nycklar i ordlistan ignoreras för att möjliggöra framtida "
"tillägg. Om sökvägen inte kan hanteras genereras :exc:`OSError`."

msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Utlös :exc:`OSError` istället för :exc:`NotImplementedError`."

msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Valfri abstrakt metod som returnerar modifieringstiden för den angivna "
"sökvägen."

msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"Den här metoden är utfasad till förmån för :meth:`path_stats`.  Du behöver "
"inte implementera den, men den är fortfarande tillgänglig för "
"kompatibilitetsändamål. Utlöser :exc:`OSError` om sökvägen inte kan hanteras."

msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Valfri abstrakt metod som skriver de angivna bytena till en filsökväg. "
"Eventuella mellanliggande kataloger som inte finns ska skapas automatiskt."

msgid ""
"When writing to the path fails because the path is read-only (:const:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""
"Om det inte går att skriva till sökvägen eftersom sökvägen är skrivskyddad (:"
"const:`errno.EACCES`/:exc:`PermissionError`), ska undantaget inte spridas."

msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr ""
"Ger inte längre upphov till :exc:`NotImplementedError` när den anropas."

msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Konkret implementation av :meth:`InspectLoader.get_code`."

msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Konkret implementering av :meth:`Loader.exec_module`."

msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Konkret implementation av :meth:`Loader.load_module`."

msgid "Use :meth:`exec_module` instead."
msgstr "Använd :meth:`exec_module` istället."

msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Konkret implementation av :meth:`InspectLoader.get_source`."

msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Konkret implementation av :meth:`InspectLoader.is_package`. En modul anses "
"vara ett paket om dess filsökväg (som tillhandahålls av :meth:"
"`ExecutionLoader.get_filename`) är en fil med namnet ``__init__`` när "
"filtillägget är borttaget **och** modulnamnet i sig inte slutar på "
"``__init__``."

msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr "En :term:`abstrakt basklass` för att ge möjlighet att läsa *resurser*."

msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored e.g. in a zip "
"file versus on the file system."
msgstr ""
"I det här ABC:s perspektiv är en *resurs* en binär artefakt som levereras i "
"ett paket. Vanligtvis är detta något som en datafil som lever bredvid "
"paketets ``__init__.py``-fil. Syftet med den här klassen är att hjälpa till "
"att abstrahera åtkomsten till sådana datafiler så att det inte spelar någon "
"roll om paketet och dess datafil(er) lagras t.ex. i en zip-fil eller i "
"filsystemet."

msgid ""
"For any of methods of this class, a *resource* argument is expected to be a :"
"term:`path-like object` which represents conceptually just a file name. This "
"means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names "
"is packages and resources, respectively. This is also why instances of this "
"class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"För alla metoder i denna klass förväntas ett *resource*-argument vara ett :"
"term:`sökvägsliknande objekt` som konceptuellt bara representerar ett "
"filnamn. Detta innebär att inga sökvägar till underkataloger bör inkluderas "
"i *resource*-argumentet. Detta beror på att platsen för det paket som "
"läsaren är avsedd för fungerar som \"katalog\". Därför är metaforen för "
"kataloger och filnamn paket respektive resurser. Det är också därför som "
"instanser av denna klass förväntas vara direkt korrelerade till ett "
"specifikt paket (i stället för att potentiellt representera flera paket "
"eller en modul)."

msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible "
"with this ABC should only be returned when the specified module is a package."
msgstr ""
"Laddare som vill stödja resursläsning förväntas tillhandahålla en metod som "
"heter ``get_resource_reader(fullname)`` som returnerar ett objekt som "
"implementerar detta ABC-gränssnitt. Om den modul som anges av fullname inte "
"är ett paket, bör denna metod returnera :const:`None`. Ett objekt som är "
"kompatibelt med denna ABC bör endast returneras när den angivna modulen är "
"ett paket."

msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr "Använd :class:`importlib.resources.abc.TraversableResources` istället."

msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""
"Returnerar ett öppnat, :term:`filliknande objekt` för binär läsning av "
"*resursen*."

msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "Om resursen inte kan hittas genereras :exc:`FileNotFoundError`."

msgid "Returns the file system path to the *resource*."
msgstr "Returnerar filsystemets sökväg till *resursen*."

msgid ""
"If the resource does not concretely exist on the file system, raise :exc:"
"`FileNotFoundError`."
msgstr ""
"Om resursen inte finns i filsystemet, uppstår :exc:`FileNotFoundError`."

msgid ""
"Returns ``True`` if the named *name* is considered a resource. :exc:"
"`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"Returnerar ``True`` om namnet *name* anses vara en resurs. :exc:"
"`FileNotFoundError` uppstår om *name* inte finns."

msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which :meth:"
"`is_resource` would be false."
msgstr ""
"Returnerar en :term:`iterable` av strängar över innehållet i paketet. "
"Observera att det inte är nödvändigt att alla namn som returneras av "
"iteratorn är faktiska resurser, t.ex. är det acceptabelt att returnera namn "
"för vilka :meth:`is_resource` skulle vara false."

msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used directly."
msgstr ""
"Att tillåta att icke-resursnamn returneras är för att möjliggöra situationer "
"där det på förhand är känt hur ett paket och dess resurser lagras och icke-"
"resursnamnen skulle vara användbara. Det är t.ex. tillåtet att returnera "
"namn på underkataloger så att dessa namn på underkataloger kan användas "
"direkt när det är känt att paketet och resurserna lagras i filsystemet."

msgid "The abstract method returns an iterable of no items."
msgstr "Den abstrakta metoden returnerar en iterabel utan objekt."

msgid ""
"An object with a subset of :class:`pathlib.Path` methods suitable for "
"traversing directories and opening files."
msgstr ""
"Ett objekt med en delmängd av :class:`pathlib.Path`-metoder som lämpar sig "
"för genomgång av kataloger och öppning av filer."

msgid ""
"For a representation of the object on the file-system, use :meth:`importlib."
"resources.as_file`."
msgstr ""
"För en representation av objektet i filsystemet, använd :meth:`importlib."
"resources.as_file`."

msgid "Use :class:`importlib.resources.abc.Traversable` instead."
msgstr "Använd :class:`importlib.resources.abc.Traversable` istället."

msgid "Abstract. The base name of this object without any parent references."
msgstr ""
"Abstrakt. Basnamnet för detta objekt utan några överordnade referenser."

msgid "Yield ``Traversable`` objects in ``self``."
msgstr "Avkastar ``Traversable``-objekt i ``self``."

msgid "Return ``True`` if ``self`` is a directory."
msgstr "Returnerar ``True`` om ``self`` är en katalog."

msgid "Return ``True`` if ``self`` is a file."
msgstr "Returnerar ``True`` om ``self`` är en fil."

msgid "Return Traversable child in ``self``."
msgstr "Returnera Traversibelt barn i ``self``."

msgid "Return ``Traversable`` child in ``self``."
msgstr "Returnera ``Traversable`` barn i ``self``."

msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""
"*mode* kan vara 'r' eller 'rb' för att öppna som text eller binär. "
"Returnerar ett handtag som är lämpligt för läsning (samma som :attr:`pathlib."
"Path.open`)."

msgid ""
"When opening as text, accepts encoding parameters such as those accepted by :"
"class:`io.TextIOWrapper`."
msgstr ""
"När den öppnas som text accepteras kodningsparametrar som de som accepteras "
"av :class:`io.TextIOWrapper`."

msgid "Read contents of ``self`` as bytes."
msgstr "Läs innehållet i ``själv`` som bytes."

msgid "Read contents of ``self`` as text."
msgstr "Läs innehållet i ``själv`` som text."

msgid ""
"An abstract base class for resource readers capable of serving the :meth:"
"`importlib.resources.files` interface. Subclasses :class:`importlib."
"resources.abc.ResourceReader` and provides concrete implementations of the :"
"class:`importlib.resources.abc.ResourceReader`'s abstract methods. "
"Therefore, any loader supplying :class:`importlib.abc.TraversableResources` "
"also supplies ResourceReader."
msgstr ""
"En abstrakt basklass för resursläsare som kan hantera :meth:`importlib."
"resources.files`-gränssnittet. Underklassar :class:`importlib.resources.abc."
"ResourceReader` och tillhandahåller konkreta implementationer av :class:"
"`importlib.resources.abc.ResourceReader`s abstrakta metoder. Därför "
"tillhandahåller alla laddare som tillhandahåller :class:`importlib.abc."
"TraversableResources` också ResourceReader."

msgid ""
"Loaders that wish to support resource reading are expected to implement this "
"interface."
msgstr ""
"Laddare som vill stödja resursläsning förväntas implementera detta "
"gränssnitt."

msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the loaded "
"package."
msgstr ""
"Returnerar ett :class:`importlib.resources.abc.Traversable`-objekt för det "
"laddade paketet."

msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- Importörer och sökvägs-hooks"

msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Källkod:** :source:`Lib/importlib/machinery.py`"

msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Denna modul innehåller de olika objekt som hjälper :keyword:`import` att "
"hitta och ladda moduler."

msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"En lista med strängar som representerar de identifierade filsuffixen för "
"källmoduler."

msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"En lista med strängar som representerar filsuffixen för icke-optimerade "
"bytekodsmoduler."

msgid "Use :const:`BYTECODE_SUFFIXES` instead."
msgstr "Använd :const:`BYTECODE_SUFFIXES` istället."

msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"En lista med strängar som representerar filsuffixen för optimerade bytecode-"
"moduler."

msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"En lista med strängar som representerar de erkända filsuffixen för bytecode-"
"moduler (inklusive den inledande punkten)."

msgid "The value is no longer dependent on ``__debug__``."
msgstr "Värdet är inte längre beroende av ``__debug__``."

msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"En lista med strängar som representerar de identifierade filsuffixen för "
"tilläggsmoduler."

msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"Returnerar en kombinerad lista med strängar som representerar alla filsuffix "
"för moduler som känns igen av standardimportmaskineriet. Detta är ett "
"hjälpmedel för kod som helt enkelt behöver veta om en filsystemssökväg "
"potentiellt hänvisar till en modul utan att behöva några detaljer om typen "
"av modul (till exempel :func:`inspect.getmodulename`)."

msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"En :term:`importör` för inbyggda moduler. Alla kända inbyggda moduler finns "
"listade i :data:`sys.builtin_module_names`. Den här klassen implementerar "
"ABC:erna :class:`importlib.abc.MetaPathFinder` och :class:`importlib.abc."
"InspectLoader`."

msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"Endast klassens metoder definieras av denna klass för att minska behovet av "
"instansiering."

msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
"Som en del av :pep:`489` implementerar den inbyggda importören nu :meth:"
"`Loader.create_module` och :meth:`Loader.exec_module`"

msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"En :term:`importör` för frysta moduler. Denna klass implementerar ABC:erna :"
"class:`importlib.abc.MetaPathFinder` och :class:`importlib.abc."
"InspectLoader`."

msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr ""
"Fått metoderna :meth:`~Loader.create_module` och :meth:`~Loader.exec_module`."

msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` för moduler som deklareras i Windows-registret.  Den "
"här klassen implementerar :class:`importlib.abc.MetaPathFinder` ABC."

msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Använd :mod:`site`-konfigurationen istället. Framtida versioner av Python "
"kanske inte aktiverar den här sökaren som standard."

msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"En :term:`Finder <finder>` för :data:`sys.path` och paketets ``__path__`` "
"attribut. Den här klassen implementerar :class:`importlib.abc."
"MetaPathFinder` ABC."

msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
"Klassmetod som försöker hitta en :term:`spec <module spec>` för den modul "
"som anges av *fullname* på :data:`sys.path` eller, om definierad, på *path*. "
"För varje sökvägspost som genomsöks kontrolleras :data:`sys."
"path_importer_cache`. Om ett icke-falskt objekt hittas används det som :term:"
"`path entry finder` för att leta efter den modul som söks. Om ingen post "
"hittas i :data:`sys.path_importer_cache`, söks i :data:`sys.path_hooks` "
"efter en sökare för sökvägsposten och, om den hittas, lagras den i :data:"
"`sys.path_importer_cache` tillsammans med en fråga om modulen. Om ingen "
"sökare någonsin hittas lagras ``None`` i cachen och returneras."

msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr ""
"Om den aktuella arbetskatalogen - representerad av en tom sträng - inte "
"längre är giltig returneras ``None`` men inget värde cachas i :data:`sys."
"path_importer_cache`."

msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Anropar :meth:`importlib.abc.PathEntryFinder.invalidate_caches` på alla "
"sökare som lagras i :data:`sys.path_importer_cache` som definierar metoden. "
"Annars raderas poster i :data:`sys.path_importer_cache` som är inställda på "
"``None``."

msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr "Poster med ``None`` i :data:`sys.path_importer_cache` tas bort."

msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Anropar objekt i :data:`sys.path_hooks` med den aktuella arbetskatalogen för "
"``''`` (d.v.s. den tomma strängen)."

msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"En konkret implementation av :class:`importlib.abc.PathEntryFinder` som "
"cachar resultat från filsystemet."

msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "Argumentet *path* är den katalog som sökaren ska söka i."

msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"Argumentet *loader_details* är ett variabelt antal tuples med två objekt som "
"var och en innehåller en laddare och en sekvens av filsuffix som laddaren "
"känner igen. Laddarna förväntas vara callables som accepterar två argument, "
"modulens namn och sökvägen till den fil som hittas."

msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"Sökaren cachelagrar kataloginnehållet efter behov och gör stat-anrop för "
"varje modulsökning för att kontrollera att cacheminnet inte är föråldrat. "
"Eftersom cache-stalkeness är beroende av granulariteten i operativsystemets "
"statusinformation om filsystemet, finns det ett potentiellt "
"tävlingsförhållande där man söker efter en modul, skapar en ny fil och sedan "
"söker efter den modul som den nya filen representerar. Om operationerna sker "
"tillräckligt snabbt för att rymmas inom granulariteten för stat-anrop, "
"kommer modulsökningen att misslyckas. För att förhindra att detta händer, "
"när du skapar en modul dynamiskt, se till att anropa :func:`importlib."
"invalidate_caches`."

msgid "The path the finder will search in."
msgstr "Den väg som sökaren kommer att söka i."

msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Försök att hitta specifikationen för att hantera *fullname* inom :attr:"
"`path`."

msgid "Clear out the internal cache."
msgstr "Rensa ut den interna cachen."

msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"En klassmetod som returnerar en closure för användning på :data:`sys."
"path_hooks`. En instans av :class:`FileFinder` returneras av stängningen med "
"hjälp av sökvägsargumentet som ges till stängningen direkt och "
"*loader_details* indirekt."

msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""
"Om argumentet till stängningen inte är en befintlig katalog kommer :exc:"
"`ImportError` att tas upp."

msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"En konkret implementation av :class:`importlib.abc.SourceLoader` genom att "
"underklassa :class:`importlib.abc.FileLoader` och tillhandahålla några "
"konkreta implementationer av andra metoder."

msgid "The name of the module that this loader will handle."
msgstr "Namnet på den modul som den här laddaren ska hantera."

msgid "The path to the source file."
msgstr "Sökvägen till källfilen."

msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Returnerar ``True`` om :attr:`path` verkar vara för ett paket."

msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ""
"Konkret implementering av :meth:`importlib.abc.SourceLoader.path_stats`."

msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr "Konkret implementation av :meth:`importlib.abc.SourceLoader.set_data`."

msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Konkret implementation av :meth:`importlib.abc.Loader.load_module` där det "
"är valfritt att ange namnet på den modul som ska laddas."

msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "Använd :meth:`importlib.abc.Loader.exec_module` istället."

msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"En konkret implementation av :class:`importlib.abc.FileLoader` som kan "
"importera bytecode-filer (dvs. inga källkodsfiler existerar)."

msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""
"Observera att direkt användning av bytecode-filer (och därmed inte "
"källkodsfiler) hindrar dina moduler från att kunna användas av alla Python-"
"implementationer eller nya versioner av Python som ändrar bytecode-formatet."

msgid "The name of the module the loader will handle."
msgstr "Namnet på den modul som laddaren ska hantera."

msgid "The path to the bytecode file."
msgstr "Sökvägen till bytekodfilen."

msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Avgör om modulen är ett paket baserat på :attr:`path`."

msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr "Returnerar kodobjektet för :attr:`name` som skapats från :attr:`path`."

msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Returnerar ``None`` eftersom bytecode-filer inte har någon källa när denna "
"laddare används."

msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"En konkret implementation av :class:`importlib.abc.ExecutionLoader` för "
"tilläggsmoduler."

msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"Argumentet *fullname* anger namnet på den modul som laddaren ska stödja. "
"Argumentet *path* är sökvägen till filen för tilläggsmodulen."

msgid ""
"Note that, by default, importing an extension module will fail in "
"subinterpreters if it doesn't implement multi-phase init (see :pep:`489`), "
"even if it would otherwise import successfully."
msgstr ""
"Observera att import av en tilläggsmodul som standard kommer att misslyckas "
"i undertolkar om den inte implementerar flerfasig init (se :pep:`489`), även "
"om den annars skulle importeras framgångsrikt."

msgid "Multi-phase init is now required for use in subinterpreters."
msgstr "Flerfasig init krävs nu för användning i undertolkar."

msgid "Name of the module the loader supports."
msgstr "Namnet på den modul som laddaren stöder."

msgid "Path to the extension module."
msgstr "Sökväg till tilläggsmodulen."

msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr ""
"Skapar modulobjektet från den givna specifikationen i enlighet med :pep:"
"`489`."

msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Initialiserar det givna modulobjektet i enlighet med :pep:`489`."

msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :const:`EXTENSION_SUFFIXES`."
msgstr ""
"Returnerar ``True`` om filsökvägen pekar på ett pakets ``__init__``-modul "
"baserat på :const:`EXTENSION_SUFFIXES`."

msgid "Returns ``None`` as extension modules lack a code object."
msgstr "Returnerar ``None`` eftersom tilläggsmoduler saknar ett kodobjekt."

msgid "Returns ``None`` as extension modules do not have source code."
msgstr "Returnerar ``None`` eftersom tilläggsmoduler inte har någon källkod."

msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace packages::"
msgstr ""
"En konkret implementation av :class:`importlib.abc.InspectLoader` för "
"namespace-paket.  Detta är ett alias för en privat klass och görs endast "
"offentlig för introspektion av ``__loader__``-attributet på namespace-paket::"

msgid ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"
msgstr ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"

msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`~module.__spec__` attribute.  Many "
"of these attributes are also available directly on a module: for example, "
"``module.__spec__.origin == module.__file__``.  Note, however, that while "
"the *values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  For example, it is possible to "
"update the module's :attr:`~module.__file__` at runtime and this will not be "
"automatically reflected in the module's :attr:`__spec__.origin <ModuleSpec."
"origin>`, and vice versa."
msgstr ""
"En specifikation för en moduls importsystemrelaterade tillstånd.  Detta "
"exponeras vanligtvis som modulens attribut :attr:`~module.__spec__`.  Många "
"av dessa attribut är också tillgängliga direkt på en modul: till exempel, "
"``module.__spec__.origin == module.__file__``.  Observera dock att även om "
"*värdena* vanligtvis är likvärdiga kan de skilja sig åt eftersom det inte "
"finns någon synkronisering mellan de två objekten.  Det är t.ex. möjligt att "
"uppdatera modulens :attr:`~module.__file__` vid körning, men detta "
"återspeglas inte automatiskt i modulens :attr:`__spec__.origin <ModuleSpec."
"origin>`, och vice versa."

msgid ""
"The module's fully qualified name (see :attr:`module.__name__`). The :term:"
"`finder` should always set this attribute to a non-empty string."
msgstr ""
"Modulens fullständigt kvalificerade namn (se :attr:`module.__name__`). "
"Termen :term:`finder` bör alltid sätta detta attribut till en icke-tom "
"sträng."

msgid ""
"The :term:`loader` used to load the module (see :attr:`module.__loader__`). "
"The :term:`finder` should always set this attribute."
msgstr ""
"Den :term:`loader` som används för att ladda modulen (se :attr:`module."
"__loader__`). Attributet bör alltid anges av :term:`finder`."

msgid ""
"The location the :term:`loader` should use to load the module (see :attr:"
"`module.__file__`). For example, for modules loaded from a ``.py`` file this "
"is the filename. The :term:`finder` should always set this attribute to a "
"meaningful value for the :term:`loader` to use.  In the uncommon case that "
"there is not one (like for namespace packages), it should be set to ``None``."
msgstr ""
"Den plats som :term:`loader` ska använda för att ladda modulen (se :attr:"
"`module.__file__`). För moduler som laddas från en ``.py``-fil är detta till "
"exempel filnamnet. :term:`finder` bör alltid sätta detta attribut till ett "
"meningsfullt värde som :term:`loader` kan använda.  I det ovanliga fallet "
"att det inte finns något sådant (som för namnrymdspaket), bör det sättas "
"till ``None``."

msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations in "
"which a package's submodules will be found (see :attr:`module.__path__`). "
"Most of the time there will only be a single directory in this list."
msgstr ""
"En (eventuellt tom) :term:`sekvens` av strängar som räknar upp de platser "
"där ett pakets undermoduler kommer att hittas (se :attr:`module.__path__`). "
"För det mesta kommer det bara att finnas en enda katalog i den här listan."

msgid ""
"The :term:`finder` should set this attribute to a sequence, even an empty "
"one, to indicate to the import system that the module is a package.  It "
"should be set to ``None`` for non-package modules.  It is set automatically "
"later to a special object for namespace packages."
msgstr ""
":term:`finder` bör sätta detta attribut till en sekvens, även en tom sådan, "
"för att ange för importsystemet att modulen är ett paket.  Det bör sättas "
"till ``None`` för icke-paketmoduler.  Det sätts automatiskt senare till ett "
"speciellt objekt för namnrymdspaket."

msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ""
":term:`finder` kan sätta detta attribut till ett objekt som innehåller "
"ytterligare modulspecifika data att använda vid laddning av modulen.  Annars "
"bör det sättas till ``None``."

msgid ""
"The filename of a compiled version of the module's code (see :attr:`module."
"__cached__`). The :term:`finder` should always set this attribute but it may "
"be ``None`` for modules that do not need compiled code stored."
msgstr ""
"Filnamnet för en kompilerad version av modulens kod (se :attr:`module."
"__cached__`). Attributet bör alltid anges av :term:`finder` men kan vara "
"``None`` för moduler som inte behöver lagra kompilerad kod."

msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the "
"empty string for a top-level module). See :attr:`module.__package__`. If the "
"module is a package then this is the same as :attr:`name`."
msgstr ""
"(Skrivskyddad) Det fullständigt kvalificerade namnet på det paket som "
"modulen finns i (eller den tomma strängen för en modul på högsta nivån). Se :"
"attr:`module.__package__`. Om modulen är ett paket är detta samma sak som :"
"attr:`name`."

msgid ""
"``True`` if the spec's :attr:`origin` refers to a loadable location, "
"``False`` otherwise.  This value impacts how :attr:`!origin` is interpreted "
"and how the module's :attr:`~module.__file__` is populated."
msgstr ""
"``True`` om specifikationens :attr:`origin`` hänvisar till en laddningsbar "
"plats, ``False`` annars.  Detta värde påverkar hur :attr:`!origin` tolkas "
"och hur modulens :attr:`~module.__file__` fylls i."

msgid ""
"A specialization of :class:`importlib.machinery.ExtensionFileLoader` that is "
"able to load extension modules in Framework format."
msgstr ""
"En specialisering av :class:`importlib.machinery.ExtensionFileLoader` som "
"kan ladda tilläggsmoduler i Framework-format."

msgid ""
"For compatibility with the iOS App Store, *all* binary modules in an iOS app "
"must be dynamic libraries, contained in a framework with appropriate "
"metadata, stored in the ``Frameworks`` folder of the packaged app. There can "
"be only a single binary per framework, and there can be no executable binary "
"material outside the Frameworks folder."
msgstr ""
"För kompatibilitet med iOS App Store måste *alla* binära moduler i en iOS-"
"app vara dynamiska bibliotek som ingår i ett ramverk med lämpliga metadata "
"som lagras i mappen ``Frameworks`` i den paketerade appen. Det får bara "
"finnas ett enda binärt program per ramverk och det får inte finnas något "
"körbart binärt material utanför Frameworks-mappen."

msgid ""
"To accommodate this requirement, when running on iOS, extension module "
"binaries are *not* packaged as ``.so`` files on ``sys.path``, but as "
"individual standalone frameworks. To discover those frameworks, this loader "
"is be registered against the ``.fwork`` file extension, with a ``.fwork`` "
"file acting as a placeholder in the original location of the binary on ``sys."
"path``. The ``.fwork`` file contains the path of the actual binary in the "
"``Frameworks`` folder, relative to the app bundle. To allow for resolving a "
"framework-packaged binary back to the original location, the framework is "
"expected to contain a ``.origin`` file that contains the location of the ``."
"fwork`` file, relative to the app bundle."
msgstr ""
"För att tillgodose detta krav, när de körs på iOS, är tilläggsmodulens "
"binärer *inte* paketerade som ``.so``-filer på ``sys.path``, utan som "
"enskilda fristående ramverk. För att upptäcka dessa ramverk registreras den "
"här laddaren mot filtillägget ``.fwork``, med en ``.fwork``-fil som fungerar "
"som en platshållare på den ursprungliga platsen för binärfilen på ``sys."
"path``. Filen ``.fwork`` innehåller sökvägen till den faktiska binärfilen i "
"mappen ``Frameworks``, i förhållande till appbunten. För att göra det "
"möjligt att återställa en ramverkspackad binär fil till den ursprungliga "
"platsen förväntas ramverket innehålla en fil med namnet ``.origin`` som "
"innehåller platsen för filen ``.fwork`` i förhållande till appbunten."

msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"Tänk till exempel på fallet med en import ``from foo.bar import _whiz``, där "
"``_whiz`` implementeras med den binära modulen ``sources/foo/bar/_whiz.abi3."
"so``, där ``sources`` är den plats som registrerats på ``sys.path``, "
"relativt programpaketet. Den här modulen *måste* distribueras som "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (ramverkets namn skapas "
"från modulens fullständiga importsökväg), med en ``Info.plist``-fil i "
"katalogen ``.framework`` som identifierar binärfilen som ett ramverk. "
"Modulen ``foo.bar._whiz`` skulle representeras på den ursprungliga platsen "
"med en ``källor/foo/bar/_whiz.abi3.fwork`` markörfil, som innehåller "
"sökvägen ``Frameworks/foo.bar._whiz/foo.bar._whiz``. Ramverket skulle också "
"innehålla ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``, som "
"innehåller sökvägen till filen ``.fwork``."

msgid ""
"When a module is loaded with this loader, the ``__file__`` for the module "
"will report as the location of the ``.fwork`` file. This allows code to use "
"the ``__file__`` of a  module as an anchor for file system traversal. "
"However, the spec origin will reference the location of the *actual* binary "
"in the ``.framework`` folder."
msgstr ""
"När en modul laddas med den här laddaren kommer ``__file__`` för modulen att "
"rapporteras som platsen för filen ``.fwork``. Detta gör att kod kan använda "
"``__file__`` för en modul som ett ankare för filsystemtraversering. Spec-"
"ursprunget kommer dock att referera till platsen för den *verkliga* binära "
"filen i mappen ``.framework``."

msgid ""
"The Xcode project building the app is responsible for converting any ``.so`` "
"files from wherever they exist in the ``PYTHONPATH`` into frameworks in the "
"``Frameworks`` folder (including stripping extensions from the module file, "
"the addition of framework metadata, and signing the resulting framework), "
"and creating the ``.fwork`` and ``.origin`` files. This will usually be done "
"with a build step in the Xcode project; see the iOS documentation for "
"details on how to construct this build step."
msgstr ""
"Xcode-projektet som bygger appen ansvarar för att konvertera alla ``.so``-"
"filer från var de än finns i ``PYTHONPATH`` till ramverk i mappen "
"``Frameworks`` (inklusive att ta bort tillägg från modulfilen, lägga till "
"metadata för ramverket och signera det resulterande ramverket) och skapa "
"filerna ``.fwork`` och ``.origin``. Detta görs vanligtvis med ett byggsteg i "
"Xcode-projektet; se iOS-dokumentationen för detaljer om hur man konstruerar "
"detta byggsteg."

msgid "Availability"
msgstr "Tillgänglighet"

msgid "Path to the ``.fwork`` file for the extension module."
msgstr "Sökväg till filen ``.fwork`` för tilläggsmodulen."

msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- Verktygskod för importörer"

msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**Källkod:** :källa:`Lib/importlib/util.py`"

msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""
"Denna modul innehåller de olika objekt som hjälper till vid konstruktionen "
"av en :term:`importör`."

msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"Byte som representerar bytekodens versionsnummer. Om du behöver hjälp med "
"att ladda/skriva bytecode kan du överväga :class:`importlib.abc."
"SourceLoader`."

msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""
"Returnerar :pep:`3147`/:pep:`488` sökvägen till den bytekompilerade filen "
"som är associerad med källan *path*.  Till exempel, om *väg* är ``/foo/bar/"
"baz.py`` skulle returvärdet vara ``/foo/bar/__pycache__/baz.cpython-32.pyc`` "
"för Python 3.2. Strängen ``cpython-32`` kommer från den aktuella magiska "
"taggen (se :func:`get_tag`; om :attr:`sys.implementation.cache_tag` inte är "
"definierad kommer :exc:`NotImplementedError`` att anges)."

msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""
"Parametern *optimization* används för att ange optimeringsnivån för bytecode-"
"filen. En tom sträng representerar ingen optimering, så ``/foo/bar/baz.py`` "
"med en *optimering* på ``''`` kommer att resultera i en bytekodssökväg på ``/"
"foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` gör att tolkens "
"optimeringsnivå används. Alla andra värdens strängrepresentation används, så "
"``/foo/bar/baz.py`` med en *optimering* på ``2`` kommer att leda till "
"bytekodssökvägen ``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. "
"Strängrepresentationen av *optimering* kan endast vara alfanumerisk, annars "
"uppstår :exc:`ValueError`."

msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"Parametern *debug_override* är föråldrad och kan användas för att åsidosätta "
"systemets värde för ``__debug__``. Värdet ``True`` motsvarar inställningen "
"av *optimization* till den tomma strängen. Ett värde på ``False`` är "
"detsamma som att sätta *optimization* till ``1``. Om både *debug_override* "
"och *optimization* inte är ``None`` så genereras :exc:`TypeError`."

msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"Parametern *optimization* har lagts till och parametern *debug_override* har "
"tagits bort."

msgid "Accepts a :term:`path-like object`."
msgstr "Accepterar en :term:`path-liknande objekt`."

msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""
"Givet *sökvägen* till ett :pep:`3147`-filnamn, returnera den associerade "
"källkodsfilsökvägen.  Till exempel, om *sökväg* är ``/foo/bar/__pycache__/"
"baz.cpython-32.pyc`` skulle den returnerade sökvägen vara ``/foo/bar/baz."
"py``.  *path* behöver inte existera, men om den inte överensstämmer med :pep:"
"`3147` eller :pep:`488` format, kommer ett :exc:`ValueError` att uppstå. Om :"
"attr:`sys.implementation.cache_tag` inte är definierad, genereras :exc:"
"`NotImplementedError`."

msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""
"Avkodar de angivna byte som representerar källkod och returnerar den som en "
"sträng med universella nya linjer (enligt :meth:`importlib.abc.InspectLoader."
"get_source`)."

msgid "Resolve a relative module name to an absolute one."
msgstr "Omvandlar ett relativt modulnamn till ett absolut."

msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""
"Om **name** inte har några inledande punkter returneras helt enkelt "
"**name**. Detta gör det möjligt att använda ``importlib.util."
"resolve_name('sys', __spec__.parent)`` utan att kontrollera om argumentet "
"**package** behövs."

msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). :exc:"
"`ImportError` is also raised if a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
":exc:`ImportError` tas upp om **name** är ett relativt modulnamn men "
"**package** är ett falskt värde (t.ex. ``None`` eller den tomma strängen). :"
"exc:`ImportError` tas också upp om ett relativt namn skulle undkomma det "
"innehållande paketet (t.ex. begära ``..bacon`` inom paketet ``spam``)."

msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"För att förbättra konsistensen med importdeklarationer, skicka :exc:"
"`ImportError` istället för :exc:`ValueError` för ogiltiga relativa "
"importförsök."

msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :data:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""
"Hitta :term:`spec <module spec>` för en modul, eventuellt i förhållande till "
"det angivna **package**-namnet. Om modulen finns i :data:`sys.modules`, "
"returneras ``sys.modules[name].__spec__`` (såvida inte specifikationen "
"skulle vara ``None`` eller inte är inställd, i vilket fall :exc:"
"`ValueError`` tas upp). Annars görs en sökning med hjälp av :data:`sys."
"meta_path`. ``None`` returneras om ingen specifikation hittas."

msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"Om **namn** är för en undermodul (innehåller en punkt) importeras den "
"överordnade modulen automatiskt."

msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr ""
"**name** och **package** fungerar på samma sätt som för :func:"
"`import_module`."

msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`~module.__path__` "
"attribute)."
msgstr ""
"Utlöser :exc:`ModuleNotFoundError` istället för :exc:`AttributeError` om "
"**package** i själva verket inte är ett paket (dvs. saknar attributet :attr:"
"`~module.__path__`)."

msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"Skapa en ny modul baserad på **spec** och :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."

msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"Om :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"inte returnerar ``None``, kommer inga befintliga attribut att återställas. "
"Inte heller kommer något :exc:`AttributeError` att uppstå om det utlöses "
"under åtkomst till **spec** eller inställning av ett attribut på modulen."

msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"Denna funktion är att föredra framför att använda :class:`types.ModuleType` "
"för att skapa en ny modul eftersom **spec** används för att ange så många "
"importkontrollerade attribut för modulen som möjligt."

msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do "
"for ModuleSpec.  The function uses available :term:`loader` APIs, such as :"
"meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"En fabriksfunktion för att skapa en :class:`~importlib.machinery.ModuleSpec`-"
"instans baserad på en laddare.  Parametrarna har samma betydelse som de har "
"för ModuleSpec.  Funktionen använder tillgängliga :term:`loader` API:er, "
"såsom :meth:`InspectLoader.is_package`, för att fylla i eventuell saknad "
"information om specifikationen."

msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in "
"on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"En fabriksfunktion för att skapa en :class:`~importlib.machinery.ModuleSpec`-"
"instans baserat på sökvägen till en fil.  Saknad information kommer att "
"fyllas i i specifikationen genom att använda API:er för laddare och genom "
"att antyda att modulen kommer att vara filbaserad."

msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"Returnerar hashen av *source_bytes* som bytes. En hashbaserad ``.pyc``-fil "
"bäddar in :func:`source_hash` av motsvarande källfils innehåll i sitt huvud."

msgid ""
"A context manager that can temporarily skip the compatibility check for "
"extension modules.  By default the check is enabled and will fail when a "
"single-phase init module is imported in a subinterpreter. It will also fail "
"for a multi-phase init module that doesn't explicitly support a per-"
"interpreter GIL, when imported in an interpreter with its own GIL."
msgstr ""
"En kontexthanterare som tillfälligt kan hoppa över kompatibilitetskontrollen "
"för tilläggsmoduler.  Som standard är kontrollen aktiverad och kommer att "
"misslyckas när en enfasig init-modul importeras i en undertolk. Den kommer "
"också att misslyckas för en flerfasig init-modul som inte uttryckligen "
"stöder en GIL per tolk, när den importeras i en tolk med sin egen GIL."

msgid ""
"Note that this function is meant to accommodate an unusual case; one which "
"is likely to eventually go away.  There's is a pretty good chance this is "
"not what you were looking for."
msgstr ""
"Observera att den här funktionen är avsedd för ett ovanligt fall, ett fall "
"som sannolikt kommer att försvinna så småningom.  Det finns en ganska stor "
"chans att det här inte är vad du letade efter."

msgid ""
"You can get the same effect as this function by implementing the basic "
"interface of multi-phase init (:pep:`489`) and lying about support for "
"multiple interpreters (or per-interpreter GIL)."
msgstr ""
"Du kan få samma effekt som den här funktionen genom att implementera det "
"grundläggande gränssnittet för flerfasig init (:pep:`489`) och ljuga om stöd "
"för flera tolkar (eller GIL per tolk)."

msgid ""
"Using this function to disable the check can lead to unexpected behavior and "
"even crashes.  It should only be used during extension module development."
msgstr ""
"Om du använder den här funktionen för att inaktivera kontrollen kan det leda "
"till oväntat beteende och till och med krascher.  Den bör endast användas "
"under utveckling av tilläggsmoduler."

msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"En klass som skjuter upp exekveringen av laddaren för en modul tills dess "
"att modulen har ett attribut åtkomligt."

msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :data:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""
"Denna klass fungerar **endast** med laddare som definierar :meth:`~importlib."
"abc.Loader.exec_module` eftersom kontroll över vilken modultyp som används "
"för modulen krävs. Av samma skäl måste laddarens metod :meth:`~importlib.abc."
"Loader.create_module` returnera ``None`` eller en typ för vilken attributet "
"``__class__`` kan ändras, och inte heller använda :term:`slots <__slots__>`. "
"Slutligen kommer moduler som ersätter objektet som placerats i :data:`sys."
"modules` inte att fungera eftersom det inte finns något sätt att på ett "
"säkert sätt ersätta modulreferenserna i hela tolken; :exc:`ValueError` tas "
"upp om en sådan ersättning upptäcks."

msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"För projekt där uppstartstiden är kritisk gör den här klassen det möjligt "
"att potentiellt minimera kostnaden för att ladda en modul om den aldrig "
"används. För projekt där starttiden inte är avgörande är det **starkt** "
"avrått från att använda denna klass eftersom felmeddelanden som skapas under "
"laddningen skjuts upp och därmed uppträder utanför sitt sammanhang."

msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"Började anropa :meth:`~importlib.abc.Loader.create_module`, vilket tog bort "
"kompatibilitetsvarningen för :class:`importlib.machinery.BuiltinImporter` "
"och :class:`importlib.machinery.ExtensionFileLoader`."

msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"En klassmetod som returnerar en callable som skapar en lazy loader. Detta är "
"tänkt att användas i situationer där laddaren skickas av klassen istället "
"för av instansen:"

msgid ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"
msgstr ""
"suffix = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(sökväg, (lazy_loader, suffixes))"

msgid "Examples"
msgstr "Exempel"

msgid "Importing programmatically"
msgstr "Importera programmatiskt"

msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"För att programmatiskt importera en modul, använd :func:`importlib."
"import_module`. ::"

msgid ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"
msgstr ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"

msgid "Checking if a module can be imported"
msgstr "Kontroll av om en modul kan importeras"

msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"Om du behöver ta reda på om en modul kan importeras utan att faktiskt göra "
"importen, bör du använda :func:`importlib.util.find_spec`."

msgid ""
"Note that if ``name`` is a submodule (contains a dot), :func:`importlib.util."
"find_spec` will import the parent module. ::"
msgstr ""
"Observera att om ``name`` är en undermodul (innehåller en punkt) kommer :"
"func:`importlib.util.find_spec` att importera föräldramodulen. ::"

msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"

msgid "Importing a source file directly"
msgstr "Importera en källfil direkt"

msgid ""
"This recipe should be used with caution: it is an approximation of an import "
"statement where the file path is specified directly, rather than :data:`sys."
"path` being searched. Alternatives should first be considered first, such as "
"modifying :data:`sys.path` when a proper module is required, or using :func:"
"`runpy.run_path` when the global namespace resulting from running a Python "
"file is appropriate."
msgstr ""
"Det här receptet bör användas med försiktighet: det är en approximation av "
"en importsats där filsökvägen anges direkt, i stället för att :data:`sys."
"path` söks. Alternativ bör först övervägas, till exempel att ändra :data:"
"`sys.path` när en riktig modul krävs, eller att använda :func:`runpy."
"run_path` när det globala namnrymden som uppstår när en Python-fil körs är "
"lämplig."

msgid ""
"To import a Python source file directly from a path, use the following "
"recipe::"
msgstr ""
"Om du vill importera en Python-källfil direkt från en sökväg använder du "
"följande recept::"

msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"

msgid "Implementing lazy imports"
msgstr "Implementering av lat import"

msgid "The example below shows how to implement lazy imports::"
msgstr "Exemplet nedan visar hur man implementerar lazy imports::"

msgid ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"
msgstr ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"

msgid "Setting up an importer"
msgstr "Konfigurera en importer"

msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :data:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :data:`sys.path_hooks` "
"which works with :data:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""
"För djupa anpassningar av import vill du vanligtvis implementera en :term:"
"`importer`. Detta innebär att hantera både :term:`finder` och :term:`loader` "
"sidan av saker och ting. För sökare finns det två varianter att välja mellan "
"beroende på dina behov: en :term:`meta path finder` eller en :term:`path "
"entry finder`. Den förra är vad du skulle sätta på :data:`sys.meta_path` "
"medan den senare är vad du skapar med hjälp av en :term:`path entry hook` "
"på :data:`sys.path_hooks` som fungerar med :data:`sys.path`-poster för att "
"potentiellt skapa en sökare. Det här exemplet visar hur du registrerar dina "
"egna importörer så att import använder dem (för att skapa en egen importör, "
"läs dokumentationen för lämpliga klasser som definieras i det här paketet)::"

msgid ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms "
"of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in "
"terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"
msgstr ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms "
"of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in "
"terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"

msgid "Approximating :func:`importlib.import_module`"
msgstr "Närmar sig :func:`importlib.import_module`"

msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""
"Import i sig är implementerat i Python-kod, vilket gör det möjligt att "
"exponera det mesta av importmaskineriet genom importlib. Följande hjälper "
"till att illustrera de olika API:erna som importlib exponerar genom att "
"tillhandahålla en ungefärlig implementering av :func:`importlib."
"import_module`::"

msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"

msgid "universal newlines"
msgstr "universella nya rader"

msgid "importlib.abc.InspectLoader.get_source method"
msgstr "importlib.abc.InspectLoader.get_source-metoden"
