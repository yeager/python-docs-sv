# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!configparser` --- Configuration file parser"
msgstr ":mod:`!configparser` --- Parser för konfigurationsfiler"

msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Källkod:** :source:`Lib/configparser.py`"

msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Denna modul tillhandahåller :class:`ConfigParser`-klassen som implementerar "
"ett grundläggande konfigurationsspråk som ger en struktur som liknar den som "
"finns i Microsoft Windows INI-filer.  Du kan använda detta för att skriva "
"Python-program som enkelt kan anpassas av slutanvändare."

msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Det här biblioteket tolkar eller skriver *inte* de prefix för värdetyper som "
"används i Windows-registrets utökade version av INI-syntax."

msgid "Module :mod:`tomllib`"
msgstr "Modul :mod:`tomllib`"

msgid ""
"TOML is a well-specified format for application configuration files. It is "
"specifically designed to be an improved version of INI."
msgstr ""
"TOML är ett väl specificerat format för konfigurationsfiler för program. Det "
"är särskilt utformat för att vara en förbättrad version av INI."

msgid "Module :mod:`shlex`"
msgstr "Modul :mod:`shlex`"

msgid ""
"Support for creating Unix shell-like mini-languages which can also be used "
"for application configuration files."
msgstr ""
"Stöd för att skapa Unix shell-liknande minispråk som också kan användas för "
"konfigurationsfiler för applikationer."

msgid "Module :mod:`json`"
msgstr "Modul :mod:`json`"

msgid ""
"The ``json`` module implements a subset of JavaScript syntax which is "
"sometimes used for configuration, but does not support comments."
msgstr ""
"Modulen ``json`` implementerar en delmängd av JavaScript-syntax som ibland "
"används för konfiguration, men stöder inte kommentarer."

msgid "Quick Start"
msgstr "Snabbstart"

msgid "Let's take a very basic configuration file that looks like this:"
msgstr ""
"Låt oss ta en mycket grundläggande konfigurationsfil som ser ut så här:"

msgid ""
"[DEFAULT]\n"
"ServerAliveInterval = 45\n"
"Compression = yes\n"
"CompressionLevel = 9\n"
"ForwardX11 = yes\n"
"\n"
"[forge.example]\n"
"User = hg\n"
"\n"
"[topsecret.server.example]\n"
"Port = 50022\n"
"ForwardX11 = no"
msgstr ""
"[DEFAULT]\n"
"ServerAliveInterval = 45\n"
"Komprimering = ja\n"
"Komprimeringsnivå = 9\n"
"ForwardX11 = ja\n"
"\n"
"[forge.exempel]\n"
"Användare = hg\n"
"\n"
"[topsecret.server.exempel]\n"
"Port = 50022\n"
"ForwardX11 = nej"

msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"INI-filernas struktur beskrivs `i följande avsnitt <#supported-ini-file-"
"structure>`_.  I huvudsak består filen av sektioner, som var och en "
"innehåller nycklar med värden. :mod:`configparser`-klasser kan läsa och "
"skriva sådana filer.  Låt oss börja med att skapa ovanstående "
"konfigurationsfil programmatiskt."

msgid ""
">>> import configparser\n"
">>> config = configparser.ConfigParser()\n"
">>> config['DEFAULT'] = {'ServerAliveInterval': '45',\n"
"...                      'Compression': 'yes',\n"
"...                      'CompressionLevel': '9'}\n"
">>> config['forge.example'] = {}\n"
">>> config['forge.example']['User'] = 'hg'\n"
">>> config['topsecret.server.example'] = {}\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['Port'] = '50022'     # mutates the parser\n"
">>> topsecret['ForwardX11'] = 'no'  # same here\n"
">>> config['DEFAULT']['ForwardX11'] = 'yes'\n"
">>> with open('example.ini', 'w') as configfile:\n"
"...   config.write(configfile)\n"
"..."
msgstr ""
">>> import configparser\n"
">>> config = configparser.ConfigParser()\n"
">>> config['DEFAULT'] = {'ServerAliveInterval': '45',\n"
"...                      'Komprimering': 'ja',\n"
"...                      'CompressionLevel': '9'}\n"
">>> config['forge.example'] = {} >>> config['forge.example'] = {}\n"
">>> config['forge.example']['User'] = 'hg'\n"
">>> config['topsecret.server.example'] = {} >>> topsecret = "
"config['topsecret.server.example']['User'] = 'hg'\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['Port'] = '50022' # muterar parsern\n"
">>> topsecret['ForwardX11'] = 'no' # samma här\n"
">>> config['DEFAULT']['ForwardX11'] = 'yes'\n"
">>> med open('example.ini', 'w') som configfile:\n"
"... config.write(configfile)\n"
"..."

msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Som du kan se kan vi behandla en config-parser ungefär som en ordbok. Det "
"finns skillnader, \"beskrivs senare <#mapping-protocol-access>\", men "
"beteendet ligger mycket nära vad du kan förvänta dig av en ordbok."

msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Nu när vi har skapat och sparat en konfigurationsfil ska vi läsa upp den och "
"utforska vilka data den innehåller."

msgid ""
">>> config = configparser.ConfigParser()\n"
">>> config.sections()\n"
"[]\n"
">>> config.read('example.ini')\n"
"['example.ini']\n"
">>> config.sections()\n"
"['forge.example', 'topsecret.server.example']\n"
">>> 'forge.example' in config\n"
"True\n"
">>> 'python.org' in config\n"
"False\n"
">>> config['forge.example']['User']\n"
"'hg'\n"
">>> config['DEFAULT']['Compression']\n"
"'yes'\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['ForwardX11']\n"
"'no'\n"
">>> topsecret['Port']\n"
"'50022'\n"
">>> for key in config['forge.example']:\n"
"...     print(key)\n"
"user\n"
"compressionlevel\n"
"serveraliveinterval\n"
"compression\n"
"forwardx11\n"
">>> config['forge.example']['ForwardX11']\n"
"'yes'"
msgstr ""
">>> config = configparser.ConfigParser()\n"
">>> config.sektioner()\n"
"[]\n"
">>> config.read('exempel.ini')\n"
"['exempel.ini']\n"
">>> config.sections()\n"
"['forge.exempel', 'topsecret.server.exempel']\n"
">>> 'forge.example' i config\n"
"Sant\n"
">>> \"python.org\" i konfigurationen\n"
"False\n"
">>> config['forge.example']['User']\n"
"'hg'\n"
">>> config['DEFAULT']['Komprimering']\n"
"'yes'\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['ForwardX11']\n"
"'nej'\n"
">>> topsecret['Port']\n"
"'50022'\n"
">>> for key in config['forge.example']:\n"
"... print(nyckel)\n"
"användare\n"
"komprimeringsnivå\n"
"serveraliveintervall\n"
"komprimering\n"
"forwardx11\n"
">>> config['forge.exempel']['ForwardX11']\n"
"'yes'"

msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Som vi kan se ovan är API:et ganska okomplicerat.  Det enda magiska är "
"avsnittet ``DEFAULT`` som innehåller standardvärden för alla andra avsnitt "
"[1]_.  Observera också att nycklar i sektioner är skiftlägesokänsliga och "
"lagras med gemener [1]_."

msgid ""
"It is possible to read several configurations into a single :class:"
"`ConfigParser`, where the most recently added configuration has the highest "
"priority. Any conflicting keys are taken from the more recent configuration "
"while the previously existing keys are retained. The example below reads in "
"an ``override.ini`` file, which will override any conflicting keys from the "
"``example.ini`` file."
msgstr ""
"Det är möjligt att läsa in flera konfigurationer i en enda :class:"
"`ConfigParser`, där den senast tillagda konfigurationen har högsta "
"prioritet. Eventuella motstridiga nycklar hämtas från den senaste "
"konfigurationen medan de tidigare befintliga nycklarna behålls. I exemplet "
"nedan läses en fil med namnet ``override.ini`` in, som åsidosätter alla "
"motstridiga nycklar från filen ``example.ini``."

msgid ""
"[DEFAULT]\n"
"ServerAliveInterval = -1"
msgstr ""
"[DEFAULT]\n"
"ServerAliveInterval = -1"

msgid ""
">>> config_override = configparser.ConfigParser()\n"
">>> config_override['DEFAULT'] = {'ServerAliveInterval': '-1'}\n"
">>> with open('override.ini', 'w') as configfile:\n"
"...     config_override.write(configfile)\n"
"...\n"
">>> config_override = configparser.ConfigParser()\n"
">>> config_override.read(['example.ini', 'override.ini'])\n"
"['example.ini', 'override.ini']\n"
">>> print(config_override.get('DEFAULT', 'ServerAliveInterval'))\n"
"-1"
msgstr ""
">>> config_override = configparser.ConfigParser()\n"
">>> config_override['DEFAULT'] = {'ServerAliveInterval': '-1'}\n"
">>> med open('override.ini', 'w') som configfile:\n"
"... config_override.write(configfile)\n"
"...\n"
">>> config_override = configparser.ConfigParser()\n"
">>> config_override.read(['example.ini', 'override.ini'])\n"
"['example.ini', 'override.ini'] ['example.ini', 'override.ini'\n"
">>> print(config_override.get('DEFAULT', 'ServerAliveInterval'))\n"
"-1"

msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr ""
"Detta beteende motsvarar ett anrop av :meth:`ConfigParser.read` med flera "
"filer som skickas till parametern *filnamn*."

msgid "Supported Datatypes"
msgstr "Datatyper som stöds"

msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Config-parsers gissar inte datatyperna för värden i konfigurationsfiler, "
"utan lagrar dem alltid internt som strängar.  Detta innebär att om du "
"behöver andra datatyper bör du konvertera på egen hand:"

msgid ""
">>> int(topsecret['Port'])\n"
"50022\n"
">>> float(topsecret['CompressionLevel'])\n"
"9.0"
msgstr ""
">>> int(topsecret['Port'])\n"
"50022\n"
">>> float(topsecret['CompressionLevel'])\n"
"9.0"

msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Eftersom den här uppgiften är så vanlig tillhandahåller config-parsers en "
"rad praktiska getter-metoder för att hantera heltal, flottörer och "
"booleaner.  Den sista är den mest intressanta eftersom det inte skulle vara "
"bra att bara skicka värdet till ``bool()`` eftersom ``bool('False')`` "
"fortfarande är ``True``.  Det är därför som config-parsers också "
"tillhandahåller :meth:`~ConfigParser.getboolean`.  Denna metod är "
"skiftlägesokänslig och känner igen booleska värden från ``'yes'``/``'no'``, "
"``'on'``/``'off'``, ``'true'``/``'false'`` och ``'1'``/``'0'`` [1]_.  Till "
"exempel:"

msgid ""
">>> topsecret.getboolean('ForwardX11')\n"
"False\n"
">>> config['forge.example'].getboolean('ForwardX11')\n"
"True\n"
">>> config.getboolean('forge.example', 'Compression')\n"
"True"
msgstr ""
">>> topsecret.getboolean('ForwardX11')\n"
"Falsk\n"
">>> config['forge.example'].getboolean('ForwardX11')\n"
"True\n"
">>> config.getboolean('forge.example', 'Compression')\n"
"True"

msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"Förutom :meth:`~ConfigParser.getboolean` tillhandahåller config-parser också "
"motsvarande metoder :meth:`~ConfigParser.getint` och :meth:`~ConfigParser."
"getfloat`.  Du kan registrera dina egna omvandlare och anpassa de som "
"tillhandahålls. [1]_"

msgid "Fallback Values"
msgstr "Reservvärden"

msgid ""
"As with a dictionary, you can use a section's :meth:`~ConfigParser.get` "
"method to provide fallback values:"
msgstr ""
"Precis som med en ordbok kan du använda en sektions :meth:`~ConfigParser."
"get`-metod för att tillhandahålla reservvärden:"

msgid ""
">>> topsecret.get('Port')\n"
"'50022'\n"
">>> topsecret.get('CompressionLevel')\n"
"'9'\n"
">>> topsecret.get('Cipher')\n"
">>> topsecret.get('Cipher', '3des-cbc')\n"
"'3des-cbc'"
msgstr ""
">>> topsecret.get('Port')\n"
"'50022'\n"
">>> topsecret.get('Kompressionsnivå')\n"
"'9'\n"
">>> topsecret.get('Cipher')\n"
">>> topsecret.get('Cipher', '3des-cbc')\n"
"'3des-cbc'"

msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.example'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"Observera att standardvärden har företräde framför reservvärden. I vårt "
"exempel har nyckeln ``'CompressionLevel'`` endast angetts i avsnittet "
"``'DEFAULT'``.  Om vi försöker hämta den från avsnittet ``'topsecret.server."
"example'`` får vi alltid standardvärdet, även om vi anger ett reservvärde:"

msgid ""
">>> topsecret.get('CompressionLevel', '3')\n"
"'9'"
msgstr ""
">>> topsecret.get('Kompressionsnivå', '3')\n"
"'9'"

msgid ""
"One more thing to be aware of is that the parser-level :meth:`~ConfigParser."
"get` method provides a custom, more complex interface, maintained for "
"backwards compatibility.  When using this method, a fallback value can be "
"provided via the ``fallback`` keyword-only argument:"
msgstr ""
"Ytterligare en sak att vara medveten om är att metoden :meth:`~ConfigParser."
"get` på parser-nivå ger ett anpassat, mer komplext gränssnitt, som bibehålls "
"för bakåtkompatibilitet.  När du använder den här metoden kan ett "
"reservvärde anges via det enda nyckelordsargumentet ``fallback``:"

msgid ""
">>> config.get('forge.example', 'monster',\n"
"...            fallback='No such things as monsters')\n"
"'No such things as monsters'"
msgstr ""
">>> config.get('smedja.exempel', 'monster',\n"
"... fallback=\"Det finns inga sådana saker som monster\")\n"
"\"Det finns inga sådana saker som monster"

msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"Samma ``fallback``-argument kan t.ex. användas med metoderna :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` och :meth:"
"`~ConfigParser.getboolean`:"

msgid ""
">>> 'BatchMode' in topsecret\n"
"False\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"True\n"
">>> config['DEFAULT']['BatchMode'] = 'no'\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"False"
msgstr ""
">>> \"BatchMode\" i topsecret\n"
"Falsk\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"Sant\n"
">>> config['DEFAULT']['BatchMode'] = 'no'\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"False"

msgid "Supported INI File Structure"
msgstr "INI-filstruktur som stöds"

msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"En konfigurationsfil består av sektioner, var och en inledd med en rubrik "
"``[section]``, följt av nyckel-/värdeposter åtskilda av en specifik sträng "
"(``=`` eller ``:`` som standard [1]_).  Som standard är avsnittsnamn "
"skiftlägeskänsliga, men nycklar är det inte [1]_.  Ledande och efterföljande "
"blanksteg tas bort från nycklar och värden. Värden kan utelämnas om parsern "
"är konfigurerad att tillåta det [1]_, i vilket fall avgränsaren för nyckel/"
"värde också kan utelämnas.  Värden kan också sträcka sig över flera rader, "
"så länge de är indragna djupare än den första raden i värdet.  Beroende på "
"parserns läge kan tomma rader behandlas som delar av värden på flera rader "
"eller ignoreras."

msgid ""
"By default, a valid section name can be any string that does not contain '\\"
"\\n'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""
"Som standard kan ett giltigt sektionsnamn vara en sträng som inte innehåller "
"\"\\\\n\". För att ändra detta, se :attr:`ConfigParser.SECTCRE`."

msgid ""
"The first section name may be omitted if the parser is configured to allow "
"an unnamed top level section with ``allow_unnamed_section=True``. In this "
"case, the keys/values may be retrieved by :const:`UNNAMED_SECTION` as in "
"``config[UNNAMED_SECTION]``."
msgstr ""
"Det första sektionsnamnet kan utelämnas om parsern är konfigurerad att "
"tillåta en icke namngiven sektion på högsta nivån med "
"``allow_unnamed_section=True``. I detta fall kan nycklarna/värdena hämtas "
"med :const:`UNNAMED_SECTION` som i ``config[UNNAMED_SECTION]``."

msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Konfigurationsfiler kan innehålla kommentarer, som inleds med specifika "
"tecken (``#`` och ``;`` som standard [1]_).  Kommentarer kan visas separat "
"på en i övrigt tom rad, eventuellt indragna. [1]_"

msgid "For example:"
msgstr "Till exempel:"

msgid ""
"[Simple Values]\n"
"key=value\n"
"spaces in keys=allowed\n"
"spaces in values=allowed as well\n"
"spaces around the delimiter = obviously\n"
"you can also use : to delimit keys from values\n"
"\n"
"[All Values Are Strings]\n"
"values like this: 1000000\n"
"or this: 3.14159265359\n"
"are they treated as numbers? : no\n"
"integers, floats and booleans are held as: strings\n"
"can use the API to get converted values directly: true\n"
"\n"
"[Multiline Values]\n"
"chorus: I'm a lumberjack, and I'm okay\n"
"    I sleep all night and I work all day\n"
"\n"
"[No Values]\n"
"key_without_value\n"
"empty string value here =\n"
"\n"
"[You can use comments]\n"
"# like this\n"
"; or this\n"
"\n"
"# By default only in an empty line.\n"
"# Inline comments can be harmful because they prevent users\n"
"# from using the delimiting characters as parts of values.\n"
"# That being said, this can be customized.\n"
"\n"
"    [Sections Can Be Indented]\n"
"        can_values_be_as_well = True\n"
"        does_that_mean_anything_special = False\n"
"        purpose = formatting for readability\n"
"        multiline_values = are\n"
"            handled just fine as\n"
"            long as they are indented\n"
"            deeper than the first line\n"
"            of a value\n"
"        # Did I mention we can indent comments, too?"
msgstr ""
"[Enkla värden]\n"
"nyckel=värde\n"
"mellanslag i nycklar=tillåtet\n"
"mellanslag i värden=tillåtet också\n"
"mellanslag runt avgränsaren = självklart\n"
"du kan också använda : för att avgränsa nycklar från värden\n"
"\n"
"[Alla värden är strängar]\n"
"värden som detta: 1000000\n"
"eller detta: 3.14159265359\n"
"behandlas de som siffror? : nej\n"
"heltal, flyttal och booleaner hålls som: strängar\n"
"kan använda API:et för att få konverterade värden direkt: true\n"
"\n"
"[Värden på flera rader]\n"
"kör: Jag är en skogshuggare, och jag är okej\n"
"    Jag sover hela natten och jag arbetar hela dagen\n"
"\n"
"[Inga värden]\n"
"nyckel_utan_värde\n"
"tomt strängvärde här =\n"
"\n"
"[Du kan använda kommentarer]\n"
"# så här\n"
"; eller så här\n"
"\n"
"# Som standard endast på en tom rad.\n"
"# Inline-kommentarer kan vara skadliga eftersom de hindrar användare\n"
"# från att använda avgränsande tecken som delar av värden.\n"
"# Med det sagt kan detta anpassas.\n"
"\n"
"    [Avsnitt kan vara indragna]\n"
"        can_values_be_as_well = Sant\n"
"        betyder_det_något_speciellt = False\n"
"        syfte = formatering för läsbarhet\n"
"        multiline_values = är\n"
"            hanteras helt okej så länge\n"
"            så länge de är indragna\n"
"            djupare än den första raden\n"
"            av ett värde\n"
"        # Nämnde jag att vi kan indentera kommentarer också?"

msgid "Unnamed Sections"
msgstr "Icke namngivna sektioner"

msgid ""
"The name of the first section (or unique) may be omitted and values "
"retrieved by the :const:`UNNAMED_SECTION` attribute."
msgstr ""
"Namnet på den första (eller unika) sektionen kan utelämnas och värden hämtas "
"med attributet :const:`UNNAMED_SECTION`."

msgid ""
">>> config = \"\"\"\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> unnamed = configparser.ConfigParser(allow_unnamed_section=True)\n"
">>> unnamed.read_string(config)\n"
">>> unnamed.get(configparser.UNNAMED_SECTION, 'option')\n"
"'value'"
msgstr ""
">>> config = \"\"\"\n"
"... alternativ = värde\n"
"...\n"
"... [ Avsnitt 2 ]\n"
"... en annan = val\n"
"... \"\"\"\n"
">>> unnamed = configparser.ConfigParser(allow_unnamed_section=True)\n"
">>> unnamed.read_string(config)\n"
">>> unnamed.get(configparser.UNNAMAMED_SECTION, 'option')\n"
"'värde'"

msgid "Interpolation of values"
msgstr "Interpolering av värden"

msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"Utöver kärnfunktionaliteten har :class:`ConfigParser` stöd för "
"interpolering.  Detta innebär att värden kan förbehandlas innan de "
"returneras från ``get()``-anrop."

msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"Standardimplementationen som används av :class:`ConfigParser`.  Den gör det "
"möjligt för värden att innehålla formatsträngar som hänvisar till andra "
"värden i samma avsnitt, eller värden i det speciella standardavsnittet "
"[1]_.  Ytterligare standardvärden kan anges vid initiering."

msgid ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: %(home_dir)s/lumberjack\n"
"my_pictures: %(my_dir)s/Pictures\n"
"\n"
"[Escape]\n"
"# use a %% to escape the % sign (% is the only character that needs to be "
"escaped):\n"
"gain: 80%%"
msgstr ""
"[Sökvägar]\n"
"hem_dir: /Användare\n"
"min_dir: %(home_dir)s/lumberjack\n"
"my_pictures: %(my_dir)s/Bilder\n"
"\n"
"[Escape]\n"
"# använd en %% för att undkomma % sign (% i är det enda tecken som behöver "
"undkommas):\n"
"vinst: 80%%"

msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"I exemplet ovan skulle :class:`ConfigParser` med *interpolation* inställd på "
"``BasicInterpolation()`` lösa ``%(home_dir)s`` till värdet av ``home_dir`` "
"(``/Users`` i det här fallet).  ``%(my_dir)s`` skulle i praktiken motsvara "
"``/Users/lumberjack``.  Alla interpoleringar görs på begäran så nycklar som "
"används i kedjan av referenser behöver inte anges i någon specifik ordning i "
"konfigurationsfilen."

msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Med ``interpolation`` inställd på ``None`` skulle parsern helt enkelt "
"returnera ``%(my_dir)s/Pictures`` som värdet på ``my_pictures`` och "
"``%(home_dir)s/lumberjack`` som värdet på ``my_dir``."

msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"En alternativ hanterare för interpolering som implementerar en mer avancerad "
"syntax, som t.ex. används i ``zc.buildout``.  Utökad interpolering är att "
"använda ``${section:option}`` för att beteckna ett värde från en utländsk "
"sektion. Interpolering kan sträcka sig över flera nivåer.  För enkelhetens "
"skull, om ``section:`` utelämnas, blir standardvärdet för interpolering det "
"aktuella avsnittet (och eventuellt standardvärdena från specialavsnittet)."

msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Den konfiguration som anges ovan med grundläggande interpolering skulle t."
"ex. se ut så här med utökad interpolering:"

msgid ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: ${home_dir}/lumberjack\n"
"my_pictures: ${my_dir}/Pictures\n"
"\n"
"[Escape]\n"
"# use a $$ to escape the $ sign ($ is the only character that needs to be "
"escaped):\n"
"cost: $$80"
msgstr ""
"[Sökvägar]\n"
"hem_dir: /Användare\n"
"min_dir: ${home_dir}/lumberjack\n"
"my_pictures: ${my_dir}/Bilder\n"
"\n"
"[Escape]\n"
"# använd en $$ för att undkomma tecknet $ ($ är det enda tecken som behöver "
"undkommas):\n"
"kostnad: $$80"

msgid "Values from other sections can be fetched as well:"
msgstr "Värden från andra sektioner kan också hämtas:"

msgid ""
"[Common]\n"
"home_dir: /Users\n"
"library_dir: /Library\n"
"system_dir: /System\n"
"macports_dir: /opt/local\n"
"\n"
"[Frameworks]\n"
"Python: 3.2\n"
"path: ${Common:system_dir}/Library/Frameworks/\n"
"\n"
"[Arthur]\n"
"nickname: Two Sheds\n"
"last_name: Jackson\n"
"my_dir: ${Common:home_dir}/twosheds\n"
"my_pictures: ${my_dir}/Pictures\n"
"python_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}"
msgstr ""
"[Vanlig]\n"
"hem_dir: /Användare\n"
"bibliotek_dir: /Bibliotek\n"
"system_dir: /System\n"
"macports_dir: /opt/lokal\n"
"\n"
"[Ramverk]\n"
"Python: 3.2\n"
"sökväg: ${Common:system_dir}/Bibliotek/Framverk/\n"
"\n"
"[Arthur]\n"
"smeknamn: Two Sheds\n"
"efternamn: Jackson\n"
"min_dir: ${Common:home_dir}/twosheds\n"
"mina_bilder: ${my_dir}/Bilder\n"
"python_dir: ${Frameworks:path}/Python/Versioner/${Frameworks:Python}"

msgid "Mapping Protocol Access"
msgstr "Mappning Protokoll Åtkomst"

msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"Mappningsprotokollåtkomst är ett generiskt namn för funktionalitet som gör "
"det möjligt att använda anpassade objekt som om de vore lexikon.  I fallet "
"med :mod:`configparser` använder implementationen av mappningsgränssnittet "
"notationen ``parser['section']['option']``."

msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"``parser['section']`` returnerar i synnerhet en proxy för sektionens data i "
"parsern.  Detta innebär att värdena inte kopieras utan hämtas från den "
"ursprungliga parsern på begäran.  Vad som är ännu viktigare är att när "
"värden ändras på en sektionsproxy, så ändras de faktiskt i den ursprungliga "
"parsern."

msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
":mod:`configparser`-objekt beter sig så nära faktiska ordböcker som möjligt. "
"Mappningsgränssnittet är komplett och följer :class:`~collections.abc."
"MutableMapping` ABC. Det finns dock några skillnader som bör tas med i "
"beräkningen:"

msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"Som standard är alla nycklar i sektioner tillgängliga på ett "
"skiftlägesokänsligt sätt [1]_.  T.ex. ``for option in parser[\"section\"]`` "
"ger endast ``optionxform``'ed alternativnyckelnamn.  Detta innebär att "
"nycklarna som standard har gemener.  Samtidigt, för ett avsnitt som "
"innehåller nyckeln ``'a'``, returnerar båda uttrycken ``True``::"

msgid ""
"\"a\" in parser[\"section\"]\n"
"\"A\" in parser[\"section\"]"
msgstr ""
"\"a\" i parser[\"section\"]\n"
"\"A\" i parser[\"section\"]"

msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Alla sektioner innehåller även ``DEFAULTSECT``-värden, vilket innebär att ``."
"clear()`` på en sektion kanske inte lämnar sektionen synligt tom.  Detta "
"beror på att standardvärden inte kan tas bort från avsnittet (eftersom de "
"tekniskt sett inte finns där).  Om de är åsidosatta i avsnittet, gör "
"borttagningen att standardvärdet blir synligt igen.  Försök att ta bort ett "
"standardvärde orsakar ett :exc:`KeyError`."

msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` kan inte tas bort från parsern:"

msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "försök att ta bort det ger :exc:`ValueError`,"

msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` lämnar den intakt,"

msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` returnerar den aldrig."

msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - det andra argumentet är **inte** "
"ett fallback-värde.  Observera dock att metoderna ``get()`` på sektionsnivå "
"är kompatibla både med mappningsprotokollet och det klassiska configparser-"
"API:et."

msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` är kompatibel med mappningsprotokollet (returnerar en "
"lista med paren *section_name*, *section_proxy* inklusive DEFAULTSECT).  Den "
"här metoden kan dock också anropas med argument: ``parser.items(section, "
"raw, vars)``.  Det senare anropet returnerar en lista med paren *option*, "
"*value* för en angiven ``section``, med alla interpoleringar expanderade (om "
"inte ``raw=True`` anges)."

msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"Mappningsprotokollet implementeras ovanpå det befintliga äldre API:et så att "
"subklasser som åsidosätter det ursprungliga gränssnittet fortfarande bör ha "
"mappningar som fungerar som förväntat."

msgid "Customizing Parser Behaviour"
msgstr "Anpassa parserns beteende"

msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Det finns nästan lika många INI-formatvarianter som det finns applikationer "
"som använder det. :mod:`configparser` gör mycket för att ge stöd för den "
"största möjliga uppsättningen INI-stilar som finns tillgängliga.  "
"Standardfunktionaliteten dikteras huvudsakligen av historisk bakgrund och "
"det är mycket troligt att du kommer att vilja anpassa några av funktionerna."

msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`!__init__` options:"
msgstr ""
"Det vanligaste sättet att ändra hur en specifik konfigurationsparser "
"fungerar är att använda :meth:`!__init__`-alternativen:"

msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, standardvärde: ``None``"

msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Detta alternativ accepterar en ordlista med nyckel-värdepar som initialt "
"kommer att placeras i avsnittet ``DEFAULT``.  Detta är ett elegant sätt att "
"stödja kortfattade konfigurationsfiler som inte anger värden som är desamma "
"som den dokumenterade standardinställningen."

msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`~ConfigParser.read_dict` before you read the actual file."
msgstr ""
"Tips: Om du vill ange standardvärden för ett visst avsnitt använder du :meth:"
"`~ConfigParser.read_dict` innan du läser den faktiska filen."

msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, standardvärde: :class:`dict`"

msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Detta alternativ har stor inverkan på hur mappningsprotokollet kommer att "
"bete sig och hur de skrivna konfigurationsfilerna ser ut.  Med "
"standardordboken lagras varje avsnitt i den ordning som de lades till i "
"parsern.  Detsamma gäller för alternativ inom avsnitt."

msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"En alternativ ordbokstyp kan t.ex. användas för att sortera sektioner och "
"alternativ på write-back."

msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"Observera: Det finns sätt att lägga till en uppsättning nyckel-värdepar i en "
"enda operation.  När du använder en vanlig ordbok i dessa operationer kommer "
"ordningen på nycklarna att vara ordnad.  Till exempel:"

msgid ""
">>> parser = configparser.ConfigParser()\n"
">>> parser.read_dict({'section1': {'key1': 'value1',\n"
"...                                'key2': 'value2',\n"
"...                                'key3': 'value3'},\n"
"...                   'section2': {'keyA': 'valueA',\n"
"...                                'keyB': 'valueB',\n"
"...                                'keyC': 'valueC'},\n"
"...                   'section3': {'foo': 'x',\n"
"...                                'bar': 'y',\n"
"...                                'baz': 'z'}\n"
"... })\n"
">>> parser.sections()\n"
"['section1', 'section2', 'section3']\n"
">>> [option for option in parser['section3']]\n"
"['foo', 'bar', 'baz']"
msgstr ""
">>> parser = configparser.ConfigParser()\n"
">>> parser.read_dict({'section1': {'key1': 'value1',\n"
"...                                'key2': 'value2',\n"
"...                                'key3': 'value3'},\n"
"...                   'section2': {'keyA': 'valueA',\n"
"...                                'keyB': 'valueB',\n"
"...                                'keyC': 'valueC'},\n"
"...                   'section3': {'foo': 'x',\n"
"...                                'bar': 'y',\n"
"...                                'baz': 'z'}\n"
"... })\n"
">>> parser.sections()\n"
"['section1', 'section2', 'section3']\n"
">>> [alternativ för alternativ i parser['section3']]]\n"
"['foo', 'bar', 'baz']"

msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, standardvärde: ``False``"

msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Det är känt att vissa konfigurationsfiler innehåller inställningar utan "
"värden, men som i övrigt överensstämmer med den syntax som stöds av :mod:"
"`configparser`.  Parametern *allow_no_value* till konstruktören kan användas "
"för att ange att sådana värden ska accepteras:"

msgid ""
">>> import configparser\n"
"\n"
">>> sample_config = \"\"\"\n"
"... [mysqld]\n"
"...   user = mysql\n"
"...   pid-file = /var/run/mysqld/mysqld.pid\n"
"...   skip-external-locking\n"
"...   old_passwords = 1\n"
"...   skip-bdb\n"
"...   # we don't need ACID today\n"
"...   skip-innodb\n"
"... \"\"\"\n"
">>> config = configparser.ConfigParser(allow_no_value=True)\n"
">>> config.read_string(sample_config)\n"
"\n"
">>> # Settings with values are treated as before:\n"
">>> config[\"mysqld\"][\"user\"]\n"
"'mysql'\n"
"\n"
">>> # Settings without values provide None:\n"
">>> config[\"mysqld\"][\"skip-bdb\"]\n"
"\n"
">>> # Settings which aren't specified still raise an error:\n"
">>> config[\"mysqld\"][\"does-not-exist\"]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'does-not-exist'"
msgstr ""
">>> import configparser\n"
"\n"
">>> sample_config = \"\"\"\n"
"... [mysqld]\n"
"...   user = mysql\n"
"...   pid-file = /var/run/mysqld/mysqld.pid\n"
"...   skip-external-locking\n"
"...   old_passwords = 1\n"
"...   skip-bdb\n"
"...   # we don't need ACID today\n"
"...   skip-innodb\n"
"... \"\"\"\n"
">>> config = configparser.ConfigParser(allow_no_value=True)\n"
">>> config.read_string(sample_config)\n"
"\n"
">>> # Settings with values are treated as before:\n"
">>> config[\"mysqld\"][\"user\"]\n"
"'mysql'\n"
"\n"
">>> # Settings without values provide None:\n"
">>> config[\"mysqld\"][\"skip-bdb\"]\n"
"\n"
">>> # Settings which aren't specified still raise an error:\n"
">>> config[\"mysqld\"][\"does-not-exist\"]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'does-not-exist'"

msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*avgränsningstecken*, standardvärde: ``('=', ':')``"

msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Avgränsare är substrängar som avgränsar nycklar från värden inom ett "
"avsnitt. Den första förekomsten av en avgränsande substräng på en rad "
"betraktas som en avgränsare.  Detta innebär att värden (men inte nycklar) "
"kan innehålla avgränsare."

msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"Se även argumentet *space_around_delimiters* till :meth:`ConfigParser.write`."

msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, standardvärde: ``('#', ';')```"

msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, standardvärde: ``None``"

msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Comment prefixes är strängar som anger början på en giltig kommentar i en "
"konfigurationsfil. *comment_prefixes* används endast på annars tomma rader "
"(eventuellt indragna) medan *inline_comment_prefixes* kan användas efter "
"varje giltigt värde (t.ex. sektionsnamn, alternativ och även tomma rader).  "
"Som standard är inline-kommentarer inaktiverade och ``'#'`` och ``';'`` "
"används som prefix för kommentarer på hela rader."

msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"I tidigare versioner av :mod:`configparser` matchade beteendet "
"``comment_prefixes=('#',';')`` och ``inline_comment_prefixes=(';',)``."

msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Observera att konfigurationsanalysatorer inte stöder escaping av "
"kommentarprefix, så om du använder *inline_comment_prefixes* kan det hindra "
"användare från att ange alternativvärden med tecken som används som "
"kommentarprefix.  Undvik att ange *inline_comment_prefixes* när du är "
"osäker.  Under alla omständigheter är det enda sättet att lagra prefixtecken "
"för kommentarer i början av en rad i flerradiga värden att interpolera "
"prefixet, t.ex.::"

msgid ""
">>> from configparser import ConfigParser, ExtendedInterpolation\n"
">>> parser = ConfigParser(interpolation=ExtendedInterpolation())\n"
">>> # the default BasicInterpolation could be used as well\n"
">>> parser.read_string(\"\"\"\n"
"... [DEFAULT]\n"
"... hash = #\n"
"...\n"
"... [hashes]\n"
"... shebang =\n"
"...   ${hash}!/usr/bin/env python\n"
"...   ${hash} -*- coding: utf-8 -*-\n"
"...\n"
"... extensions =\n"
"...   enabled_extension\n"
"...   another_extension\n"
"...   #disabled_by_comment\n"
"...   yet_another_extension\n"
"...\n"
"... interpolation not necessary = if # is not at line start\n"
"... even in multiline values = line #1\n"
"...   line #2\n"
"...   line #3\n"
"... \"\"\")\n"
">>> print(parser['hashes']['shebang'])\n"
"\n"
"#!/usr/bin/env python\n"
"# -*- coding: utf-8 -*-\n"
">>> print(parser['hashes']['extensions'])\n"
"\n"
"enabled_extension\n"
"another_extension\n"
"yet_another_extension\n"
">>> print(parser['hashes']['interpolation not necessary'])\n"
"if # is not at line start\n"
">>> print(parser['hashes']['even in multiline values'])\n"
"line #1\n"
"line #2\n"
"line #3"
msgstr ""
">>> from configparser import ConfigParser, UtökadInterpolation\n"
">>> parser = ConfigParser(interpolation=ExtendedInterpolation())\n"
">>> # standard BasicInterpolation kan också användas\n"
">>> parser.read_string(\"\"\"\n"
"... [DEFAULT]\n"
"... hash = #\n"
"...\n"
"... [hash]\n"
"... shebang =\n"
"... ${hash}!/usr/bin/env python\n"
"... ${hash} -*- kodning: utf-8 -*-\n"
"...\n"
"... tillägg =\n"
"... aktiverad_utvidgning\n"
"... en annan_utvidgning\n"
"...   # inaktiverad_av_kommentar\n"
"... ännu_en annan_förlängning\n"
"...\n"
"... interpolering inte nödvändig = om # inte är i början av raden\n"
"... även i värden med flera rader = rad #1\n"
"... rad 2\n"
"... rad #3\n"
"... \"\"\")\n"
">>> print(parser['hashes']['shebang'])\n"
"\n"
"#!/usr/bin/env python\n"
"# -*- kodning: utf-8 -*-\n"
">>> print(parser['hashes']['extensions'])\n"
"\n"
"aktiverad_utvidgning\n"
"another_extension\n"
"yet_another_extension\n"
">>> print(parser['hashes']['interpolation ej nödvändig'])\n"
"om # inte är vid radstart\n"
">>> print(parser['hashes']['även i värden med flera rader'])\n"
"rad #1\n"
"rad #2\n"
"rad #3"

msgid "*strict*, default value: ``True``"
msgstr "*strict*, standardvärde: ``True``"

msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`~ConfigParser."
"read_file`, :meth:`~ConfigParser.read_string` or :meth:`~ConfigParser."
"read_dict`).  It is recommended to use strict parsers in new applications."
msgstr ""
"När inställningen är ``True`` tillåter inte parsern att avsnitt eller "
"alternativ dupliceras när den läser från en enda källa (med :meth:"
"`~ConfigParser.read_file`, :meth:`~ConfigParser.read_string` eller :meth:"
"`~ConfigParser.read_dict`).  Det rekommenderas att använda strikta parsers i "
"nya applikationer."

msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"I tidigare versioner av :mod:`configparser` matchade beteendet "
"``strict=False``."

msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, standardvärde: ``True``"

msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"I config-parsers kan värden sträcka sig över flera rader så länge de är "
"indragna mer än den nyckel som innehåller dem.  Som standard låter parsers "
"även tomma rader vara delar av värden.  Samtidigt kan nycklarna själva vara "
"godtyckligt indragna för att förbättra läsbarheten.  När konfigurationsfiler "
"blir stora och komplexa är det därför lätt för användaren att tappa bort "
"filstrukturen.  Ta till exempel:"

msgid ""
"[Section]\n"
"key = multiline\n"
"  value with a gotcha\n"
"\n"
" this = is still a part of the multiline value of 'key'"
msgstr ""
"[Sektion]\n"
"nyckel = multilinje\n"
"  värde med en gotcha\n"
"\n"
" detta = är fortfarande en del av det flerledade värdet av 'nyckel'"

msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Detta kan vara särskilt problematiskt för användaren att se om hon använder "
"ett proportionellt teckensnitt för att redigera filen.  Det är därför du bör "
"överväga att inte tillåta värden med tomma rader när din applikation inte "
"behöver dem.  Detta kommer att göra att tomma rader delar tangenter varje "
"gång.  I exemplet ovan skulle det ge två nycklar, ``key`` och ``this``."

msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, standardvärde: ``configparser.DEFAULTSECT`` (det vill "
"säga: ``\"DEFAULT\"``)"

msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"Konventionen att tillåta ett speciellt avsnitt med standardvärden för andra "
"avsnitt eller interpoleringsändamål är ett kraftfullt koncept i detta "
"bibliotek, vilket gör det möjligt för användare att skapa komplexa "
"deklarativa konfigurationer.  Detta avsnitt kallas normalt ``\"DEFAULT\"`` "
"men det kan anpassas så att det pekar på vilket annat giltigt avsnittsnamn "
"som helst.  Några typiska värden är t.ex: ``\"general\"`` eller "
"``\"common\"``.  Det angivna namnet används för att känna igen "
"standardavsnitt när man läser från en källa och används när man skriver "
"tillbaka konfigurationen till en fil.  Dess aktuella värde kan hämtas med "
"hjälp av attributet ``parser_instance.default_section`` och kan ändras under "
"körning (t.ex. för att konvertera filer från ett format till ett annat)."

msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr "*interpolation*, standardvärde: ``configparser.BasicInterpolation``"

msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"Interpolationsbeteendet kan anpassas genom att tillhandahålla en anpassad "
"hanterare via argumentet *interpolation*. ``None`` kan användas för att "
"stänga av interpolering helt, ``ExtendedInterpolation()`` ger en mer "
"avancerad variant inspirerad av ``zc.buildout``.  Mer om ämnet i det "
"`dedikerade dokumentationsavsnittet <#interpolation-av-värden>`_. :class:"
"`RawConfigParser` har ett standardvärde på ``None``."

msgid "*converters*, default value: not set"
msgstr "*omvandlare*, standardvärde: inte inställt"

msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`!getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"Config-parsers tillhandahåller getters för alternativvärden som utför "
"typkonvertering.  Som standard implementeras :meth:`~ConfigParser.getint`, :"
"meth:`~ConfigParser.getfloat` och :meth:`~ConfigParser.getboolean`.  Om "
"andra getters är önskvärda kan användare definiera dem i en subklass eller "
"skicka en dictionary där varje nyckel är ett namn på omvandlaren och varje "
"värde är en anropsbar som implementerar omvandlingen.  Till exempel, om man "
"skickar ``{'decimal': decimal.Decimal}`` skulle man lägga till :meth:`!"
"getdecimal` på både parserobjektet och alla sektionsproxies.  Med andra ord "
"kommer det att vara möjligt att skriva både ``parser_instance."
"getdecimal('section', 'key', fallback=0)`` och ``parser_instance['section']."
"getdecimal('key', 0)``."

msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"Om omvandlaren behöver komma åt parserns tillstånd kan det implementeras som "
"en metod i en config parser-underklass.  Om namnet på denna metod börjar med "
"``get`` kommer den att vara tillgänglig på alla sektionsproxyer, i den dict-"
"kompatibla formen (se exemplet ``getdecimal()`` ovan)."

msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"Mer avancerad anpassning kan uppnås genom att åsidosätta standardvärdena för "
"dessa parserattribut.  Standardvärdena definieras för klasserna, så de kan "
"åsidosättas av subklasser eller genom attributtilldelning."

msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"Som standard när :meth:`~ConfigParser.getboolean` används, beaktar config-"
"parser följande värden ``True``: ``'1'``, ``'yes'``, ``'true'``, ``'on'`` "
"och följande värden ``False``: ``'0'``, ``'no'``, ``'false'``, ``'off'``.  "
"Du kan åsidosätta detta genom att ange en anpassad ordlista med strängar och "
"deras booleska resultat. Till exempel:"

msgid ""
">>> custom = configparser.ConfigParser()\n"
">>> custom['section1'] = {'funky': 'nope'}\n"
">>> custom['section1'].getboolean('funky')\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Not a boolean: nope\n"
">>> custom.BOOLEAN_STATES = {'sure': True, 'nope': False}\n"
">>> custom['section1'].getboolean('funky')\n"
"False"
msgstr ""
">>> anpassad = configparser.ConfigParser()\n"
">>> custom['section1'] = {'funky': 'nope'}\n"
">>> custom['section1'].getboolean('funky')\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"ValueError (värdefel): Inte en boolean: nope\n"
">>> custom.BOOLEAN_STATES = {'sure': True, 'nope': False}\n"
">>> custom['section1'].getboolean('funky')\n"
"False"

msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""
"Andra typiska booleska par är ``accept``/`reject`` eller ``enabled``/"
"`disabled``."

msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"Denna metod omvandlar optionsnamn vid varje read-, get- eller set-"
"operation.  Som standard konverteras namnet till gemener.  Detta innebär "
"också att när en konfigurationsfil skrivs kommer alla nycklar att vara "
"gemener.  Åsidosätt denna metod om det är olämpligt. Till exempel:"

msgid ""
">>> config = \"\"\"\n"
"... [Section1]\n"
"... Key = Value\n"
"...\n"
"... [Section2]\n"
"... AnotherKey = Value\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> list(typical['Section1'].keys())\n"
"['key']\n"
">>> list(typical['Section2'].keys())\n"
"['anotherkey']\n"
">>> custom = configparser.RawConfigParser()\n"
">>> custom.optionxform = lambda option: option\n"
">>> custom.read_string(config)\n"
">>> list(custom['Section1'].keys())\n"
"['Key']\n"
">>> list(custom['Section2'].keys())\n"
"['AnotherKey']"
msgstr ""
">>> config = \"\"\"\n"
"... [Avsnitt1]\n"
"... Nyckel = Värde\n"
"...\n"
"... [Avsnitt2]\n"
"... En annan nyckel = värde\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> list(typical['Section1'].keys())\n"
"['key']\n"
">>> list(typical['Section2'].keys())\n"
"['anotherkey']\n"
">>> anpassad = configparser.RawConfigParser()\n"
">>> custom.optionxform = lambda option: option\n"
">>> custom.read_string(config)\n"
">>> list(custom['Section1'].keys())\n"
"['Key']\n"
">>> list(custom['Section2'].keys())\n"
"['AnotherKey']"

msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""
"Funktionen optionxform omvandlar optionsnamn till en kanonisk form. Detta "
"bör vara en idempotent funktion: om namnet redan är i kanonisk form bör det "
"returneras oförändrat."

msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""
"Ett kompilerat reguljärt uttryck som används för att analysera "
"sektionsrubriker.  Standardvärdet matchar ``[section]`` till namnet "
"``\"section\"``.  Whitespace anses vara en del av sektionsnamnet, så "
"``[ larch ]`` kommer att läsas som en sektion med namnet ``\" larch\"``.  "
"Åsidosätt detta attribut om det är olämpligt.  Exempelvis:"

msgid ""
">>> import re\n"
">>> config = \"\"\"\n"
"... [Section 1]\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> typical.sections()\n"
"['Section 1', '  Section 2  ']\n"
">>> custom = configparser.ConfigParser()\n"
">>> custom.SECTCRE = re.compile(r\"\\[ *(?P<header>[^]]+?) *\\]\")\n"
">>> custom.read_string(config)\n"
">>> custom.sections()\n"
"['Section 1', 'Section 2']"
msgstr ""
"&gt;&gt;&gt; import re\n"
"&gt;&gt;&gt; config = \"\"\"\n"
"... [Avsnitt 1]\n"
"... alternativ = värde\n"
"...\n"
"... [ Avsnitt 2 ]\n"
"... annan = val\n"
"... \"\"\"\n"
"&gt;&gt;&gt; typical = configparser.ConfigParser()\n"
"&gt;&gt;&gt; typical.read_string(config)\n"
"&gt;&gt;&gt; typical.sections()\n"
"['Avsnitt 1', ' Avsnitt 2']\n"
"&gt;&gt;&gt; anpassad = configparser.ConfigParser()\n"
"&gt;&gt;&gt; custom.SECTCRE = re.compile(r\"\\[ *(?P<header>[^]]+?) *\\]\")\n"
"&gt;&gt;&gt; custom.read_string(config)\n"
"&gt;&gt;&gt; custom.sections()\n"
"['Avsnitt 1', 'Avsnitt 2']"

msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"Även om ConfigParser-objekt också använder ett ``OPTCRE``-attribut för att "
"känna igen optionsrader rekommenderas det inte att åsidosätta det eftersom "
"det skulle störa konstruktoralternativen *allow_no_value* och *delimiters*."

msgid "Legacy API Examples"
msgstr "Exempel på äldre API"

msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"Främst på grund av bakåtkompatibilitet tillhandahåller :mod:`configparser` "
"också ett äldre API med explicita ``get``/``set``-metoder.  Även om det "
"finns giltiga användningsfall för de metoder som beskrivs nedan, föredras "
"åtkomst via mappningsprotokoll för nya projekt.  Det äldre API:et är ibland "
"mer avancerat, på låg nivå och rent av kontraintuitivt."

msgid "An example of writing to a configuration file::"
msgstr "Ett exempel på hur man skriver till en konfigurationsfil::"

msgid ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"\n"
"# Please note that using RawConfigParser's set functions, you can assign\n"
"# non-string values to keys internally, but will receive an error when\n"
"# attempting to write to a file or when you get it in non-raw mode. Setting\n"
"# values using the mapping protocol or ConfigParser's set() does not allow\n"
"# such assignments to take place.\n"
"config.add_section('Section1')\n"
"config.set('Section1', 'an_int', '15')\n"
"config.set('Section1', 'a_bool', 'true')\n"
"config.set('Section1', 'a_float', '3.1415')\n"
"config.set('Section1', 'baz', 'fun')\n"
"config.set('Section1', 'bar', 'Python')\n"
"config.set('Section1', 'foo', '%(bar)s is %(baz)s!')\n"
"\n"
"# Writing our configuration file to 'example.cfg'\n"
"with open('example.cfg', 'w') as configfile:\n"
"    config.write(configfile)"
msgstr ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"\n"
"# Please note that using RawConfigParser's set functions, you can assign\n"
"# non-string values to keys internally, but will receive an error when\n"
"# attempting to write to a file or when you get it in non-raw mode. Setting\n"
"# values using the mapping protocol or ConfigParser's set() does not allow\n"
"# such assignments to take place.\n"
"config.add_section('Section1')\n"
"config.set('Section1', 'an_int', '15')\n"
"config.set('Section1', 'a_bool', 'true')\n"
"config.set('Section1', 'a_float', '3.1415')\n"
"config.set('Section1', 'baz', 'fun')\n"
"config.set('Section1', 'bar', 'Python')\n"
"config.set('Section1', 'foo', '%(bar)s is %(baz)s!')\n"
"\n"
"# Writing our configuration file to 'example.cfg'\n"
"with open('example.cfg', 'w') as configfile:\n"
"    config.write(configfile)"

msgid "An example of reading the configuration file again::"
msgstr "Ett exempel på att läsa konfigurationsfilen igen::"

msgid ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"config.read('example.cfg')\n"
"\n"
"# getfloat() raises an exception if the value is not a float\n"
"# getint() and getboolean() also do this for their respective types\n"
"a_float = config.getfloat('Section1', 'a_float')\n"
"an_int = config.getint('Section1', 'an_int')\n"
"print(a_float + an_int)\n"
"\n"
"# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.\n"
"# This is because we are using a RawConfigParser().\n"
"if config.getboolean('Section1', 'a_bool'):\n"
"    print(config.get('Section1', 'foo'))"
msgstr ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"config.read('example.cfg')\n"
"\n"
"# getfloat() raises an exception if the value is not a float\n"
"# getint() and getboolean() also do this for their respective types\n"
"a_float = config.getfloat('Section1', 'a_float')\n"
"an_int = config.getint('Section1', 'an_int')\n"
"print(a_float + an_int)\n"
"\n"
"# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.\n"
"# This is because we are using a RawConfigParser().\n"
"if config.getboolean('Section1', 'a_bool'):\n"
"    print(config.get('Section1', 'foo'))"

msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "För att få interpolation, använd :class:`ConfigParser`::"

msgid ""
"import configparser\n"
"\n"
"cfg = configparser.ConfigParser()\n"
"cfg.read('example.cfg')\n"
"\n"
"# Set the optional *raw* argument of get() to True if you wish to disable\n"
"# interpolation in a single get operation.\n"
"print(cfg.get('Section1', 'foo', raw=False))  # -> \"Python is fun!\"\n"
"print(cfg.get('Section1', 'foo', raw=True))   # -> \"%(bar)s is %(baz)s!\"\n"
"\n"
"# The optional *vars* argument is a dict with members that will take\n"
"# precedence in interpolation.\n"
"print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation',\n"
"                                       'baz': 'evil'}))\n"
"\n"
"# The optional *fallback* argument can be used to provide a fallback value\n"
"print(cfg.get('Section1', 'foo'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'foo', fallback='Monty is not.'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback='No such things as "
"monsters.'))\n"
"      # -> \"No such things as monsters.\"\n"
"\n"
"# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError\n"
"# but we can also use:\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback=None))\n"
"      # -> None"
msgstr ""
"import configparser\n"
"\n"
"cfg = configparser.ConfigParser()\n"
"cfg.read('example.cfg')\n"
"\n"
"# Set the optional *raw* argument of get() to True if you wish to disable\n"
"# interpolation in a single get operation.\n"
"print(cfg.get('Section1', 'foo', raw=False))  # -> \"Python is fun!\"\n"
"print(cfg.get('Section1', 'foo', raw=True))   # -> \"%(bar)s is %(baz)s!\"\n"
"\n"
"# The optional *vars* argument is a dict with members that will take\n"
"# precedence in interpolation.\n"
"print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation',\n"
"                                       'baz': 'evil'}))\n"
"\n"
"# The optional *fallback* argument can be used to provide a fallback value\n"
"print(cfg.get('Section1', 'foo'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'foo', fallback='Monty is not.'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback='No such things as "
"monsters.'))\n"
"      # -> \"No such things as monsters.\"\n"
"\n"
"# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError\n"
"# but we can also use:\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback=None))\n"
"      # -> None"

msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"Standardvärden finns tillgängliga i båda typerna av ConfigParsers.  De "
"används vid interpolering om ett alternativ som används inte är definierat "
"någon annanstans. ::"

msgid ""
"import configparser\n"
"\n"
"# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each\n"
"config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})\n"
"config.read('example.cfg')\n"
"\n"
"print(config.get('Section1', 'foo'))     # -> \"Python is fun!\"\n"
"config.remove_option('Section1', 'bar')\n"
"config.remove_option('Section1', 'baz')\n"
"print(config.get('Section1', 'foo'))     # -> \"Life is hard!\""
msgstr ""
"import configparser\n"
"\n"
"# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each\n"
"config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})\n"
"config.read('example.cfg')\n"
"\n"
"print(config.get('Section1', 'foo'))     # -> \"Python is fun!\"\n"
"config.remove_option('Section1', 'bar')\n"
"config.remove_option('Section1', 'baz')\n"
"print(config.get('Section1', 'foo'))     # -> \"Life is hard!\""

msgid "ConfigParser Objects"
msgstr "ConfigParser-objekt"

msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"Den huvudsakliga konfigurationsparsern.  När *defaults* anges initialiseras "
"den till en ordbok med inneboende standardvärden.  När *dict_type* anges "
"kommer den att användas för att skapa ordboksobjekt för listan över avsnitt, "
"för alternativen inom ett avsnitt och för standardvärdena."

msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"När *delimiters* anges används det som den uppsättning substrängar som "
"skiljer nycklar från värden.  När *comment_prefixes* anges kommer det att "
"användas som en uppsättning substrängar som prefixar kommentarer i annars "
"tomma rader. Kommentarer kan vara indragna.  När *inline_comment_prefixes* "
"anges kommer det att användas som den uppsättning substrängar som prefixar "
"kommentarer på icke-tomma rader."

msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"När *strict* är ``True`` (standard) kommer parsern inte att tillåta "
"dubbletter av avsnitt eller alternativ när den läser från en enda källa "
"(fil, sträng eller ordbok), vilket ger :exc:`DuplicateSectionError` eller :"
"exc:`DuplicateOptionError`.  När *empty_lines_in_values* är ``False`` "
"(standard: ``True``) markerar varje tom rad slutet på ett alternativ.  "
"Annars behålls interna tomma rader i ett flerradigt alternativ som en del av "
"värdet. När *allow_no_value* är ``True`` (standard: ``False``) accepteras "
"alternativ utan värden; värdet för dessa är ``None`` och de serialiseras "
"utan den efterföljande avgränsaren."

msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"at runtime using the ``default_section`` instance attribute. This won't re-"
"evaluate an already parsed config file, but will be used when writing parsed "
"settings to a new config file."
msgstr ""
"När *default_section* anges, specificeras namnet på det speciella avsnitt "
"som innehåller standardvärden för andra avsnitt och för "
"interpoleringsändamål (normalt benämnt ``\"DEFAULT\"``).  Detta värde kan "
"hämtas och ändras vid körning med hjälp av instansattributet "
"``default_section``. Detta kommer inte att omvärdera en redan analyserad "
"konfigurationsfil, men kommer att användas när du skriver analyserade "
"inställningar till en ny konfigurationsfil."

msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"Interpolationsbeteendet kan anpassas genom att tillhandahålla en anpassad "
"hanterare via argumentet *interpolation*. ``None`` kan användas för att "
"stänga av interpolering helt, ``ExtendedInterpolation()`` ger en mer "
"avancerad variant inspirerad av ``zc.buildout``.  Mer om ämnet i det "
"`dedikerade dokumentationsavsnittet <#interpolation-av-värden>`_."

msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"Alla alternativnamn som används i interpoleringen skickas genom metoden :"
"meth:`optionxform` precis som alla andra referenser till alternativnamn.  "
"Till exempel, med standardimplementeringen av :meth:`optionxform` (som "
"konverterar alternativnamn till gemener), är värdena ``foo %(bar)s`` och "
"``foo %(BAR)s`` likvärdiga."

msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`!get*` method on the parser "
"object and section proxies."
msgstr ""
"När *converters* anges bör det vara en dictionary där varje nyckel "
"representerar namnet på en typomvandlare och varje värde är en anropsbar som "
"implementerar omvandlingen från sträng till önskad datatyp.  Varje "
"omvandlare får sin egen motsvarande :meth:`!get*`-metod på parserobjektet "
"och sektionsproxyerna."

msgid ""
"When *allow_unnamed_section* is ``True`` (default: ``False``), the first "
"section name can be omitted. See the `\"Unnamed Sections\" section <#unnamed-"
"sections>`_."
msgstr ""
"När *allow_unnamed_section* är ``True`` (standard: ``False``) kan det första "
"sektionsnamnet utelämnas. Se avsnittet `\"Unnamed Sections\" <#unnamed-"
"sections>`_."

msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "Standardvärdet för *dict_type* är :class:`collections.OrderedDict`."

msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* och *interpolation* har lagts "
"till."

msgid "The *converters* argument was added."
msgstr "Argumentet *konverterare* har lagts till."

msgid ""
"The *defaults* argument is read with :meth:`read_dict`, providing consistent "
"behavior across the parser: non-string keys and values are implicitly "
"converted to strings."
msgstr ""
"Argumentet *defaults* läses med :meth:`read_dict`, vilket ger ett konsekvent "
"beteende i hela parsern: nycklar och värden som inte är strängar konverteras "
"implicit till strängar."

msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""
"Standard *dict_type* är :class:`dict`, eftersom den nu bevarar "
"inmatningsordningen."

msgid ""
"Raise a :exc:`MultilineContinuationError` when *allow_no_value* is ``True``, "
"and a key without a value is continued with an indented line."
msgstr ""
"Skapar ett :exc:`MultilineContinuationError` när *allow_no_value* är "
"``True``, och en nyckel utan värde fortsätter med en indragen rad."

msgid "The *allow_unnamed_section* argument was added."
msgstr "Argumentet *allow_unnamed_section* har lagts till."

msgid "Return a dictionary containing the instance-wide defaults."
msgstr ""
"Returnerar en ordbok som innehåller de instansövergripande standardvärdena."

msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""
"Returnerar en lista över tillgängliga sektioner; *standardsektionen* ingår "
"inte i listan."

msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"Lägger till en sektion med namnet *section* till instansen.  Om en sektion "
"med det angivna namnet redan existerar, :exc:`DuplicateSectionError` tas "
"upp.  Om *default section*-namnet anges, genereras :exc:`ValueError`.  "
"Namnet på sektionen måste vara en sträng, annars visas :exc:`TypeError`."

msgid "Non-string section names raise :exc:`TypeError`."
msgstr "Icke-strängade sektionsnamn ger upphov till :exc:`TypeError`."

msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""
"Indikerar om den namngivna *sektionen* finns i konfigurationen. "
"Standardavsnittet *default section* bekräftas inte."

msgid "Return a list of options available in the specified *section*."
msgstr ""
"Returnerar en lista över alternativ som är tillgängliga i den angivna "
"*sektionen*."

msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"Om den angivna *sektionen* finns och innehåller den angivna *optionen*, "
"returneras :const:`True`; annars returneras :const:`False`.  Om den angivna "
"*sektionen* är :const:`None` eller en tom sträng, antas DEFAULT."

msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""
"Försöker läsa och analysera en iterabel med filnamn och returnerar en lista "
"med filnamn som analyserats framgångsrikt."

msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"Om *filnamn* är en sträng, ett :class:`bytes`-objekt eller ett :term:`path-"
"liknande objekt`, behandlas det som ett enda filnamn.  Om en fil som anges i "
"*filnamn* inte kan öppnas ignoreras den filen.  Detta är utformat så att du "
"kan ange en iterabel av potentiella platser för konfigurationsfiler (till "
"exempel den aktuella katalogen, användarens hemkatalog och någon "
"systemomfattande katalog), och alla befintliga konfigurationsfiler i den "
"iterabla kommer att läsas."

msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"Om ingen av de namngivna filerna finns, kommer :class:`ConfigParser`-"
"instansen att innehålla en tom dataset.  En applikation som kräver att "
"initiala värden laddas från en fil bör ladda den eller de filer som krävs "
"med hjälp av :meth:`read_file` innan den anropar :meth:`read` för eventuella "
"valfria filer:"

msgid ""
"import configparser, os\n"
"\n"
"config = configparser.ConfigParser()\n"
"config.read_file(open('defaults.cfg'))\n"
"config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],\n"
"            encoding='cp1250')"
msgstr ""
"import configparser, os\n"
"\n"
"config = configparser.ConfigParser()\n"
"config.read_file(open('defaults.cfg'))\n"
"config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],\n"
"            encoding='cp1250')"

msgid ""
"Added the *encoding* parameter. Previously, all files were read using the "
"default encoding for :func:`open`."
msgstr ""
"Parametern *encoding* har lagts till. Tidigare lästes alla filer med hjälp "
"av standardkodningen för :func:`open`."

msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "Parametern *filnamn* accepterar en :term:`path-liknande objekt`."

msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "Parametern *filnamn* accepterar ett :class:`bytes`-objekt."

msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"Läser och analyserar konfigurationsdata från *f* som måste vara en iterabel "
"som ger Unicode-strängar (t.ex. filer som öppnas i textläge)."

msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`!name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"Det valfria argumentet *källa* anger namnet på den fil som läses.  Om det "
"inte anges och *f* har attributet :attr:`!name`, används det för *source*; "
"standardvärdet är ``'<???>'``."

msgid "Replaces :meth:`!readfp`."
msgstr "Ersätter :meth:`!readfp`."

msgid "Parse configuration data from a string."
msgstr "Analyserar konfigurationsdata från en sträng."

msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"Det valfria argumentet *source* anger ett kontextspecifikt namn på den "
"sträng som skickas.  Om det inte anges används ``'<string>'``.  Detta bör "
"vanligtvis vara en filsystemssökväg eller en URL."

msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"Ladda konfiguration från ett objekt som tillhandahåller en diktliknande "
"metod ``items()``.  Nycklar är namn på sektioner, värden är ordböcker med "
"nycklar och värden som ska finnas i sektionen.  Om den använda ordbokstypen "
"bevarar ordningen kommer sektioner och deras nycklar att läggas till i "
"ordning. Värden konverteras automatiskt till strängar."

msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"Det valfria argumentet *source* anger ett kontextspecifikt namn på den "
"ordbok som skickas.  Om det inte anges används ``<dict>``."

msgid "This method can be used to copy state between parsers."
msgstr "Denna metod kan användas för att kopiera tillstånd mellan parsers."

msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"Hämta ett *option*-värde för den namngivna *section*.  Om *vars* anges måste "
"det vara en ordbok.  *Alternativet* söks upp i *vars* (om det finns), "
"*section* och *DEFAULTSECT* i den ordningen.  Om nyckeln inte hittas och "
"*fallback* anges, används den som ett reservvärde.  ``None`` kan anges som "
"ett *fallback*-värde."

msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"Alla ``'%'``-interpoleringar expanderas i returvärdena, såvida inte "
"argumentet *raw* är true.  Värden för interpolationsnycklar söks upp på "
"samma sätt som för alternativet."

msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"Argumenten *raw*, *vars* och *fallback* är nyckelord endast för att skydda "
"användare från att försöka använda det tredje argumentet som *fallback*-"
"fallback (särskilt vid användning av mappningsprotokollet)."

msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"En praktisk metod som omvandlar *alternativet* i den angivna *sektionen* "
"till ett heltal.  Se :meth:`get` för förklaring av *raw*, *vars* och "
"*fallback*."

msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating-point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"En praktisk metod som omvandlar *alternativet* i den angivna *sektionen* "
"till ett flyttal.  Se :meth:`get` för förklaring av *raw*, *vars* och "
"*fallback*."

msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"En bekvämlighetsmetod som tvingar *alternativet* i den angivna *sektionen* "
"till ett booleskt värde.  Observera att de accepterade värdena för "
"alternativet är ``'1'``, ``'yes'``, ``'true'`` och ``'on'``, som gör att "
"denna metod returnerar ``True``, och ``'0'``, ``'no'``, ``'false'`` och "
"``'off'``, som gör att den returnerar ``False``.  Dessa strängvärden "
"kontrolleras på ett sätt som inte tar hänsyn till skiftlägesskillnader.  "
"Alla andra värden kommer att ge upphov till :exc:`ValueError`.  Se :meth:"
"`get` för förklaring av *raw*, *vars* och *fallback*."

msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"Om *section* inte anges, returneras en lista med paren *section_name*, "
"*section_proxy*, inklusive DEFAULTSECT."

msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""
"I annat fall returneras en lista med paren *namn*, *värde* för alternativen "
"i den angivna *sektionen*.  Valfria argument har samma betydelse som för "
"metoden :meth:`get`."

msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"Objekt som finns i *vars* visas inte längre i resultatet.  Det tidigare "
"beteendet blandade faktiska parseralternativ med variabler som "
"tillhandahölls för interpolering."

msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"Om det givna avsnittet finns, sätt det givna alternativet till det angivna "
"värdet; annars uppstår :exc:`NoSectionError`.  *option* och *value* måste "
"vara strängar; om inte, uppstår :exc:`TypeError`."

msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"Skriver en representation av konfigurationen till det angivna :term:"
"`filobjektet`, som måste öppnas i textläge (accepterar strängar).  Denna "
"representation kan analyseras av ett framtida :meth:`read`-anrop.  Om "
"*space_around_delimiters* är true, omges avgränsningar mellan nycklar och "
"värden av mellanslag."

msgid ""
"Raises InvalidWriteError if this would write a representation which cannot "
"be accurately parsed by a future :meth:`read` call from this parser."
msgstr ""
"Utlöser InvalidWriteError om detta skulle skriva en representation som inte "
"kan analyseras korrekt av ett framtida :meth:`read`-anrop från denna "
"analysator."

msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"Kommentarer i den ursprungliga konfigurationsfilen bevaras inte när "
"konfigurationen skrivs tillbaka. Vad som betraktas som en kommentar beror på "
"de angivna värdena för *comment_prefix* och *inline_comment_prefix*."

msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"Tar bort det angivna *alternativet* från det angivna *avsnittet*.  Om "
"sektionen inte finns, returneras :exc:`NoSectionError`.  Om alternativet "
"existerade för att tas bort, returneras :const:`True`; annars returneras :"
"const:`False`."

msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"Tar bort den angivna *sektionen* från konfigurationen.  Om avsnittet "
"faktiskt existerade returneras ``True``.  Annars returneras ``False``."

msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"Transformerar optionsnamnet *option* som finns i en indatafil eller som "
"skickas in av klientkod till den form som ska användas i de interna "
"strukturerna.  Standardimplementeringen returnerar en version av *option* "
"med små bokstäver; subklasser kan åsidosätta detta eller så kan klientkoden "
"ange ett attribut med detta namn på instanser för att påverka detta beteende."

msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"Du behöver inte underklassa parsern för att använda den här metoden, du kan "
"också ställa in den på en instans, till en funktion som tar ett "
"strängargument och returnerar en sträng.  Att ställa in den till ``str``, "
"till exempel, skulle göra alternativnamn skiftlägeskänsliga::"

msgid ""
"cfgparser = ConfigParser()\n"
"cfgparser.optionxform = str"
msgstr ""
"cfgparser = ConfigParser()\n"
"cfgparser.optionxform = str"

msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""
"Observera att vid läsning av konfigurationsfiler tas blanksteg runt "
"alternativnamnen bort innan :meth:`optionxform` anropas."

msgid ""
"A special object representing a section name used to reference the unnamed "
"section (see :ref:`unnamed-sections`)."
msgstr ""
"Ett specialobjekt som representerar ett sektionsnamn som används för att "
"referera till en icke namngiven sektion (se :ref:`unnamed-sections`)."

msgid ""
"The maximum depth for recursive interpolation for :meth:`~configparser."
"ConfigParser.get` when the *raw* parameter is false.  This is relevant only "
"when the default *interpolation* is used."
msgstr ""
"Det maximala djupet för rekursiv interpolation för :meth:`~configparser."
"ConfigParser.get` när parametern *raw* är false.  Detta är endast relevant "
"när standardvärdet *interpolation* används."

msgid "RawConfigParser Objects"
msgstr "RawConfigParser-objekt"

msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"Äldre variant av :class:`ConfigParser`.  Den har interpolering inaktiverad "
"som standard och tillåter icke-strängade sektionsnamn, alternativnamn och "
"värden via dess osäkra metoder ``add_section`` och ``set``, samt den äldre "
"``defaults=`` nyckelordsargumenthanteringen."

msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"Överväg att använda :class:`ConfigParser` istället, som kontrollerar typerna "
"för de värden som ska lagras internt.  Om du inte vill ha interpolering kan "
"du använda ``ConfigParser(interpolation=None)``."

msgid ""
"Add a section named *section* or :const:`UNNAMED_SECTION` to the instance."
msgstr ""
"Lägg till en sektion med namnet *section* eller :const:`UNNAMED_SECTION` "
"till instansen."

msgid ""
"If the given section already exists, :exc:`DuplicateSectionError` is raised. "
"If the *default section* name is passed, :exc:`ValueError` is raised. If :"
"const:`UNNAMED_SECTION` is passed and support is disabled, :exc:"
"`UnnamedSectionDisabledError` is raised."
msgstr ""
"Om den angivna sektionen redan existerar, :exc:`DuplicateSectionError`. Om "
"*standardnamnet* på sektionen anges, genereras :exc:`ValueError`. Om :const:"
"`UNNAMED_SECTION` anges och stödet är inaktiverat, genereras :exc:"
"`UnnamedSectionDisabledError`."

msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"Type of *section* kontrolleras inte, vilket gör det möjligt för användare "
"att skapa avsnitt med namn som inte är strängnamn.  Detta beteende stöds "
"inte och kan orsaka interna fel."

msgid "Added support for :const:`UNNAMED_SECTION`."
msgstr "Lagt till stöd för :const:`UNNAMED_SECTION`."

msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"Om den givna sektionen finns, sätt det givna alternativet till det angivna "
"värdet; annars uppstår :exc:`NoSectionError`.  Det är möjligt att använda :"
"class:`RawConfigParser` (eller :class:`ConfigParser` med *raw*-parametrar "
"inställda på true) för *intern* lagring av värden som inte är strängvärden, "
"men full funktionalitet (inklusive interpolering och utmatning till filer) "
"kan endast uppnås med strängvärden."

msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"Med den här metoden kan användare tilldela icke-strängvärden till nycklar "
"internt.  Detta beteende stöds inte och kommer att orsaka fel när man "
"försöker skriva till en fil eller hämta den i icke-rått läge.  **Använd "
"mappningsprotokollets API** som inte tillåter att sådana tilldelningar sker."

msgid "Exceptions"
msgstr "Undantag"

msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "Basklass för alla andra :mod:`configparser`-undantag."

msgid "Exception raised when a specified section is not found."
msgstr "Undantag som uppstår när ett angivet avsnitt inte hittas."

msgid ""
"Exception raised if :meth:`~ConfigParser.add_section` is called with the "
"name of a section that is already present or in strict parsers when a "
"section if found more than once in a single input file, string or dictionary."
msgstr ""
"Undantag om :meth:`~ConfigParser.add_section` anropas med namnet på ett "
"avsnitt som redan finns eller i strikta parsers när ett avsnitt hittas mer "
"än en gång i en enda indatafil, sträng eller ordbok."

msgid ""
"Added the optional *source* and *lineno* attributes and parameters to :meth:"
"`!__init__`."
msgstr ""
"Lagt till de valfria attributen och parametrarna *source* och *lineno* till :"
"meth:`!__init__`."

msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"Undantag som tas upp av strikta parsers om ett enda alternativ visas två "
"gånger under läsning från en enda fil, sträng eller ordbok. Detta fångar upp "
"felstavningar och fel relaterade till skiftlägeskänslighet, t.ex. kan en "
"ordbok ha två nycklar som representerar samma skiftlägesokänsliga "
"konfigurationsnyckel."

msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""
"Undantag som uppstår när ett angivet alternativ inte finns i det angivna "
"avsnittet."

msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""
"Basklass för undantag som uppstår när det uppstår problem vid "
"stränginterpolering."

msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"Undantag som uppstår när stränginterpolering inte kan slutföras eftersom "
"antalet iterationer överstiger :const:`MAX_INTERPOLATION_DEPTH`.  Underklass "
"till :exc:`InterpolationError`."

msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
"Undantag som uppstår när ett alternativ som refereras från ett värde inte "
"finns. Underklass till :exc:`InterpolationError`."

msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"Undantag som uppstår när källtexten i vilken substitutioner görs inte "
"överensstämmer med den syntax som krävs.  Underklass till :exc:"
"`InterpolationError`."

msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"Exception vid försök att analysera en fil som inte har några "
"avsnittsrubriker."

msgid "Exception raised when errors occur attempting to parse a file."
msgstr ""
"Undantag som uppstår när fel inträffar vid försök att analysera en fil."

msgid ""
"The ``filename`` attribute and :meth:`!__init__` constructor argument were "
"removed.  They have been available using the name ``source`` since 3.2."
msgstr ""
"Attributet ``filnamn`` och :meth:`!__init__`-konstruktörsargumentet togs "
"bort.  De har varit tillgängliga med namnet ``source`` sedan 3.2."

msgid ""
"Exception raised when a key without a corresponding value is continued with "
"an indented line."
msgstr ""
"Undantag när en tangent utan motsvarande värde fortsätter med en indragen "
"rad."

msgid ""
"Exception raised when attempting to use the :const:`UNNAMED_SECTION` without "
"enabling it."
msgstr ""
"Exception uppstod när man försökte använda :const:`UNNAMED_SECTION` utan att "
"aktivera den."

msgid ""
"Exception raised when an attempted :meth:`ConfigParser.write` would not be "
"parsed accurately with a future :meth:`ConfigParser.read` call."
msgstr ""
"Exception uppstod när ett försök till :meth:`ConfigParser.write` inte skulle "
"tolkas korrekt med ett framtida :meth:`ConfigParser.read`-anrop."

msgid ""
"Ex: Writing a key beginning with the :attr:`ConfigParser.SECTCRE` pattern "
"would parse as a section header when read. Attempting to write this will "
"raise this exception."
msgstr ""
"Ex: Att skriva en nyckel som börjar med mönstret :attr:`ConfigParser."
"SECTCRE` skulle tolkas som en sektionsrubrik när den läses. Försök att "
"skriva detta kommer att ge upphov till detta undantag."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"Config-parsers tillåter omfattande anpassningar.  Om du är intresserad av "
"att ändra det beteende som beskrivs i fotnotens referens, se avsnittet "
"\"Anpassa parserbeteendet\"."

msgid ".ini"
msgstr ".ini"

msgid "file"
msgstr "fil"

msgid "configuration"
msgstr "konfiguration"

msgid "ini file"
msgstr "ini-fil"

msgid "Windows ini file"
msgstr "Windows ini-fil"

msgid "% (percent)"
msgstr "% (procent)"

msgid "interpolation in configuration files"
msgstr "interpolation i konfigurationsfiler"

msgid "$ (dollar)"
msgstr "$ (dollar)"
