# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Transports and Protocols"
msgstr "Transporter och protokoll"

msgid "Preface"
msgstr "Förord"

msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Transporter och protokoll används av API:er för händelseslingor på **låg "
"nivå**, t.ex. :meth:`loop.create_connection`.  De använder en callback-"
"baserad programmeringsstil och möjliggör högpresterande implementeringar av "
"nätverks- eller IPC-protokoll (t.ex. HTTP)."

msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"I grund och botten bör transporter och protokoll endast användas i bibliotek "
"och ramverk och aldrig i asyncio-applikationer på hög nivå."

msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr "Denna dokumentationssida omfattar både `Transports`_ och `Protocols`_."

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"På högsta nivå handlar transporten om *hur* bytes överförs, medan "
"protokollet avgör *vilka* bytes som ska överföras (och i viss mån när)."

msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Ett annat sätt att säga samma sak: en transport är en abstraktion för en "
"socket (eller liknande I/O-slutpunkt) medan ett protokoll är en abstraktion "
"för en applikation, ur transportens synvinkel."

msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"En annan syn är att transport- och protokollgränssnitten tillsammans "
"definierar ett abstrakt gränssnitt för användning av nätverks-I/O och "
"interprocess-I/O."

msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Det finns alltid ett 1:1-förhållande mellan transport- och protokollobjekt: "
"protokollet anropar transportmetoder för att skicka data, medan transporten "
"anropar protokollmetoder för att vidarebefordra data som har mottagits."

msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"De flesta anslutningsorienterade event loop-metoder (t.ex. :meth:`loop."
"create_connection`) accepterar vanligtvis ett *protocol_factory*-argument "
"som används för att skapa ett *Protocol*-objekt för en accepterad "
"anslutning, representerad av ett *Transport*-objekt. Sådana metoder "
"returnerar vanligtvis en tupel av ``(transport, protocol)``."

msgid "Contents"
msgstr "Innehåll"

msgid "This documentation page contains the following sections:"
msgstr "Denna dokumentationssida innehåller följande avsnitt:"

msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"Avsnittet `Transports`_ dokumenterar asyncio klasserna :class:"
"`BaseTransport`, :class:`ReadTransport`, :class:`WriteTransport`, :class:"
"`Transport`, :class:`DatagramTransport` och :class:`SubprocessTransport`."

msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"Avsnittet `Protocols`_ dokumenterar asyncio klasserna :class:"
"`BaseProtocol`, :class:`Protocol`, :class:`BufferedProtocol`, :class:"
"`DatagramProtocol` och :class:`SubprocessProtocol`."

msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"Avsnittet `Examples`_ visar hur man arbetar med transporter, protokoll och "
"API:er för händelseslingor på låg nivå."

msgid "Transports"
msgstr "Transporter"

msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/transports.py`"

msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Transporter är klasser som tillhandahålls av :mod:`asyncio` för att "
"abstrahera olika typer av kommunikationskanaler."

msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Transportobjekt instansieras alltid av en :ref:`asyncio event loop <asyncio-"
"event-loop>`."

msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio implementerar transporter för TCP, UDP, SSL och subprocessrör. Vilka "
"metoder som är tillgängliga för en transport beror på transportens typ."

msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr "Transportklasserna är :ref:`not thread safe <asyncio-multithreading>`."

msgid "Transports Hierarchy"
msgstr "Transporter Hierarki"

msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Basklass för alla transporter.  Innehåller metoder som alla "
"asynciotransporter delar."

msgid "A base transport for write-only connections."
msgstr "En bastransport för skrivskyddade anslutningar."

msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Instanser av klassen *WriteTransport* returneras från händelseslingans "
"metod :meth:`loop.connect_write_pipe` och används även av "
"subprocessrelaterade metoder som :meth:`loop.subprocess_exec`."

msgid "A base transport for read-only connections."
msgstr "En bastransport för skrivskyddade anslutningar."

msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Instanser av klassen *ReadTransport* returneras från händelseslingans metod :"
"meth:`loop.connect_read_pipe` och används även av subprocessrelaterade "
"metoder som :meth:`loop.subprocess_exec`."

msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Gränssnitt som representerar en dubbelriktad transport, t.ex. en TCP-"
"anslutning."

msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"Användaren instansierar inte en transport direkt, utan anropar en utility-"
"funktion som får en protokollfabrik och annan information som krävs för att "
"skapa transport och protokoll."

msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Instanser av klassen *Transport* returneras från eller används av metoder i "
"händelseslingor som :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."

msgid "A transport for datagram (UDP) connections."
msgstr "En transport för datagram (UDP)-anslutningar."

msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Instanser av klassen *DatagramTransport* returneras från metoden :meth:`loop."
"create_datagram_endpoint` i händelseslingan."

msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"En abstraktion för att representera en koppling mellan en överordnad och en "
"underordnad OS-process."

msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Instanser av klassen *SubprocessTransport* returneras från eventloop-"
"metoderna :meth:`loop.subprocess_shell` och :meth:`loop.subprocess_exec`."

msgid "Base Transport"
msgstr "Bas transport"

msgid "Close the transport."
msgstr "Stäng transporten."

msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""
"Om transporten har en buffert för utgående data kommer buffrade data att "
"tömmas asynkront.  Inga fler data kommer att tas emot.  När alla buffrade "
"data har spolats kommer protokollets metod :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` att anropas med :const:`None` som argument. "
"Transporten bör inte användas när den är stängd."

msgid "Return ``True`` if the transport is closing or is closed."
msgstr ""
"Returnerar ``True`` om transporten håller på att stängas eller är stängd."

msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Returnera information om transporten eller underliggande resurser som den "
"använder."

msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*name* är en sträng som representerar den transportspecifika information som "
"ska hämtas."

msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* är det värde som ska returneras om informationen inte är "
"tillgänglig, eller om transporten inte stöder att den efterfrågas med den "
"givna implementeringen av händelseslingan från tredje part eller på den "
"aktuella plattformen."

msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Följande kod försöker till exempel hämta det underliggande socket-objektet "
"för transporten::"

msgid ""
"sock = transport.get_extra_info('socket')\n"
"if sock is not None:\n"
"    print(sock.getsockopt(...))"
msgstr ""
"sock = transport.get_extra_info('socket')\n"
"om sock inte är None:\n"
"    print(sock.getsockopt(...))"

msgid "Categories of information that can be queried on some transports:"
msgstr "Kategorier av information som kan efterfrågas på vissa transporter:"

msgid "socket:"
msgstr "socket:"

msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: den fjärradress som uttaget är anslutet till, resultat av :"
"meth:`socket.socket.getpeername` (``None`` vid fel)"

msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: :class:`socket.socket` instans"

msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: socketens egen adress, resultat av :meth:`socket.socket."
"getsockname`"

msgid "SSL socket:"
msgstr "SSL-uttag:"

msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``: den komprimeringsalgoritm som används som en sträng, "
"eller ``None`` om anslutningen inte komprimeras; resultat av :meth:`ssl."
"SSLSocket.compression`"

msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: en tupel med tre värden som innehåller namnet på det chiffer "
"som används, den version av SSL-protokollet som definierar dess användning "
"och antalet hemliga bitar som används; resultat av :meth:`ssl.SSLSocket."
"cipher`"

msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: peer-certifikat; resultat av :meth:`ssl.SSLSocket."
"getpeercert`"

msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: :class:`ssl.SSLContext` instans"

msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: :class:`ssl.SSLObject` eller :class:`ssl.SSLSocket` instans"

msgid "pipe:"
msgstr "rör:"

msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: rörobjekt"

msgid "subprocess:"
msgstr "underprocess:"

msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: :class:`subprocess.Popen` instans"

msgid "Set a new protocol."
msgstr "Ställ in ett nytt protokoll."

msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"Byte av protokoll bör endast göras när båda protokollen är dokumenterade för "
"att stödja bytet."

msgid "Return the current protocol."
msgstr "Returnerar det aktuella protokollet."

msgid "Read-only Transports"
msgstr "Skrivskyddade transporter"

msgid "Return ``True`` if the transport is receiving new data."
msgstr "Returnerar ``True`` om transporten tar emot nya data."

msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Pausa den mottagande änden av transporten.  Inga data kommer att skickas "
"till protokollets :meth:`protocol.data_received() <Protocol.data_received>`-"
"metod förrän :meth:`resume_reading` anropas."

msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"Metoden är idempotent, d.v.s. den kan anropas när transporten redan är "
"pausad eller stängd."

msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Återuppta den mottagande änden.  Protokollets :meth:`protocol."
"data_received() <Protocol.data_received>`-metod kommer att anropas igen om "
"några data är tillgängliga för läsning."

msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"Metoden är idempotent, d.v.s. den kan anropas när transporten redan läser."

msgid "Write-only Transports"
msgstr "Skrivskyddade transporter"

msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Stäng transporten omedelbart, utan att vänta på att väntande operationer ska "
"slutföras.  Buffrade data kommer att gå förlorade.  Inga fler data kommer "
"att tas emot. Protokollets metod :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` kommer så småningom att anropas med :const:"
"`None` som argument."

msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Returnerar :const:`True` om transporten stöder :meth:`~WriteTransport."
"write_eof`, :const:`False` om inte."

msgid "Return the current size of the output buffer used by the transport."
msgstr ""
"Returnerar den aktuella storleken på den utmatningsbuffert som används av "
"transporten."

msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Hämta vattenmärkena *hög* och *låg* för skrivflödeskontroll. Returnerar en "
"tupel ``(låg, hög)`` där *låg* och *hög* är positiva antal byte."

msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "Använd :meth:`set_write_buffer_limits` för att ställa in gränserna."

msgid "Set the *high* and *low* watermarks for write flow control."
msgstr "Ställ in vattenmärkena *hög* och *låg* för skrivflödeskontroll."

msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Dessa två värden (mätt i antal byte) styr när protokollets metoder :meth:"
"`protocol.pause_writing() <BaseProtocol.pause_writing>` och :meth:`protocol."
"resume_writing() <BaseProtocol.resume_writing>` anropas. Om det anges måste "
"det låga vattenmärket vara mindre än eller lika med det höga vattenmärket.  "
"Varken *high* eller *low* kan vara negativa."

msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` anropas när buffertstorleken blir större "
"än eller lika med värdet *high*. Om skrivningen har pausats anropas :meth:"
"`~BaseProtocol.resume_writing` när buffertstorleken blir mindre än eller "
"lika med värdet *low*."

msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Standardvärdena är implementationsspecifika.  Om endast det höga "
"vattenmärket anges, är det låga vattenmärket ett implementationsspecifikt "
"standardvärde som är mindre än eller lika med det höga vattenmärket.  Om "
"*high* sätts till noll sätts även *low* till noll, vilket gör att :meth:"
"`~BaseProtocol.pause_writing` anropas när bufferten inte längre är tom.  Om "
"*low* sätts till noll kommer :meth:`~BaseProtocol.resume_writing` att "
"anropas först när bufferten är tom. Att använda noll för någon av gränserna "
"är i allmänhet suboptimalt eftersom det minskar möjligheterna att göra I/O "
"och beräkningar samtidigt."

msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Använd :meth:`~WriteTransport.get_write_buffer_limits` för att få fram "
"gränserna."

msgid "Write some *data* bytes to the transport."
msgstr "Skriv några *data*-bytes till transporten."

msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Den här metoden blockerar inte, utan buffrar data och ser till att den "
"skickas ut asynkront."

msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Skriv en lista (eller en iterabel) med databytes till transporten. Detta är "
"funktionellt likvärdigt med att anropa :meth:`write` på varje element som "
"iterabeln ger, men kan implementeras mer effektivt."

msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Stäng transportens skrivände efter att ha spolat ut alla buffrade data. Data "
"kan fortfarande tas emot."

msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Denna metod kan ge upphov till :exc:`NotImplementedError` om transporten (t."
"ex. SSL) inte stöder halvstängda anslutningar."

msgid "Datagram Transports"
msgstr "Datagramtransporter"

msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Skicka *data* byte till den fjärrpeer som anges av *addr* (en "
"transportberoende måladress).  Om *addr* är :const:`None` skickas data till "
"den måladress som anges när transporten skapas."

msgid ""
"This method can be called with an empty bytes object to send a zero-length "
"datagram. The buffer size calculation used for flow control is also updated "
"to account for the datagram header."
msgstr ""
"Denna metod kan anropas med ett tomt bytes-objekt för att skicka ett "
"datagram med noll längd. Beräkningen av buffertstorleken som används för "
"flödeskontroll uppdateras också för att ta hänsyn till datagramhuvudet."

msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Stäng transporten omedelbart, utan att vänta på att väntande operationer ska "
"slutföras.  Buffrade data kommer att gå förlorade. Inga fler data kommer att "
"tas emot.  Protokollets metod :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` kommer så småningom att anropas med :const:"
"`None` som argument."

msgid "Subprocess Transports"
msgstr "Underprocess transporter"

msgid "Return the subprocess process id as an integer."
msgstr "Returnerar subprocessens process-ID som ett heltal."

msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Returnera transporten för kommunikationsröret som motsvarar filbeskrivaren "
"för heltal *fd*:"

msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: läsbar strömmande transport av standardinmatningen (*stdin*), eller :"
"const:`None`` om underprocessen inte skapades med ``stdin=PIPE``"

msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: skrivbar strömmande transport av standardutdata (*stdout*), eller :"
"const:`None`` om subprocessen inte skapades med ``stdout=PIPE``"

msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: skrivbar strömmande transport av standardfelet (*stderr*), eller :"
"const:`None`` om underprocessen inte skapades med ``stderr=PIPE``"

msgid "other *fd*: :const:`None`"
msgstr "andra *fd*: :const:`None`"

msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Returnerar subprocessens returkod som ett heltal eller :const:`None` om den "
"inte har returnerats, vilket liknar attributet :attr:`subprocess.Popen."
"returncode`."

msgid "Kill the subprocess."
msgstr "Stäng av underprocessen."

msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"På POSIX-system skickar funktionen SIGKILL till subprocessen. I Windows är "
"den här metoden ett alias för :meth:`terminate`."

msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Se även :meth:`subprocess.Popen.kill`."

msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Skicka *signal*-numret till underprocessen, som i :meth:`subprocess.Popen."
"send_signal`."

msgid "Stop the subprocess."
msgstr "Stoppa underprocessen."

msgid ""
"On POSIX systems, this method sends :py:const:`~signal.SIGTERM` to the "
"subprocess. On Windows, the Windows API function :c:func:`!TerminateProcess` "
"is called to stop the subprocess."
msgstr ""
"På POSIX-system skickar den här metoden :py:const:`~signal.SIGTERM` till "
"subprocessen. På Windows anropas Windows API-funktionen :c:func:`!"
"TerminateProcess` för att stoppa subprocessen."

msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Se även :meth:`subprocess.Popen.terminate`."

msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Döda subprocessen genom att anropa metoden :meth:`kill`."

msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Om underprocessen inte har återvänt ännu, och stäng transporterna av rören "
"*stdin*, *stdout* och *stderr*."

msgid "Protocols"
msgstr "Protokoll"

msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/protocols.py`"

msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio tillhandahåller en uppsättning abstrakta basklasser som bör användas "
"för att implementera nätverksprotokoll.  Dessa klasser är avsedda att "
"användas tillsammans med :ref:``transports <asyncio-transport>``."

msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Underklasser av abstrakta basprotokollklasser kan implementera vissa eller "
"alla metoder.  Alla dessa metoder är callbacks: de anropas av transporter "
"vid vissa händelser, t.ex. när data tas emot. En basprotokollmetod bör "
"anropas av motsvarande transport."

msgid "Base Protocols"
msgstr "Basprotokoll"

msgid "Base protocol with methods that all protocols share."
msgstr "Basprotokoll med metoder som är gemensamma för alla protokoll."

msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"Basklassen för implementering av streamingprotokoll (TCP, Unix-sockets, etc)."

msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"En basklass för implementering av streamingprotokoll med manuell kontroll av "
"mottagningsbufferten."

msgid "The base class for implementing datagram (UDP) protocols."
msgstr "Basklassen för implementering av datagram (UDP)-protokoll."

msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"Basklass för implementering av protokoll som kommunicerar med underordnade "
"processer (enkelriktade pipes)."

msgid "Base Protocol"
msgstr "Basprotokoll"

msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr "Alla asyncioprotokoll kan implementera Base Protocol callbacks."

msgid "Connection Callbacks"
msgstr "Callbacks för anslutning"

msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Connection callbacks anropas på alla protokoll, exakt en gång per lyckad "
"anslutning.  Alla andra protokollåterkallelser kan bara anropas mellan dessa "
"två metoder."

msgid "Called when a connection is made."
msgstr "Anropas när en anslutning har gjorts."

msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"Argumentet *transport* är den transport som representerar anslutningen.  "
"Protokollet är ansvarigt för att lagra referensen till sin transport."

msgid "Called when the connection is lost or closed."
msgstr "Anropas när anslutningen bryts eller stängs."

msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"Argumentet är antingen ett undantagsobjekt eller :const:`None`. Det senare "
"innebär att en vanlig EOF tas emot, eller att anslutningen avbröts eller "
"stängdes av den här sidan av anslutningen."

msgid "Flow Control Callbacks"
msgstr "Återkallelser för flödeskontroll"

msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Återanrop för flödeskontroll kan anropas av transporter för att pausa eller "
"återuppta skrivning som utförs av protokollet."

msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Se dokumentationen för metoden :meth:`~WriteTransport."
"set_write_buffer_limits` för mer information."

msgid "Called when the transport's buffer goes over the high watermark."
msgstr "Anropas när transportens buffert går över det högsta vattenmärket."

msgid "Called when the transport's buffer drains below the low watermark."
msgstr "Anropas när transportens buffert töms under lågvattenmärket."

msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Om buffertstorleken är lika med den höga vattenstämpeln anropas inte :meth:"
"`~BaseProtocol.pause_writing`: buffertstorleken måste gå strikt över."

msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"Omvänt anropas :meth:`~BaseProtocol.resume_writing` när buffertstorleken är "
"lika med eller lägre än det låga vattenmärket.  Dessa slutvillkor är viktiga "
"för att säkerställa att saker och ting går som förväntat när något av "
"märkena är noll."

msgid "Streaming Protocols"
msgstr "Protokoll för streaming"

msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Händelsemetoder som :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe` och :meth:`loop.connect_write_pipe` accepterar fabriker "
"som returnerar streamingprotokoll."

msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Anropas när data har tagits emot.  *data* är ett icke-tomt bytes-objekt som "
"innehåller inkommande data."

msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Om data buffras, delas upp i bitar eller sammanställs på nytt beror på "
"transporten.  I allmänhet bör du inte förlita dig på specifik semantik utan "
"i stället göra din parsning generisk och flexibel. Data tas dock alltid emot "
"i rätt ordning."

msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"Metoden kan anropas ett godtyckligt antal gånger medan en anslutning är "
"öppen."

msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"Men :meth:`protocol.eof_received() <Protocol.eof_received>` anropas högst en "
"gång.  När ``eof_received()`` har anropats anropas inte ``data_received()`` "
"längre."

msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Anropas när den andra änden signalerar att den inte kommer att skicka mer "
"data (t.ex. genom att anropa :meth:`transport.write_eof() <WriteTransport."
"write_eof>`, om den andra änden också använder asyncio)."

msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Denna metod kan returnera ett falskt värde (inklusive ``None``), i vilket "
"fall transporten kommer att stänga sig själv.  Omvänt, om denna metod "
"returnerar ett sant värde, avgör det protokoll som används om transporten "
"ska stängas. Eftersom standardimplementeringen returnerar ``None``, stänger "
"den implicit anslutningen."

msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Vissa transporter, inklusive SSL, stöder inte halvstängda anslutningar, i "
"vilket fall returnering av true från denna metod kommer att resultera i att "
"anslutningen stängs."

msgid "State machine:"
msgstr "Statlig maskin:"

msgid ""
"start -> connection_made\n"
"    [-> data_received]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> anslutning_gjord\n"
"    [-> data_mottagen]*\n"
"    [-> eof_received]?\n"
"-> anslutning_förlorad -> slut"

msgid "Buffered Streaming Protocols"
msgstr "Protokoll för buffrad strömning"

msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Buffrade protokoll kan användas med alla metoder för händelseslingor som "
"stöder `Streaming Protocols`_."

msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"implementeringar av ``BufferedProtocol`` tillåter explicit manuell "
"tilldelning och kontroll av mottagningsbufferten.  Händelseslingor kan då "
"använda den buffert som tillhandahålls av protokollet för att undvika "
"onödiga datakopior.  Detta kan resultera i märkbara prestandaförbättringar "
"för protokoll som tar emot stora mängder data.  Sofistikerade "
"protokollimplementeringar kan avsevärt minska antalet buffertallokeringar."

msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr "Följande callbacks anropas på :class:`BufferedProtocol`-instanser:"

msgid "Called to allocate a new receive buffer."
msgstr "Anropas för att allokera en ny mottagningsbuffert."

msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* är den rekommenderade minimistorleken för den returnerade "
"bufferten.  Det är acceptabelt att returnera mindre eller större buffertar "
"än vad *sizehint* föreslår.  När den är satt till -1 kan buffertstorleken "
"vara godtycklig. Det är ett fel att returnera en buffert med noll i storlek."

msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` måste returnera ett objekt som implementerar :ref:`buffer "
"protocol <bufferobjects>`."

msgid "Called when the buffer was updated with the received data."
msgstr "Anropas när bufferten har uppdaterats med de mottagna uppgifterna."

msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* är det totala antalet bytes som skrevs till bufferten."

msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Se dokumentationen för metoden :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` kan anropas ett godtyckligt antal "
"gånger under en anslutning.  Men :meth:`protocol.eof_received() <Protocol."
"eof_received>` anropas högst en gång och om den anropas kommer :meth:"
"`~BufferedProtocol.get_buffer` och :meth:`~BufferedProtocol.buffer_updated` "
"inte att anropas efter den."

msgid ""
"start -> connection_made\n"
"    [-> get_buffer\n"
"        [-> buffer_updated]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> connection_lost -> end"
msgstr ""
"start -> anslutning_gjord\n"
"    [-> hämta_buffer\n"
"        [-> buffert_uppdaterad]?\n"
"    ]*\n"
"    [-> eof_received]?\n"
"-> anslutning_förlorad -> slut"

msgid "Datagram Protocols"
msgstr "Datagram-protokoll"

msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Datagram-protokollinstanser bör konstrueras av protokollfabriker som skickas "
"till metoden :meth:`loop.create_datagram_endpoint`."

msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Anropas när ett datagram tas emot.  *data* är ett bytes-objekt som "
"innehåller inkommande data.  *addr* är adressen till den peer som skickar "
"data; det exakta formatet beror på transportmedlet."

msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Anropas när en tidigare sändnings- eller mottagningsoperation ger upphov "
"till ett :class:`OSError`.  *exc* är en instans av :class:`OSError`."

msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Denna metod anropas i sällsynta fall när transporten (t.ex. UDP) upptäcker "
"att ett datagram inte kunde levereras till mottagaren. Under många "
"förhållanden kommer dock datagram som inte kan levereras att släppas i "
"tysthet."

msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"På BSD-system (macOS, FreeBSD etc.) stöds inte flödeskontroll för "
"datagramprotokoll, eftersom det inte finns något tillförlitligt sätt att "
"upptäcka sändningsfel som orsakas av att för många paket skrivs."

msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"Uttaget verkar alltid \"klart\" och överflödiga paket släpps. Ett :class:"
"`OSError` med ``errno`` satt till :const:`errno.ENOBUFS` kan eller inte kan "
"uppstå; om det uppstår kommer det att rapporteras till :meth:"
"`DatagramProtocol.error_received` men annars ignoreras."

msgid "Subprocess Protocols"
msgstr "Protokoll för delprocesser"

msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Subprocessprotokollinstanser bör konstrueras av protokollfabriker som "
"skickas till metoderna :meth:`loop.subprocess_exec` och :meth:`loop."
"subprocess_shell`."

msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Anropas när barnprocessen skriver data till sin stdout- eller stderr-"
"pipeline."

msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* är pipens filbeskrivare i heltal."

msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* är ett icke-tomt bytesobjekt som innehåller de mottagna data."

msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr "Anropas när ett av de rör som kommunicerar med barnprocessen stängs."

msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* är den heltalsfilsbeskrivare som stängdes."

msgid "Called when the child process has exited."
msgstr "Anropas när den underordnade processen har avslutats."

msgid ""
"It can be called before :meth:`~SubprocessProtocol.pipe_data_received` and :"
"meth:`~SubprocessProtocol.pipe_connection_lost` methods."
msgstr ""
"Den kan anropas före metoderna :meth:`~SubprocessProtocol."
"pipe_data_received` och :meth:`~SubprocessProtocol.pipe_connection_lost`."

msgid "Examples"
msgstr "Exempel"

msgid "TCP Echo Server"
msgstr "TCP Echo-server"

msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Skapa en TCP-ekoserver med hjälp av metoden :meth:`loop.create_server`, "
"skicka tillbaka mottagna data och stäng anslutningen::"

msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    server = await loop.create_server(\n"
"        EchoServerProtocol,\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    server = await loop.create_server(\n"
"        EchoServerProtocol,\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"\n"
"asyncio.run(main())"

msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"I exemplet :ref:`TCP echo server using streams <asyncio-tcp-echo-server-"
"streams>` används funktionen :func:`asyncio.start_server` på hög nivå."

msgid "TCP Echo Client"
msgstr "TCP Echo-klient"

msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"En TCP-ekoklient som använder metoden :meth:`loop.create_connection`, "
"skickar data och väntar tills anslutningen stängs::"

msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = 'Hello World!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # Wait until the protocol signals that the connection\n"
"    # is lost and close the transport.\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = 'Hello World!'\n"
"\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    # Wait until the protocol signals that the connection\n"
"    # is lost and close the transport.\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"I exemplet :ref:`TCP echo client using streams <asyncio-tcp-echo-client-"
"streams>` används högnivåfunktionen :func:`asyncio.open_connection`."

msgid "UDP Echo Server"
msgstr "UDP Echo-server"

msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"En UDP-ekoserver, som använder metoden :meth:`loop."
"create_datagram_endpoint`, skickar tillbaka mottagna data::"

msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"\n"
"async def main():\n"
"    print(\"Starting UDP server\")\n"
"\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # One protocol instance will be created to serve all\n"
"    # client requests.\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        EchoServerProtocol,\n"
"        local_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await asyncio.sleep(3600)  # Serve for 1 hour.\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"\n"
"async def main():\n"
"    print(\"Starting UDP server\")\n"
"\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # One protocol instance will be created to serve all\n"
"    # client requests.\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        EchoServerProtocol,\n"
"        local_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await asyncio.sleep(3600)  # Serve for 1 hour.\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

msgid "UDP Echo Client"
msgstr "UDP Echo-klient"

msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"En UDP-eko-klient, som använder metoden :meth:`loop."
"create_datagram_endpoint`, skickar data och stänger transporten när den får "
"svaret::"

msgid ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, on_con_lost):\n"
"        self.message = message\n"
"        self.on_con_lost = on_con_lost\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Connection closed\")\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    on_con_lost = loop.create_future()\n"
"    message = \"Hello World!\"\n"
"\n"
"    transport, protocol = await loop.create_datagram_endpoint(\n"
"        lambda: EchoClientProtocol(message, on_con_lost),\n"
"        remote_addr=('127.0.0.1', 9999))\n"
"\n"
"    try:\n"
"        await on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"\n"
"\n"
"asyncio.run(main())"

msgid "Connecting Existing Sockets"
msgstr "Anslutning av befintliga uttag"

msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Vänta tills ett uttag tar emot data med hjälp av metoden :meth:`loop."
"create_connection` med protokollet::"

msgid ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # We are done: close the transport;\n"
"        # connection_lost() will be called automatically.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # Create a pair of connected sockets\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the socket to wait for data.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import socket\n"
"\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"\n"
"    def __init__(self, on_con_lost):\n"
"        self.transport = None\n"
"        self.on_con_lost = on_con_lost\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # We are done: close the transport;\n"
"        # connection_lost() will be called automatically.\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed\n"
"        self.on_con_lost.set_result(True)\n"
"\n"
"\n"
"async def main():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"    on_con_lost = loop.create_future()\n"
"\n"
"    # Create a pair of connected sockets\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the socket to wait for data.\n"
"    transport, protocol = await loop.create_connection(\n"
"        lambda: MyProtocol(on_con_lost), sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network.\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    try:\n"
"        await protocol.on_con_lost\n"
"    finally:\n"
"        transport.close()\n"
"        wsock.close()\n"
"\n"
"asyncio.run(main())"

msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"I exemplet :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` används lågnivåmetoden :meth:`loop.add_reader` "
"för att registrera en FD."

msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"I exemplet :ref:`registrera ett öppet uttag för att vänta på data med hjälp "
"av strömmar <asyncio_example_create_connection-streams>` används strömmar på "
"hög nivå som skapas av funktionen :func:`open_connection` i en coroutine."

msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() och SubprocessProtocol"

msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Ett exempel på ett subprocessprotokoll som används för att få utdata från en "
"subprocess och för att vänta på att subprocessen ska avslutas."

msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "Subprocessen skapas med metoden :meth:`loop.subprocess_exec`::"

msgid ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # process_exited() method can be called before\n"
"        # pipe_connection_lost() method: wait until both methods are\n"
"        # called.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # Create the subprocess controlled by DateProtocol;\n"
"    # redirect the standard output into a pipe.\n"
"    transport, protocol = await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # Wait for the subprocess exit using the process_exited()\n"
"    # method of the protocol.\n"
"    await exit_future\n"
"\n"
"    # Close the stdout pipe.\n"
"    transport.close()\n"
"\n"
"    # Read the output which was collected by the\n"
"    # pipe_data_received() method of the protocol.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"
msgstr ""
"import asyncio\n"
"import sys\n"
"\n"
"class DateProtocol(asyncio.SubprocessProtocol):\n"
"    def __init__(self, exit_future):\n"
"        self.exit_future = exit_future\n"
"        self.output = bytearray()\n"
"        self.pipe_closed = False\n"
"        self.exited = False\n"
"\n"
"    def pipe_connection_lost(self, fd, exc):\n"
"        self.pipe_closed = True\n"
"        self.check_for_exit()\n"
"\n"
"    def pipe_data_received(self, fd, data):\n"
"        self.output.extend(data)\n"
"\n"
"    def process_exited(self):\n"
"        self.exited = True\n"
"        # process_exited() method can be called before\n"
"        # pipe_connection_lost() method: wait until both methods are\n"
"        # called.\n"
"        self.check_for_exit()\n"
"\n"
"    def check_for_exit(self):\n"
"        if self.pipe_closed and self.exited:\n"
"            self.exit_future.set_result(True)\n"
"\n"
"async def get_date():\n"
"    # Get a reference to the event loop as we plan to use\n"
"    # low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    code = 'import datetime; print(datetime.datetime.now())'\n"
"    exit_future = asyncio.Future(loop=loop)\n"
"\n"
"    # Create the subprocess controlled by DateProtocol;\n"
"    # redirect the standard output into a pipe.\n"
"    transport, protocol = await loop.subprocess_exec(\n"
"        lambda: DateProtocol(exit_future),\n"
"        sys.executable, '-c', code,\n"
"        stdin=None, stderr=None)\n"
"\n"
"    # Wait for the subprocess exit using the process_exited()\n"
"    # method of the protocol.\n"
"    await exit_future\n"
"\n"
"    # Close the stdout pipe.\n"
"    transport.close()\n"
"\n"
"    # Read the output which was collected by the\n"
"    # pipe_data_received() method of the protocol.\n"
"    data = bytes(protocol.output)\n"
"    return data.decode('ascii').rstrip()\n"
"\n"
"date = asyncio.run(get_date())\n"
"print(f\"Current date: {date}\")"

msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Se även :ref:`samme exempel <asyncio_example_create_subprocess_exec>` "
"skrivet med hjälp av API:er på hög nivå."
