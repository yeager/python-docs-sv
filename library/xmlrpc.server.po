# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!xmlrpc.server` --- Basic XML-RPC servers"
msgstr ":mod:`!xmlrpc.server` --- Grundläggande XML-RPC-servrar"

msgid "**Source code:** :source:`Lib/xmlrpc/server.py`"
msgstr "**Källkod:** :source:`Lib/xmlrpc/server.py`"

msgid ""
"The :mod:`xmlrpc.server` module provides a basic server framework for XML-"
"RPC servers written in Python.  Servers can either be free standing, using :"
"class:`SimpleXMLRPCServer`, or embedded in a CGI environment, using :class:"
"`CGIXMLRPCRequestHandler`."
msgstr ""
"Modulen :mod:`xmlrpc.server` tillhandahåller ett grundläggande serverramverk "
"för XML-RPC-servrar skrivna i Python.  Servrar kan antingen vara fristående, "
"med :class:`SimpleXMLRPCServer`, eller inbäddade i en CGI-miljö, med :class:"
"`CGIXMLRPCRequestHandler`."

msgid ""
"The :mod:`xmlrpc.server` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data, "
"see :ref:`xml-security`."
msgstr ""
"Modulen :mod:`xmlrpc.server` är inte säker mot skadligt konstruerade data.  "
"Om du behöver analysera icke betrodda eller oautentiserade data, se :ref:"
"`xml-security`."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid ""
"Create a new server instance.  This class provides methods for registration "
"of functions that can be called by the XML-RPC protocol.  The "
"*requestHandler* parameter should be a factory for request handler "
"instances; it defaults to :class:`SimpleXMLRPCRequestHandler`.  The *addr* "
"and *requestHandler* parameters are passed to the :class:`socketserver."
"TCPServer` constructor.  If *logRequests* is true (the default), requests "
"will be logged; setting this parameter to false will turn off logging.   The "
"*allow_none* and *encoding* parameters are passed on to :mod:`xmlrpc.client` "
"and control the XML-RPC responses that will be returned from the server. The "
"*bind_and_activate* parameter controls whether :meth:`server_bind` and :meth:"
"`server_activate` are called immediately by the constructor; it defaults to "
"true. Setting it to false allows code to manipulate the "
"*allow_reuse_address* class variable before the address is bound. The "
"*use_builtin_types* parameter is passed to the :func:`~xmlrpc.client.loads` "
"function and controls which types are processed when date/times values or "
"binary data are received; it defaults to false."
msgstr ""
"Skapa en ny serverinstans.  Denna klass tillhandahåller metoder för "
"registrering av funktioner som kan anropas av XML-RPC-protokollet.  "
"Parametern *requestHandler* bör vara en fabrik för requesthandler-instanser; "
"standardvärdet är :class:`SimpleXMLRPCRequestHandler`.  Parametrarna *addr* "
"och *requestHandler* skickas till konstruktören för :class:`socketserver."
"TCPServer`.  Om *logRequests* är true (standard) kommer förfrågningar att "
"loggas; om parametern är false stängs loggning av.   Parametrarna "
"*allow_none* och *encoding* skickas vidare till :mod:`xmlrpc.client` och "
"styr de XML-RPC-svar som kommer att returneras från servern. Parametern "
"*bind_and_activate* styr om :meth:`server_bind` och :meth:`server_activate` "
"anropas omedelbart av konstruktören; standardvärdet är true. Om den sätts "
"till false kan koden manipulera klassvariabeln *allow_reuse_address* innan "
"adressen är bunden. Parametern *use_builtin_types* skickas till funktionen :"
"func:`~xmlrpc.client.loads` och styr vilka typer som bearbetas när datum-/"
"tidsvärden eller binära data tas emot; standardvärdet är false."

msgid "The *use_builtin_types* flag was added."
msgstr "Flaggan *use_builtin_types* har lagts till."

msgid ""
"Create a new instance to handle XML-RPC requests in a CGI environment.  The "
"*allow_none* and *encoding* parameters are passed on to :mod:`xmlrpc.client` "
"and control the XML-RPC responses that will be returned from the server. The "
"*use_builtin_types* parameter is passed to the :func:`~xmlrpc.client.loads` "
"function and controls which types are processed when date/times values or "
"binary data are received; it defaults to false."
msgstr ""
"Skapa en ny instans för att hantera XML-RPC-förfrågningar i en CGI-miljö.  "
"Parametrarna *allow_none* och *encoding* skickas vidare till :mod:`xmlrpc."
"client` och styr de XML-RPC-svar som returneras från servern. Parametern "
"*use_builtin_types* skickas till funktionen :func:`~xmlrpc.client.loads` och "
"styr vilka typer som behandlas när datum-/tidsvärden eller binära data tas "
"emot; standardvärdet är false."

msgid ""
"Create a new request handler instance.  This request handler supports "
"``POST`` requests and modifies logging so that the *logRequests* parameter "
"to the :class:`SimpleXMLRPCServer` constructor parameter is honored."
msgstr ""
"Skapa en ny instans av request handler.  Denna request handler stöder "
"``POST`` requests och modifierar loggningen så att parametern *logRequests* "
"till :class:`SimpleXMLRPCServer` constructor parameter respekteras."

msgid "SimpleXMLRPCServer Objects"
msgstr "SimpleXMLRPCServer-objekt"

msgid ""
"The :class:`SimpleXMLRPCServer` class is based on :class:`socketserver."
"TCPServer` and provides a means of creating simple, stand alone XML-RPC "
"servers."
msgstr ""
"Klassen :class:`SimpleXMLRPCServer` är baserad på :class:`socketserver."
"TCPServer` och gör det möjligt att skapa enkla, fristående XML-RPC-servrar."

msgid ""
"Register a function that can respond to XML-RPC requests.  If *name* is "
"given, it will be the method name associated with *function*, otherwise :"
"attr:`function.__name__` will be used.  *name* is a string, and may contain "
"characters not legal in Python identifiers, including the period character."
msgstr ""
"Registrerar en funktion som kan svara på XML-RPC-förfrågningar.  Om *name* "
"anges kommer det att vara det metodnamn som associeras med *function*, "
"annars kommer :attr:`function.__name__` att användas.  *name* är en sträng "
"och kan innehålla tecken som inte är tillåtna i Python-identifierare, "
"inklusive periodtecknet."

msgid ""
"This method can also be used as a decorator.  When used as a decorator, "
"*name* can only be given as a keyword argument to register *function* under "
"*name*.  If no *name* is given, :attr:`function.__name__` will be used."
msgstr ""
"Denna metod kan också användas som en dekorator.  När den används som en "
"dekorator kan *name* endast anges som ett nyckelordsargument för att "
"registrera *function* under *name*.  Om inget *namn* anges kommer :attr:"
"`function.__name__` att användas."

msgid ":meth:`register_function` can be used as a decorator."
msgstr ":meth:`register_function` kan användas som dekorator."

msgid ""
"Register an object which is used to expose method names which have not been "
"registered using :meth:`register_function`.  If *instance* contains a :meth:"
"`_dispatch` method, it is called with the requested method name and the "
"parameters from the request.  Its API is ``def _dispatch(self, method, "
"params)`` (note that *params* does not represent a variable argument list).  "
"If it calls an underlying function to perform its task, that function is "
"called as ``func(*params)``, expanding the parameter list. The return value "
"from :meth:`_dispatch` is returned to the client as the result.  If "
"*instance* does not have a :meth:`_dispatch` method, it is searched for an "
"attribute matching the name of the requested method."
msgstr ""
"Registrera ett objekt som används för att exponera metodnamn som inte har "
"registrerats med hjälp av :meth:`register_function`.  Om *instance* "
"innehåller en :meth:`_dispatch`-metod, anropas den med det begärda "
"metodnamnet och parametrarna från begäran.  Dess API är ``def "
"_dispatch(self, method, params)`` (observera att *params* inte representerar "
"en variabel argumentlista).  Om den anropar en underliggande funktion för "
"att utföra sin uppgift, kallas den funktionen som ``func(*params)`` och "
"utökar parameterlistan. Returvärdet från :meth:`_dispatch` returneras till "
"klienten som resultat.  Om *instance* inte har någon :meth:`_dispatch`-"
"metod, söks den efter ett attribut som matchar namnet på den begärda metoden."

msgid ""
"If the optional *allow_dotted_names* argument is true and the instance does "
"not have a :meth:`_dispatch` method, then if the requested method name "
"contains periods, each component of the method name is searched for "
"individually, with the effect that a simple hierarchical search is "
"performed.  The value found from this search is then called with the "
"parameters from the request, and the return value is passed back to the "
"client."
msgstr ""
"Om det valfria argumentet *allow_dotted_names* är true och instansen inte "
"har någon :meth:`_dispatch`-metod, och det begärda metodnamnet innehåller "
"punkter, söks varje komponent i metodnamnet individuellt, vilket innebär att "
"en enkel hierarkisk sökning utförs.  Det värde som hittas vid denna sökning "
"anropas sedan med parametrarna från begäran och returvärdet skickas tillbaka "
"till klienten."

msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this option on a secure, closed network."
msgstr ""
"Om du aktiverar alternativet *allow_dotted_names* får inkräktare tillgång "
"till modulens globala variabler och kan köra godtycklig kod på din dator.  "
"Använd endast det här alternativet i ett säkert, slutet nätverk."

msgid ""
"Registers the XML-RPC introspection functions ``system.listMethods``, "
"``system.methodHelp`` and ``system.methodSignature``."
msgstr ""
"Registrerar XML-RPC introspektionsfunktionerna ``system.listMethods``, "
"``system.methodHelp`` och ``system.methodSignature``."

msgid "Registers the XML-RPC multicall function system.multicall."
msgstr "Registrerar XML-RPC multicall-funktionen system.multicall."

msgid ""
"An attribute value that must be a tuple listing valid path portions of the "
"URL for receiving XML-RPC requests.  Requests posted to other paths will "
"result in a 404 \"no such page\" HTTP error.  If this tuple is empty, all "
"paths will be considered valid. The default value is ``('/', '/RPC2')``."
msgstr ""
"Ett attributvärde som måste vara en tupel som listar giltiga sökvägsdelar av "
"URL:en för mottagning av XML-RPC-förfrågningar.  Förfrågningar som skickas "
"till andra sökvägar kommer att resultera i ett HTTP-fel 404 \"no such "
"page\".  Om denna tupel är tom kommer alla sökvägar att betraktas som "
"giltiga. Standardvärdet är ``('/', '/RPC2')``."

msgid "SimpleXMLRPCServer Example"
msgstr "Exempel på SimpleXMLRPCServer"

msgid "Server code::"
msgstr "Serverkod::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restrict to a particular path.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Create server\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Register an instance; all the methods of the instance are\n"
"    # published as XML-RPC methods (in this case, just 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Run the server's main loop\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restrict to a particular path.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Create server\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Register an instance; all the methods of the instance are\n"
"    # published as XML-RPC methods (in this case, just 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Run the server's main loop\n"
"    server.serve_forever()"

msgid ""
"The following client code will call the methods made available by the "
"preceding server::"
msgstr ""
"Följande klientkod anropar de metoder som görs tillgängliga av den "
"föregående servern::"

msgid ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Returns 2**3 = 8\n"
"print(s.add(2,3))  # Returns 5\n"
"print(s.mul(5,2))  # Returns 5*2 = 10\n"
"\n"
"# Print list of available methods\n"
"print(s.system.listMethods())"
msgstr ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Returns 2**3 = 8\n"
"print(s.add(2,3))  # Returns 5\n"
"print(s.mul(5,2))  # Returns 5*2 = 10\n"
"\n"
"# Print list of available methods\n"
"print(s.system.listMethods())"

msgid ""
":meth:`register_function` can also be used as a decorator. The previous "
"server example can register functions in a decorator way::"
msgstr ""
":meth:`register_function` kan också användas som en dekorator. Det "
"föregående serverexemplet kan registrera funktioner på ett dekorativt sätt::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name, using\n"
"    # register_function as a decorator. *name* can only be given\n"
"    # as a keyword argument.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Register a function under function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name, using\n"
"    # register_function as a decorator. *name* can only be given\n"
"    # as a keyword argument.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Register a function under function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"

msgid ""
"The following example included in the :file:`Lib/xmlrpc/server.py` module "
"shows a server allowing dotted names and registering a multicall function."
msgstr ""
"Följande exempel som ingår i modulen :file:`Lib/xmlrpc/server.py` visar en "
"server som tillåter prickade namn och registrerar en multicall-funktion."

msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this example only within a secure, closed network."
msgstr ""
"Om du aktiverar alternativet *allow_dotted_names* får inkräktare tillgång "
"till modulens globala variabler och kan köra godtycklig kod på din dator.  "
"Använd detta exempel endast inom ett säkert, slutet nätverk."

msgid ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"
msgstr ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"

msgid "This ExampleService demo can be invoked from the command line::"
msgstr "Denna ExampleService-demo kan startas från kommandoraden::"

msgid "python -m xmlrpc.server"
msgstr "python -m xmlrpc.server"

msgid ""
"The client that interacts with the above server is included in ``Lib/xmlrpc/"
"client.py``::"
msgstr ""
"Klienten som interagerar med ovanstående server ingår i ``Lib/xmlrpc/client."
"py``::"

msgid ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"
msgstr ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"försök:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"försök:\n"
"    for svar i multi():\n"
"        print(svar)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"

msgid ""
"This client which interacts with the demo XMLRPC server can be invoked as::"
msgstr "Denna klient som interagerar med demo XMLRPC-servern kan anropas som::"

msgid "python -m xmlrpc.client"
msgstr "python -m xmlrpc.client"

msgid "CGIXMLRPCRequestHandler"
msgstr "CGIXMLRPCFörfrågningshanterare"

msgid ""
"The :class:`CGIXMLRPCRequestHandler` class can be used to handle XML-RPC "
"requests sent to Python CGI scripts."
msgstr ""
"Klassen :class:`CGIXMLRPCRequestHandler` kan användas för att hantera XML-"
"RPC-förfrågningar som skickas till Python CGI-skript."

msgid ""
"Register an object which is used to expose method names  which have not been "
"registered using :meth:`register_function`. If  instance contains a :meth:"
"`_dispatch` method, it is called with the  requested method name and the "
"parameters from the  request; the return value is returned to the client as "
"the result. If instance does not have a :meth:`_dispatch` method, it is "
"searched for an attribute matching the name of the requested method; if  the "
"requested method name contains periods, each  component of the method name "
"is searched for individually,  with the effect that a simple hierarchical "
"search is performed. The value found from this search is then called with "
"the  parameters from the request, and the return value is passed  back to "
"the client."
msgstr ""
"Registrera ett objekt som används för att exponera metodnamn som inte har "
"registrerats med hjälp av :meth:`register_function`. Om instance innehåller "
"en :meth:`_dispatch`-metod anropas den med det begärda metodnamnet och "
"parametrarna från begäran; returvärdet returneras till klienten som "
"resultat. Om instance inte har någon :meth:`_dispatch`-metod söks den efter "
"ett attribut som matchar namnet på den begärda metoden; om det begärda "
"metodnamnet innehåller perioder söks varje komponent i metodnamnet "
"individuellt, vilket innebär att en enkel hierarkisk sökning utförs. Det "
"värde som hittas vid denna sökning anropas sedan med parametrarna från "
"begäran, och returvärdet skickas tillbaka till klienten."

msgid ""
"Register the XML-RPC introspection functions  ``system.listMethods``, "
"``system.methodHelp`` and  ``system.methodSignature``."
msgstr ""
"Registrera XML-RPC introspektionsfunktionerna ``system.listMethods``, "
"``system.methodHelp`` och ``system.methodSignature``."

msgid "Register the XML-RPC multicall function ``system.multicall``."
msgstr "Registrera XML-RPC multicall-funktionen ``system.multicall``."

msgid ""
"Handle an XML-RPC request. If *request_text* is given, it should be the POST "
"data provided by the HTTP server,  otherwise the contents of stdin will be "
"used."
msgstr ""
"Hantera en XML-RPC-begäran. Om *request_text* anges bör det vara POST-data "
"som tillhandahålls av HTTP-servern, annars kommer innehållet i stdin att "
"användas."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"
msgstr ""
"klass MyFuncs:\n"
"    def mul(self, x, y):\n"
"        returnerar x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"

msgid "Documenting XMLRPC server"
msgstr "Dokumentation av XMLRPC-server"

msgid ""
"These classes extend the above classes to serve HTML documentation in "
"response to HTTP GET requests.  Servers can either be free standing, using :"
"class:`DocXMLRPCServer`, or embedded in a CGI environment, using :class:"
"`DocCGIXMLRPCRequestHandler`."
msgstr ""
"Dessa klasser utökar ovanstående klasser för att servera HTML-dokumentation "
"som svar på HTTP GET-begäranden.  Servrar kan antingen vara fristående, med :"
"class:`DocXMLRPCServer`, eller inbäddade i en CGI-miljö, med :class:"
"`DocCGIXMLRPCRequestHandler`."

msgid ""
"Create a new server instance. All parameters have the same meaning as for :"
"class:`SimpleXMLRPCServer`; *requestHandler* defaults to :class:"
"`DocXMLRPCRequestHandler`."
msgstr ""
"Skapa en ny serverinstans. Alla parametrar har samma betydelse som för :"
"class:`SimpleXMLRPCServer`; *requestHandler* är standard för :class:"
"`DocXMLRPCRequestHandler`."

msgid "Create a new instance to handle XML-RPC requests in a CGI environment."
msgstr "Skapa en ny instans för att hantera XML-RPC-begäranden i en CGI-miljö."

msgid ""
"Create a new request handler instance. This request handler supports XML-RPC "
"POST requests, documentation GET requests, and modifies logging so that the "
"*logRequests* parameter to the :class:`DocXMLRPCServer` constructor "
"parameter is honored."
msgstr ""
"Skapa en ny instans av request handler. Denna request handler stöder XML-RPC "
"POST requests, documentation GET requests och modifierar loggning så att "
"parametern *logRequests* till :class:`DocXMLRPCServer` constructor parameter "
"respekteras."

msgid "DocXMLRPCServer Objects"
msgstr "DocXMLRPCServer-objekt"

msgid ""
"The :class:`DocXMLRPCServer` class is derived from :class:"
"`SimpleXMLRPCServer` and provides a means of creating self-documenting, "
"stand alone XML-RPC servers. HTTP POST requests are handled as XML-RPC "
"method calls. HTTP GET requests are handled by generating pydoc-style HTML "
"documentation. This allows a server to provide its own web-based "
"documentation."
msgstr ""
"Klassen :class:`DocXMLRPCServer` är härledd från :class:`SimpleXMLRPCServer` "
"och gör det möjligt att skapa självdokumenterande, fristående XML-RPC-"
"servrar. HTTP POST-förfrågningar hanteras som XML-RPC-metodanrop. HTTP GET-"
"förfrågningar hanteras genom att generera HTML-dokumentation i pydoc-stil. "
"Detta gör att en server kan tillhandahålla sin egen webbaserade "
"dokumentation."

msgid ""
"Set the title used in the generated HTML documentation. This title will be "
"used inside the HTML \"title\" element."
msgstr ""
"Ange den titel som används i den genererade HTML-dokumentationen. Denna "
"titel kommer att användas inuti HTML-elementet \"title\"."

msgid ""
"Set the name used in the generated HTML documentation. This name will appear "
"at the top of the generated documentation inside a \"h1\" element."
msgstr ""
"Ange det namn som används i den genererade HTML-dokumentationen. Detta namn "
"kommer att visas högst upp i den genererade dokumentationen i ett \"h1\"-"
"element."

msgid ""
"Set the description used in the generated HTML documentation. This "
"description will appear as a paragraph, below the server name, in the "
"documentation."
msgstr ""
"Ange den beskrivning som används i den genererade HTML-dokumentationen. "
"Beskrivningen kommer att visas som ett stycke under servernamnet i "
"dokumentationen."

msgid "DocCGIXMLRPCRequestHandler"
msgstr "DocCGIXMLRPCRequestHandler"

msgid ""
"The :class:`DocCGIXMLRPCRequestHandler` class is derived from :class:"
"`CGIXMLRPCRequestHandler` and provides a means of creating self-documenting, "
"XML-RPC CGI scripts. HTTP POST requests are handled as XML-RPC method calls. "
"HTTP GET requests are handled by generating pydoc-style HTML documentation. "
"This allows a server to provide its own web-based documentation."
msgstr ""
"Klassen :class:`DocCGIXMLRPCRequestHandler` är härledd från :class:"
"`CGIXMLRPCRequestHandler` och gör det möjligt att skapa självdokumenterande "
"XML-RPC CGI-skript. HTTP POST-förfrågningar hanteras som XML-RPC-metodanrop. "
"HTTP GET-begäranden hanteras genom att generera HTML-dokumentation i pydoc-"
"stil. Detta gör att en server kan tillhandahålla sin egen webbaserade "
"dokumentation."
