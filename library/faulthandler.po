# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!faulthandler` --- Dump the Python traceback"
msgstr ":mod:`!faulthandler` --- Dumpa Python-spårningen"

msgid ""
"This module contains functions to dump Python tracebacks explicitly, on a "
"fault, after a timeout, or on a user signal. Call :func:`faulthandler."
"enable` to install fault handlers for the :const:`~signal.SIGSEGV`, :const:"
"`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:`~signal.SIGBUS`, and :"
"const:`~signal.SIGILL` signals. You can also enable them at startup by "
"setting the :envvar:`PYTHONFAULTHANDLER` environment variable or by using "
"the :option:`-X` ``faulthandler`` command line option."
msgstr ""
"Denna modul innehåller funktioner för att dumpa Python-spårningar explicit, "
"på ett fel, efter en timeout eller på en användarsignal. Anropa :func:"
"`faulthandler.enable` för att installera felhanterare för signalerna :const:"
"`~signal.SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:"
"`~signal.SIGBUS` och :const:`~signal.SIGILL`. Du kan också aktivera dem vid "
"start genom att ställa in miljövariabeln :envvar:`PYTHONFAULTHANDLER` eller "
"genom att använda kommandoradsalternativet :option:`-X` ``faulthandler``."

msgid ""
"The fault handler is compatible with system fault handlers like Apport or "
"the Windows fault handler. The module uses an alternative stack for signal "
"handlers if the :c:func:`!sigaltstack` function is available. This allows it "
"to dump the traceback even on a stack overflow."
msgstr ""
"Felhanteraren är kompatibel med systemfelhanterare som Apport eller Windows "
"felhanterare. Modulen använder en alternativ stack för signalhanterare om "
"funktionen :c:func:`!sigaltstack` är tillgänglig. Detta gör att den kan "
"dumpa traceback även vid stacköverflöd."

msgid ""
"The fault handler is called on catastrophic cases and therefore can only use "
"signal-safe functions (e.g. it cannot allocate memory on the heap). Because "
"of this limitation traceback dumping is minimal compared to normal Python "
"tracebacks:"
msgstr ""
"Felhanteraren anropas i katastroffall och kan därför bara använda "
"signalsäkra funktioner (den kan t.ex. inte allokera minne i heapen). På "
"grund av denna begränsning är spårningsdumpningen minimal jämfört med "
"normala Python-spårningar:"

msgid ""
"Only ASCII is supported. The ``backslashreplace`` error handler is used on "
"encoding."
msgstr ""
"Endast ASCII stöds. Felhanteraren ``backslashreplace`` används vid kodning."

msgid "Each string is limited to 500 characters."
msgstr "Varje sträng är begränsad till 500 tecken."

msgid ""
"Only the filename, the function name and the line number are displayed. (no "
"source code)"
msgstr "Endast filnamnet, funktionsnamnet och radnumret visas. (ingen källkod)"

msgid "It is limited to 100 frames and 100 threads."
msgstr "Den är begränsad till 100 ramar och 100 trådar."

msgid "The order is reversed: the most recent call is shown first."
msgstr "Ordningen är omvänd: det senaste anropet visas först."

msgid ""
"By default, the Python traceback is written to :data:`sys.stderr`. To see "
"tracebacks, applications must be run in the terminal. A log file can "
"alternatively be passed to :func:`faulthandler.enable`."
msgstr ""
"Som standard skrivs Python-spårningen till :data:`sys.stderr`. För att se "
"spårningar måste program köras i terminalen. En loggfil kan alternativt "
"skickas till :func:`faulthandler.enable`."

msgid ""
"The module is implemented in C, so tracebacks can be dumped on a crash or "
"when Python is deadlocked."
msgstr ""
"Modulen är implementerad i C, så att spårningar kan dumpas vid en krasch "
"eller när Python är blockerat."

msgid ""
"The :ref:`Python Development Mode <devmode>` calls :func:`faulthandler."
"enable` at Python startup."
msgstr ""
"I :ref:`Python Development Mode <devmode>` anropas :func:`faulthandler."
"enable` vid Python-start."

msgid "Module :mod:`pdb`"
msgstr "Modul :mod:`pdb`"

msgid "Interactive source code debugger for Python programs."
msgstr "Interaktiv källkodsfelsökare för Python-program."

msgid "Module :mod:`traceback`"
msgstr "Modul :mod:`traceback`"

msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""
"Standardgränssnitt för att extrahera, formatera och skriva ut stackspår från "
"Python-program."

msgid "Dumping the traceback"
msgstr "Dumpning av spårningen"

msgid ""
"Dump the tracebacks of all threads into *file*. If *all_threads* is "
"``False``, dump only the current thread."
msgstr ""
"Dumpar spårningarna av alla trådar till *fil*. Om *all_threads* är "
"``False``, dumpas endast den aktuella tråden."

msgid ""
":func:`traceback.print_tb`, which can be used to print a traceback object."
msgstr ""
":func:`traceback.print_tb`, som kan användas för att skriva ut ett traceback-"
"objekt."

msgid "Added support for passing file descriptor to this function."
msgstr "Lagt till stöd för att skicka filbeskrivare till denna funktion."

msgid "Dumping the C stack"
msgstr "Dumpa C-stacken"

msgid "Dump the C stack trace of the current thread into *file*."
msgstr "Dumpa C-stackspårningen för den aktuella tråden till *fil*."

msgid ""
"If the Python build does not support it or the operating system does not "
"provide a stack trace, then this prints an error in place of a dumped C "
"stack."
msgstr ""
"Om Python-versionen inte stöder detta eller om operativsystemet inte "
"tillhandahåller en stackspårning, skrivs ett fel ut i stället för en dumpad "
"C-stack."

msgid "C Stack Compatibility"
msgstr "Kompatibilitet med C-stack"

msgid ""
"If the system does not support the C-level :manpage:`backtrace(3)` or :"
"manpage:`dladdr1(3)`, then C stack dumps will not work. An error will be "
"printed instead of the stack."
msgstr ""
"Om systemet inte stöder C-nivå :manpage:`backtrace(3)` eller :manpage:"
"`dladdr1(3)` fungerar inte C-stackdumpar. Ett felmeddelande kommer att "
"skrivas ut istället för stacken."

msgid ""
"Additionally, some compilers do not support :term:`CPython's <CPython>` "
"implementation of C stack dumps. As a result, a different error may be "
"printed instead of the stack, even if the operating system supports dumping "
"stacks."
msgstr ""
"Dessutom stöder vissa kompilatorer inte :term:`CPythons <CPython>` "
"implementering av C-stackdumpar. Detta kan leda till att ett annat fel "
"skrivs ut i stället för stacken, även om operativsystemet stöder dumpning av "
"stackar."

msgid ""
"Dumping C stacks can be arbitrarily slow, depending on the DWARF level of "
"the binaries in the call stack."
msgstr ""
"Dumpning av C-stackar kan vara godtyckligt långsam, beroende på DWARF-nivån "
"för binärprogrammen i anropsstacken."

msgid "Fault handler state"
msgstr "Felhanterarens status"

msgid ""
"Enable the fault handler: install handlers for the :const:`~signal."
"SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:`~signal."
"SIGBUS` and :const:`~signal.SIGILL` signals to dump the Python traceback. If "
"*all_threads* is ``True``, produce tracebacks for every running thread. "
"Otherwise, dump only the current thread."
msgstr ""
"Aktivera felhanteraren: installera hanterare för signalerna :const:`~signal."
"SIGSEGV`, :const:`~signal.SIGFPE`, :const:`~signal.SIGABRT`, :const:`~signal."
"SIGBUS` och :const:`~signal.SIGILL` för att dumpa Python-spårningen. Om "
"*all_threads* är ``True``, producera spårningar för varje tråd som körs. "
"Annars dumpas endast den aktuella tråden."

msgid ""
"The *file* must be kept open until the fault handler is disabled: see :ref:"
"`issue with file descriptors <faulthandler-fd>`."
msgstr ""
"Filen måste hållas öppen tills felhanteraren inaktiveras: se :ref:`problem "
"med filbeskrivare <faulthandler-fd>`."

msgid ""
"If *c_stack* is ``True``, then the C stack trace is printed after the Python "
"traceback, unless the system does not support it. See :func:`dump_c_stack` "
"for more information on compatibility."
msgstr ""
"Om *c_stack* är ``True``, skrivs C-stackspåret ut efter Python-spårningen, "
"såvida inte systemet inte stöder det. Se :func:`dump_c_stack` för mer "
"information om kompatibilitet."

msgid "On Windows, a handler for Windows exception is also installed."
msgstr "I Windows installeras även en hanterare för Windows-undantag."

msgid ""
"The dump now mentions if a garbage collector collection is running if "
"*all_threads* is true."
msgstr "Dumpen nämner nu om en skräpsamlare körs om *all_threads* är true."

msgid ""
"Only the current thread is dumped if the :term:`GIL` is disabled to prevent "
"the risk of data races."
msgstr ""
"Endast den aktuella tråden dumpas om :term:`GIL` är inaktiverad för att "
"förhindra risken för datarace."

msgid "The dump now displays the C stack trace if *c_stack* is true."
msgstr "Dumpen visar nu C-stackspårningen om *c_stack* är sant."

msgid ""
"Disable the fault handler: uninstall the signal handlers installed by :func:"
"`enable`."
msgstr ""
"Inaktivera felhanteraren: avinstallera de signalhanterare som installerats "
"av :func:`enable`."

msgid "Check if the fault handler is enabled."
msgstr "Kontrollera om felhanteraren är aktiverad."

msgid "Dumping the tracebacks after a timeout"
msgstr "Dumpning av spårningar efter en timeout"

msgid ""
"Dump the tracebacks of all threads, after a timeout of *timeout* seconds, or "
"every *timeout* seconds if *repeat* is ``True``.  If *exit* is ``True``, "
"call :c:func:`!_exit` with status=1 after dumping the tracebacks.  (Note :c:"
"func:`!_exit` exits the process immediately, which means it doesn't do any "
"cleanup like flushing file buffers.) If the function is called twice, the "
"new call replaces previous parameters and resets the timeout. The timer has "
"a sub-second resolution."
msgstr ""
"Dumpar spårningarna av alla trådar efter en tidsgräns på *timeout* sekunder, "
"eller varje *timeout* sekund om *repeat* är ``True``.  Om *exit* är "
"``True``, anropa :c:func:`!_exit` med status=1 efter att ha dumpat "
"spårningarna.  (Observera att :c:func:`!_exit` avslutar processen "
"omedelbart, vilket innebär att den inte gör någon upprensning som att tömma "
"filbuffertar) Om funktionen anropas två gånger ersätter det nya anropet "
"tidigare parametrar och återställer timeouten. Timern har en upplösning på "
"subsekunder."

msgid ""
"The *file* must be kept open until the traceback is dumped or :func:"
"`cancel_dump_traceback_later` is called: see :ref:`issue with file "
"descriptors <faulthandler-fd>`."
msgstr ""
"Filen måste hållas öppen tills spårningen dumpas eller :func:"
"`cancel_dump_traceback_later` anropas: se :ref:`problem med filbeskrivare "
"<faulthandler-fd>`."

msgid "This function is implemented using a watchdog thread."
msgstr "Denna funktion implementeras med hjälp av en watchdog-tråd."

msgid "This function is now always available."
msgstr "Denna funktion är nu alltid tillgänglig."

msgid "Cancel the last call to :func:`dump_traceback_later`."
msgstr "Avbryt det senaste anropet till :func:`dump_traceback_later`."

msgid "Dumping the traceback on a user signal"
msgstr "Dumpning av spårningen av en användarsignal"

msgid ""
"Register a user signal: install a handler for the *signum* signal to dump "
"the traceback of all threads, or of the current thread if *all_threads* is "
"``False``, into *file*. Call the previous handler if chain is ``True``."
msgstr ""
"Registrera en användarsignal: installera en hanterare för *signum*-signalen "
"för att dumpa spårningen av alla trådar, eller av den aktuella tråden om "
"*all_threads* är ``False``, i *file*. Anropa den föregående hanteraren om "
"chain är ``True``."

msgid ""
"The *file* must be kept open until the signal is unregistered by :func:"
"`unregister`: see :ref:`issue with file descriptors <faulthandler-fd>`."
msgstr ""
"*Filen* måste hållas öppen tills signalen avregistreras med :func:"
"`unregister`: se :ref:`problem med filbeskrivare <faulthandler-fd>`."

msgid "Not available on Windows."
msgstr "Ej tillgängligt på Windows."

msgid ""
"Unregister a user signal: uninstall the handler of the *signum* signal "
"installed by :func:`register`. Return ``True`` if the signal was registered, "
"``False`` otherwise."
msgstr ""
"Avregistrera en användarsignal: avinstallera hanteraren av *signum*-signalen "
"som installerats av :func:`register`. Returnerar ``True`` om signalen var "
"registrerad, ``False`` annars."

msgid "Issue with file descriptors"
msgstr "Problem med filbeskrivare"

msgid ""
":func:`enable`, :func:`dump_traceback_later` and :func:`register` keep the "
"file descriptor of their *file* argument. If the file is closed and its file "
"descriptor is reused by a new file, or if :func:`os.dup2` is used to replace "
"the file descriptor, the traceback will be written into a different file. "
"Call these functions again each time that the file is replaced."
msgstr ""
":func:`enable`, :func:`dump_traceback_later` och :func:`register` behåller "
"filbeskrivaren för sitt *file*-argument. Om filen stängs och dess "
"filbeskrivare återanvänds av en ny fil, eller om :func:`os.dup2` används för "
"att ersätta filbeskrivaren, kommer spårningen att skrivas till en annan fil. "
"Anropa dessa funktioner igen varje gång filen ersätts."

msgid "Example"
msgstr "Exempel"

msgid ""
"Example of a segmentation fault on Linux with and without enabling the fault "
"handler:"
msgstr ""
"Exempel på ett segmenteringsfel på Linux med och utan aktivering av "
"felhanteraren:"

msgid ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/opt/python/Lib/ctypes/__init__.py\", line 486 in string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"\n"
"Current thread's C stack trace (most recent call first):\n"
"  Binary file \"/opt/python/python\", at _Py_DumpStack+0x42 "
"[0x5b27f7d7147e]\n"
"  Binary file \"/opt/python/python\", at +0x32dcbd [0x5b27f7d85cbd]\n"
"  Binary file \"/opt/python/python\", at +0x32df8a [0x5b27f7d85f8a]\n"
"  Binary file \"/usr/lib/libc.so.6\", at +0x3def0 [0x77b73226bef0]\n"
"  Binary file \"/usr/lib/libc.so.6\", at +0x17ef9c [0x77b7323acf9c]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0xcdf6 [0x77b7315dddf6]\n"
"  Binary file \"/usr/lib/libffi.so.8\", at +0x7976 [0x77b73158f976]\n"
"  Binary file \"/usr/lib/libffi.so.8\", at +0x413c [0x77b73158c13c]\n"
"  Binary file \"/usr/lib/libffi.so.8\", at ffi_call+0x12e [0x77b73158ef0e]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0x15a33 [0x77b7315e6a33]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0x164fa [0x77b7315e74fa]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0xc624 [0x77b7315dd624]\n"
"  Binary file \"/opt/python/python\", at _PyObject_MakeTpCall+0xce "
"[0x5b27f7b73883]\n"
"  Binary file \"/opt/python/python\", at +0x11bab6 [0x5b27f7b73ab6]\n"
"  Binary file \"/opt/python/python\", at PyObject_Vectorcall+0x23 "
"[0x5b27f7b73b04]\n"
"  Binary file \"/opt/python/python\", at _PyEval_EvalFrameDefault+0x490c "
"[0x5b27f7cbb302]\n"
"  Binary file \"/opt/python/python\", at +0x2818e6 [0x5b27f7cd98e6]\n"
"  Binary file \"/opt/python/python\", at +0x281aab [0x5b27f7cd9aab]\n"
"  Binary file \"/opt/python/python\", at PyEval_EvalCode+0xc5 "
"[0x5b27f7cd9ba3]\n"
"  Binary file \"/opt/python/python\", at +0x255957 [0x5b27f7cad957]\n"
"  Binary file \"/opt/python/python\", at +0x255ab4 [0x5b27f7cadab4]\n"
"  Binary file \"/opt/python/python\", at _PyEval_EvalFrameDefault+0x6c3e "
"[0x5b27f7cbd634]\n"
"  Binary file \"/opt/python/python\", at +0x2818e6 [0x5b27f7cd98e6]\n"
"  Binary file \"/opt/python/python\", at +0x281aab [0x5b27f7cd9aab]\n"
"  Binary file \"/opt/python/python\", at +0x11b6e1 [0x5b27f7b736e1]\n"
"  Binary file \"/opt/python/python\", at +0x11d348 [0x5b27f7b75348]\n"
"  Binary file \"/opt/python/python\", at +0x11d626 [0x5b27f7b75626]\n"
"  Binary file \"/opt/python/python\", at PyObject_Call+0x20 "
"[0x5b27f7b7565e]\n"
"  Binary file \"/opt/python/python\", at +0x32a67a [0x5b27f7d8267a]\n"
"  Binary file \"/opt/python/python\", at +0x32a7f8 [0x5b27f7d827f8]\n"
"  Binary file \"/opt/python/python\", at +0x32ac1b [0x5b27f7d82c1b]\n"
"  Binary file \"/opt/python/python\", at Py_RunMain+0x31 [0x5b27f7d82ebe]\n"
"  <truncated rest of calls>\n"
"Segmentation fault"
msgstr ""
"$ python -c \"import ctypes; ctypes.string_at(0)\"\n"
"Segmentation fault\n"
"\n"
"$ python -q -X faulthandler\n"
">>> import ctypes\n"
">>> ctypes.string_at(0)\n"
"Fatal Python error: Segmentation fault\n"
"\n"
"Current thread 0x00007fb899f39700 (most recent call first):\n"
"  File \"/opt/python/Lib/ctypes/__init__.py\", line 486 in string_at\n"
"  File \"<stdin>\", line 1 in <module>\n"
"\n"
"Current thread's C stack trace (most recent call first):\n"
"  Binary file \"/opt/python/python\", at _Py_DumpStack+0x42 "
"[0x5b27f7d7147e]\n"
"  Binary file \"/opt/python/python\", at +0x32dcbd [0x5b27f7d85cbd]\n"
"  Binary file \"/opt/python/python\", at +0x32df8a [0x5b27f7d85f8a]\n"
"  Binary file \"/usr/lib/libc.so.6\", at +0x3def0 [0x77b73226bef0]\n"
"  Binary file \"/usr/lib/libc.so.6\", at +0x17ef9c [0x77b7323acf9c]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0xcdf6 [0x77b7315dddf6]\n"
"  Binary file \"/usr/lib/libffi.so.8\", at +0x7976 [0x77b73158f976]\n"
"  Binary file \"/usr/lib/libffi.so.8\", at +0x413c [0x77b73158c13c]\n"
"  Binary file \"/usr/lib/libffi.so.8\", at ffi_call+0x12e [0x77b73158ef0e]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0x15a33 [0x77b7315e6a33]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0x164fa [0x77b7315e74fa]\n"
"  Binary file \"/opt/python/build/lib.linux-x86_64-3.14/_ctypes.cpython-314d-"
"x86_64-linux-gnu.so\", at +0xc624 [0x77b7315dd624]\n"
"  Binary file \"/opt/python/python\", at _PyObject_MakeTpCall+0xce "
"[0x5b27f7b73883]\n"
"  Binary file \"/opt/python/python\", at +0x11bab6 [0x5b27f7b73ab6]\n"
"  Binary file \"/opt/python/python\", at PyObject_Vectorcall+0x23 "
"[0x5b27f7b73b04]\n"
"  Binary file \"/opt/python/python\", at _PyEval_EvalFrameDefault+0x490c "
"[0x5b27f7cbb302]\n"
"  Binary file \"/opt/python/python\", at +0x2818e6 [0x5b27f7cd98e6]\n"
"  Binary file \"/opt/python/python\", at +0x281aab [0x5b27f7cd9aab]\n"
"  Binary file \"/opt/python/python\", at PyEval_EvalCode+0xc5 "
"[0x5b27f7cd9ba3]\n"
"  Binary file \"/opt/python/python\", at +0x255957 [0x5b27f7cad957]\n"
"  Binary file \"/opt/python/python\", at +0x255ab4 [0x5b27f7cadab4]\n"
"  Binary file \"/opt/python/python\", at _PyEval_EvalFrameDefault+0x6c3e "
"[0x5b27f7cbd634]\n"
"  Binary file \"/opt/python/python\", at +0x2818e6 [0x5b27f7cd98e6]\n"
"  Binary file \"/opt/python/python\", at +0x281aab [0x5b27f7cd9aab]\n"
"  Binary file \"/opt/python/python\", at +0x11b6e1 [0x5b27f7b736e1]\n"
"  Binary file \"/opt/python/python\", at +0x11d348 [0x5b27f7b75348]\n"
"  Binary file \"/opt/python/python\", at +0x11d626 [0x5b27f7b75626]\n"
"  Binary file \"/opt/python/python\", at PyObject_Call+0x20 "
"[0x5b27f7b7565e]\n"
"  Binary file \"/opt/python/python\", at +0x32a67a [0x5b27f7d8267a]\n"
"  Binary file \"/opt/python/python\", at +0x32a7f8 [0x5b27f7d827f8]\n"
"  Binary file \"/opt/python/python\", at +0x32ac1b [0x5b27f7d82c1b]\n"
"  Binary file \"/opt/python/python\", at Py_RunMain+0x31 [0x5b27f7d82ebe]\n"
"  <truncated rest of calls>\n"
"Segmentation fault"
