# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!selectors` --- High-level I/O multiplexing"
msgstr ":mod:`!selectors` --- I/O-multiplexering på hög nivå"

msgid "**Source code:** :source:`Lib/selectors.py`"
msgstr "**Källkod:** :source:`Lib/selectors.py`"

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"This module allows high-level and efficient I/O multiplexing, built upon "
"the :mod:`select` module primitives. Users are encouraged to use this module "
"instead, unless they want precise control over the OS-level primitives used."
msgstr ""
"Den här modulen möjliggör effektiv I/O-multiplexering på hög nivå och bygger "
"på :mod:`select`-modulens primitiver. Användare uppmanas att använda den här "
"modulen istället, såvida de inte vill ha exakt kontroll över de primitiver "
"på OS-nivå som används."

msgid ""
"It defines a :class:`BaseSelector` abstract base class, along with several "
"concrete implementations (:class:`KqueueSelector`, :class:"
"`EpollSelector`...), that can be used to wait for I/O readiness notification "
"on multiple file objects. In the following, \"file object\" refers to any "
"object with a :meth:`~io.IOBase.fileno` method, or a raw file descriptor. "
"See :term:`file object`."
msgstr ""
"Den definierar en :class:`BaseSelector` abstrakt basklass, tillsammans med "
"flera konkreta implementationer (:class:`KqueueSelector`, :class:"
"`EpollSelector`...), som kan användas för att vänta på I/O-"
"beredskapsmeddelande på flera filobjekt. I det följande avser \"filobjekt\" "
"alla objekt med en :meth:`~io.IOBase.fileno`-metod eller en rå "
"filbeskrivare. Se :term:`filobjekt`."

msgid ""
":class:`DefaultSelector` is an alias to the most efficient implementation "
"available on the current platform: this should be the default choice for "
"most users."
msgstr ""
":class:`DefaultSelector` är ett alias för den mest effektiva "
"implementationen som finns tillgänglig på den aktuella plattformen: detta "
"bör vara standardvalet för de flesta användare."

msgid ""
"The type of file objects supported depends on the platform: on Windows, "
"sockets are supported, but not pipes, whereas on Unix, both are supported "
"(some other types may be supported as well, such as fifos or special file "
"devices)."
msgstr ""
"Vilken typ av filobjekt som stöds beror på plattformen: på Windows stöds "
"sockets, men inte pipes, medan båda stöds på Unix (vissa andra typer kan "
"också stödjas, t.ex. fifos eller speciella filenheter)."

msgid ":mod:`select`"
msgstr ":mod:`välja`"

msgid "Low-level I/O multiplexing module."
msgstr "Modul för I/O-multiplexering på låg nivå."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid "Classes"
msgstr "Klasser"

msgid "Classes hierarchy::"
msgstr "Klasser-hierarki::"

msgid ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"
msgstr ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"

msgid ""
"In the following, *events* is a bitwise mask indicating which I/O events "
"should be waited for on a given file object. It can be a combination of the "
"modules constants below:"
msgstr ""
"I det följande är *events* en bitvis mask som anger vilka I/O-händelser som "
"ska inväntas för ett visst filobjekt. Den kan vara en kombination av "
"modulkonstanterna nedan:"

msgid "Constant"
msgstr "Konstant"

msgid "Meaning"
msgstr "Betydelse"

msgid "Available for read"
msgstr "Tillgänglig för läsning"

msgid "Available for write"
msgstr "Tillgänglig för skrivning"

msgid ""
"A :class:`SelectorKey` is a :class:`~collections.namedtuple` used to "
"associate a file object to its underlying file descriptor, selected event "
"mask and attached data. It is returned by several :class:`BaseSelector` "
"methods."
msgstr ""
"En :class:`SelectorKey` är en :class:`~collections.namedtuple` som används "
"för att associera ett filobjekt till dess underliggande filbeskrivning, "
"valda händelsemask och bifogade data. Den returneras av flera :class:"
"`BaseSelector`-metoder."

msgid "File object registered."
msgstr "Filobjekt registrerat."

msgid "Underlying file descriptor."
msgstr "Underliggande filbeskrivare."

msgid "Events that must be waited for on this file object."
msgstr "Händelser som måste inväntas för detta filobjekt."

msgid ""
"Optional opaque data associated to this file object: for example, this could "
"be used to store a per-client session ID."
msgstr ""
"Valfri opak data som är kopplad till filobjektet: kan t.ex. användas för att "
"lagra ett sessions-ID för varje klient."

msgid ""
"A :class:`BaseSelector` is used to wait for I/O event readiness on multiple "
"file objects. It supports file stream registration, unregistration, and a "
"method to wait for I/O events on those streams, with an optional timeout. "
"It's an abstract base class, so cannot be instantiated. Use :class:"
"`DefaultSelector` instead, or one of :class:`SelectSelector`, :class:"
"`KqueueSelector` etc. if you want to specifically use an implementation, and "
"your platform supports it. :class:`BaseSelector` and its concrete "
"implementations support the :term:`context manager` protocol."
msgstr ""
"En :class:`BaseSelector` används för att vänta på I/O-händelser på flera "
"filobjekt. Den stöder registrering och avregistrering av filströmmar och en "
"metod för att vänta på I/O-händelser i dessa strömmar, med en valfri "
"timeout. Det är en abstrakt basklass, så den kan inte instansieras. Använd :"
"class:`DefaultSelector` istället, eller en av :class:`SelectSelector`, :"
"class:`KqueueSelector` etc. om du specifikt vill använda en implementation, "
"och din plattform stödjer det. :class:`BaseSelector` och dess konkreta "
"implementationer stödjer :term:`context manager` protokollet."

msgid "Register a file object for selection, monitoring it for I/O events."
msgstr "Registrera ett filobjekt för val och övervaka det för I/O-händelser."

msgid ""
"*fileobj* is the file object to monitor.  It may either be an integer file "
"descriptor or an object with a ``fileno()`` method. *events* is a bitwise "
"mask of events to monitor. *data* is an opaque object."
msgstr ""
"*fileobj* är det filobjekt som ska övervakas.  Det kan antingen vara en "
"filbeskrivare med heltal eller ett objekt med en ``fileno()``-metod. "
"*events* är en bitvis mask av händelser som ska övervakas. *data* är ett "
"opakt objekt."

msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is already registered."
msgstr ""
"Detta returnerar en ny :class:`SelectorKey`-instans, eller ger upphov till "
"ett :exc:`ValueError` om händelsemasken eller filbeskrivningen är ogiltig, "
"eller :exc:`KeyError` om filobjektet redan är registrerat."

msgid ""
"Unregister a file object from selection, removing it from monitoring. A file "
"object shall be unregistered prior to being closed."
msgstr ""
"Avregistrera ett filobjekt från urvalet och ta bort det från övervakning. "
"Ett filobjekt ska avregistreras innan det stängs."

msgid "*fileobj* must be a file object previously registered."
msgstr "*fileobj* måste vara ett filobjekt som tidigare registrerats."

msgid ""
"This returns the associated :class:`SelectorKey` instance, or raises a :exc:"
"`KeyError` if *fileobj* is not registered.  It will raise :exc:`ValueError` "
"if *fileobj* is invalid (e.g. it has no ``fileno()`` method or its "
"``fileno()`` method has an invalid return value)."
msgstr ""
"Detta returnerar den associerade :class:`SelectorKey`-instansen, eller ger "
"upphov till :exc:`KeyError` om *fileobj* inte är registrerad.  Den ger "
"upphov till :exc:`ValueError` om *fileobj* är ogiltig (t.ex. om den inte har "
"någon ``fileno()``-metod eller om dess ``fileno()``-metod har ett ogiltigt "
"returvärde)."

msgid "Change a registered file object's monitored events or attached data."
msgstr ""
"Ändra ett registrerat filobjekts övervakade händelser eller bifogade data."

msgid ""
"This is equivalent to ``BaseSelector.unregister(fileobj)`` followed by "
"``BaseSelector.register(fileobj, events, data)``, except that it can be "
"implemented more efficiently."
msgstr ""
"Detta är likvärdigt med ``BaseSelector.unregister(fileobj)`` följt av "
"``BaseSelector.register(fileobj, events, data)``, förutom att det kan "
"implementeras mer effektivt."

msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is not registered."
msgstr ""
"Detta returnerar en ny :class:`SelectorKey`-instans, eller ger upphov till "
"ett :exc:`ValueError` i händelse av ogiltig händelsemask eller "
"filbeskrivning, eller :exc:`KeyError` om filobjektet inte är registrerat."

msgid ""
"Wait until some registered file objects become ready, or the timeout expires."
msgstr ""
"Vänta tills några registrerade filobjekt blir klara eller tills timeouten "
"löper ut."

msgid ""
"If ``timeout > 0``, this specifies the maximum wait time, in seconds. If "
"``timeout <= 0``, the call won't block, and will report the currently ready "
"file objects. If *timeout* is ``None``, the call will block until a "
"monitored file object becomes ready."
msgstr ""
"Om ``timeout > 0``, anger detta den maximala väntetiden i sekunder. Om "
"``timeout <= 0`` kommer anropet inte att blockeras och rapporterar de "
"filobjekt som för närvarande är klara. Om *timeout* är ``None`` kommer "
"anropet att blockeras tills ett övervakat filobjekt blir klart."

msgid ""
"This returns a list of ``(key, events)`` tuples, one for each ready file "
"object."
msgstr ""
"Detta returnerar en lista med ``(key, events)``-tupler, en för varje färdigt "
"filobjekt."

msgid ""
"*key* is the :class:`SelectorKey` instance corresponding to a ready file "
"object. *events* is a bitmask of events ready on this file object."
msgstr ""
"*key* är den instans av :class:`SelectorKey` som motsvarar ett färdigt "
"filobjekt. *events* är en bitmask av händelser som är klara för detta "
"filobjekt."

msgid ""
"This method can return before any file object becomes ready or the timeout "
"has elapsed if the current process receives a signal: in this case, an empty "
"list will be returned."
msgstr ""
"Denna metod kan returneras innan något filobjekt blir klart eller timeouten "
"har löpt ut om den aktuella processen får en signal: i detta fall returneras "
"en tom lista."

msgid ""
"The selector is now retried with a recomputed timeout when interrupted by a "
"signal if the signal handler did not raise an exception (see :pep:`475` for "
"the rationale), instead of returning an empty list of events before the "
"timeout."
msgstr ""
"Väljaren försöker nu igen med en omräknad timeout när den avbryts av en "
"signal om signalhanteraren inte utlöste ett undantag (se :pep:`475` för "
"förklaringen), istället för att returnera en tom lista med händelser före "
"timeouten."

msgid "Close the selector."
msgstr "Stäng väljaren."

msgid ""
"This must be called to make sure that any underlying resource is freed. The "
"selector shall not be used once it has been closed."
msgstr ""
"Detta måste anropas för att säkerställa att alla underliggande resurser är "
"frigjorda. Väljaren får inte användas när den har stängts."

msgid "Return the key associated with a registered file object."
msgstr "Returnerar nyckeln som är kopplad till ett registrerat filobjekt."

msgid ""
"This returns the :class:`SelectorKey` instance associated to this file "
"object, or raises :exc:`KeyError` if the file object is not registered."
msgstr ""
"Detta returnerar :class:`SelectorKey`-instansen som är associerad med detta "
"filobjekt, eller ger upphov till :exc:`KeyError` om filobjektet inte är "
"registrerat."

msgid "Return a mapping of file objects to selector keys."
msgstr "Returnerar en mappning av filobjekt till väljarknappar."

msgid ""
"This returns a :class:`~collections.abc.Mapping` instance mapping registered "
"file objects to their associated :class:`SelectorKey` instance."
msgstr ""
"Detta returnerar en :class:`~collections.abc.Mapping`-instans som mappar "
"registrerade filobjekt till deras associerade :class:`SelectorKey`-instans."

msgid ""
"The default selector class, using the most efficient implementation "
"available on the current platform. This should be the default choice for "
"most users."
msgstr ""
"Standardväljarklassen använder den mest effektiva implementeringen som finns "
"tillgänglig på den aktuella plattformen. Detta bör vara standardvalet för de "
"flesta användare."

msgid ":func:`select.select`-based selector."
msgstr ":func:`select.select`-baserad väljare."

msgid ":func:`select.poll`-based selector."
msgstr ":func:`select.poll`-baserad väljare."

msgid ":func:`select.epoll`-based selector."
msgstr ":func:`select.epoll`-baserad väljare."

msgid ""
"This returns the file descriptor used by the underlying :func:`select.epoll` "
"object."
msgstr ""
"Detta returnerar filbeskrivaren som används av det underliggande :func:"
"`select.epoll`-objektet."

msgid ":func:`select.devpoll`-based selector."
msgstr ":func:`select.devpoll`-baserad väljare."

msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"devpoll` object."
msgstr ""
"Detta returnerar filbeskrivaren som används av det underliggande :func:"
"`select.devpoll`-objektet."

msgid ":func:`select.kqueue`-based selector."
msgstr ":func:`select.kqueue`-baserad väljare."

msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"kqueue` object."
msgstr ""
"Detta returnerar filbeskrivaren som används av det underliggande :func:"
"`select.kqueue`-objektet."

msgid "Examples"
msgstr "Exempel"

msgid "Here is a simple echo server implementation::"
msgstr "Här är en enkel implementering av en ekoserver::"

msgid ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
msgstr ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
