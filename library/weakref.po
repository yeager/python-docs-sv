# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- Svaga referenser"

msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**Källkod:** :source:`Lib/weakref.py`"

msgid ""
"The :mod:`weakref` module allows the Python programmer to create :dfn:`weak "
"references` to objects."
msgstr ""
"Modulen :mod:`weakref` gör det möjligt för Python-programmerare att skapa :"
"dfn:`svaga referenser` till objekt."

msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr ""
"I det följande betyder termen :dfn:`referent` det objekt som refereras till "
"med en svag referens."

msgid ""
"A weak reference to an object is not enough to keep the object alive: when "
"the only remaining references to a referent are weak references, :term:"
"`garbage collection` is free to destroy the referent and reuse its memory "
"for something else.  However, until the object is actually destroyed the "
"weak reference may return the object even if there are no strong references "
"to it."
msgstr ""
"En svag referens till ett objekt räcker inte för att hålla objektet vid liv: "
"när de enda återstående referenserna till en referent är svaga referenser, "
"kan :term:`garbage collection` fritt förstöra referenten och återanvända "
"dess minne till något annat.  Fram till dess att objektet faktiskt förstörs "
"kan dock den svaga referensen returnera objektet även om det inte finns "
"några starka referenser till det."

msgid ""
"A primary use for weak references is to implement caches or mappings holding "
"large objects, where it's desired that a large object not be kept alive "
"solely because it appears in a cache or mapping."
msgstr ""
"En primär användning av svaga referenser är att implementera cacheminnen "
"eller mappningar som innehåller stora objekt, där det är önskvärt att ett "
"stort objekt inte hålls vid liv enbart för att det förekommer i ett "
"cacheminne eller en mappning."

msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to map "
"names to images, or images to names, the image objects would remain alive "
"just because they appeared as values or keys in the dictionaries.  The :"
"class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes supplied "
"by the :mod:`weakref` module are an alternative, using weak references to "
"construct mappings that don't keep objects alive solely because they appear "
"in the mapping objects.  If, for example, an image object is a value in a :"
"class:`WeakValueDictionary`, then when the last remaining references to that "
"image object are the weak references held by weak mappings, garbage "
"collection can reclaim the object, and its corresponding entries in weak "
"mappings are simply deleted."
msgstr ""
"Om du till exempel har ett antal stora binära bildobjekt kanske du vill "
"associera ett namn med varje objekt.  Om du använde en Python-ordbok för att "
"mappa namn till bilder, eller bilder till namn, skulle bildobjekten förbli "
"levande bara för att de dök upp som värden eller nycklar i ordböckerna.  "
"Klasserna :class:`WeakKeyDictionary` och :class:`WeakValueDictionary` som "
"tillhandahålls av modulen :mod:`weakref` är ett alternativ som använder "
"svaga referenser för att konstruera mappningar som inte håller objekt vid "
"liv enbart för att de förekommer i mappningsobjekten.  Om t.ex. ett "
"bildobjekt är ett värde i en :class:`WeakValueDictionary`, och när de sista "
"kvarvarande referenserna till bildobjektet är svaga referenser i svaga "
"mappningar, kan skräpsamlingen återta objektet och motsvarande poster i "
"svaga mappningar raderas helt enkelt."

msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has "
"been reclaimed by garbage collection.  :class:`WeakSet` implements the :"
"class:`set` interface, but keeps weak references to its elements, just like "
"a :class:`WeakKeyDictionary` does."
msgstr ""
":class:`WeakKeyDictionary` och :class:`WeakValueDictionary` använder svaga "
"referenser i sin implementering och skapar callback-funktioner på de svaga "
"referenserna som meddelar de svaga ordböckerna när en nyckel eller ett värde "
"har återvunnits av garbage collection. :class:`WeakSet` implementerar "
"gränssnittet :class:`set`, men behåller svaga referenser till sina element, "
"precis som en :class:`WeakKeyDictionary` gör."

msgid ""
":class:`finalize` provides a straight forward way to register a cleanup "
"function to be called when an object is garbage collected. This is simpler "
"to use than setting up a callback function on a raw weak reference, since "
"the module automatically ensures that the finalizer remains alive until the "
"object is collected."
msgstr ""
":class:`finalize` ger ett enkelt sätt att registrera en rensningsfunktion "
"som ska anropas när ett objekt samlas in. Detta är enklare att använda än "
"att sätta upp en callback-funktion på en svag referens, eftersom modulen "
"automatiskt ser till att finalizer-funktionen hålls vid liv tills objektet "
"samlas in."

msgid ""
"Most programs should find that using one of these weak container types or :"
"class:`finalize` is all they need -- it's not usually necessary to create "
"your own weak references directly.  The low-level machinery is exposed by "
"the :mod:`weakref` module for the benefit of advanced uses."
msgstr ""
"De flesta program bör finna att det räcker med att använda en av dessa svaga "
"containertyper eller :class:`finalize` - det är vanligtvis inte nödvändigt "
"att skapa egna svaga referenser direkt.  Maskineriet på låg nivå exponeras "
"av modulen :mod:`weakref` till förmån för avancerade användningsområden."

msgid ""
"Not all objects can be weakly referenced. Objects which support weak "
"references include class instances, functions written in Python (but not in "
"C), instance methods, sets, frozensets, some :term:`file objects <file "
"object>`, :term:`generators <generator>`, type objects, sockets, arrays, "
"deques, regular expression pattern objects, and code objects."
msgstr ""
"Det är inte alla objekt som kan refereras svagt. Objekt som stöder svaga "
"referenser inkluderar klassinstanser, funktioner skrivna i Python (men inte "
"i C), instansmetoder, set, frozensets, vissa :term:`filobjekt <file "
"object>`, :term:`generatorer <generator>`, typobjekt, sockets, matriser, "
"deques, mönsterobjekt för reguljära uttryck och kodobjekt."

msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr "Lagt till stöd för thread.lock, threading.Lock och kodobjekt."

msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through subclassing::"
msgstr ""
"Flera inbyggda typer som :class:`list` och :class:`dict` har inte direkt "
"stöd för svaga referenser men kan lägga till stöd genom underklassning::"

msgid ""
"class Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(red=1, green=2, blue=3)   # this object is weak referenceable"
msgstr ""
"klass Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(röd=1, grön=2, blå=3) # detta objekt är svagt refererbart"

msgid ""
"Other built-in types such as :class:`tuple` and :class:`int` do not support "
"weak references even when subclassed."
msgstr ""
"Andra inbyggda typer som :class:`tuple` och :class:`int` stöder inte svaga "
"referenser även om de är underklassade."

msgid ""
"Extension types can easily be made to support weak references; see :ref:"
"`weakref-support`."
msgstr ""
"Tilläggstyper kan enkelt göras för att stödja svaga referenser; se :ref:"
"`weakref-support`."

msgid ""
"When ``__slots__`` are defined for a given type, weak reference support is "
"disabled unless a ``'__weakref__'`` string is also present in the sequence "
"of strings in the ``__slots__`` declaration. See :ref:`__slots__ "
"documentation <slots>` for details."
msgstr ""
"När ``__slots__`` definieras för en viss typ inaktiveras stödet för svaga "
"referenser om inte en sträng av typen ``'__weakref__'`` också finns i "
"sekvensen av strängar i ``__slots__``-deklarationen. Se :ref:`__slots__ "
"dokumentation <slots>` för detaljer."

msgid ""
"Return a weak reference to *object*.  The original object can be retrieved "
"by calling the reference object if the referent is still alive; if the "
"referent is no longer alive, calling the reference object will cause :const:"
"`None` to be returned.  If *callback* is provided and not :const:`None`, and "
"the returned weakref object is still alive, the callback will be called when "
"the object is about to be finalized; the weak reference object will be "
"passed as the only parameter to the callback; the referent will no longer be "
"available."
msgstr ""
"Returnerar en svag referens till *object*.  Det ursprungliga objektet kan "
"hämtas genom att anropa referensobjektet om referenten fortfarande är vid "
"liv; om referenten inte längre är vid liv kommer anrop av referensobjektet "
"att leda till att :const:`None` returneras.  Om *callback* anges och inte :"
"const:`None`, och det returnerade weakref-objektet fortfarande är vid liv, "
"kommer callbacken att anropas när objektet är på väg att slutföras; det "
"svaga referensobjektet kommer att skickas som den enda parametern till "
"callbacken; referenten kommer inte längre att vara tillgänglig."

msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from the "
"most recently registered callback to the oldest registered callback."
msgstr ""
"Det är tillåtet att konstruera många svaga referenser för samma objekt. "
"Callbacks som registrerats för varje svag referens kommer att anropas från "
"den senast registrerade callbacken till den äldsta registrerade callbacken."

msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same way "
"as exceptions raised from an object's :meth:`~object.__del__` method."
msgstr ""
"Undantag som orsakas av återuppringningen noteras i standardfelutmatningen, "
"men kan inte spridas; de hanteras på exakt samma sätt som undantag som "
"orsakas av ett objekts :meth:`~object.__del__`-metod."

msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They will "
"maintain their hash value even after the *object* was deleted.  If :func:"
"`hash` is called the first time only after the *object* was deleted, the "
"call will raise :exc:`TypeError`."
msgstr ""
"Svaga referenser är :term:`hashable` om *objektet* är hashbart.  De behåller "
"sitt hashvärde även efter att *objektet* har tagits bort.  Om :func:`hash` "
"anropas första gången först efter att *objektet* har tagits bort, kommer "
"anropet att ge upphov till :exc:`TypeError`."

msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If either "
"referent has been deleted, the references are equal only if the reference "
"objects are the same object."
msgstr ""
"Svaga referenser stöder tester för jämlikhet, men inte för ordning.  Om "
"referenterna fortfarande är vid liv har två referenser samma "
"jämlikhetsrelation som sina referenter (oavsett *callback*).  Om någon av "
"referenterna har tagits bort är referenserna jämlika endast om "
"referensobjekten är samma objekt."

msgid "This is a subclassable type rather than a factory function."
msgstr "Detta är en underklassbar typ snarare än en fabriksfunktion."

msgid ""
"This read-only attribute returns the callback currently associated to the "
"weakref.  If there is no callback or if the referent of the weakref is no "
"longer alive then this attribute will have value ``None``."
msgstr ""
"Detta skrivskyddade attribut returnerar den återuppringning som för "
"närvarande är associerad med weakref.  Om det inte finns någon återkallelse "
"eller om referenten till weakref inte längre lever kommer detta attribut att "
"ha värdet ``None``."

msgid "Added the :attr:`__callback__` attribute."
msgstr "Lagt till attributet :attr:`__callback__`."

msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports use "
"of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will "
"have a type of either ``ProxyType`` or ``CallableProxyType``, depending on "
"whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevents their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the :func:"
"`ref` function."
msgstr ""
"Returnerar en proxy till *object* som använder en svag referens.  Detta "
"stödjer användning av proxyn i de flesta sammanhang istället för att kräva "
"den explicita dereferencing som används med svaga referensobjekt.  Det "
"returnerade objektet kommer att ha en typ av antingen ``ProxyType`` eller "
"``CallableProxyType``, beroende på om *object* är anropsbart.  Proxy-objekt "
"är inte :term:`hashable` oavsett referent; detta undviker ett antal problem "
"relaterade till deras fundamentalt föränderliga natur, och förhindrar deras "
"användning som ordboksnycklar.  *callback* är detsamma som parametern med "
"samma namn till funktionen :func:`ref`."

msgid ""
"Accessing an attribute of the proxy object after the referent is garbage "
"collected raises :exc:`ReferenceError`."
msgstr ""
"Åtkomst till ett attribut för proxyobjektet efter att referenten har samlats "
"in ger upphov till :exc:`ReferenceError`."

msgid ""
"Extended the operator support on proxy objects to include the matrix "
"multiplication operators ``@`` and ``@=``."
msgstr ""
"Utökat operatorsstöd för proxyobjekt till att omfatta "
"matrismultiplikationsoperatorerna ``@`` och ``@=``."

msgid ""
"Return the number of weak references and proxies which refer to *object*."
msgstr ""
"Returnera antalet svaga referenser och proxies som refererar till *objekt*."

msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr ""
"Returnerar en lista över alla svaga referens- och proxyobjekt som refererar "
"till *object*."

msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary will "
"be discarded when there is no longer a strong reference to the key.  This "
"can be used to associate additional data with an object owned by other parts "
"of an application without adding attributes to those objects.  This can be "
"especially useful with objects that override attribute accesses."
msgstr ""
"Mappningsklass som refererar svagt till nycklar.  Poster i ordlistan kommer "
"att kasseras när det inte längre finns någon stark referens till nyckeln.  "
"Detta kan användas för att associera ytterligare data med ett objekt som ägs "
"av andra delar av en applikation utan att lägga till attribut till dessa "
"objekt.  Detta kan vara särskilt användbart med objekt som åsidosätter "
"attributåtkomst."

msgid ""
"Note that when a key with equal value to an existing key (but not equal "
"identity) is inserted into the dictionary, it replaces the value but does "
"not replace the existing key. Due to this, when the reference to the "
"original key is deleted, it also deletes the entry in the dictionary::"
msgstr ""
"Observera att när en nyckel med samma värde som en befintlig nyckel (men "
"inte samma identitet) infogas i ordlistan ersätter den värdet men inte den "
"befintliga nyckeln. När referensen till den ursprungliga nyckeln raderas, "
"raderas därför även posten i ordlistan::"

msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> d[k2] = 2   # d = {k1: 2}\n"
">>> del k1      # d = {}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1 # d = {k1: 1}\n"
"d[k2] = 2 # d = {k1: 2} >>> d[k2] = 2 # d = {k1: 2}\n"
">>> del k1 # d = {}"

msgid "A workaround would be to remove the key prior to reassignment::"
msgstr "En lösning skulle vara att ta bort nyckeln före omplaceringen::"

msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2   # d = {k2: 2}\n"
">>> del k1      # d = {k2: 2}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1 # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2 # d = {k2: 2} >>> del k1 # d = {k1: 1} >>> del k1\n"
">>> del k1 # d = {k2: 2}"

msgid ""
"Added support for ``|`` and ``|=`` operators, as specified in :pep:`584`."
msgstr ""
"Lagt till stöd för operatorerna ``|`` och ``|=``, enligt specifikation i :"
"pep:`584`."

msgid ""
":class:`WeakKeyDictionary` objects have an additional method that exposes "
"the internal references directly.  The references are not guaranteed to be "
"\"live\" at the time they are used, so the result of calling the references "
"needs to be checked before being used.  This can be used to avoid creating "
"references that will cause the garbage collector to keep the keys around "
"longer than needed."
msgstr ""
":class:`WeakKeyDictionary`-objekt har en extra metod som exponerar de "
"interna referenserna direkt.  Det är inte säkert att referenserna är "
"\"live\" när de används, så resultatet av att anropa referenserna måste "
"kontrolleras innan de används.  Detta kan användas för att undvika att skapa "
"referenser som gör att garbage collector behåller nycklarna längre än "
"nödvändigt."

msgid "Return an iterable of the weak references to the keys."
msgstr "Returnerar en iterabel av de svaga referenserna till nycklarna."

msgid ""
"Mapping class that references values weakly.  Entries in the dictionary will "
"be discarded when no strong reference to the value exists any more."
msgstr ""
"Mappningsklass som refererar svagt till värden.  Poster i ordlistan kommer "
"att kasseras när det inte längre finns någon stark referens till värdet."

msgid ""
":class:`WeakValueDictionary` objects have an additional method that has the "
"same issues as the :meth:`WeakKeyDictionary.keyrefs` method."
msgstr ""
":class:`WeakValueDictionary`-objekt har en ytterligare metod som har samma "
"problem som metoden :meth:`WeakKeyDictionary.keyrefs`."

msgid "Return an iterable of the weak references to the values."
msgstr "Returnerar en iterabel med svaga referenser till värdena."

msgid ""
"Set class that keeps weak references to its elements.  An element will be "
"discarded when no strong reference to it exists any more."
msgstr ""
"Set-klass som behåller svaga referenser till sina element.  Ett element "
"kasseras när det inte längre finns någon stark referens till det."

msgid ""
"A custom :class:`ref` subclass which simulates a weak reference to a bound "
"method (i.e., a method defined on a class and looked up on an instance). "
"Since a bound method is ephemeral, a standard weak reference cannot keep "
"hold of it.  :class:`WeakMethod` has special code to recreate the bound "
"method until either the object or the original function dies::"
msgstr ""
"En anpassad :class:`ref`-underklass som simulerar en svag referens till en "
"bunden metod (dvs. en metod som definieras i en klass och söks upp i en "
"instans). Eftersom en bunden metod är flyktig kan en vanlig svag referens "
"inte hålla fast vid den. :class:`WeakMethod` har specialkod för att "
"återskapa den bundna metoden tills antingen objektet eller den ursprungliga "
"funktionen dör:"

msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"
msgstr ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"

msgid ""
"*callback* is the same as the parameter of the same name to the :func:`ref` "
"function."
msgstr ""
"*callback* är samma som parametern med samma namn till funktionen :func:"
"`ref`."

msgid ""
"Return a callable finalizer object which will be called when *obj* is "
"garbage collected. Unlike an ordinary weak reference, a finalizer will "
"always survive until the reference object is collected, greatly simplifying "
"lifecycle management."
msgstr ""
"Returnerar ett anropbart finalizer-objekt som kommer att anropas när *obj* "
"samlas in. Till skillnad från en vanlig svag referens kommer en finalizer "
"alltid att överleva tills referensobjektet samlas in, vilket förenklar "
"livscykelhanteringen avsevärt."

msgid ""
"A finalizer is considered *alive* until it is called (either explicitly or "
"at garbage collection), and after that it is *dead*.  Calling a live "
"finalizer returns the result of evaluating ``func(*arg, **kwargs)``, whereas "
"calling a dead finalizer returns :const:`None`."
msgstr ""
"En finalizer anses vara *alive* tills den anropas (antingen explicit eller "
"vid garbage collection), och efter det är den *dead*.  Anrop av en levande "
"finalizer returnerar resultatet av utvärderingen av ``func(*arg, "
"**kwargs)``, medan anrop av en död finalizer returnerar :const:`None`."

msgid ""
"Exceptions raised by finalizer callbacks during garbage collection will be "
"shown on the standard error output, but cannot be propagated.  They are "
"handled in the same way as exceptions raised from an object's :meth:`~object."
"__del__` method or a weak reference's callback."
msgstr ""
"Undantag som orsakas av finalizer callbacks under garbage collection visas "
"på standardfelutmatningen, men kan inte spridas vidare.  De hanteras på "
"samma sätt som undantag som orsakas av ett objekts :meth:`~object.__del__`-"
"metod eller en svag referenss återkallelse."

msgid ""
"When the program exits, each remaining live finalizer is called unless its :"
"attr:`atexit` attribute has been set to false.  They are called in reverse "
"order of creation."
msgstr ""
"När programmet avslutas anropas varje kvarvarande live finalizer om inte "
"dess attribut :attr:`atexit` har satts till false.  De anropas i omvänd "
"ordning efter att de skapats."

msgid ""
"A finalizer will never invoke its callback during the later part of the :"
"term:`interpreter shutdown` when module globals are liable to have been "
"replaced by :const:`None`."
msgstr ""
"En finalizer kommer aldrig att anropa sitt callback under den senare delen "
"av :term:`tolkavstängningen` när modulglobaler kan ha ersatts av :const:"
"`None`."

msgid ""
"If *self* is alive then mark it as dead and return the result of calling "
"``func(*args, **kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"Om *self* är levande markeras den som död och resultatet av anropet "
"``func(*args, **kwargs)`` returneras.  Om *self* är död returneras :const:"
"`None`."

msgid ""
"If *self* is alive then mark it as dead and return the tuple ``(obj, func, "
"args, kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"Om *self* är levande markeras den som död och tupeln ``(obj, func, args, "
"kwargs)`` returneras.  Om *self* är död returneras :const:`None`."

msgid ""
"If *self* is alive then return the tuple ``(obj, func, args, kwargs)``.  If "
"*self* is dead then return :const:`None`."
msgstr ""
"Om *self* är vid liv returneras tupeln ``(obj, func, args, kwargs)``.  Om "
"*self* är död returneras :const:`None`."

msgid "Property which is true if the finalizer is alive, false otherwise."
msgstr "Egenskap som är sann om finalizer är levande, annars falsk."

msgid ""
"A writable boolean property which by default is true.  When the program "
"exits, it calls all remaining live finalizers for which :attr:`.atexit` is "
"true.  They are called in reverse order of creation."
msgstr ""
"En skrivbar boolesk egenskap som som standard är true.  När programmet "
"avslutas anropas alla återstående live finalizers för vilka :attr:`.atexit` "
"är true.  De anropas i omvänd ordning efter att de skapats."

msgid ""
"It is important to ensure that *func*, *args* and *kwargs* do not own any "
"references to *obj*, either directly or indirectly, since otherwise *obj* "
"will never be garbage collected.  In particular, *func* should not be a "
"bound method of *obj*."
msgstr ""
"Det är viktigt att se till att *func*, *args* och *kwargs* inte äger några "
"referenser till *obj*, varken direkt eller indirekt, eftersom *obj* annars "
"aldrig kommer att garbage collectas.  I synnerhet bör *func* inte vara en "
"bunden metod till *obj*."

msgid "The type object for weak references objects."
msgstr "Typobjektet för objekt med svaga referenser."

msgid "The type object for proxies of objects which are not callable."
msgstr "Typobjektet för proxies av objekt som inte är anropsbara."

msgid "The type object for proxies of callable objects."
msgstr "Typobjektet för proxyer av anropsbara objekt."

msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming "
"both proxy types."
msgstr ""
"Sekvens som innehåller alla typobjekt för proxy.  Detta kan göra det enklare "
"att testa om ett objekt är en proxy utan att vara beroende av att namnge "
"båda proxytyperna."

msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - Svaga referenser"

msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other languages."
msgstr ""
"Förslaget och motiveringen till den här funktionen, inklusive länkar till "
"tidigare implementeringar och information om liknande funktioner i andra "
"språk."

msgid "Weak Reference Objects"
msgstr "Svaga referensobjekt"

msgid ""
"Weak reference objects have no methods and no attributes besides :attr:`ref."
"__callback__`. A weak reference object allows the referent to be obtained, "
"if it still exists, by calling it:"
msgstr ""
"Svaga referensobjekt har inga metoder och inga attribut förutom :attr:`ref."
"__callback__`. Ett svagt referensobjekt gör att referenten kan erhållas, om "
"den fortfarande finns, genom att anropa det:"

msgid ""
"If the referent no longer exists, calling the reference object returns :"
"const:`None`:"
msgstr ""
"Om referenten inte längre finns, returneras :const:`None` när "
"referensobjektet anropas:"

msgid ""
"Testing that a weak reference object is still live should be done using the "
"expression ``ref() is not None``.  Normally, application code that needs to "
"use a reference object should follow this pattern::"
msgstr ""
"Testning av att ett svagt referensobjekt fortfarande är aktivt bör göras med "
"hjälp av uttrycket ``ref() is not None``.  Normalt bör applikationskod som "
"behöver använda ett referensobjekt följa detta mönster::"

msgid ""
"# r is a weak reference object\n"
"o = r()\n"
"if o is None:\n"
"    # referent has been garbage collected\n"
"    print(\"Object has been deallocated; can't frobnicate.\")\n"
"else:\n"
"    print(\"Object is still live!\")\n"
"    o.do_something_useful()"
msgstr ""
"# r är ett svagt referensobjekt\n"
"o = r()\n"
"om o är None:\n"
"    # referensen har blivit skräpinsamlad\n"
"    print(\"Objektet har avallokerats; kan inte frobnisera.\")\n"
"else:\n"
"    print(\"Objektet är fortfarande levande!\")\n"
"    o.gör_något_nyttigt()"

msgid ""
"Using a separate test for \"liveness\" creates race conditions in threaded "
"applications; another thread can cause a weak reference to become "
"invalidated before the weak reference is called; the idiom shown above is "
"safe in threaded applications as well as single-threaded applications."
msgstr ""
"Att använda ett separat test för \"liveness\" skapar tävlingsförhållanden i "
"gängade applikationer; en annan tråd kan orsaka att en svag referens blir "
"ogiltig innan den svaga referensen anropas; idiomet som visas ovan är säkert "
"i gängade applikationer såväl som i enkeltrådade applikationer."

msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the :class:"
"`WeakValueDictionary` to reduce the memory overhead for each entry in the "
"mapping.  This may be most useful to associate additional information with a "
"reference, but could also be used to insert additional processing on calls "
"to retrieve the referent."
msgstr ""
"Specialiserade versioner av :class:`ref`-objekt kan skapas genom "
"subklassning. Detta används i implementeringen av :class:"
"`WeakValueDictionary` för att minska minneskostnaden för varje post i "
"mappningen.  Detta kan vara mest användbart för att associera ytterligare "
"information med en referens, men kan också användas för att infoga "
"ytterligare bearbetning vid anrop för att hämta referensen."

msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's returned "
"when the referent is accessed::"
msgstr ""
"Detta exempel visar hur en subklass av :class:`ref` kan användas för att "
"lagra ytterligare information om ett objekt och påverka det värde som "
"returneras när referenten anropas::"

msgid ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"Return a pair containing the referent and the number of\n"
"        times the reference has been called.\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"
msgstr ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"Return a pair containing the referent and the number of\n"
"        times the reference has been called.\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"

msgid "Example"
msgstr "Exempel"

msgid ""
"This simple example shows how an application can use object IDs to retrieve "
"objects that it has seen before.  The IDs of the objects can then be used in "
"other data structures without forcing the objects to remain alive, but the "
"objects can still be retrieved by ID if they do."
msgstr ""
"Detta enkla exempel visar hur en applikation kan använda objekt-ID:n för att "
"hämta objekt som den har sett förut.  Objektens ID:n kan sedan användas i "
"andra datastrukturer utan att objekten tvingas leva vidare, men om de gör "
"det kan de ändå hämtas via ID."

msgid ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"
msgstr ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"

msgid "Finalizer Objects"
msgstr "Finalizer-objekt"

msgid ""
"The main benefit of using :class:`finalize` is that it makes it simple to "
"register a callback without needing to preserve the returned finalizer "
"object.  For instance"
msgstr ""
"Den största fördelen med att använda :class:`finalize` är att det gör det "
"enkelt att registrera en callback utan att behöva bevara det returnerade "
"finalizer-objektet.  Exempelvis"

msgid ""
"The finalizer can be called directly as well.  However the finalizer will "
"invoke the callback at most once."
msgstr ""
"Finalizer kan också anropas direkt.  Finalizern kommer dock att anropa "
"callbacken högst en gång."

msgid ""
"You can unregister a finalizer using its :meth:`~finalize.detach` method.  "
"This kills the finalizer and returns the arguments passed to the constructor "
"when it was created."
msgstr ""
"Du kan avregistrera en finalizer med hjälp av dess :meth:`~finalize.detach`-"
"metod.  Detta dödar finalizern och returnerar de argument som skickades till "
"konstruktören när den skapades."

msgid ""
"Unless you set the :attr:`~finalize.atexit` attribute to :const:`False`, a "
"finalizer will be called when the program exits if it is still alive.  For "
"instance"
msgstr ""
"Om du inte sätter attributet :attr:`~finalize.atexit` till :const:`False`, "
"kommer en finalizer att anropas när programmet avslutas om det fortfarande "
"är vid liv.  Exempelvis"

msgid ""
">>> obj = Object()\n"
">>> weakref.finalize(obj, print, \"obj dead or exiting\")\n"
"<finalize object at ...; for 'Object' at ...>\n"
">>> exit()\n"
"obj dead or exiting"
msgstr ""
">>> obj = Objekt()\n"
">>> weakref.finalize(obj, print, \"obj död eller avslutas\")\n"
"<finalize object at ...; for 'Object' at ...> >>> exit()\n"
">>> exit()\n"
"obj död eller lämnar"

msgid "Comparing finalizers with :meth:`~object.__del__` methods"
msgstr "Jämförelse av finalizers med :meth:`~object.__del__`-metoder"

msgid ""
"Suppose we want to create a class whose instances represent temporary "
"directories.  The directories should be deleted with their contents when the "
"first of the following events occurs:"
msgstr ""
"Antag att vi vill skapa en klass vars instanser representerar tillfälliga "
"kataloger.  Katalogerna ska raderas med sitt innehåll när den första av "
"följande händelser inträffar:"

msgid "the object is garbage collected,"
msgstr "objektet är skräpinsamlat,"

msgid "the object's :meth:`!remove` method is called, or"
msgstr "objektets :meth:`!remove`-metod anropas, eller"

msgid "the program exits."
msgstr "avslutas programmet."

msgid ""
"We might try to implement the class using a :meth:`~object.__del__` method "
"as follows::"
msgstr ""
"Vi kan försöka implementera klassen med hjälp av en :meth:`~object.__del__`-"
"metod enligt följande::"

msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"

msgid ""
"Starting with Python 3.4, :meth:`~object.__del__` methods no longer prevent "
"reference cycles from being garbage collected, and module globals are no "
"longer forced to :const:`None` during :term:`interpreter shutdown`. So this "
"code should work without any issues on CPython."
msgstr ""
"Från och med Python 3.4 förhindrar inte längre :meth:`~object.__del__`-"
"metoder att referenscykler garbage-samlas, och modulglobaler tvingas inte "
"längre till :const:`None` under :term:`interpreter shutdown`. Så den här "
"koden bör fungera utan problem på CPython."

msgid ""
"However, handling of :meth:`~object.__del__` methods is notoriously "
"implementation specific, since it depends on internal details of the "
"interpreter's garbage collector implementation."
msgstr ""
"Hanteringen av :meth:`~object.__del__`-metoder är dock notoriskt "
"implementationsspecifik, eftersom den beror på interna detaljer i tolkens "
"garbage collector-implementation."

msgid ""
"A more robust alternative can be to define a finalizer which only references "
"the specific functions and objects that it needs, rather than having access "
"to the full state of the object::"
msgstr ""
"Ett mer robust alternativ kan vara att definiera en finalizer som bara "
"refererar till de specifika funktioner och objekt som den behöver, i stället "
"för att ha tillgång till objektets fullständiga tillstånd:"

msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"

msgid ""
"Defined like this, our finalizer only receives a reference to the details it "
"needs to clean up the directory appropriately. If the object never gets "
"garbage collected the finalizer will still be called at exit."
msgstr ""
"Definierad på det här sättet får vår finalizer bara en referens till de "
"detaljer den behöver för att städa upp katalogen på lämpligt sätt. Om "
"objektet aldrig blir skräpinsamlat kommer finalizern fortfarande att anropas "
"vid avslut."

msgid ""
"The other advantage of weakref based finalizers is that they can be used to "
"register finalizers for classes where the definition is controlled by a "
"third party, such as running code when a module is unloaded::"
msgstr ""
"Den andra fördelen med weakref-baserade finalizers är att de kan användas "
"för att registrera finalizers för klasser där definitionen styrs av en "
"tredje part, t.ex. att köra kod när en modul avlastas:"

msgid ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # implicit reference to the module globals from the function body\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"
msgstr ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # implicit referens till modulens globaler från funktionskroppen\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"

msgid ""
"If you create a finalizer object in a daemonic thread just as the program "
"exits then there is the possibility that the finalizer does not get called "
"at exit.  However, in a daemonic thread :func:`atexit.register`, ``try: ... "
"finally: ...`` and ``with: ...`` do not guarantee that cleanup occurs either."
msgstr ""
"Om du skapar ett finalizer-objekt i en daemonisk tråd precis när programmet "
"avslutas finns det en möjlighet att finalizern inte anropas vid "
"avslutningen.  Men i en daemonisk tråd :func:`atexit.register`, ``try: ... "
"finally: ...`` och ``with: ...`` inte heller garantera att upprensning sker."
