# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Exception Handling"
msgstr "Hantering av undantag"

msgid ""
"The functions described in this chapter will let you handle and raise Python "
"exceptions.  It is important to understand some of the basics of Python "
"exception handling.  It works somewhat like the POSIX :c:data:`errno` "
"variable: there is a global indicator (per thread) of the last error that "
"occurred.  Most C API functions don't clear this on success, but will set it "
"to indicate the cause of the error on failure.  Most C API functions also "
"return an error indicator, usually ``NULL`` if they are supposed to return a "
"pointer, or ``-1`` if they return an integer (exception: the ``PyArg_*`` "
"functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"De funktioner som beskrivs i detta kapitel låter dig hantera och skapa "
"Python-undantag.  Det är viktigt att förstå några av grunderna i Pythons "
"undantagshantering.  Det fungerar ungefär som POSIX :c:data:`errno`-"
"variabeln: det finns en global indikator (per tråd) för det senaste felet "
"som inträffade.  De flesta C API-funktioner rensar inte detta vid framgång, "
"men kommer att ställa in det för att ange orsaken till felet vid "
"misslyckande.  De flesta C API-funktioner returnerar också en felindikator, "
"vanligtvis ``NULL`` om de ska returnera en pekare, eller ``-1`` om de "
"returnerar ett heltal (undantag: funktionerna ``PyArg_*`` returnerar ``1`` "
"vid framgång och ``0`` vid misslyckande)."

msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any of "
"those pointers can be ``NULL`` if non-set (although some combinations are "
"forbidden, for example you can't have a non-``NULL`` traceback if the "
"exception type is ``NULL``)."
msgstr ""
"Konkret består felindikatorn av tre objektpekare: undantagets typ, "
"undantagets värde och traceback-objektet.  Vilken som helst av dessa pekare "
"kan vara ``NULL`` om den inte är inställd (även om vissa kombinationer är "
"förbjudna, till exempel kan du inte ha en traceback som inte är ``NULL`` om "
"undantagstypen är ``NULL``)."

msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already "
"set it.  It is responsible for either handling the error and clearing the "
"exception or returning after cleaning up any resources it holds (such as "
"object references or memory allocations); it should *not* continue normally "
"if it is not prepared to handle the error.  If returning due to an error, it "
"is important to indicate to the caller that an error has been set.  If the "
"error is not handled or carefully propagated, additional calls into the "
"Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"När en funktion måste misslyckas på grund av att någon funktion som den "
"anropade misslyckades, sätter den i allmänhet inte felindikatorn; den "
"funktion som den anropade har redan satt den.  Den är ansvarig för att "
"antingen hantera felet och rensa undantaget eller återvända efter att ha "
"rensat upp alla resurser den har (t.ex. objektreferenser eller "
"minnesallokeringar); den ska *inte* fortsätta normalt om den inte är beredd "
"att hantera felet.  Om den återvänder på grund av ett fel är det viktigt att "
"ange för den som anropar att ett fel har uppstått.  Om felet inte hanteras "
"eller sprids på ett noggrant sätt kan det hända att ytterligare anrop till "
"Python/C API:et inte beter sig som avsett och misslyckas på mystiska sätt."

msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info`. The "
"former corresponds to an exception that is not yet caught (and is therefore "
"still propagating), while the latter returns an exception after it is caught "
"(and has therefore stopped propagating)."
msgstr ""
"Felindikatorn är **inte** resultatet av :func:`sys.exc_info`. Det "
"förstnämnda motsvarar ett undantag som ännu inte har fångats upp (och som "
"därför fortfarande sprids), medan det sistnämnda returnerar ett undantag "
"efter att det har fångats upp (och därför har slutat spridas)."

msgid "Printing and clearing"
msgstr "Tryckning och clearing"

msgid ""
"Clear the error indicator.  If the error indicator is not set, there is no "
"effect."
msgstr ""
"Rensa felindikatorn.  Om felindikatorn inte är inställd har det ingen effekt."

msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error indicator. "
"**Unless** the error is a ``SystemExit``, in that case no traceback is "
"printed and the Python process will exit with the error code specified by "
"the ``SystemExit`` instance."
msgstr ""
"Skriver ut en standardspårning till ``sys.stderr`` och rensar felindikatorn. "
"**Om** felet inte är ett ``SystemExit``, i så fall skrivs ingen spårning ut "
"och Python-processen avslutas med den felkod som anges av ``SystemExit``-"
"instansen."

msgid ""
"Call this function **only** when the error indicator is set.  Otherwise it "
"will cause a fatal error!"
msgstr ""
"Anropa denna funktion **endast** när felindikatorn är inställd.  Annars "
"kommer den att orsaka ett dödligt fel!"

msgid ""
"If *set_sys_last_vars* is nonzero, the variable :data:`sys.last_exc` is set "
"to the printed exception. For backwards compatibility, the deprecated "
"variables :data:`sys.last_type`, :data:`sys.last_value` and :data:`sys."
"last_traceback` are also set to the type, value and traceback of this "
"exception, respectively."
msgstr ""
"Om *set_sys_last_vars* inte är noll, sätts variabeln :data:`sys.last_exc` "
"till det utskrivna undantaget. För bakåtkompatibilitet sätts även de "
"föråldrade variablerna :data:`sys.last_type`, :data:`sys.last_value` och :"
"data:`sys.last_traceback` till typ, värde respektive traceback för detta "
"undantag."

msgid "The setting of :data:`sys.last_exc` was added."
msgstr "Inställningen :data:`sys.last_exc` har lagts till."

msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "Alias för ``PyErr_PrintEx(1)``."

msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr ""
"Anropa :func:`sys.unraisablehook` med aktuellt undantag och *obj*-argument."

msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to actually "
"raise the exception.  It is used, for example, when an exception occurs in "
"an :meth:`~object.__del__` method."
msgstr ""
"Den här funktionen skriver ut ett varningsmeddelande till ``sys.stderr`` när "
"ett undantag har ställts in men det är omöjligt för tolken att faktiskt lösa "
"ut undantaget.  Den används t.ex. när ett undantag inträffar i en :meth:"
"`~object.__del__`-metod."

msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr of "
"*obj* will be printed in the warning message. If *obj* is ``NULL``, only the "
"traceback is printed."
msgstr ""
"Funktionen anropas med ett enda argument *obj* som identifierar det "
"sammanhang där det ovärderliga undantaget inträffade. Om möjligt skrivs repr "
"av *obj* ut i varningsmeddelandet. Om *obj* är ``NULL`` skrivs endast "
"spårningen ut."

msgid "An exception must be set when calling this function."
msgstr "Ett undantag måste ställas in när denna funktion anropas."

msgid "Print a traceback. Print only traceback if *obj* is ``NULL``."
msgstr ""
"Skriv ut en spårning. Skriv endast ut en återgång om *obj* är ``NULL``."

msgid "Use :func:`sys.unraisablehook`."
msgstr "Använd :func:`sys.unraisablehook`."

msgid ""
"Similar to :c:func:`PyErr_WriteUnraisable`, but the *format* and subsequent "
"parameters help format the warning message; they have the same meaning and "
"values as in :c:func:`PyUnicode_FromFormat`. ``PyErr_WriteUnraisable(obj)`` "
"is roughly equivalent to ``PyErr_FormatUnraisable(\"Exception ignored in: "
"%R\", obj)``. If *format* is ``NULL``, only the traceback is printed."
msgstr ""
"Liknar :c:func:`PyErr_WriteUnraisable`, men *format* och efterföljande "
"parametrar hjälper till att formatera varningsmeddelandet; de har samma "
"betydelse och värden som i :c:func:`PyUnicode_FromFormat`. "
"``PyErr_WriteUnraisable(obj)`` är ungefär likvärdigt med "
"``PyErr_FormatUnraisable(\"Exception ignored in: %R\", obj)``. Om *format* "
"är ``NULL`` skrivs endast spårningen ut."

msgid ""
"Print the standard traceback display of ``exc`` to ``sys.stderr``, including "
"chained exceptions and notes."
msgstr ""
"Skriv ut standardspårningsvisningen av ``exc`` till ``sys.stderr``, "
"inklusive kedjade undantag och anteckningar."

msgid "Raising exceptions"
msgstr "Upprättande av undantag"

msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` pointer "
"for use in a ``return`` statement."
msgstr ""
"Dessa funktioner hjälper dig att ställa in den aktuella trådens "
"felindikator. För enkelhetens skull kommer vissa av dessa funktioner alltid "
"att returnera en ``NULL``-pekare för användning i en ``return``-sats."

msgid ""
"This is the most common way to set the error indicator.  The first argument "
"specifies the exception type; it is normally one of the standard exceptions, "
"e.g. :c:data:`PyExc_RuntimeError`.  You need not create a new :term:`strong "
"reference` to it (e.g. with :c:func:`Py_INCREF`). The second argument is an "
"error message; it is decoded from ``'utf-8'``."
msgstr ""
"Detta är det vanligaste sättet att ställa in felindikatorn.  Det första "
"argumentet anger undantagstypen; det är normalt ett av standardundantagen, t."
"ex. :c:data:`PyExc_RuntimeError`.  Du behöver inte skapa en ny :term:`strong "
"reference` till den (t.ex. med :c:func:`Py_INCREF`). Det andra argumentet är "
"ett felmeddelande; det avkodas från ``'utf-8'``."

msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you specify "
"an arbitrary Python object for the \"value\" of the exception."
msgstr ""
"Den här funktionen liknar :c:func:`PyErr_SetString` men låter dig ange ett "
"godtyckligt Python-objekt som \"värde\" för undantaget."

msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception* "
"should be a Python exception class.  The *format* and subsequent parameters "
"help format the error message; they have the same meaning and values as in :"
"c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded string."
msgstr ""
"Denna funktion anger felindikatorn och returnerar ``NULL``.  *exception* bör "
"vara en Python exception-klass.  Parametrarna *format* och följande hjälper "
"till att formatera felmeddelandet; de har samma betydelse och värden som i :"
"c:func:`PyUnicode_FromFormat`. *format* är en ASCII-kodad sträng."

msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr ""
"Samma som :c:func:`PyErr_Format`, men tar ett :c:type:`va_list`-argument i "
"stället för ett variabelt antal argument."

msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "Detta är en förkortning för ``PyErr_SetObject(type, Py_None)``."

msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, where "
"*message* indicates that a built-in operation was invoked with an illegal "
"argument.  It is mostly for internal use."
msgstr ""
"Detta är en förkortning för ``PyErr_SetString(PyExc_TypeError, message)``, "
"där *message* anger att en inbyggd operation anropades med ett olagligt "
"argument.  Den är mestadels för internt bruk."

msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"Detta är en förkortning för ``PyErr_SetNone(PyExc_MemoryError)``; den "
"returnerar ``NULL`` så att en objektallokeringsfunktion kan skriva ``return "
"PyErr_NoMemory();`` när den har slut på minne."

msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  It "
"constructs a tuple object whose first item is the integer :c:data:`errno` "
"value and whose second item is the corresponding error message (gotten from :"
"c:func:`!strerror`), and then calls ``PyErr_SetObject(type, object)``.  On "
"Unix, when the :c:data:`errno` value is :c:macro:`!EINTR`, indicating an "
"interrupted system call, this calls :c:func:`PyErr_CheckSignals`, and if "
"that set the error indicator, leaves it set to that.  The function always "
"returns ``NULL``, so a wrapper function around a system call can write "
"``return PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""
"Detta är en bekvämlighetsfunktion för att skapa ett undantag när en C-"
"biblioteksfunktion har returnerat ett fel och satt C-variabeln :c:data:"
"`errno`.  Den konstruerar ett tuple-objekt vars första post är heltalet :c:"
"data:`errno`-värdet och vars andra post är motsvarande felmeddelande (hämtat "
"från :c:func:`!strerror`), och anropar sedan ``PyErr_SetObject(type, "
"object)``.  På Unix, när :c:data:`errno`-värdet är :c:macro:`!EINTR`, vilket "
"indikerar ett avbrutet systemanrop, anropas :c:func:`PyErr_CheckSignals`, "
"och om det ställde in felindikatorn, lämnas den inställd på det.  Funktionen "
"returnerar alltid ``NULL``, så en wrapperfunktion runt ett systemanrop kan "
"skriva ``return PyErr_SetFromErrno(type);`` när systemanropet returnerar ett "
"fel."

msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that "
"if *filenameObject* is not ``NULL``, it is passed to the constructor of "
"*type* as a third parameter.  In the case of :exc:`OSError` exception, this "
"is used to define the :attr:`!filename` attribute of the exception instance."
msgstr ""
"Liknar :c:func:`PyErr_SetFromErrno`, med det ytterligare beteendet att om "
"*filenameObject* inte är ``NULL``, skickas det till konstruktören av *type* "
"som en tredje parameter.  I fallet med :exc:`OSError` undantag, används "
"detta för att definiera :attr:`!filename` attributet för undantagsinstansen."

msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two "
"filenames fails."
msgstr ""
"Liknar :c:func:`PyErr_SetFromErrnoWithFilenameObject`, men tar ett andra "
"filnamnsobjekt, för att skapa fel när en funktion som tar två filnamn "
"misslyckas."

msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the filename "
"is given as a C string.  *filename* is decoded from the :term:`filesystem "
"encoding and error handler`."
msgstr ""
"Liknar :c:func:`PyErr_SetFromErrnoWithFilenameObject`, men filnamnet anges "
"som en C-sträng.  *filename* är avkodad från :term:`filsystemets kodning och "
"felhantering`."

msgid ""
"This is a convenience function to raise :exc:`OSError`. If called with "
"*ierr* of ``0``, the error code returned by a call to :c:func:`!"
"GetLastError` is used instead.  It calls the Win32 function :c:func:`!"
"FormatMessage` to retrieve the Windows description of error code given by "
"*ierr* or :c:func:`!GetLastError`, then it constructs a :exc:`OSError` "
"object with the :attr:`~OSError.winerror` attribute set to the error code, "
"the :attr:`~OSError.strerror` attribute set to the corresponding error "
"message (gotten from :c:func:`!FormatMessage`), and then calls "
"``PyErr_SetObject(PyExc_OSError, object)``. This function always returns "
"``NULL``."
msgstr ""
"Detta är en bekvämlighetsfunktion för att skapa :exc:`OSError`. Om den "
"anropas med *ierr* på ``0`` används istället den felkod som returneras av "
"ett anrop till :c:func:`!GetLastError`.  Den anropar Win32-funktionen :c:"
"func:`!FormatMessage` för att hämta Windows-beskrivningen av felkoden som "
"ges av *ierr* eller :c:func:`!GetLastError`, och konstruerar sedan ett :exc:"
"`OSError`-objekt med attributet :attr:`~OSError.winerror`-attributet satt "
"till felkoden, :attr:`~OSError.strerror`-attributet satt till motsvarande "
"felmeddelande (hämtat från :c:func:`!FormatMessage`), och anropar sedan "
"``PyErr_SetObject(PyExc_OSError, object)``. Denna funktion returnerar alltid "
"``NULL``."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional parameter "
"specifying the exception type to be raised."
msgstr ""
"Liknar :c:func:`PyErr_SetFromWindowsErr`, med en ytterligare parameter som "
"anger vilken typ av undantag som ska tas upp."

msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with the additional behavior "
"that if *filename* is not ``NULL``, it is decoded from the filesystem "
"encoding (:func:`os.fsdecode`) and passed to the constructor of :exc:"
"`OSError` as a third parameter to be used to define the :attr:`!filename` "
"attribute of the exception instance."
msgstr ""
"Liknar :c:func:`PyErr_SetFromWindowsErr`, med det ytterligare beteendet att "
"om *filnamn* inte är ``NULL``, avkodas det från filsystemets kodning (:func:"
"`os.fsdecode`) och skickas till konstruktören av :exc:`OSError` som en "
"tredje parameter som används för att definiera attributet :attr:`!filnamn` "
"för undantagsinstansen."

msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErr`, with the additional "
"behavior that if *filename* is not ``NULL``, it is passed to the constructor "
"of :exc:`OSError` as a third parameter to be used to define the :attr:`!"
"filename` attribute of the exception instance."
msgstr ""
"Liknar :c:func:`PyErr_SetExcFromWindowsErr`, med det ytterligare beteendet "
"att om *filnamn* inte är ``NULL``, skickas det till konstruktören av :exc:"
"`OSError` som en tredje parameter som används för att definiera attributet :"
"attr:`!filnamn` för undantagsinstansen."

msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"Liknar :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, men "
"accepterar ett andra filnamnsobjekt."

msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an additional "
"parameter specifying the exception type to be raised."
msgstr ""
"Liknar :c:func:`PyErr_SetFromWindowsErrWithFilename`, med en ytterligare "
"parameter som anger vilken typ av undantag som ska tas upp."

msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be "
"set as the exception's message string. *name* and *path*, both of which can "
"be ``NULL``, will be set as the :exc:`ImportError`'s respective ``name`` and "
"``path`` attributes."
msgstr ""
"Detta är en bekvämlighetsfunktion för att skapa :exc:`ImportError`. *msg* "
"kommer att sättas som undantagets meddelandesträng. *name* och *path*, som "
"båda kan vara ``NULL``, kommer att anges som :exc:`ImportError`'s respektive "
"attribut ``name`` och ``path``."

msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"Ungefär som :c:func:`PyErr_SetImportError` men den här funktionen gör det "
"möjligt att ange en underklass av :exc:`ImportError` som ska uppstå."

msgid ""
"Set file, line, and offset information for the current exception.  If the "
"current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the exception "
"is a :exc:`SyntaxError`."
msgstr ""
"Ställer in fil-, rad- och offsetinformation för det aktuella undantaget.  Om "
"det aktuella undantaget inte är ett :exc:`SyntaxError`, anges ytterligare "
"attribut som får subsystemet för utskrift av undantag att tro att undantaget "
"är ett :exc:`SyntaxError`."

msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte string "
"decoded from the :term:`filesystem encoding and error handler`."
msgstr ""
"Som :c:func:`PyErr_SyntaxLocationObject`, men *filnamn* är en byte-sträng "
"avkodad från :term:`filsystemets kodning och felhantering`."

msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the *col_offset* parameter is "
"omitted."
msgstr ""
"Som :c:func:`PyErr_SyntaxLocationEx`, men parametern *col_offset* är "
"utelämnad."

msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API "
"function) was invoked with an illegal argument.  It is mostly for internal "
"use."
msgstr ""
"Detta är en förkortning för ``PyErr_SetString(PyExc_SystemError, message)``, "
"där *message* indikerar att en intern operation (t.ex. en Python/C API-"
"funktion) anropades med ett olagligt argument.  Den är mestadels för internt "
"bruk."

msgid "Issuing warnings"
msgstr "Utfärdande av varningar"

msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible that "
"the user has specified that warnings are to be turned into errors, and in "
"that case they will raise an exception.  It is also possible that the "
"functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1`` if "
"an exception is raised.  (It is not possible to determine whether a warning "
"message is actually printed, nor what the reason is for the exception; this "
"is intentional.)  If an exception is raised, the caller should do its normal "
"exception handling (for example, :c:func:`Py_DECREF` owned references and "
"return an error value)."
msgstr ""
"Använd dessa funktioner för att utfärda varningar från C-kod.  De speglar "
"liknande funktioner som exporteras av Python :mod:`warnings`-modulen.  De "
"skriver normalt ut ett varningsmeddelande till *sys.stderr*, men det är "
"också möjligt att användaren har angett att varningar ska omvandlas till "
"fel, och i så fall kommer de att ge upphov till ett undantag.  Det är också "
"möjligt att funktionerna ger upphov till ett undantag på grund av ett "
"problem med varningsmaskineriet. Returvärdet är ``0`` om inget undantag "
"uppstår, eller ``-1`` om ett undantag uppstår.  (Det är inte möjligt att "
"avgöra om ett varningsmeddelande faktiskt skrivs ut eller vad orsaken till "
"undantaget är; detta är avsiktligt)  Om ett undantag uppstår bör anroparen "
"göra sin normala undantagshantering (t.ex. :c:func:`Py_DECREF` äger "
"referenser och returnerar ett felvärde)."

msgid ""
"Issue a warning message.  The *category* argument is a warning category (see "
"below) or ``NULL``; the *message* argument is a UTF-8 encoded string.  "
"*stack_level* is a positive number giving a number of stack frames; the "
"warning will be issued from the  currently executing line of code in that "
"stack frame.  A *stack_level* of 1 is the function calling :c:func:"
"`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"Utfärdar ett varningsmeddelande.  Argumentet *category* är en "
"varningskategori (se nedan) eller ``NULL``; argumentet *message* är en UTF-8-"
"kodad sträng.  *stack_level* är ett positivt tal som anger ett antal "
"stackrutor; varningen kommer att utfärdas från den kodrad som för närvarande "
"körs i den stackrutan.  En *stack_level* på 1 är den funktion som anropar :c:"
"func:`PyErr_WarnEx`, 2 är funktionen ovanför den, och så vidare."

msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the default "
"warning category is :c:data:`PyExc_RuntimeWarning`. The standard Python "
"warning categories are available as global variables whose names are "
"enumerated at :ref:`standardwarningcategories`."
msgstr ""
"Varningskategorier måste vara subklasser av :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` är en subklass av :c:data:`PyExc_Exception`; "
"standardvarningskategorin är :c:data:`PyExc_RuntimeWarning`. Pythons "
"standardvarningskategorier finns tillgängliga som globala variabler vars "
"namn räknas upp på :ref:`standardwarningcategories`."

msgid ""
"For information about warning control, see the documentation for the :mod:"
"`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr ""
"Mer information om varningskontroll finns i dokumentationen för modulen :mod:"
"`warnings` och alternativet :option:`-W` i kommandoradsdokumentationen.  Det "
"finns inget C API för varningskontroll."

msgid ""
"Issue a warning message with explicit control over all warning attributes.  "
"This is a straightforward wrapper around the Python function :func:`warnings."
"warn_explicit`; see there for more information.  The *module* and *registry* "
"arguments may be set to ``NULL`` to get the default effect described there."
msgstr ""
"Utfärda ett varningsmeddelande med explicit kontroll över alla "
"varningsattribut.  Detta är en enkel omslutning av Python-funktionen :func:"
"`warnings.warn_explicit`; se där för mer information.  Argumenten *module* "
"och *registry* kan sättas till ``NULL`` för att få den förvalda effekten som "
"beskrivs där."

msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the :term:"
"`filesystem encoding and error handler`."
msgstr ""
"Liknar :c:func:`PyErr_WarnExplicitObject` förutom att *message* och *module* "
"är UTF-8-kodade strängar och *filename* är avkodad från :term:`filsystemets "
"kodning och felhantering`."

msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use :c:func:"
"`PyUnicode_FromFormat` to format the warning message.  *format* is an ASCII-"
"encoded string."
msgstr ""
"Funktion liknande :c:func:`PyErr_WarnEx`, men använd :c:func:"
"`PyUnicode_FromFormat` för att formatera varningsmeddelandet.  *format* är "
"en ASCII-kodad sträng."

msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is :exc:"
"`ResourceWarning` and it passes *source* to :class:`!warnings."
"WarningMessage`."
msgstr ""
"Funktion liknande :c:func:`PyErr_WarnFormat`, men *category* är :exc:"
"`ResourceWarning` och den skickar *source* till :class:`!warnings."
"WarningMessage`."

msgid "Querying the error indicator"
msgstr "Fråga efter felindikatorn"

msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the ``PyErr_Set*`` "
"functions or to :c:func:`PyErr_Restore`).  If not set, return ``NULL``.  You "
"do not own a reference to the return value, so you do not need to :c:func:"
"`Py_DECREF` it."
msgstr ""
"Testar om felindikatorn är inställd.  Om den är inställd, returneras "
"undantagets *typ* (det första argumentet till det senaste anropet till en av "
"funktionerna ``PyErr_Set*`` eller till :c:func:`PyErr_Restore``).  Om den "
"inte är inställd returneras ``NULL``.  Du äger inte en referens till "
"returvärdet, så du behöver inte :c:func:`Py_DECREF` det."

msgid "The caller must have an :term:`attached thread state`."
msgstr "Den som anropar måste ha en :term:`attached thread state`."

msgid ""
"Do not compare the return value to a specific exception; use :c:func:"
"`PyErr_ExceptionMatches` instead, shown below.  (The comparison could easily "
"fail since the exception may be an instance instead of a class, in the case "
"of a class exception, or it may be a subclass of the expected exception.)"
msgstr ""
"Jämför inte returvärdet med ett specifikt undantag; använd istället :c:func:"
"`PyErr_ExceptionMatches`, som visas nedan.  (Jämförelsen kan lätt misslyckas "
"eftersom undantaget kan vara en instans i stället för en klass, i fallet med "
"ett klassundantag, eller det kan vara en underklass av det förväntade "
"undantaget)"

msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This "
"should only be called when an exception is actually set; a memory access "
"violation will occur if no exception has been raised."
msgstr ""
"Motsvarar ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  Detta bör "
"endast anropas när ett undantag faktiskt har ställts in; en "
"minnesåtkomstöverträdelse kommer att inträffa om inget undantag har ställts "
"in."

msgid ""
"Return true if the *given* exception matches the exception type in *exc*.  "
"If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""
"Returnerar true om det *givna* undantaget matchar undantagstypen i *exc*.  "
"Om *exc* är ett klassobjekt returneras även true när *given* är en instans "
"av en underklass.  Om *exc* är en tupel, söks alla undantagstyper i tupeln "
"(och rekursivt i subtuplar) efter en matchning."

msgid ""
"Return the exception currently being raised, clearing the error indicator at "
"the same time. Return ``NULL`` if the error indicator is not set."
msgstr ""
"Returnerar det undantag som för närvarande tas upp och rensar samtidigt "
"felindikatorn. Returnerar ``NULL`` om felindikatorn inte är inställd."

msgid ""
"This function is used by code that needs to catch exceptions, or code that "
"needs to save and restore the error indicator temporarily."
msgstr ""
"Denna funktion används av kod som behöver fånga upp undantag, eller kod som "
"behöver spara och återställa felindikatorn tillfälligt."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"{\n"
"   PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"{\n"
"   PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"   /* ... kod som kan producera andra fel ... */\n"
"\n"
"   PyErr_SetRaisedException(exc);\n"
"}"

msgid ""
":c:func:`PyErr_GetHandledException`, to save the exception currently being "
"handled."
msgstr ""
":c:func:`PyErr_GetHandledException`, för att spara det undantag som för "
"närvarande hanteras."

msgid ""
"Set *exc* as the exception currently being raised, clearing the existing "
"exception if one is set."
msgstr ""
"Ange *exc* som det undantag som för närvarande tas upp, och rensa det "
"befintliga undantaget om ett sådant har angetts."

msgid "This call steals a reference to *exc*, which must be a valid exception."
msgstr ""
"Detta anrop stjäl en referens till *exc*, som måste vara ett giltigt "
"undantag."

msgid "Use :c:func:`PyErr_GetRaisedException` instead."
msgstr "Använd :c:func:`PyErr_GetRaisedException` istället."

msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to each "
"object retrieved.  The value and traceback object may be ``NULL`` even when "
"the type object is not."
msgstr ""
"Hämta felindikatorn till tre variabler vars adresser skickas. Om "
"felindikatorn inte är inställd, ställ in alla tre variablerna till "
"``NULL``.  Om den är inställd kommer den att rensas och du äger en referens "
"till varje objekt som hämtas.  Värde- och spårningsobjektet kan vara "
"``NULL`` även om typobjektet inte är det."

msgid ""
"This function is normally only used by legacy code that needs to catch "
"exceptions or save and restore the error indicator temporarily."
msgstr ""
"Den här funktionen används normalt bara av äldre kod som behöver fånga upp "
"undantag eller spara och återställa felindikatorn tillfälligt."

msgid ""
"{\n"
"   PyObject *type, *value, *traceback;\n"
"   PyErr_Fetch(&type, &value, &traceback);\n"
"\n"
"   /* ... code that might produce other errors ... */\n"
"\n"
"   PyErr_Restore(type, value, traceback);\n"
"}"
msgstr ""
"{\n"
"   PyObject *typ, *värde, *traceback;\n"
"   PyErr_Fetch(&typ, &value, &traceback);\n"
"\n"
"   /* ... kod som kan ge upphov till andra fel ... */\n"
"\n"
"   PyErr_Restore(typ, värde, återgång);\n"
"}"

msgid "Use :c:func:`PyErr_SetRaisedException` instead."
msgstr "Använd :c:func:`PyErr_SetRaisedException` istället."

msgid ""
"Set the error indicator from the three objects, *type*, *value*, and "
"*traceback*, clearing the existing exception if one is set. If the objects "
"are ``NULL``, the error indicator is cleared.  Do not pass a ``NULL`` type "
"and non-``NULL`` value or traceback.  The exception type should be a class.  "
"Do not pass an invalid exception type or value. (Violating these rules will "
"cause subtle problems later.)  This call takes away a reference to each "
"object: you must own a reference to each object before the call and after "
"the call you no longer own these references.  (If you don't understand this, "
"don't use this function.  I warned you.)"
msgstr ""
"Ställ in felindikatorn från de tre objekten *type*, *value* och *traceback*, "
"och rensa det befintliga undantaget om ett sådant har ställts in. Om "
"objekten är ``NULL`` rensas felindikatorn.  Skicka inte en ``NULL``-typ och "
"ett icke-`NULL``-värde eller en traceback.  Undantagstypen bör vara en "
"klass.  Skicka inte en ogiltig undantagstyp eller ett ogiltigt värde. (Brott "
"mot dessa regler kommer att orsaka subtila problem senare.) Detta anrop tar "
"bort en referens till varje objekt: du måste äga en referens till varje "
"objekt före anropet och efter anropet äger du inte längre dessa referenser.  "
"(Om du inte förstår detta, använd inte den här funktionen. Jag varnade dig.)"

msgid ""
"This function is normally only used by legacy code that needs to save and "
"restore the error indicator temporarily. Use :c:func:`PyErr_Fetch` to save "
"the current error indicator."
msgstr ""
"Den här funktionen används normalt bara av äldre kod som behöver spara och "
"återställa felindikatorn tillfälligt. Använd :c:func:`PyErr_Fetch` för att "
"spara den aktuella felindikatorn."

msgid ""
"Use :c:func:`PyErr_GetRaisedException` instead, to avoid any possible de-"
"normalization."
msgstr ""
"Använd :c:func:`PyErr_GetRaisedException` istället, för att undvika "
"eventuell de-normalisering."

msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch` "
"below can be \"unnormalized\", meaning that ``*exc`` is a class object but "
"``*val`` is not an instance of the  same class.  This function can be used "
"to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""
"Under vissa omständigheter kan värdena som returneras av :c:func:"
"`PyErr_Fetch` nedan vara \"onormaliserade\", vilket innebär att ``*exc`` är "
"ett klassobjekt men ``*val`` inte är en instans av samma klass.  Denna "
"funktion kan användas för att instansiera klassen i det fallet.  Om värdena "
"redan är normaliserade händer ingenting. Den fördröjda normaliseringen är "
"implementerad för att förbättra prestandan."

msgid ""
"This function *does not* implicitly set the :attr:`~BaseException."
"__traceback__` attribute on the exception value. If setting the traceback "
"appropriately is desired, the following additional snippet is needed::"
msgstr ""
"Den här funktionen *ställer* inte implicit in attributet :attr:"
"`~BaseException.__traceback__` på undantagsvärdet. Om man vill ställa in "
"traceback på rätt sätt behövs följande ytterligare snutt::"

msgid ""
"if (tb != NULL) {\n"
"  PyException_SetTraceback(val, tb);\n"
"}"
msgstr ""
"if (tb != NULL) {\n"
"  PyException_SetTraceback(val, tb);\n"
"}"

msgid ""
"Retrieve the active exception instance, as would be returned by :func:`sys."
"exception`. This refers to an exception that was *already caught*, not to an "
"exception that was freshly raised. Returns a new reference to the exception "
"or ``NULL``. Does not modify the interpreter's exception state."
msgstr ""
"Hämtar den aktiva undantagsinstansen, som den skulle returneras av :func:"
"`sys.exception`. Detta hänvisar till ett undantag som *redan fångats upp*, "
"inte till ett undantag som nyligen har uppstått. Returnerar en ny referens "
"till undantaget eller ``NULL``. Ändrar inte tolkens undantagstillstånd."

msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetHandledException` to restore or "
"clear the exception state."
msgstr ""
"Denna funktion används normalt inte av kod som vill hantera undantag. "
"Istället kan den användas när koden behöver spara och återställa "
"undantagstillståndet tillfälligt.  Använd :c:func:"
"`PyErr_SetHandledException` för att återställa eller rensa "
"undantagstillståndet."

msgid ""
"Set the active exception, as known from ``sys.exception()``.  This refers to "
"an exception that was *already caught*, not to an exception that was freshly "
"raised. To clear the exception state, pass ``NULL``."
msgstr ""
"Ställer in det aktiva undantaget, enligt ``sys.exception()``.  Detta "
"hänvisar till ett undantag som *redan fångats*, inte till ett undantag som "
"nyligen har uppstått. För att rensa undantagstillståndet, skicka ``NULL``."

msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetHandledException` to get the "
"exception state."
msgstr ""
"Denna funktion används normalt inte av kod som vill hantera undantag. "
"Istället kan den användas när koden behöver spara och återställa "
"undantagstillståndet tillfälligt.  Använd :c:func:"
"`PyErr_GetHandledException` för att hämta undantagstillståndet."

msgid ""
"Retrieve the old-style representation of the exception info, as known from :"
"func:`sys.exc_info`.  This refers to an exception that was *already caught*, "
"not to an exception that was freshly raised.  Returns new references for the "
"three objects, any of which may be ``NULL``.  Does not modify the exception "
"info state.  This function is kept for backwards compatibility. Prefer "
"using :c:func:`PyErr_GetHandledException`."
msgstr ""
"Hämtar den gammaldags representationen av undantagsinformationen, som den är "
"känd från :func:`sys.exc_info`.  Detta hänvisar till ett undantag som *redan "
"fångats upp*, inte till ett undantag som nyligen uppstått.  Returnerar nya "
"referenser för de tre objekten, varav något kan vara ``NULL``.  Ändrar inte "
"tillståndet för undantagsinfo.  Denna funktion behålls för "
"bakåtkompatibilitet. Föredrar att använda :c:func:"
"`PyErr_GetHandledException`."

msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetExcInfo` to restore or clear the "
"exception state."
msgstr ""
"Denna funktion används normalt inte av kod som vill hantera undantag. "
"Istället kan den användas när koden behöver spara och återställa "
"undantagstillståndet tillfälligt.  Använd :c:func:`PyErr_SetExcInfo` för att "
"återställa eller rensa undantagstillståndet."

msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to an "
"exception that was *already caught*, not to an exception that was freshly "
"raised.  This function steals the references of the arguments. To clear the "
"exception state, pass ``NULL`` for all three arguments. This function is "
"kept for backwards compatibility. Prefer using :c:func:"
"`PyErr_SetHandledException`."
msgstr ""
"Ställer in undantagsinformationen, som den är känd från ``sys.exc_info()``.  "
"Detta hänvisar till ett undantag som *redan fångats*, inte till ett undantag "
"som nyligen uppstod.  Den här funktionen stjäl argumentens referenser. För "
"att rensa undantagstillståndet, skicka ``NULL`` för alla tre argumenten. "
"Denna funktion behålls för bakåtkompatibilitet. Föredrar att använda :c:func:"
"`PyErr_SetHandledException`."

msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read the exception "
"state."
msgstr ""
"Denna funktion används normalt inte av kod som vill hantera undantag. "
"Istället kan den användas när koden behöver spara och återställa "
"undantagstillståndet tillfälligt.  Använd :c:func:`PyErr_GetExcInfo` för att "
"läsa undantagstillståndet."

msgid ""
"The ``type`` and ``traceback`` arguments are no longer used and can be NULL. "
"The interpreter now derives them from the exception instance (the ``value`` "
"argument). The function still steals references of all three arguments."
msgstr ""
"Argumenten ``type`` och ``traceback`` används inte längre och kan vara NULL. "
"Tolken härleder dem nu från undantagsinstansen (argumentet ``value``). "
"Funktionen stjäl fortfarande referenser till alla tre argumenten."

msgid "Signal Handling"
msgstr "Signalhantering"

msgid "This function interacts with Python's signal handling."
msgstr "Denna funktion interagerar med Pythons signalhantering."

msgid ""
"If the function is called from the main thread and under the main Python "
"interpreter, it checks whether a signal has been sent to the processes and "
"if so, invokes the corresponding signal handler.  If the :mod:`signal` "
"module is supported, this can invoke a signal handler written in Python."
msgstr ""
"Om funktionen anropas från huvudtråden och under Pythons huvudtolk, "
"kontrollerar den om en signal har skickats till processerna och anropar i så "
"fall motsvarande signalhanterare.  Om modulen :mod:`signal` stöds kan den "
"anropa en signalhanterare som är skriven i Python."

msgid ""
"The function attempts to handle all pending signals, and then returns ``0``. "
"However, if a Python signal handler raises an exception, the error indicator "
"is set and the function returns ``-1`` immediately (such that other pending "
"signals may not have been handled yet: they will be on the next :c:func:"
"`PyErr_CheckSignals()` invocation)."
msgstr ""
"Funktionen försöker hantera alla väntande signaler och returnerar sedan "
"``0``. Men om en Python-signalhanterare ger upphov till ett undantag, sätts "
"felindikatorn och funktionen returnerar ``-1`` omedelbart (så att andra "
"väntande signaler kanske inte har hanterats ännu: de kommer att hanteras vid "
"nästa :c:func:`PyErr_CheckSignals()`-inkallning)."

msgid ""
"If the function is called from a non-main thread, or under a non-main Python "
"interpreter, it does nothing and returns ``0``."
msgstr ""
"Om funktionen anropas från en tråd som inte är huvudtråd, eller under en "
"Python-tolk som inte är huvudtråd, gör den ingenting och returnerar ``0``."

msgid ""
"This function can be called by long-running C code that wants to be "
"interruptible by user requests (such as by pressing Ctrl-C)."
msgstr ""
"Den här funktionen kan anropas av C-kod som körs under lång tid och som vill "
"kunna avbrytas av användaren (t.ex. genom att trycka på Ctrl-C)."

msgid ""
"The default Python signal handler for :c:macro:`!SIGINT` raises the :exc:"
"`KeyboardInterrupt` exception."
msgstr ""
"Pythons standardsignalhanterare för :c:macro:`!SIGINT` ger upphov till "
"undantaget :exc:`KeyboardInterrupt`."

msgid ""
"Simulate the effect of a :c:macro:`!SIGINT` signal arriving. This is "
"equivalent to ``PyErr_SetInterruptEx(SIGINT)``."
msgstr ""
"Simulerar effekten av att en :c:macro:`!SIGINT`-signal anländer. Detta är "
"likvärdigt med ``PyErr_SetInterruptEx(SIGINT)``."

msgid ""
"This function is async-signal-safe.  It can be called without an :term:"
"`attached thread state` and from a C signal handler."
msgstr ""
"Denna funktion är async-signal-säker.  Den kan anropas utan en :term:"
"`attached thread state` och från en C-signalhanterare."

msgid ""
"Simulate the effect of a signal arriving. The next time :c:func:"
"`PyErr_CheckSignals` is called,  the Python signal handler for the given "
"signal number will be called."
msgstr ""
"Simulerar effekten av att en signal anländer. Nästa gång :c:func:"
"`PyErr_CheckSignals` anropas, kommer Python-signalhanteraren för det angivna "
"signalnumret att anropas."

msgid ""
"This function can be called by C code that sets up its own signal handling "
"and wants Python signal handlers to be invoked as expected when an "
"interruption is requested (for example when the user presses Ctrl-C to "
"interrupt an operation)."
msgstr ""
"Denna funktion kan anropas av C-kod som ställer in sin egen signalhantering "
"och vill att Pythons signalhanterare ska anropas som förväntat när ett "
"avbrott begärs (t.ex. när användaren trycker på Ctrl-C för att avbryta en "
"operation)."

msgid ""
"If the given signal isn't handled by Python (it was set to :py:const:`signal."
"SIG_DFL` or :py:const:`signal.SIG_IGN`), it will be ignored."
msgstr ""
"Om den angivna signalen inte hanteras av Python (den var inställd på :py:"
"const:`signal.SIG_DFL` eller :py:const:`signal.SIG_IGN`), ignoreras den."

msgid ""
"If *signum* is outside of the allowed range of signal numbers, ``-1`` is "
"returned.  Otherwise, ``0`` is returned.  The error indicator is never "
"changed by this function."
msgstr ""
"Om *signum* ligger utanför det tillåtna intervallet för signalnummer, "
"returneras ``-1``.  I annat fall returneras ``0``.  Felindikatorn ändras "
"aldrig av denna funktion."

msgid ""
"This utility function specifies a file descriptor to which the signal number "
"is written as a single byte whenever a signal is received. *fd* must be non-"
"blocking. It returns the previous such file descriptor."
msgstr ""
"Denna utility-funktion specificerar en filbeskrivare till vilken "
"signalnumret skrivs som en enda byte när en signal tas emot. *fd* måste vara "
"icke-blockerande. Den returnerar den föregående sådana fildescriptorn."

msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is "
"equivalent to :func:`signal.set_wakeup_fd` in Python, but without any error "
"checking.  *fd* should be a valid file descriptor.  The function should only "
"be called from the main thread."
msgstr ""
"Värdet ``-1`` inaktiverar funktionen; detta är det initiala tillståndet. "
"Detta är likvärdigt med :func:`signal.set_wakeup_fd` i Python, men utan "
"någon felkontroll.  *fd* bör vara en giltig filbeskrivare.  Funktionen bör "
"endast anropas från huvudtråden."

msgid "On Windows, the function now also supports socket handles."
msgstr "I Windows stöder funktionen nu även socket-handtag."

msgid "Exception Classes"
msgstr "Undantagsklasser"

msgid ""
"This utility function creates and returns a new exception class. The *name* "
"argument must be the name of the new exception, a C string of the form "
"``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""
"Denna verktygsfunktion skapar och returnerar en ny undantagsklass. "
"Argumentet *name* måste vara namnet på det nya undantaget, en C-sträng av "
"formen ``module.classname``.  Argumenten *base* och *dict* är normalt "
"``NULL``. Detta skapar ett klassobjekt som härrör från :exc:`Exception` "
"(tillgängligt i C som :c:data:`PyExc_Exception`)."

msgid ""
"The :attr:`~type.__module__` attribute of the new class is set to the first "
"part (up to the last dot) of the *name* argument, and the class name is set "
"to the last part (after the last dot).  The *base* argument can be used to "
"specify alternate base classes; it can either be only one class or a tuple "
"of classes. The *dict* argument can be used to specify a dictionary of class "
"variables and methods."
msgstr ""
"Attributet :attr:`~type.__module__` för den nya klassen sätts till den "
"första delen (upp till den sista punkten) av argumentet *name* och "
"klassnamnet sätts till den sista delen (efter den sista punkten).  "
"Argumentet *base* kan användas för att ange alternativa basklasser; det kan "
"antingen vara bara en klass eller en tupel av klasser. Argumentet *dict* kan "
"användas för att ange en ordbok över klassens variabler och metoder."

msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class "
"can easily be given a docstring: If *doc* is non-``NULL``, it will be used "
"as the docstring for the exception class."
msgstr ""
"Samma som :c:func:`PyErr_NewException`, förutom att den nya undantagsklassen "
"enkelt kan ges en docstring: Om *doc* är icke-``NULL``, kommer den att "
"användas som dokumentsträng för undantagsklassen."

msgid ""
"Return non-zero if *ob* is an exception class, zero otherwise. This function "
"always succeeds."
msgstr ""
"Returnerar icke-noll om *ob* är en undantagsklass, noll annars. Denna "
"funktion lyckas alltid."

msgid "Return :c:member:`~PyTypeObject.tp_name` of the exception class *ob*."
msgstr "Returnerar :c:member:`~PyTypeObject.tp_name` i undantagsklassen *ob*."

msgid "Exception Objects"
msgstr "Objekt för undantag"

msgid ""
"Return the traceback associated with the exception as a new reference, as "
"accessible from Python through the :attr:`~BaseException.__traceback__` "
"attribute. If there is no traceback associated, this returns ``NULL``."
msgstr ""
"Returnerar den traceback som är associerad med undantaget som en ny "
"referens, som tillgänglig från Python genom attributet :attr:`~BaseException."
"__traceback__`. Om det inte finns någon traceback associerad, returneras "
"``NULL``."

msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None`` to "
"clear it."
msgstr ""
"Ställ in den traceback som är kopplad till undantaget till *tb*.  Använd "
"``Py_None`` för att rensa det."

msgid ""
"Return the context (another exception instance during whose handling *ex* "
"was raised) associated with the exception as a new reference, as accessible "
"from Python through the :attr:`~BaseException.__context__` attribute. If "
"there is no context associated, this returns ``NULL``."
msgstr ""
"Returnerar kontexten (en annan undantagsinstans under vars hantering *ex* "
"togs upp) som är associerad med undantaget som en ny referens, som "
"tillgänglig från Python genom attributet :attr:`~BaseException.__context__`. "
"Om det inte finns någon kontext associerad, returneras ``NULL``."

msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception "
"instance. This steals a reference to *ctx*."
msgstr ""
"Ställ in kontexten som är associerad med undantaget till *ctx*.  Använd "
"``NULL`` för att rensa den.  Det finns ingen typkontroll för att se till att "
"*ctx* är en undantagsinstans. Detta stjäl en referens till *ctx*."

msgid ""
"Return the cause (either an exception instance, or ``None``, set by "
"``raise ... from ...``) associated with the exception as a new reference, as "
"accessible from Python through the :attr:`~BaseException.__cause__` "
"attribute."
msgstr ""
"Returnerar orsaken (antingen en undantagsinstans eller ``None``, inställd av "
"``raise ... from ...``) associerad med undantaget som en ny referens, som "
"tillgänglig från Python genom attributet :attr:`~BaseException.__cause__`."

msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or ``None``.  This steals a reference to *cause*."
msgstr ""
"Ange orsaken till undantaget till *cause*.  Använd ``NULL`` för att rensa "
"den.  Det finns ingen typkontroll för att se till att *cause* antingen är en "
"undantagsinstans eller ``None``.  Detta stjäl en referens till *cause*."

msgid ""
"The :attr:`~BaseException.__suppress_context__` attribute is implicitly set "
"to ``True`` by this function."
msgstr ""
"Attributet :attr:`~BaseException.__suppress_context__` sätts implicit till "
"``True`` av denna funktion."

msgid "Return :attr:`~BaseException.args` of exception *ex*."
msgstr "Returnera :attr:`~BaseException.args` för undantag *ex*."

msgid "Set :attr:`~BaseException.args` of exception *ex* to *args*."
msgstr "Ställ in :attr:`~BaseException.args` för undantag *ex* till *args*."

msgid ""
"Implement part of the interpreter's implementation of :keyword:`!except*`. "
"*orig* is the original exception that was caught, and *excs* is the list of "
"the exceptions that need to be raised. This list contains the unhandled part "
"of *orig*, if any, as well as the exceptions that were raised from the :"
"keyword:`!except*` clauses (so they have a different traceback from *orig*) "
"and those that were reraised (and have the same traceback as *orig*). Return "
"the :exc:`ExceptionGroup` that needs to be reraised in the end, or ``None`` "
"if there is nothing to reraise."
msgstr ""
"Implementerar en del av tolkens implementation av :keyword:`!except*`. "
"*orig* är det ursprungliga undantaget som fångades upp och *excs* är listan "
"över de undantag som måste tas upp. Denna lista innehåller den ohanterade "
"delen av *orig*, om någon, samt de undantag som togs upp från :keyword:`!"
"except*`-klausulerna (så de har en annan traceback än *orig*) och de som "
"togs upp igen (och har samma traceback som *orig*). Returnerar den :exc:"
"`ExceptionGroup` som behöver återupplivas i slutet, eller ``None`` om det "
"inte finns något att återuppliva."

msgid "Unicode Exception Objects"
msgstr "Objekt för Unicode-undantag"

msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr ""
"Följande funktioner används för att skapa och modifiera Unicode-undantag "
"från C."

msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are "
"UTF-8 encoded strings."
msgstr ""
"Skapa ett :class:`UnicodeDecodeError`-objekt med attributen *encoding*, "
"*object*, *length*, *start*, *end* och *reason*. *encoding* och *reason* är "
"UTF-8-kodade strängar."

msgid "Return the *encoding* attribute of the given exception object."
msgstr "Returnerar *encoding*-attributet för det angivna undantagsobjektet."

msgid "Return the *object* attribute of the given exception object."
msgstr "Returnerar *object*-attributet för det angivna undantagsobjektet."

msgid ""
"Get the *start* attribute of the given exception object and place it into "
"*\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""
"Hämta *start*-attributet för det angivna undantagsobjektet och placera det i "
"*\\*start*.  *start* får inte vara ``NULL``.  Returnerar ``0`` vid framgång, "
"``-1`` vid misslyckande."

msgid ""
"If the :attr:`UnicodeError.object` is an empty sequence, the resulting "
"*start* is ``0``. Otherwise, it is clipped to ``[0, len(object) - 1]``."
msgstr ""
"Om :attr:`UnicodeError.object` är en tom sekvens, är den resulterande "
"*starten* ``0``. Annars klipps den till ``[0, len(object) - 1]``."

msgid ":attr:`UnicodeError.start`"
msgstr ":attr:`UnicodeError.start`"

msgid ""
"Set the *start* attribute of the given exception object to *start*. Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Sätter attributet *start* för det angivna undantagsobjektet till *start*. "
"Returnerar ``0`` vid framgång, ``-1`` vid misslyckande."

msgid ""
"While passing a negative *start* does not raise an exception, the "
"corresponding getters will not consider it as a relative offset."
msgstr ""
"Även om det inte leder till något undantag att skicka en negativ *start*, "
"kommer motsvarande getters inte att betrakta den som en relativ offset."

msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` on "
"failure."
msgstr ""
"Hämta *end*-attributet för det angivna undantagsobjektet och placera det i "
"*\\*end*.  *end* får inte vara ``NULL``.  Returnerar ``0`` vid framgång, "
"``-1`` vid misslyckande."

msgid ""
"If the :attr:`UnicodeError.object` is an empty sequence, the resulting *end* "
"is ``0``. Otherwise, it is clipped to ``[1, len(object)]``."
msgstr ""
"Om :attr:`UnicodeError.object` är en tom sekvens, blir det resulterande "
"*slutet* ``0``. Annars klipps den till ``[1, len(object)]``."

msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Sätter attributet *end* för det angivna undantagsobjektet till *end*.  "
"Returnerar ``0`` vid framgång, ``-1`` vid misslyckande."

msgid ":attr:`UnicodeError.end`"
msgstr ":attr:`UnicodeError.end`"

msgid "Return the *reason* attribute of the given exception object."
msgstr "Returnerar attributet *reason* för det angivna undantagsobjektet."

msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""
"Sätter attributet *reason* för det angivna undantagsobjektet till *reason*.  "
"Returnerar ``0`` vid framgång, ``-1`` vid misslyckande."

msgid "Recursion Control"
msgstr "Kontroll av rekursion"

msgid ""
"These two functions provide a way to perform safe recursive calls at the C "
"level, both in the core and in extension modules.  They are needed if the "
"recursive code does not necessarily invoke Python code (which tracks its "
"recursion depth automatically). They are also not needed for *tp_call* "
"implementations because the :ref:`call protocol <call>` takes care of "
"recursion handling."
msgstr ""
"Dessa två funktioner gör det möjligt att utföra säkra rekursiva anrop på C-"
"nivå, både i kärnan och i tilläggsmoduler.  De behövs om den rekursiva koden "
"inte nödvändigtvis anropar Python-kod (som spårar sitt rekursionsdjup "
"automatiskt). De behövs inte heller för *tp_call*-implementeringar eftersom :"
"ref:`call protocol <call>` tar hand om rekursionshanteringen."

msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr ""
"Markerar en punkt där ett rekursivt anrop på C-nivå är på väg att utföras."

msgid ""
"The function then checks if the stack limit is reached.  If this is the "
"case, a :exc:`RecursionError` is set and a nonzero value is returned. "
"Otherwise, zero is returned."
msgstr ""
"Funktionen kontrollerar sedan om stackgränsen är nådd.  Om så är fallet "
"anges ett :exc:`RecursionError` och ett värde som inte är noll returneras. "
"Annars returneras noll."

msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance check\"`` "
"to be concatenated to the :exc:`RecursionError` message caused by the "
"recursion depth limit."
msgstr ""
"*där* ska vara en UTF-8-kodad sträng som ``\" in instance check\"`` som ska "
"konkateneras till meddelandet :exc:`RecursionError` som orsakas av gränsen "
"för rekursionsdjup."

msgid ""
"This function is now also available in the :ref:`limited API <limited-c-"
"api>`."
msgstr ""
"Denna funktion är nu också tillgänglig i :ref:``limited API <limited-c-api>`."

msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""
"Avslutar en :c:func:`Py_EnterRecursiveCall`.  Måste anropas en gång för "
"varje *lyckad* anrop av :c:func:`Py_EnterRecursiveCall`."

msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container types "
"requires special recursion handling.  In addition to protecting the stack, :"
"c:member:`~PyTypeObject.tp_repr` also needs to track objects to prevent "
"cycles.  The following two functions facilitate this functionality.  "
"Effectively, these are the C equivalent to :func:`reprlib.recursive_repr`."
msgstr ""
"Korrekt implementering av :c:member:`~PyTypeObject.tp_repr` för "
"containertyper kräver speciell rekursionshantering.  Förutom att skydda "
"stacken måste :c:member:`~PyTypeObject.tp_repr` också spåra objekt för att "
"förhindra cykler.  Följande två funktioner underlättar denna "
"funktionalitet.  I praktiken är dessa C-motsvarigheten till :func:`reprlib."
"recursive_repr`."

msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr ""
"Anropas i början av :c:member:`~PyTypeObject.tp_repr`-implementeringen för "
"att upptäcka cykler."

msgid ""
"If the object has already been processed, the function returns a positive "
"integer.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should return a string object indicating a cycle.  As examples, :class:"
"`dict` objects return ``{...}`` and :class:`list` objects return ``[...]``."
msgstr ""
"Om objektet redan har bearbetats returnerar funktionen ett positivt heltal.  "
"I så fall bör :c:member:`~PyTypeObject.tp_repr`-implementeringen returnera "
"ett strängobjekt som indikerar en cykel.  Som exempel kan nämnas att :class:"
"`dict`-objekt returnerar ``{...}`` och :class:`list`-objekt returnerar "
"``[...]``."

msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should typically return ``NULL``."
msgstr ""
"Funktionen returnerar ett negativt heltal om rekursionsgränsen är nådd.  I "
"så fall bör implementeringen :c:member:`~PyTypeObject.tp_repr` typiskt "
"returnera ``NULL``."

msgid ""
"Otherwise, the function returns zero and the :c:member:`~PyTypeObject."
"tp_repr` implementation can continue normally."
msgstr ""
"I annat fall returnerar funktionen noll och :c:member:`~PyTypeObject."
"tp_repr`-implementeringen kan fortsätta normalt."

msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation of :"
"c:func:`Py_ReprEnter` that returns zero."
msgstr ""
"Avslutar en :c:func:`Py_ReprEnter`.  Måste anropas en gång för varje anrop "
"av :c:func:`Py_ReprEnter` som returnerar noll."

msgid "Exception and warning types"
msgstr "Typer av undantag och varningar"

msgid ""
"All standard Python exceptions and warning categories are available as "
"global variables whose names are ``PyExc_`` followed by the Python exception "
"name. These have the type :c:expr:`PyObject*`; they are all class objects."
msgstr ""
"Alla Pythons standardundantag och varningskategorier finns tillgängliga som "
"globala variabler vars namn är ``PyExc_`` följt av Pythons undantagsnamn. "
"Dessa har typen :c:expr:`PyObject*`; de är alla klassobjekt."

msgid "For completeness, here are all the variables:"
msgstr "För fullständighetens skull, här är alla variabler:"

msgid "Exception types"
msgstr "Typer av undantag"

msgid "C name"
msgstr "C-namn"

msgid "Python name"
msgstr "Python-namn"

msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

msgid ":exc:`BaseExceptionGroup`"
msgstr ":exc:`BaseExceptionGroup`"

msgid ":exc:`Exception`"
msgstr ":exc:`Untantagande`"

msgid ":exc:`ArithmeticError`"
msgstr ":exc:`Aritmetiskt fel`"

msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`BrokenPipeError`"

msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`Fel vid avbruten anslutning`"

msgid ":exc:`ConnectionError`"
msgstr ":exc:`AnslutningFel`"

msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`AnslutningRefusedError`"

msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`Fel vid återställning av anslutning`"

msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

msgid ":exc:`InterruptedError`"
msgstr ":exc:`AvbrutetFel`"

msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

msgid ":exc:`NameError`"
msgstr ":exc:`NamnFel`"

msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

msgid ":exc:`PythonFinalizationError`"
msgstr ":exc:`PythonFinalizationError`"

msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

msgid ":exc:`SystemError`"
msgstr ":exc:`Systemfel`"

msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`UnicodeDecodeError`"

msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

msgid ":exc:`UnicodeError`"
msgstr ":exc:`UnicodeError`"

msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`UnicodeTranslateError`"

msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and :c:data:"
"`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` och :c:data:"
"`PyExc_TimeoutError` infördes enligt :pep:`3151`."

msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ":c:data:`PyExc_StopAsyncIteration` och :c:data:`PyExc_RecursionError`."

msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`."

msgid ":c:data:`PyExc_BaseExceptionGroup`."
msgstr ":c:data:`PyExc_BaseExceptionGroup`."

msgid "OSError aliases"
msgstr "OSError-aliaser"

msgid "The following are a compatibility aliases to :c:data:`PyExc_OSError`."
msgstr "Följande är kompatibla alias till :c:data:`PyExc_OSError`."

msgid "These aliases used to be separate exception types."
msgstr "Dessa alias brukade tidigare vara separata undantagstyper."

msgid "Notes"
msgstr "Anteckningar"

msgid "[win]_"
msgstr "[win]_"

msgid "Notes:"
msgstr "Anteckningar:"

msgid ""
":c:var:`!PyExc_WindowsError` is only defined on Windows; protect code that "
"uses this by testing that the preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""
":c:var:`!PyExc_WindowsError` definieras endast på Windows; skydda kod som "
"använder detta genom att testa att preprocessormakrot ``MS_WINDOWS`` är "
"definierat."

msgid "Warning types"
msgstr "Typer av varningar"

msgid ":exc:`Warning`"
msgstr ":exc:`Varning`"

msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

msgid ":exc:`EncodingWarning`"
msgstr ":exc:`EncodingWarning`"

msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`UnicodeWarning`"

msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

msgid ":c:data:`PyExc_EncodingWarning`."
msgstr ":c:data:`PyExc_EncodingWarning`."

msgid "strerror (C function)"
msgstr "strerror (C-funktion)"

msgid "module"
msgstr "modul"

msgid "signal"
msgstr "signal"

msgid "SIGINT (C macro)"
msgstr "SIGINT (C-makro)"

msgid "KeyboardInterrupt (built-in exception)"
msgstr "KeyboardInterrupt (inbyggt undantag)"
