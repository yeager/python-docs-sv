# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!concurrent.interpreters` --- Multiple interpreters in the same process"
msgstr ""

msgid "**Source code:** :source:`Lib/concurrent/interpreters`"
msgstr ""

msgid ""
"The :mod:`!concurrent.interpreters` module constructs higher-level "
"interfaces on top of the lower level :mod:`!_interpreters` module."
msgstr ""

msgid ""
"The module is primarily meant to provide a basic API for managing "
"interpreters (AKA \"subinterpreters\") and running things in them. Running "
"mostly involves switching to an interpreter (in the current thread) and "
"calling a function in that execution context."
msgstr ""

msgid ""
"For concurrency, interpreters themselves (and this module) don't provide "
"much more than isolation, which on its own isn't useful. Actual concurrency "
"is available separately through :mod:`threads <threading>`  See `below "
"<interp-concurrency_>`_"
msgstr ""

msgid ":class:`~concurrent.futures.InterpreterPoolExecutor`"
msgstr ""

msgid "combines threads with interpreters in a familiar interface."
msgstr ""

msgid ":ref:`isolating-extensions-howto`"
msgstr ""

msgid "how to update an extension module to support multiple interpreters"
msgstr ""

msgid ":pep:`554`"
msgstr ""

msgid ":pep:`734`"
msgstr ""

msgid ":pep:`684`"
msgstr ""

msgid "Availability"
msgstr ""

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""

msgid "Key details"
msgstr ""

msgid ""
"Before we dive in further, there are a small number of details to keep in "
"mind about using multiple interpreters:"
msgstr ""

msgid "`isolated <interp-isolation_>`_, by default"
msgstr ""

msgid "no implicit threads"
msgstr ""

msgid "not all PyPI packages support use in multiple interpreters yet"
msgstr ""

msgid "Introduction"
msgstr ""

msgid ""
"An \"interpreter\" is effectively the execution context of the Python "
"runtime.  It contains all of the state the runtime needs to execute a "
"program.  This includes things like the import state and builtins. (Each "
"thread, even if there's only the main thread, has some extra runtime state, "
"in addition to the current interpreter, related to the current exception and "
"the bytecode eval loop.)"
msgstr ""

msgid ""
"The concept and functionality of the interpreter have been a part of Python "
"since version 2.2, but the feature was only available through the C-API and "
"not well known, and the `isolation <interp-isolation_>`_ was relatively "
"incomplete until version 3.12."
msgstr ""

msgid "Multiple Interpreters and Isolation"
msgstr ""

msgid ""
"A Python implementation may support using multiple interpreters in the same "
"process.  CPython has this support.  Each interpreter is effectively "
"isolated from the others (with a limited number of carefully managed process-"
"global exceptions to the rule)."
msgstr ""

msgid ""
"That isolation is primarily useful as a strong separation between distinct "
"logical components of a program, where you want to have careful control of "
"how those components interact."
msgstr ""

msgid ""
"Interpreters in the same process can technically never be strictly isolated "
"from one another since there are few restrictions on memory access within "
"the same process.  The Python runtime makes a best effort at isolation but "
"extension modules may easily violate that. Therefore, do not use multiple "
"interpreters in security-sensitive situations, where they shouldn't have "
"access to each other's data."
msgstr ""

msgid "Running in an Interpreter"
msgstr ""

msgid ""
"Running in a different interpreter involves switching to it in the current "
"thread and then calling some function.  The runtime will execute the "
"function using the current interpreter's state.  The :mod:`!concurrent."
"interpreters` module provides a basic API for creating and managing "
"interpreters, as well as the switch-and-call operation."
msgstr ""

msgid ""
"No other threads are automatically started for the operation. There is `a "
"helper <interp-call-in-thread_>`_ for that though. There is another "
"dedicated helper for calling the builtin :func:`exec` in an interpreter."
msgstr ""

msgid ""
"When :func:`exec` (or :func:`eval`) are called in an interpreter, they run "
"using the interpreter's :mod:`!__main__` module as the \"globals\" "
"namespace.  The same is true for functions that aren't associated with any "
"module.  This is the same as how scripts invoked from the command-line run "
"in the :mod:`!__main__` module."
msgstr ""

msgid "Concurrency and Parallelism"
msgstr ""

msgid ""
"As noted earlier, interpreters do not provide any concurrency on their own.  "
"They strictly represent the isolated execution context the runtime will use "
"*in the current thread*.  That isolation makes them similar to processes, "
"but they still enjoy in-process efficiency, like threads."
msgstr ""

msgid ""
"All that said, interpreters do naturally support certain flavors of "
"concurrency. There's a powerful side effect of that isolation.  It enables a "
"different approach to concurrency than you can take with async or threads.  "
"It's a similar concurrency model to CSP or the actor model, a model which is "
"relatively easy to reason about."
msgstr ""

msgid ""
"You can take advantage of that concurrency model in a single thread, "
"switching back and forth between interpreters, Stackless-style. However, "
"this model is more useful when you combine interpreters with multiple "
"threads.  This mostly involves starting a new thread, where you switch to "
"another interpreter and run what you want there."
msgstr ""

msgid ""
"Each actual thread in Python, even if you're only running in the main "
"thread, has its own *current* execution context.  Multiple threads can use "
"the same interpreter or different ones."
msgstr ""

msgid ""
"At a high level, you can think of the combination of threads and "
"interpreters as threads with opt-in sharing."
msgstr ""

msgid ""
"As a significant bonus, interpreters are sufficiently isolated that they do "
"not share the :term:`GIL`, which means combining threads with multiple "
"interpreters enables full multi-core parallelism. (This has been the case "
"since Python 3.12.)"
msgstr ""

msgid "Communication Between Interpreters"
msgstr ""

msgid ""
"In practice, multiple interpreters are useful only if we have a way to "
"communicate between them.  This usually involves some form of message "
"passing, but can even mean sharing data in some carefully managed way."
msgstr ""

msgid ""
"With this in mind, the :mod:`!concurrent.interpreters` module provides a :"
"class:`queue.Queue` implementation, available through :func:`create_queue`."
msgstr ""

msgid "\"Sharing\" Objects"
msgstr ""

msgid ""
"Any data actually shared between interpreters loses the thread-safety "
"provided by the :term:`GIL`.  There are various options for dealing with "
"this in extension modules.  However, from Python code the lack of thread-"
"safety means objects can't actually be shared, with a few exceptions.  "
"Instead, a copy must be created, which means mutable objects won't stay in "
"sync."
msgstr ""

msgid ""
"By default, most objects are copied with :mod:`pickle` when they are passed "
"to another interpreter.  Nearly all of the immutable builtin objects are "
"either directly shared or copied efficiently.  For example:"
msgstr ""

msgid ":const:`None`"
msgstr ""

msgid ":class:`bool` (:const:`True` and :const:`False`)"
msgstr ""

msgid ":class:`bytes`"
msgstr ""

msgid ":class:`str`"
msgstr ""

msgid ":class:`int`"
msgstr ""

msgid ":class:`float`"
msgstr ""

msgid ":class:`tuple` (of similarly supported objects)"
msgstr ""

msgid ""
"There is a small number of Python types that actually share mutable data "
"between interpreters:"
msgstr ""

msgid ":class:`memoryview`"
msgstr ""

msgid ":class:`Queue`"
msgstr ""

msgid "Reference"
msgstr ""

msgid "This module defines the following functions:"
msgstr ""

msgid ""
"Return a :class:`list` of :class:`Interpreter` objects, one for each "
"existing interpreter."
msgstr ""

msgid ""
"Return an :class:`Interpreter` object for the currently running interpreter."
msgstr ""

msgid ""
"Return an :class:`Interpreter` object for the main interpreter. This is the "
"interpreter the runtime created to run the :term:`REPL` or the script given "
"at the command-line.  It is usually the only one."
msgstr ""

msgid ""
"Initialize a new (idle) Python interpreter and return a :class:`Interpreter` "
"object for it."
msgstr ""

msgid ""
"Initialize a new cross-interpreter queue and return a :class:`Queue` object "
"for it."
msgstr ""

msgid "Interpreter objects"
msgstr ""

msgid "A single interpreter in the current process."
msgstr ""

msgid ""
"Generally, :class:`Interpreter` shouldn't be called directly. Instead, use :"
"func:`create` or one of the other module functions."
msgstr ""

msgid "(read-only)"
msgstr ""

msgid "The underlying interpreter's ID."
msgstr ""

msgid "A string describing where the interpreter came from."
msgstr ""

msgid ""
"Return ``True`` if the interpreter is currently executing code in its :mod:`!"
"__main__` module and ``False`` otherwise."
msgstr ""

msgid "Finalize and destroy the interpreter."
msgstr ""

msgid "Bind objects in the interpreter's :mod:`!__main__` module."
msgstr ""

msgid ""
"Some objects are actually shared and some are copied efficiently, but most "
"are copied via :mod:`pickle`.  See :ref:`interp-object-sharing`."
msgstr ""

msgid "Run the given source code in the interpreter (in the current thread)."
msgstr ""

msgid ""
"Return the result of calling running the given function in the interpreter "
"(in the current thread)."
msgstr ""

msgid "Run the given function in the interpreter (in a new thread)."
msgstr ""

msgid "Exceptions"
msgstr ""

msgid ""
"This exception, a subclass of :exc:`Exception`, is raised when an "
"interpreter-related error happens."
msgstr ""

msgid ""
"This exception, a subclass of :exc:`InterpreterError`, is raised when the "
"targeted interpreter no longer exists."
msgstr ""

msgid ""
"This exception, a subclass of :exc:`InterpreterError`, is raised when the "
"running code raised an uncaught exception."
msgstr ""

msgid "A basic snapshot of the exception raised in the other interpreter."
msgstr ""

msgid ""
"This exception, a subclass of :exc:`TypeError`, is raised when an object "
"cannot be sent to another interpreter."
msgstr ""

msgid "Communicating Between Interpreters"
msgstr ""

msgid ""
"A wrapper around a low-level, cross-interpreter queue, which implements the :"
"class:`queue.Queue` interface.  The underlying queue can only be created "
"through :func:`create_queue`."
msgstr ""

msgid "The queue's ID."
msgstr ""

msgid ""
"This exception, a subclass of :exc:`queue.Empty`, is raised from :meth:`!"
"Queue.get` and :meth:`!Queue.get_nowait` when the queue is empty."
msgstr ""

msgid ""
"This exception, a subclass of :exc:`queue.Full`, is raised from :meth:`!"
"Queue.put` and :meth:`!Queue.put_nowait` when the queue is full."
msgstr ""

msgid "Basic usage"
msgstr ""

msgid "Creating an interpreter and running code in it::"
msgstr ""

msgid ""
"from concurrent import interpreters\n"
"\n"
"interp = interpreters.create()\n"
"\n"
"# Run in the current OS thread.\n"
"\n"
"interp.exec('print(\"spam!\")')\n"
"\n"
"interp.exec(\"\"\"if True:\n"
"    print('spam!')\n"
"    \"\"\")\n"
"\n"
"from textwrap import dedent\n"
"interp.exec(dedent(\"\"\"\n"
"    print('spam!')\n"
"    \"\"\"))\n"
"\n"
"def run(arg):\n"
"    return arg\n"
"\n"
"res = interp.call(run, 'spam!')\n"
"print(res)\n"
"\n"
"def run():\n"
"    print('spam!')\n"
"\n"
"interp.call(run)\n"
"\n"
"# Run in new OS thread.\n"
"\n"
"t = interp.call_in_thread(run)\n"
"t.join()"
msgstr ""
