# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Floating-Point Arithmetic:  Issues and Limitations"
msgstr "Aritmetik med flyttal: problem och begränsningar"

msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the **decimal** fraction ``0.625`` has "
"value 6/10 + 2/100 + 5/1000, and in the same way the **binary** fraction "
"``0.101`` has value 1/2 + 0/4 + 1/8. These two fractions have identical "
"values, the only real difference being that the first is written in base 10 "
"fractional notation, and the second in base 2."
msgstr ""
"Flyttal representeras i datorhårdvara som bas 2 (binära) fraktioner.  Till "
"exempel har det **decimala** bråket ``0,625`` värdet 6/10 + 2/100 + 5/1000, "
"och på samma sätt har det **binära** bråket ``0,101`` värdet 1/2 + 0/4 + "
"1/8. Dessa två bråk har identiska värden, den enda verkliga skillnaden är "
"att det första är skrivet i bråknotation i bas 10 och det andra i bas 2."

msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"Tyvärr kan de flesta decimala fraktioner inte representeras exakt som binära "
"fraktioner.  En följd av detta är att de decimala flyttal som du anger i "
"allmänhet endast approximeras av de binära flyttal som faktiskt lagras i "
"maskinen."

msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"Problemet är lättare att förstå till en början i bas 10.  Tänk på bråket "
"1/3.  Du kan approximera det som ett bas 10-bråk::"

msgid "0.3"
msgstr "0.3"

msgid "or, better, ::"
msgstr "eller, bättre, ::"

msgid "0.33"
msgstr "0.33"

msgid "0.333"
msgstr "0.333"

msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"och så vidare.  Oavsett hur många siffror du är villig att skriva ner kommer "
"resultatet aldrig att bli exakt 1/3, men det kommer att bli en allt bättre "
"approximation av 1/3."

msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"På samma sätt, oavsett hur många bas 2-siffror du är villig att använda, kan "
"decimalvärdet 0,1 inte representeras exakt som ett bas 2-brott.  I bas 2 är "
"1/10 det oändligt upprepade bråket ::"

msgid "0.0001100110011001100110011001100110011001100110011..."
msgstr "0.0001100110011001100110011001100110011001100110011..."

msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"Om du stannar vid ett ändligt antal bitar får du en approximation.  På de "
"flesta maskiner idag approximeras floats med hjälp av ett binärt bråk där "
"täljaren använder de första 53 bitarna med början med den mest signifikanta "
"biten och där nämnaren är en tvåpotens.  I fallet 1/10 är det binära bråket "
"``3602879701896397 / 2 ** 55``, vilket är nära men inte exakt lika med det "
"sanna värdet 1/10."

msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display::"
msgstr ""
"Många användare är inte medvetna om approximationen på grund av hur värdena "
"visas.  Python skriver bara ut en decimal approximation av det sanna "
"decimalvärdet av den binära approximationen som lagras av maskinen.  Om "
"Python skulle skriva ut det sanna decimalvärdet för den binära approximation "
"som lagrats för 0,1, skulle det på de flesta maskiner behöva visa::"

msgid ""
">>> 0.1\n"
"0.1000000000000000055511151231257827021181583404541015625"
msgstr ""
">>> 0.1\n"
"0.1000000000000000055511151231257827021181583404541015625"

msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead:"
msgstr ""
"Det är fler siffror än de flesta tycker är användbart, så Python håller "
"antalet siffror hanterbart genom att visa ett avrundat värde istället:"

msgid ""
">>> 1 / 10\n"
"0.1"
msgstr ""
">>> 1 / 10\n"
"0.1"

msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"Kom ihåg att även om det utskrivna resultatet ser ut som det exakta värdet "
"av 1/10, är det faktiska lagrade värdet det närmaste representerbara binära "
"bråket."

msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Intressant nog finns det många olika decimaltal som delar samma närmaste "
"approximativa binära fraktion.  Till exempel approximeras siffrorna ``0,1`` "
"och ``0,10000000000000001`` och "
"``0,1000000000000000055511151231257827021181583404541015625`` alla av "
"``3602879701896397 / 2 ** 55``.  Eftersom alla dessa decimalvärden har samma "
"approximation kan vilket som helst av dem visas samtidigt som invariansen "
"``eval(repr(x)) == x`` bevaras."

msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"Historiskt sett har Pythons prompt och den inbyggda funktionen :func:`repr` "
"valt den med 17 signifikanta siffror, ``0.10000000000000001``.   Från och "
"med Python 3.1 kan Python (på de flesta system) nu välja det kortaste av "
"dessa och helt enkelt visa ``0.1``."

msgid ""
"Note that this is in the very nature of binary floating point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Observera att detta ligger i själva naturen för binärt flyttal: detta är "
"inte en bugg i Python, och det är inte heller en bugg i din kod.  Du kommer "
"att se samma sak i alla språk som stöder din hårdvaras aritmetik med flyttal "
"(även om vissa språk kanske inte *visar* skillnaden som standard eller i "
"alla utdatalägen)."

msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits:"
msgstr ""
"Om du vill ha en trevligare utmatning kan du använda strängformatering för "
"att få fram ett begränsat antal signifikanta siffror:"

msgid ""
">>> format(math.pi, '.12g')  # give 12 significant digits\n"
"'3.14159265359'\n"
"\n"
">>> format(math.pi, '.2f')   # give 2 digits after the point\n"
"'3.14'\n"
"\n"
">>> repr(math.pi)\n"
"'3.141592653589793'"
msgstr ""
">>> format(math.pi, '.12g') # ger 12 signifikanta siffror\n"
"'3.14159265359'\n"
"\n"
">>> format(math.pi, '.2f') # ge 2 siffror efter punkten\n"
"'3.14'\n"
"\n"
">>> repr(math.pi)\n"
"'3.141592653589793'"

msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr ""
"Det är viktigt att inse att detta i själva verket är en illusion: du "
"avrundar helt enkelt *displayen* av det verkliga maskinvärdet."

msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either:"
msgstr ""
"En illusion kan ge upphov till en annan.  Eftersom 0,1 till exempel inte är "
"exakt 1/10, kan summan av tre värden av 0,1 inte heller ge exakt 0,3:"

msgid ""
">>> 0.1 + 0.1 + 0.1 == 0.3\n"
"False"
msgstr ""
">>> 0.1 + 0.1 + 0.1 == 0.3\n"
"Falskt"

msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help:"
msgstr ""
"Eftersom 0,1 inte kan komma närmare det exakta värdet av 1/10 och 0,3 inte "
"kan komma närmare det exakta värdet av 3/10, kan förrundning med funktionen :"
"func:`round` inte heller hjälpa:"

msgid ""
">>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\n"
"False"
msgstr ""
">>> round(0,1, 1) + round(0,1, 1) + round(0,1, 1) == round(0,3, 1)\n"
"Falsk"

msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`math.isclose` function can be useful for comparing inexact values:"
msgstr ""
"Även om talen inte kan göras närmare sina avsedda exakta värden, kan "
"funktionen :func:`math.isclose` vara användbar för att jämföra inexakta "
"värden:"

msgid ""
">>> math.isclose(0.1 + 0.1 + 0.1, 0.3)\n"
"True"
msgstr ""
">>> math.isclose(0,1 + 0,1 + 0,1, 0,3)\n"
"Sant"

msgid ""
"Alternatively, the :func:`round` function can be used to compare rough "
"approximations:"
msgstr ""
"Alternativt kan funktionen :func:`round` användas för att jämföra grova "
"approximationer:"

msgid ""
">>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\n"
"True"
msgstr ""
">>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\n"
"Sant"

msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `Examples of Floating Point Problems "
"<https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/>`_ for "
"a pleasant summary of how binary floating point works and the kinds of "
"problems commonly encountered in practice.  Also see `The Perils of Floating "
"Point <http://www.indowsway.com/floatingpoint.htm>`_ for a more complete "
"account of other common surprises."
msgstr ""
"Binär aritmetik med flyttal innehåller många överraskningar som denna.  "
"Problemet med \"0,1\" förklaras i detalj nedan, i avsnittet \"Representation "
"Error\".  Se `Exempel på flyttalsproblem <https://jvns.ca/blog/2023/01/13/"
"examples-of-floating-point-problems/>`_ för en trevlig sammanfattning av hur "
"binär flyttalsaritmetik fungerar och vilka typer av problem som är vanliga i "
"praktiken.  Se även `The Perils of Floating Point <http://www.indowsway.com/"
"floatingpoint.htm>`_ för en mer fullständig redogörelse för andra vanliga "
"överraskningar."

msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Som det står i slutet: \"Det finns inga enkla svar.\"  Var ändå inte onödigt "
"försiktig med flyttal!  Felen i Pythons flyttalsoperationer ärvs från "
"flyttalshårdvaran, och på de flesta maskiner är de i storleksordningen högst "
"1 del i 2\\*\\*53 per operation.  Det är mer än tillräckligt för de flesta "
"uppgifter, men du måste komma ihåg att det inte är decimalaritmetik och att "
"varje flyttalsoperation kan drabbas av ett nytt avrundningsfel."

msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Även om patologiska fall finns, för de flesta vardaglig användning av "
"flyttalsaritmetik du kommer att se det resultat du förväntar dig i slutändan "
"om du helt enkelt avrunda visningen av dina slutresultat till antalet "
"decimaler du förväntar dig. :func:`str` oftast räcker, och för finare "
"kontroll se :meth:`str.format` metodens format specificerare i :ref:"
"`formatstrings`."

msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"För användningsfall som kräver exakt decimal representation, försök använda "
"modulen :mod:`decimal` som implementerar decimal aritmetik som är lämplig "
"för redovisningstillämpningar och högprecisionstillämpningar."

msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"En annan form av exakt aritmetik stöds av modulen :mod:`fractions` som "
"implementerar aritmetik baserad på rationella tal (så att tal som 1/3 kan "
"representeras exakt)."

msgid ""
"If you are a heavy user of floating-point operations you should take a look "
"at the NumPy package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"Om du är en flitig användare av flyttalsoperationer bör du ta en titt på "
"NumPy-paketet och många andra paket för matematiska och statistiska "
"operationer som tillhandahålls av SciPy-projektet. Se <https://scipy.org>."

msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction:"
msgstr ""
"Python tillhandahåller verktyg som kan hjälpa till vid de sällsynta "
"tillfällen då du verkligen *vill* veta det exakta värdet av en float.  "
"Metoden :meth:`float.as_integer_ratio` uttrycker värdet av en float som ett "
"bråk:"

msgid ""
">>> x = 3.14159\n"
">>> x.as_integer_ratio()\n"
"(3537115888337719, 1125899906842624)"
msgstr ""
">>> x = 3.14159\n"
">>> x.as_integer_ratio()\n"
"(3537115888337719, 1125899906842624)"

msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value:"
msgstr ""
"Eftersom förhållandet är exakt kan det användas för att förlustfritt "
"återskapa originalvärdet:"

msgid ""
">>> x == 3537115888337719 / 1125899906842624\n"
"True"
msgstr ""
">>> x == 3537115888337719 / 1125899906842624\n"
"Sant"

msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer:"
msgstr ""
"Metoden :meth:`float.hex` uttrycker en float i hexadecimal (bas 16), vilket "
"återigen ger det exakta värde som lagras av din dator:"

msgid ""
">>> x.hex()\n"
"'0x1.921f9f01b866ep+1'"
msgstr ""
">>> x.hex()\n"
"'0x1.921f9f01b866ep+1'"

msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly:"
msgstr ""
"Denna exakta hexadecimala representation kan användas för att rekonstruera "
"floatvärdet exakt:"

msgid ""
">>> x == float.fromhex('0x1.921f9f01b866ep+1')\n"
"True"
msgstr ""
">>> x == float.fromhex('0x1.921f9f01b866ep+1')\n"
"Sant"

msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"Eftersom representationen är exakt är den användbar för att på ett "
"tillförlitligt sätt överföra värden mellan olika versioner av Python "
"(plattformsoberoende) och utbyta data med andra språk som stöder samma "
"format (t.ex. Java och C99)."

msgid ""
"Another helpful tool is the :func:`sum` function which helps mitigate loss-"
"of-precision during summation.  It uses extended precision for intermediate "
"rounding steps as values are added onto a running total. That can make a "
"difference in overall accuracy so that the errors do not accumulate to the "
"point where they affect the final total:"
msgstr ""
"Ett annat användbart verktyg är funktionen :func:`sum` som hjälper till att "
"minska precisionsförlusten vid summering.  Den använder utökad precision för "
"mellanliggande avrundningssteg när värden läggs till i en löpande "
"totalsumma. Det kan göra skillnad för den totala noggrannheten så att felen "
"inte ackumuleras till den punkt där de påverkar den slutliga totalsumman:"

msgid ""
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False\n"
">>> sum([0.1] * 10) == 1.0\n"
"True"
msgstr ""
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"Falsk\n"
">>> sum([0,1] * 10) == 1,0\n"
"Sant"

msgid ""
"The :func:`math.fsum` goes further and tracks all of the \"lost digits\" as "
"values are added onto a running total so that the result has only a single "
"rounding.  This is slower than :func:`sum` but will be more accurate in "
"uncommon cases where large magnitude inputs mostly cancel each other out "
"leaving a final sum near zero:"
msgstr ""
":func:`math.fsum` går längre och spårar alla \"förlorade siffror\" när "
"värden läggs till en löpande summa så att resultatet bara har en enda "
"avrundning.  Detta är långsammare än :func:`sum` men kommer att vara mer "
"exakt i ovanliga fall där stora ingångsvärden mestadels upphäver varandra "
"och ger en slutlig summa nära noll:"

msgid ""
">>> arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,\n"
"...        -143401161400469.7, 266262841.31058735, -0.003244936839808227]\n"
">>> float(sum(map(Fraction, arr)))   # Exact summation with single rounding\n"
"8.042173697819788e-13\n"
">>> math.fsum(arr)                   # Single rounding\n"
"8.042173697819788e-13\n"
">>> sum(arr)                         # Multiple roundings in extended "
"precision\n"
"8.042178034628478e-13\n"
">>> total = 0.0\n"
">>> for x in arr:\n"
"...     total += x                   # Multiple roundings in standard "
"precision\n"
"...\n"
">>> total                            # Straight addition has no correct "
"digits!\n"
"-0.0051575902860057365"
msgstr ""
">>> arr = [-0,10430216751806065, -266310978,67179024, 143401161448607,16,\n"
"...        -143401161400469.7, 266262841.31058735, -0.003244936839808227]\n"
">>> float(sum(map(Fraktion, arr))))   # Exakt summering med en enda "
"avrundning\n"
"8.042173697819788e-13\n"
">>> math.fsum(arr) # Enkel avrundning\n"
"8.042173697819788e-13\n"
">>> sum(arr) # Flera avrundningar med utökad precision\n"
"8.042178034628478e-13\n"
">>> total = 0,0\n"
">>> för x i arr:\n"
"... total += x # Multipla avrundningar med standardprecision\n"
"...\n"
">>> total # Rak addition har inga korrekta siffror!\n"
"-0.0051575902860057365"

msgid "Representation Error"
msgstr "Representation Fel"

msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"I detta avsnitt förklaras exemplet \"0,1\" i detalj och det visas hur du "
"själv kan utföra en exakt analys av fall som detta.  Grundläggande kännedom "
"om binär flyttalsrepresentation förutsätts."

msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
":dfn:`Representation error` hänvisar till det faktum att vissa (de flesta, "
"faktiskt) decimalfraktioner inte kan representeras exakt som binära (bas 2) "
"fraktioner. Detta är den främsta anledningen till att Python (eller Perl, C, "
"C++, Java, Fortran och många andra) ofta inte visar det exakta decimaltal du "
"förväntar dig."

msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction.  Since "
"at least 2000, almost all machines use IEEE 754 binary floating-point "
"arithmetic, and almost all platforms map Python floats to IEEE 754 binary64 "
"\"double precision\" values.  IEEE 754 binary64 values contain 53 bits of "
"precision, so on input the computer strives to convert 0.1 to the closest "
"fraction it can of the form *J*/2**\\ *N* where *J* is an integer containing "
"exactly 53 bits. Rewriting ::"
msgstr ""
"Varför är det så?  1/10 är inte exakt representerbar som en binär fraktion.  "
"Sedan åtminstone år 2000 använder nästan alla maskiner IEEE 754 binär "
"aritmetik med flyttal och nästan alla plattformar mappar Python-flottal till "
"IEEE 754 binär64-värden med \"dubbel precision\".  IEEE 754 binary64-värden "
"innehåller 53 bitars precision, så vid inmatning strävar datorn efter att "
"konvertera 0,1 till det närmaste bråket den kan av formen *J*/2**\\ *N* där "
"*J* är ett heltal som innehåller exakt 53 bitar. Omskrivning ::"

msgid "1 / 10 ~= J / (2**N)"
msgstr "1 / 10 ~= J / (2**N)"

msgid "as ::"
msgstr "som ::"

msgid "J ~= 2**N / 10"
msgstr "J ~= 2**N / 10"

msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56:"
msgstr ""
"och med tanke på att *J* har exakt 53 bitar (är ``>= 2**52`` men ``< "
"2**53``), är det bästa värdet för *N* 56:"

msgid ""
">>> 2**52 <=  2**56 // 10  < 2**53\n"
"True"
msgstr ""
">>> 2**52 <= 2**56 // 10 < 2**53\n"
"Sant"

msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded:"
msgstr ""
"Det vill säga 56 är det enda värdet för *N* som gör att *J* har exakt 53 "
"bitar.  Det bästa möjliga värdet för *J* är då denna kvot avrundad:"

msgid ""
">>> q, r = divmod(2**56, 10)\n"
">>> r\n"
"6"
msgstr ""
">>> q, r = divmod(2**56, 10)\n"
">>> r\n"
"6"

msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up:"
msgstr ""
"Eftersom återstoden är mer än hälften av 10 erhålls den bästa "
"approximationen genom att avrunda uppåt:"

msgid ""
">>> q+1\n"
"7205759403792794"
msgstr ""
">>> q+1\n"
"7205759403792794"

msgid ""
"Therefore the best possible approximation to 1/10 in IEEE 754 double "
"precision is::"
msgstr ""
"Därför är den bästa möjliga approximationen av 1/10 i IEEE 754 dubbel "
"precision::"

msgid "7205759403792794 / 2 ** 56"
msgstr "7205759403792794 / 2 ** 56"

msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr ""
"Genom att dividera både täljaren och nämnaren med två minskar bråket till::"

msgid "3602879701896397 / 2 ** 55"
msgstr "3602879701896397 / 2 ** 55"

msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Observera att eftersom vi avrundade uppåt är detta faktiskt lite större än "
"1/10; om vi inte hade avrundat uppåt skulle kvoten ha varit lite mindre än "
"1/10.  Men det kan inte i något fall vara *exakt* 1/10!"

msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best IEEE 754 double approximation it can get:"
msgstr ""
"Så datorn \"ser\" aldrig 1/10: vad den ser är den exakta fraktionen som "
"anges ovan, den bästa IEEE 754-dubbelapproximationen som den kan få:"

msgid ""
">>> 0.1 * 2 ** 55\n"
"3602879701896397.0"
msgstr ""
">>> 0.1 * 2 ** 55\n"
"3602879701896397.0"

msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits:"
msgstr ""
"Om vi multiplicerar bråket med 10\\*\\*55 kan vi se värdet med 55 decimalers "
"noggrannhet:"

msgid ""
">>> 3602879701896397 * 10 ** 55 // 2 ** 55\n"
"1000000000000000055511151231257827021181583404541015625"
msgstr ""
">>> 3602879701896397 * 10 ** 55 // 2 ** 55\n"
"1000000000000000055511151231257827021181583404541015625"

msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits:"
msgstr ""
"vilket innebär att det exakta talet som lagras i datorn är lika med "
"decimalvärdet 0,1000000000000000055511151231257827021181583404541015625. "
"Istället för att visa hela decimalvärdet avrundar många språk (inklusive "
"äldre versioner av Python) resultatet till 17 signifikanta siffror:"

msgid ""
">>> format(0.1, '.17f')\n"
"'0.10000000000000001'"
msgstr ""
">>> format(0,1, '.17f')\n"
"'0.10000000000000001'"

msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations easy:"
msgstr ""
"Modulerna :mod:`fractions` och :mod:`decimal` gör dessa beräkningar enkla:"

msgid ""
">>> from decimal import Decimal\n"
">>> from fractions import Fraction\n"
"\n"
">>> Fraction.from_float(0.1)\n"
"Fraction(3602879701896397, 36028797018963968)\n"
"\n"
">>> (0.1).as_integer_ratio()\n"
"(3602879701896397, 36028797018963968)\n"
"\n"
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
"\n"
">>> format(Decimal.from_float(0.1), '.17')\n"
"'0.10000000000000001'"
msgstr ""
">>> from decimal import Decimal\n"
">>> from fractions import Fraction\n"
"\n"
">>> Fraction.from_float(0.1)\n"
"Fraction(3602879701896397, 36028797018963968)\n"
"\n"
">>> (0.1).as_integer_ratio()\n"
"(3602879701896397, 36028797018963968)\n"
"\n"
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
"\n"
">>> format(Decimal.from_float(0.1), '.17')\n"
"'0.10000000000000001'"
