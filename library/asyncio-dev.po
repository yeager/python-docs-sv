# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Developing with asyncio"
msgstr "Utveckla med asyncio"

msgid ""
"Asynchronous programming is different from classic \"sequential\" "
"programming."
msgstr ""
"Asynkron programmering skiljer sig från klassisk \"sekventiell\" "
"programmering."

msgid ""
"This page lists common mistakes and traps and explains how to avoid them."
msgstr ""
"På den här sidan listas vanliga misstag och fällor och det förklaras hur man "
"undviker dem."

msgid "Debug Mode"
msgstr "Felsökningsläge"

msgid ""
"By default asyncio runs in production mode.  In order to ease the "
"development asyncio has a *debug mode*."
msgstr ""
"Som standard körs asyncio i produktionsläge.  För att underlätta "
"utvecklingen har asyncio ett *debuggläge*."

msgid "There are several ways to enable asyncio debug mode:"
msgstr "Det finns flera sätt att aktivera felsökningsläget för asyncio:"

msgid "Setting the :envvar:`PYTHONASYNCIODEBUG` environment variable to ``1``."
msgstr "Miljövariabeln :envvar:`PYTHONASYNCIODEBUG` sätts till ``1``."

msgid "Using the :ref:`Python Development Mode <devmode>`."
msgstr "Använda :ref:`Python Development Mode <devmode>`."

msgid "Passing ``debug=True`` to :func:`asyncio.run`."
msgstr "Överlämnar ``debug=True`` till :func:`asyncio.run`."

msgid "Calling :meth:`loop.set_debug`."
msgstr "Anropar :meth:`loop.set_debug`."

msgid "In addition to enabling the debug mode, consider also:"
msgstr "Förutom att aktivera felsökningsläget bör du också överväga:"

msgid ""
"setting the log level of the :ref:`asyncio logger <asyncio-logger>` to :py:"
"const:`logging.DEBUG`, for example the following snippet of code can be run "
"at startup of the application::"
msgstr ""
"ställa in loggnivån för :ref:`asyncio logger <asyncio-logger>` till :py:"
"const:`logging.DEBUG`, till exempel kan följande kodavsnitt köras vid start "
"av applikationen::"

msgid "logging.basicConfig(level=logging.DEBUG)"
msgstr "logging.basicConfig(level=logging.DEBUG)"

msgid ""
"configuring the :mod:`warnings` module to display :exc:`ResourceWarning` "
"warnings.  One way of doing that is by using the :option:`-W` ``default`` "
"command line option."
msgstr ""
"konfigurera modulen :mod:`warnings` så att den visar :exc:`ResourceWarning`-"
"varningar.  Ett sätt att göra det är att använda kommandoradsalternativet :"
"option:`-W` ``default``."

msgid "When the debug mode is enabled:"
msgstr "När felsökningsläget är aktiverat:"

msgid ""
"Many non-threadsafe asyncio APIs (such as :meth:`loop.call_soon` and :meth:"
"`loop.call_at` methods) raise an exception if they are called from a wrong "
"thread."
msgstr ""
"Många asyncio API:er som inte är trådlösa (t.ex. metoderna :meth:`loop."
"call_soon` och :meth:`loop.call_at`) ger upphov till ett undantag om de "
"anropas från fel tråd."

msgid ""
"The execution time of the I/O selector is logged if it takes too long to "
"perform an I/O operation."
msgstr ""
"I/O-väljarens exekveringstid loggas om det tar för lång tid att utföra en I/"
"O-operation."

msgid ""
"Callbacks taking longer than 100 milliseconds are logged.  The :attr:`loop."
"slow_callback_duration` attribute can be used to set the minimum execution "
"duration in seconds that is considered \"slow\"."
msgstr ""
"Återkallelser som tar längre tid än 100 millisekunder loggas.  Attributet :"
"attr:`loop.slow_callback_duration` kan användas för att ange den minsta "
"exekveringstid i sekunder som anses vara \"långsam\"."

msgid "Concurrency and Multithreading"
msgstr "Samtidighet och multithreading"

msgid ""
"An event loop runs in a thread (typically the main thread) and executes all "
"callbacks and Tasks in its thread.  While a Task is running in the event "
"loop, no other Tasks can run in the same thread.  When a Task executes an "
"``await`` expression, the running Task gets suspended, and the event loop "
"executes the next Task."
msgstr ""
"En händelseslinga körs i en tråd (vanligtvis huvudtråden) och utför alla "
"callbacks och Tasks i sin tråd.  Medan en uppgift körs i händelseslingan kan "
"inga andra uppgifter köras i samma tråd.  När en uppgift utför ett ``await``-"
"uttryck avbryts den pågående uppgiften och händelseslingan utför nästa "
"uppgift."

msgid ""
"To schedule a :term:`callback` from another OS thread, the :meth:`loop."
"call_soon_threadsafe` method should be used. Example::"
msgstr ""
"För att schemalägga en :term:`callback` från en annan OS-tråd bör metoden :"
"meth:`loop.call_soon_threadsafe` användas. Exempel::"

msgid "loop.call_soon_threadsafe(callback, *args)"
msgstr "loop.call_soon_threadsafe(callback, *args)"

msgid ""
"Almost all asyncio objects are not thread safe, which is typically not a "
"problem unless there is code that works with them from outside of a Task or "
"a callback.  If there's a need for such code to call a low-level asyncio "
"API, the :meth:`loop.call_soon_threadsafe` method should be used, e.g.::"
msgstr ""
"Nästan alla asyncio-objekt är inte trådsäkra, vilket vanligtvis inte är ett "
"problem om det inte finns kod som arbetar med dem utanför en Task eller en "
"callback.  Om det finns ett behov för sådan kod att anropa ett asyncio API "
"på låg nivå, bör metoden :meth:`loop.call_soon_threadsafe` användas, t.ex.::"

msgid "loop.call_soon_threadsafe(fut.cancel)"
msgstr "loop.call_soon_threadsafe(fut.cancel)"

msgid ""
"To schedule a coroutine object from a different OS thread, the :func:"
"`run_coroutine_threadsafe` function should be used. It returns a :class:"
"`concurrent.futures.Future` to access the result::"
msgstr ""
"För att schemalägga ett coroutine-objekt från en annan OS-tråd bör "
"funktionen :func:`run_coroutine_threadsafe` användas. Den returnerar en :"
"class:`concurrent.futures.Future` för att komma åt resultatet::"

msgid ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Later in another OS thread:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Wait for the result:\n"
"result = future.result()"
msgstr ""
"async def coro_func():\n"
"     return await asyncio.sleep(1, 42)\n"
"\n"
"# Later in another OS thread:\n"
"\n"
"future = asyncio.run_coroutine_threadsafe(coro_func(), loop)\n"
"# Wait for the result:\n"
"result = future.result()"

msgid "To handle signals the event loop must be run in the main thread."
msgstr "För att hantera signaler måste händelseslingan köras i huvudtråden."

msgid ""
"The :meth:`loop.run_in_executor` method can be used with a :class:"
"`concurrent.futures.ThreadPoolExecutor` or :class:`~concurrent.futures."
"InterpreterPoolExecutor` to execute blocking code in a different OS thread "
"without blocking the OS thread that the event loop runs in."
msgstr ""
"Metoden :meth:`loop.run_in_executor` kan användas med en :class:`concurrent."
"futures.ThreadPoolExecutor` eller :class:`~concurrent.futures."
"InterpreterPoolExecutor` för att köra blockerande kod i en annan OS-tråd "
"utan att blockera den OS-tråd som händelseslingan körs i."

msgid ""
"There is currently no way to schedule coroutines or callbacks directly from "
"a different process (such as one started with :mod:`multiprocessing`). The :"
"ref:`asyncio-event-loop-methods` section lists APIs that can read from pipes "
"and watch file descriptors without blocking the event loop. In addition, "
"asyncio's :ref:`Subprocess <asyncio-subprocess>` APIs provide a way to start "
"a process and communicate with it from the event loop. Lastly, the "
"aforementioned :meth:`loop.run_in_executor` method can also be used with a :"
"class:`concurrent.futures.ProcessPoolExecutor` to execute code in a "
"different process."
msgstr ""
"Det finns för närvarande inget sätt att schemalägga coroutines eller "
"callbacks direkt från en annan process (t.ex. en process som startats med :"
"mod:`multiprocessing`). Avsnittet :ref:`asyncio-event-loop-methods` listar "
"API:er som kan läsa från rör och titta på filbeskrivare utan att blockera "
"händelseslingan. Dessutom ger asyncios API:er :ref:`Subprocess <asyncio-"
"subprocess>` ett sätt att starta en process och kommunicera med den från "
"händelseslingan. Slutligen kan den tidigare nämnda :meth:`loop."
"run_in_executor`-metoden också användas med en :class:`concurrent.futures."
"ProcessPoolExecutor` för att exekvera kod i en annan process."

msgid "Running Blocking Code"
msgstr "Körning av blockerande kod"

msgid ""
"Blocking (CPU-bound) code should not be called directly.  For example, if a "
"function performs a CPU-intensive calculation for 1 second, all concurrent "
"asyncio Tasks and IO operations would be delayed by 1 second."
msgstr ""
"Blockerande (CPU-bunden) kod bör inte anropas direkt.  Om en funktion t.ex. "
"utför en CPU-intensiv beräkning under 1 sekund, kommer alla samtidiga "
"asyncio Tasks och IO-operationer att försenas med 1 sekund."

msgid ""
"An executor can be used to run a task in a different thread, including in a "
"different interpreter, or even in a different process to avoid blocking the "
"OS thread with the event loop.  See the :meth:`loop.run_in_executor` method "
"for more details."
msgstr ""
"En executor kan användas för att köra en uppgift i en annan tråd, inklusive "
"i en annan tolk, eller till och med i en annan process för att undvika att "
"blockera OS-tråden med händelseslingan.  Se metoden :meth:`loop."
"run_in_executor` för mer information."

msgid "Logging"
msgstr "Loggning"

msgid ""
"asyncio uses the :mod:`logging` module and all logging is performed via the "
"``\"asyncio\"`` logger."
msgstr ""
"asyncio använder modulen :mod:`logging` och all loggning sker via loggern "
"``\"asyncio\"``."

msgid ""
"The default log level is :py:const:`logging.INFO`, which can be easily "
"adjusted::"
msgstr ""
"Standardloggnivån är :py:const:`logging.INFO`, som enkelt kan justeras::"

msgid "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"
msgstr "logging.getLogger(\"asyncio\").setLevel(logging.WARNING)"

msgid ""
"Network logging can block the event loop. It is recommended to use a "
"separate thread for handling logs or use non-blocking IO. For example, see :"
"ref:`blocking-handlers`."
msgstr ""
"Nätverksloggning kan blockera händelseslingan. Vi rekommenderar att du "
"använder en separat tråd för att hantera loggar eller använder icke-"
"blockerande IO. Se till exempel :ref:`blocking-handlers`."

msgid "Detect never-awaited coroutines"
msgstr "Upptäck aldrig efterlängtade coroutines"

msgid ""
"When a coroutine function is called, but not awaited (e.g. ``coro()`` "
"instead of ``await coro()``) or the coroutine is not scheduled with :meth:"
"`asyncio.create_task`, asyncio will emit a :exc:`RuntimeWarning`::"
msgstr ""
"När en coroutine-funktion anropas, men inte väntar (t.ex. ``coro()`` "
"istället för ``await coro()``) eller coroutinen inte schemaläggs med :meth:"
"`asyncio.create_task`, kommer asyncio att avge en :exc:`RuntimeWarning`::"

msgid ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def test():\n"
"    print(\"never scheduled\")\n"
"\n"
"async def main():\n"
"    test()\n"
"\n"
"asyncio.run(main())"

msgid "Output::"
msgstr "Utgång::"

msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"  test()"

msgid "Output in debug mode::"
msgstr "Utdata i felsökningsläge::"

msgid ""
"test.py:7: RuntimeWarning: coroutine 'test' was never awaited\n"
"Coroutine created at (most recent call last)\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"  < .. >\n"
"\n"
"  File \"../t.py\", line 7, in main\n"
"    test()\n"
"  test()"
msgstr ""
"test.py:7: RuntimeWarning: Coroutine 'test' var aldrig väntad\n"
"Coroutine skapad vid (senaste anropet senast)\n"
"  Fil \"../t.py\", rad 9, i <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
" < .. >\n"
"\n"
"  Fil \"../t.py\", rad 7, i main\n"
"    test()\n"
"  test()"

msgid ""
"The usual fix is to either await the coroutine or call the :meth:`asyncio."
"create_task` function::"
msgstr ""
"Den vanliga lösningen är att antingen vänta på coroutinen eller anropa "
"funktionen :meth:`asyncio.create_task`::"

msgid ""
"async def main():\n"
"    await test()"
msgstr ""
"async def main():\n"
"    await test()"

msgid "Detect never-retrieved exceptions"
msgstr "Upptäck undantag som aldrig hämtats"

msgid ""
"If a :meth:`Future.set_exception` is called but the Future object is never "
"awaited on, the exception would never be propagated to the user code.  In "
"this case, asyncio would emit a log message when the Future object is "
"garbage collected."
msgstr ""
"Om en :meth:`Future.set_exception` anropas men Future-objektet aldrig blir "
"väntat på, kommer undantaget aldrig att spridas till användarkoden.  I detta "
"fall skulle asyncio skicka ut ett loggmeddelande när Future-objektet samlas "
"in."

msgid "Example of an unhandled exception::"
msgstr "Exempel på ett ohanterat undantag::"

msgid ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def bug():\n"
"    raise Exception(\"not consumed\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(bug())\n"
"\n"
"asyncio.run(main())"

msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"  exception=Exception('not consumed')>\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"test.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Uppgiftsundantaget hämtades aldrig\n"
"i framtiden: <Uppgift slutförd coro=<bug() utförd, definierad vid test."
"py:3>\n"
"  exception=Undantag('inte förbrukad')>\n"
"\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"test.py\", rad 4, i bug\n"
"    raise Undantag(\"inte förbrukad\")\n"
"Undantag: inte förbrukad"

msgid ""
":ref:`Enable the debug mode <asyncio-debug-mode>` to get the traceback where "
"the task was created::"
msgstr ""
":ref:`Aktivera felsökningsläget <asyncio-debug-mode>` för att få en spårning "
"av var uppgiften skapades::"

msgid "asyncio.run(main(), debug=True)"
msgstr "asyncio.run(main(), debug=True)"

msgid ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
msgstr ""
"Task exception was never retrieved\n"
"future: <Task finished coro=<bug() done, defined at test.py:3>\n"
"    exception=Exception('not consumed') created at asyncio/tasks.py:321>\n"
"\n"
"source_traceback: Object created at (most recent call last):\n"
"  File \"../t.py\", line 9, in <module>\n"
"    asyncio.run(main(), debug=True)\n"
"\n"
"< .. >\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"../t.py\", line 4, in bug\n"
"    raise Exception(\"not consumed\")\n"
"Exception: not consumed"
