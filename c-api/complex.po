# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Complex Number Objects"
msgstr "Objekt för komplexa tal"

msgid ""
"Python's complex number objects are implemented as two distinct types when "
"viewed from the C API:  one is the Python object exposed to Python programs, "
"and the other is a C structure which represents the actual complex number "
"value. The API provides functions for working with both."
msgstr ""
"Pythons komplexa talobjekt implementeras som två olika typer när de "
"betraktas från C API: en är Python-objektet som exponeras för Python-"
"program, och den andra är en C-struktur som representerar det faktiska "
"komplexa talvärdet. API:et tillhandahåller funktioner för att arbeta med "
"båda."

msgid "Complex Numbers as C Structures"
msgstr "Komplexa tal som C-strukturer"

msgid ""
"Note that the functions which accept these structures as parameters and "
"return them as results do so *by value* rather than dereferencing them "
"through pointers.  This is consistent throughout the API."
msgstr ""
"Observera att de funktioner som accepterar dessa strukturer som parametrar "
"och returnerar dem som resultat gör det *med värde* i stället för att "
"dereferencera dem via pekare.  Detta är konsekvent i hela API:et."

msgid ""
"The C structure which corresponds to the value portion of a Python complex "
"number object.  Most of the functions for dealing with complex number "
"objects use structures of this type as input or output values, as "
"appropriate."
msgstr ""
"Den C-struktur som motsvarar värdedelen av ett Python-objekt med komplexa "
"tal.  De flesta funktioner för att hantera komplexa talobjekt använder "
"strukturer av denna typ som in- eller utvärden, beroende på vad som är "
"lämpligt."

msgid "The structure is defined as::"
msgstr "Strukturen definieras som::"

msgid ""
"typedef struct {\n"
"    double real;\n"
"    double imag;\n"
"} Py_complex;"
msgstr ""
"typedef struct {\n"
"    dubbel real;\n"
"    dubbel imag;\n"
"} Py_complex;"

msgid ""
"Return the sum of two complex numbers, using the C :c:type:`Py_complex` "
"representation."
msgstr ""
"Returnerar summan av två komplexa tal, med C :c:type:`Py_complex`-"
"representationen."

msgid ""
"Return the difference between two complex numbers, using the C :c:type:"
"`Py_complex` representation."
msgstr ""
"Returnerar skillnaden mellan två komplexa tal, med C :c:type:`Py_complex`-"
"representationen."

msgid ""
"Return the negation of the complex number *num*, using the C :c:type:"
"`Py_complex` representation."
msgstr ""
"Returnerar negationen av det komplexa talet *num*, med C :c:type:"
"`Py_complex`-representationen."

msgid ""
"Return the product of two complex numbers, using the C :c:type:`Py_complex` "
"representation."
msgstr ""
"Returnerar produkten av två komplexa tal, med C :c:type:`Py_complex`-"
"representationen."

msgid ""
"Return the quotient of two complex numbers, using the C :c:type:`Py_complex` "
"representation."
msgstr ""
"Returnerar kvoten av två komplexa tal, med C :c:type:`Py_complex`-"
"representationen."

msgid ""
"If *divisor* is null, this method returns zero and sets :c:data:`errno` to :"
"c:macro:`!EDOM`."
msgstr ""
"Om *divisor* är null, returnerar denna metod noll och sätter :c:data:`errno` "
"till :c:macro:`!EDOM`."

msgid ""
"Return the exponentiation of *num* by *exp*, using the C :c:type:"
"`Py_complex` representation."
msgstr ""
"Returnerar exponentiering av *num* med *exp*, med C :c:type:`Py_complex`-"
"representationen."

msgid ""
"If *num* is null and *exp* is not a positive real number, this method "
"returns zero and sets :c:data:`errno` to :c:macro:`!EDOM`."
msgstr ""
"Om *num* är null och *exp* inte är ett positivt reellt tal, returnerar denna "
"metod noll och sätter :c:data:`errno` till :c:macro:`!EDOM`."

msgid "Set :c:data:`errno` to :c:macro:`!ERANGE` on overflows."
msgstr "Sätt :c:data:`errno` till :c:macro:`!ERANGE` vid överskridanden."

msgid "Complex Numbers as Python Objects"
msgstr "Komplexa tal som Python-objekt"

msgid ""
"This subtype of :c:type:`PyObject` represents a Python complex number object."
msgstr ""
"Denna subtyp av :c:type:`PyObject` representerar ett Python-objekt med "
"komplexa tal."

msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python complex number "
"type. It is the same object as :class:`complex` in the Python layer."
msgstr ""
"Denna instans av :c:type:`PyTypeObject` representerar Pythons komplexa "
"taltyp. Det är samma objekt som :class:`complex` i Python-lagret."

msgid ""
"Return true if its argument is a :c:type:`PyComplexObject` or a subtype of :"
"c:type:`PyComplexObject`.  This function always succeeds."
msgstr ""
"Returnerar true om dess argument är ett :c:type:`PyComplexObject` eller en "
"subtyp av :c:type:`PyComplexObject`.  Denna funktion lyckas alltid."

msgid ""
"Return true if its argument is a :c:type:`PyComplexObject`, but not a "
"subtype of :c:type:`PyComplexObject`.  This function always succeeds."
msgstr ""
"Returnerar true om dess argument är ett :c:type:`PyComplexObject`, men inte "
"en subtyp av :c:type:`PyComplexObject`.  Denna funktion lyckas alltid."

msgid ""
"Create a new Python complex number object from a C :c:type:`Py_complex` "
"value. Return ``NULL`` with an exception set on error."
msgstr ""
"Skapar ett nytt Python-komplext talobjekt från ett C :c:type:`Py_complex`-"
"värde. Returnerar ``NULL`` med en undantagsuppsättning vid fel."

msgid ""
"Return a new :c:type:`PyComplexObject` object from *real* and *imag*. Return "
"``NULL`` with an exception set on error."
msgstr ""
"Returnerar ett nytt :c:type:`PyComplexObject`-objekt från *real* och *imag*. "
"Returnerar ``NULL`` med en undantagsuppsättning vid fel."

msgid "Return the real part of *op* as a C :c:expr:`double`."
msgstr "Returnera den reella delen av *op* som en C :c:expr:`double`."

msgid ""
"If *op* is not a Python complex number object but has a :meth:`~object."
"__complex__` method, this method will first be called to convert *op* to a "
"Python complex number object.  If :meth:`!__complex__` is not defined then "
"it falls back to call :c:func:`PyFloat_AsDouble` and returns its result."
msgstr ""
"Om *op* inte är ett Python-objekt för komplexa tal men har en :meth:`~object."
"__complex__`-metod, kommer denna metod först att anropas för att konvertera "
"*op* till ett Python-objekt för komplexa tal.  Om :meth:`!__complex__` inte "
"är definierad så faller den tillbaka till att anropa :c:func:"
"`PyFloat_AsDouble` och returnerar dess resultat."

msgid ""
"Upon failure, this method returns ``-1.0`` with an exception set, so one "
"should call :c:func:`PyErr_Occurred` to check for errors."
msgstr ""
"Om metoden misslyckas returnerar den ``-1.0`` med en undantagsuppsättning, "
"så man bör anropa :c:func:`PyErr_Occurred` för att kontrollera om det finns "
"fel."

msgid "Use :meth:`~object.__complex__` if available."
msgstr "Använd :meth:`~object.__complex__` om det finns tillgängligt."

msgid "Return the imaginary part of *op* as a C :c:expr:`double`."
msgstr "Returnera imaginärdelen av *op* som en C :c:expr:`double`."

msgid ""
"If *op* is not a Python complex number object but has a :meth:`~object."
"__complex__` method, this method will first be called to convert *op* to a "
"Python complex number object.  If :meth:`!__complex__` is not defined then "
"it falls back to call :c:func:`PyFloat_AsDouble` and returns ``0.0`` on "
"success."
msgstr ""
"Om *op* inte är ett Python-objekt för komplexa tal men har en :meth:`~object."
"__complex__`-metod, kommer denna metod först att anropas för att konvertera "
"*op* till ett Python-objekt för komplexa tal.  Om :meth:`!__complex__` inte "
"är definierad så faller den tillbaka till att anropa :c:func:"
"`PyFloat_AsDouble` och returnerar ``0.0`` vid framgång."

msgid "Return the :c:type:`Py_complex` value of the complex number *op*."
msgstr "Returnera :c:type:`Py_complex`-värdet för det komplexa talet *op*."

msgid ""
"If *op* is not a Python complex number object but has a :meth:`~object."
"__complex__` method, this method will first be called to convert *op* to a "
"Python complex number object.  If :meth:`!__complex__` is not defined then "
"it falls back to :meth:`~object.__float__`.  If :meth:`!__float__` is not "
"defined then it falls back to :meth:`~object.__index__`."
msgstr ""
"Om *op* inte är ett Python-komplextalsobjekt men har en :meth:`~object."
"__complex__`-metod, kommer denna metod först att anropas för att konvertera "
"*op* till ett Python-komplextalsobjekt.  Om :meth:`!__complex__` inte är "
"definierad faller den tillbaka till :meth:`~object.__float__`.  Om :meth:`!"
"__float__` inte är definierat så faller det tillbaka på :meth:`~object."
"__index__`."

msgid ""
"Upon failure, this method returns :c:type:`Py_complex` with :c:member:"
"`~Py_complex.real` set to ``-1.0`` and with an exception set, so one should "
"call :c:func:`PyErr_Occurred` to check for errors."
msgstr ""
"Vid misslyckande returnerar denna metod :c:type:`Py_complex` med :c:member:"
"`~Py_complex.real` satt till ``-1.0`` och med ett undantag satt, så man bör "
"anropa :c:func:`PyErr_Occurred` för att kontrollera fel."

msgid "Use :meth:`~object.__index__` if available."
msgstr "Använd :meth:`~object.__index__` om det finns tillgängligt."

msgid "object"
msgstr "objekt"

msgid "complex number"
msgstr "komplext tal"
