# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!mmap` --- Memory-mapped file support"
msgstr ":mod:`!mmap` --- Stöd för minnesmappade filer"

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid ""
"Memory-mapped file objects behave like both :class:`bytearray` and like :"
"term:`file objects <file object>`.  You can use mmap objects in most places "
"where :class:`bytearray` are expected; for example, you can use the :mod:"
"`re` module to search through a memory-mapped file.  You can also change a "
"single byte by doing ``obj[index] = 97``, or change a subsequence by "
"assigning to a slice: ``obj[i1:i2] = b'...'``.  You can also read and write "
"data starting at the current file position, and :meth:`seek` through the "
"file to different positions."
msgstr ""
"Minnesmappade filobjekt beter sig som både :class:`bytearray` och som :term:"
"`filobjekt <file object>`.  Du kan använda mmap-objekt på de flesta ställen "
"där :class:`bytearray` förväntas; till exempel kan du använda modulen :mod:"
"`re` för att söka igenom en minnesmappad fil.  Du kan också ändra en enstaka "
"byte genom att göra ``obj[index] = 97``, eller ändra en delsekvens genom att "
"tilldela en slice: ``obj[i1:i2] = b'...'``.  Du kan också läsa och skriva "
"data med början vid den aktuella filpositionen och :meth:`seek` genom filen "
"till olika positioner."

msgid ""
"A memory-mapped file is created by the :class:`~mmap.mmap` constructor, "
"which is different on Unix and on Windows.  In either case you must provide "
"a file descriptor for a file opened for update. If you wish to map an "
"existing Python file object, use its :meth:`~io.IOBase.fileno` method to "
"obtain the correct value for the *fileno* parameter.  Otherwise, you can "
"open the file using the :func:`os.open` function, which returns a file "
"descriptor directly (the file still needs to be closed when done)."
msgstr ""
"En minnesmappad fil skapas av :class:`~mmap.mmap`-konstruktören, som är "
"olika i Unix och Windows.  I båda fallen måste du tillhandahålla en "
"filbeskrivare för en fil som är öppen för uppdatering. Om du vill mappa ett "
"befintligt Python-filobjekt använder du dess :meth:`~io.IOBase.fileno`-metod "
"för att få rätt värde för parametern *fileno*.  Annars kan du öppna filen "
"med hjälp av funktionen :func:`os.open`, som returnerar en filbeskrivning "
"direkt (filen måste fortfarande stängas när den är klar)."

msgid ""
"If you want to create a memory-mapping for a writable, buffered file, you "
"should :func:`~io.IOBase.flush` the file first.  This is necessary to ensure "
"that local modifications to the buffers are actually available to the "
"mapping."
msgstr ""
"Om du vill skapa en minnesmappning för en skrivbar, buffrad fil, bör du :"
"func:`~io.IOBase.flush` filen först.  Detta är nödvändigt för att "
"säkerställa att lokala ändringar av buffertarna faktiskt är tillgängliga för "
"mappningen."

msgid ""
"For both the Unix and Windows versions of the constructor, *access* may be "
"specified as an optional keyword parameter. *access* accepts one of four "
"values: :const:`ACCESS_READ`, :const:`ACCESS_WRITE`, or :const:`ACCESS_COPY` "
"to specify read-only, write-through or copy-on-write memory respectively, "
"or :const:`ACCESS_DEFAULT` to defer to *prot*.  *access* can be used on both "
"Unix and Windows.  If *access* is not specified, Windows mmap returns a "
"write-through mapping.  The initial memory values for all three access types "
"are taken from the specified file.  Assignment to an :const:`ACCESS_READ` "
"memory map raises a :exc:`TypeError` exception.  Assignment to an :const:"
"`ACCESS_WRITE` memory map affects both memory and the underlying file. "
"Assignment to an :const:`ACCESS_COPY` memory map affects memory but does not "
"update the underlying file."
msgstr ""
"För både Unix- och Windows-versionerna av konstruktören kan *access* anges "
"som en valfri nyckelordsparameter. *access* accepterar ett av fyra värden: :"
"const:`ACCESS_READ`, :const:`ACCESS_WRITE`, eller :const:`ACCESS_COPY` för "
"att ange skrivskyddad läsning, genomskrivning respektive kopiering vid "
"skrivning, eller :const:`ACCESS_DEFAULT` för att hänvisa till *prot*.  "
"*access* kan användas både på Unix och Windows.  Om *access* inte anges "
"returnerar Windows mmap en genomskrivningsmappning.  De initiala "
"minnesvärdena för alla tre access-typerna hämtas från den angivna filen.  "
"Tilldelning till en minnesmappning av typen :const:`ACCESS_READ` ger upphov "
"till ett undantag av typen :exc:`TypeError`.  Tilldelning till en :const:"
"`ACCESS_WRITE`-minnesmappning påverkar både minnet och den underliggande "
"filen. Tilldelning till en :const:`ACCESS_COPY`-minnesmappning påverkar "
"minnet men uppdaterar inte den underliggande filen."

msgid "Added :const:`ACCESS_DEFAULT` constant."
msgstr "Lagt till :const:`ACCESS_DEFAULT` konstant."

msgid ""
"To map anonymous memory, -1 should be passed as the fileno along with the "
"length."
msgstr ""
"För att kartlägga anonyma minnen ska -1 anges som fileno tillsammans med "
"längden."

msgid ""
"**(Windows version)** Maps *length* bytes from the file specified by the "
"file handle *fileno*, and creates a mmap object.  If *length* is larger than "
"the current size of the file, the file is extended to contain *length* "
"bytes.  If *length* is ``0``, the maximum length of the map is the current "
"size of the file, except that if the file is empty Windows raises an "
"exception (you cannot create an empty mapping on Windows)."
msgstr ""
"**(Windows-version)** Mappar *längd* byte från filen som anges av "
"filhandtaget *fileno* och skapar ett mmap-objekt.  Om *length* är större än "
"filens aktuella storlek utökas filen till att innehålla *length* byte.  Om "
"*längd* är ``0`` är den maximala längden på mappningen den aktuella "
"filstorleken, förutom att om filen är tom gör Windows ett undantag (du kan "
"inte skapa en tom mappning i Windows)."

msgid ""
"*tagname*, if specified and not ``None``, is a string giving a tag name for "
"the mapping.  Windows allows you to have many different mappings against the "
"same file.  If you specify the name of an existing tag, that tag is opened, "
"otherwise a new tag of this name is created.  If this parameter is omitted "
"or ``None``, the mapping is created without a name.  Avoiding the use of the "
"*tagname* parameter will assist in keeping your code portable between Unix "
"and Windows."
msgstr ""
"*tagname*, om det anges och inte ``None``, är en sträng som anger ett "
"taggnamn för mappningen.  I Windows kan du ha många olika mappningar mot "
"samma fil.  Om du anger namnet på en befintlig tagg öppnas den taggen, "
"annars skapas en ny tagg med detta namn.  Om denna parameter utelämnas eller "
"``None`` skapas mappningen utan namn.  Om du undviker att använda parametern "
"*tagname* blir det lättare att hålla din kod portabel mellan Unix och "
"Windows."

msgid ""
"*offset* may be specified as a non-negative integer offset. mmap references "
"will be relative to the offset from the beginning of the file. *offset* "
"defaults to 0.  *offset* must be a multiple of the :const:"
"`ALLOCATIONGRANULARITY`."
msgstr ""
"*offset* kan anges som en icke-negativ heltalsförskjutning. mmap-referenser "
"kommer att vara relativa till förskjutningen från början av filen. *offset* "
"är 0 som standard.  *offset* måste vara en multipel av :const:"
"`ALLOCATIONGRANULARITY`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``mmap.__new__`` with arguments "
"``fileno``, ``length``, ``access``, ``offset``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``mmap.__new__`` med argumenten "
"``fileno``, ``length``, ``access``, ``offset``."

msgid ""
"**(Unix version)** Maps *length* bytes from the file specified by the file "
"descriptor *fileno*, and returns a mmap object.  If *length* is ``0``, the "
"maximum length of the map will be the current size of the file when :class:"
"`~mmap.mmap` is called."
msgstr ""
"**(Unix version)** Mappar *längd* byte från filen som anges av "
"filbeskrivaren *fileno* och returnerar ett mmap-objekt.  Om *längd* är ``0`` "
"kommer den maximala längden på mappningen att vara den aktuella storleken på "
"filen när :class:`~mmap.mmap` anropas."

msgid ""
"*flags* specifies the nature of the mapping. :const:`MAP_PRIVATE` creates a "
"private copy-on-write mapping, so changes to the contents of the mmap object "
"will be private to this process, and :const:`MAP_SHARED` creates a mapping "
"that's shared with all other processes mapping the same areas of the file.  "
"The default value is :const:`MAP_SHARED`. Some systems have additional "
"possible flags with the full list specified in :ref:`MAP_* constants <map-"
"constants>`."
msgstr ""
"*flags* anger hur mappningen ska se ut. :const:`MAP_PRIVATE` skapar en "
"privat copy-on-write-mappning, så ändringar i innehållet i mmap-objektet "
"kommer att vara privata för den här processen, och :const:`MAP_SHARED` "
"skapar en mappning som delas med alla andra processer som mappar samma "
"områden i filen.  Standardvärdet är :const:`MAP_SHARED`. Vissa system har "
"ytterligare möjliga flaggor med den fullständiga listan som anges i :ref:"
"`MAP_* constants <map-constants>`."

msgid ""
"*prot*, if specified, gives the desired memory protection; the two most "
"useful values are :const:`PROT_READ` and :const:`PROT_WRITE`, to specify "
"that the pages may be read or written.  *prot* defaults to :const:`PROT_READ "
"\\| PROT_WRITE`."
msgstr ""
"*prot*, om det anges, ger önskat minnesskydd; de två mest användbara värdena "
"är :const:`PROT_READ` och :const:`PROT_WRITE`, för att ange att sidorna kan "
"läsas eller skrivas.  *prot* är som standard :const:`PROT_READ \\| "
"PROT_WRITE`."

msgid ""
"*access* may be specified in lieu of *flags* and *prot* as an optional "
"keyword parameter.  It is an error to specify both *flags*, *prot* and "
"*access*.  See the description of *access* above for information on how to "
"use this parameter."
msgstr ""
"*access* kan anges i stället för *flags* och *prot* som en valfri "
"nyckelordsparameter.  Det är ett fel att ange både *flags*, *prot* och "
"*access*.  Se beskrivningen av *access* ovan för information om hur denna "
"parameter ska användas."

msgid ""
"*offset* may be specified as a non-negative integer offset. mmap references "
"will be relative to the offset from the beginning of the file. *offset* "
"defaults to 0. *offset* must be a multiple of :const:`ALLOCATIONGRANULARITY` "
"which is equal to :const:`PAGESIZE` on Unix systems."
msgstr ""
"*offset* kan anges som en icke-negativ heltalsförskjutning. mmap-referenser "
"kommer att vara relativa till förskjutningen från början av filen. *offset* "
"är 0 som standard. *offset* måste vara en multipel av :const:"
"`ALLOCATIONGRANULARITY` som är lika med :const:`PAGESIZE` på Unix-system."

msgid ""
"If *trackfd* is ``False``, the file descriptor specified by *fileno* will "
"not be duplicated, and the resulting :class:`!mmap` object will not be "
"associated with the map's underlying file. This means that the :meth:`~mmap."
"mmap.size` and :meth:`~mmap.mmap.resize` methods will fail. This mode is "
"useful to limit the number of open file descriptors."
msgstr ""
"Om *trackfd* är ``False`` kommer filbeskrivaren som anges av *fileno* inte "
"att dupliceras och det resulterande :class:`!mmap`-objektet kommer inte att "
"associeras med mappens underliggande fil. Detta innebär att metoderna :meth:"
"`~mmap.mmap.size` och :meth:`~mmap.mmap.resize` misslyckas. Detta läge är "
"användbart för att begränsa antalet öppna filbeskrivare."

msgid ""
"To ensure validity of the created memory mapping the file specified by the "
"descriptor *fileno* is internally automatically synchronized with the "
"physical backing store on macOS."
msgstr ""
"För att säkerställa giltigheten för den skapade minnesmappningen "
"synkroniseras filen som anges av deskriptorn *fileno* internt automatiskt "
"med det fysiska backinglagret på macOS."

msgid "The *trackfd* parameter was added."
msgstr "Parametern *trackfd* har lagts till."

msgid "This example shows a simple way of using :class:`~mmap.mmap`::"
msgstr "Detta exempel visar ett enkelt sätt att använda :class:`~mmap.mmap`::"

msgid ""
"import mmap\n"
"\n"
"# write a simple example file\n"
"with open(\"hello.txt\", \"wb\") as f:\n"
"    f.write(b\"Hello Python!\\n\")\n"
"\n"
"with open(\"hello.txt\", \"r+b\") as f:\n"
"    # memory-map the file, size 0 means whole file\n"
"    mm = mmap.mmap(f.fileno(), 0)\n"
"    # read content via standard file methods\n"
"    print(mm.readline())  # prints b\"Hello Python!\\n\"\n"
"    # read content via slice notation\n"
"    print(mm[:5])  # prints b\"Hello\"\n"
"    # update content using slice notation;\n"
"    # note that new content must have same size\n"
"    mm[6:] = b\" world!\\n\"\n"
"    # ... and read again using standard file methods\n"
"    mm.seek(0)\n"
"    print(mm.readline())  # prints b\"Hello  world!\\n\"\n"
"    # close the map\n"
"    mm.close()"
msgstr ""
"import mmap\n"
"\n"
"# write a simple example file\n"
"with open(\"hello.txt\", \"wb\") as f:\n"
"    f.write(b\"Hello Python!\\n\")\n"
"\n"
"with open(\"hello.txt\", \"r+b\") as f:\n"
"    # memory-map the file, size 0 means whole file\n"
"    mm = mmap.mmap(f.fileno(), 0)\n"
"    # read content via standard file methods\n"
"    print(mm.readline())  # prints b\"Hello Python!\\n\"\n"
"    # read content via slice notation\n"
"    print(mm[:5])  # prints b\"Hello\"\n"
"    # update content using slice notation;\n"
"    # note that new content must have same size\n"
"    mm[6:] = b\" world!\\n\"\n"
"    # ... and read again using standard file methods\n"
"    mm.seek(0)\n"
"    print(mm.readline())  # prints b\"Hello  world!\\n\"\n"
"    # close the map\n"
"    mm.close()"

msgid ""
":class:`~mmap.mmap` can also be used as a context manager in a :keyword:"
"`with` statement::"
msgstr ""
":class:`~mmap.mmap` kan också användas som en kontexthanterare i en :keyword:"
"`with`-sats::"

msgid ""
"import mmap\n"
"\n"
"with mmap.mmap(-1, 13) as mm:\n"
"    mm.write(b\"Hello world!\")"
msgstr ""
"import mmap\n"
"\n"
"with mmap.mmap(-1, 13) as mm:\n"
"    mm.write(b\"Hello world!\")"

msgid "Context manager support."
msgstr "Stöd för kontextansvarig."

msgid ""
"The next example demonstrates how to create an anonymous map and exchange "
"data between the parent and child processes::"
msgstr ""
"I nästa exempel visas hur du skapar en anonym karta och utbyter data mellan "
"föräldra- och barnprocesserna::"

msgid ""
"import mmap\n"
"import os\n"
"\n"
"mm = mmap.mmap(-1, 13)\n"
"mm.write(b\"Hello world!\")\n"
"\n"
"pid = os.fork()\n"
"\n"
"if pid == 0:  # In a child process\n"
"    mm.seek(0)\n"
"    print(mm.readline())\n"
"\n"
"    mm.close()"
msgstr ""
"import mmap\n"
"import os\n"
"\n"
"mm = mmap.mmap(-1, 13)\n"
"mm.write(b\"Hello world!\")\n"
"\n"
"pid = os.fork()\n"
"\n"
"if pid == 0:  # In a child process\n"
"    mm.seek(0)\n"
"    print(mm.readline())\n"
"\n"
"    mm.close()"

msgid "Memory-mapped file objects support the following methods:"
msgstr "Minnesmappade filobjekt stöder följande metoder:"

msgid ""
"Closes the mmap. Subsequent calls to other methods of the object will result "
"in a ValueError exception being raised. This will not close the open file."
msgstr ""
"Stänger mmap. Efterföljande anrop till andra metoder i objektet kommer att "
"resultera i ett ValueError-undantag. Detta kommer inte att stänga den öppna "
"filen."

msgid "``True`` if the file is closed."
msgstr "``True`` om filen är stängd."

msgid ""
"Returns the lowest index in the object where the subsequence *sub* is found, "
"such that *sub* is contained in the range [*start*, *end*]. Optional "
"arguments *start* and *end* are interpreted as in slice notation. Returns "
"``-1`` on failure."
msgstr ""
"Returnerar det lägsta indexet i objektet där underföljden *sub* finns, så "
"att *sub* ingår i intervallet [*start*, *slut*]. De valfria argumenten "
"*start* och *end* tolkas som i slice-notation. Returnerar ``-1`` om den "
"misslyckas."

msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Skrivbar :term:`bytesliknande objekt` är nu accepterad."

msgid ""
"Flushes changes made to the in-memory copy of a file back to disk. Without "
"use of this call there is no guarantee that changes are written back before "
"the object is destroyed.  If *offset* and *size* are specified, only changes "
"to the given range of bytes will be flushed to disk; otherwise, the whole "
"extent of the mapping is flushed.  *offset* must be a multiple of the :const:"
"`PAGESIZE` or :const:`ALLOCATIONGRANULARITY`."
msgstr ""
"Spolar tillbaka ändringar som gjorts i minneskopian av en fil till disken. "
"Utan användning av detta anrop finns det ingen garanti för att ändringar "
"skrivs tillbaka innan objektet förstörs.  Om *offset* och *size* anges, "
"kommer endast ändringar i det angivna intervallet av byte att spolas till "
"disken; annars spolas hela omfattningen av mappningen.  *offset* måste vara "
"en multipel av :const:`PAGESIZE` eller :const:`ALLOCATIONGRANULARITY`."

msgid ""
"``None`` is returned to indicate success.  An exception is raised when the "
"call failed."
msgstr ""
"``None`` returneras för att indikera framgång.  Ett undantag uppstår när "
"anropet misslyckades."

msgid ""
"Previously, a nonzero value was returned on success; zero was returned on "
"error under Windows.  A zero value was returned on success; an exception was "
"raised on error under Unix."
msgstr ""
"Tidigare returnerades ett värde som inte var noll vid framgång, medan noll "
"returnerades vid fel under Windows.  Under Unix returnerades ett nollvärde "
"vid framgång och ett undantag vid fel."

msgid ""
"Send advice *option* to the kernel about the memory region beginning at "
"*start* and extending *length* bytes.  *option* must be one of the :ref:"
"`MADV_* constants <madvise-constants>` available on the system.  If *start* "
"and *length* are omitted, the entire mapping is spanned.  On some systems "
"(including Linux), *start* must be a multiple of the :const:`PAGESIZE`."
msgstr ""
"Skicka råd *option* till kärnan om minnesregionen som börjar vid *start* och "
"sträcker sig *length* byte.  *option* måste vara en av de :ref:`MADV_*-"
"konstanter <madvise-constants>` som finns tillgängliga i systemet.  Om "
"*start* och *length* utelämnas täcks hela mappningen.  På vissa system "
"(inklusive Linux) måste *start* vara en multipel av :const:`PAGESIZE`."

msgid "Availability: Systems with the ``madvise()`` system call."
msgstr "Tillgänglighet: System med systemanropet ``madvise()``."

msgid ""
"Copy the *count* bytes starting at offset *src* to the destination index "
"*dest*.  If the mmap was created with :const:`ACCESS_READ`, then calls to "
"move will raise a :exc:`TypeError` exception."
msgstr ""
"Kopierar *antal* byte från offset *src* till destinationsindex *dest*.  Om "
"mmap skapades med :const:`ACCESS_READ`, så kommer anrop till move att ge "
"upphov till ett :exc:`TypeError` undantag."

msgid ""
"Return a :class:`bytes` containing up to *n* bytes starting from the current "
"file position. If the argument is omitted, ``None`` or negative, return all "
"bytes from the current file position to the end of the mapping. The file "
"position is updated to point after the bytes that were returned."
msgstr ""
"Returnerar en :class:`bytes` som innehåller upp till *n* byte med start från "
"aktuell filposition. Om argumentet utelämnas, ``None`` eller negativt, "
"returneras alla byte från den aktuella filpositionen till slutet av "
"mappningen. Filpositionen uppdateras så att den pekar efter de byte som "
"returnerades."

msgid "Argument can be omitted or ``None``."
msgstr "Argumentet kan utelämnas eller vara ``None``."

msgid ""
"Returns a byte at the current file position as an integer, and advances the "
"file position by 1."
msgstr ""
"Returnerar en byte vid den aktuella filpositionen som ett heltal och flyttar "
"fram filpositionen med 1."

msgid ""
"Returns a single line, starting at the current file position and up to the "
"next newline. The file position is updated to point after the bytes that "
"were returned."
msgstr ""
"Returnerar en enda rad, med början vid den aktuella filpositionen och fram "
"till nästa nya rad. Filpositionen uppdateras så att den pekar efter de bytes "
"som returnerades."

msgid "Resizes the map and the underlying file, if any."
msgstr ""
"Ändrar storlek på kartan och den underliggande filen, om en sådan finns."

msgid ""
"Resizing a map created with *access* of :const:`ACCESS_READ` or :const:"
"`ACCESS_COPY`, will raise a :exc:`TypeError` exception. Resizing a map "
"created with *trackfd* set to ``False``, will raise a :exc:`ValueError` "
"exception."
msgstr ""
"Om du ändrar storlek på en karta som skapats med *access* av :const:"
"`ACCESS_READ` eller :const:`ACCESS_COPY`, kommer det att leda till ett :exc:"
"`TypeError`-undantag. Om du ändrar storlek på en karta som skapats med "
"*trackfd* satt till ``False``, kommer ett :exc:`ValueError` undantag att "
"uppstå."

msgid ""
"**On Windows**: Resizing the map will raise an :exc:`OSError` if there are "
"other maps against the same named file. Resizing an anonymous map (ie "
"against the pagefile) will silently create a new map with the original data "
"copied over up to the length of the new size."
msgstr ""
"**På Windows**: Om du ändrar storlek på kartan kommer det att uppstå ett :"
"exc:`OSError` om det finns andra kartor mot samma namngivna fil. Om du "
"ändrar storlek på en anonym karta (dvs. mot sidfilen) skapas en ny karta i "
"tysthet med originaldata som kopieras över upp till längden på den nya "
"storleken."

msgid ""
"Correctly fails if attempting to resize when another map is held Allows "
"resize against an anonymous map on Windows"
msgstr ""
"Misslyckas korrekt vid försök att ändra storlek när en annan karta hålls "
"kvar Tillåter ändring av storlek mot en anonym karta i Windows"

msgid ""
"Returns the highest index in the object where the subsequence *sub* is "
"found, such that *sub* is contained in the range [*start*, *end*]. Optional "
"arguments *start* and *end* are interpreted as in slice notation. Returns "
"``-1`` on failure."
msgstr ""
"Returnerar det högsta indexet i objektet där underföljden *sub* finns, så "
"att *sub* ingår i intervallet [*start*, *slut*]. De valfria argumenten "
"*start* och *end* tolkas som i slice-notation. Returnerar ``-1`` om den "
"misslyckas."

msgid ""
"Set the file's current position.  *whence* argument is optional and defaults "
"to ``os.SEEK_SET`` or ``0`` (absolute file positioning); other values are "
"``os.SEEK_CUR`` or ``1`` (seek relative to the current position) and ``os."
"SEEK_END`` or ``2`` (seek relative to the file's end)."
msgstr ""
"Ställ in filens aktuella position.  *whence*-argumentet är valfritt och "
"standardvärdet är ``os.SEEK_SET`` eller ``0`` (absolut filpositionering); "
"andra värden är ``os.SEEK_CUR`` eller ``1`` (sök relativt den aktuella "
"positionen) och ``os.SEEK_END`` eller ``2`` (sök relativt filens slut)."

msgid "Return the new absolute position instead of ``None``."
msgstr "Returnerar den nya absoluta positionen istället för ``None``."

msgid ""
"Return whether the file supports seeking, and the return value is always "
"``True``."
msgstr ""
"Returnerar om filen stöder sökning, och returvärdet är alltid ``True``."

msgid ""
"Return the length of the file, which can be larger than the size of the "
"memory-mapped area."
msgstr ""
"Returnera längden på filen, som kan vara större än storleken på det "
"minnesmappade området."

msgid "Returns the current position of the file pointer."
msgstr "Returnerar den aktuella positionen för filpekaren."

msgid ""
"Write the bytes in *bytes* into memory at the current position of the file "
"pointer and return the number of bytes written (never less than "
"``len(bytes)``, since if the write fails, a :exc:`ValueError` will be "
"raised).  The file position is updated to point after the bytes that were "
"written.  If the mmap was created with :const:`ACCESS_READ`, then writing to "
"it will raise a :exc:`TypeError` exception."
msgstr ""
"Skriv bytena i *bytes* till minnet vid filpekarens aktuella position och "
"returnera antalet skrivna byte (aldrig mindre än ``len(bytes)``, eftersom om "
"skrivningen misslyckas kommer ett :exc:`ValueError` att uppstå).  "
"Filpositionen uppdateras så att den pekar efter de byte som skrevs.  Om mmap "
"skapades med :const:`ACCESS_READ`, så kommer skrivning till den att ge "
"upphov till ett :exc:`TypeError` undantag."

msgid "The number of bytes written is now returned."
msgstr "Antalet skrivna bytes returneras nu."

msgid ""
"Write the integer *byte* into memory at the current position of the file "
"pointer; the file position is advanced by ``1``. If the mmap was created "
"with :const:`ACCESS_READ`, then writing to it will raise a :exc:`TypeError` "
"exception."
msgstr ""
"Skriv in heltalet *byte* i minnet vid filpekarens aktuella position; "
"filpositionen flyttas fram med ``1``. Om mmap skapades med :const:"
"`ACCESS_READ`, så kommer skrivning till den att ge upphov till ett :exc:"
"`TypeError` undantag."

msgid "MADV_* Constants"
msgstr "MADV_* Konstanter"

msgid ""
"These options can be passed to :meth:`mmap.madvise`.  Not every option will "
"be present on every system."
msgstr ""
"Dessa alternativ kan skickas till :meth:`mmap.madvise`.  Alla alternativ "
"kommer inte att finnas på alla system."

msgid "Availability: Systems with the madvise() system call."
msgstr "Tillgänglighet: System med systemanropet madvise()."

msgid "MAP_* Constants"
msgstr "MAP_* Konstanter"

msgid ""
"These are the various flags that can be passed to :meth:`mmap.mmap`.  :data:"
"`MAP_ALIGNED_SUPER` is only available at FreeBSD and :data:`MAP_CONCEAL` is "
"only available at OpenBSD.  Note that some options might not be present on "
"some systems."
msgstr ""
"Dessa är de olika flaggor som kan skickas till :meth:`mmap.mmap`. :data:"
"`MAP_ALIGNED_SUPER` är endast tillgänglig på FreeBSD och :data:`MAP_CONCEAL` "
"är endast tillgänglig på OpenBSD.  Observera att vissa alternativ kanske "
"inte finns på vissa system."

msgid "Added :data:`MAP_POPULATE` constant."
msgstr "Lagt till :data:`MAP_POPULATE` konstant."

msgid "Added :data:`MAP_STACK` constant."
msgstr "Lagt till :data:`MAP_STACK` konstant."

msgid "Added :data:`MAP_ALIGNED_SUPER` and :data:`MAP_CONCEAL` constants."
msgstr ""
"Lagt till konstanterna :data:`MAP_ALIGNED_SUPER` och :data:`MAP_CONCEAL`."

msgid ""
"Added :data:`MAP_32BIT`, :data:`MAP_HASSEMAPHORE`, :data:`MAP_JIT`, :data:"
"`MAP_NOCACHE`, :data:`MAP_NOEXTEND`, :data:`MAP_NORESERVE`, :data:"
"`MAP_RESILIENT_CODESIGN`, :data:`MAP_RESILIENT_MEDIA`, :data:`MAP_TPRO`, :"
"data:`MAP_TRANSLATED_ALLOW_EXECUTE`, and :data:`MAP_UNIX03` constants."
msgstr ""
"Lade till :data:`MAP_32BIT`, :data:`MAP_HASSEMAPHORE`, :data:`MAP_JIT`, :"
"data:`MAP_NOCACHE`, :data:`MAP_NOEXTEND`, :data:`MAP_NORESERVE`, :data:"
"`MAP_RESILIENT_CODESIGN`, :data:`MAP_RESILIENT_MEDIA`, :data:`MAP_TPRO`, :"
"data:`MAP_TRANSLATED_ALLOW_EXECUTE`, och :data:`MAP_UNIX03` konstanter."
