# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!multiprocessing.shared_memory` --- Shared memory for direct access "
"across processes"
msgstr ""
":mod:`!multiprocessing.shared_memory` --- Delat minne för direktåtkomst "
"mellan processer"

msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**Källkod:** :source:`Lib/multiprocessing/shared_memory.py`"

msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation and "
"management of shared memory to be accessed by one or more processes on a "
"multicore or symmetric multiprocessor (SMP) machine.  To assist with the "
"life-cycle management of shared memory especially across distinct processes, "
"a :class:`~multiprocessing.managers.BaseManager` subclass, :class:"
"`~multiprocessing.managers.SharedMemoryManager`, is also provided in the :"
"mod:`multiprocessing.managers` module."
msgstr ""
"Den här modulen innehåller en klass, :class:`SharedMemory`, för allokering "
"och hantering av delat minne som kan användas av en eller flera processer på "
"en flerkärnig eller symmetrisk multiprocessormaskin (SMP).  För att "
"underlätta livscykelhanteringen av delat minne, särskilt mellan olika "
"processer, finns också en underklass till :class:`~multiprocessing.managers."
"BaseManager`, :class:`~multiprocessing.managers.SharedMemoryManager`, i "
"modulen :mod:`multiprocessing.managers`."

msgid ""
"In this module, shared memory refers to \"POSIX style\" shared memory blocks "
"(though is not necessarily implemented explicitly as such) and does not "
"refer to \"distributed shared memory\".  This style of shared memory permits "
"distinct processes to potentially read and write to a common (or shared) "
"region of volatile memory.  Processes are conventionally limited to only "
"have access to their own process memory space but shared memory permits the "
"sharing of data between processes, avoiding the need to instead send "
"messages between processes containing that data.  Sharing data directly via "
"memory can provide significant performance benefits compared to sharing data "
"via disk or socket or other communications requiring the serialization/"
"deserialization and copying of data."
msgstr ""
"I den här modulen avser delat minne delade minnesblock i POSIX-stil (även om "
"de inte nödvändigtvis implementeras explicit som sådana) och inte "
"\"distribuerat delat minne\".  Denna typ av delat minne gör det möjligt för "
"olika processer att potentiellt läsa och skriva till en gemensam (eller "
"delad) region i det flyktiga minnet.  Processer är normalt begränsade till "
"att bara ha tillgång till sitt eget processminnesutrymme, men med delat "
"minne kan data delas mellan processer, vilket gör att man inte behöver "
"skicka meddelanden mellan processerna som innehåller dessa data.  Att dela "
"data direkt via minnet kan ge betydande prestandafördelar jämfört med att "
"dela data via disk eller socket eller annan kommunikation som kräver "
"serialisering/deserialisering och kopiering av data."

msgid ""
"Create an instance of the :class:`!SharedMemory` class for either creating a "
"new shared memory block or attaching to an existing shared memory block.  "
"Each shared memory block is assigned a unique name. In this way, one process "
"can create a shared memory block with a particular name and a different "
"process can attach to that same shared memory block using that same name."
msgstr ""
"Skapa en instans av :class:`!SharedMemory`-klassen för att antingen skapa "
"ett nytt delat minnesblock eller koppla till ett befintligt delat "
"minnesblock.  Varje delat minnesblock tilldelas ett unikt namn. På så sätt "
"kan en process skapa ett shared memory-block med ett visst namn och en annan "
"process kan koppla till samma shared memory-block med samma namn."

msgid ""
"As a resource for sharing data across processes, shared memory blocks may "
"outlive the original process that created them.  When one process no longer "
"needs access to a shared memory block that might still be needed by other "
"processes, the :meth:`close` method should be called. When a shared memory "
"block is no longer needed by any process, the :meth:`unlink` method should "
"be called to ensure proper cleanup."
msgstr ""
"Som en resurs för att dela data mellan processer kan delade minnesblock "
"överleva den ursprungliga processen som skapade dem.  När en process inte "
"längre behöver tillgång till ett delat minnesblock som fortfarande kan "
"behövas av andra processer, bör metoden :meth:`close` anropas. När ett delat "
"minnesblock inte längre behövs av någon process bör metoden :meth:`unlink` "
"anropas för att säkerställa korrekt upprensning."

msgid "Parameters"
msgstr "Parametrar"

msgid ""
"The unique name for the requested shared memory, specified as a string. When "
"creating a new shared memory block, if ``None`` (the default) is supplied "
"for the name, a novel name will be generated."
msgstr ""
"Det unika namnet för det begärda delade minnet, angivet som en sträng. Om "
"``None`` (standard) anges för namnet när ett nytt block med delat minne "
"skapas, kommer ett nytt namn att genereras."

msgid ""
"Control whether a new shared memory block is created (``True``) or an "
"existing shared memory block is attached (``False``)."
msgstr ""
"Styr om ett nytt delat minnesblock ska skapas (``True``) eller om ett "
"befintligt delat minnesblock ska kopplas till (``False``)."

msgid ""
"The requested number of bytes when creating a new shared memory block. "
"Because some platforms choose to allocate chunks of memory based upon that "
"platform's memory page size, the exact size of the shared memory block may "
"be larger or equal to the size requested. When attaching to an existing "
"shared memory block, the *size* parameter is ignored."
msgstr ""
"Det begärda antalet byte när ett nytt delat minnesblock skapas. Eftersom "
"vissa plattformar väljer att allokera minnesbitar baserat på plattformens "
"minnessidstorlek, kan den exakta storleken på det delade minnesblocket vara "
"större eller lika med den begärda storleken. När du ansluter till ett "
"befintligt delat minnesblock ignoreras parametern *size*."

msgid ""
"When ``True``, register the shared memory block with a resource tracker "
"process on platforms where the OS does not do this automatically. The "
"resource tracker ensures proper cleanup of the shared memory even if all "
"other processes with access to the memory exit without doing so. Python "
"processes created from a common ancestor using :mod:`multiprocessing` "
"facilities share a single resource tracker process, and the lifetime of "
"shared memory segments is handled automatically among these processes. "
"Python processes created in any other way will receive their own resource "
"tracker when accessing shared memory with *track* enabled. This will cause "
"the shared memory to be deleted by the resource tracker of the first process "
"that terminates. To avoid this issue, users of :mod:`subprocess` or "
"standalone Python processes should set *track* to ``False`` when there is "
"already another process in place that does the bookkeeping. *track* is "
"ignored on Windows, which has its own tracking and automatically deletes "
"shared memory when all handles to it have been closed."
msgstr ""
"När ``True``, registrera det delade minnesblocket med en "
"resursspårningsprocess på plattformar där operativsystemet inte gör detta "
"automatiskt. Resursspåraren säkerställer korrekt rensning av det delade "
"minnet även om alla andra processer med tillgång till minnet avslutas utan "
"att göra det. Python-processer som skapats från en gemensam förfader med "
"hjälp av :mod:`multiprocessing` delar en enda resursspårningsprocess, och "
"livstiden för delade minnessegment hanteras automatiskt mellan dessa "
"processer. Python-processer som skapas på något annat sätt kommer att få sin "
"egen resursspårare när de använder delat minne med *track* aktiverat. Detta "
"kommer att leda till att det delade minnet raderas av resursspåraren för den "
"första process som avslutas. För att undvika detta problem bör användare av :"
"mod:`subprocess` eller fristående Python-processer sätta *track* till "
"``False`` när det redan finns en annan process på plats som sköter "
"bokföringen. *track* ignoreras i Windows, som har sin egen spårning och "
"automatiskt raderar delat minne när alla handtag till det har stängts."

msgid "Added the *track* parameter."
msgstr "Parametern *track* har lagts till."

msgid ""
"Close the file descriptor/handle to the shared memory from this instance.  :"
"meth:`close` should be called once access to the shared memory block from "
"this instance is no longer needed.  Depending on operating system, the "
"underlying memory may or may not be freed even if all handles to it have "
"been closed.  To ensure proper cleanup, use the :meth:`unlink` method."
msgstr ""
"Stäng filbeskrivaren/handtaget till det delade minnet från den här "
"instansen. :meth:`close` bör anropas när åtkomst till det delade "
"minnesblocket från den här instansen inte längre behövs.  Beroende på "
"operativsystem kan det hända att det underliggande minnet inte frigörs även "
"om alla handtag till det har stängts.  För att säkerställa korrekt "
"upprensning, använd metoden :meth:`unlink`."

msgid ""
"Delete the underlying shared memory block.  This should be called only once "
"per shared memory block regardless of the number of handles to it, even in "
"other processes. :meth:`unlink` and :meth:`close` can be called in any "
"order, but trying to access data inside a shared memory block after :meth:"
"`unlink` may result in memory access errors, depending on platform."
msgstr ""
"Ta bort det underliggande delade minnesblocket.  Detta bör bara anropas en "
"gång per delat minnesblock oavsett antalet handtag till det, även i andra "
"processer. :meth:`unlink` och :meth:`close` kan anropas i valfri ordning, "
"men om du försöker komma åt data i ett delat minnesblock efter :meth:"
"`unlink` kan det leda till minnesåtkomstfel, beroende på plattform."

msgid ""
"This method has no effect on Windows, where the only way to delete a shared "
"memory block is to close all handles."
msgstr ""
"Den här metoden har ingen effekt i Windows, där det enda sättet att ta bort "
"ett delat minnesblock är att stänga alla handtag."

msgid "A memoryview of contents of the shared memory block."
msgstr "En minnesvy av innehållet i det delade minnesblocket."

msgid "Read-only access to the unique name of the shared memory block."
msgstr ""
"Skrivskyddad åtkomst till det unika namnet på det delade minnesblocket."

msgid "Read-only access to size in bytes of the shared memory block."
msgstr ""
"Skrivskyddad åtkomst till storleken i bytes på det delade minnesblocket."

msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory` "
"instances::"
msgstr ""
"Följande exempel demonstrerar lågnivåanvändning av :class:`SharedMemory`-"
"instanser::"

msgid ""
">>> from multiprocessing import shared_memory\n"
">>> shm_a = shared_memory.SharedMemory(create=True, size=10)\n"
">>> type(shm_a.buf)\n"
"<class 'memoryview'>\n"
">>> buffer = shm_a.buf\n"
">>> len(buffer)\n"
"10\n"
">>> buffer[:4] = bytearray([22, 33, 44, 55])  # Modify multiple at once\n"
">>> buffer[4] = 100                           # Modify single byte at a "
"time\n"
">>> # Attach to an existing shared memory block\n"
">>> shm_b = shared_memory.SharedMemory(shm_a.name)\n"
">>> import array\n"
">>> array.array('b', shm_b.buf[:5])  # Copy the data into a new array.array\n"
"array('b', [22, 33, 44, 55, 100])\n"
">>> shm_b.buf[:5] = b'howdy'  # Modify via shm_b using bytes\n"
">>> bytes(shm_a.buf[:5])      # Access via shm_a\n"
"b'howdy'\n"
">>> shm_b.close()   # Close each SharedMemory instance\n"
">>> shm_a.close()\n"
">>> shm_a.unlink()  # Call unlink only once to release the shared memory"
msgstr ""
">>> från multiprocessing import shared_memory\n"
">>> shm_a = shared_memory.SharedMemory(create=True, size=10)\n"
">>> typ(shm_a.buf)\n"
"<klass 'minnesvy'>\n"
">>> buffert = shm_a.buf\n"
">>> len(buffert)\n"
"10\n"
">>> buffert[:4] = bytearray([22, 33, 44, 55]) # Modifiera flera på en gång\n"
">>> buffert[4] = 100 # Modifiera en byte i taget\n"
">>> # Koppla till ett befintligt delat minnesblock\n"
">>> shm_b = shared_memory.SharedMemory(shm_a.name)\n"
">>> import array\n"
">>> array.array('b', shm_b.buf[:5]) # Kopiera data till en ny array.array\n"
"array('b', [22, 33, 44, 55, 100])\n"
">>> shm_b.buf[:5] = b'howdy' # Modifiera via shm_b med hjälp av bytes\n"
">>> bytes(shm_a.buf[:5]) # Åtkomst via shm_a\n"
"b'howdy'\n"
">>> shm_b.close() # Stäng varje SharedMemory-instans\n"
">>> shm_a.close()\n"
">>> shm_a.unlink() # Anropa unlink endast en gång för att frigöra det delade "
"minnet"

msgid ""
"The following example demonstrates a practical use of the :class:"
"`SharedMemory` class with `NumPy arrays <https://numpy.org/>`_, accessing "
"the same :class:`!numpy.ndarray` from two distinct Python shells:"
msgstr ""
"Följande exempel visar en praktisk användning av klassen :class:"
"`SharedMemory` med `NumPy matriser <https://numpy.org/>`_, med åtkomst till "
"samma :class:`!numpy.ndarray` från två olika Python-skal:"

msgid ""
">>> # In the first Python interactive shell\n"
">>> import numpy as np\n"
">>> a = np.array([1, 1, 2, 3, 5, 8])  # Start with an existing NumPy array\n"
">>> from multiprocessing import shared_memory\n"
">>> shm = shared_memory.SharedMemory(create=True, size=a.nbytes)\n"
">>> # Now create a NumPy array backed by shared memory\n"
">>> b = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)\n"
">>> b[:] = a[:]  # Copy the original data into shared memory\n"
">>> b\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> type(b)\n"
"<class 'numpy.ndarray'>\n"
">>> type(a)\n"
"<class 'numpy.ndarray'>\n"
">>> shm.name  # We did not specify a name so one was chosen for us\n"
"'psm_21467_46075'\n"
"\n"
">>> # In either the same shell or a new Python shell on the same machine\n"
">>> import numpy as np\n"
">>> from multiprocessing import shared_memory\n"
">>> # Attach to the existing shared memory block\n"
">>> existing_shm = shared_memory.SharedMemory(name='psm_21467_46075')\n"
">>> # Note that a.shape is (6,) and a.dtype is np.int64 in this example\n"
">>> c = np.ndarray((6,), dtype=np.int64, buffer=existing_shm.buf)\n"
">>> c\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> c[-1] = 888\n"
">>> c\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Back in the first Python interactive shell, b reflects this change\n"
">>> b\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Clean up from within the second Python shell\n"
">>> del c  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> existing_shm.close()\n"
"\n"
">>> # Clean up from within the first Python shell\n"
">>> del b  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> shm.close()\n"
">>> shm.unlink()  # Free and release the shared memory block at the very end"
msgstr ""
">>> # In the first Python interactive shell\n"
">>> import numpy as np\n"
">>> a = np.array([1, 1, 2, 3, 5, 8])  # Start with an existing NumPy array\n"
">>> from multiprocessing import shared_memory\n"
">>> shm = shared_memory.SharedMemory(create=True, size=a.nbytes)\n"
">>> # Now create a NumPy array backed by shared memory\n"
">>> b = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)\n"
">>> b[:] = a[:]  # Copy the original data into shared memory\n"
">>> b\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> type(b)\n"
"<class 'numpy.ndarray'>\n"
">>> type(a)\n"
"<class 'numpy.ndarray'>\n"
">>> shm.name  # We did not specify a name so one was chosen for us\n"
"'psm_21467_46075'\n"
"\n"
">>> # In either the same shell or a new Python shell on the same machine\n"
">>> import numpy as np\n"
">>> from multiprocessing import shared_memory\n"
">>> # Attach to the existing shared memory block\n"
">>> existing_shm = shared_memory.SharedMemory(name='psm_21467_46075')\n"
">>> # Note that a.shape is (6,) and a.dtype is np.int64 in this example\n"
">>> c = np.ndarray((6,), dtype=np.int64, buffer=existing_shm.buf)\n"
">>> c\n"
"array([1, 1, 2, 3, 5, 8])\n"
">>> c[-1] = 888\n"
">>> c\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Back in the first Python interactive shell, b reflects this change\n"
">>> b\n"
"array([  1,   1,   2,   3,   5, 888])\n"
"\n"
">>> # Clean up from within the second Python shell\n"
">>> del c  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> existing_shm.close()\n"
"\n"
">>> # Clean up from within the first Python shell\n"
">>> del b  # Unnecessary; merely emphasizing the array is no longer used\n"
">>> shm.close()\n"
">>> shm.unlink()  # Free and release the shared memory block at the very end"

msgid ""
"A subclass of :class:`multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ""
"En underklass till :class:`multiprocessing.managers.BaseManager` som kan "
"användas för hantering av delade minnesblock mellan processer."

msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a :class:`!"
"SharedMemoryManager` instance causes a new process to be started. This new "
"process's sole purpose is to manage the life cycle of all shared memory "
"blocks created through it.  To trigger the release of all shared memory "
"blocks managed by that process, call :meth:`~multiprocessing.managers."
"BaseManager.shutdown` on the instance. This triggers a :meth:"
"`~multiprocessing.shared_memory.SharedMemory.unlink` call on all of the :"
"class:`SharedMemory` objects managed by that process and then stops the "
"process itself.  By creating :class:`!SharedMemory` instances through a :"
"class:`!SharedMemoryManager`, we avoid the need to manually track and "
"trigger the freeing of shared memory resources."
msgstr ""
"Ett anrop till :meth:`~multiprocessing.managers.BaseManager.start` på en "
"instans av :class:`!SharedMemoryManager` gör att en ny process startas. Den "
"nya processens enda syfte är att hantera livscykeln för alla delade "
"minnesblock som skapas genom den.  För att utlösa frisläppandet av alla "
"delade minnesblock som hanteras av den processen, anropa :meth:"
"`~multiprocessing.managers.BaseManager.shutdown` på instansen. Detta utlöser "
"ett :meth:`~multiprocessing.shared_memory.SharedMemory.unlink`-anrop på "
"alla :class:`SharedMemory`-objekt som hanteras av den processen och stoppar "
"sedan själva processen.  Genom att skapa :class:`!SharedMemory`-instanser "
"genom en :class:`!SharedMemoryManager` slipper vi manuellt spåra och utlösa "
"frigörandet av delade minnesresurser."

msgid ""
"This class provides methods for creating and returning :class:`SharedMemory` "
"instances and for creating a list-like object (:class:`ShareableList`) "
"backed by shared memory."
msgstr ""
"Den här klassen innehåller metoder för att skapa och returnera :class:"
"`SharedMemory`-instanser och för att skapa ett listliknande objekt (:class:"
"`ShareableList`) som stöds av delat minne."

msgid ""
"Refer to :class:`~multiprocessing.managers.BaseManager` for a description of "
"the inherited *address* and *authkey* optional input arguments and how they "
"may be used to connect to an existing :class:`!SharedMemoryManager` service "
"from other processes."
msgstr ""
"Se :class:`~multiprocessing.managers.BaseManager` för en beskrivning av de "
"ärvda valfria inmatningsargumenten *address* och *authkey* och hur de kan "
"användas för att ansluta till en befintlig tjänst :class:`!"
"SharedMemoryManager` från andra processer."

msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"*size* in bytes."
msgstr ""
"Skapar och returnerar ett nytt :class:`SharedMemory`-objekt med den angivna "
"*storleken* i byte."

msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the "
"values from the input *sequence*."
msgstr ""
"Skapar och returnerar ett nytt :class:`ShareableList`-objekt, initierat med "
"värdena från indatans *sekvens*."

msgid ""
"The following example demonstrates the basic mechanisms of a :class:"
"`~multiprocessing.managers.SharedMemoryManager`:"
msgstr ""
"Följande exempel visar de grundläggande mekanismerna i en :class:"
"`~multiprocessing.managers.SharedMemoryManager`:"

msgid ""
">>> from multiprocessing.managers import SharedMemoryManager\n"
">>> smm = SharedMemoryManager()\n"
">>> smm.start()  # Start the process that manages the shared memory blocks\n"
">>> sl = smm.ShareableList(range(4))\n"
">>> sl\n"
"ShareableList([0, 1, 2, 3], name='psm_6572_7512')\n"
">>> raw_shm = smm.SharedMemory(size=128)\n"
">>> another_sl = smm.ShareableList('alpha')\n"
">>> another_sl\n"
"ShareableList(['a', 'l', 'p', 'h', 'a'], name='psm_6572_12221')\n"
">>> smm.shutdown()  # Calls unlink() on sl, raw_shm, and another_sl"
msgstr ""
">>> from multiprocessing.managers import SharedMemoryManager\n"
">>> smm = SharedMemoryManager()\n"
">>> smm.start() # Starta processen som hanterar de delade minnesblocken\n"
">>> sl = smm.ShareableList(intervall(4))\n"
">>> sl\n"
"ShareableList([0, 1, 2, 3], name='psm_6572_7512')\n"
">>> raw_shm = smm.SharedMemory(size=128)\n"
">>> en annan_sl = smm.shareableList('alpha')\n"
">>> en annan_sl\n"
"ShareableList(['a', 'l', 'p', 'h', 'a'], name='psm_6572_12221')\n"
">>> smm.shutdown() # Anropar unlink() på sl, raw_shm och another_sl"

msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`~multiprocessing.managers.SharedMemoryManager` objects via "
"the :keyword:`with` statement to ensure that all shared memory blocks are "
"released after they are no longer needed:"
msgstr ""
"I följande exempel visas ett potentiellt mer praktiskt mönster för "
"användning av :class:`~multiprocessing.managers.SharedMemoryManager`-objekt "
"via :keyword:`with`-satsen för att säkerställa att alla delade minnesblock "
"frigörs när de inte längre behövs:"

msgid ""
">>> with SharedMemoryManager() as smm:\n"
"...     sl = smm.ShareableList(range(2000))\n"
"...     # Divide the work among two processes, storing partial results in "
"sl\n"
"...     p1 = Process(target=do_work, args=(sl, 0, 1000))\n"
"...     p2 = Process(target=do_work, args=(sl, 1000, 2000))\n"
"...     p1.start()\n"
"...     p2.start()  # A multiprocessing.Pool might be more efficient\n"
"...     p1.join()\n"
"...     p2.join()   # Wait for all work to complete in both processes\n"
"...     total_result = sum(sl)  # Consolidate the partial results now in sl"
msgstr ""
">>> med SharedMemoryManager() som smm:\n"
"... sl = smm.ShareableList(intervall(2000))\n"
"...     # Dela upp arbetet mellan två processer och lagra delresultat i sl\n"
"... p1 = Process(target=do_work, args=(sl, 0, 1000))\n"
"... p2 = Process(target=do_work, args=(sl, 1000, 2000))\n"
"... p1.start()\n"
"... p2.start() # En multiprocessing.pool kan vara mer effektiv\n"
"... p1.join()\n"
"... p2.join() # Vänta tills allt arbete är klart i båda processerna\n"
"... total_result = sum(sl) # Konsolidera delresultaten nu i sl"

msgid ""
"When using a :class:`~multiprocessing.managers.SharedMemoryManager` in a :"
"keyword:`with` statement, the shared memory blocks created using that "
"manager are all released when the :keyword:`!with` statement's code block "
"finishes execution."
msgstr ""
"När du använder en :class:`~multiprocessing.managers.SharedMemoryManager` i "
"en :keyword:`with`-sats, frigörs alla delade minnesblock som skapats med den "
"hanteraren när :keyword:`!with`-satsens kodblock är färdigt exekverat."

msgid ""
"Provide a mutable list-like object where all values stored within are stored "
"in a shared memory block. This constrains storable values to the following "
"built-in data types:"
msgstr ""
"Tillhandahåller ett föränderligt listliknande objekt där alla värden som "
"lagras i objektet lagras i ett delat minnesblock. Detta begränsar "
"lagringsbara värden till följande inbyggda datatyper:"

msgid ":class:`int` (signed 64-bit)"
msgstr ":class:`int` (signerad 64-bitars)"

msgid ":class:`float`"
msgstr ":class:`float`"

msgid ":class:`bool`"
msgstr ":class:`bool`"

msgid ":class:`str` (less than 10M bytes each when encoded as UTF-8)"
msgstr ":class:`str` (mindre än 10M byte vardera när de kodas som UTF-8)"

msgid ":class:`bytes` (less than 10M bytes each)"
msgstr ":class:`bytes` (mindre än 10M bytes vardera)"

msgid "``None``"
msgstr "``Ingen``"

msgid ""
"It also notably differs from the built-in :class:`list` type in that these "
"lists can not change their overall length (i.e. no :meth:`!append`, :meth:`!"
"insert`, etc.) and do not support the dynamic creation of new :class:`!"
"ShareableList` instances via slicing."
msgstr ""
"Den skiljer sig också markant från den inbyggda :class:`list`-typen genom "
"att dessa listor inte kan ändra sin totala längd (dvs. ingen :meth:`!"
"append`, :meth:`!insert`, etc.) och inte stöder det dynamiska skapandet av "
"nya :class:`!ShareableList`-instanser via slicing."

msgid ""
"*sequence* is used in populating a new :class:`!ShareableList` full of "
"values. Set to ``None`` to instead attach to an already existing :class:`!"
"ShareableList` by its unique shared memory name."
msgstr ""
"*sequence* används för att fylla en ny :class:`!ShareableList` full med "
"värden. Sätt till ``None`` för att istället koppla till en redan "
"existerande :class:`!ShareableList` med dess unika namn i det delade minnet."

msgid ""
"*name* is the unique name for the requested shared memory, as described in "
"the definition for :class:`SharedMemory`.  When attaching to an existing :"
"class:`!ShareableList`, specify its shared memory block's unique name while "
"leaving *sequence* set to ``None``."
msgstr ""
"*name* är det unika namnet för det begärda delade minnet, enligt "
"beskrivningen i definitionen för :class:`SharedMemory`.  När du ansluter "
"till en befintlig :class:`!ShareableList`, ange det unika namnet på det "
"delade minnesblocket medan *sequence* är satt till ``None``."

msgid ""
"A known issue exists for :class:`bytes` and :class:`str` values. If they end "
"with ``\\x00`` nul bytes or characters, those may be *silently stripped* "
"when fetching them by index from the :class:`!ShareableList`. This ``."
"rstrip(b'\\x00')`` behavior is considered a bug and may go away in the "
"future. See :gh:`106939`."
msgstr ""
"Ett känt problem finns för :class:`bytes` och :class:`str`-värden. Om de "
"slutar med ``\\x00`` nollbytes eller tecken, kan dessa *tyst avlägsnas* när "
"de hämtas med index från :class:`!ShareableList`. Detta ``."
"rstrip(b'\\x00')``-beteende anses vara en bugg och kan försvinna i "
"framtiden. Se :gh:`106939`."

msgid ""
"For applications where rstripping of trailing nulls is a problem, work "
"around it by always unconditionally appending an extra non-0 byte to the end "
"of such values when storing and unconditionally removing it when fetching:"
msgstr ""
"För applikationer där rstripping av efterföljande nollor är ett problem, kan "
"du kringgå det genom att alltid ovillkorligen lägga till en extra icke-0-"
"byte i slutet av sådana värden vid lagring och ovillkorligen ta bort den vid "
"hämtning:"

msgid ""
">>> from multiprocessing import shared_memory\n"
">>> nul_bug_demo = shared_memory.ShareableList(['?\\x00', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00'])\n"
">>> nul_bug_demo[0]\n"
"'?'\n"
">>> nul_bug_demo[1]\n"
"b'\\x03\\x02\\x01'\n"
">>> nul_bug_demo.shm.unlink()\n"
">>> padded = shared_memory.ShareableList(['?\\x00\\x07', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00\\x07'])\n"
">>> padded[0][:-1]\n"
"'?\\x00'\n"
">>> padded[1][:-1]\n"
"b'\\x03\\x02\\x01\\x00\\x00\\x00'\n"
">>> padded.shm.unlink()"
msgstr ""
">>> from multiprocessing import shared_memory\n"
">>> nul_bug_demo = shared_memory.ShareableList(['?\\x00', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00\\x00'])\n"
">>> nul_bug_demo[0]\n"
"'?'\n"
">>> nul_bug_demo[1]\n"
"b'\\x03\\x02\\x01'\n"
">>> nul_bug_demo.shm.unlink()\n"
">>> padded = shared_memory.ShareableList(['?\\x00\\x07', "
"b'\\x03\\x02\\x01\\x00\\x00\\x00\\x07'])\n"
">>> utfylld[0][:-1]\n"
"'?\\x00'\n"
">>> utfylld[1][:-1]\n"
"b'\\x03\\x02\\x01\\x00\\x00\\x00'\n"
">>> padded.shm.unlink()"

msgid "Return the number of occurrences of *value*."
msgstr "Returnera antalet förekomster av *värde*."

msgid ""
"Return first index position of *value*. Raise :exc:`ValueError` if *value* "
"is not present."
msgstr ""
"Returnerar första indexpositionen för *värde*. Utlöser :exc:`ValueError` om "
"*värde* inte finns."

msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by all "
"currently stored values."
msgstr ""
"Skrivskyddat attribut som innehåller förpackningsformatet :mod:`struct` som "
"används av alla aktuella lagrade värden."

msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr "Den :class:`SharedMemory`-instans där värdena lagras."

msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr ""
"Följande exempel visar grundläggande användning av en :class:`ShareableList`-"
"instans:"

msgid ""
"The following example depicts how one, two, or many processes may access the "
"same :class:`ShareableList` by supplying the name of the shared memory block "
"behind it:"
msgstr ""
"Följande exempel visar hur en, två eller många processer kan komma åt samma :"
"class:`ShareableList` genom att ange namnet på det bakomliggande delade "
"minnesblocket:"

msgid ""
"The following examples demonstrates that :class:`ShareableList` (and "
"underlying :class:`SharedMemory`) objects can be pickled and unpickled if "
"needed. Note, that it will still be the same shared object. This happens, "
"because the deserialized object has the same unique name and is just "
"attached to an existing object with the same name (if the object is still "
"alive):"
msgstr ""
"Följande exempel visar att :class:`ShareableList` (och underliggande :class:"
"`SharedMemory`) objekt kan picklas och unpicklas vid behov. Notera, att det "
"fortfarande kommer att vara samma delade objekt. Detta händer eftersom det "
"deserialiserade objektet har samma unika namn och bara är kopplat till ett "
"befintligt objekt med samma namn (om objektet fortfarande är vid liv):"

msgid "Shared Memory"
msgstr "Delat minne"

msgid "POSIX Shared Memory"
msgstr "POSIX delat minne"

msgid "Named Shared Memory"
msgstr "Namngivet delat minne"
