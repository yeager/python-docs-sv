# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Curses Programming with Python"
msgstr "Curses-programmering med Python"

msgid "Author"
msgstr "Författare"

msgid "A.M. Kuchling, Eric S. Raymond"
msgstr "A.M. Kuchling, Eric S. Raymond"

msgid "Release"
msgstr "Release"

msgid "2.04"
msgstr "2.04"

msgid "Abstract"
msgstr "Abstrakt"

msgid ""
"This document describes how to use the :mod:`curses` extension module to "
"control text-mode displays."
msgstr ""
"I det här dokumentet beskrivs hur du använder tilläggsmodulen :mod:`curses` "
"för att styra textlägesdisplayer."

msgid "What is curses?"
msgstr "Vad är curses?"

msgid ""
"The curses library supplies a terminal-independent screen-painting and "
"keyboard-handling facility for text-based terminals; such terminals include "
"VT100s, the Linux console, and the simulated terminal provided by various "
"programs.  Display terminals support various control codes to perform common "
"operations such as moving the cursor, scrolling the screen, and erasing "
"areas.  Different terminals use widely differing codes, and often have their "
"own minor quirks."
msgstr ""
"Curses-biblioteket tillhandahåller en terminaloberoende skärmmålnings- och "
"tangentbordshanteringsfunktion för textbaserade terminaler; sådana "
"terminaler inkluderar VT100, Linux-konsolen och den simulerade terminalen "
"som tillhandahålls av olika program.  Displayterminaler stöder olika "
"kontrollkoder för att utföra vanliga åtgärder som att flytta markören, rulla "
"skärmen och radera områden.  Olika terminaler använder vitt skilda koder och "
"har ofta sina egna små egenheter."

msgid ""
"In a world of graphical displays, one might ask \"why bother\"?  It's true "
"that character-cell display terminals are an obsolete technology, but there "
"are niches in which being able to do fancy things with them are still "
"valuable.  One niche is on small-footprint or embedded Unixes that don't run "
"an X server.  Another is tools such as OS installers and kernel "
"configurators that may have to run before any graphical support is available."
msgstr ""
"I en värld av grafiska skärmar kan man fråga sig \"varför bry sig\"?  Det är "
"sant att terminaler med teckencellsskärm är en föråldrad teknik, men det "
"finns nischer där det fortfarande är värdefullt att kunna göra snygga saker "
"med dem.  En nisch är små eller inbäddade Unix-datorer som inte kör en X-"
"server.  En annan är verktyg som OS-installatörer och kärnkonfiguratorer som "
"kan behöva köras innan något grafiskt stöd finns tillgängligt."

msgid ""
"The curses library provides fairly basic functionality, providing the "
"programmer with an abstraction of a display containing multiple non-"
"overlapping windows of text.  The contents of a window can be changed in "
"various ways---adding text, erasing it, changing its appearance---and the "
"curses library will figure out what control codes need to be sent to the "
"terminal to produce the right output.  curses doesn't provide many user-"
"interface concepts such as buttons, checkboxes, or dialogs; if you need such "
"features, consider a user interface library such as :pypi:`Urwid`."
msgstr ""
"Curses-biblioteket har ganska grundläggande funktioner och ger "
"programmeraren en abstraktion av en bildskärm som innehåller flera icke "
"överlappande textfönster.  Innehållet i ett fönster kan ändras på olika sätt "
"- lägga till text, radera den, ändra dess utseende - och curses-biblioteket "
"räknar ut vilka kontrollkoder som behöver skickas till terminalen för att "
"producera rätt utdata. curses tillhandahåller inte många "
"användargränssnittskoncept som knappar, kryssrutor eller dialogrutor; om du "
"behöver sådana funktioner, överväg ett användargränssnittsbibliotek som :"
"pypi:`Urwid`."

msgid ""
"The curses library was originally written for BSD Unix; the later System V "
"versions of Unix from AT&T added many enhancements and new functions. BSD "
"curses is no longer maintained, having been replaced by ncurses, which is an "
"open-source implementation of the AT&T interface.  If you're using an open-"
"source Unix such as Linux or FreeBSD, your system almost certainly uses "
"ncurses.  Since most current commercial Unix versions are based on System V "
"code, all the functions described here will probably be available.  The "
"older versions of curses carried by some proprietary Unixes may not support "
"everything, though."
msgstr ""
"Curses-biblioteket skrevs ursprungligen för BSD Unix; de senare System V-"
"versionerna av Unix från AT&T lade till många förbättringar och nya "
"funktioner. BSD curses underhålls inte längre, utan har ersatts av ncurses, "
"som är en implementering av AT&T-gränssnittet med öppen källkod.  Om du "
"använder ett Unix med öppen källkod, som Linux eller FreeBSD, använder ditt "
"system nästan säkert ncurses.  Eftersom de flesta aktuella kommersiella Unix-"
"versioner är baserade på System V-kod, kommer alla funktioner som beskrivs "
"här förmodligen att finnas tillgängliga.  De äldre versionerna av curses som "
"finns i vissa proprietära Unix-system kanske dock inte stöder allt."

msgid ""
"The Windows version of Python doesn't include the :mod:`curses` module.  A "
"ported version called :pypi:`UniCurses` is available."
msgstr ""
"Windows-versionen av Python innehåller inte modulen :mod:`curses`.  En "
"portad version som heter :pypi:`UniCurses` är tillgänglig."

msgid "The Python curses module"
msgstr "Python-modulen curses"

msgid ""
"The Python module is a fairly simple wrapper over the C functions provided "
"by curses; if you're already familiar with curses programming in C, it's "
"really easy to transfer that knowledge to Python.  The biggest difference is "
"that the Python interface makes things simpler by merging different C "
"functions such as :c:func:`!addstr`, :c:func:`!mvaddstr`, and :c:func:`!"
"mvwaddstr` into a single :meth:`~curses.window.addstr` method.  You'll see "
"this covered in more detail later."
msgstr ""
"Python-modulen är ett ganska enkelt omslag över de C-funktioner som "
"tillhandahålls av curses; om du redan är bekant med curses-programmering i C "
"är det väldigt enkelt att överföra den kunskapen till Python.  Den största "
"skillnaden är att Python-gränssnittet gör saker enklare genom att slå samman "
"olika C-funktioner som :c:func:`!addstr`, :c:func:`!mvaddstr` och :c:func:`!"
"mvwaddstr` till en enda :meth:`~curses.window.addstr`-metod.  Du kommer att "
"se detta mer i detalj senare."

msgid ""
"This HOWTO is an introduction to writing text-mode programs with curses and "
"Python. It doesn't attempt to be a complete guide to the curses API; for "
"that, see the Python library guide's section on ncurses, and the C manual "
"pages for ncurses.  It will, however, give you the basic ideas."
msgstr ""
"Denna HOWTO är en introduktion till att skriva textlägesprogram med curses "
"och Python. Den försöker inte vara en komplett guide till curses API; för "
"det, se Python-biblioteksguidens avsnitt om ncurses och C-manualsidorna för "
"ncurses.  Det kommer dock att ge dig de grundläggande idéerna."

msgid "Starting and ending a curses application"
msgstr "Starta och avsluta en curses-applikation"

msgid ""
"Before doing anything, curses must be initialized.  This is done by calling "
"the :func:`~curses.initscr` function, which will determine the terminal "
"type, send any required setup codes to the terminal, and create various "
"internal data structures.  If successful, :func:`!initscr` returns a window "
"object representing the entire screen; this is usually called ``stdscr`` "
"after the name of the corresponding C variable. ::"
msgstr ""
"Innan något kan göras måste curses initialiseras.  Detta görs genom att "
"anropa funktionen :func:`~curses.initscr`, som bestämmer terminaltypen, "
"skickar alla nödvändiga inställningskoder till terminalen och skapar olika "
"interna datastrukturer.  Om funktionen lyckas returnerar :func:`!initscr` "
"ett fönsterobjekt som representerar hela skärmen; detta kallas vanligtvis "
"``stdscr`` efter namnet på motsvarande C-variabel. ::"

msgid ""
"import curses\n"
"stdscr = curses.initscr()"
msgstr ""
"import curses\n"
"stdscr = curses.initscr()"

msgid ""
"Usually curses applications turn off automatic echoing of keys to the "
"screen, in order to be able to read keys and only display them under certain "
"circumstances.  This requires calling the :func:`~curses.noecho` function. ::"
msgstr ""
"Vanligtvis stänger curses-applikationer av automatisk ekoåtergivning av "
"tangenter till skärmen, för att kunna läsa tangenter och bara visa dem under "
"vissa omständigheter.  Detta kräver att man anropar funktionen :func:"
"`~curses.noecho`. ::"

msgid "curses.noecho()"
msgstr "curses.noecho()"

msgid ""
"Applications will also commonly need to react to keys instantly, without "
"requiring the Enter key to be pressed; this is called cbreak mode, as "
"opposed to the usual buffered input mode. ::"
msgstr ""
"Program behöver också ofta reagera på tangenter direkt, utan att Enter-"
"tangenten behöver tryckas; detta kallas cbreak-läge, i motsats till det "
"vanliga buffrade inmatningsläget. ::"

msgid "curses.cbreak()"
msgstr "curses.cbreak()"

msgid ""
"Terminals usually return special keys, such as the cursor keys or navigation "
"keys such as Page Up and Home, as a multibyte escape sequence.  While you "
"could write your application to expect such sequences and process them "
"accordingly, curses can do it for you, returning a special value such as :"
"const:`curses.KEY_LEFT`.  To get curses to do the job, you'll have to enable "
"keypad mode. ::"
msgstr ""
"Terminaler returnerar vanligtvis specialtangenter, t.ex. markörknapparna "
"eller navigeringstangenter som Page Up och Home, som en escape-sekvens med "
"flera byte.  Du kan skriva ditt program så att det förväntar sig sådana "
"sekvenser och behandlar dem därefter, men curses kan göra det åt dig genom "
"att returnera ett specialvärde som :const:`curses.KEY_LEFT`.  För att få "
"curses att göra jobbet måste du aktivera tangentbordsläget. ::"

msgid "stdscr.keypad(True)"
msgstr "stdscr.keypad(True)"

msgid ""
"Terminating a curses application is much easier than starting one. You'll "
"need to call::"
msgstr ""
"Att avsluta en curses-applikation är mycket enklare än att starta en. Du "
"behöver bara anropa::"

msgid ""
"curses.nocbreak()\n"
"stdscr.keypad(False)\n"
"curses.echo()"
msgstr ""
"curses.nocbreak()\n"
"stdscr.keypad(False)\n"
"curses.echo()"

msgid ""
"to reverse the curses-friendly terminal settings. Then call the :func:"
"`~curses.endwin` function to restore the terminal to its original operating "
"mode. ::"
msgstr ""
"för att återställa de curses-vänliga terminalinställningarna. Anropa sedan "
"funktionen :func:`~curses.endwin` för att återställa terminalen till dess "
"ursprungliga driftläge. ::"

msgid "curses.endwin()"
msgstr "curses.endwin()"

msgid ""
"A common problem when debugging a curses application is to get your terminal "
"messed up when the application dies without restoring the terminal to its "
"previous state.  In Python this commonly happens when your code is buggy and "
"raises an uncaught exception.  Keys are no longer echoed to the screen when "
"you type them, for example, which makes using the shell difficult."
msgstr ""
"Ett vanligt problem när man felsöker en curses-applikation är att terminalen "
"blir rörig när applikationen dör utan att terminalen återställs till sitt "
"tidigare tillstånd.  I Python händer detta ofta när din kod är buggig och "
"ger upphov till ett undantag som inte fångats upp.  Tangenter ekar inte "
"längre på skärmen när du skriver dem, till exempel, vilket gör det svårt att "
"använda skalet."

msgid ""
"In Python you can avoid these complications and make debugging much easier "
"by importing the :func:`curses.wrapper` function and using it like this::"
msgstr ""
"I Python kan du undvika dessa komplikationer och göra felsökningen mycket "
"enklare genom att importera funktionen :func:`curses.wrapper` och använda "
"den så här::"

msgid ""
"from curses import wrapper\n"
"\n"
"def main(stdscr):\n"
"    # Clear screen\n"
"    stdscr.clear()\n"
"\n"
"    # This raises ZeroDivisionError when i == 10.\n"
"    for i in range(0, 11):\n"
"        v = i-10\n"
"        stdscr.addstr(i, 0, '10 divided by {} is {}'.format(v, 10/v))\n"
"\n"
"        stdscr.refresh()\n"
"        stdscr.getkey()\n"
"\n"
"wrapper(main)"
msgstr ""
"from curses import wrapper\n"
"\n"
"def main(stdscr):\n"
"    # Clear screen\n"
"    stdscr.clear()\n"
"\n"
"    # This raises ZeroDivisionError when i == 10.\n"
"    for i in range(0, 11):\n"
"        v = i-10\n"
"        stdscr.addstr(i, 0, '10 divided by {} is {}'.format(v, 10/v))\n"
"\n"
"        stdscr.refresh()\n"
"        stdscr.getkey()\n"
"\n"
"wrapper(main)"

msgid ""
"The :func:`~curses.wrapper` function takes a callable object and does the "
"initializations described above, also initializing colors if color support "
"is present.  :func:`!wrapper` then runs your provided callable. Once the "
"callable returns, :func:`!wrapper` will restore the original state of the "
"terminal.  The callable is called inside a :keyword:`try`...\\ :keyword:"
"`except` that catches exceptions, restores the state of the terminal, and "
"then re-raises the exception.  Therefore your terminal won't be left in a "
"funny state on exception and you'll be able to read the exception's message "
"and traceback."
msgstr ""
"Funktionen :func:`~curses.wrapper` tar ett anropbart objekt och gör de "
"initialiseringar som beskrivs ovan, samt initialiserar färger om det finns "
"färgstöd. :func:`!wrapper` kör sedan din tillhandahållna anropbara kod. När "
"det anropbara objektet returneras återställer :func:`!wrapper` terminalens "
"ursprungliga tillstånd.  Den anropbara funktionen anropas inuti en :keyword:"
"`try`...\\ :keyword:`except` som fångar upp undantag, återställer "
"terminalens tillstånd och sedan anropar undantaget igen.  Därför kommer din "
"terminal inte att lämnas i ett konstigt tillstånd vid undantag och du kommer "
"att kunna läsa undantagets meddelande och traceback."

msgid "Windows and Pads"
msgstr "Fönster och pads"

msgid ""
"Windows are the basic abstraction in curses.  A window object represents a "
"rectangular area of the screen, and supports methods to display text, erase "
"it, allow the user to input strings, and so forth."
msgstr ""
"Fönster är den grundläggande abstraktionen i curses.  Ett fönsterobjekt "
"representerar ett rektangulärt område på skärmen och stöder metoder för att "
"visa text, radera den, låta användaren mata in strängar och så vidare."

msgid ""
"The ``stdscr`` object returned by the :func:`~curses.initscr` function is a "
"window object that covers the entire screen.  Many programs may need only "
"this single window, but you might wish to divide the screen into smaller "
"windows, in order to redraw or clear them separately. The :func:`~curses."
"newwin` function creates a new window of a given size, returning the new "
"window object. ::"
msgstr ""
"Objektet ``stdscr`` som returneras av funktionen :func:`~curses.initscr` är "
"ett fönsterobjekt som täcker hela skärmen.  Många program behöver bara detta "
"enda fönster, men du kanske vill dela upp skärmen i mindre fönster för att "
"kunna rita om eller rensa dem separat. Funktionen :func:`~curses.newwin` "
"skapar ett nytt fönster av en given storlek och returnerar det nya "
"fönsterobjektet. ::"

msgid ""
"begin_x = 20; begin_y = 7\n"
"height = 5; width = 40\n"
"win = curses.newwin(height, width, begin_y, begin_x)"
msgstr ""
"begin_x = 20; begin_y = 7\n"
"height = 5; width = 40\n"
"win = curses.newwin(height, width, begin_y, begin_x)"

msgid ""
"Note that the coordinate system used in curses is unusual. Coordinates are "
"always passed in the order *y,x*, and the top-left corner of a window is "
"coordinate (0,0).  This breaks the normal convention for handling "
"coordinates where the *x* coordinate comes first.  This is an unfortunate "
"difference from most other computer applications, but it's been part of "
"curses since it was first written, and it's too late to change things now."
msgstr ""
"Observera att det koordinatsystem som används i curses är ovanligt. "
"Koordinater skickas alltid i ordningen *y,x*, och det övre vänstra hörnet av "
"ett fönster är koordinat (0,0).  Detta bryter mot den normala konventionen "
"för hantering av koordinater där *x*-koordinaten kommer först.  Detta är en "
"olycklig skillnad mot de flesta andra datorprogram, men det har varit en del "
"av curses sedan det först skrevs, och det är för sent att ändra på saker nu."

msgid ""
"Your application can determine the size of the screen by using the :data:"
"`curses.LINES` and :data:`curses.COLS` variables to obtain the *y* and *x* "
"sizes.  Legal coordinates will then extend from ``(0,0)`` to ``(curses.LINES "
"- 1, curses.COLS - 1)``."
msgstr ""
"Ditt program kan bestämma skärmens storlek genom att använda variablerna :"
"data:`curses.LINES` och :data:`curses.COLS` för att få storlekarna *y* och "
"*x*.  Lagliga koordinater kommer då att sträcka sig från ``(0,0)`` till "
"``(curses.LINES - 1, curses.COLS - 1)``."

msgid ""
"When you call a method to display or erase text, the effect doesn't "
"immediately show up on the display.  Instead you must call the :meth:"
"`~curses.window.refresh` method of window objects to update the screen."
msgstr ""
"När du anropar en metod för att visa eller radera text visas inte effekten "
"omedelbart på skärmen.  Istället måste du anropa metoden :meth:`~curses."
"window.refresh` för fönsterobjekt för att uppdatera skärmen."

msgid ""
"This is because curses was originally written with slow 300-baud terminal "
"connections in mind; with these terminals, minimizing the time required to "
"redraw the screen was very important.  Instead curses accumulates changes to "
"the screen and displays them in the most efficient manner when you call :"
"meth:`!refresh`.  For example, if your program displays some text in a "
"window and then clears the window, there's no need to send the original text "
"because they're never visible."
msgstr ""
"Detta beror på att curses ursprungligen skrevs med tanke på långsamma 300-"
"baud terminalanslutningar; med dessa terminaler var det mycket viktigt att "
"minimera den tid som krävdes för att rita om skärmen.  Istället ackumulerar "
"curses ändringar på skärmen och visar dem på det mest effektiva sättet när "
"du anropar :meth:`!refresh`.  Om ditt program t.ex. visar text i ett fönster "
"och sedan rensar fönstret, behöver du inte skicka originaltexten eftersom "
"den aldrig är synlig."

msgid ""
"In practice, explicitly telling curses to redraw a window doesn't really "
"complicate programming with curses much. Most programs go into a flurry of "
"activity, and then pause waiting for a keypress or some other action on the "
"part of the user.  All you have to do is to be sure that the screen has been "
"redrawn before pausing to wait for user input, by first calling :meth:`!"
"stdscr.refresh` or the :meth:`!refresh` method of some other relevant window."
msgstr ""
"I praktiken är det inte särskilt komplicerat att programmera med curses om "
"man uttryckligen säger till curses att rita om ett fönster. De flesta "
"program går in i en febril aktivitet och pausar sedan i väntan på en "
"tangenttryckning eller någon annan åtgärd från användarens sida.  Allt du "
"behöver göra är att vara säker på att skärmen har ritats om innan du pausar "
"för att vänta på användarinmatning, genom att först anropa :meth:`!stdscr."
"refresh` eller :meth:`!refresh`-metoden för något annat relevant fönster."

msgid ""
"A pad is a special case of a window; it can be larger than the actual "
"display screen, and only a portion of the pad displayed at a time. Creating "
"a pad requires the pad's height and width, while refreshing a pad requires "
"giving the coordinates of the on-screen area where a subsection of the pad "
"will be displayed.  ::"
msgstr ""
"En pad är ett specialfall av ett fönster; den kan vara större än den "
"faktiska skärmen och endast en del av padden visas åt gången. För att skapa "
"en pad krävs paddens höjd och bredd, medan uppdatering av en pad kräver att "
"koordinaterna anges för det område på skärmen där en del av padden ska visas:"

msgid ""
"pad = curses.newpad(100, 100)\n"
"# These loops fill the pad with letters; addch() is\n"
"# explained in the next section\n"
"for y in range(0, 99):\n"
"    for x in range(0, 99):\n"
"        pad.addch(y,x, ord('a') + (x*x+y*y) % 26)\n"
"\n"
"# Displays a section of the pad in the middle of the screen.\n"
"# (0,0) : coordinate of upper-left corner of pad area to display.\n"
"# (5,5) : coordinate of upper-left corner of window area to be filled\n"
"#         with pad content.\n"
"# (20, 75) : coordinate of lower-right corner of window area to be\n"
"#          : filled with pad content.\n"
"pad.refresh( 0,0, 5,5, 20,75)"
msgstr ""
"pad = curses.newpad(100, 100)\n"
"# Dessa slingor fyller paddan med bokstäver; addch() förklaras\n"
"# förklaras i nästa avsnitt\n"
"för y i intervallet(0, 99):\n"
"    for x in range(0, 99):\n"
"        pad.addch(y,x, ord('a') + (x*x+y*y) % 26)\n"
"\n"
"# Visar ett utsnitt av paddan i mitten av skärmen.\n"
"# (0,0) : koordinat för det övre vänstra hörnet av det område som ska "
"visas.\n"
"# (5,5) : koordinat för övre vänstra hörnet av fönsterområdet som ska "
"fyllas\n"
"# med pad-innehåll.\n"
"# (20, 75) : koordinat för det nedre högra hörnet av fönsterytan som ska\n"
"# : fyllas med pad-innehåll.\n"
"pad.refresh( 0,0, 5,5, 20,75)"

msgid ""
"The :meth:`!refresh` call displays a section of the pad in the rectangle "
"extending from coordinate (5,5) to coordinate (20,75) on the screen; the "
"upper left corner of the displayed section is coordinate (0,0) on the pad.  "
"Beyond that difference, pads are exactly like ordinary windows and support "
"the same methods."
msgstr ""
"Anropet :meth:`!refresh` visar en del av padden i den rektangel som sträcker "
"sig från koordinat (5,5) till koordinat (20,75) på skärmen; det övre vänstra "
"hörnet av den visade delen är koordinat (0,0) på padden.  Utöver denna "
"skillnad är paddar precis som vanliga fönster och stöder samma metoder."

msgid ""
"If you have multiple windows and pads on screen there is a more efficient "
"way to update the screen and prevent annoying screen flicker as each part of "
"the screen gets updated.  :meth:`!refresh` actually does two things:"
msgstr ""
"Om du har flera fönster och pads på skärmen finns det ett mer effektivt sätt "
"att uppdatera skärmen och förhindra irriterande skärmflimmer när varje del "
"av skärmen uppdateras. :meth:`!refresh` gör faktiskt två saker:"

msgid ""
"Calls the :meth:`~curses.window.noutrefresh` method of each window to update "
"an underlying data structure representing the desired state of the screen."
msgstr ""
"Anropar :meth:`~curses.window.noutrefresh`-metoden för varje fönster för att "
"uppdatera en underliggande datastruktur som representerar det önskade "
"tillståndet på skärmen."

msgid ""
"Calls the function :func:`~curses.doupdate` function to change the physical "
"screen to match the desired state recorded in the data structure."
msgstr ""
"Anropar funktionen :func:`~curses.doupdate` för att ändra den fysiska "
"skärmen så att den motsvarar det önskade tillstånd som registrerats i "
"datastrukturen."

msgid ""
"Instead you can call :meth:`!noutrefresh` on a number of windows to update "
"the data structure, and then call :func:`!doupdate` to update the screen."
msgstr ""
"Istället kan du anropa :meth:`!noutrefresh` på ett antal fönster för att "
"uppdatera datastrukturen, och sedan anropa :func:`!doupdate` för att "
"uppdatera skärmen."

msgid "Displaying Text"
msgstr "Visning av text"

msgid ""
"From a C programmer's point of view, curses may sometimes look like a twisty "
"maze of functions, all subtly different.  For example, :c:func:`!addstr` "
"displays a string at the current cursor location in the ``stdscr`` window, "
"while :c:func:`!mvaddstr` moves to a given y,x coordinate first before "
"displaying the string. :c:func:`!waddstr` is just like :c:func:`!addstr`, "
"but allows specifying a window to use instead of using ``stdscr`` by "
"default. :c:func:`!mvwaddstr` allows specifying both a window and a "
"coordinate."
msgstr ""
"Från en C-programmerares synvinkel kan curses ibland se ut som en snårig "
"labyrint av funktioner, alla subtilt olika.  Till exempel visar :c:func:`!"
"addstr` en sträng vid den aktuella markörpositionen i fönstret ``stdscr``, "
"medan :c:func:`!mvaddstr` först flyttar till en given y,x-koordinat innan "
"strängen visas. :c:func:`!waddstr` är precis som :c:func:`!addstr`, men "
"tillåter att man anger ett fönster att använda istället för att använda "
"``stdscr`` som standard. :c:func:`!mvwaddstr` tillåter att man anger både "
"ett fönster och en koordinat."

msgid ""
"Fortunately the Python interface hides all these details.  ``stdscr`` is a "
"window object like any other, and methods such as :meth:`~curses.window."
"addstr` accept multiple argument forms.  Usually there are four different "
"forms."
msgstr ""
"Lyckligtvis döljer Python-gränssnittet alla dessa detaljer.  ``stdscr`` är "
"ett fönsterobjekt som alla andra, och metoder som :meth:`~curses.window."
"addstr` accepterar flera argumentformer.  Vanligtvis finns det fyra olika "
"former."

msgid "Form"
msgstr "Formulär"

msgid "Description"
msgstr "Beskrivning"

msgid "*str* or *ch*"
msgstr "*str* eller *ch*"

msgid "Display the string *str* or character *ch* at the current position"
msgstr "Visa strängen *str* eller tecknet *ch* vid den aktuella positionen"

msgid "*str* or *ch*, *attr*"
msgstr "*str* eller *ch*, *attr*"

msgid ""
"Display the string *str* or character *ch*, using attribute *attr* at the "
"current position"
msgstr ""
"Visa strängen *str* eller tecknet *ch* med attributet *attr* på den aktuella "
"positionen"

msgid "*y*, *x*, *str* or *ch*"
msgstr "*y*, *x*, *str* eller *ch*"

msgid "Move to position *y,x* within the window, and display *str* or *ch*"
msgstr "Flytta till position *y,x* i fönstret och visa *str* eller *ch*"

msgid "*y*, *x*, *str* or *ch*, *attr*"
msgstr "*y*, *x*, *str* eller *ch*, *attr*"

msgid ""
"Move to position *y,x* within the window, and display *str* or *ch*, using "
"attribute *attr*"
msgstr ""
"Flytta till position *y,x* i fönstret och visa *str* eller *ch* med hjälp av "
"attributet *attr*"

msgid ""
"Attributes allow displaying text in highlighted forms such as boldface, "
"underline, reverse code, or in color.  They'll be explained in more detail "
"in the next subsection."
msgstr ""
"Attribut gör det möjligt att visa text i markerade former som fetstil, "
"understrykning, omvänd kod eller i färg.  De förklaras mer i detalj i nästa "
"underavsnitt."

msgid ""
"The :meth:`~curses.window.addstr` method takes a Python string or bytestring "
"as the value to be displayed.  The contents of bytestrings are sent to the "
"terminal as-is.  Strings are encoded to bytes using the value of the "
"window's :attr:`~window.encoding` attribute; this defaults to the default "
"system encoding as returned by :func:`locale.getencoding`."
msgstr ""
"Metoden :meth:`~curses.window.addstr` tar en Python-sträng eller bytestring "
"som det värde som ska visas.  Innehållet i bytestrings skickas till "
"terminalen som det är.  Strängar kodas till bytes med hjälp av värdet i "
"fönstrets attribut :attr:`~window.encoding`; detta är standardvärdet för "
"systemets standardkodning som returneras av :func:`locale.getencoding`."

msgid ""
"The :meth:`~curses.window.addch` methods take a character, which can be "
"either a string of length 1, a bytestring of length 1, or an integer."
msgstr ""
"Metoderna :meth:`~curses.window.addch` tar ett tecken, som kan vara antingen "
"en sträng med längden 1, en bytestring med längden 1 eller ett heltal."

msgid ""
"Constants are provided for extension characters; these constants are "
"integers greater than 255.  For example, :const:`ACS_PLMINUS` is a +/- "
"symbol, and :const:`ACS_ULCORNER` is the upper left corner of a box (handy "
"for drawing borders).  You can also use the appropriate Unicode character."
msgstr ""
"Konstanter finns för tilläggstecken; dessa konstanter är heltal större än "
"255.  Exempelvis är :const:`ACS_PLMINUS` en +/- symbol och :const:"
"`ACS_ULCORNER` är det övre vänstra hörnet av en ruta (praktiskt för att rita "
"gränser).  Du kan också använda lämpliga Unicode-tecken."

msgid ""
"Windows remember where the cursor was left after the last operation, so if "
"you leave out the *y,x* coordinates, the string or character will be "
"displayed wherever the last operation left off.  You can also move the "
"cursor with the ``move(y,x)`` method.  Because some terminals always display "
"a flashing cursor, you may want to ensure that the cursor is positioned in "
"some location where it won't be distracting; it can be confusing to have the "
"cursor blinking at some apparently random location."
msgstr ""
"Windows kommer ihåg var markören befann sig efter den senaste operationen, "
"så om du utelämnar *y,x*-koordinaterna kommer strängen eller tecknet att "
"visas där den senaste operationen slutade.  Du kan också flytta markören med "
"metoden ``move(y,x)``.  Eftersom vissa terminaler alltid visar en blinkande "
"markör kan det vara bra att se till att markören är placerad på en plats där "
"den inte stör; det kan vara förvirrande att ha markören blinkande på en till "
"synes slumpmässig plats."

msgid ""
"If your application doesn't need a blinking cursor at all, you can call "
"``curs_set(False)`` to make it invisible.  For compatibility with older "
"curses versions, there's a ``leaveok(bool)`` function that's a synonym for :"
"func:`~curses.curs_set`.  When *bool* is true, the curses library will "
"attempt to suppress the flashing cursor, and you won't need to worry about "
"leaving it in odd locations."
msgstr ""
"Om ditt program inte alls behöver en blinkande markör kan du anropa "
"``curs_set(False)`` för att göra den osynlig.  För kompatibilitet med äldre "
"curses-versioner finns funktionen ``leaveok(bool)`` som är en synonym till :"
"func:`~curses.curs_set`.  När *bool* är sant kommer curses-biblioteket att "
"försöka undertrycka den blinkande markören, och du behöver inte oroa dig för "
"att lämna den på udda platser."

msgid "Attributes and Color"
msgstr "Attribut och färg"

msgid ""
"Characters can be displayed in different ways.  Status lines in a text-based "
"application are commonly shown in reverse video, or a text viewer may need "
"to highlight certain words.  curses supports this by allowing you to specify "
"an attribute for each cell on the screen."
msgstr ""
"Tecken kan visas på olika sätt.  Statusrader i en textbaserad applikation "
"visas ofta i omvänd video, eller så kan en textvisare behöva markera vissa "
"ord. curses stöder detta genom att låta dig ange ett attribut för varje cell "
"på skärmen."

msgid ""
"An attribute is an integer, each bit representing a different attribute.  "
"You can try to display text with multiple attribute bits set, but curses "
"doesn't guarantee that all the possible combinations are available, or that "
"they're all visually distinct.  That depends on the ability of the terminal "
"being used, so it's safest to stick to the most commonly available "
"attributes, listed here."
msgstr ""
"Ett attribut är ett heltal, där varje bit representerar ett annat attribut.  "
"Du kan försöka visa text med flera attributbitar inställda, men curses "
"garanterar inte att alla möjliga kombinationer är tillgängliga eller att de "
"alla är visuellt distinkta.  Det beror på hur bra terminalen som används är, "
"så det är säkrast att hålla sig till de vanligaste attributen, som listas "
"här."

msgid "Attribute"
msgstr "Attribut"

msgid ":const:`A_BLINK`"
msgstr ":const:`A_BLÄNK`"

msgid "Blinking text"
msgstr "Blinkande text"

msgid ":const:`A_BOLD`"
msgstr ":const:`A_BOLD`"

msgid "Extra bright or bold text"
msgstr "Extra ljus eller fet text"

msgid ":const:`A_DIM`"
msgstr ":const:`A_DIM`"

msgid "Half bright text"
msgstr "Halv ljus text"

msgid ":const:`A_REVERSE`"
msgstr ":const:`A_REVERSE`"

msgid "Reverse-video text"
msgstr "Text för omvänd video"

msgid ":const:`A_STANDOUT`"
msgstr ":const:`A_STANDOUT`"

msgid "The best highlighting mode available"
msgstr "Det bästa markeringsläget som finns"

msgid ":const:`A_UNDERLINE`"
msgstr ":const:`A_UNDERLINE`"

msgid "Underlined text"
msgstr "Understruken text"

msgid ""
"So, to display a reverse-video status line on the top line of the screen, "
"you could code::"
msgstr ""
"För att visa en statusrad med omvänd video på den övre raden på skärmen kan "
"du alltså koda::"

msgid ""
"stdscr.addstr(0, 0, \"Current mode: Typing mode\",\n"
"              curses.A_REVERSE)\n"
"stdscr.refresh()"
msgstr ""
"stdscr.addstr(0, 0,\"Aktuellt läge: Skrivläge\",\n"
"              curses.A_REVERSE)\n"
"stdscr.refresh()"

msgid ""
"The curses library also supports color on those terminals that provide it. "
"The most common such terminal is probably the Linux console, followed by "
"color xterms."
msgstr ""
"Curses-biblioteket stöder också färg på de terminaler som tillhandahåller "
"det. Den vanligaste sådana terminalen är förmodligen Linux-konsolen, följt "
"av färg xterms."

msgid ""
"To use color, you must call the :func:`~curses.start_color` function soon "
"after calling :func:`~curses.initscr`, to initialize the default color set "
"(the :func:`curses.wrapper` function does this automatically).  Once that's "
"done, the :func:`~curses.has_colors` function returns TRUE if the terminal "
"in use can actually display color.  (Note: curses uses the American spelling "
"'color', instead of the Canadian/British spelling 'colour'.  If you're used "
"to the British spelling, you'll have to resign yourself to misspelling it "
"for the sake of these functions.)"
msgstr ""
"För att använda färg måste du anropa funktionen :func:`~curses.start_color` "
"strax efter anropet av :func:`~curses.initscr`, för att initiera "
"standardfärgsättningen (funktionen :func:`curses.wrapper` gör detta "
"automatiskt).  När det är gjort returnerar funktionen :func:`~curses."
"has_colors` TRUE om terminalen som används faktiskt kan visa färg. (Obs: "
"curses använder den amerikanska stavningen \"color\", istället för den "
"kanadensiska/brittiska stavningen \"colour\".  Om du är van vid den "
"brittiska stavningen får du finna dig i att stava det fel för dessa "
"funktioners skull)"

msgid ""
"The curses library maintains a finite number of color pairs, containing a "
"foreground (or text) color and a background color.  You can get the "
"attribute value corresponding to a color pair with the :func:`~curses."
"color_pair` function; this can be bitwise-OR'ed with other attributes such "
"as :const:`A_REVERSE`, but again, such combinations are not guaranteed to "
"work on all terminals."
msgstr ""
"Curses-biblioteket har ett begränsat antal färgpar, som innehåller en "
"förgrundsfärg (eller textfärg) och en bakgrundsfärg.  Du kan få fram "
"attributvärdet som motsvarar ett färgpar med funktionen :func:`~curses."
"color_pair`; detta kan bitvis-OR:as med andra attribut som :const:"
"`A_REVERSE`, men återigen, sådana kombinationer är inte garanterade att "
"fungera på alla terminaler."

msgid "An example, which displays a line of text using color pair 1::"
msgstr "Ett exempel, som visar en textrad med färgparet 1::"

msgid ""
"stdscr.addstr(\"Pretty text\", curses.color_pair(1))\n"
"stdscr.refresh()"
msgstr ""
"stdscr.addstr(\"Fin text\", curses.color_pair(1))\n"
"stdscr.refresh()"

msgid ""
"As I said before, a color pair consists of a foreground and background "
"color. The ``init_pair(n, f, b)`` function changes the definition of color "
"pair *n*, to foreground color f and background color b.  Color pair 0 is "
"hard-wired to white on black, and cannot be changed."
msgstr ""
"Som jag sa tidigare består ett färgpar av en förgrunds- och en "
"bakgrundsfärg. Funktionen ``init_pair(n, f, b)`` ändrar definitionen av "
"färgparet *n*, till förgrundsfärgen f och bakgrundsfärgen b. Färgparet 0 är "
"hårdkodat till vitt på svart och kan inte ändras."

msgid ""
"Colors are numbered, and :func:`start_color` initializes 8 basic colors when "
"it activates color mode.  They are: 0:black, 1:red, 2:green, 3:yellow, 4:"
"blue, 5:magenta, 6:cyan, and 7:white.  The :mod:`curses` module defines "
"named constants for each of these colors: :const:`curses.COLOR_BLACK`, :"
"const:`curses.COLOR_RED`, and so forth."
msgstr ""
"Färgerna är numrerade och :func:`start_color` initierar 8 grundfärger när "
"den aktiverar färgläget.  Dessa är: 0:svart, 1:röd, 2:grön, 3:gul, 4:blå, 5:"
"magenta, 6:cyan och 7:vit.  Modulen :mod:`curses` definierar namngivna "
"konstanter för var och en av dessa färger: :const:`curses.COLOR_BLACK`, :"
"const:`curses.COLOR_RED`, och så vidare."

msgid ""
"Let's put all this together. To change color 1 to red text on a white "
"background, you would call::"
msgstr ""
"Låt oss sätta ihop allt detta. För att ändra färg 1 till röd text på en vit "
"bakgrund, skulle du ringa::"

msgid "curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)"
msgstr "curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)"

msgid ""
"When you change a color pair, any text already displayed using that color "
"pair will change to the new colors.  You can also display new text in this "
"color with::"
msgstr ""
"När du ändrar ett färgpar kommer all text som redan visas med det färgparet "
"att ändras till de nya färgerna.  Du kan också visa ny text i den här färgen "
"med::"

msgid "stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1))"
msgstr "stdscr.addstr(0,0,\"RED ALERT!\", curses.color_pair(1))"

msgid ""
"Very fancy terminals can change the definitions of the actual colors to a "
"given RGB value.  This lets you change color 1, which is usually red, to "
"purple or blue or any other color you like.  Unfortunately, the Linux "
"console doesn't support this, so I'm unable to try it out, and can't provide "
"any examples.  You can check if your terminal can do this by calling :func:"
"`~curses.can_change_color`, which returns ``True`` if the capability is "
"there.  If you're lucky enough to have such a talented terminal, consult "
"your system's man pages for more information."
msgstr ""
"Mycket avancerade terminaler kan ändra definitionerna av de faktiska "
"färgerna till ett givet RGB-värde.  Detta gör att du kan ändra färg 1, som "
"vanligtvis är röd, till lila eller blå eller någon annan färg du vill ha.  "
"Tyvärr har Linux-konsolen inte stöd för detta, så jag kan inte prova det och "
"kan inte ge några exempel.  Du kan kontrollera om din terminal kan göra "
"detta genom att anropa :func:`~curses.can_change_color`, som returnerar "
"``True`` om möjligheten finns.  Om du har turen att ha en så begåvad "
"terminal kan du läsa mer i systemets man-sidor."

msgid "User Input"
msgstr "Användarinput"

msgid ""
"The C curses library offers only very simple input mechanisms. Python's :mod:"
"`curses` module adds a basic text-input widget.  (Other libraries such as :"
"pypi:`Urwid` have more extensive collections of widgets.)"
msgstr ""
"C-biblioteket curses erbjuder endast mycket enkla inmatningsmekanismer. "
"Pythons modul :mod:`curses` lägger till en grundläggande widget för "
"textinmatning.  (Andra bibliotek som :pypi:`Urwid` har mer omfattande "
"samlingar av widgetar)"

msgid "There are two methods for getting input from a window:"
msgstr "Det finns två metoder för att få in data från ett fönster:"

msgid ""
":meth:`~curses.window.getch` refreshes the screen and then waits for the "
"user to hit a key, displaying the key if :func:`~curses.echo` has been "
"called earlier.  You can optionally specify a coordinate to which the cursor "
"should be moved before pausing."
msgstr ""
":meth:`~curses.window.getch` uppdaterar skärmen och väntar sedan på att "
"användaren ska trycka på en tangent, och visar tangenten om :func:`~curses."
"echo` har anropats tidigare.  Du kan eventuellt ange en koordinat till "
"vilken markören ska flyttas innan den pausas."

msgid ""
":meth:`~curses.window.getkey` does the same thing but converts the integer "
"to a string.  Individual characters are returned as 1-character strings, and "
"special keys such as function keys return longer strings containing a key "
"name such as ``KEY_UP`` or ``^G``."
msgstr ""
":meth:`~curses.window.getkey` gör samma sak men omvandlar heltalet till en "
"sträng.  Enskilda tecken returneras som strängar med 1 tecken, och "
"specialnycklar som funktionstangenter returnerar längre strängar som "
"innehåller ett nyckelnamn som ``KEY_UP`` eller ``^G``."

msgid ""
"It's possible to not wait for the user using the :meth:`~curses.window."
"nodelay` window method. After ``nodelay(True)``, :meth:`!getch` and :meth:`!"
"getkey` for the window become non-blocking. To signal that no input is "
"ready, :meth:`!getch` returns ``curses.ERR`` (a value of -1) and :meth:`!"
"getkey` raises an exception. There's also a :func:`~curses.halfdelay` "
"function, which can be used to (in effect) set a timer on each :meth:`!"
"getch`; if no input becomes available within a specified delay (measured in "
"tenths of a second), curses raises an exception."
msgstr ""
"Det är möjligt att inte vänta på användaren med hjälp av fönstermetoden :"
"meth:`~curses.window.nodelay`. Efter ``nodelay(True)`` blir :meth:`!getch` "
"och :meth:`!getkey` för fönstret icke-blockerande. För att signalera att "
"ingen inmatning är klar returnerar :meth:`!getch` ``curses.ERR`` (ett värde "
"på -1) och :meth:`!getkey` utlöser ett undantag. Det finns också en :func:"
"`~curses.halfdelay`-funktion, som kan användas för att (i praktiken) ställa "
"in en timer på varje :meth:`!getch`; om ingen inmatning blir tillgänglig "
"inom en angiven fördröjning (mätt i tiondelar av en sekund), ger curses "
"upphov till ett undantag."

msgid ""
"The :meth:`!getch` method returns an integer; if it's between 0 and 255, it "
"represents the ASCII code of the key pressed.  Values greater than 255 are "
"special keys such as Page Up, Home, or the cursor keys. You can compare the "
"value returned to constants such as :const:`curses.KEY_PPAGE`, :const:"
"`curses.KEY_HOME`, or :const:`curses.KEY_LEFT`.  The main loop of your "
"program may look something like this::"
msgstr ""
"Metoden :meth:`!getch` returnerar ett heltal; om det är mellan 0 och 255 "
"representerar det ASCII-koden för den tangent som tryckts in.  Värden större "
"än 255 är specialtangenter som Page Up, Home eller markörknapparna. Du kan "
"jämföra det returnerade värdet med konstanter som :const:`curses."
"KEY_PPAGE`, :const:`curses.KEY_HOME` eller :const:`curses.KEY_LEFT`.  "
"Huvudloopen i ditt program kan se ut ungefär så här::"

msgid ""
"while True:\n"
"    c = stdscr.getch()\n"
"    if c == ord('p'):\n"
"        PrintDocument()\n"
"    elif c == ord('q'):\n"
"        break  # Exit the while loop\n"
"    elif c == curses.KEY_HOME:\n"
"        x = y = 0"
msgstr ""
"medan True:\n"
"    c = stdscr.getch()\n"
"    if c == ord('p'):\n"
"        PrintDocument()\n"
"    elif c == ord('q'):\n"
"        break # Avsluta while-slingan\n"
"    elif c == curses.KEY_HOME:\n"
"        x = y = 0"

msgid ""
"The :mod:`curses.ascii` module supplies ASCII class membership functions "
"that take either integer or 1-character string arguments; these may be "
"useful in writing more readable tests for such loops.  It also supplies "
"conversion functions  that take either integer or 1-character-string "
"arguments and return the same type.  For example, :func:`curses.ascii.ctrl` "
"returns the control character corresponding to its argument."
msgstr ""
"Modulen :mod:`curses.ascii` tillhandahåller ASCII-"
"klasstillhörighetsfunktioner som tar antingen heltals- eller 1-"
"teckenssträngargument; dessa kan vara användbara för att skriva mer läsbara "
"tester för sådana loopar.  Den innehåller också konverteringsfunktioner som "
"tar antingen heltal eller 1-teckenssträngar som argument och returnerar "
"samma typ.  Till exempel returnerar :func:`curses.ascii.ctrl` det "
"kontrolltecken som motsvarar dess argument."

msgid ""
"There's also a method to retrieve an entire string, :meth:`~curses.window."
"getstr`.  It isn't used very often, because its functionality is quite "
"limited; the only editing keys available are the backspace key and the Enter "
"key, which terminates the string.  It can optionally be limited to a fixed "
"number of characters. ::"
msgstr ""
"Det finns också en metod för att hämta en hel sträng, :meth:`~curses.window."
"getstr`.  Den används inte så ofta eftersom dess funktionalitet är ganska "
"begränsad; de enda redigeringstangenter som finns är backstegstangenten och "
"Enter-tangenten, som avslutar strängen.  Den kan eventuellt begränsas till "
"ett fast antal tecken. ::"

msgid ""
"curses.echo()            # Enable echoing of characters\n"
"\n"
"# Get a 15-character string, with the cursor on the top line\n"
"s = stdscr.getstr(0,0, 15)"
msgstr ""
"curses.echo() # Aktivera eko av tecken\n"
"\n"
"# Hämta en sträng med 15 tecken, med markören på den översta raden\n"
"s = stdscr.getstr(0,0, 15)"

msgid ""
"The :mod:`curses.textpad` module supplies a text box that supports an Emacs-"
"like set of keybindings.  Various methods of the :class:`~curses.textpad."
"Textbox` class support editing with input validation and gathering the edit "
"results either with or without trailing spaces.  Here's an example::"
msgstr ""
"Modulen :mod:`curses.textpad` tillhandahåller en textruta som stöder en "
"Emacs-liknande uppsättning tangentbindningar.  Olika metoder i klassen :"
"class:`~curses.textpad.Textbox` stöder redigering med inmatningsvalidering "
"och insamling av redigeringsresultaten antingen med eller utan efterföljande "
"mellanslag.  Här är ett exempel::"

msgid ""
"import curses\n"
"from curses.textpad import Textbox, rectangle\n"
"\n"
"def main(stdscr):\n"
"    stdscr.addstr(0, 0, \"Enter IM message: (hit Ctrl-G to send)\")\n"
"\n"
"    editwin = curses.newwin(5,30, 2,1)\n"
"    rectangle(stdscr, 1,0, 1+5+1, 1+30+1)\n"
"    stdscr.refresh()\n"
"\n"
"    box = Textbox(editwin)\n"
"\n"
"    # Let the user edit until Ctrl-G is struck.\n"
"    box.edit()\n"
"\n"
"    # Get resulting contents\n"
"    message = box.gather()"
msgstr ""
"import curses\n"
"from curses.textpad import Textbox, rectangle\n"
"\n"
"def main(stdscr):\n"
"    stdscr.addstr(0, 0, \"Enter IM message: (hit Ctrl-G to send)\")\n"
"\n"
"    editwin = curses.newwin(5,30, 2,1)\n"
"    rectangle(stdscr, 1,0, 1+5+1, 1+30+1)\n"
"    stdscr.refresh()\n"
"\n"
"    box = Textbox(editwin)\n"
"\n"
"    # Let the user edit until Ctrl-G is struck.\n"
"    box.edit()\n"
"\n"
"    # Get resulting contents\n"
"    message = box.gather()"

msgid ""
"See the library documentation on :mod:`curses.textpad` for more details."
msgstr ""
"Se biblioteksdokumentationen för :mod:`curses.textpad` för mer information."

msgid "For More Information"
msgstr "För mer information"

msgid ""
"This HOWTO doesn't cover some advanced topics, such as reading the contents "
"of the screen or capturing mouse events from an xterm instance, but the "
"Python library page for the :mod:`curses` module is now reasonably "
"complete.  You should browse it next."
msgstr ""
"Denna HOWTO täcker inte några avancerade ämnen, som att läsa innehållet på "
"skärmen eller fånga mushändelser från en xterm-instans, men Python-"
"bibliotekssidan för modulen :mod:`curses` är nu någorlunda komplett.  Du bör "
"bläddra igenom den härnäst."

msgid ""
"If you're in doubt about the detailed behavior of the curses functions, "
"consult the manual pages for your curses implementation, whether it's "
"ncurses or a proprietary Unix vendor's.  The manual pages will document any "
"quirks, and provide complete lists of all the functions, attributes, and :"
"ref:`ACS_\\* <curses-acs-codes>` characters available to you."
msgstr ""
"Om du är osäker på hur curses-funktionerna fungerar i detalj bör du läsa "
"manualsidorna för din curses-implementering, oavsett om det är ncurses eller "
"en egenutvecklad Unix-leverantörs.  Manualsidorna dokumenterar alla "
"konstigheter och innehåller fullständiga listor över alla funktioner, "
"attribut och :ref:`ACS_\\* <curses-acs-codes>`-tecken som är tillgängliga "
"för dig."

msgid ""
"Because the curses API is so large, some functions aren't supported in the "
"Python interface.  Often this isn't because they're difficult to implement, "
"but because no one has needed them yet.  Also, Python doesn't yet support "
"the menu library associated with ncurses. Patches adding support for these "
"would be welcome; see `the Python Developer's Guide <https://devguide.python."
"org/>`_ to learn more about submitting patches to Python."
msgstr ""
"Eftersom curses API är så stort finns det funktioner som inte stöds i Python-"
"gränssnittet.  Ofta beror detta inte på att de är svåra att implementera, "
"utan på att ingen har behövt dem ännu.  Dessutom stöder Python ännu inte "
"menybiblioteket som är associerat med ncurses. Patchar som lägger till stöd "
"för dessa skulle vara välkomna; se `the Python Developer's Guide <https://"
"devguide.python.org/>`_ för att lära dig mer om att skicka in patchar till "
"Python."

msgid ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses/ncurses-"
"intro.html>`_: a lengthy tutorial for C programmers."
msgstr ""
"`Writing Programs with NCURSES <https://invisible-island.net/ncurses/ncurses-"
"intro.html>`_: en utförlig handledning för C-programmerare."

msgid "`The ncurses man page <https://linux.die.net/man/3/ncurses>`_"
msgstr "\"Manuell sida för ncurses <https://linux.die.net/man/3/ncurses>"

msgid ""
"`The ncurses FAQ <https://invisible-island.net/ncurses/ncurses.faq.html>`_"
msgstr ""
"fAQ om ncurses <https://invisible-island.net/ncurses/ncurses.faq.html>`_"

msgid ""
"`\"Use curses... don't swear\" <https://www.youtube.com/watch?"
"v=eN1eZtjLEnU>`_: video of a PyCon 2013 talk on controlling terminals using "
"curses or Urwid."
msgstr ""
"`\"Use curses... don't swwear\" <https://www.youtube.com/watch?"
"v=eN1eZtjLEnU>`_: video av ett PyCon 2013-tal om att styra terminaler med "
"hjälp av curses eller Urwid."

msgid ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568/console-"
"applications-with-urwid>`_: video of a PyCon CA 2012 talk demonstrating some "
"applications written using Urwid."
msgstr ""
"`\"Console Applications with Urwid\" <https://pyvideo.org/video/1568/console-"
"applications-with-urwid>`_: video av ett föredrag på PyCon CA 2012 som visar "
"några program som skrivits med Urwid."
