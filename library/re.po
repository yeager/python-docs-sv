# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!re` --- Regular expression operations"
msgstr ":mod:`!re` --- Operationer med reguljära uttryck"

msgid "**Source code:** :source:`Lib/re/`"
msgstr "**Källkod:** :källa:`Lib/re/`"

msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Den här modulen innehåller funktioner för matchning med reguljära uttryck "
"som liknar dem som finns i Perl."

msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a bytes pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"Både mönster och strängar som ska sökas kan vara Unicode-strängar (:class:"
"`str`) såväl som 8-bitarssträngar (:class:`bytes`). Unicode-strängar och 8-"
"bitarssträngar kan dock inte blandas: det vill säga, du kan inte matcha en "
"Unicode-sträng med ett bytesmönster eller vice versa; på samma sätt måste "
"ersättningssträngen vara av samma typ som både mönstret och söksträngen när "
"du ber om en substitution."

msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`SyntaxWarning` and in the "
"future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"Reguljära uttryck använder tecknet backslash (``'\\'``) för att ange "
"speciella former eller för att tillåta att specialtecken används utan att "
"deras speciella betydelse åberopas.  Detta kolliderar med Pythons användning "
"av samma tecken för samma ändamål i stränglitteraler; till exempel, för att "
"matcha en bokstavlig backslash kan man behöva skriva ``'\\\\\\\\'`` som "
"mönstersträng, eftersom det reguljära uttrycket måste vara ``\\``, och varje "
"backslash måste uttryckas som ``\\\\`` inuti en reguljär Python-"
"stränglitteral. Observera också att alla ogiltiga escape-sekvenser i Pythons "
"användning av backslash i stränglitteraler nu genererar en :exc:"
"`SyntaxWarning` och i framtiden kommer detta att bli en :exc:`SyntaxError`. "
"Detta beteende kommer att ske även om det är en giltig escape-sekvens för "
"ett reguljärt uttryck."

msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"Lösningen är att använda Pythons råa strängnotation för reguljära "
"uttrycksmönster; backslash hanteras inte på något speciellt sätt i en "
"stränglitual med prefixet ``'r'``.  Så ``r\"\\n\"`` är en tvåteckenssträng "
"som innehåller ``'\\'`` och ``'n'``, medan ``\"\\n\"`` är en enteckenssträng "
"som innehåller en ny rad.  Vanligtvis kommer mönster att uttryckas i Python-"
"kod med hjälp av denna råa strängnotation."

msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"Det är viktigt att notera att de flesta operationer med reguljära uttryck "
"finns tillgängliga som funktioner och metoder på modulnivå på :ref:"
"``compiled regular expressions <re-objects>``.  Funktionerna är genvägar som "
"inte kräver att du först kompilerar ett regex-objekt, men saknar vissa "
"finjusteringsparametrar."

msgid ""
"The third-party :pypi:`regex` module, which has an API compatible with the "
"standard library :mod:`re` module, but offers additional functionality and a "
"more thorough Unicode support."
msgstr ""
"Tredjepartsmodulen :pypi:`regex`, som har ett API som är kompatibelt med "
"standardbibliotekets modul :mod:`re`, men som erbjuder ytterligare "
"funktionalitet och ett mer omfattande Unicode-stöd."

msgid "Regular Expression Syntax"
msgstr "Syntax för reguljära uttryck"

msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Ett reguljärt uttryck (eller RE) anger en uppsättning strängar som matchar "
"det; med funktionerna i den här modulen kan du kontrollera om en viss sträng "
"matchar ett visst reguljärt uttryck (eller om ett visst reguljärt uttryck "
"matchar en viss sträng, vilket är samma sak)."

msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"Reguljära uttryck kan sammankopplas för att bilda nya reguljära uttryck; om "
"*A* och *B* båda är reguljära uttryck, är *AB* också ett reguljärt uttryck. "
"I allmänhet gäller att om en sträng *p* matchar *A* och en annan sträng *q* "
"matchar *B*, kommer strängen *pq* att matcha AB.  Detta gäller om inte *A* "
"eller *B* innehåller operationer med låg prioritet, gränsvillkor mellan *A* "
"och *B* eller har numrerade gruppreferenser.  Komplexa uttryck kan alltså "
"lätt konstrueras från enklare primitiva uttryck som de som beskrivs här.  "
"För detaljer om teorin och implementeringen av reguljära uttryck, se Friedls "
"bok [Frie09]_, eller nästan vilken lärobok som helst om "
"kompilatorkonstruktion."

msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Här följer en kort förklaring av formatet för reguljära uttryck.  För "
"ytterligare information och en mildare presentation, se :ref:`regex-howto`."

msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"Reguljära uttryck kan innehålla både specialtecken och vanliga tecken. De "
"flesta vanliga tecken, som ``'A'``, ``'a'`` eller ``'0'``, är de enklaste "
"reguljära uttrycken; de matchar helt enkelt sig själva.  Du kan konkatenera "
"vanliga tecken, så att ``last`` matchar strängen ``'last'``.  (I resten av "
"det här avsnittet skriver vi RE:s med ``den här speciella stilen``, "
"vanligtvis utan citationstecken, och strängar som ska matchas ``'med enkla "
"citationstecken``)"

msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Vissa tecken, som ``'|'`` eller ``'('``, är specialtecken. Specialtecken "
"står antingen för klasser av vanliga tecken eller påverkar hur de reguljära "
"uttryck som omger dem tolkas."

msgid ""
"Repetition operators or quantifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) "
"cannot be directly nested. This avoids ambiguity with the non-greedy "
"modifier suffix ``?``, and with other modifiers in other implementations. To "
"apply a second repetition to an inner repetition, parentheses may be used. "
"For example, the expression ``(?:a{6})*`` matches any multiple of six "
"``'a'`` characters."
msgstr ""
"Repetitionsoperatorer eller kvantifierare (``*``, ``+``, ``?``, ``{m,n}``, "
"etc) kan inte direkt nästlas. Detta undviker tvetydighet med det icke-greedy "
"modifieringssuffixet ``?``, och med andra modifierare i andra "
"implementeringar. För att tillämpa en andra upprepning på en inre upprepning "
"kan parenteser användas. Till exempel matchar uttrycket ``(?:a{6})*`` alla "
"multiplar av sex ``'a'``-tecken."

msgid "The special characters are:"
msgstr "Specialtecknen är följande:"

msgid "``.``"
msgstr "``.``"

msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline.  ``(?s:.)`` matches any character regardless of flags."
msgstr ""
"(Punkt.) I standardläget matchar detta alla tecken utom en ny rad.  Om "
"flaggan :const:`DOTALL` har angetts, matchar detta alla tecken inklusive en "
"ny rad.  ``(?s:.)`` matchar alla tecken oavsett flaggor."

msgid "``^``"
msgstr "``^``"

msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Caret.) Matchar början av strängen, och i :const:`MULTILINE`-läget även "
"omedelbart efter varje ny rad."

msgid "``$``"
msgstr "``$``"

msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Matchar slutet av strängen eller precis före den nya raden i slutet av "
"strängen, och i :const:`MULTILINE`-läget även före en ny rad.  ``foo`` "
"matchar både 'foo' och 'foobar', medan det reguljära uttrycket ``foo$`` "
"endast matchar 'foo'.  Mer intressant är att en sökning efter ``foo.$`` i "
"``'foo1\\nfoo2\\n'`` normalt matchar 'foo2', men 'foo1' i :const:`MULTILINE`-"
"läget; en sökning efter en enda ``$`` i ``'foo\\n'`` kommer att hitta två "
"(tomma) träffar: en precis före det nya strecket och en i slutet av strängen."

msgid "``*``"
msgstr "``*``"

msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Gör att den resulterande RE:n matchar 0 eller flera upprepningar av den "
"föregående RE:n, så många upprepningar som möjligt.  ``ab*`` matchar 'a', "
"'ab' eller 'a' följt av ett valfritt antal 'b'."

msgid "``+``"
msgstr "``+``"

msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Gör att den resulterande RE:n matchar 1 eller flera upprepningar av den "
"föregående RE:n. ``ab+`` kommer att matcha 'a' följt av ett valfritt antal "
"'b' som inte är noll; det kommer inte att matcha bara 'a'."

msgid "``?``"
msgstr "``?``"

msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Gör att den resulterande RE:n matchar 0 eller 1 upprepningar av den "
"föregående RE:n. ``ab?`` kommer att matcha antingen 'a' eller 'ab'."

msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` quantifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the quantifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"Kvantifierarna ``'*'``, ``'+'`` och ``'?'`` är alla :dfn:`greedy`; de "
"matchar så mycket text som möjligt.  Ibland är detta beteende inte önskvärt; "
"om RE ``<.*>`` matchas mot ``'<a> b <c>'``, kommer den att matcha hela "
"strängen, och inte bara ``'<a>'``.  Om du lägger till ``?`` efter "
"kvantifieraren kommer den att utföra matchningen på :dfn:`non-greedy` eller :"
"dfn:`minimal` sätt; så *få* tecken som möjligt kommer att matchas.  Om RE "
"``<.*?>`` används kommer endast ``'<a>'`` att matchas."

msgid "``*+``, ``++``, ``?+``"
msgstr "``*+``, ``++``, ``?+``"

msgid ""
"Like the ``'*'``, ``'+'``, and ``'?'`` quantifiers, those where ``'+'`` is "
"appended also match as many times as possible. However, unlike the true "
"greedy quantifiers, these do not allow back-tracking when the expression "
"following it fails to match. These are known as :dfn:`possessive` "
"quantifiers. For example, ``a*a`` will match ``'aaaa'`` because the ``a*`` "
"will match all 4 ``'a'``\\ s, but, when the final ``'a'`` is encountered, "
"the expression is backtracked so that in the end the ``a*`` ends up matching "
"3 ``'a'``\\ s total, and the fourth ``'a'`` is matched by the final ``'a'``. "
"However, when ``a*+a`` is used to match ``'aaaa'``, the ``a*+`` will match "
"all 4 ``'a'``, but when the final ``'a'`` fails to find any more characters "
"to match, the expression cannot be backtracked and will thus fail to match. "
"``x*+``, ``x++`` and ``x?+`` are equivalent to ``(?>x*)``, ``(?>x+)`` and "
"``(?>x?)`` correspondingly."
msgstr ""
"Liksom kvantifierarna ``'*'``, ``'+'`` och ``'?'`` matchar de där ``'+'`` är "
"tillagt också så många gånger som möjligt. Men till skillnad från de riktiga "
"greedy-kvantifierarna tillåter dessa inte backspårning när uttrycket efter "
"det inte matchar. Dessa är kända som :dfn:`possessiva` kvantifierare. Till "
"exempel kommer ``a*a`` att matcha ``'aaaa'`` eftersom ``a*`` kommer att "
"matcha alla 4 ``'a'`` s, men när den sista ``'a'`` påträffas, spåras "
"uttrycket tillbaka så att ``a*`` i slutändan matchar 3 ``'a'`` s totalt, och "
"den fjärde ``'a'`` matchas av den sista ``'a'``. Men när ``a*+a`` används "
"för att matcha ``'aaaa'`` kommer ``a*+`` att matcha alla fyra ``'a'``, men "
"när den sista ``'a'`` inte hittar några fler tecken att matcha kan uttrycket "
"inte spåras tillbaka och kommer därför inte att matcha. ``x*+``, ``x++`` och "
"``x?+`` är likvärdiga med ``(?>x*)``, ``(?>x+)`` och ``(?>x?)`` på "
"motsvarande sätt."

msgid "``{m}``"
msgstr "``{m}``"

msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Anger att exakt *m* kopior av föregående RE ska matchas; färre matchningar "
"gör att hela RE inte matchas.  Till exempel kommer ``a{6}`` att matcha exakt "
"sex ``'a'``-tecken, men inte fem."

msgid "``{m,n}``"
msgstr "``{m,n}``"

msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Gör att den resulterande RE:n matchar från *m* till *n* upprepningar av den "
"föregående RE:n, med försök att matcha så många upprepningar som möjligt.  "
"Exempelvis kommer ``a{3,5}`` att matcha mellan 3 och 5 ``'a'``-tecken.  Om "
"*m* utelämnas anges en nedre gräns på noll, och om *n* utelämnas anges en "
"oändlig övre gräns.  Som ett exempel kommer ``a{4,}b`` att matcha "
"``'aaaab'`` eller tusen ``'a'``-tecken följt av ett ``'b'``, men inte "
"``'aaab'``. Kommatecknet får inte utelämnas, eftersom modifieraren då skulle "
"förväxlas med den tidigare beskrivna formen."

msgid "``{m,n}?``"
msgstr "``{m,n}?``"

msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous quantifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"Gör att den resulterande RE:n matchar från *m* till *n* repetitioner av "
"föregående RE, med försök att matcha så *få* repetitioner som möjligt.  "
"Detta är den icke-grådiga versionen av den föregående kvantifieraren.  Till "
"exempel, på strängen ``'aaaaaa'`` med 6 tecken kommer ``a{3,5}`` att matcha "
"5 ``'a'``-tecken, medan ``a{3,5}?`` endast kommer att matcha 3 tecken."

msgid "``{m,n}+``"
msgstr "``{m,n}+``"

msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible *without* "
"establishing any backtracking points. This is the possessive version of the "
"quantifier above. For example, on the 6-character string ``'aaaaaa'``, "
"``a{3,5}+aa`` attempt to match 5 ``'a'`` characters, then, requiring 2 more "
"``'a'``\\ s, will need more characters than available and thus fail, while "
"``a{3,5}aa`` will match with ``a{3,5}`` capturing 5, then 4 ``'a'``\\ s by "
"backtracking and then the final 2 ``'a'``\\ s are matched by the final "
"``aa`` in the pattern. ``x{m,n}+`` is equivalent to ``(?>x{m,n})``."
msgstr ""
"Gör att den resulterande RE:n matchar från *m* till *n* upprepningar av "
"föregående RE, med försök att matcha så många upprepningar som möjligt "
"*utan* att skapa några backtracking-punkter. Detta är den possessiva "
"versionen av kvantifieraren ovan. Till exempel, på strängen ``'aaaaaa'`` med "
"6 tecken, försöker ``a{3,5}+aa`` matcha 5 ``'a'``-tecken, sedan, när "
"ytterligare 2 ``'a'``-tecken krävs, behöver fler tecken än tillgängliga och "
"misslyckas därför, medan ``a{3,5}aa`` kommer att matcha med ``a{3,5}`` som "
"fångar 5, sedan 4 ``'a'``-tecken genom backtracking och sedan matchas de "
"sista 2 ``'a'``-tecken av den sista ``aa`` i mönstret. ``x{m,n}+`` är "
"likvärdigt med ``(?>x{m,n})``."

msgid "``\\``"
msgstr "``\\``"

msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Antingen undviker du specialtecken (så att du kan matcha tecken som ``'*'``, "
"``'?'`` osv.) eller så signalerar du en specialsekvens; specialsekvenser "
"diskuteras nedan."

msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Om du inte använder en rå sträng för att uttrycka mönstret, kom ihåg att "
"Python också använder backslash som en escape-sekvens i stränglitteraler; om "
"escape-sekvensen inte känns igen av Pythons parser, inkluderas backslash och "
"efterföljande tecken i den resulterande strängen.  Men om Python skulle "
"känna igen den resulterande sekvensen, bör backslash upprepas två gånger.  "
"Det här är komplicerat och svårt att förstå, så det rekommenderas starkt att "
"du använder råa strängar för alla utom de enklaste uttrycken."

msgid "``[]``"
msgstr "``[]``"

msgid "Used to indicate a set of characters.  In a set:"
msgstr "Används för att ange en uppsättning tecken.  I en uppsättning:"

msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Tecken kan listas individuellt, t.ex. kommer ``[amk]`` att matcha ``'a'``, "
"``'m'`` eller ``'k'``."

msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Teckenintervall kan anges genom att ange två tecken och separera dem med "
"``'-'``, t.ex. ``[a-z]`` matchar alla gemena ASCII-bokstäver, ``[0-5][0-9]`` "
"matchar alla tvåsiffriga tal från ``00`` till ``59`` och ``[0-9A-Fa-f]`` "
"matchar alla hexadecimala siffror.  Om ``-`` är escapat (t.ex. ``[a\\-z]``) "
"eller om det placeras som första eller sista tecken (t.ex. ``[-a]`` eller "
"``[a-]``), kommer det att matcha ett bokstavligt ``'-'``."

msgid ""
"Special characters except backslash lose their special meaning inside sets. "
"For example, ``[(+*)]`` will match any of the literal characters ``'('``, "
"``'+'``, ``'*'``, or ``')'``."
msgstr ""
"Specialtecken utom backslash förlorar sin speciella betydelse i "
"uppsättningar. Till exempel kommer ``[(+*)]`` att matcha vilket som helst av "
"de bokstavliga tecknen ``'('``, ``'+'``, ``'*'`` eller ``')'``."

msgid ""
"Backslash either escapes characters which have special meaning in a set such "
"as ``'-'``, ``']'``, ``'^'`` and ``'\\\\'`` itself or signals a special "
"sequence which represents a single character such as ``\\xa0`` or ``\\n`` or "
"a character class such as ``\\w`` or ``\\S`` (defined below). Note that "
"``\\b`` represents a single \"backspace\" character, not a word boundary as "
"outside a set, and numeric escapes such as ``\\1`` are always octal escapes, "
"not group references. Special sequences which do not match a single "
"character such as ``\\A`` and ``\\z`` are not allowed."
msgstr ""
"Backslash escapar antingen tecken som har en speciell betydelse i en "
"uppsättning, t.ex. ``'-'``, ``']'``, ``'^'`` och ``'\\\\'``, eller "
"signalerar en speciell sekvens som representerar ett enskilt tecken, t.ex. "
"``xa0`` eller ``n``, eller en teckenklass, t.ex. ``w`` eller ``S`` "
"(definieras nedan). Observera att ``b`` representerar ett enskilt "
"\"backspace\"-tecken, inte en ordgräns utanför en uppsättning, och numeriska "
"escapes som ``1`` är alltid oktala escapes, inte gruppreferenser. "
"Specialsekvenser som inte matchar ett enda tecken, t.ex. ``A`` och ``z``, är "
"inte tillåtna."

msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Tecken som inte finns inom ett intervall kan matchas genom att :dfn:"
"`komplettera` uppsättningen.  Om det första tecknet i uppsättningen är "
"``'^'`` kommer alla tecken som *inte* finns i uppsättningen att matchas.  "
"Till exempel kommer ``[^5]`` att matcha alla tecken utom ``'5'``, och "
"``[^^]`` kommer att matcha alla tecken utom ``'^'``.  ``^`` har ingen "
"speciell betydelse om det inte är det första tecknet i uppsättningen."

msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will match a right bracket, as well as left bracket, braces, "
"and parentheses."
msgstr ""
"För att matcha en bokstavlig ``']'`` inuti en uppsättning, föregå den med "
"ett backslash eller placera den i början av uppsättningen.  Till exempel "
"kommer både ``[()[\\]{}]`` och ``[]()[{}]`` att matcha en högerparentes "
"såväl som vänsterparenteser, hakparenteser och parenteser."

msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"Stöd för nästlade mängder och mängdoperationer som i `Unicode Technical "
"Standard #18`_ kan komma att läggas till i framtiden.  Detta skulle ändra "
"syntaxen, så för att underlätta denna förändring kommer en :exc:"
"`FutureWarning` att visas i tvetydiga fall för tillfället. Detta inkluderar "
"uppsättningar som börjar med en bokstavlig ``'['`` eller innehåller "
"bokstavliga teckensekvenser ``'--'``, ``'&&'``, ``'~~'`` och ``'||'``.  För "
"att undvika en varning, undvik dem med ett backslash."

msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
":exc:`FutureWarning` utlöses om en teckenuppsättning innehåller "
"konstruktioner som kommer att förändras semantiskt i framtiden."

msgid "``|``"
msgstr "``|``"

msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, där *A* och *B* kan vara godtyckliga RE:s, skapar ett reguljärt "
"uttryck som matchar antingen *A* eller *B*.  Ett godtyckligt antal RE:s kan "
"separeras med ``'|'`` på detta sätt.  Detta kan även användas inom grupper "
"(se nedan).  När målsträngen skannas testas RE:s som separerats med ``'|'`` "
"från vänster till höger. När ett mönster matchar fullständigt accepteras den "
"grenen. Detta innebär att när *A* matchar kommer *B* inte att testas "
"ytterligare, även om det skulle ge en längre total matchning.  Med andra ord "
"är operatorn ``'|'`` aldrig girig.  Om du vill matcha en bokstavlig ``'|'`` "
"använder du ``\\|` eller omsluter den i en teckenklass, som i ``[|]``."

msgid "``(...)``"
msgstr "``(...)``"

msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Matchar det reguljära uttryck som finns inom parentesen och anger början och "
"slutet på en grupp; innehållet i en grupp kan hämtas efter att en matchning "
"har utförts och kan matchas senare i strängen med specialsekvensen "
"``\\number``, som beskrivs nedan.  För att matcha bokstavstecken ``'('`` "
"eller ``')'``, använd ``(`` eller ``\\)``, eller omslut dem i en "
"teckenklass: ``[(]``, ``[)]``."

msgid "``(?...)``"
msgstr "``(?...)``"

msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Detta är en utvidgad notation (en ``'?'`` efter en ``'('`` är inte "
"meningsfull i övrigt).  Det första tecknet efter ``'?'`` avgör vad "
"konstruktionen har för betydelse och vidare syntax. Tillägg skapar "
"vanligtvis inte en ny grupp; ``(?P<name>...)`` är det enda undantaget från "
"denna regel. Följande är de tillägg som för närvarande stöds."

msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.) The group matches the empty string; the letters "
"set the corresponding flags for the entire regular expression:"
msgstr ""
"(En eller flera bokstäver från uppsättningen ``'a'``, ``'i'``, ``'L'``, "
"``'m'``, ``'s'``, ``'u'``, ``'x'``.) Gruppen matchar den tomma strängen; "
"bokstäverna anger motsvarande flaggor för hela det reguljära uttrycket:"

msgid ":const:`re.A` (ASCII-only matching)"
msgstr ":const:`re.A` (endast ASCII-matchning)"

msgid ":const:`re.I` (ignore case)"
msgstr ":const:`re.I` (ignorera fall)"

msgid ":const:`re.L` (locale dependent)"
msgstr ":const:`re.L` (lokalberoende)"

msgid ":const:`re.M` (multi-line)"
msgstr ":const:`re.M` (flerradig)"

msgid ":const:`re.S` (dot matches all)"
msgstr ":const:`re.S` (prick matchar alla)"

msgid ":const:`re.U` (Unicode matching)"
msgstr ":const:`re.U` (Unicode-matchning)"

msgid ":const:`re.X` (verbose)"
msgstr ":const:`re.X` (långsam)"

msgid ""
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if "
"you wish to include the flags as part of the regular expression, instead of "
"passing a *flag* argument to the :func:`re.compile` function. Flags should "
"be used first in the expression string."
msgstr ""
"(Flaggorna beskrivs i :ref:`contents-of-module-re`.) Detta är användbart om "
"du vill inkludera flaggorna som en del av det reguljära uttrycket, istället "
"för att skicka ett *flag*-argument till :func:`re.compile`-funktionen. "
"Flaggorna bör användas först i uttryckssträngen."

msgid "This construction can only be used at the start of the expression."
msgstr "Denna konstruktion kan endast användas i början av uttrycket."

msgid "``(?:...)``"
msgstr "``(?:...)``"

msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"En icke-fångande version av reguljära parenteser.  Matchar det reguljära "
"uttryck som finns inom parentesen, men den delsträng som matchas av gruppen "
"*kan* inte hämtas efter en matchning eller refereras till senare i mönstret."

msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)```"

msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags for the part of the expression:"
msgstr ""
"(Noll eller flera bokstäver från uppsättningen ``'a'``, ``'i'``, ``'L'``, "
"``'m'``, ``'s'``, ``'u'``, ``'x'``, eventuellt följt av ``'-'`` följt av en "
"eller flera bokstäver från ``'i'``, ``'m'``, ``'s'``, ``'x'``.) Bokstäverna "
"sätter eller tar bort motsvarande flaggor för den del av uttrycket:"

msgid "(The flags are described in :ref:`contents-of-module-re`.)"
msgstr "(Flaggorna beskrivs i :ref:`contents-of-module-re`.)"

msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"bytes patterns ``(?L:...)`` switches to locale dependent matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"Bokstäverna ``'a'``, ``'L'`` och ``'u'`` är ömsesidigt uteslutande när de "
"används som inline-flaggor, så de kan inte kombineras eller följa ``'-'``.  "
"Istället, när en av dem visas i en inline-grupp, åsidosätter den "
"matchningsläget i den omslutande gruppen.  I Unicode-mönster växlar ``(?"
"a:...)`` till enbart ASCII-matchning och ``(?u:...)`` växlar till Unicode-"
"matchning (standard).  I bytesmönster växlar ``(?L:...)`` till lokalberoende "
"matchning och ``(?a:...)`` växlar till enbart ASCII-matchning (standard). "
"Detta åsidosättande gäller endast för gruppen narrow inline, och det "
"ursprungliga matchningsläget återställs utanför gruppen."

msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr ""
"Bokstäverna ``'a'``, ``'L'`` och ``'u'`` kan också användas i en grupp."

msgid "``(?>...)``"
msgstr "``(?>...)``"

msgid ""
"Attempts to match ``...`` as if it was a separate regular expression, and if "
"successful, continues to match the rest of the pattern following it. If the "
"subsequent pattern fails to match, the stack can only be unwound to a point "
"*before* the ``(?>...)`` because once exited, the expression, known as an :"
"dfn:`atomic group`, has thrown away all stack points within itself. Thus, "
"``(?>.*).`` would never match anything because first the ``.*`` would match "
"all characters possible, then, having nothing left to match, the final ``.`` "
"would fail to match. Since there are no stack points saved in the Atomic "
"Group, and there is no stack point before it, the entire expression would "
"thus fail to match."
msgstr ""
"Försöker matcha ``...`` som om det vore ett separat reguljärt uttryck, och "
"om det lyckas fortsätter det att matcha resten av det efterföljande "
"mönstret. Om det efterföljande mönstret inte matchar kan stacken bara rullas "
"tillbaka till en punkt *före* ``(?>...)`` eftersom uttrycket, som kallas en :"
"dfn:`atomisk grupp`, har kastat bort alla stackpunkter inom sig när det väl "
"har avslutats. Således skulle ``(?>.*).`` aldrig matcha någonting eftersom "
"först ``.*`` skulle matcha alla möjliga tecken, sedan, när det inte fanns "
"något kvar att matcha, skulle den sista ``.`` misslyckas med att matcha. "
"Eftersom det inte finns några stackpunkter sparade i Atomic Group, och det "
"inte finns någon stackpunkt före den, skulle hela uttrycket alltså inte "
"matcha."

msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and in :class:`bytes` patterns they can only contain "
"bytes in the ASCII range.  Each group name must be defined only once within "
"a regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Liknar vanliga parenteser, men den delsträng som matchas av gruppen är "
"tillgänglig via det symboliska gruppnamnet *namn*.  Gruppnamn måste vara "
"giltiga Python-identifierare och i :class:`bytes`-mönster kan de endast "
"innehålla byte i ASCII-intervallet.  Varje gruppnamn får bara definieras en "
"gång inom ett reguljärt uttryck.  En symbolisk grupp är också en numrerad "
"grupp, precis som om gruppen inte hade något namn."

msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"Namngivna grupper kan refereras till i tre sammanhang.  Om mönstret är ``(?"
"P<quote>['\"]).*?(?P=quote)`` (d.v.s. matchning av en sträng som citeras med "
"antingen enkla eller dubbla citattecken):"

msgid "Context of reference to group \"quote\""
msgstr "Sammanhang med hänvisning till gruppen \"offert\""

msgid "Ways to reference it"
msgstr "Sätt att hänvisa till den"

msgid "in the same pattern itself"
msgstr "i samma mönster själv"

msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (som visas)"

msgid "``\\1``"
msgstr "``\\1``"

msgid "when processing match object *m*"
msgstr "vid bearbetning av matchningsobjekt *m*"

msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "i en sträng som skickas till *repl*-argumentet i ``re.sub()``"

msgid "``\\g<quote>``"
msgstr "<quote>"

msgid "``\\g<1>``"
msgstr "<1>"

msgid ""
"In :class:`bytes` patterns, group *name* can only contain bytes in the ASCII "
"range (``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"I :class:`bytes`-mönster kan gruppen *name* bara innehålla byte i ASCII-"
"intervallet (``b'\\x00'``-``b'\\x7f'``)."

msgid "``(?P=name)``"
msgstr "``(?P=namn)``"

msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"En återreferens till en namngiven grupp; den matchar den text som matchades "
"av den tidigare gruppen med namnet *namn*."

msgid "``(?#...)``"
msgstr "``(?#...)``"

msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "En kommentar; innehållet i parentesen ignoreras helt enkelt."

msgid "``(?=...)``"
msgstr "``(?=...)``"

msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Matchar om ``...`` matchar nästa, men inte förbrukar någon del av strängen.  "
"Detta kallas för ett :dfn:`lookahead-assertion`.  Till exempel kommer "
"``Isaac (?=Asimov)`` att matcha ``'Isaac'`` endast om det följs av "
"``'Asimov'``."

msgid "``(?!...)``"
msgstr "``(?!...)``"

msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Matchar om ``...`` inte matchar nästa.  Detta är ett :dfn:`negativt "
"lookahead-antagande`. Till exempel kommer ``Isaac (?!Asimov)`` att matcha "
"``'Isaac'`` endast om det *inte* följs av ``'Asimov'``."

msgid "``(?<=...)``"
msgstr "``(?<=...)``"

msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Matchar om den aktuella positionen i strängen föregås av en matchning för "
"``...`` som slutar vid den aktuella positionen.  Detta kallas ett :dfn:"
"`positivt lookbehind-antagande`. ``(?<=abc)def`` kommer att hitta en "
"matchning i ``'abcdef'``, eftersom lookbehind kommer att backa 3 tecken och "
"kontrollera om det ingående mönstret matchar. Det ingående mönstret får bara "
"matcha strängar av en viss bestämd längd, vilket innebär att ``abc`` eller "
"``a|b`` är tillåtna, men inte ``a*`` och ``a{3,4}``.  Observera att mönster "
"som börjar med positiva lookbehind-assertions inte kommer att matcha i "
"början av den sträng som söks; du kommer troligen att vilja använda "
"funktionen :func:`search` snarare än funktionen :func:`match`:"

msgid "This example looks for a word following a hyphen:"
msgstr "I det här exemplet söker du efter ett ord efter ett bindestreck:"

msgid "Added support for group references of fixed length."
msgstr "Stöd för gruppreferenser med fast längd har lagts till."

msgid "``(?<!...)``"
msgstr "``(?<!...)``"

msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Träffar om den aktuella positionen i strängen inte föregås av en träff för "
"``...``.  Detta kallas ett :dfn:`negativt lookbehind-antagande`.  I likhet "
"med positiva lookbehind-assertions måste det ingående mönstret endast matcha "
"strängar av en viss bestämd längd.  Mönster som börjar med negativa "
"lookbehind-assertions kan matcha i början av den sträng som söks."

msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/namn)ja-mönster|nej-mönster)```"

msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Försöker matcha med ``yes-pattern`` om gruppen med angivet *id* eller *namn* "
"finns, och med ``no-pattern`` om den inte gör det. ``no-pattern`` är "
"valfritt och kan utelämnas. Till exempel är ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` ett dåligt mönster för e-postmatchning, som kommer att matcha med "
"``'<user@host.com>'`` såväl som ``'user@host.com'``, men inte med "
"``'<user@host.com'`` eller ``'user@host.com>'``."

msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` patterns, group "
"*name* can only contain bytes in the ASCII range (``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"Grupp *id* kan endast innehålla ASCII-siffror. I :class:`bytes`-mönster kan "
"grupp *name* endast innehålla bytes i ASCII-intervallet (``b'\\x00'``-"
"``b'\\x7f'``)."

msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"De speciella sekvenserna består av ``'\\'`` och ett tecken från listan "
"nedan. Om det vanliga tecknet inte är en ASCII-siffra eller en ASCII-"
"bokstav, kommer den resulterande RE att matcha det andra tecknet.  Till "
"exempel matchar ``\\$`` tecknet ``'$'``."

msgid "``\\number``"
msgstr "\"Nummer"

msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Matchar innehållet i gruppen med samma nummer.  Grupperna är numrerade från "
"1. Till exempel matchar ``(.+) \\1`` ``'the the'`` eller ``'55 55'``, men "
"inte ``'thethe'`` (notera mellanslaget efter gruppen).  Denna speciella "
"sekvens kan endast användas för att matcha en av de första 99 grupperna.  Om "
"den första siffran i *number* är 0, eller *number* är 3 oktalsiffror långt, "
"tolkas det inte som en gruppmatchning, utan som tecknet med oktalvärdet "
"*number*. Inom ``'['`` och ``']'`` i en teckenklass behandlas alla numeriska "
"eskapader som tecken."

msgid "``\\A``"
msgstr "``\\A``"

msgid "Matches only at the start of the string."
msgstr "Matchar endast i början av strängen."

msgid "``\\b``"
msgstr "``\\b``"

msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters. Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning or end of the string. This "
"means that ``r'\\bat\\b'`` matches ``'at'``, ``'at.'``, ``'(at)'``, and "
"``'as at ay'`` but not ``'attempt'`` or ``'atlas'``."
msgstr ""
"Matchar den tomma strängen, men bara i början eller slutet av ett ord. Ett "
"ord definieras som en sekvens av ordtecken. Observera att \"b\" formellt "
"definieras som gränsen mellan ett \"w\"- och ett \"w\"-tecken (eller vice "
"versa), eller mellan \"w\" och början eller slutet av strängen. Detta "
"innebär att ``r'\\bat\\b'`` matchar ``'at'``, ``'at.'``, ``'(at)'`` och "
"``'as at ay'`` men inte ``'attempt'`` eller ``'atlas'``."

msgid ""
"The default word characters in Unicode (str) patterns are Unicode "
"alphanumerics and the underscore, but this can be changed by using the :py:"
"const:`~re.ASCII` flag. Word boundaries are determined by the current locale "
"if the :py:const:`~re.LOCALE` flag is used."
msgstr ""
"Standardordtecknen i Unicode (str)-mönster är Unicode-alfanumeriska tecken "
"och understreck, men detta kan ändras med hjälp av flaggan :py:const:`~re."
"ASCII`. Ordgränser bestäms av den aktuella språkdräkten om flaggan :py:const:"
"`~re.LOCALE` används."

msgid ""
"Inside a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"Inom ett teckenintervall representerar ``b`` backspace-tecknet, för "
"kompatibilitet med Pythons stränglitteraler."

msgid "``\\B``"
msgstr "``\\B``"

msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word. This means that ``r'at\\B'`` matches ``'athens'``, ``'atom'``, "
"``'attorney'``, but not ``'at'``, ``'at.'``, or ``'at!'``. ``\\B`` is the "
"opposite of ``\\b``, so word characters in Unicode (str) patterns are "
"Unicode alphanumerics or the underscore, although this can be changed by "
"using the :py:const:`~re.ASCII` flag. Word boundaries are determined by the "
"current locale if the :py:const:`~re.LOCALE` flag is used."
msgstr ""
"Matchar den tomma strängen, men bara när den *inte* står i början eller "
"slutet av ett ord. Detta innebär att ``r'at\\B'`` matchar ``'athens'``, "
"``'atom'``, ``'attorney'``, men inte ``'at'``, ``'at.'``, eller ``'at!'``. "
"``B`` är motsatsen till ``b``, så ordtecken i Unicode (str)-mönster är "
"Unicodes alfanumeriska tecken eller understreck, även om detta kan ändras "
"med hjälp av :py:const:`~re.ASCII`-flaggan. Ordgränser bestäms av den "
"aktuella språkdräkten om flaggan :py:const:`~re.LOCALE` används."

msgid "``\\B`` now matches empty input string."
msgstr "``B`` matchar nu tom indatasträng."

msgid "``\\d``"
msgstr "``\\d``"

msgid "For Unicode (str) patterns:"
msgstr "För Unicode (str)-mönster:"

msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category `[Nd]`__). This includes ``[0-9]``, and also many other "
"digit characters."
msgstr ""
"Matchar alla Unicodes decimalsiffror (dvs. alla tecken i Unicodes "
"teckenkategori `[Nd]`__). Detta inkluderar ``[0-9]`` och även många andra "
"siffertecken."

msgid "Matches ``[0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr "Matchar ``[0-9]`` om flaggan :py:const:`~re.ASCII` används."

msgid "For 8-bit (bytes) patterns:"
msgstr "För 8-bitars (bytes) mönster:"

msgid ""
"Matches any decimal digit in the ASCII character set; this is equivalent to "
"``[0-9]``."
msgstr ""
"Matchar alla decimala siffror i ASCII-teckenuppsättningen; detta motsvarar "
"``[0-9]``."

msgid "``\\D``"
msgstr "``\\D``"

msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``."
msgstr ""
"Matchar alla tecken som inte är en decimalsiffra. Detta är motsatsen till "
"``d``."

msgid "Matches ``[^0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr "Matchar ``[^0-9]`` om flaggan :py:const:`~re.ASCII` används."

msgid "``\\s``"
msgstr "``\\s``"

msgid ""
"Matches Unicode whitespace characters (as defined by :py:meth:`str."
"isspace`). This includes ``[ \\t\\n\\r\\f\\v]``, and also many other "
"characters, for example the non-breaking spaces mandated by typography rules "
"in many languages."
msgstr ""
"Matchar Unicode-tecken för blanksteg (enligt definitionen i :py:meth:`str."
"isspace`). Detta inkluderar ``[ \\t\\n\\r\\f\\v]``, och även många andra "
"tecken, till exempel de icke-brytande mellanslag som krävs enligt "
"typografiska regler i många språk."

msgid ""
"Matches ``[ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Matchar ``[ \\t\\n\\r\\f\\v]`` om flaggan :py:const:`~re.ASCII` används."

msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Matchar tecken som betraktas som blanksteg i ASCII-teckensatsen; detta "
"motsvarar ``[ \\t\\n\\r\\f\\v]``."

msgid "``\\S``"
msgstr "``\\S``"

msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``."
msgstr ""
"Matchar alla tecken som inte är blankstegstecken. Detta är motsatsen till "
"\"s\"."

msgid ""
"Matches ``[^ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Matchar ``[^ \\t\\n\\r\\f\\v]`` om flaggan :py:const:`~re.ASCII` används."

msgid "``\\w``"
msgstr "``\\w``"

msgid ""
"Matches Unicode word characters; this includes all Unicode alphanumeric "
"characters (as defined by :py:meth:`str.isalnum`), as well as the underscore "
"(``_``)."
msgstr ""
"Matchar Unicode-ordtecken; detta inkluderar alla alfanumeriska Unicode-"
"tecken (enligt definitionen i :py:meth:`str.isalnum`), samt understreck "
"(``_``)."

msgid "Matches ``[a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr "Matchar ``[a-zA-Z0-9_]`` om flaggan :py:const:`~re.ASCII` används."

msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``. If the :py:const:`~re.LOCALE` flag is "
"used, matches characters considered alphanumeric in the current locale and "
"the underscore."
msgstr ""
"Matchar tecken som anses vara alfanumeriska i ASCII-teckenuppsättningen; "
"detta motsvarar ``[a-zA-Z0-9_]``. Om flaggan :py:const:`~re.LOCALE` används, "
"matchas tecken som anses vara alfanumeriska i den aktuella språkdräkten och "
"understreck."

msgid "``\\W``"
msgstr "``\\W``"

msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. By default, matches non-underscore (``_``) characters for which :py:"
"meth:`str.isalnum` returns ``False``."
msgstr ""
"Matchar alla tecken som inte är ordtecken. Detta är motsatsen till ``\\w``. "
"Som standard matchas icke-underscore (``_``) tecken för vilka :py:meth:`str."
"isalnum` returnerar ``False``."

msgid "Matches ``[^a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr "Matchar ``[^a-zA-Z0-9_]`` om flaggan :py:const:`~re.ASCII` används."

msgid ""
"If the :py:const:`~re.LOCALE` flag is used, matches characters which are "
"neither alphanumeric in the current locale nor the underscore."
msgstr ""
"Om flaggan :py:const:`~re.LOCALE` används, matchar den tecken som varken är "
"alfanumeriska i den aktuella språkdräkten eller underscore."

msgid "``\\z``"
msgstr "``\\z``"

msgid "Matches only at the end of the string."
msgstr "Matchar endast i slutet av strängen."

msgid "``\\Z``"
msgstr "``\\Z``"

msgid "The same as ``\\z``.  For compatibility with old Python versions."
msgstr "Samma som ``z``.  För kompatibilitet med gamla Python-versioner."

msgid ""
"Most of the :ref:`escape sequences <escape-sequences>` supported by Python "
"string literals are also accepted by the regular expression parser::"
msgstr ""
"De flesta av de :ref:`escape-sekvenser <escape-sequences>` som stöds av "
"Pythons stränglitteraler accepteras också av parsern för reguljära uttryck::"

msgid ""
"\\a      \\b      \\f      \\n\n"
"\\N      \\r      \\t      \\u\n"
"\\U      \\v      \\x      \\\\"
msgstr ""
"\\a \\b \\f \\n\n"
"\\N \\r \\t \\u\n"
"\\U \\v \\x \\\\"

msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Observera att ``b`` används för att representera ordgränser och betyder "
"\"backspace\" endast inom teckenklasser)"

msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes "
"of ASCII letters are reserved for future use and treated as errors."
msgstr ""
"escape-sekvenserna ``'\\u'``, ``'\\U'`` och ``'\\N'`` känns bara igen i "
"Unicode-mönster (str). I bytesmönster är de fel. Okända escapes av ASCII-"
"bokstäver reserveras för framtida användning och behandlas som fel."

msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Oktala escapes ingår i en begränsad form.  Om den första siffran är en 0, "
"eller om det finns tre oktalsiffror, betraktas det som en oktal escape. "
"Annars är det en gruppreferens.  När det gäller stränglitteraler är oktala "
"escapes alltid högst tre siffror långa."

msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "Escape-sekvenserna ``'\\u'`` och ``'\\U'`` har lagts till."

msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr "Okända escapes som består av ``'\\'`` och en ASCII-bokstav är nu fel."

msgid ""
"The :samp:`'\\\\N\\\\{{name}\\\\}'` escape sequence has been added. As in "
"string literals, it expands to the named Unicode character (e.g. ``'\\N{EM "
"DASH}'``)."
msgstr ""
"Escape-sekvensen :samp:`'\\\\N\\\\{{name}\\\\}'` har lagts till. Precis som "
"i stränglitteraler expanderar den till det namngivna Unicode-tecknet (t.ex. "
"``'\\N{EM DASH}'``)."

msgid "Module Contents"
msgstr "Modulens innehåll"

msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"Modulen definierar flera funktioner, konstanter och ett undantag. Vissa av "
"funktionerna är förenklade versioner av de fullständiga metoderna för "
"kompilerade reguljära uttryck.  De flesta icke-triviala applikationer "
"använder alltid den kompilerade formen."

msgid "Flags"
msgstr "Flaggor"

msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Flaggkonstanter är nu instanser av :class:`RegexFlag`, som är en underklass "
"av :class:`enum.IntFlag`."

msgid ""
"An :class:`enum.IntFlag` class containing the regex options listed below."
msgstr ""
"En :class:`enum.IntFlag`-klass som innehåller de regex-alternativ som anges "
"nedan."

msgid "- added to ``__all__``"
msgstr "- tillagd till ``__all__``"

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode (str) patterns, and is ignored for bytes "
"patterns."
msgstr ""
"Gör så att ``w``, ``W``, ``b``, ``B``, ``d``, ``D``, ``s`` och ``S`` endast "
"utför ASCII-matchning istället för fullständig Unicode-matchning.  Detta är "
"endast meningsfullt för Unicode-mönster (str) och ignoreras för bytes-"
"mönster."

msgid "Corresponds to the inline flag ``(?a)``."
msgstr "Motsvarar inline-flaggan ``(?a)``."

msgid ""
"The :py:const:`~re.U` flag still exists for backward compatibility, but is "
"redundant in Python 3 since matches are Unicode by default for ``str`` "
"patterns, and Unicode matching isn't allowed for bytes patterns. :py:const:"
"`~re.UNICODE` and the inline flag ``(?u)`` are similarly redundant."
msgstr ""
"Flaggan :py:const:`~re.U` finns fortfarande kvar för bakåtkompatibilitet, "
"men är överflödig i Python 3 eftersom matchningar är Unicode som standard "
"för ``str``-mönster och Unicode-matchning inte är tillåten för bytesmönster. "
"Flaggan :py:const:`~re.UNICODE` och inline-flaggan ``(?u)`` är på samma sätt "
"överflödiga."

msgid "Display debug information about compiled expression."
msgstr "Visa felsökningsinformation om kompilerade uttryck."

msgid "No corresponding inline flag."
msgstr "Ingen motsvarande inline-flagga."

msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also  "
"match lowercase letters. Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :py:const:`~re.ASCII` flag is used to disable "
"non-ASCII matches. The current locale does not change the effect of this "
"flag unless the :py:const:`~re.LOCALE` flag is also used."
msgstr ""
"Utför matchning utan hänsyn till skiftlägesskillnader; uttryck som ``[A-Z]`` "
"matchar även små bokstäver. Fullständig Unicode-matchning (t.ex. ``Ü`` som "
"matchar ``ü``) fungerar också om inte flaggan :py:const:`~re.ASCII` används "
"för att inaktivera icke-ASCII-matchningar. Den aktuella språkdräkten ändrar "
"inte effekten av denna flagga om inte flaggan :py:const:`~re.LOCALE` också "
"används."

msgid "Corresponds to the inline flag ``(?i)``."
msgstr "Motsvarar inline-flaggan ``(?i)``."

msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), "
"'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :py:const:`~re.ASCII` flag is used, only letters 'a' to 'z' and 'A' to "
"'Z' are matched."
msgstr ""
"Observera att när Unicode-mönstren ``[a-z]`` eller ``[A-Z]`` används i "
"kombination med flaggan :const:`IGNORECASE`, matchar de de 52 ASCII-"
"bokstäverna och 4 ytterligare icke-ASCII-bokstäver: 'İ' (U+0130, latinsk "
"versal I med punkt ovanför), ’ı’ (U+0131, latinsk gemen i utan punkt), "
"’ſ’ (U+017F, latinsk gemen lång s) och ’K’ (U+212A, Kelvin-tecken). Om "
"flaggan :const:`~re.ASCII` används matchas endast bokstäverna ’a’ till ’z’ "
"och ’A’ till ’Z’."

msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale. This flag can be used only with bytes "
"patterns."
msgstr ""
"Gör ``w``, ``W``, ``b``, ``B`` och skiftlägesokänslig matchning beroende av "
"aktuell lokal. Denna flagga kan endast användas med bytesmönster."

msgid "Corresponds to the inline flag ``(?L)``."
msgstr "Motsvarar inline-flaggan ``(?L)``."

msgid ""
"This flag is discouraged; consider Unicode matching instead. The locale "
"mechanism is very unreliable as it only handles one \"culture\" at a time "
"and only works with 8-bit locales. Unicode matching is enabled by default "
"for Unicode (str) patterns and it is able to handle different locales and "
"languages."
msgstr ""
"Denna flagga avrådes; överväg Unicode-matchning istället. Lokalmekanismen är "
"mycket opålitlig eftersom den bara hanterar en \"kultur\" åt gången och bara "
"fungerar med 8-bitars lokalspråk. Unicode-matchning är aktiverad som "
"standard för Unicode (str)-mönster och kan hantera olika lokala språk och "
"språk."

msgid ""
":py:const:`~re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :py:const:`~re.ASCII`."
msgstr ""
":py:const:`~re.LOCALE` kan endast användas med bytesmönster och är inte "
"kompatibel med :py:const:`~re.ASCII`."

msgid ""
"Compiled regular expression objects with the :py:const:`~re.LOCALE` flag no "
"longer depend on the locale at compile time. Only the locale at matching "
"time affects the result of matching."
msgstr ""
"Kompilerade objekt för reguljära uttryck med :py:const:`~re.LOCALE`-flaggan "
"är inte längre beroende av locale vid kompileringstillfället. Endast locale "
"vid matchningstillfället påverkar resultatet av matchningen."

msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string."
msgstr ""
"När det anges matchar mönsterstecknet ``'^'`` i början av strängen och i "
"början av varje rad (omedelbart efter varje ny rad); och mönsterstecknet "
"``'$'`` matchar i slutet av strängen och i slutet av varje rad (omedelbart "
"före varje ny rad).  Som standard matchar ``'^'`` endast i början av "
"strängen och ``'$'`` endast i slutet av strängen och omedelbart före den nya "
"raden (om någon) i slutet av strängen."

msgid "Corresponds to the inline flag ``(?m)``."
msgstr "Motsvarar inline-flaggan ``(?m)``."

msgid ""
"Indicates no flag being applied, the value is ``0``.  This flag may be used "
"as a default value for a function keyword argument or as a base value that "
"will be conditionally ORed with other flags.  Example of use as a default "
"value::"
msgstr ""
"Indikerar att ingen flagga tillämpas, värdet är ``0``.  Denna flagga kan "
"användas som ett standardvärde för ett funktionsnyckelordsargument eller som "
"ett basvärde som villkorligt OR:as med andra flaggor.  Exempel på användning "
"som standardvärde::"

msgid ""
"def myfunc(text, flag=re.NOFLAG):\n"
"    return re.match(text, flag)"
msgstr ""
"def myfunc(text, flag=re.NOFLAG):\n"
"    return re.match(text, flag)"

msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Låt specialtecknet ``'.'`` matcha vilket tecken som helst, inklusive en ny "
"rad; utan denna flagga kommer ``'.'`` att matcha allt *utom* en ny rad."

msgid "Corresponds to the inline flag ``(?s)``."
msgstr "Motsvarar den inline-flaggan ``(?s)``."

msgid ""
"In Python 3, Unicode characters are matched by default for ``str`` patterns. "
"This flag is therefore redundant with **no effect** and is only kept for "
"backward compatibility."
msgstr ""
"I Python 3 matchas Unicode-tecken som standard för ``str``-mönster. Denna "
"flagga är därför överflödig med **ingen effekt** och behålls endast för "
"bakåtkompatibilitet."

msgid ""
"See :py:const:`~re.ASCII` to restrict matching to ASCII characters instead."
msgstr ""
"Se :py:const:`~re.ASCII` för att begränsa matchningen till ASCII-tecken "
"istället."

msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For example, ``(? :`` "
"and ``* ?`` are not allowed. When a line contains a ``#`` that is not in a "
"character class and is not preceded by an unescaped backslash, all "
"characters from the leftmost such ``#`` through the end of the line are "
"ignored."
msgstr ""
"Med den här flaggan kan du skriva reguljära uttryck som ser snyggare ut och "
"är mer läsbara genom att du visuellt kan separera logiska delar av mönstret "
"och lägga till kommentarer. Whitespace inom mönstret ignoreras, utom när det "
"är i en teckenklass, eller när det föregås av ett oavkortat backslash, eller "
"inom tokens som ``*?``, ``(?:`` eller ``(?P<...>``. Till exempel är ``(? :`` "
"och ``* ?`` inte tillåtna. När en rad innehåller en ``#`` som inte ingår i "
"en teckenklass och som inte föregås av en obegränsad backslash, ignoreras "
"alla tecken från den längst till vänster liggande sådana ``#`` till slutet "
"av raden."

msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Detta innebär att de två följande objekten för reguljära uttryck som matchar "
"ett decimaltal är funktionellt lika::"

msgid ""
"a = re.compile(r\"\"\"\\d +  # the integral part\n"
"                   \\.    # the decimal point\n"
"                   \\d *  # some fractional digits\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"
msgstr ""
"a = re.compile(r\"\"\"\\d + # den integrerade delen\n"
"                   \\.    # decimalpunkten\n"
"                   \\d * # några fraktionssiffror\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"

msgid "Corresponds to the inline flag ``(?x)``."
msgstr "Motsvarar inline-flaggan ``(?x)``."

msgid "Functions"
msgstr "Funktioner"

msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"Kompilera ett mönster för reguljära uttryck till ett :ref:``regular "
"expression object <re-objects>``, som kan användas för matchning med hjälp "
"av dess :func:`~Pattern.match`, :func:`~Pattern.search` och andra metoder, "
"som beskrivs nedan."

msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the `flags`_ variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"Uttryckets beteende kan ändras genom att ange ett *flags*-värde. Värdena kan "
"vara vilken som helst av variablerna `flags`_, kombinerade med bitvis OR "
"(operatorn ``|``)."

msgid "The sequence ::"
msgstr "Sekvensen ::"

msgid ""
"prog = re.compile(pattern)\n"
"result = prog.match(string)"
msgstr ""
"prog = re.compile(mönster)\n"
"resultat = prog.match(sträng)"

msgid "is equivalent to ::"
msgstr "är likvärdig med ::"

msgid "result = re.match(pattern, string)"
msgstr "resultat = re.match(mönster, sträng)"

msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"men att använda :func:`re.compile` och spara det resulterande objektet för "
"reguljära uttryck för återanvändning är effektivare när uttrycket kommer att "
"användas flera gånger i ett och samma program."

msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"De kompilerade versionerna av de senaste mönstren som skickas till :func:`re."
"compile` och matchningsfunktionerna på modulnivå cachas, så program som bara "
"använder ett fåtal reguljära uttryck åt gången behöver inte oroa sig för att "
"kompilera reguljära uttryck."

msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :class:"
"`~re.Match`. Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"Skanna igenom *sträng* och leta efter den första platsen där det reguljära "
"uttrycket *mönster* ger en träff, och returnera en motsvarande :class:`~re."
"Match`. Returnerar ``None`` om ingen position i strängen matchar mönstret; "
"observera att detta skiljer sig från att hitta en noll-längdsmatchning "
"någonstans i strängen."

msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :class:`~re.Match`.  Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"Om noll eller fler tecken i början av *sträng* matchar det reguljära "
"uttrycket *mönster*, returneras en motsvarande :class:`~re.Match`.  "
"Returnerar ``None`` om strängen inte matchar mönstret; notera att detta "
"skiljer sig från en noll-längds matchning."

msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Observera att även i :const:`MULTILINE`-läget kommer :func:`re.match` bara "
"att matcha i början av strängen och inte i början av varje rad."

msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Om du vill hitta en träff var som helst i *sträng*, använd :func:`search` "
"istället (se även :ref:`search-vs-match`)."

msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""
"Om hela *strängen* matchar det reguljära uttrycket *mönstret*, returneras en "
"motsvarande :class:`~re.Match`.  Returnerar ``None`` om strängen inte "
"matchar mönstret; notera att detta skiljer sig från en matchning med noll "
"längd."

msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Dela upp *sträng* efter förekomsterna av *mönster*.  Om fångande parenteser "
"används i *mönster* returneras även texten för alla grupper i mönstret som "
"en del av den resulterande listan. Om *maxsplit* inte är noll, sker högst "
"*maxsplit* uppdelningar och resten av strängen returneras som det sista "
"elementet i listan. ::"

msgid ""
">>> re.split(r'\\W+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'(\\W+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'\\W+', 'Words, words, words.', maxsplit=1)\n"
"['Words', 'words, words.']\n"
">>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n"
"['0', '3', '9']"
msgstr ""
">>> re.split(r'\\W+', 'Ord, ord, ord, ord.')\n"
"['Ord', 'ord', 'ord', 'ord', '']\n"
">>> re.split(r'(\\W+)', 'Ord, ord, ord.')\n"
"['Ord', ', ', 'ord', ', ', 'ord', '.', '']\n"
">>> re.split(r'\\W+', 'Ord, ord, ord.', maxsplit=1)\n"
"['Ord', 'ord, ord, ord.']\n"
">>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n"
"['0', '3', '9']"

msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"Om det finns fångstgrupper i separatorn och den matchar i början av "
"strängen, kommer resultatet att börja med en tom sträng.  Detsamma gäller "
"för slutet av strängen::"

msgid ""
">>> re.split(r'(\\W+)', '...words, words...')\n"
"['', '...', 'words', ', ', 'words', '...', '']"
msgstr ""
">>> re.split(r'(\\W+)', '...ord, ord...')\n"
"['', '...', 'ord', ', ', 'ord', '...', '']"

msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"På så sätt hittas separatorkomponenterna alltid på samma relativa index i "
"resultatlistan."

msgid ""
"Adjacent empty matches are not possible, but an empty match can occur "
"immediately after a non-empty match."
msgstr ""
"Intilliggande tomma matchningar är inte möjliga, men en tom matchning kan "
"inträffa omedelbart efter en icke-tom matchning."

msgid ""
">>> re.split(r'\\b', 'Words, words, words.')\n"
"['', 'Words', ', ', 'words', ', ', 'words', '.']\n"
">>> re.split(r'\\W*', '...words...')\n"
"['', '', 'w', 'o', 'r', 'd', 's', '', '']\n"
">>> re.split(r'(\\W*)', '...words...')\n"
"['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', "
"'']"
msgstr ""
">>> re.split(r'\\b', 'Ord, ord, ord.')\n"
"['', 'Ord', ', ', 'ord', ', ', 'ord', '.']\n"
">>> re.split(r'\\W*', '...ord...')\n"
"['', '', 'w', 'o', 'r', 'd', 's', '', '']\n"
">>> re.split(r'(\\W*)', '...ord...')\n"
"['', '...', '', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', "
"'', '']"

msgid "Added the optional flags argument."
msgstr "Lagt till det valfria flaggargumentet."

msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""
"Stöd för uppdelning av ett mönster som kan matcha en tom sträng har lagts "
"till."

msgid ""
"Passing *maxsplit* and *flags* as positional arguments is deprecated. In "
"future Python versions they will be :ref:`keyword-only parameters <keyword-"
"only_parameter>`."
msgstr ""
"Att skicka *maxsplit* och *flags* som positionella argument är föråldrat. I "
"framtida Python-versioner kommer de att vara :ref:`keyword-only parameters "
"<keyword-only_parameter>`."

msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"Returnerar alla icke-överlappande matchningar av *mönster* i *sträng*, som "
"en lista med strängar eller tupler.  *sträng* skannas från vänster till "
"höger och matchningarna returneras i den ordning de hittas.  Tomma "
"matchningar inkluderas i resultatet."

msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"Resultatet beror på antalet fångstgrupper i mönstret. Om det inte finns "
"några grupper returneras en lista med strängar som matchar hela mönstret.  "
"Om det finns exakt en grupp returneras en lista med strängar som matchar den "
"gruppen.  Om det finns flera grupper returneras en lista med tupler av "
"strängar som matchar grupperna.  Grupper som inte fångas upp påverkar inte "
"resultatets form."

msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""
"Matcher som inte är tomma kan nu starta precis efter en tidigare tom match."

msgid ""
"Return an :term:`iterator` yielding :class:`~re.Match` objects over all non-"
"overlapping matches for the RE *pattern* in *string*.  The *string* is "
"scanned left-to-right, and matches are returned in the order found.  Empty "
"matches are included in the result."
msgstr ""
"Returnerar en :term:`iterator` som ger :class:`~re.Match`-objekt över alla "
"icke-överlappande matchningar för RE *mönster* i *sträng*.  *strängen* "
"skannas från vänster till höger och matchningarna returneras i den ordning "
"de hittas.  Tomma matchningar inkluderas i resultatet."

msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"Returnerar strängen som erhålls genom att ersätta de längst till vänster "
"liggande icke överlappande förekomsterna av *mönster* i *sträng* med "
"ersättningen *repl*.  Om mönstret inte hittas returneras *sträng* "
"oförändrad.  *repl* kan vara en sträng eller en funktion; om det är en "
"sträng behandlas alla backslash-escapes i den.  Det innebär att ``\\n`` "
"konverteras till ett enda ny rad-tecken, ``r`` konverteras till en "
"vagnsretur och så vidare.  Okända escapes av ASCII-bokstäver reserveras för "
"framtida användning och behandlas som fel.  Andra okända escapetecken som "
"``&`` lämnas därhän. Bakreferenser, t.ex. ``\\6``, ersätts med den delsträng "
"som matchas av grupp 6 i mönstret. Till exempel::"

msgid ""
">>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n"
"...        r'static PyObject*\\npy_\\1(void)\\n{',\n"
"...        'def myfunc():')\n"
"'static PyObject*\\npy_myfunc(void)\\n{'"
msgstr ""
">>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n"
"... r'statiskt PyObject*\\npy_\\1(void)\\n{',\n"
"...        'def myfunc():')\n"
"'statisk PyObject*\\npy_myfunc(void)\\n{'"

msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :class:`~re.Match` argument, and "
"returns the replacement string.  For example::"
msgstr ""
"Om *repl* är en funktion anropas den för varje icke-överlappande förekomst "
"av *pattern*.  Funktionen tar ett enda :class:`~re.Match`-argument och "
"returnerar ersättningssträngen.  Till exempel::"

msgid ""
">>> def dashrepl(matchobj):\n"
"...     if matchobj.group(0) == '-': return ' '\n"
"...     else: return '-'\n"
"...\n"
">>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')\n"
"'pro--gram files'\n"
">>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re."
"IGNORECASE)\n"
"'Baked Beans & Spam'"
msgstr ""
">>> def dashrepl(matchobj):\n"
"... if matchobj.group(0) == '-': return ' '\n"
"... annars: returnera '-'\n"
"...\n"
">>> re.sub('-{1,2}', dashrepl, 'pro----gram-filer')\n"
"'pro--programfiler'\n"
">>> re.sub(r'\\sAND\\s', ' & ', 'Bakade bönor och skräppost', flags=re."
"IGNORECASE)\n"
"'Bakade bönor och skräp'"

msgid "The pattern may be a string or a :class:`~re.Pattern`."
msgstr "Mönstret kan vara en sträng eller en :class:`~re.Pattern`."

msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced."
msgstr ""
"Det valfria argumentet *count* är det maximala antalet mönsterförekomster "
"som ska ersättas; *count* måste vara ett icke-negativt heltal.  Om det "
"utelämnas eller är noll kommer alla förekomster att ersättas."

msgid ""
"Adjacent empty matches are not possible, but an empty match can occur "
"immediately after a non-empty match. As a result, ``sub('x*', '-', 'abxd')`` "
"returns ``'-a-b--d-'`` instead of ``'-a-b-d-'``."
msgstr ""
"Intilliggande tomma matchningar är inte möjliga, men en tom matchning kan "
"inträffa omedelbart efter en icke-tom matchning. Därför returnerar "
"``sub('x*', '-', 'abxd')`` ``'-a-b--d-'`` i stället för ``'-a-b-d-'``."

msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"I *repl*-argument av strängtyp, utöver de teckenundantag och bakåtreferenser "
"som beskrivs ovan, kommer ``g<name>`` att använda den delsträng som matchas "
"av gruppen med namnet ``namn``, enligt definitionen i syntaxen ``(?"
"P<name>...)``. ``\\g<number>`` använder motsvarande gruppnummer; ``g<2>`` är "
"därför likvärdigt med ``2``, men är inte tvetydigt i en ersättning som "
"``g<2>0``.  ``20`` skulle tolkas som en referens till grupp 20, inte en "
"referens till grupp 2 följt av det bokstavliga tecknet ``'0'``.  "
"Bakreferensen ``\\g<0>`` ersätter hela den delsträng som matchas av RE."

msgid "Unmatched groups are replaced with an empty string."
msgstr "Omatchade grupper ersätts med en tom sträng."

msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Okända escapes i *mönster* som består av ``'\\'``` och en ASCII-bokstav är "
"nu fel."

msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors. An empty match can occur immediately after a non-empty match."
msgstr ""
"Okända escapes i *repl* som består av ``'\\'`` och en ASCII-bokstav är nu "
"fel. En tom matchning kan inträffa omedelbart efter en icke-tom matchning."

msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` replacement "
"strings, group *name* can only contain bytes in the ASCII range "
"(``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"Grupp *id* kan bara innehålla ASCII-siffror. I :class:`bytes` "
"ersättningssträngar kan grupp *name* endast innehålla bytes i ASCII-"
"intervallet (``b'\\x00'``-``b'\\x7f'``)."

msgid ""
"Passing *count* and *flags* as positional arguments is deprecated. In future "
"Python versions they will be :ref:`keyword-only parameters <keyword-"
"only_parameter>`."
msgstr ""
"Att skicka *count* och *flags* som positionella argument är föråldrat. I "
"framtida Python-versioner kommer de att vara :ref:`keyword-only parameters "
"<keyword-only_parameter>`."

msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
"Utför samma operation som :func:`sub`, men returnerar en tupel "
"``(new_string, number_of_subs_made)``."

msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""
"Undvik specialtecken i *mönster*. Detta är användbart om du vill matcha en "
"godtycklig bokstavlig sträng som kan innehålla metatecken för reguljära "
"uttryck.  Till exempel::"

msgid ""
">>> print(re.escape('https://www.python.org'))\n"
"https://www\\.python\\.org\n"
"\n"
">>> legal_chars = string.ascii_lowercase + string.digits + \"!#$%&'*+-.^_`|~:"
"\"\n"
">>> print('[%s]+' % re.escape(legal_chars))\n"
"[abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+\n"
"\n"
">>> operators = ['+', '-', '*', '/', '**']\n"
">>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))\n"
"/|\\-|\\+|\\*\\*|\\*"
msgstr ""
">>> print(re.escape('https://www.python.org'))\n"
"https://www\\.python\\.org\n"
"\n"
">>> legal_chars = sträng.ascii_lågbokstav + sträng.siffror + \"!#$%&'*+-.^_`|"
"~:\"\n"
">>> print('[%s]+' % re.escape(legal_chars))\n"
"[abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+\n"
"\n"
">>> operatorer = ['+', '-', '*', '/', '**']\n"
">>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))\n"
"/|\\-|\\+|\\*\\*|\\*"

msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"Denna funktion får inte användas för ersättningssträngen i :func:`sub` och :"
"func:`subn`, endast backslashes ska escapas.  Till exempel::"

msgid ""
">>> digits_re = r'\\d+'\n"
">>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings'\n"
">>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample))\n"
"/usr/sbin/sendmail - \\d+ errors, \\d+ warnings"
msgstr ""
">>> siffror_re = r'\\d+'\n"
">>> exempel = '/usr/sbin/sendmail - 0 fel, 12 varningar'\n"
">>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample))\n"
"/usr/sbin/sendmail - \\d+ fel, \\d+ varningar"

msgid "The ``'_'`` character is no longer escaped."
msgstr "Tecknet ``'_'`` är inte längre escapat."

msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"Endast tecken som kan ha en speciell betydelse i ett reguljärt uttryck "
"escapas. Därför undviks inte längre ``'!'``, ``'\"'``, ``'%'``, ``\"''``, "
"``','``, ``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'`` och "
"``\"`\"``."

msgid "Clear the regular expression cache."
msgstr "Rensa cacheminnet för reguljära uttryck."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The ``PatternError`` instance has the following additional "
"attributes:"
msgstr ""
"Undantag som uppstår när en sträng som skickas till en av funktionerna här "
"inte är ett giltigt reguljärt uttryck (det kan t.ex. innehålla parenteser "
"som inte matchar) eller när något annat fel uppstår under kompilering eller "
"matchning.  Det är aldrig ett fel om en sträng inte innehåller någon "
"matchning för ett mönster.  Instansen ``PatternError`` har följande "
"ytterligare attribut:"

msgid "The unformatted error message."
msgstr "Det oformaterade felmeddelandet."

msgid "The regular expression pattern."
msgstr "Det reguljära uttrycksmönstret."

msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""
"Indexet i *mönster* där kompileringen misslyckades (kan vara ``None``)."

msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "Den rad som motsvarar *pos* (kan vara ``None``)."

msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "Den kolumn som motsvarar *pos* (kan vara ``None``)."

msgid "Added additional attributes."
msgstr "Lagt till ytterligare attribut."

msgid ""
"``PatternError`` was originally named ``error``; the latter is kept as an "
"alias for backward compatibility."
msgstr ""
"``PatternError`` hette ursprungligen ``error``; det senare behålls som ett "
"alias för bakåtkompatibilitet."

msgid "Regular Expression Objects"
msgstr "Objekt för reguljära uttryck"

msgid "Compiled regular expression object returned by :func:`re.compile`."
msgstr ""
"Kompilerat objekt för reguljära uttryck som returneras av :func:`re.compile`."

msgid ""
":py:class:`re.Pattern` supports ``[]`` to indicate a Unicode (str) or bytes "
"pattern. See :ref:`types-genericalias`."
msgstr ""
":py:class:`re.Pattern` stöder ``[]`` för att ange ett Unicode- (str) eller "
"bytesmönster. Se :ref:`types-genericalias`."

msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :class:`~re.Match`. "
"Return ``None`` if no position in the string matches the pattern; note that "
"this is different from finding a zero-length match at some point in the "
"string."
msgstr ""
"Skanna igenom *sträng* och leta efter den första platsen där detta reguljära "
"uttryck ger en träff, och returnera en motsvarande :class:`~re.Match`. "
"Returnerar ``None`` om ingen position i strängen matchar mönstret; observera "
"att detta skiljer sig från att hitta en noll-längdsmatchning någonstans i "
"strängen."

msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"Den valfria andra parametern *pos* anger ett index i strängen där sökningen "
"ska börja; standardvärdet är ``0``.  Detta är inte helt likvärdigt med att "
"skära upp strängen; mönsterstecknet ``'^'`` matchar i strängens verkliga "
"början och vid positioner strax efter en ny rad, men inte nödvändigtvis vid "
"det index där sökningen ska börja."

msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"Den valfria parametern *endpos* begränsar hur långt strängen kommer att "
"sökas; det kommer att vara som om strängen är *endpos* tecken lång, så "
"endast tecknen från *pos* till ``endpos - 1`` kommer att sökas efter en "
"matchning.  Om *endpos* är mindre än *pos* kommer ingen matchning att "
"hittas; annars, om *rx* är ett kompilerat objekt för reguljära uttryck, är "
"``rx.search(string, 0, 50)`` likvärdigt med ``rx.search(string[:50], 0)``. ::"

msgid ""
">>> pattern = re.compile(\"d\")\n"
">>> pattern.search(\"dog\")     # Match at index 0\n"
"<re.Match object; span=(0, 1), match='d'>\n"
">>> pattern.search(\"dog\", 1)  # No match; search doesn't include the \"d\""
msgstr ""
">>> mönster = re.compile(\"d\")\n"
">>> pattern.search(\"hund\") # Matchning vid index 0\n"
"<re.Match-objekt; span=(0, 1), match='d'>\n"
">>> pattern.search(\"dog\", 1) # Ingen matchning; sökningen inkluderar inte "
"\"d\""

msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :class:`~re.Match`. Return ``None`` if "
"the string does not match the pattern; note that this is different from a "
"zero-length match."
msgstr ""
"Om noll eller fler tecken i *början* av *sträng* matchar detta reguljära "
"uttryck, returneras en motsvarande :class:`~re.Match`. Returnerar ``None`` "
"om strängen inte matchar mönstret; observera att detta skiljer sig från en "
"noll-längdsmatchning."

msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr ""
"De valfria parametrarna *pos* och *endpos* har samma betydelse som för "
"metoden :meth:`~Pattern.search`. ::"

msgid ""
">>> pattern = re.compile(\"o\")\n"
">>> pattern.match(\"dog\")      # No match as \"o\" is not at the start of "
"\"dog\".\n"
">>> pattern.match(\"dog\", 1)   # Match as \"o\" is the 2nd character of "
"\"dog\".\n"
"<re.Match object; span=(1, 2), match='o'>"
msgstr ""
">>> mönster = re.compile(\"o\")\n"
">>> pattern.match(\"dog\") # Ingen matchning eftersom \"o\" inte är i början "
"av \"dog\".\n"
">>> pattern.match(\"dog\", 1) # Matchning eftersom \"o\" är det 2:a tecknet "
"i \"dog\".\n"
"<re.Match-objekt; span=(1, 2), match='o'>"

msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"Om du vill hitta en matchning var som helst i *sträng*, använd :meth:"
"`~Pattern.search` istället (se även :ref:`search-vs-match`)."

msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""
"Om hela *strängen* matchar detta reguljära uttryck, returneras en "
"motsvarande :class:`~re.Match`.  Returnerar ``None`` om strängen inte "
"matchar mönstret; notera att detta skiljer sig från en noll-längdsmatchning."

msgid ""
">>> pattern = re.compile(\"o[gh]\")\n"
">>> pattern.fullmatch(\"dog\")      # No match as \"o\" is not at the start "
"of \"dog\".\n"
">>> pattern.fullmatch(\"ogre\")     # No match as not the full string "
"matches.\n"
">>> pattern.fullmatch(\"doggie\", 1, 3)   # Matches within given limits.\n"
"<re.Match object; span=(1, 3), match='og'>"
msgstr ""
">>> mönster = re.compile(\"o[gh]\")\n"
">>> pattern.fullmatch(\"dog\") # Ingen matchning eftersom \"o\" inte är i "
"början av \"dog\".\n"
">>> pattern.fullmatch(\"ogre\") # Ingen matchning eftersom inte hela "
"strängen matchar.\n"
">>> pattern.fullmatch(\"doggie\", 1, 3) # Träffar inom givna gränser.\n"
"<re.Match-objekt; span=(1, 3), match='og'>"

msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""
"Identisk med funktionen :func:`split`, men med det kompilerade mönstret."

msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Liknar funktionen :func:`findall`, använder det kompilerade mönstret, men "
"accepterar också valfria parametrar *pos* och *endpos* som begränsar "
"sökregionen som för :meth:`search`."

msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Liknar funktionen :func:`finditer`, använder det kompilerade mönstret, men "
"accepterar också valfria parametrar *pos* och *endpos* som begränsar "
"sökregionen som för :meth:`search`."

msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ""
"Identisk med funktionen :func:`sub`, men använder det kompilerade mönstret."

msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ""
"Identisk med funktionen :func:`subn`, men med det kompilerade mönstret."

msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :py:const:`~re.UNICODE` if the pattern is a Unicode string."
msgstr ""
"Flaggorna för regex-matchning.  Detta är en kombination av de flaggor som "
"ges till :func:`.compile`, eventuella ``(?...)`` inline-flaggor i mönstret "
"och implicita flaggor som :py:const:`~re.UNICODE` om mönstret är en Unicode-"
"sträng."

msgid "The number of capturing groups in the pattern."
msgstr "Antalet fångstgrupper i mönstret."

msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"En ordbok som mappar alla symboliska gruppnamn som definieras av ``(?"
"P<id>)`` till gruppnummer.  Ordlistan är tom om inga symboliska grupper har "
"använts i mönstret."

msgid "The pattern string from which the pattern object was compiled."
msgstr "Den mönstersträng från vilken mönsterobjektet sammanställdes."

msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
"Lagt till stöd för :func:`copy.copy` och :func:`copy.deepcopy`.  Kompilerade "
"objekt för reguljära uttryck betraktas som atomära."

msgid "Match Objects"
msgstr "Matchningsobjekt"

msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"Match-objekt har alltid det booleska värdet ``True``. Eftersom :meth:"
"`~Pattern.match` och :meth:`~Pattern.search` returnerar ``None`` när det "
"inte finns någon matchning, kan du testa om det fanns en matchning med en "
"enkel ``if``-sats::"

msgid ""
"match = re.search(pattern, string)\n"
"if match:\n"
"    process(match)"
msgstr ""
"match = re.search(mönster, sträng)\n"
"om match:\n"
"    process(match)"

msgid "Match object returned by successful ``match``\\ es and ``search``\\ es."
msgstr ""
"Matchningsobjekt som returneras av framgångsrika \"matchningar\" och "
"\"sökningar\"."

msgid ""
":py:class:`re.Match` supports ``[]`` to indicate a Unicode (str) or bytes "
"match. See :ref:`types-genericalias`."
msgstr ""
":py:class:`re.Match` stöder ``[]`` för att ange en matchning med Unicode "
"(str) eller bytes. Se :ref:`types-genericalias`."

msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group. The "
"backreference ``\\g<0>`` will be replaced by the entire match."
msgstr ""
"Returnerar strängen som erhålls genom att göra backslash-substitution på "
"mallsträngen *template*, vilket görs av metoden :meth:`~Pattern.sub`. "
"Escapes som ``\\n`` konverteras till lämpliga tecken, och numeriska "
"backreferenser (``1``, ``2``) och namngivna backreferenser (``\\g<1>``, "
"``g<name>``) ersätts av innehållet i motsvarande grupp. Bakreferensen "
"``\\g<0>`` kommer att ersättas av hela matchningen."

msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"Returnerar en eller flera undergrupper av matchningen.  Om det finns ett "
"enda argument är resultatet en enda sträng; om det finns flera argument är "
"resultatet en tupel med ett objekt per argument. Utan argument är *group1* "
"standardvärdet noll (hela matchningen returneras). Om ett *groupN*-argument "
"är noll är motsvarande returvärde hela den matchande strängen; om det är i "
"det inkluderande intervallet [1..99] är det den sträng som matchar "
"motsvarande grupp inom parentes.  Om ett gruppnummer är negativt eller "
"större än det antal grupper som definieras i mönstret, uppstår ett :exc:"
"`IndexError` undantag. Om en grupp ingår i en del av mönstret som inte "
"matchade, är motsvarande resultat ``None``. Om en grupp ingår i en del av "
"mönstret som matchade flera gånger, returneras den sista matchningen. ::"

msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m.group(0)       # The entire match\n"
"'Isaac Newton'\n"
">>> m.group(1)       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m.group(2)       # The second parenthesized subgroup.\n"
"'Newton'\n"
">>> m.group(1, 2)    # Multiple arguments give us a tuple.\n"
"('Isaac', 'Newton')"
msgstr ""
">>> m = re.match(r\"(\\w+) (\\w+)\",\"Isaac Newton, fysiker\")\n"
">>> m.group(0) # Hela matchningen\n"
"\"Isaac Newton\n"
">>> m.group(1) # Den första parentesförsedda undergruppen.\n"
"'Isaac'\n"
">>> m.group(2) # Den andra parentesförsedda undergruppen.\n"
"'Newton'\n"
">>> m.group(1, 2) # Flera argument ger oss en tupel.\n"
"('Isaac', 'Newton')"

msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"Om det reguljära uttrycket använder syntaxen ``(?P<name>...)`` kan *groupN*-"
"argumenten också vara strängar som identifierar grupper med deras "
"gruppnamn.  Om ett strängargument inte används som ett gruppnamn i mönstret, "
"uppstår ett :exc:`IndexError` undantag."

msgid "A moderately complicated example::"
msgstr "Ett måttligt komplicerat exempel::"

msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.group('first_name')\n"
"'Malcolm'\n"
">>> m.group('last_name')\n"
"'Reynolds'"
msgstr ""
">>> m = re.match(r\"(?P<förnamn>\\w+) (?P<efternamn>\\w+)\",\"Malcolm "
"Reynolds\")\n"
">>> m.group('förnamn')\n"
"'Malcolm'\n"
">>> m.group('efternamn')\n"
"\"Reynolds"

msgid "Named groups can also be referred to by their index::"
msgstr "Namngivna grupper kan också hänvisas till genom sitt index::"

msgid ""
">>> m.group(1)\n"
"'Malcolm'\n"
">>> m.group(2)\n"
"'Reynolds'"
msgstr ""
">>> m.grupp(1)\n"
"'Malcolm'\n"
">>> m.grupp(2)\n"
"'Reynolds'"

msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""
"Om en grupp matchar flera gånger är det bara den sista matchningen som är "
"tillgänglig::"

msgid ""
">>> m = re.match(r\"(..)+\", \"a1b2c3\")  # Matches 3 times.\n"
">>> m.group(1)                        # Returns only the last match.\n"
"'c3'"
msgstr ""
">>> m = re.match(r\"(..)+\", \"a1b2c3\")  # Matchar 3 gånger.\n"
">>> m.group(1) # Returnerar endast den sista matchningen.\n"
"'c3'"

msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""
"Detta är identiskt med ``m.group(g)``.  Detta gör det lättare att få "
"tillgång till en enskild grupp från en matchning:"

msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m[0]       # The entire match\n"
"'Isaac Newton'\n"
">>> m[1]       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m[2]       # The second parenthesized subgroup.\n"
"'Newton'"
msgstr ""
">>> m = re.match(r\"(\\w+) (\\w+)\",\"Isaac Newton, fysiker\")\n"
">>> m[0] # Hela matchningen\n"
"\"Isaac Newton\n"
">>> m[1] # Den första parentesförsedda undergruppen.\n"
"'Isaac'\n"
">>> m[2] # Den andra parentesförsedda undergruppen.\n"
"'Newton'"

msgid "Named groups are supported as well::"
msgstr "Namngivna grupper stöds också::"

msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Isaac "
"Newton\")\n"
">>> m['first_name']\n"
"'Isaac'\n"
">>> m['last_name']\n"
"'Newton'"
msgstr ""
">>> m = re.match(r\"(?P<förnamn>\\w+) (?P<efternamn>\\w+)\",\"Isaac "
"Newton\")\n"
">>> m['förnamn']\n"
"\"Isaac\n"
">>> m['efternamn']\n"
"'Newton'"

msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"Returnerar en tupel som innehåller alla undergrupper i matchningen, från 1 "
"upp till hur många grupper som helst i mönstret.  Argumentet *default* "
"används för grupper som inte deltog i matchningen; standardvärdet är "
"``None``."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n"
">>> m.groups()\n"
"('24', '1632')"
msgstr ""
">>> m = re.match(r\"(\\d+)\\.(\\d+)\",\"24.1632\")\n"
">>> m.grupper()\n"
"('24', '1632')"

msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"Om vi gör decimaltecknet och allt efter det valfritt kan det hända att inte "
"alla grupper deltar i matchningen.  Dessa grupper kommer som standard att "
"vara ``None`` om inte *default*-argumentet anges::"

msgid ""
">>> m = re.match(r\"(\\d+)\\.?(\\d+)?\", \"24\")\n"
">>> m.groups()      # Second group defaults to None.\n"
"('24', None)\n"
">>> m.groups('0')   # Now, the second group defaults to '0'.\n"
"('24', '0')"
msgstr ""
">>> m = re.match(r\"(\\d+)\\.?(\\d+)?\", \"24\")\n"
">>> m.groups() # Andra gruppen är som standard ingen.\n"
"('24', Ingen)\n"
">>> m.groups('0') # Nu är standardvärdet för den andra gruppen '0'.\n"
"('24', '0')"

msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"Returnerar en ordbok som innehåller alla *namngivna* undergrupper i "
"matchningen, med undergruppsnamnet som nyckel.  Argumentet *default* används "
"för grupper som inte deltog i matchningen; standardvärdet är ``None``.  Till "
"exempel::"

msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.groupdict()\n"
"{'first_name': 'Malcolm', 'last_name': 'Reynolds'}"
msgstr ""
">>> m = re.match(r\"(?P<förnamn>\\w+) (?P<efternamn>\\w+)\",\"Malcolm "
"Reynolds\")\n"
">>> m.groupdict()\n"
"{'förnamn': 'Malcolm', 'efternamn': 'Reynolds'}"

msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"Returnerar indexen för början och slutet av den delsträng som matchas av "
"*group*; *group* är som standard noll (vilket betyder hela den matchade "
"delsträngen). Returnerar ``-1`` om *group* finns men inte bidrog till "
"matchningen.  För ett matchningsobjekt *m* och en grupp *g* som bidrog till "
"matchningen är den delsträng som matchas av gruppen *g* (motsvarande ``m."
"group(g)``) ::"

msgid "m.string[m.start(g):m.end(g)]"
msgstr "m.string[m.start(g):m.slut(g)]"

msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"Observera att ``m.start(group)`` kommer att vara lika med ``m.end(group)`` "
"om *group* matchade en nollsträng.  Till exempel, efter ``m = re."
"search('b(c?)', 'cba')``, är ``m.start(0)`` 1, ``m.end(0)`` är 2, ``m."
"start(1)`` och ``m.end(1)`` är båda 2, och ``m.start(2)`` ger upphov till "
"ett :exc:`IndexError` undantag."

msgid "An example that will remove *remove_this* from email addresses::"
msgstr "Ett exempel som tar bort *remove_this* från e-postadresser::"

msgid ""
">>> email = \"tony@tiremove_thisger.net\"\n"
">>> m = re.search(\"remove_this\", email)\n"
">>> email[:m.start()] + email[m.end():]\n"
"'tony@tiger.net'"
msgstr ""
">>> e-post = \"tony@tiremove_thisger.net\"\n"
">>> m = re.search(\"remove_this\", email)\n"
">>> email[:m.start()] + email[m.end():]\n"
"'tony@tiger.net'"

msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"För en matchning *m* returneras 2-tupeln ``(m.start(group), m.end(group))``. "
"Observera att om *grupp* inte bidrog till matchen är detta ``(-1, -1)``. "
"*group* är standardvärdet noll, hela matchningen."

msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
"Värdet på *pos* som skickades till metoden :meth:`~Pattern.search` eller :"
"meth:`~Pattern.match` i ett :ref:`regexobjekt <re-objects>`.  Detta är det "
"index i strängen där RE-motorn började leta efter en matchning."

msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
"Värdet på *endpos* som skickades till metoden :meth:`~Pattern.search` eller :"
"meth:`~Pattern.match` i en :ref:`regexobjekt <re-objects>`.  Detta är det "
"index i strängen som RE-motorn inte kommer längre än så."

msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"Heltalsindexet för den senast matchade fångstgruppen, eller ``None`` om "
"ingen grupp matchades alls. Till exempel kommer uttrycken ``(a)b``, ``((a)"
"(b))`` och ``((ab))`` att ha ``lastindex == 1`` om de tillämpas på strängen "
"``'ab'``, medan uttrycket ``(a)(b)`` kommer att ha ``lastindex == 2`` om det "
"tillämpas på samma sträng."

msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"Namnet på den senast matchade fångstgruppen, eller ``None`` om gruppen inte "
"hade något namn, eller om ingen grupp matchades alls."

msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""
"Den :ref:`objekt för reguljära uttryck <re-objects>` vars :meth:`~Pattern."
"match` eller :meth:`~Pattern.search` metod producerade denna "
"matchningsinstans."

msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""
"Den sträng som skickas till :meth:`~Pattern.match` eller :meth:`~Pattern."
"search`."

msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""
"Lagt till stöd för :func:`copy.copy` och :func:`copy.deepcopy`.  "
"Matchningsobjekt betraktas som atomära."

msgid "Regular Expression Examples"
msgstr "Exempel på reguljära uttryck"

msgid "Checking for a Pair"
msgstr "Kontrollerar för ett par"

msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"I det här exemplet använder vi följande hjälpfunktion för att visa "
"matchningsobjekt på ett lite mer elegant sätt::"

msgid ""
"def displaymatch(match):\n"
"    if match is None:\n"
"        return None\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"
msgstr ""
"def displaymatch(match):\n"
"    om match är None:\n"
"        returnera Ingen\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"

msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Anta att du skriver ett pokerprogram där en spelares hand representeras av "
"en sträng med 5 tecken där varje tecken representerar ett kort, \"a\" för "
"ess, \"k\" för kung, \"q\" för dam, \"j\" för knekt, \"t\" för 10 och \"2\" "
"till \"9\" representerar kortet med det värdet."

msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""
"För att se om en given sträng är en giltig hand kan man göra följande::"

msgid ""
">>> valid = re.compile(r\"^[a2-9tjqk]{5}$\")\n"
">>> displaymatch(valid.match(\"akt5q\"))  # Valid.\n"
"\"<Match: 'akt5q', groups=()>\"\n"
">>> displaymatch(valid.match(\"akt5e\"))  # Invalid.\n"
">>> displaymatch(valid.match(\"akt\"))    # Invalid.\n"
">>> displaymatch(valid.match(\"727ak\"))  # Valid.\n"
"\"<Match: '727ak', groups=()>\""
msgstr ""
">>> valid = re.compile(r\"^[a2-9tjqk]{5}$\")\n"
">>> displaymatch(valid.match(\"akt5q\"))  # Giltig.\n"
"\"<Matchning: 'akt5q', grupper=()>\"\n"
">>> displaymatch(valid.match(\"akt5e\"))  # Ogiltig.\n"
">>> displaymatch(valid.match(\"akt\"))    # Invalid.\n"
">>> displaymatch(valid.match(\"727ak\"))  # Giltig.\n"
"\"<Matchning: '727ak', grupper=()>\""

msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"Den sista handen, ``\"727ak\"``, innehöll ett par eller två kort med samma "
"värde. För att matcha detta med ett reguljärt uttryck kan man använda "
"backreferenser som t.ex:"

msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> displaymatch(pair.match(\"717ak\"))     # Pair of 7s.\n"
"\"<Match: '717', groups=('7',)>\"\n"
">>> displaymatch(pair.match(\"718ak\"))     # No pairs.\n"
">>> displaymatch(pair.match(\"354aa\"))     # Pair of aces.\n"
"\"<Match: '354aa', groups=('a',)>\""
msgstr ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> displaymatch(par.match(\"717ak\"))     # Par av 7-tal.\n"
"\"<Matchning: '717', grupper=('7',)>\"\n"
">>> displaymatch(par.match(\"718ak\"))     # Inga par.\n"
">>> displaymatch(par.match(\"354aa\"))     # Par med ess.\n"
"\"<Matchning: '354aa', grupper=('a',)>\""

msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr ""
"För att ta reda på vilket kort paret består av kan man använda :meth:`~Match."
"group`-metoden för match-objektet på följande sätt::"

msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> pair.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Error because re.match() returns None, which doesn't have a group() "
"method:\n"
">>> pair.match(\"718ak\").group(1)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#23>\", line 1, in <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: 'NoneType' object has no attribute 'group'\n"
"\n"
">>> pair.match(\"354aa\").group(1)\n"
"'a'"
msgstr ""
"&gt;&gt;&gt; pair = re.compile(r\".*(.).*\\1\")\n"
"&gt;&gt;&gt; par.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Fel eftersom re.match() returnerar None, som inte har någon group()-"
"metod:\n"
"&gt;&gt;&gt; par.match(\"718ak\").group(1)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<pyshell#23>\", rad 1, i <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: Objektet 'NoneType' har inget attribut 'group'\n"
"\n"
"&gt;&gt;&gt; pair.match(\"354aa\").group(1)\n"
"'a'"

msgid "Simulating scanf()"
msgstr "Simulering av scanf()"

msgid ""
"Python does not currently have an equivalent to :c:func:`!scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`!scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`!scanf` format tokens and regular "
"expressions."
msgstr ""
"Python har för närvarande ingen motsvarighet till :c:func:`!scanf`.  "
"Reguljära uttryck är i allmänhet mer kraftfulla, men också mer verbala, än :"
"c:func:`!scanf` formatsträngar.  Tabellen nedan visar några mer eller mindre "
"likvärdiga mappningar mellan :c:func:`!scanf`-formattokens och reguljära "
"uttryck."

msgid ":c:func:`!scanf` Token"
msgstr ":c:func:`!scanf` Token"

msgid "Regular Expression"
msgstr "Reguljärt uttryck"

msgid "``%c``"
msgstr "``%c``"

msgid "``%5c``"
msgstr "``%5c``"

msgid "``.{5}``"
msgstr "``.{5}``"

msgid "``%d``"
msgstr "``%d``"

msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

msgid "``%i``"
msgstr "``%i``"

msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

msgid "``%o``"
msgstr "``%o``"

msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

msgid "``%s``"
msgstr "``%s``"

msgid "``\\S+``"
msgstr "``\\S+``"

msgid "``%u``"
msgstr "``%u``"

msgid "``\\d+``"
msgstr "``\\d+``"

msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

msgid "To extract the filename and numbers from a string like ::"
msgstr "Så här extraherar du filnamn och siffror från en sträng som ::"

msgid "/usr/sbin/sendmail - 0 errors, 4 warnings"
msgstr "/usr/sbin/sendmail - 0 fel, 4 varningar"

msgid "you would use a :c:func:`!scanf` format like ::"
msgstr "skulle du använda ett :c:func:`!scanf`-format som ::"

msgid "%s - %d errors, %d warnings"
msgstr "%s - %d fel, %d varningar"

msgid "The equivalent regular expression would be ::"
msgstr "Motsvarande reguljära uttryck skulle vara ::"

msgid "(\\S+) - (\\d+) errors, (\\d+) warnings"
msgstr "(\\S+) - (\\d+) fel, (\\d+) varningar"

msgid "search() vs. match()"
msgstr "sök() vs. match()"

msgid ""
"Python offers different primitive operations based on regular expressions:"
msgstr ""
"Python erbjuder olika primitiva operationer baserade på reguljära uttryck:"

msgid ":func:`re.match` checks for a match only at the beginning of the string"
msgstr ":func:`re.match` söker efter en matchning endast i början av strängen"

msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what "
"Perl does by default)"
msgstr ""
":func:`re.search` söker efter en träff var som helst i strängen (detta är "
"vad Perl gör som standard)"

msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ":func:`re.fullmatch` kontrollerar att hela strängen är en matchning"

msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"c\", \"abcdef\")   # Match\n"
"<re.Match object; span=(2, 3), match='c'>\n"
">>> re.fullmatch(\"p.*n\", \"python\") # Match\n"
"<re.Match object; span=(0, 6), match='python'>\n"
">>> re.fullmatch(\"r.*n\", \"python\") # No match"
msgstr ""
">>> re.match(\"c\", \"abcdef\") # Ingen matchning\n"
">>> re.search(\"c\", \"abcdef\") # Matchning\n"
"<re.match-objekt; span=(2, 3), match='c'> >>> re.fullmatch\n"
">>> re.fullmatch(\"p.*n\", \"python\") # Matchning\n"
"<re.match-objekt; span=(0, 6), match='python'>\n"
">>> re.fullmatch(\"r.*n\", \"python\") # Ingen matchning"

msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Reguljära uttryck som börjar med ``'^'`` kan användas med :func:`search` för "
"att begränsa matchningen till början av strängen::"

msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"^c\", \"abcdef\")  # No match\n"
">>> re.search(\"^a\", \"abcdef\")  # Match\n"
"<re.Match object; span=(0, 1), match='a'>"
msgstr ""
">>> re.match(\"c\", \"abcdef\") # Ingen matchning\n"
">>> re.search(\"^c\", \"abcdef\") # Ingen matchning\n"
">>> re.search(\"^a\", \"abcdef\") # Matchning\n"
"<re.Match-objekt; span=(0, 1), match='a'>"

msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"Observera dock att i :const:`MULTILINE`-läget matchar :func:`match` bara i "
"början av strängen, medan :func:`search` med ett reguljärt uttryck som "
"börjar med ``'^'`` matchar i början av varje rad:"

msgid ""
">>> re.match(\"X\", \"A\\nB\\nX\", re.MULTILINE)  # No match\n"
">>> re.search(\"^X\", \"A\\nB\\nX\", re.MULTILINE)  # Match\n"
"<re.Match object; span=(4, 5), match='X'>"
msgstr ""
">>> re.match(\"X\", \"A\\nB\\nX\", re.MULTILINE) # Ingen matchning\n"
">>> re.search(\"^X\", \"A\\nB\\nX\", re.MULTILINE) # Matchning\n"
"<re.Match-objekt; span=(4, 5), match='X'>"

msgid "Making a Phonebook"
msgstr "Skapa en telefonbok"

msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` delar upp en sträng i en lista som avgränsas av det passerade "
"mönstret.  Metoden är ovärderlig för att konvertera textdata till "
"datastrukturer som lätt kan läsas och modifieras av Python, vilket visas i "
"följande exempel som skapar en telefonbok."

msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"Först, här är indata.  Normalt kan den komma från en fil, här använder vi "
"trippelciterad strängsyntax"

msgid ""
">>> text = \"\"\"Ross McFluff: 834.345.1254 155 Elm Street\n"
"...\n"
"... Ronald Heathmore: 892.345.3428 436 Finley Avenue\n"
"... Frank Burger: 925.541.7625 662 South Dogwood Way\n"
"...\n"
"...\n"
"... Heather Albrecht: 548.326.4584 919 Park Place\"\"\""
msgstr ""
">>> text = \"\"\"Ross McFluff: 834.345.1254 155 Elm Street\n"
"...\n"
"... Ronald Heathmore: 892.345.3428 436 Finley Avenue\n"
"... Frank Burger: 925.541.7625 662 South Dogwood Way\n"
"...\n"
"...\n"
"... Heather Albrecht: 548.326.4584 919 Park Place\"\"\""

msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Posterna är åtskilda av en eller flera nya linjer. Nu omvandlar vi strängen "
"till en lista där varje icke-tom rad har en egen post:"

msgid ""
">>> entries = re.split(\"\\n+\", text)\n"
">>> entries\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"'Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"'Frank Burger: 925.541.7625 662 South Dogwood Way',\n"
"'Heather Albrecht: 548.326.4584 919 Park Place']"
msgstr ""
">>> poster = re.split(\"\\n+\", text)\n"
">>> poster\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"\"Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"\"Frank Burger: 925.541.7625 662 South Dogwood Way\",\n"
"\"Heather Albrecht: 548.326.4584 919 Park Place\"]"

msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Slutligen delar vi upp varje post i en lista med förnamn, efternamn, "
"telefonnummer och adress.  Vi använder parametern ``maxsplit`` i :func:"
"`split` eftersom adressen innehåller mellanslag, vårt uppdelningsmönster:"

msgid ""
">>> [re.split(\":? \", entry, maxsplit=3) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"
msgstr ""
">>> [re.split(\":? \", post, maxsplit=3) för post i poster]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"

msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"Mönstret ``:?`` matchar kolon efter efternamnet, så att det inte förekommer "
"i resultatlistan.  Med en ``maxsplit`` på ``4`` kan vi separera husnumret "
"från gatunamnet:"

msgid ""
">>> [re.split(\":? \", entry, maxsplit=4) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"
msgstr ""
">>> [re.split(\":? \", post, maxsplit=4) för post i poster]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"

msgid "Text Munging"
msgstr "Text Munging"

msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` ersätter varje förekomst av ett mönster med en sträng eller "
"resultatet av en funktion.  I det här exemplet används :func:`sub` "
"tillsammans med en funktion för att \"mjuka upp\" text, dvs. slumpa fram "
"ordningen på alla tecken i varje ord i en mening utom det första och sista "
"tecknet::"

msgid ""
">>> def repl(m):\n"
"...     inner_word = list(m.group(2))\n"
"...     random.shuffle(inner_word)\n"
"...     return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
"...\n"
">>> text = \"Professor Abdolmalek, please report your absences promptly.\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'"
msgstr ""
">>> def repl(m):\n"
"... inner_word = list(m.group(2))\n"
"... slumpmässig.blanda(inre_ord)\n"
"... return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
"...\n"
">>> text = \"Professor Abdolmalek, vänligen rapportera din frånvaro omgående."
"\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"\"Poefsrosr Aealmlobdk, pslaee rapportera din frånvaro plmrptoy\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'"

msgid "Finding all Adverbs"
msgstr "Hitta alla adverb"

msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` matchar *alla* förekomster av ett mönster, inte bara den "
"första som :func:`search` gör.  Om en skribent till exempel vill hitta alla "
"adverb i en text, kan han använda :func:`findall` på följande sätt::"

msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> re.findall(r\"\\w+ly\\b\", text)\n"
"['carefully', 'quickly']"
msgstr ""
">>> text = \"Han var omsorgsfullt förklädd men fångades snabbt av polisen."
"\"\n"
">>> re.findall(r\"\\w+ly\\b\", text)\n"
"['försiktigt', 'snabbt']"

msgid "Finding all Adverbs and their Positions"
msgstr "Hitta alla adverb och deras positioner"

msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :class:`~re.Match` "
"objects instead of strings.  Continuing with the previous example, if a "
"writer wanted to find all of the adverbs *and their positions* in some text, "
"they would use :func:`finditer` in the following manner::"
msgstr ""
"Om man vill ha mer information om alla matchningar av ett mönster än den "
"matchade texten, är :func:`finditer` användbar eftersom den tillhandahåller :"
"class:`~re.Match`-objekt istället för strängar.  Om vi fortsätter med det "
"tidigare exemplet och en skribent vill hitta alla adverb *och deras "
"positioner* i en text, skulle han använda :func:`finditer` på följande sätt::"

msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> for m in re.finditer(r\"\\w+ly\\b\", text):\n"
"...     print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))\n"
"07-16: carefully\n"
"40-47: quickly"
msgstr ""
">>> text = \"Han var omsorgsfullt förklädd men fångades snabbt av polisen."
"\"\n"
">>> for m in re.finditer(r\"\\w+ly\\b\", text):\n"
"... print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))\n"
"07-16: försiktigt\n"
"40-47: snabbt"

msgid "Raw String Notation"
msgstr "Notation av råa strängar"

msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Rå strängnotation (``r\"text\"``) håller reguljära uttryck sunda.  Utan den "
"skulle varje backslash (``'\\'``) i ett reguljärt uttryck behöva föregås av "
"en annan för att undkomma den.  Till exempel är de två följande raderna med "
"kod funktionellt identiska::"

msgid ""
">>> re.match(r\"\\W(.)\\1\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>\n"
">>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>"
msgstr ""
">>> re.match(r\"\\W(.)\\1\\W\", \" ff \")\n"
"<re.Match-objekt; span=(0, 4), match=' ff '>\n"
">>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \")\n"
"<re.match-objekt; span=(0, 4), match=' ff '>"

msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"När man vill matcha en bokstavlig backslash måste den escapas i det "
"reguljära uttrycket.  Med rå strängnotation betyder detta ``r\"\\\\\"``.  "
"Utan rå strängnotation måste man använda ``\"\\\\\\\\\"``, vilket gör "
"följande kodrader funktionellt identiska::"

msgid ""
">>> re.match(r\"\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>\n"
">>> re.match(\"\\\\\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>"
msgstr ""
">>> re.match(r\"\\\\\", r\"\\\\\")\n"
"<re.match-objekt; span=(0, 1), match='\\\\'> >>> re.match(\", r\"\\\\\")\n"
">>> re.match(\"\\\\\\\\\", r\"\\\\\")\n"
"<re.match-objekt; span=(0, 1), match='\\\\'> >>> re.match(\", r\"\\\\\")"

msgid "Writing a Tokenizer"
msgstr "Skriva en Tokenizer"

msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"En `tokenizer eller scanner <https://en.wikipedia.org/wiki/"
"Lexical_analysis>`_ analyserar en sträng för att kategorisera grupper av "
"tecken.  Detta är ett användbart första steg i att skriva en kompilator "
"eller tolk."

msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"Textkategorierna specificeras med reguljära uttryck.  Tekniken är att "
"kombinera dessa till ett enda övergripande reguljärt uttryck och att loopa "
"över successiva matchningar::"

msgid ""
"from typing import NamedTuple\n"
"import re\n"
"\n"
"class Token(NamedTuple):\n"
"    type: str\n"
"    value: str\n"
"    line: int\n"
"    column: int\n"
"\n"
"def tokenize(code):\n"
"    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}\n"
"    token_specification = [\n"
"        ('NUMBER',   r'\\d+(\\.\\d*)?'),  # Integer or decimal number\n"
"        ('ASSIGN',   r':='),           # Assignment operator\n"
"        ('END',      r';'),            # Statement terminator\n"
"        ('ID',       r'[A-Za-z]+'),    # Identifiers\n"
"        ('OP',       r'[+\\-*/]'),      # Arithmetic operators\n"
"        ('NEWLINE',  r'\\n'),           # Line endings\n"
"        ('SKIP',     r'[ \\t]+'),       # Skip over spaces and tabs\n"
"        ('MISMATCH', r'.'),            # Any other character\n"
"    ]\n"
"    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in "
"token_specification)\n"
"    line_num = 1\n"
"    line_start = 0\n"
"    for mo in re.finditer(tok_regex, code):\n"
"        kind = mo.lastgroup\n"
"        value = mo.group()\n"
"        column = mo.start() - line_start\n"
"        if kind == 'NUMBER':\n"
"            value = float(value) if '.' in value else int(value)\n"
"        elif kind == 'ID' and value in keywords:\n"
"            kind = value\n"
"        elif kind == 'NEWLINE':\n"
"            line_start = mo.end()\n"
"            line_num += 1\n"
"            continue\n"
"        elif kind == 'SKIP':\n"
"            continue\n"
"        elif kind == 'MISMATCH':\n"
"            raise RuntimeError(f'{value!r} unexpected on line {line_num}')\n"
"        yield Token(kind, value, line_num, column)\n"
"\n"
"statements = '''\n"
"    IF quantity THEN\n"
"        total := total + price * quantity;\n"
"        tax := price * 0.05;\n"
"    ENDIF;\n"
"'''\n"
"\n"
"for token in tokenize(statements):\n"
"    print(token)"
msgstr ""
"from typing import NamedTuple\n"
"import re\n"
"\n"
"class Token(NamedTuple):\n"
"    type: str\n"
"    value: str\n"
"    line: int\n"
"    column: int\n"
"\n"
"def tokenize(code):\n"
"    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}\n"
"    token_specification = [\n"
"        ('NUMBER',   r'\\d+(\\.\\d*)?'),  # Integer or decimal number\n"
"        ('ASSIGN',   r':='),           # Assignment operator\n"
"        ('END',      r';'),            # Statement terminator\n"
"        ('ID',       r'[A-Za-z]+'),    # Identifiers\n"
"        ('OP',       r'[+\\-*/]'),      # Arithmetic operators\n"
"        ('NEWLINE',  r'\\n'),           # Line endings\n"
"        ('SKIP',     r'[ \\t]+'),       # Skip over spaces and tabs\n"
"        ('MISMATCH', r'.'),            # Any other character\n"
"    ]\n"
"    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in "
"token_specification)\n"
"    line_num = 1\n"
"    line_start = 0\n"
"    for mo in re.finditer(tok_regex, code):\n"
"        kind = mo.lastgroup\n"
"        value = mo.group()\n"
"        column = mo.start() - line_start\n"
"        if kind == 'NUMBER':\n"
"            value = float(value) if '.' in value else int(value)\n"
"        elif kind == 'ID' and value in keywords:\n"
"            kind = value\n"
"        elif kind == 'NEWLINE':\n"
"            line_start = mo.end()\n"
"            line_num += 1\n"
"            continue\n"
"        elif kind == 'SKIP':\n"
"            continue\n"
"        elif kind == 'MISMATCH':\n"
"            raise RuntimeError(f'{value!r} unexpected on line {line_num}')\n"
"        yield Token(kind, value, line_num, column)\n"
"\n"
"statements = '''\n"
"    IF quantity THEN\n"
"        total := total + price * quantity;\n"
"        tax := price * 0.05;\n"
"    ENDIF;\n"
"'''\n"
"\n"
"for token in tokenize(statements):\n"
"    print(token)"

msgid "The tokenizer produces the following output::"
msgstr "Tokenizer producerar följande utdata::"

msgid ""
"Token(type='IF', value='IF', line=2, column=4)\n"
"Token(type='ID', value='quantity', line=2, column=7)\n"
"Token(type='THEN', value='THEN', line=2, column=16)\n"
"Token(type='ID', value='total', line=3, column=8)\n"
"Token(type='ASSIGN', value=':=', line=3, column=14)\n"
"Token(type='ID', value='total', line=3, column=17)\n"
"Token(type='OP', value='+', line=3, column=23)\n"
"Token(type='ID', value='price', line=3, column=25)\n"
"Token(type='OP', value='*', line=3, column=31)\n"
"Token(type='ID', value='quantity', line=3, column=33)\n"
"Token(type='END', value=';', line=3, column=41)\n"
"Token(type='ID', value='tax', line=4, column=8)\n"
"Token(type='ASSIGN', value=':=', line=4, column=12)\n"
"Token(type='ID', value='price', line=4, column=15)\n"
"Token(type='OP', value='*', line=4, column=21)\n"
"Token(type='NUMBER', value=0.05, line=4, column=23)\n"
"Token(type='END', value=';', line=4, column=27)\n"
"Token(type='ENDIF', value='ENDIF', line=5, column=4)\n"
"Token(type='END', value=';', line=5, column=9)"
msgstr ""
"Token(type='IF', value='IF', rad=2, kolumn=4)\n"
"Token(type='ID', value='quantity', rad=2, kolumn=7)\n"
"Token(type='THEN', value='THEN', line=2, column=16)\n"
"Token(typ='ID', värde='total', rad=3, kolumn=8)\n"
"Token(type='ASSIGN', value=':=', line=3, column=14)\n"
"Token(typ='ID', värde='total', rad=3, kolumn=17)\n"
"Token(type='OP', value='+', line=3, column=23)\n"
"Token(typ='ID', värde='pris', rad=3, kolumn=25)\n"
"Token(typ=\"OP\", värde=\"*\", rad=3, kolumn=31)\n"
"Token(type='ID', value='quantity', rad=3, kolumn=33)\n"
"Token(type='END', value=';', line=3, column=41)\n"
"Token(type='ID', value='tax', rad=4, kolumn=8)\n"
"Token(type='ASSIGN', value=':=', line=4, column=12)\n"
"Token(typ='ID', värde='pris', rad=4, kolumn=15)\n"
"Token(type='OP', value='*', line=4, column=21)\n"
"Token(typ='NUMBER', värde=0,05, rad=4, kolumn=23)\n"
"Token(type='END', value=';', line=4, column=27)\n"
"Token(type='ENDIF', value='ENDIF', line=5, column=4)\n"
"Token(typ='END', värde=';', rad=5, kolumn=9)"

msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3:e upplagan, O'Reilly "
"Media, 2009. Den tredje upplagan av boken täcker inte längre Python alls, "
"men den första upplagan täckte att skriva bra reguljära uttrycksmönster i "
"stor detalj."

msgid ". (dot)"
msgstr ". (punkt)"

msgid "in regular expressions"
msgstr "i reguljära uttryck"

msgid "^ (caret)"
msgstr "^ (caret)"

msgid "$ (dollar)"
msgstr "$ (dollar)"

msgid "* (asterisk)"
msgstr "* (asterisk)"

msgid "+ (plus)"
msgstr "+ (plus)"

msgid "? (question mark)"
msgstr "? (frågetecken)"

msgid "*?"
msgstr "*?"

msgid "+?"
msgstr "+?"

msgid "??"
msgstr "??"

msgid "*+"
msgstr "*+"

msgid "++"
msgstr "++"

msgid "?+"
msgstr "?+"

msgid "{} (curly brackets)"
msgstr "{} (inom hakparentes)"

msgid "\\ (backslash)"
msgstr "\\ (backslash)"

msgid "[] (square brackets)"
msgstr "[] (hakparenteser)"

msgid "- (minus)"
msgstr "- (minus)"

msgid "| (vertical bar)"
msgstr "| (vertikal stapel)"

msgid "() (parentheses)"
msgstr "() (inom parentes)"

msgid "(?"
msgstr "(?"

msgid "(?:"
msgstr "(?:"

msgid "(?P<"
msgstr "(?P<"

msgid "(?P="
msgstr "(?P="

msgid "(?#"
msgstr "(?#"

msgid "(?="
msgstr "(?="

msgid "(?!"
msgstr "(?!"

msgid "(?<="
msgstr "(?<="

msgid "(?<!"
msgstr "(?<!"

msgid "(?("
msgstr "(?("

msgid "\\A"
msgstr "\\A"

msgid "\\b"
msgstr "\\b"

msgid "\\B"
msgstr "\\B"

msgid "\\d"
msgstr "\\d"

msgid "\\D"
msgstr "\\D"

msgid "\\s"
msgstr "\\s"

msgid "\\S"
msgstr "\\S"

msgid "\\w"
msgstr "\\w"

msgid "\\W"
msgstr "\\W"

msgid "\\z"
msgstr "\\z"

msgid "\\Z"
msgstr "\\Z"

msgid "\\a"
msgstr "\\a"

msgid "\\f"
msgstr "\\f"

msgid "\\n"
msgstr "\\n"

msgid "\\r"
msgstr "\\r"

msgid "\\t"
msgstr "\\t"

msgid "\\u"
msgstr "\\u"

msgid "\\U"
msgstr "\\U"

msgid "\\v"
msgstr "\\v"

msgid "\\x"
msgstr "\\x"

msgid "\\\\"
msgstr "\\\\"

msgid "# (hash)"
msgstr "# (hash)"

msgid "\\g"
msgstr "\\g"

msgid "scanf (C function)"
msgstr "scanf (C-funktion)"
