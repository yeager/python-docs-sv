# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!numbers` --- Numeric abstract base classes"
msgstr ":mod:`!numbers` --- Numeriska abstrakta basklasser"

msgid "**Source code:** :source:`Lib/numbers.py`"
msgstr "**Källkod:** :source:`Lib/numbers.py`"

msgid ""
"The :mod:`!numbers` module (:pep:`3141`) defines a hierarchy of numeric :"
"term:`abstract base classes <abstract base class>` which progressively "
"define more operations.  None of the types defined in this module are "
"intended to be instantiated."
msgstr ""
"Modulen :mod:`!numbers` (:pep:`3141`) definierar en hierarki av numeriska :"
"term:`abstrakta basklasser <abstract base class>` som successivt definierar "
"fler operationer.  Ingen av de typer som definieras i denna modul är avsedda "
"att instansieras."

msgid ""
"The root of the numeric hierarchy. If you just want to check if an argument "
"*x* is a number, without caring what kind, use ``isinstance(x, Number)``."
msgstr ""
"Roten i den numeriska hierarkin. Om du bara vill kontrollera om ett argument "
"*x* är ett tal, utan att bry dig om vilken typ, använd ``isinstance(x, "
"Number)``."

msgid "The numeric tower"
msgstr "Det numeriska tornet"

msgid ""
"Subclasses of this type describe complex numbers and include the operations "
"that work on the built-in :class:`complex` type. These are: conversions to :"
"class:`complex` and :class:`bool`, :attr:`.real`, :attr:`.imag`, ``+``, ``-"
"``, ``*``, ``/``, ``**``, :func:`abs`, :meth:`conjugate`, ``==``, and ``!"
"=``. All except ``-`` and ``!=`` are abstract."
msgstr ""
"Subklasser av denna typ beskriver komplexa tal och innehåller de operationer "
"som fungerar på den inbyggda typen :class:`complex`. Dessa är: "
"konverteringar till :class:`complex` och :class:`bool`, :attr:`.real`, :attr:"
"`.imag`, ``+``, ``-``, ``*``, ``/``, ``**``, :func:`abs`, :meth:`conjugate`, "
"``==`` och ``!=``. Alla utom ``-`` och ``!=`` är abstrakta."

msgid "Abstract. Retrieves the real component of this number."
msgstr "Sammanfattning. Hämtar den reella komponenten i detta tal."

msgid "Abstract. Retrieves the imaginary component of this number."
msgstr "Sammanfattning. Hämtar den imaginära komponenten i detta tal."

msgid ""
"Abstract. Returns the complex conjugate. For example, ``(1+3j).conjugate() "
"== (1-3j)``."
msgstr ""
"Sammanfattning. Returnerar den komplexa konjugaten. Till exempel, ``(1+3j)."
"conjugate() == (1-3j)``."

msgid ""
"To :class:`Complex`, :class:`!Real` adds the operations that work on real "
"numbers."
msgstr ""
"Till :class:`Complex` lägger :class:`!Real` till de operationer som fungerar "
"på reella tal."

msgid ""
"In short, those are: a conversion to :class:`float`, :func:`math.trunc`, :"
"func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:`divmod`, ``//``, "
"``%``, ``<``, ``<=``, ``>``, and ``>=``."
msgstr ""
"I korthet är dessa: en konvertering till :class:`float`, :func:`math."
"trunc`, :func:`round`, :func:`math.floor`, :func:`math.ceil`, :func:"
"`divmod`, ``//``, ``%``, ``<``, ``<=``, ``>`` och ``>=``."

msgid ""
"Real also provides defaults for :func:`complex`, :attr:`~Complex.real`, :"
"attr:`~Complex.imag`, and :meth:`~Complex.conjugate`."
msgstr ""
"Real innehåller också standardvärden för :func:`complex`, :attr:`~Complex."
"real`, :attr:`~Complex.imag` och :meth:`~Complex.conjugate`."

msgid ""
"Subtypes :class:`Real` and adds :attr:`~Rational.numerator` and :attr:"
"`~Rational.denominator` properties. It also provides a default for :func:"
"`float`."
msgstr ""
"Subtyp av :class:`Real` och lägger till egenskaperna :attr:`~Rational."
"numerator` och :attr:`~Rational.denominator`. Det ger också en standard för :"
"func:`float`."

msgid ""
"The :attr:`~Rational.numerator` and :attr:`~Rational.denominator` values "
"should be instances of :class:`Integral` and should be in lowest terms with :"
"attr:`~Rational.denominator` positive."
msgstr ""
"Värdena :attr:`~Rational.numerator` och :attr:`~Rational.denominator` ska "
"vara instanser av :class:`Integral` och ska vara i lägsta termer med :attr:"
"`~Rational.denominator` positiv."

msgid "Abstract."
msgstr "Sammanfattning."

msgid ""
"Subtypes :class:`Rational` and adds a conversion to :class:`int`.  Provides "
"defaults for :func:`float`, :attr:`~Rational.numerator`, and :attr:"
"`~Rational.denominator`.  Adds abstract methods for :func:`pow` with modulus "
"and bit-string operations: ``<<``, ``>>``, ``&``, ``^``, ``|``, ``~``."
msgstr ""
"Subtyp av :class:`Rational` och lägger till en konvertering till :class:"
"`int`.  Tillhandahåller standardvärden för :func:`float`, :attr:`~Rational."
"numerator` och :attr:`~Rational.denominator`.  Lägger till abstrakta metoder "
"för :func:`pow` med modulus- och bitsträngsoperationer: ``<<``, ``>>``, "
"``&``, ``^``, ``|``, ``~``."

msgid "Notes for type implementers"
msgstr "Anmärkningar för typimplementerare"

msgid ""
"Implementers should be careful to make equal numbers equal and hash them to "
"the same values. This may be subtle if there are two different extensions of "
"the real numbers. For example, :class:`fractions.Fraction` implements :func:"
"`hash` as follows::"
msgstr ""
"Implementatörer bör vara noga med att göra lika tal lika och hasha dem till "
"samma värden. Detta kan vara subtilt om det finns två olika utvidgningar av "
"de reella talen. Till exempel :class:`fractions.Fraction` implementerar :"
"func:`hash` enligt följande::"

msgid ""
"def __hash__(self):\n"
"    if self.denominator == 1:\n"
"        # Get integers right.\n"
"        return hash(self.numerator)\n"
"    # Expensive check, but definitely correct.\n"
"    if self == float(self):\n"
"        return hash(float(self))\n"
"    else:\n"
"        # Use tuple's hash to avoid a high collision rate on\n"
"        # simple fractions.\n"
"        return hash((self.numerator, self.denominator))"
msgstr ""
"def __hash__(self):\n"
"    if self.denominator == 1:\n"
"        # Gör heltal rätt.\n"
"        return hash(self.numerator)\n"
"    # Dyr kontroll, men definitivt korrekt.\n"
"    om self == float(self):\n"
"        returnera hash(float(self))\n"
"    else:\n"
"        # Använd tupels hash för att undvika en hög kollisionsfrekvens på\n"
"        # enkla fraktioner.\n"
"        return hash((self.numerator, self.denominator))"

msgid "Adding More Numeric ABCs"
msgstr "Lägga till fler numeriska ABC"

msgid ""
"There are, of course, more possible ABCs for numbers, and this would be a "
"poor hierarchy if it precluded the possibility of adding those. You can add "
"``MyFoo`` between :class:`Complex` and :class:`Real` with::"
msgstr ""
"Det finns naturligtvis fler möjliga ABC för tal, och detta skulle vara en "
"dålig hierarki om den uteslöt möjligheten att lägga till dessa. Du kan lägga "
"till ``MyFoo`` mellan :class:`Complex` och :class:`Real` med::"

msgid ""
"class MyFoo(Complex): ...\n"
"MyFoo.register(Real)"
msgstr ""
"klass MyFoo(Komplex): ...\n"
"MyFoo.register(Real)"

msgid "Implementing the arithmetic operations"
msgstr "Implementering av aritmetiska operationer"

msgid ""
"We want to implement the arithmetic operations so that mixed-mode operations "
"either call an implementation whose author knew about the types of both "
"arguments, or convert both to the nearest built in type and do the operation "
"there. For subtypes of :class:`Integral`, this means that :meth:`~object."
"__add__` and :meth:`~object.__radd__` should be defined as::"
msgstr ""
"Vi vill implementera de aritmetiska operationerna så att operationer i "
"blandade lägen antingen anropar en implementation vars författare kände till "
"typerna för båda argumenten, eller konverterar båda till närmaste inbyggda "
"typ och utför operationen där. För subtyper av :class:`Integral` innebär "
"detta att :meth:`~object.__add__` och :meth:`~object.__radd__` bör "
"definieras som::"

msgid ""
"class MyIntegral(Integral):\n"
"\n"
"    def __add__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(self, other)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(self, other)\n"
"        else:\n"
"            return NotImplemented\n"
"\n"
"    def __radd__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(other, self)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(other, self)\n"
"        elif isinstance(other, Integral):\n"
"            return int(other) + int(self)\n"
"        elif isinstance(other, Real):\n"
"            return float(other) + float(self)\n"
"        elif isinstance(other, Complex):\n"
"            return complex(other) + complex(self)\n"
"        else:\n"
"            return NotImplemented"
msgstr ""
"klass MyIntegral(Integral):\n"
"\n"
"    def __add__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(self, other)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(self, other)\n"
"        else:\n"
"            return Inte implementerad\n"
"\n"
"    def __radd__(self, other):\n"
"        if isinstance(other, MyIntegral):\n"
"            return do_my_adding_stuff(other, self)\n"
"        elif isinstance(other, OtherTypeIKnowAbout):\n"
"            return do_my_other_adding_stuff(other, self)\n"
"        elif isinstance(other, Integral):\n"
"            return int(other) + int(self)\n"
"        elif isinstance(other, Real):\n"
"            return float(other) + float(self)\n"
"        elif isinstance(other, Complex):\n"
"            return komplex(annan) + komplex(själv)\n"
"        else:\n"
"            return Ej implementerad"

msgid ""
"There are 5 different cases for a mixed-type operation on subclasses of :"
"class:`Complex`. I'll refer to all of the above code that doesn't refer to "
"``MyIntegral`` and ``OtherTypeIKnowAbout`` as \"boilerplate\". ``a`` will be "
"an instance of ``A``, which is a subtype of :class:`Complex` (``a : A <: "
"Complex``), and ``b : B <: Complex``. I'll consider ``a + b``:"
msgstr ""
"Det finns 5 olika fall för en mixed-type operation på subklasser av :class:"
"`Complex`. Jag kommer att referera till all ovanstående kod som inte "
"refererar till ``MyIntegral`` och ``OtherTypeIKnowAbout`` som "
"\"boilerplate\". ``a`` kommer att vara en instans av ``A``, som är en subtyp "
"av :class:`Complex` (``a : A <: Complex``), och ``b : B <: Complex``. Jag "
"kommer att överväga ``a + b``:"

msgid ""
"If ``A`` defines an :meth:`~object.__add__` which accepts ``b``, all is well."
msgstr ""
"Om ``A`` definierar en :meth:`~object.__add__` som accepterar ``b``, är allt "
"väl."

msgid ""
"If ``A`` falls back to the boilerplate code, and it were to return a value "
"from :meth:`~object.__add__`, we'd miss the possibility that ``B`` defines a "
"more intelligent :meth:`~object.__radd__`, so the boilerplate should return :"
"data:`NotImplemented` from :meth:`!__add__`. (Or ``A`` may not implement :"
"meth:`!__add__` at all.)"
msgstr ""
"Om ``A`` faller tillbaka till boilerplate koden, och det skulle returnera "
"ett värde från :meth:`~object.__add__`, skulle vi missa möjligheten att "
"``B`` definierar en mer intelligent :meth:`~object.__radd__`, så boilerplate "
"bör returnera :data:`NotImplemented` från :meth:`!__add__`. (Eller så kanske "
"``A`` inte implementerar :meth:`!__add__`` alls.)"

msgid ""
"Then ``B``'s :meth:`~object.__radd__` gets a chance. If it accepts ``a``, "
"all is well."
msgstr ""
"Då får ``B``:s :meth:`~object.__radd__` en chans. Om den accepterar ``a`` är "
"allt bra."

msgid ""
"If it falls back to the boilerplate, there are no more possible methods to "
"try, so this is where the default implementation should live."
msgstr ""
"Om den faller tillbaka på standardutformningen finns det inga fler möjliga "
"metoder att prova, så det är här standardimplementeringen ska finnas."

msgid ""
"If ``B <: A``, Python tries ``B.__radd__`` before ``A.__add__``. This is ok, "
"because it was implemented with knowledge of ``A``, so it can handle those "
"instances before delegating to :class:`Complex`."
msgstr ""
"Om ``B <: A``, försöker Python ``B.__radd__`` före ``A.__add__``. Detta är "
"ok, eftersom det implementerades med kunskap om ``A``, så det kan hantera "
"dessa instanser innan det delegeras till :class:`Complex``."

msgid ""
"If ``A <: Complex`` and ``B <: Real`` without sharing any other knowledge, "
"then the appropriate shared operation is the one involving the built in :"
"class:`complex`, and both :meth:`~object.__radd__` s land there, so ``a+b == "
"b+a``."
msgstr ""
"Om ``A <: Complex`` och ``B <: Real`` utan att dela någon annan kunskap, så "
"är den lämpliga delade operationen den som involverar den inbyggda :class:"
"`complex``, och båda :meth:`~object.__radd__`` landar där, så ``a+b == b+a``."

msgid ""
"Because most of the operations on any given type will be very similar, it "
"can be useful to define a helper function which generates the forward and "
"reverse instances of any given operator. For example, :class:`fractions."
"Fraction` uses::"
msgstr ""
"Eftersom de flesta operationer på en viss typ kommer att vara mycket lika "
"kan det vara användbart att definiera en hjälpfunktion som genererar de "
"framåtriktade och bakåtriktade instanserna av en viss operator. Till exempel "
"använder :class:`fractions.Fraction`::"

msgid ""
"def _operator_fallbacks(monomorphic_operator, fallback_operator):\n"
"    def forward(a, b):\n"
"        if isinstance(b, (int, Fraction)):\n"
"            return monomorphic_operator(a, b)\n"
"        elif isinstance(b, float):\n"
"            return fallback_operator(float(a), b)\n"
"        elif isinstance(b, complex):\n"
"            return fallback_operator(complex(a), b)\n"
"        else:\n"
"            return NotImplemented\n"
"    forward.__name__ = '__' + fallback_operator.__name__ + '__'\n"
"    forward.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    def reverse(b, a):\n"
"        if isinstance(a, Rational):\n"
"            # Includes ints.\n"
"            return monomorphic_operator(a, b)\n"
"        elif isinstance(a, Real):\n"
"            return fallback_operator(float(a), float(b))\n"
"        elif isinstance(a, Complex):\n"
"            return fallback_operator(complex(a), complex(b))\n"
"        else:\n"
"            return NotImplemented\n"
"    reverse.__name__ = '__r' + fallback_operator.__name__ + '__'\n"
"    reverse.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    return forward, reverse\n"
"\n"
"def _add(a, b):\n"
"    \"\"\"a + b\"\"\"\n"
"    return Fraction(a.numerator * b.denominator +\n"
"                    b.numerator * a.denominator,\n"
"                    a.denominator * b.denominator)\n"
"\n"
"__add__, __radd__ = _operator_fallbacks(_add, operator.add)\n"
"\n"
"# ..."
msgstr ""
"def _operator_fallbacks(monomorf_operator, fallback_operator):\n"
"    def forward(a, b):\n"
"        if isinstance(b, (int, Fraktion)):\n"
"            return monomorfisk_operator(a, b)\n"
"        elif isinstance(b, float):\n"
"            return fallback_operator(float(a), b)\n"
"        elif isinstance(b, komplex):\n"
"            return fallback_operator(komplex(a), b)\n"
"        else:\n"
"            return Ej implementerad\n"
"    forward.__name__ = '__' + fallback_operator.__name__ + '__'\n"
"    forward.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    def reverse(b, a):\n"
"        if isinstance(a, Rational):\n"
"            # Inkluderar ints.\n"
"            return monomorfisk_operator(a, b)\n"
"        elif isinstance(a, Real):\n"
"            return fallback_operator(float(a), float(b))\n"
"        elif isinstance(a, Komplex):\n"
"            return fallback_operator(komplex(a), komplex(b))\n"
"        else:\n"
"            return Inte implementerad\n"
"    reverse.__name__ = '__r' + fallback_operator.__name__ + '__'\n"
"    reverse.__doc__ = monomorphic_operator.__doc__\n"
"\n"
"    returnera framåt, bakåt\n"
"\n"
"def _add(a, b):\n"
"    \"\"\"a + b\"\"\"\n"
"    return Fraktion(a.täljare * b.nämnare + b.täljare * a.nämnare\n"
"                    b.täljare * a.nämnare,\n"
"                    a.nämnare * b.nämnare)\n"
"\n"
"__add__, __radd__ = _operator_fallbacks(_add, operator.add)\n"
"\n"
"# ..."
