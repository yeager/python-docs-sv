# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Module Objects"
msgstr "Modulobjekt"

msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"Denna instans av :c:type:`PyTypeObject` representerar Pythons modultyp.  "
"Detta exponeras för Python-program som ``types.ModuleType``."

msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""
"Returnerar true om *p* är ett modulobjekt eller en subtyp av ett "
"modulobjekt. Denna funktion lyckas alltid."

msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""
"Returnerar true om *p* är ett modulobjekt, men inte en subtyp av :c:data:"
"`PyModule_Type`.  Denna funktion lyckas alltid."

msgid ""
"Return a new module object with :attr:`module.__name__` set to *name*. The "
"module's :attr:`!__name__`, :attr:`~module.__doc__`, :attr:`~module."
"__package__` and :attr:`~module.__loader__` attributes are filled in (all "
"but :attr:`!__name__` are set to ``None``). The caller is responsible for "
"setting a :attr:`~module.__file__` attribute."
msgstr ""
"Returnerar ett nytt modulobjekt med :attr:`module.__name__` satt till "
"*name*. Modulens attribut :attr:`!__name__`, :attr:`~module.__doc__`, :attr:"
"`~module.__package__` och :attr:`~module.__loader__` fylls i (alla utom :"
"attr:`!__name__` sätts till ``None``). Den som anropar är ansvarig för att "
"ange attributet :attr:`~module.__file__`."

msgid "Return ``NULL`` with an exception set on error."
msgstr "Returnerar ``NULL`` med ett undantag inställt på fel."

msgid ""
":attr:`~module.__package__` and :attr:`~module.__loader__` are now set to "
"``None``."
msgstr ""
":attr:`~module.__package__` och :attr:`~module.__loader__` är nu inställda "
"på ``None``."

msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
"Liknar :c:func:`PyModule_NewObject`, men namnet är en UTF-8-kodad sträng i "
"stället för ett Unicode-objekt."

msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"Returnerar det ordboksobjekt som implementerar *modul*:s namnrymd; detta "
"objekt är detsamma som :attr:`~object.__dict__`-attributet för "
"modulobjektet. Om *module* inte är ett modulobjekt (eller en subtyp av ett "
"modulobjekt), avges :exc:`SystemError` och ``NULL`` returneras."

msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""
"Det rekommenderas att använda andra ``PyModule_*`` och ``PyObject_*`` "
"funktioner snarare än att direkt manipulera en moduls :attr:`~object."
"__dict__`."

msgid ""
"Return *module*'s :attr:`~module.__name__` value.  If the module does not "
"provide one, or if it is not a string, :exc:`SystemError` is raised and "
"``NULL`` is returned."
msgstr ""
"Returnerar *modul*:s :attr:`~module.__name__`-värde.  Om modulen inte "
"tillhandahåller något värde eller om det inte är en sträng, :exc:"
"`SystemError` och ``NULL`` returneras."

msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
"Liknar :c:func:`PyModule_GetNameObject` men returnerar namnet kodat till "
"``'utf-8'``."

msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:member:"
"`PyModuleDef.m_size`."
msgstr ""
"Returnerar modulens \"tillstånd\", det vill säga en pekare till det "
"minnesblock som allokerades när modulen skapades, eller ``NULL``.  Se :c:"
"member:`PyModuleDef.m_size`."

msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"Returnerar en pekare till :c:type:`PyModuleDef`-strukturen från vilken "
"modulen skapades, eller ``NULL`` om modulen inte skapades från en definition."

msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`~module.__file__` attribute.  If this is not defined, or if it is not "
"a string, raise :exc:`SystemError` and return ``NULL``; otherwise return a "
"reference to a Unicode object."
msgstr ""
"Returnerar namnet på den fil som *modul* laddades från med hjälp av *moduls* "
"attribut :attr:`~module.__file__`.  Om detta inte är definierat, eller om "
"det inte är en sträng, uppstår :exc:`SystemError` och ``NULL`` returneras; "
"annars returneras en referens till ett Unicode-objekt."

msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
"Liknar :c:func:`PyModule_GetFilenameObject` men returnerar filnamnet kodat "
"till 'utf-8'."

msgid ""
":c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` ger upphov till :exc:`UnicodeEncodeError` på "
"okodbara filnamn, använd :c:func:`PyModule_GetFilenameObject` istället."

msgid "Module definitions"
msgstr "Definitioner av moduler"

msgid ""
"The functions in the previous section work on any module object, including "
"modules imported from Python code."
msgstr ""
"Funktionerna i föregående avsnitt fungerar på alla modulobjekt, inklusive "
"moduler som importeras från Python-kod."

msgid ""
"Modules defined using the C API typically use a *module definition*, :c:type:"
"`PyModuleDef` -- a statically allocated, constant “description\" of how a "
"module should be created."
msgstr ""
"Moduler som definieras med hjälp av C API använder vanligtvis en "
"*moduldefinition*, :c:type:`PyModuleDef` -- en statiskt allokerad, konstant "
"\"beskrivning\" av hur en modul ska skapas."

msgid ""
"The definition is usually used to define an extension's “main” module object "
"(see :ref:`extension-modules` for details). It is also used to :ref:`create "
"extension modules dynamically <moduledef-dynamic>`."
msgstr ""
"Definitionen används vanligtvis för att definiera ett tilläggs \"huvud\"-"
"modulobjekt (se :ref:`extension-modules` för detaljer). Den används också "
"för att :ref:``skapa tilläggsmoduler dynamiskt <moduledef-dynamic>`."

msgid ""
"Unlike :c:func:`PyModule_New`, the definition allows management of *module "
"state* -- a piece of memory that is allocated and cleared together with the "
"module object. Unlike the module's Python attributes, Python code cannot "
"replace or delete data stored in module state."
msgstr ""
"Till skillnad från :c:func:`PyModule_New` tillåter definitionen hantering av "
"*modultillstånd* -- en del av minnet som allokeras och rensas tillsammans "
"med modulobjektet. Till skillnad från modulens Python-attribut kan Python-"
"kod inte ersätta eller ta bort data som lagras i modulens tillstånd."

msgid ""
"The module definition struct, which holds all information needed to create a "
"module object. This structure must be statically allocated (or be otherwise "
"guaranteed to be valid while any modules created from it exist). Usually, "
"there is only one variable of this type for each extension module."
msgstr ""
"Moduldefinitionsstrukturen, som innehåller all information som behövs för "
"att skapa ett modulobjekt. Denna struktur måste vara statiskt allokerad "
"(eller på annat sätt garanteras vara giltig så länge moduler som skapats "
"från den existerar). Vanligtvis finns det bara en variabel av denna typ för "
"varje tilläggsmodul."

msgid "Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`."
msgstr ""
"Initialisera alltid denna medlem till :c:macro:`PyModuleDef_HEAD_INIT`."

msgid "Name for the new module."
msgstr "Namn för den nya modulen."

msgid ""
"Docstring for the module; usually a docstring variable created with :c:macro:"
"`PyDoc_STRVAR` is used."
msgstr ""
"Docstring för modulen; vanligtvis används en docstring-variabel som skapats "
"med :c:macro:`PyDoc_STRVAR`."

msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"Modulstatus kan förvaras i ett minnesområde per modul som kan hämtas med :c:"
"func:`PyModule_GetState`, i stället för i statiska globaler. Detta gör "
"moduler säkra för användning i flera undertolkare."

msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:"
"`~PyModuleDef.m_free` function has been called, if present."
msgstr ""
"Detta minnesområde allokeras baserat på *m_size* när modulen skapas och "
"frigörs när modulobjektet avallokeras, efter att funktionen :c:member:"
"`~PyModuleDef.m_free` har anropats, om den finns."

msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state."
msgstr ""
"Om du anger ett icke-negativt värde innebär det att modulen kan initieras på "
"nytt och anger den extra mängd minne som krävs för dess tillstånd."

msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state. Negative ``m_size`` is only "
"allowed when using :ref:`legacy single-phase initialization <single-phase-"
"initialization>` or when :ref:`creating modules dynamically <moduledef-"
"dynamic>`."
msgstr ""
"Om ``m_size`` sätts till ``-1`` innebär det att modulen inte stöder "
"undertolkare, eftersom den har ett globalt tillstånd. Negativa ``m_size`` är "
"endast tillåtet när man använder :ref:``legacy single-phase initialization "
"<single-phase-initialization>`` eller när man :ref:``creating modules "
"dynamically <moduledef-dynamic>`."

msgid "See :PEP:`3121` for more details."
msgstr "Se :PEP:`3121` för mer information."

msgid ""
"A pointer to a table of module-level functions, described by :c:type:"
"`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr ""
"En pekare till en tabell med funktioner på modulnivå, beskrivna av :c:type:"
"`PyMethodDef`-värden.  Kan vara ``NULL`` om inga funktioner finns."

msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a "
"``{0, NULL}`` entry. When using legacy single-phase initialization, "
"*m_slots* must be ``NULL``."
msgstr ""
"En array av slotdefinitioner för flerfasinitialisering, som avslutas med en "
"``{0, NULL}``-post. Vid användning av äldre enfasinitialisering måste "
"*m_slots* vara ``NULL``."

msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr ""
"Före version 3.5 var denna medlem alltid inställd på ``NULL``, och "
"definierades som:"

msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr ""
"En traversalfunktion som ska anropas under GC-traversal av modulobjektet, "
"eller ``NULL`` om den inte behövs."

msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is "
"greater than 0 and the module state (as returned by :c:func:"
"`PyModule_GetState`) is ``NULL``."
msgstr ""
"Denna funktion anropas inte om modultillståndet begärdes men ännu inte har "
"allokerats. Detta är fallet omedelbart efter att modulen skapats och innan "
"modulen exekveras (:c:data:`Py_mod_exec` funktion). Mer exakt anropas inte "
"denna funktion om :c:member:`~PyModuleDef.m_size` är större än 0 och "
"modultillståndet (som returneras av :c:func:`PyModule_GetState`) är ``NULL``."

msgid "No longer called before the module state is allocated."
msgstr "Anropas inte längre innan modultillståndet har allokerats."

msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr ""
"En clear-funktion som ska anropas vid GC-rensning av modulobjektet, eller "
"``NULL`` om den inte behövs."

msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"Precis som :c:member:`PyTypeObject.tp_clear` anropas inte den här funktionen "
"*alltid* innan en modul avallokeras. Till exempel, när referensräkning är "
"tillräckligt för att avgöra att ett objekt inte längre används, är den "
"cykliska skräpsamlaren inte inblandad och :c:member:`~PyModuleDef.m_free` "
"anropas direkt."

msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr ""
"En funktion som ska anropas vid avallokering av modulobjektet, eller "
"``NULL`` om den inte behövs."

msgid "Module slots"
msgstr "Modulplatser"

msgid "A slot ID, chosen from the available values explained below."
msgstr ""
"Ett slot-ID, som väljs bland de tillgängliga värden som beskrivs nedan."

msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "Värde för slot, vars betydelse beror på slot-ID."

msgid "The available slot types are:"
msgstr "De tillgängliga slot-typerna är:"

msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"Anger en funktion som anropas för att skapa själva modulobjektet. Poängaren "
"*value* i denna slot måste peka på en funktion med samma signatur:"

msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"Funktionen tar emot en instans av :py:class:`~importlib.machinery."
"ModuleSpec`, enligt definitionen i :PEP:`451`, och moduldefinitionen. Den "
"bör returnera ett nytt modulobjekt, eller ange ett fel och returnera "
"``NULL``."

msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"Denna funktion bör hållas minimal. I synnerhet bör den inte anropa "
"godtycklig Python-kod, eftersom försök att importera samma modul igen kan "
"resultera i en oändlig loop."

msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "Flera ``Py_mod_create``-platser får inte anges i en moduldefinition."

msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""
"Om ``Py_mod_create`` inte anges kommer importmaskineriet att skapa ett "
"normalt modulobjekt med hjälp av :c:func:`PyModule_New`. Namnet är taget "
"från *spec*, inte definitionen, för att göra det möjligt för tilläggsmoduler "
"att dynamiskt anpassa sig till sin plats i modulhierarkin och importeras "
"under olika namn genom symlinks, samtidigt som de delar en enda "
"moduldefinition."

msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. Any type can be used, as long as it supports setting and "
"getting import-related attributes. However, only ``PyModule_Type`` instances "
"may be returned if the ``PyModuleDef`` has non-``NULL`` ``m_traverse``, "
"``m_clear``, ``m_free``; non-zero ``m_size``; or slots other than "
"``Py_mod_create``."
msgstr ""
"Det finns inget krav på att det returnerade objektet ska vara en instans av :"
"c:type:`PyModule_Type`. Vilken typ som helst kan användas, så länge den "
"stöder inställning och hämtning av importrelaterade attribut. Dock kan "
"endast ``PyModule_Type`` instanser returneras om ``PyModuleDef`` har icke-"
"``NULL`` ``m_traverse``, ``m_clear``, ``m_free``; icke- noll ``m_size``; "
"eller andra slots än ``Py_mod_create``."

msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"Specificerar en funktion som anropas för att *exekvera* modulen. Detta "
"motsvarar att exekvera koden i en Python-modul: vanligtvis lägger denna "
"funktion till klasser och konstanter i modulen. Funktionens signatur är:"

msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr ""
"Om flera ``Py_mod_exec``-slots anges, behandlas de i den ordning de visas i "
"*m_slots*-arrayen."

msgid "Specifies one of the following values:"
msgstr "Anger ett av följande värden:"

msgid "The module does not support being imported in subinterpreters."
msgstr "Modulen stöder inte import i undertolkar."

msgid ""
"The module supports being imported in subinterpreters, but only when they "
"share the main interpreter's GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""
"Modulen kan importeras i undertolkar, men endast om de delar huvudtolkens "
"GIL. (Se :ref:`isolating-extensions-howto`.)"

msgid ""
"The module supports being imported in subinterpreters, even when they have "
"their own GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""
"Modulen stöder import i undertolkare, även när de har sin egen GIL. (Se :ref:"
"`isolating-extensions-howto`.)"

msgid ""
"This slot determines whether or not importing this module in a "
"subinterpreter will fail."
msgstr ""
"Denna plats avgör om import av denna modul i en subinterpreter kommer att "
"misslyckas eller inte."

msgid ""
"Multiple ``Py_mod_multiple_interpreters`` slots may not be specified in one "
"module definition."
msgstr ""
"Flera ``Py_mod_multiple_interpreters``-platser får inte anges i en "
"moduldefinition."

msgid ""
"If ``Py_mod_multiple_interpreters`` is not specified, the import machinery "
"defaults to ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."
msgstr ""
"Om ``Py_mod_multiple_interpreters`` inte anges, är standardvärdet för "
"importmaskineriet ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."

msgid ""
"The module depends on the presence of the global interpreter lock (GIL), and "
"may access global state without synchronization."
msgstr ""
"Modulen är beroende av att det globala tolklåset (GIL) finns och kan komma "
"åt globala tillstånd utan synkronisering."

msgid "The module is safe to run without an active GIL."
msgstr "Modulen är säker att köra utan en aktiv GIL."

msgid ""
"This slot is ignored by Python builds not configured with :option:`--disable-"
"gil`.  Otherwise, it determines whether or not importing this module will "
"cause the GIL to be automatically enabled. See :ref:`whatsnew313-free-"
"threaded-cpython` for more detail."
msgstr ""
"Denna slot ignoreras av Python-byggnader som inte konfigurerats med :option:"
"`--disable-gil`.  Annars avgör den om import av denna modul kommer att "
"orsaka att GIL aktiveras automatiskt. Se :ref:`whatsnew313-free-threaded-"
"cpython` för mer detaljer."

msgid ""
"Multiple ``Py_mod_gil`` slots may not be specified in one module definition."
msgstr "Flera ``Py_mod_gil``-platser får inte anges i en moduldefinition."

msgid ""
"If ``Py_mod_gil`` is not specified, the import machinery defaults to "
"``Py_MOD_GIL_USED``."
msgstr ""
"Om ``Py_mod_gil`` inte anges, är standardvärdet för importmaskineriet "
"``Py_MOD_GIL_USED``."

msgid "Creating extension modules dynamically"
msgstr "Dynamiskt skapande av tilläggsmoduler"

msgid ""
"The following functions may be used to create a module outside of an "
"extension's :ref:`initialization function <extension-export-hook>`. They are "
"also used in :ref:`single-phase initialization <single-phase-"
"initialization>`."
msgstr ""
"Följande funktioner kan användas för att skapa en modul utanför ett "
"tilläggs :ref:`initialiseringsfunktion <extension-export-hook>`. De används "
"också i :ref:``initialisering i en fas <single-phase-initialization>`."

msgid ""
"Create a new module object, given the definition in *def*. This is a macro "
"that calls :c:func:`PyModule_Create2` with *module_api_version* set to :c:"
"macro:`PYTHON_API_VERSION`, or to :c:macro:`PYTHON_ABI_VERSION` if using "
"the :ref:`limited API <limited-c-api>`."
msgstr ""
"Skapa ett nytt modulobjekt, givet definitionen i *def*. Detta är ett makro "
"som anropar :c:func:`PyModule_Create2` med *module_api_version* satt till :c:"
"macro:`PYTHON_API_VERSION`, eller till :c:macro:`PYTHON_ABI_VERSION` om du "
"använder :ref:`limited API <limited-c-api>`."

msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"Skapa ett nytt modulobjekt med definitionen i *def* och API-versionen "
"*module_api_version*.  Om den versionen inte stämmer överens med versionen i "
"den tolk som körs, skickas en :exc:`RuntimeWarning` ut."

msgid ""
"This function does not support slots. The :c:member:`~PyModuleDef.m_slots` "
"member of *def* must be ``NULL``."
msgstr ""
"Denna funktion stöder inte slots. Medlemmen :c:member:`~PyModuleDef.m_slots` "
"i *def* måste vara ``NULL``."

msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"De flesta användningar av denna funktion bör använda :c:func:"
"`PyModule_Create` istället; använd endast denna om du är säker på att du "
"behöver den."

msgid ""
"This macro calls :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :c:macro:`PYTHON_API_VERSION`, or to :c:macro:"
"`PYTHON_ABI_VERSION` if using the :ref:`limited API <limited-c-api>`."
msgstr ""
"Detta makro anropar :c:func:`PyModule_FromDefAndSpec2` med "
"*module_api_version* satt till :c:macro:`PYTHON_API_VERSION`, eller till :c:"
"macro:`PYTHON_ABI_VERSION` om man använder :ref:`limited API <limited-c-"
"api>`."

msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*, assuming the API version *module_api_version*. If that version does "
"not match the version of the running interpreter, a :exc:`RuntimeWarning` is "
"emitted."
msgstr ""
"Skapar ett nytt modulobjekt, givet definitionen i *def* och ModuleSpec "
"*spec*, med API-versionen *module_api_version*. Om den versionen inte "
"stämmer överens med versionen i den tolk som körs, skickas en :exc:"
"`RuntimeWarning` ut."

msgid ""
"Note that this does not process execution slots (:c:data:`Py_mod_exec`). "
"Both ``PyModule_FromDefAndSpec`` and ``PyModule_ExecDef`` must be called to "
"fully initialize a module."
msgstr ""
"Observera att detta inte behandlar exekveringsplatser (:c:data:"
"`Py_mod_exec`). Både ``PyModule_FromDefAndSpec`` och ``PyModule_ExecDef`` "
"måste anropas för att initiera en modul fullständigt."

msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""
"De flesta användningar av denna funktion bör använda :c:func:"
"`PyModule_FromDefAndSpec` istället; använd endast denna om du är säker på "
"att du behöver den."

msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr ""
"Behandla alla exekveringsplatser (:c:data:`Py_mod_exec`) som anges i *def*."

msgid "The C API version. Defined for backwards compatibility."
msgstr "C API-versionen. Definierad för bakåtkompatibilitet."

msgid ""
"Currently, this constant is not updated in new Python versions, and is not "
"useful for versioning. This may change in the future."
msgstr ""
"För närvarande uppdateras inte denna konstant i nya Python-versioner och är "
"inte användbar för versionshantering. Detta kan komma att ändras i framtiden."

msgid "Defined as ``3`` for backwards compatibility."
msgstr "Definierad som ``3`` för bakåtkompatibilitet."

msgid "Support functions"
msgstr "Stödfunktioner"

msgid ""
"The following functions are provided to help initialize a module state. They "
"are intended for a module's execution slots (:c:data:`Py_mod_exec`), the "
"initialization function for legacy :ref:`single-phase initialization <single-"
"phase-initialization>`, or code that creates modules dynamically."
msgstr ""
"Följande funktioner finns för att initiera en moduls tillstånd. De är "
"avsedda för en moduls exekveringsplatser (:c:data:`Py_mod_exec`), "
"initialiseringsfunktionen för äldre :ref:`single-phase initialization "
"<single-phase-initialization>`, eller kod som skapar moduler dynamiskt."

msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""
"Lägg till ett objekt till *modul* som *namn*.  Detta är en "
"bekvämlighetsfunktion som kan användas från modulens initialiseringsfunktion."

msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""
"Vid framgång, returnera ``0``. Vid fel, skapa ett undantag och returnera "
"``-1``."

msgid "Example usage::"
msgstr "Exempel på användning::"

msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"statisk int\n"
"add_spam(PyObject *modul, int värde)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(värde);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    returnera res;\n"
" }"

msgid ""
"To be convenient, the function accepts ``NULL`` *value* with an exception "
"set. In this case, return ``-1`` and just leave the raised exception "
"unchanged."
msgstr ""
"För att vara bekväm accepterar funktionen ``NULL`` *värde* med ett undantag. "
"I detta fall returneras ``-1`` och det undantag som skapats lämnas "
"oförändrat."

msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""
"Exemplet kan också skrivas utan att uttryckligen kontrollera om *obj* är "
"``NULL``::"

msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"statisk int\n"
"add_spam(PyObject *modul, int värde)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(värde);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    returnera res;\n"
" }"

msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""
"Observera att ``Py_XDECREF()`` bör användas i stället för ``Py_DECREF()`` i "
"detta fall, eftersom *obj* kan vara ``NULL``."

msgid ""
"The number of different *name* strings passed to this function should be "
"kept small, usually by only using statically allocated strings as *name*. "
"For names that aren't known at compile time, prefer calling :c:func:"
"`PyUnicode_FromString` and :c:func:`PyObject_SetAttr` directly. For more "
"details, see :c:func:`PyUnicode_InternFromString`, which may be used "
"internally to create a key object."
msgstr ""
"Antalet olika *name*-strängar som skickas till denna funktion bör hållas "
"litet, vanligtvis genom att endast använda statiskt allokerade strängar som "
"*name*. För namn som inte är kända vid kompileringstillfället är det bättre "
"att anropa :c:func:`PyUnicode_FromString` och :c:func:`PyObject_SetAttr` "
"direkt. För mer detaljer, se :c:func:`PyUnicode_InternFromString`, som kan "
"användas internt för att skapa ett nyckelobjekt."

msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but \"steals\" a reference to "
"*value*. It can be called with a result of function that returns a new "
"reference without bothering to check its result or even saving it to a "
"variable."
msgstr ""
"Liknar :c:func:`PyModule_AddObjectRef`, men \"stjäl\" en referens till "
"*värde*. Den kan anropas med ett resultat av en funktion som returnerar en "
"ny referens utan att bry sig om att kontrollera resultatet eller ens spara "
"det i en variabel."

msgid ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    goto error;\n"
"}"
msgstr ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    gå till fel;\n"
"}"

msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"Liknar :c:func:`PyModule_AddObjectRef`, men stjäl en referens till *värde* "
"vid framgång (om den returnerar ``0``)."

msgid ""
"The new :c:func:`PyModule_Add` or :c:func:`PyModule_AddObjectRef` functions "
"are recommended, since it is easy to introduce reference leaks by misusing "
"the :c:func:`PyModule_AddObject` function."
msgstr ""
"De nya funktionerna :c:func:`PyModule_Add` eller :c:func:"
"`PyModule_AddObjectRef` rekommenderas, eftersom det är lätt att införa "
"referensläckor genom att missbruka funktionen :c:func:`PyModule_AddObject`."

msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"releases the reference to *value* **on success**."
msgstr ""
"Till skillnad från andra funktioner som stjäl referenser, släpper "
"``PyModule_AddObject()`` bara referensen till *värde* **vid framgång**."

msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_XDECREF` *value* manually on error."
msgstr ""
"Detta innebär att dess returvärde måste kontrolleras, och anropande kod "
"måste :c:func:`Py_XDECREF` *värde* manuellt vid fel."

msgid ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // If 'obj' is not NULL and PyModule_AddObject() failed,\n"
"    // 'obj' strong reference must be deleted with Py_XDECREF().\n"
"    // If 'obj' is NULL, Py_XDECREF() does nothing.\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() stole a reference to obj:\n"
"// Py_XDECREF(obj) is not needed here."
msgstr ""
"PyObject *obj = PyBytes_FromString(värde);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // Om 'obj' inte är NULL och PyModule_AddObject() misslyckades,\n"
"    // måste den starka referensen till 'obj' tas bort med Py_XDECREF().\n"
"    // Om 'obj' är NULL gör Py_XDECREF() ingenting.\n"
"    Py_XDECREF(obj);\n"
"    gå till fel;\n"
"}\n"
"// PyModule_AddObject() stal en referens till obj:\n"
"// Py_XDECREF(obj) behövs inte här."

msgid ":c:func:`PyModule_AddObject` is :term:`soft deprecated`."
msgstr ":c:func:`PyModule_AddObject` är :term:`soft deprecated`."

msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` with an "
"exception set on error, ``0`` on success."
msgstr ""
"Lägg till en heltalskonstant till *modul* som *namn*.  Denna "
"bekvämlighetsfunktion kan användas från modulens initialiseringsfunktion. "
"Returnerar ``-1`` med ett undantag inställt vid fel, ``0`` vid framgång."

msgid ""
"This is a convenience function that calls :c:func:`PyLong_FromLong` and :c:"
"func:`PyModule_AddObjectRef`; see their documentation for details."
msgstr ""
"Detta är en bekvämlighetsfunktion som anropar :c:func:`PyLong_FromLong` och :"
"c:func:`PyModule_AddObjectRef`; se deras dokumentation för detaljer."

msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated. Return ``-1`` with an exception set on error, ``0`` "
"on success."
msgstr ""
"Lägg till en strängkonstant till *modul* som *namn*.  Denna "
"bekvämlighetsfunktion kan användas från modulens initialiseringsfunktion.  "
"Strängen *värde* måste vara ``NULL``-terminerad. Returnerar ``-1`` med en "
"undantagsuppsättning vid fel, ``0`` vid framgång."

msgid ""
"This is a convenience function that calls :c:func:"
"`PyUnicode_InternFromString` and :c:func:`PyModule_AddObjectRef`; see their "
"documentation for details."
msgstr ""
"Detta är en bekvämlighetsfunktion som anropar :c:func:"
"`PyUnicode_InternFromString` och :c:func:`PyModule_AddObjectRef`; se deras "
"dokumentation för detaljer."

msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` "
"with an exception set on error, ``0`` on success."
msgstr ""
"Lägg till en int-konstant i *modul*. Namnet och värdet hämtas från *macro*. "
"Till exempel ``PyModule_AddIntMacro(module, AF_INET)`` lägger till int-"
"konstanten *AF_INET* med värdet *AF_INET* till *modul*. Returnerar ``-1`` "
"med en undantagsuppsättning vid fel, ``0`` vid framgång."

msgid "Add a string constant to *module*."
msgstr "Lägg till en strängkonstant i *modul*."

msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"Lägg till ett typobjekt till *modul*. Typobjektet färdigställs genom att "
"internt anropa :c:func:`PyType_Ready`. Namnet på typobjektet hämtas från den "
"sista komponenten i :c:member:`~PyTypeObject.tp_name` efter punkt. "
"Returnerar ``-1`` med en exception set vid fel, ``0`` vid framgång."

msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes)."
msgstr ""
"Lägg till funktionerna från den ``NULL`` avslutade *functions*-arrayen till "
"*module*. Se :c:type:`PyMethodDef`-dokumentationen för detaljer om enskilda "
"poster (på grund av avsaknaden av ett delat modulnamnrum får \"funktioner\" "
"på modulnivå som implementeras i C vanligtvis modulen som sin första "
"parameter, vilket gör att de liknar instansmetoder i Python-klasser)."

msgid ""
"This function is called automatically when creating a module from "
"``PyModuleDef`` (such as when using :ref:`multi-phase-initialization`, "
"``PyModule_Create``, or ``PyModule_FromDefAndSpec``). Some module authors "
"may prefer defining functions in multiple :c:type:`PyMethodDef` arrays; in "
"that case they should call this function directly."
msgstr ""
"Denna funktion anropas automatiskt när en modul skapas från ``PyModuleDef`` "
"(t.ex. när :ref:`multi-phase-initialization``, ``PyModule_Create`` eller "
"``PyModule_FromDefAndSpec`` används). Vissa modulförfattare kanske föredrar "
"att definiera funktioner i flera :c:type:`PyMethodDef`-arrayer; i så fall "
"bör de anropa denna funktion direkt."

msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef`` (such as when "
"using :ref:`multi-phase-initialization`, ``PyModule_Create``, or "
"``PyModule_FromDefAndSpec``)."
msgstr ""
"Ställ in docstring för *modul* till *docstring*. Denna funktion anropas "
"automatiskt när du skapar en modul från ``PyModuleDef`` (t.ex. när du "
"använder :ref:`multi-phase-initialization`, ``PyModule_Create``, eller "
"``PyModule_FromDefAndSpec``)."

msgid ""
"Indicate that *module* does or does not support running without the global "
"interpreter lock (GIL), using one of the values from :c:macro:`Py_mod_gil`. "
"It must be called during *module*'s initialization function when using :ref:"
"`single-phase-initialization`. If this function is not called during module "
"initialization, the import machinery assumes the module does not support "
"running without the GIL. This function is only available in Python builds "
"configured with :option:`--disable-gil`. Return ``-1`` with an exception set "
"on error, ``0`` on success."
msgstr ""
"Ange att *modul* stöder eller inte stöder körning utan det globala tolklåset "
"(GIL), med hjälp av ett av värdena från :c:macro:`Py_mod_gil`. Den måste "
"anropas under *modul*:s initialiseringsfunktion när :ref:`single-phase-"
"initialization` används. Om denna funktion inte anropas under "
"modulinitialiseringen, antar importmaskineriet att modulen inte stöder "
"körning utan GIL. Denna funktion är endast tillgänglig i Python-byggnader "
"som konfigurerats med :option:`--disable-gil`. Returnerar ``-1`` med en "
"undantagsuppsättning vid fel, ``0`` vid framgång."

msgid "Module lookup (single-phase initialization)"
msgstr "Moduluppslagning (enfasig initialisering)"

msgid ""
"The legacy :ref:`single-phase initialization <single-phase-initialization>` "
"initialization scheme creates singleton modules that can be looked up in the "
"context of the current interpreter. This allows the module object to be "
"retrieved later with only a reference to the module definition."
msgstr ""
"Det äldre initialiseringsschemat :ref:` `single-phase initialization <single-"
"phase-initialization>` skapar singleton-moduler som kan sökas upp i den "
"aktuella tolkens kontext. Detta gör att modulobjektet kan hämtas senare med "
"endast en referens till moduldefinitionen."

msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"Dessa funktioner fungerar inte på moduler som skapats med hjälp av "
"flerfasinitialisering, eftersom flera sådana moduler kan skapas från en enda "
"definition."

msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"Returnerar det modulobjekt som skapades från *def* för den aktuella tolken. "
"Denna metod kräver att modulobjektet har kopplats till tolktillståndet med :"
"c:func:`PyState_AddModule` i förväg. Om motsvarande modulobjekt inte hittas "
"eller inte har kopplats till tolktillståndet ännu, returnerar den ``NULL``."

msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""
"Kopplar modulobjektet som skickas till funktionen till tolkens tillstånd. "
"Detta gör att modulobjektet kan nås via :c:func:`PyState_FindModule`."

msgid "Only effective on modules created using single-phase initialization."
msgstr "Gäller endast för moduler som skapats med enfasinitialisering."

msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module "
"that uses :ref:`single-phase initialization <single-phase-initialization>`, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""
"Python anropar ``PyState_AddModule`` automatiskt efter import av en modul "
"som använder :ref:`single-phase initialization <single-phase-"
"initialization>``, så det är onödigt (men harmlöst) att anropa det från "
"modulens initialiseringskod. Ett explicit anrop behövs endast om modulens "
"egen init-kod därefter anropar ``PyState_FindModule``. Funktionen är "
"huvudsakligen avsedd för implementering av alternativa importmekanismer "
"(antingen genom att anropa den direkt eller genom att hänvisa till dess "
"implementering för detaljer om de nödvändiga tillståndsuppdateringarna)."

msgid ""
"If a module was attached previously using the same *def*, it is replaced by "
"the new *module*."
msgstr ""
"Om en modul har bifogats tidigare med samma *def*, ersätts den av den nya "
"*modulen*."

msgid "The caller must have an :term:`attached thread state`."
msgstr "Den som anropar måste ha en :term:`attached thread state`."

msgid "Return ``-1`` with an exception set on error, ``0`` on success."
msgstr "Returnerar ``-1`` med en exception set vid fel, ``0`` vid framgång."

msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"Tar bort modulobjektet som skapats från *def* från tolkens tillstånd. "
"Returnerar ``-1`` med en undantagsuppsättning vid fel, ``0`` vid framgång."

msgid "object"
msgstr "objekt"

msgid "module"
msgstr "modul"

msgid "ModuleType (in module types)"
msgstr "ModuleType (i modultyper)"

msgid "__name__ (module attribute)"
msgstr "__name__ (attribut för modul)"

msgid "__doc__ (module attribute)"
msgstr "__doc__ (modulattribut)"

msgid "__file__ (module attribute)"
msgstr "__file__ (modulattribut)"

msgid "__package__ (module attribute)"
msgstr "__package__ (modulattribut)"

msgid "__loader__ (module attribute)"
msgstr "__loader__ (modulattribut)"

msgid "__dict__ (module attribute)"
msgstr "__dict__ (modulattribut)"

msgid "SystemError (built-in exception)"
msgstr "SystemError (inbyggt undantag)"
