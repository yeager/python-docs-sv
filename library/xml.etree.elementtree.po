# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ":mod:`!xml.etree.ElementTree` --- XML API för ElementTree"

msgid "**Source code:** :source:`Lib/xml/etree/ElementTree.py`"
msgstr "**Källkod:** :source:`Lib/xml/etree/ElementTree.py`"

msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient "
"API for parsing and creating XML data."
msgstr ""
"Modulen :mod:`xml.etree.ElementTree` implementerar ett enkelt och effektivt "
"API för att analysera och skapa XML-data."

msgid "This module will use a fast implementation whenever available."
msgstr ""
"Denna modul kommer att använda en snabb implementering när så är möjligt."

msgid "The :mod:`!xml.etree.cElementTree` module is deprecated."
msgstr "Modulen :mod:`!xml.etree.cElementTree` är föråldrad."

msgid ""
"If you need to parse untrusted or unauthenticated data, see :ref:`xml-"
"security`."
msgstr ""
"Om du behöver analysera otillförlitliga eller oautentiserade data, se :ref:"
"`xml-security`."

msgid "Tutorial"
msgstr "Handledning"

msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` in "
"short).  The goal is to demonstrate some of the building blocks and basic "
"concepts of the module."
msgstr ""
"Detta är en kort handledning för användning av :mod:`xml.etree.ElementTree` "
"(förkortat ``ET``).  Målet är att demonstrera några av modulens byggstenar "
"och grundläggande begrepp."

msgid "XML tree and elements"
msgstr "XML-träd och element"

msgid ""
"XML is an inherently hierarchical data format, and the most natural way to "
"represent it is with a tree.  ``ET`` has two classes for this purpose - :"
"class:`ElementTree` represents the whole XML document as a tree, and :class:"
"`Element` represents a single node in this tree.  Interactions with the "
"whole document (reading and writing to/from files) are usually done on the :"
"class:`ElementTree` level.  Interactions with a single XML element and its "
"sub-elements are done on the :class:`Element` level."
msgstr ""
"XML är till sin natur ett hierarkiskt dataformat och det mest naturliga "
"sättet att representera det är med ett träd.  ``ET`` har två klasser för "
"detta ändamål - :class:`ElementTree` representerar hela XML-dokumentet som "
"ett träd, och :class:`Element` representerar en enskild nod i detta träd.  "
"Interaktioner med hela dokumentet (läsa och skriva till/från filer) görs "
"vanligtvis på :class:`ElementTree`-nivå.  Interaktioner med ett enskilt XML-"
"element och dess underelement görs på nivån :class:`Element`."

msgid "Parsing XML"
msgstr "Parsning av XML"

msgid ""
"We'll be using the fictive :file:`country_data.xml` XML document as the "
"sample data for this section:"
msgstr ""
"Vi kommer att använda det fiktiva XML-dokumentet :file:`country_data.xml` "
"som exempeldata för detta avsnitt:"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"

msgid "We can import this data by reading from a file::"
msgstr "Vi kan importera dessa data genom att läsa från en fil::"

msgid ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"
msgstr ""
"import xml.etree.ElementTree as ET\n"
"träd = ET.parse('land_data.xml')\n"
"root = träd.getroot()"

msgid "Or directly from a string::"
msgstr "Eller direkt från en sträng::"

msgid "root = ET.fromstring(country_data_as_string)"
msgstr "root = ET.fromstring(land_data_som_sträng)"

msgid ""
":func:`fromstring` parses XML from a string directly into an :class:"
"`Element`, which is the root element of the parsed tree.  Other parsing "
"functions may create an :class:`ElementTree`.  Check the documentation to be "
"sure."
msgstr ""
":func:`fromstring` parsar XML från en sträng direkt till ett :class:"
"`Element`, som är rotelementet i det parsade trädet.  Andra "
"parsingfunktioner kan skapa ett :class:`ElementTree`.  Kontrollera "
"dokumentationen för att vara säker."

msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of attributes::"
msgstr ""
"Som ett :class:`Element` har ``root`` en tagg och en ordlista med attribut::"

msgid ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"
msgstr ""
">>> root.tag\n"
"'data'\n"
">>> rot.attrib\n"
"{}"

msgid "It also has children nodes over which we can iterate::"
msgstr "Den har också underordnade noder som vi kan iterera över::"

msgid ""
">>> for child in root:\n"
"...     print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapore'}\n"
"country {'name': 'Panama'}"
msgstr ""
">>> för barn i rot:\n"
"... print(barn.tag, barn.attrib)\n"
"...\n"
"land {'namn': 'Liechtenstein'}\n"
"land {'namn': 'Singapore'}\n"
"land {namn: \"Panama\"}"

msgid "Children are nested, and we can access specific child nodes by index::"
msgstr ""
"Barnen är nästlade och vi kan komma åt specifika barnnoder genom index::"

msgid ""
">>> root[0][1].text\n"
"'2008'"
msgstr ""
">>> root[0][1].text\n"
"'2008'"

msgid ""
"Not all elements of the XML input will end up as elements of the parsed "
"tree. Currently, this module skips over any XML comments, processing "
"instructions, and document type declarations in the input. Nevertheless, "
"trees built using this module's API rather than parsing from XML text can "
"have comments and processing instructions in them; they will be included "
"when generating XML output. A document type declaration may be accessed by "
"passing a custom :class:`TreeBuilder` instance to the :class:`XMLParser` "
"constructor."
msgstr ""
"Inte alla element i XML-data kommer att hamna som element i det analyserade "
"trädet. För närvarande hoppar den här modulen över alla XML-kommentarer, "
"bearbetningsinstruktioner och dokumenttypsdeklarationer i indata. Träd som "
"byggs upp med hjälp av modulens API i stället för att parsa från XML-text "
"kan dock innehålla kommentarer och bearbetningsinstruktioner; de kommer att "
"inkluderas när XML-utdata genereras. En dokumenttypsdeklaration kan nås "
"genom att skicka en anpassad :class:`TreeBuilder`-instans till :class:"
"`XMLParser`-konstruktören."

msgid "Pull API for non-blocking parsing"
msgstr "Pull API för icke-blockerande parsing"

msgid ""
"Most parsing functions provided by this module require the whole document to "
"be read at once before returning any result.  It is possible to use an :"
"class:`XMLParser` and feed data into it incrementally, but it is a push API "
"that calls methods on a callback target, which is too low-level and "
"inconvenient for most needs.  Sometimes what the user really wants is to be "
"able to parse XML incrementally, without blocking operations, while enjoying "
"the convenience of fully constructed :class:`Element` objects."
msgstr ""
"De flesta parsingfunktioner som tillhandahålls av den här modulen kräver att "
"hela dokumentet läses på en gång innan de returnerar något resultat.  Det är "
"möjligt att använda en :class:`XMLParser` och mata in data i den stegvis, "
"men det är ett push-API som anropar metoder på ett callback-mål, vilket är "
"för låg nivå och obekvämt för de flesta behov.  Ibland vill användaren "
"verkligen kunna analysera XML stegvis, utan att blockera operationer, "
"samtidigt som han eller hon kan njuta av bekvämligheten med helt "
"konstruerade :class:`Element`-objekt."

msgid ""
"The most powerful tool for doing this is :class:`XMLPullParser`.  It does "
"not require a blocking read to obtain the XML data, and is instead fed with "
"data incrementally with :meth:`XMLPullParser.feed` calls.  To get the parsed "
"XML elements, call :meth:`XMLPullParser.read_events`.  Here is an example::"
msgstr ""
"Det mest kraftfulla verktyget för att göra detta är :class:`XMLPullParser`.  "
"Den kräver inte en blockerande läsning för att få XML-data, utan matas "
"istället med data stegvis med :meth:`XMLPullParser.feed`-anrop.  För att "
"hämta de analyserade XML-elementen anropas :meth:`XMLPullParser."
"read_events`.  Här är ett exempel::"

msgid ""
">>> parser = ET.XMLPullParser(['start', 'end'])\n"
">>> parser.feed('<mytag>sometext')\n"
">>> list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
">>> parser.feed(' more text</mytag>')\n"
">>> for event, elem in parser.read_events():\n"
"...     print(event)\n"
"...     print(elem.tag, 'text=', elem.text)\n"
"...\n"
"end\n"
"mytag text= sometext more text"
msgstr ""
"&gt;&gt;&gt; parser = ET.XMLPullParser(['start', 'end'])\n"
"&gt;&gt;&gt; parser.feed('<mytag>sometext')\n"
"&gt;&gt;&gt; list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
"&gt;&gt;&gt; parser.feed('mer text</mytag>')\n"
"&gt;&gt;&gt; for event, elem in parser.read_events():\n"
"... print(händelse)\n"
"... print(elem.tag, 'text=', elem.text)\n"
"...\n"
"slut\n"
"mytag text= sometext mer text"

msgid ""
"The obvious use case is applications that operate in a non-blocking fashion "
"where the XML data is being received from a socket or read incrementally "
"from some storage device.  In such cases, blocking reads are unacceptable."
msgstr ""
"Det uppenbara användningsfallet är applikationer som fungerar på ett icke-"
"blockerande sätt där XML-data tas emot från ett uttag eller läses stegvis "
"från någon lagringsenhet.  I sådana fall är blockerande läsningar "
"oacceptabla."

msgid ""
"Because it's so flexible, :class:`XMLPullParser` can be inconvenient to use "
"for simpler use-cases.  If you don't mind your application blocking on "
"reading XML data but would still like to have incremental parsing "
"capabilities, take a look at :func:`iterparse`.  It can be useful when "
"you're reading a large XML document and don't want to hold it wholly in "
"memory."
msgstr ""
"Eftersom den är så flexibel kan :class:`XMLPullParser` vara obekväm att "
"använda för enklare användningsfall.  Om du inte har något emot att din "
"applikation blockerar läsning av XML-data men ändå vill ha inkrementella "
"parsingfunktioner kan du ta en titt på :func:`iterparse`.  Det kan vara "
"användbart när du läser ett stort XML-dokument och inte vill hålla det helt "
"och hållet i minnet."

msgid ""
"Where *immediate* feedback through events is wanted, calling method :meth:"
"`XMLPullParser.flush` can help reduce delay; please make sure to study the "
"related security notes."
msgstr ""
"Om *omedelbar* återkoppling genom händelser önskas kan anrop av metoden :"
"meth:`XMLPullParser.flush` bidra till att minska fördröjningen; se till att "
"studera de relaterade säkerhetsnoterna."

msgid "Finding interesting elements"
msgstr "Hitta intressanta element"

msgid ""
":class:`Element` has some useful methods that help iterate recursively over "
"all the sub-tree below it (its children, their children, and so on).  For "
"example, :meth:`Element.iter`::"
msgstr ""
":class:`Element` har några användbara metoder som hjälper till att iterera "
"rekursivt över alla underträd under det (dess barn, deras barn, och så "
"vidare).  Till exempel :meth:`Element.iter`::"

msgid ""
">>> for neighbor in root.iter('neighbor'):\n"
"...     print(neighbor.attrib)\n"
"...\n"
"{'name': 'Austria', 'direction': 'E'}\n"
"{'name': 'Switzerland', 'direction': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"
msgstr ""
">>> för granne i rot.iter('granne'):\n"
"... print(granne.attrib)\n"
"...\n"
"{'namn': 'Österrike', 'riktning': 'E'}\n"
"{'name': 'Schweiz', 'riktning': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"

msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the element's "
"text content.  :meth:`Element.get` accesses the element's attributes::"
msgstr ""
":meth:`Element.findall` hittar bara element med en tagg som är direkta barn "
"till det aktuella elementet. :meth:`Element.find` hittar det *första* barnet "
"med en viss tagg, och :attr:`Element.text` ger tillgång till elementets "
"textinnehåll. :meth:`Element.get` ger tillgång till elementets attribut::"

msgid ""
">>> for country in root.findall('country'):\n"
"...     rank = country.find('rank').text\n"
"...     name = country.get('name')\n"
"...     print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"
msgstr ""
">>> for country in root.findall('country'):\n"
"... rank = land.find('rank').text\n"
"... namn = land.hämta('namn')\n"
"... print(namn, rang)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"

msgid ""
"More sophisticated specification of which elements to look for is possible "
"by using :ref:`XPath <elementtree-xpath>`."
msgstr ""
"En mer sofistikerad specifikation av vilka element som ska sökas är möjlig "
"genom att använda :ref:`XPath <elementtree-xpath>`."

msgid "Modifying an XML File"
msgstr "Ändra en XML-fil"

msgid ""
":class:`ElementTree` provides a simple way to build XML documents and write "
"them to files. The :meth:`ElementTree.write` method serves this purpose."
msgstr ""
":class:`ElementTree` ger ett enkelt sätt att bygga XML-dokument och skriva "
"dem till filer. Metoden :meth:`ElementTree.write` tjänar detta syfte."

msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children (for "
"example with :meth:`Element.append`)."
msgstr ""
"När ett :class:`Element`-objekt har skapats kan det manipuleras genom att "
"direkt ändra dess fält (t.ex. :attr:`Element.text`), lägga till och ändra "
"attribut (metoden :meth:`Element.set`) samt lägga till nya barn (t.ex. med :"
"meth:`Element.append`)."

msgid ""
"Let's say we want to add one to each country's rank, and add an ``updated`` "
"attribute to the rank element::"
msgstr ""
"Låt oss säga att vi vill lägga till en till varje lands rankning och lägga "
"till ett ``uppdaterat`` attribut till rank-elementet::"

msgid ""
">>> for rank in root.iter('rank'):\n"
"...     new_rank = int(rank.text) + 1\n"
"...     rank.text = str(new_rank)\n"
"...     rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""
">>> för rank i root.iter('rank'):\n"
"... new_rank = int(rank.text) + 1\n"
"... rank.text = str(ny_rank)\n"
"... rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"

msgid "Our XML now looks like this:"
msgstr "Vår XML ser nu ut så här:"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"

msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want to "
"remove all countries with a rank higher than 50::"
msgstr ""
"Vi kan ta bort element med hjälp av :meth:`Element.remove`.  Låt oss säga "
"att vi vill ta bort alla länder med en rank högre än 50::"

msgid ""
">>> for country in root.findall('country'):\n"
"...     # using root.findall() to avoid removal during traversal\n"
"...     rank = int(country.find('rank').text)\n"
"...     if rank > 50:\n"
"...         root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""
">>> för land i root.findall('land'):\n"
"...     # använder root.findall() för att undvika borttagning under "
"traversal\n"
"... rank = int(land.find('rank').text)\n"
"... om rank > 50:\n"
"... root.remove(land)\n"
"...\n"
">>> tree.write('output.xml')"

msgid ""
"Note that concurrent modification while iterating can lead to problems, just "
"like when iterating and modifying Python lists or dicts. Therefore, the "
"example first collects all matching elements with ``root.findall()``, and "
"only then iterates over the list of matches."
msgstr ""
"Observera att samtidig modifiering under iteration kan leda till problem, "
"precis som när man itererar och modifierar Python-listor eller dicts. Därför "
"samlar exemplet först in alla matchande element med ``root.findall()`` och "
"itererar först därefter över listan med matchningar."

msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"

msgid "Building XML documents"
msgstr "Skapa XML-dokument"

msgid ""
"The :func:`SubElement` function also provides a convenient way to create new "
"sub-elements for a given element::"
msgstr ""
"Funktionen :func:`SubElement` ger också ett bekvämt sätt att skapa nya "
"underelement för ett givet element::"

msgid ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"
msgstr ""
"&gt;&gt;&gt; a = ET.Element('a')\n"
"&gt;&gt;&gt; b = ET.SubElement(a, 'b')\n"
"&gt;&gt;&gt; c = ET.SubElement(a, 'c')\n"
"&gt;&gt;&gt; d = ET.SubElement(c, 'd')\n"
"&gt;&gt;&gt; ET.dump(a)\n"
"<a><b /><c><d /></c></a>"

msgid "Parsing XML with Namespaces"
msgstr "Parsning av XML med namnrymder"

msgid ""
"If the XML input has `namespaces <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, tags and attributes with prefixes in the form ``prefix:"
"sometag`` get expanded to ``{uri}sometag`` where the *prefix* is replaced by "
"the full *URI*. Also, if there is a `default namespace <https://www.w3.org/"
"TR/xml-names/#defaulting>`__, that full URI gets prepended to all of the non-"
"prefixed tags."
msgstr ""
"Om XML-inmatningen har `namnrymder <https://en.wikipedia.org/wiki/"
"XML_namespace>`__ expanderas taggar och attribut med prefix i formen "
"``prefix:sometag`` till ``{uri}sometag`` där *prefixet* ersätts av hela "
"*URI*. Om det finns ett `default namespace <https://www.w3.org/TR/xml-names/"
"#defaulting>`__ blir dessutom den fullständiga URI:n prefixad till alla icke-"
"prefixerade taggar."

msgid ""
"Here is an XML example that incorporates two namespaces, one with the prefix "
"\"fictional\" and the other serving as the default namespace:"
msgstr ""
"Här är ett XML-exempel som innehåller två namnrymder, en med prefixet "
"\"fictional\" och en som fungerar som standardnamnrymd:"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Commander Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Kommendörkapten Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"

msgid ""
"One way to search and explore this XML example is to manually add the URI to "
"every tag or attribute in the xpath of a :meth:`~Element.find` or :meth:"
"`~Element.findall`::"
msgstr ""
"Ett sätt att söka och utforska detta XML-exempel är att manuellt lägga till "
"URI:n till varje tagg eller attribut i xpath för en :meth:`~Element.find` "
"eller :meth:`~Element.findall`::"

msgid ""
"root = fromstring(xml_text)\n"
"for actor in root.findall('{http://people.example.com}actor'):\n"
"    name = actor.find('{http://people.example.com}name')\n"
"    print(name.text)\n"
"    for char in actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"
msgstr ""
"root = från sträng(xml_text)\n"
"för skådespelare i root.findall('{http://people.example.com}skådespelare'):\n"
"    namn = skådespelare.hitta('{http://people.example.com}namn')\n"
"    print(namn.text)\n"
"    for char in actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"

msgid ""
"A better way to search the namespaced XML example is to create a dictionary "
"with your own prefixes and use those in the search functions::"
msgstr ""
"Ett bättre sätt att söka i namespaced XML-exemplet är att skapa en ordbok "
"med dina egna prefix och använda dem i sökfunktionerna::"

msgid ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'role': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('real_person:name', ns)\n"
"    print(name.text)\n"
"    for char in actor.findall('role:character', ns):\n"
"        print(' |-->', char.text)"
msgstr ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'roll': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('verklig_person:namn', ns)\n"
"    print(namn.text)\n"
"    för char i actor.findall('roll:karaktär', ns):\n"
"        print(' |-->', char.text)"

msgid "These two approaches both output::"
msgstr "Dessa två metoder ger båda ut::"

msgid ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"
msgstr ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"

msgid "XPath support"
msgstr "Stöd för XPath"

msgid ""
"This module provides limited support for `XPath expressions <https://www.w3."
"org/TR/xpath>`_ for locating elements in a tree.  The goal is to support a "
"small subset of the abbreviated syntax; a full XPath engine is outside the "
"scope of the module."
msgstr ""
"Den här modulen ger begränsat stöd för `XPath-uttryck <https://www.w3.org/TR/"
"xpath>`_ för att hitta element i ett träd.  Målet är att stödja en liten "
"delmängd av den förkortade syntaxen; en fullständig XPath-motor ligger "
"utanför modulens omfattning."

msgid "Example"
msgstr "Exempel"

msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the "
"module.  We'll be using the ``countrydata`` XML document from the :ref:"
"`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""
"Här är ett exempel som demonstrerar några av XPath-funktionerna i modulen.  "
"Vi kommer att använda XML-dokumentet ``countrydata`` från :ref:`Parsing XML "
"<elementtree-parsing-xml>` avsnittet::"

msgid ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Top-level elements\n"
"root.findall(\".\")\n"
"\n"
"# All 'neighbor' grand-children of 'country' children of the top-level\n"
"# elements\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nodes with name='Singapore' that have a 'year' child\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 'year' nodes that are children of nodes with name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# All 'neighbor' nodes that are the second child of their parent\n"
"root.findall(\".//neighbor[2]\")"
msgstr ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Top-level elements\n"
"root.findall(\".\")\n"
"\n"
"# All 'neighbor' grand-children of 'country' children of the top-level\n"
"# elements\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nodes with name='Singapore' that have a 'year' child\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 'year' nodes that are children of nodes with name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# All 'neighbor' nodes that are the second child of their parent\n"
"root.findall(\".//neighbor[2]\")"

msgid ""
"For XML with namespaces, use the usual qualified ``{namespace}tag`` "
"notation::"
msgstr ""
"För XML med namnrymder används den vanliga kvalificerade ``{namespace}tag``-"
"notationen::"

msgid ""
"# All dublin-core \"title\" tags in the document\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"
msgstr ""
"# Alla dublin-core \"title\"-taggar i dokumentet\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"

msgid "Supported XPath syntax"
msgstr "XPath-syntax som stöds"

msgid "Syntax"
msgstr "Syntax"

msgid "Meaning"
msgstr "Betydelse"

msgid "``tag``"
msgstr "``tag``"

msgid ""
"Selects all child elements with the given tag. For example, ``spam`` selects "
"all child elements named ``spam``, and ``spam/egg`` selects all "
"grandchildren named ``egg`` in all children named ``spam``.  ``{namespace}"
"*`` selects all tags in the given namespace, ``{*}spam`` selects tags named "
"``spam`` in any (or no) namespace, and ``{}*`` only selects tags that are "
"not in a namespace."
msgstr ""
"Väljer alla underordnade element med den angivna taggen. Exempelvis väljer "
"``spam`` alla underordnade element med namnet ``spam``, och ``spam/egg`` "
"väljer alla barnbarn med namnet ``egg`` i alla underordnade element med "
"namnet ``spam``.  ``{namespace}*`` väljer alla taggar i den angivna "
"namnrymden, ``{*}spam`` väljer taggar med namnet ``spam`` i vilken (eller "
"ingen) namnrymd som helst och ``{}*`` väljer bara taggar som inte finns i "
"någon namnrymd."

msgid "Support for star-wildcards was added."
msgstr "Stöd för stjärn-wildcards har lagts till."

msgid "``*``"
msgstr "``*``"

msgid ""
"Selects all child elements, including comments and processing instructions.  "
"For example, ``*/egg`` selects all grandchildren named ``egg``."
msgstr ""
"Väljer alla underordnade element, inklusive kommentarer och "
"bearbetningsinstruktioner.  Exempel: ``*/egg`` väljer alla barnbarn med "
"namnet ``egg``."

msgid "``.``"
msgstr "``.``"

msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr ""
"Väljer den aktuella noden.  Detta är mest användbart i början av sökvägen "
"för att ange att det är en relativ sökväg."

msgid "``//``"
msgstr "``//``"

msgid ""
"Selects all subelements, on all levels beneath the current  element.  For "
"example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr ""
"Väljer alla underelement på alla nivåer under det aktuella elementet.  Till "
"exempel väljer ``.//egg`` alla ``egg``-element i hela trädet."

msgid "``..``"
msgstr "``..``"

msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to reach "
"the ancestors of the start element (the element ``find`` was called on)."
msgstr ""
"Väljer det överordnade elementet.  Returnerar ``None`` om sökvägen försöker "
"nå förfäderna till startelementet (det element som ``find`` anropades på)."

msgid "``[@attrib]``"
msgstr "``[@attrib]``"

msgid "Selects all elements that have the given attribute."
msgstr "Väljer alla element som har det angivna attributet."

msgid "``[@attrib='value']``"
msgstr "``[@attrib='värde']``"

msgid ""
"Selects all elements for which the given attribute has the given value.  The "
"value cannot contain quotes."
msgstr ""
"Väljer alla element för vilka det angivna attributet har det angivna "
"värdet.  Värdet kan inte innehålla citattecken."

msgid "``[@attrib!='value']``"
msgstr "``[@attrib!='värde']``"

msgid ""
"Selects all elements for which the given attribute does not have the given "
"value. The value cannot contain quotes."
msgstr ""
"Markerar alla element för vilka det angivna attributet inte har det angivna "
"värdet. Värdet får inte innehålla citattecken."

msgid "``[tag]``"
msgstr "``[tagg]```"

msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr ""
"Väljer alla element som har ett barn med namnet ``tag``.  Endast omedelbara "
"barn stöds."

msgid "``[.='text']``"
msgstr "``[.='text']``"

msgid ""
"Selects all elements whose complete text content, including descendants, "
"equals the given ``text``."
msgstr ""
"Väljer alla element vars fullständiga textinnehåll, inklusive ättlingar, är "
"lika med den angivna ``texten``."

msgid "``[.!='text']``"
msgstr "``[.!='text']``"

msgid ""
"Selects all elements whose complete text content, including descendants, "
"does not equal the given ``text``."
msgstr ""
"Väljer alla element vars fullständiga textinnehåll, inklusive ättlingar, "
"inte är lika med den angivna ``texten``."

msgid "``[tag='text']``"
msgstr "``[tag='text']``"

msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, equals the given ``text``."
msgstr ""
"Väljer alla element som har ett barn med namnet ``tag`` vars fullständiga "
"textinnehåll, inklusive ättlingar, är lika med den angivna ``texten``."

msgid "``[tag!='text']``"
msgstr "``[tag!='text']``"

msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, does not equal the given ``text``."
msgstr ""
"Väljer alla element som har ett barn med namnet ``tag`` vars fullständiga "
"textinnehåll, inklusive ättlingar, inte motsvarar den angivna ``texten``."

msgid "``[position]``"
msgstr "``[position]```"

msgid ""
"Selects all elements that are located at the given position.  The position "
"can be either an integer (1 is the first position), the expression "
"``last()`` (for the last position), or a position relative to the last "
"position (e.g. ``last()-1``)."
msgstr ""
"Väljer alla element som befinner sig på den angivna positionen.  Positionen "
"kan vara antingen ett heltal (1 är den första positionen), uttrycket "
"``last()`` (för den sista positionen) eller en position relativt den sista "
"positionen (t.ex. ``last()-1``)."

msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag "
"name, an asterisk, or another predicate.  ``position`` predicates must be "
"preceded by a tag name."
msgstr ""
"Predikat (uttryck inom hakparentes) måste föregås av ett taggnamn, en "
"asterisk eller ett annat predikat.  ``position``-predikaten måste föregås av "
"ett taggnamn."

msgid "Reference"
msgstr "Referens"

msgid "Functions"
msgstr "Funktioner"

msgid "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformation function."
msgstr ""
"`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformationsfunktion."

msgid ""
"Canonicalization is a way to normalise XML output in a way that allows byte-"
"by-byte comparisons and digital signatures.  It reduces the freedom that XML "
"serializers have and instead generates a more constrained XML "
"representation.  The main restrictions regard the placement of namespace "
"declarations, the ordering of attributes, and ignorable whitespace."
msgstr ""
"Kanonisering är ett sätt att normalisera XML-utdata på ett sätt som "
"möjliggör byte-för-byte-jämförelser och digitala signaturer.  Det minskar "
"den frihet som XML-serialisatorer har och genererar i stället en mer "
"begränsad XML-representation.  De viktigaste begränsningarna gäller "
"placeringen av namnrymdsdeklarationer, ordningsföljden för attribut och "
"obetydliga blanksteg."

msgid ""
"This function takes an XML data string (*xml_data*) or a file path or file-"
"like object (*from_file*) as input, converts it to the canonical form, and "
"writes it out using the *out* file(-like) object, if provided, or returns it "
"as a text string if not.  The output file receives text, not bytes.  It "
"should therefore be opened in text mode with ``utf-8`` encoding."
msgstr ""
"Denna funktion tar en XML-datasträng (*xml_data*) eller en filsökväg eller "
"ett filliknande objekt (*from_file*) som indata, konverterar den till den "
"kanoniska formen och skriver ut den med hjälp av *out* fil(-liknande) "
"objekt, om det tillhandahålls, eller returnerar den som en textsträng om så "
"inte är fallet.  Utdatafilen tar emot text, inte bytes.  Den bör därför "
"öppnas i textläge med kodningen ``utf-8``."

msgid "Typical uses::"
msgstr "Typiska användningsområden::"

msgid ""
"xml_data = \"<root>...</root>\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"
msgstr ""
"xml_data = \".<root>.</root>.\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"med open(\"c14n_output.xml\", mode='w', encoding='utf-8') som out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"med open(\"c14n_output.xml\", mode='w', encoding='utf-8') som out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"

msgid "The configuration *options* are as follows:"
msgstr "Konfigurationsalternativen* är följande:"

msgid "*with_comments*: set to true to include comments (default: false)"
msgstr ""
"*with_comments*: inställd på true för att inkludera kommentarer (standard: "
"false)"

msgid ""
"*strip_text*: set to true to strip whitespace before and after text content"
msgstr ""
"*strip_text*: satt till true för att ta bort blanksteg före och efter "
"textinnehåll"

msgid "(default: false)"
msgstr "(standard: false)"

msgid ""
"*rewrite_prefixes*: set to true to replace namespace prefixes by "
"\"n{number}\""
msgstr ""
"*rewrite_prefixes*: satt till true för att ersätta namnrymdsprefix med "
"\"n{number}\""

msgid "*qname_aware_tags*: a set of qname aware tag names in which prefixes"
msgstr ""
"*qname_aware_tags*: en uppsättning taggnamn som är medvetna om qname och där "
"prefix"

msgid "should be replaced in text content (default: empty)"
msgstr "ska ersättas i textinnehåll (standard: tom)"

msgid ""
"*qname_aware_attrs*: a set of qname aware attribute names in which prefixes"
msgstr ""
"*qname_aware_attrs*: en uppsättning qname aware-attributnamn där prefix"

msgid "*exclude_attrs*: a set of attribute names that should not be serialised"
msgstr "*exclude_attrs*: en uppsättning attributnamn som inte ska serialiseras"

msgid "*exclude_tags*: a set of tag names that should not be serialised"
msgstr "*exclude_tags*: en uppsättning taggnamn som inte ska serialiseras"

msgid ""
"In the option list above, \"a set\" refers to any collection or iterable of "
"strings, no ordering is expected."
msgstr ""
"I alternativlistan ovan hänvisar \"en uppsättning\" till en samling eller "
"iterabel av strängar, ingen ordning förväntas."

msgid ""
"Comment element factory.  This factory function creates a special element "
"that will be serialized as an XML comment by the standard serializer.  The "
"comment string can be either a bytestring or a Unicode string.  *text* is a "
"string containing the comment string.  Returns an element instance "
"representing a comment."
msgstr ""
"Fabrik för kommentarselement.  Denna fabriksfunktion skapar ett speciellt "
"element som kommer att serialiseras som en XML-kommentar av "
"standardserialisatorn.  Kommentarssträngen kan vara antingen en bytestring "
"eller en Unicode-sträng.  *text* är en sträng som innehåller "
"kommentarssträngen.  Returnerar en elementinstans som representerar en "
"kommentar."

msgid ""
"Note that :class:`XMLParser` skips over comments in the input instead of "
"creating comment objects for them. An :class:`ElementTree` will only contain "
"comment nodes if they have been inserted into to the tree using one of the :"
"class:`Element` methods."
msgstr ""
"Observera att :class:`XMLParser` hoppar över kommentarer i indata istället "
"för att skapa kommentarsobjekt för dem. Ett :class:`ElementTree` kommer "
"endast att innehålla kommentarsnoder om de har infogats i trädet med hjälp "
"av någon av :class:`Element` metoderna."

msgid ""
"Writes an element tree or element structure to sys.stdout.  This function "
"should be used for debugging only."
msgstr ""
"Skriver ett elementträd eller en elementstruktur till sys.stdout.  Denna "
"funktion bör endast användas för felsökning."

msgid ""
"The exact output format is implementation dependent.  In this version, it's "
"written as an ordinary XML file."
msgstr ""
"Det exakta utdataformatet är beroende av implementeringen.  I den här "
"versionen skrivs den som en vanlig XML-fil."

msgid "*elem* is an element tree or an individual element."
msgstr "*elem* är ett elementträd eller ett enskilt element."

msgid ""
"The :func:`dump` function now preserves the attribute order specified by the "
"user."
msgstr ""
"Funktionen :func:`dump` bevarar nu den attributordning som anges av "
"användaren."

msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  *text* "
"is a string containing XML data.  *parser* is an optional parser instance. "
"If not given, the standard :class:`XMLParser` parser is used. Returns an :"
"class:`Element` instance."
msgstr ""
"Parsar ett XML-avsnitt från en strängkonstant.  Samma som :func:`XML`.  "
"*text* är en sträng som innehåller XML-data.  *parser* är en valfri parser-"
"instans. Om den inte anges används standardparsern :class:`XMLParser`. "
"Returnerar en :class:`Element`-instans."

msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* is a "
"list or other sequence containing XML data fragments.  *parser* is an "
"optional parser instance.  If not given, the standard :class:`XMLParser` "
"parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Parsar ett XML-dokument från en sekvens av strängfragment.  *sequence* är en "
"lista eller annan sekvens som innehåller XML-datafragment.  *parser* är en "
"valfri parser-instans.  Om den inte anges används standardparsern :class:"
"`XMLParser`.  Returnerar en :class:`Element`-instans."

msgid ""
"Appends whitespace to the subtree to indent the tree visually. This can be "
"used to generate pretty-printed XML output. *tree* can be an Element or "
"ElementTree.  *space* is the whitespace string that will be inserted for "
"each indentation level, two space characters by default.  For indenting "
"partial subtrees inside of an already indented tree, pass the initial "
"indentation level as *level*."
msgstr ""
"Lägger till blanksteg i underträdet för att trädet ska bli visuellt "
"indraget. Detta kan användas för att generera vackert tryckt XML-utdata. "
"*tree* kan vara ett Element eller ElementTree.  *space* är den "
"blankstegsträng som ska infogas för varje indragningsnivå, två "
"blankstegstecken som standard.  För indragning av partiella subträd inuti "
"ett redan indraget träd, skicka den initiala indragningsnivån som *level*."

msgid ""
"Check if an object appears to be a valid element object.  *element* is an "
"element instance.  Return ``True`` if this is an element object."
msgstr ""
"Kontrollera om ett objekt ser ut att vara ett giltigt elementobjekt.  "
"*element* är en elementinstans.  Returnerar ``True`` om detta är ett element-"
"objekt."

msgid ""
"Parses an XML section into an element tree incrementally, and reports what's "
"going on to the user.  *source* is a filename or :term:`file object` "
"containing XML data.  *events* is a sequence of events to report back.  The "
"supported events are the strings ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-ns\"`` (the \"ns\" "
"events are used to get detailed namespace information).  If *events* is "
"omitted, only ``\"end\"`` events are reported. *parser* is an optional "
"parser instance.  If not given, the standard :class:`XMLParser` parser is "
"used.  *parser* must be a subclass of :class:`XMLParser` and can only use "
"the default :class:`TreeBuilder` as a target. Returns an :term:`iterator` "
"providing ``(event, elem)`` pairs; it has a ``root`` attribute that "
"references the root element of the resulting XML tree once *source* is fully "
"read. The iterator has the :meth:`!close` method that closes the internal "
"file object if *source* is a filename."
msgstr ""
"Parsar ett XML-avsnitt till ett elementträd stegvis och rapporterar vad som "
"händer till användaren.  *source* är ett filnamn eller :term:`filobjekt` som "
"innehåller XML-data.  *events* är en sekvens av händelser som ska "
"rapporteras tillbaka.  De händelser som stöds är strängarna ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` och ``\"end-"
"ns\"`` (händelserna \"ns\" används för att få detaljerad information om "
"namnrymden).  Om *events* utelämnas rapporteras endast ``\"end\"``-"
"händelser. *parser* är en valfri parser-instans.  Om den inte anges används "
"standardparsern :class:`XMLParser`.  *parser* måste vara en subklass av :"
"class:`XMLParser` och kan bara använda standard :class:`TreeBuilder` som "
"mål. Returnerar en :term:`iterator` som tillhandahåller ``(event, elem)``-"
"par; den har ett ``root``-attribut som refererar till rotelementet i det "
"resulterande XML-trädet när *källan* är helt läst. Iteratorn har metoden :"
"meth:`!close` som stänger det interna filobjektet om *källan* är ett filnamn."

msgid ""
"Note that while :func:`iterparse` builds the tree incrementally, it issues "
"blocking reads on *source* (or the file it names).  As such, it's unsuitable "
"for applications where blocking reads can't be made.  For fully non-blocking "
"parsing, see :class:`XMLPullParser`."
msgstr ""
"Observera att medan :func:`iterparse` bygger trädet stegvis, gör den "
"blockerande läsningar på *källan* (eller filen som den namnger).  Därför är "
"den olämplig för applikationer där blockerande läsningar inte kan göras.  "
"För helt icke-blockerande parsing, se :class:`XMLPullParser`."

msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of a "
"starting tag when it emits a \"start\" event, so the attributes are defined, "
"but the contents of the text and tail attributes are undefined at that "
"point.  The same applies to the element children; they may or may not be "
"present."
msgstr ""
":func:`iterparse` garanterar bara att den har sett tecknet \">\" i en "
"starttagg när den avger en \"start\"-händelse, så attributen är definierade, "
"men innehållet i text- och tail-attributen är odefinierat vid den "
"tidpunkten.  Detsamma gäller för elementets barn; de kan vara närvarande "
"eller inte."

msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr ""
"Om du behöver ett helt fyllt element ska du leta efter \"end\"-händelser i "
"stället."

msgid "The *parser* argument."
msgstr "Argumentet *parser*."

msgid "The ``comment`` and ``pi`` events were added."
msgstr "Händelserna ``comment`` och ``pi`` har lagts till."

msgid "Added the :meth:`!close` method."
msgstr "Lagt till metoden :meth:`!close`."

msgid ""
"Parses an XML section into an element tree.  *source* is a filename or file "
"object containing XML data.  *parser* is an optional parser instance.  If "
"not given, the standard :class:`XMLParser` parser is used.  Returns an :"
"class:`ElementTree` instance."
msgstr ""
"Parsar ett XML-avsnitt till ett elementträd.  *source* är ett filnamn eller "
"ett filobjekt som innehåller XML-data.  *parser* är en valfri parser-"
"instans.  Om den inte anges används standardparsern :class:`XMLParser`.  "
"Returnerar en :class:`ElementTree`-instans."

msgid ""
"PI element factory.  This factory function creates a special element that "
"will be serialized as an XML processing instruction.  *target* is a string "
"containing the PI target.  *text* is a string containing the PI contents, if "
"given.  Returns an element instance, representing a processing instruction."
msgstr ""
"Fabrik för PI-element.  Denna fabriksfunktion skapar ett speciellt element "
"som kommer att serialiseras som en XML-bearbetningsinstruktion.  *target* är "
"en sträng som innehåller PI-målet.  *text* är en sträng som innehåller PI-"
"innehållet, om det anges.  Returnerar en elementinstans som representerar en "
"bearbetningsinstruktion."

msgid ""
"Note that :class:`XMLParser` skips over processing instructions in the input "
"instead of creating PI objects for them. An :class:`ElementTree` will only "
"contain processing instruction nodes if they have been inserted into to the "
"tree using one of the :class:`Element` methods."
msgstr ""
"Observera att :class:`XMLParser` hoppar över bearbetningsinstruktioner i "
"indata istället för att skapa PI-objekt för dem. Ett :class:`ElementTree` "
"kommer endast att innehålla noder med bearbetningsinstruktioner om de har "
"infogats i trädet med hjälp av en av :class:`Element` metoderna."

msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed. "
"*prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if at "
"all possible."
msgstr ""
"Registrerar ett namnrymdsprefix.  Registret är globalt och alla befintliga "
"mappningar för antingen det angivna prefixet eller namnrymds-URI:n kommer "
"att tas bort. *prefix* är ett namnrymdsprefix.  *uri* är en namnrymds-uri.  "
"Taggar och attribut i denna namnrymd kommer att serialiseras med det angivna "
"prefixet, om det är möjligt."

msgid ""
"Subelement factory.  This function creates an element instance, and appends "
"it to an existing element."
msgstr ""
"Fabrik för underelement.  Denna funktion skapar en elementinstans och lägger "
"till den till ett befintligt element."

msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* is "
"the subelement name.  *attrib* is an optional dictionary, containing element "
"attributes.  *extra* contains additional attributes, given as keyword "
"arguments.  Returns an element instance."
msgstr ""
"Elementnamn, attributnamn och attributvärden kan vara antingen bytesträngar "
"eller Unicode-strängar.  *parent* är det överordnade elementet.  *tag* är "
"namnet på underelementet.  *attrib* är en valfri ordbok som innehåller "
"elementattribut.  *extra* innehåller ytterligare attribut, som anges som "
"nyckelordsargument.  Returnerar en elementinstans."

msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns an (optionally) encoded string containing the XML data."
msgstr ""
"Skapar en strängrepresentation av ett XML-element, inklusive alla "
"underelement.  *element* är en instans av :class:`Element`.  *encoding* [1]_ "
"är kodningen för utdata (standard är US-ASCII).  Använd "
"``encoding=\"unicode\"`` för att generera en Unicode-sträng (annars "
"genereras en bytestring).  *method* är antingen ``\"xml\"``, ``\"html\"`` "
"eller ``\"text\"`` (standard är ``\"xml\"``). *xml_declaration*, "
"*default_namespace* och *short_empty_elements* har samma betydelse som i :"
"meth:`ElementTree.write`. Returnerar en (valfritt) kodad sträng som "
"innehåller XML-data."

msgid "Added the *short_empty_elements* parameter."
msgstr "Parametern *short_empty_elements* har lagts till."

msgid "Added the *xml_declaration* and *default_namespace* parameters."
msgstr "Parametrarna *xml_declaration* och *default_namespace* har lagts till."

msgid ""
"The :func:`tostring` function now preserves the attribute order specified by "
"the user."
msgstr ""
"Funktionen :func:`tostring` bevarar nu den attributordning som anges av "
"användaren."

msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns a list of (optionally) encoded strings containing the XML data. It "
"does not guarantee any specific sequence, except that ``b\"\"."
"join(tostringlist(element)) == tostring(element)``."
msgstr ""
"Skapar en strängrepresentation av ett XML-element, inklusive alla "
"underelement.  *element* är en instans av :class:`Element`.  *encoding* [1]_ "
"är kodningen för utdata (standard är US-ASCII).  Använd "
"``encoding=\"unicode\"`` för att generera en Unicode-sträng (annars "
"genereras en bytestring).  *method* är antingen ``\"xml\"``, ``\"html\"`` "
"eller ``\"text\"`` (standard är ``\"xml\"``). *xml_declaration*, "
"*default_namespace* och *short_empty_elements* har samma betydelse som i :"
"meth:`ElementTree.write`. Returnerar en lista med (valfritt) kodade strängar "
"som innehåller XML-data. Den garanterar inte någon specifik sekvens, förutom "
"att ``b\"\".join(tostringlist(element)) == tostring(element)``."

msgid ""
"The :func:`tostringlist` function now preserves the attribute order "
"specified by the user."
msgstr ""
"Funktionen :func:`tostringlist` bevarar nu den attributordning som anges av "
"användaren."

msgid ""
"Parses an XML section from a string constant.  This function can be used to "
"embed \"XML literals\" in Python code.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Parsar ett XML-avsnitt från en strängkonstant.  Denna funktion kan användas "
"för att bädda in \"XML-literaler\" i Python-kod.  *text* är en sträng som "
"innehåller XML-data.  *parser* är en valfri parser-instans.  Om den inte "
"anges används standardparsern :class:`XMLParser`.  Returnerar en :class:"
"`Element`-instans."

msgid ""
"Parses an XML section from a string constant, and also returns a dictionary "
"which maps from element id:s to elements.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns a tuple containing an :class:"
"`Element` instance and a dictionary."
msgstr ""
"Parsar ett XML-avsnitt från en strängkonstant och returnerar också en ordbok "
"som mappar från element-id:n till element.  *text* är en sträng som "
"innehåller XML-data.  *parser* är en valfri parser-instans.  Om den inte "
"anges används standardparsern :class:`XMLParser`.  Returnerar en tupel som "
"innehåller en :class:`Element`-instans och en ordbok."

msgid "XInclude support"
msgstr "XInkludera stöd"

msgid ""
"This module provides limited support for `XInclude directives <https://www."
"w3.org/TR/xinclude/>`_, via the :mod:`xml.etree.ElementInclude` helper "
"module.  This module can be used to insert subtrees and text strings into "
"element trees, based on information in the tree."
msgstr ""
"Den här modulen ger begränsat stöd för `XInclude-direktiv <https://www.w3."
"org/TR/xinclude/>`_, via hjälpmodulen :mod:`xml.etree.ElementInclude`.  Den "
"här modulen kan användas för att infoga delträd och textsträngar i "
"elementträd, baserat på information i trädet."

msgid ""
"Here's an example that demonstrates use of the XInclude module. To include "
"an XML document in the current document, use the ``{http://www.w3.org/2001/"
"XInclude}include`` element and set the **parse** attribute to ``\"xml\"``, "
"and use the **href** attribute to specify the document to include."
msgstr ""
"Här följer ett exempel som visar hur modulen XInclude används. För att "
"inkludera ett XML-dokument i det aktuella dokumentet, använd elementet "
"``{http://www.w3.org/2001/XInclude}include`` och sätt attributet **parse** "
"till ``\"xml\"``, och använd attributet **href** för att ange dokumentet som "
"ska inkluderas."

msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"

msgid ""
"By default, the **href** attribute is treated as a file name. You can use "
"custom loaders to override this behaviour. Also note that the standard "
"helper does not support XPointer syntax."
msgstr ""
"Som standard behandlas attributet **href** som ett filnamn. Du kan använda "
"anpassade laddare för att åsidosätta detta beteende. Observera också att "
"standardhjälpen inte stöder XPointer-syntax."

msgid ""
"To process this file, load it as usual, and pass the root element to the :"
"mod:`xml.etree.ElementTree` module:"
msgstr ""
"För att bearbeta den här filen laddar du den som vanligt och skickar "
"rotelementet till modulen :mod:`xml.etree.ElementTree`:"

msgid ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"
msgstr ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"

msgid ""
"The ElementInclude module replaces the ``{http://www.w3.org/2001/XInclude}"
"include`` element with the root element from the **source.xml** document. "
"The result might look something like this:"
msgstr ""
"ElementInclude-modulen ersätter elementet ``{http://www.w3.org/2001/XInclude}"
"include`` med rotelementet från dokumentet **source.xml**. Resultatet kan se "
"ut ungefär så här:"

msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>This is a paragraph.</para>\n"
"</document>"
msgstr ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>Detta är ett stycke.</para>\n"
"</document>"

msgid ""
"If the **parse** attribute is omitted, it defaults to \"xml\". The href "
"attribute is required."
msgstr ""
"Om attributet **parse** utelämnas är standardvärdet \"xml\". Attributet href "
"är obligatoriskt."

msgid ""
"To include a text document, use the ``{http://www.w3.org/2001/XInclude}"
"include`` element, and set the **parse** attribute to \"text\":"
msgstr ""
"Om du vill inkludera ett textdokument använder du elementet ``{http://www.w3."
"org/2001/XInclude}include`` och sätter attributet **parse** till \"text\":"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"

msgid "The result might look something like:"
msgstr "Resultatet kan se ut ungefär så här:"

msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) 2003.\n"
"</document>"
msgstr ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Upphovsrätt (c) 2003.\n"
"</document>"

msgid ""
"Default loader. This default loader reads an included resource from disk. "
"*href* is a URL.  *parse* is for parse mode either \"xml\" or \"text\". "
"*encoding* is an optional text encoding.  If not given, encoding is "
"``utf-8``. Returns the expanded resource. If the parse mode is ``\"xml\"``, "
"this is an :class:`~xml.etree.ElementTree.Element` instance. If the parse "
"mode is ``\"text\"``, this is a string. If the loader fails, it can return "
"``None`` or raise an exception."
msgstr ""
"Standardladdare. Denna standardladdare läser en inkluderad resurs från "
"disken. *href* är en URL.  *parse* är för parse-läge antingen \"xml\" eller "
"\"text\". *encoding* är en valfri textkodning.  Om den inte anges är "
"kodningen ``utf-8``. Returnerar den expanderade resursen. Om analysläget är "
"``\"xml\"``, är detta en :class:`~xml.etree.ElementTree.Element`-instans. Om "
"tolkningsläget är ``\"text\"`` är detta en sträng. Om laddaren misslyckas "
"kan den returnera ``None`` eller skapa ett undantag."

msgid ""
"This function expands XInclude directives in-place in tree pointed by "
"*elem*. *elem* is either the root :class:`~xml.etree.ElementTree.Element` or "
"an :class:`~xml.etree.ElementTree.ElementTree` instance to find such "
"element. *loader* is an optional resource loader.  If omitted, it defaults "
"to :func:`default_loader`. If given, it should be a callable that implements "
"the same interface as :func:`default_loader`.  *base_url* is base URL of the "
"original file, to resolve relative include file references.  *max_depth* is "
"the maximum number of recursive inclusions.  Limited to reduce the risk of "
"malicious content explosion. Pass ``None`` to disable the limitation."
msgstr ""
"Denna funktion expanderar XInclude-direktiv på plats i trädet som pekas ut "
"av *elem*. *elem* är antingen roten :class:`~xml.etree.ElementTree.Element` "
"eller en :class:`~xml.etree.ElementTree.ElementTree`-instans för att hitta "
"ett sådant element. *loader* är en valfri resursladdare.  Om den utelämnas "
"är standardvärdet :func:`default_loader`. Om den anges bör den vara en "
"anropsbar som implementerar samma gränssnitt som :func:`default_loader`.  "
"*base_url* är originalfilens bas-URL för att lösa relativa referenser till "
"include-filer.  *max_depth* är det maximala antalet rekursiva "
"inkluderingar.  Begränsat för att minska risken för explosion av skadligt "
"innehåll. Ange ``None`` för att inaktivera begränsningen."

msgid "Added the *base_url* and *max_depth* parameters."
msgstr "Parametrarna *base_url* och *max_depth* har lagts till."

msgid "Element Objects"
msgstr "Element Objects"

msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr ""
"Klassen Element.  Denna klass definierar Element-gränssnittet och "
"tillhandahåller en referensimplementering av detta gränssnitt."

msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is an "
"optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""
"Elementnamn, attributnamn och attributvärden kan vara antingen bytesträngar "
"eller Unicode-strängar.  *tag* är elementets namn.  *attrib* är en valfri "
"ordbok som innehåller elementattribut.  *extra* innehåller ytterligare "
"attribut, som anges som nyckelordsargument."

msgid ""
"A string identifying what kind of data this element represents (the element "
"type, in other words)."
msgstr ""
"En sträng som identifierar vilken typ av data som elementet representerar "
"(elementtypen, med andra ord)."

msgid ""
"These attributes can be used to hold additional data associated with the "
"element.  Their values are usually strings but may be any application-"
"specific object.  If the element is created from an XML file, the *text* "
"attribute holds either the text between the element's start tag and its "
"first child or end tag, or ``None``, and the *tail* attribute holds either "
"the text between the element's end tag and the next tag, or ``None``.  For "
"the XML data"
msgstr ""
"Dessa attribut kan användas för att hålla ytterligare data associerade med "
"elementet.  Deras värden är vanligtvis strängar men kan vara vilket "
"applikationsspecifikt objekt som helst.  Om elementet skapas från en XML-fil "
"innehåller attributet *text* antingen texten mellan elementets starttagg och "
"dess första barn- eller sluttagg, eller ``None``, och attributet *tail* "
"innehåller antingen texten mellan elementets sluttagg och nästa tagg, eller "
"``None``.  För XML-data"

msgid "<a><b>1<c>2<d/>3</c></b>4</a>"
msgstr "<a><b><c>12<d/></c></b>34</a>"

msgid ""
"the *a* element has ``None`` for both *text* and *tail* attributes, the *b* "
"element has *text* ``\"1\"`` and *tail* ``\"4\"``, the *c* element has "
"*text* ``\"2\"`` and *tail* ``None``, and the *d* element has *text* "
"``None`` and *tail* ``\"3\"``."
msgstr ""
"elementet *a* har ``None`` för både attributen *text* och *tail*, elementet "
"*b* har *text* ``\"1\"`` och *tail* ``\"4\"``, elementet *c* har *text* "
"``\"2\"`` och *tail* ``None``, och elementet *d* har *text* ``None`` och "
"*tail* ``\"3\"``."

msgid ""
"To collect the inner text of an element, see :meth:`itertext`, for example "
"``\"\".join(element.itertext())``."
msgstr ""
"För att samla in den inre texten i ett element, se :meth:`itertext`, till "
"exempel ``\"\".join(element.itertext())``."

msgid "Applications may store arbitrary objects in these attributes."
msgstr "Applikationer kan lagra godtyckliga objekt i dessa attribut."

msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree "
"implementation may choose to use another internal representation, and create "
"the dictionary only if someone asks for it.  To take advantage of such "
"implementations, use the dictionary methods below whenever possible."
msgstr ""
"En ordbok som innehåller elementets attribut.  Observera att även om "
"*attrib*-värdet alltid är en verklig föränderlig Python-ordbok, kan en "
"ElementTree-implementering välja att använda en annan intern representation "
"och skapa ordboken endast om någon ber om det.  För att dra nytta av sådana "
"implementationer, använd dictionary-metoderna nedan när det är möjligt."

msgid "The following dictionary-like methods work on the element attributes."
msgstr "Följande ordboksliknande metoder fungerar på elementattributen."

msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr ""
"Återställer ett element.  Denna funktion tar bort alla underelement, rensar "
"alla attribut och sätter text- och tail-attributen till ``None``."

msgid "Gets the element attribute named *key*."
msgstr "Hämtar elementattributet med namnet *key*."

msgid ""
"Returns the attribute value, or *default* if the attribute was not found."
msgstr ""
"Returnerar attributvärdet, eller *default* om attributet inte hittades."

msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The "
"attributes are returned in an arbitrary order."
msgstr ""
"Returnerar elementattributen som en sekvens av (namn, värde)-par.  "
"Attributen returneras i godtycklig ordning."

msgid ""
"Returns the elements attribute names as a list.  The names are returned in "
"an arbitrary order."
msgstr ""
"Returnerar elementens attributnamn som en lista.  Namnen returneras i "
"godtycklig ordning."

msgid "Set the attribute *key* on the element to *value*."
msgstr "Ställ in attributet *key* på elementet till *value*."

msgid "The following methods work on the element's children (subelements)."
msgstr "Följande metoder fungerar på elementets barn (underelement)."

msgid ""
"Adds the element *subelement* to the end of this element's internal list of "
"subelements.  Raises :exc:`TypeError` if *subelement* is not an :class:"
"`Element`."
msgstr ""
"Lägger till elementet *subelement* i slutet av detta elements interna lista "
"över subelement.  Utlöser :exc:`TypeError` om *subelement* inte är ett :"
"class:`Element`."

msgid ""
"Appends *subelements* from an iterable of elements. Raises :exc:`TypeError` "
"if a subelement is not an :class:`Element`."
msgstr ""
"Lägger till *subelement* från en iterabel av element. Utlöser :exc:"
"`TypeError` om ett subelement inte är ett :class:`Element`."

msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name or "
"a :ref:`path <elementtree-xpath>`.  Returns an element instance or "
"``None``.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Hittar det första underelementet som matchar *match*.  *match* kan vara ett "
"taggnamn eller en :ref:`sökväg <elementtree-xpath>`.  Returnerar en "
"elementinstans eller ``None``.  *namespaces* är en valfri mappning från "
"namnrymds prefix till fullständigt namn.  Passera ``''`` som prefix för att "
"flytta alla taggnamn utan prefix i uttrycket till det angivna namnområdet."

msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document "
"order.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Hittar alla matchande underelement, genom taggnamn eller :ref:`path "
"<elementtree-xpath>`.  Returnerar en lista som innehåller alla matchande "
"element i dokumentordning.  *namespaces* är en valfri mappning från "
"namnrymdsprefix till fullständigt namn.  Passera ``''`` som prefix för att "
"flytta alla taggnamn utan prefix i uttrycket till det angivna namnområdet."

msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a tag "
"name or a :ref:`path <elementtree-xpath>`.  Returns the text content of the "
"first matching element, or *default* if no element was found. Note that if "
"the matching element has no text content an empty string is returned. "
"*namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"Hittar text för det första underelementet som matchar *match*.  *match* kan "
"vara ett taggnamn eller en :ref:`sökväg <elementtree-xpath>`.  Returnerar "
"textinnehållet i det första matchande elementet, eller *default* om inget "
"element hittades. Observera att om det matchande elementet inte har något "
"textinnehåll returneras en tom sträng. *namespaces* är en valfri mappning "
"från namnområdesprefix till fullständigt namn.  Ange ``''`` som prefix för "
"att flytta alla taggnamn utan prefix i uttrycket till den angivna namnrymden."

msgid ""
"Inserts *subelement* at the given position in this element.  Raises :exc:"
"`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""
"Infogar *subelement* på den angivna positionen i detta element.  Ger :exc:"
"`TypeError` om *subelement* inte är ett :class:`Element`."

msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The "
"iterator iterates over this element and all elements below it, in document "
"(depth first) order.  If *tag* is not ``None`` or ``'*'``, only elements "
"whose tag equals *tag* are returned from the iterator.  If the tree "
"structure is modified during iteration, the result is undefined."
msgstr ""
"Skapar ett träd :term:`iterator` med det aktuella elementet som rot. "
"Iteratorn itererar över detta element och alla element under det, i "
"dokumentordning (djupet först).  Om *tag* inte är ``None`` eller ``'*'`` "
"returneras endast element vars tagg är lika med *tag* från iteratorn.  Om "
"trädstrukturen ändras under iterationen blir resultatet odefinierat."

msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""
"Hittar alla matchande underelement, med taggnamn eller :ref:`path "
"<elementtree-xpath>`.  Returnerar en iterabel som ger alla matchande element "
"i dokumentordning. *namespaces* är en valfri mappning från namnområdesprefix "
"till fullständigt namn."

msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr ""
"Skapar en text-iterator.  Iteratorn loopar över detta element och alla "
"underelement, i dokumentordning, och returnerar all inre text."

msgid ""
"Creates a new element object of the same type as this element.  Do not call "
"this method, use the :func:`SubElement` factory function instead."
msgstr ""
"Skapar ett nytt elementobjekt av samma typ som detta element.  Anropa inte "
"denna metod, använd istället fabriksfunktionen :func:`SubElement`."

msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value or "
"contents."
msgstr ""
"Tar bort *subelement* från elementet.  Till skillnad från find\\*-metoderna "
"jämför den här metoden element baserat på instansidentiteten, inte på "
"taggens värde eller innehåll."

msgid ""
":class:`Element` objects also support the following sequence type methods "
"for working with subelements: :meth:`~object.__delitem__`, :meth:`~object."
"__getitem__`, :meth:`~object.__setitem__`, :meth:`~object.__len__`."
msgstr ""
":class:`Element`-objekt stöder också följande sekvensmetoder för att arbeta "
"med underelement: :meth:`~object.__delitem__`, :meth:`~object.__getitem__`, :"
"meth:`~object.__setitem__`, :meth:`~object.__len__`."

msgid ""
"Caution: Elements with no subelements will test as ``False``.  In a future "
"release of Python, all elements will test as ``True`` regardless of whether "
"subelements exist.  Instead, prefer explicit ``len(elem)`` or ``elem is not "
"None`` tests.::"
msgstr ""
"Varning för detta: Element utan underelement kommer att testas som "
"``False``.  I en framtida version av Python kommer alla element att testas "
"som ``True`` oavsett om underelement existerar.  Föredra istället explicita "
"``len(elem)`` eller ``elem is not None`` tester.::"

msgid ""
"element = root.find('foo')\n"
"\n"
"if not element:  # careful!\n"
"    print(\"element not found, or element has no subelements\")\n"
"\n"
"if element is None:\n"
"    print(\"element not found\")"
msgstr ""
"element = root.find('foo')\n"
"\n"
"om inte element:  # var försiktig!\n"
"    print(\"elementet hittades inte, eller elementet har inga "
"underelement\")\n"
"\n"
"om elementet är None:\n"
"    print(\"elementet hittades inte\")"

msgid "Testing the truth value of an Element emits :exc:`DeprecationWarning`."
msgstr ""
"Test av sanningsvärdet för ett element ger upphov till :exc:"
"`DeprecationWarning`."

msgid ""
"Prior to Python 3.8, the serialisation order of the XML attributes of "
"elements was artificially made predictable by sorting the attributes by "
"their name. Based on the now guaranteed ordering of dicts, this arbitrary "
"reordering was removed in Python 3.8 to preserve the order in which "
"attributes were originally parsed or created by user code."
msgstr ""
"Före Python 3.8 gjordes serialiseringsordningen för XML-attributen för "
"element artificiellt förutsägbar genom att sortera attributen efter deras "
"namn. Baserat på den nu garanterade ordningsföljden för dicts togs denna "
"godtyckliga omordning bort i Python 3.8 för att bevara den ordning i vilken "
"attributen ursprungligen analyserades eller skapades av användarkoden."

msgid ""
"In general, user code should try not to depend on a specific ordering of "
"attributes, given that the `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_ explicitly excludes the attribute order from conveying "
"information. Code should be prepared to deal with any ordering on input. In "
"cases where deterministic XML output is required, e.g. for cryptographic "
"signing or test data sets, canonical serialisation is available with the :"
"func:`canonicalize` function."
msgstr ""
"I allmänhet bör användarkod försöka att inte vara beroende av en specifik "
"ordning av attribut, med tanke på att `XML Information Set <https://www.w3."
"org/TR/xml-infoset/>`_ uttryckligen utesluter attributordningen från att "
"förmedla information. Koden bör vara förberedd på att hantera vilken ordning "
"som helst i indata. I fall där deterministisk XML-utdata krävs, t.ex. för "
"kryptografisk signering eller testdatauppsättningar, finns kanonisk "
"serialisering tillgänglig med funktionen :func:`canonicalize`."

msgid ""
"In cases where canonical output is not applicable but a specific attribute "
"order is still desirable on output, code should aim for creating the "
"attributes directly in the desired order, to avoid perceptual mismatches for "
"readers of the code. In cases where this is difficult to achieve, a recipe "
"like the following can be applied prior to serialisation to enforce an order "
"independently from the Element creation::"
msgstr ""
"I fall där kanonisk utdata inte är tillämplig men en specifik "
"attributordning fortfarande är önskvärd vid utdata, bör koden sträva efter "
"att skapa attributen direkt i önskad ordning för att undvika perceptuella "
"missanpassningar för läsare av koden. I fall där detta är svårt att uppnå "
"kan ett recept som följande tillämpas före serialisering för att genomdriva "
"en ordning oberoende av elementskapandet::"

msgid ""
"def reorder_attributes(root):\n"
"    for el in root.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # adjust attribute order, e.g. by sorting\n"
"            attribs = sorted(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"
msgstr ""
"def reorder_attributes(rot):\n"
"    för el i rot.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # justera attributordningen, t.ex. genom sortering\n"
"            attribs = sorterad(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"

msgid "ElementTree Objects"
msgstr "ElementTree-objekt"

msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr ""
"Omslagsklassen ElementTree.  Den här klassen representerar en hel "
"elementhierarki och ger lite extra stöd för serialisering till och från "
"standard-XML."

msgid ""
"*element* is the root element.  The tree is initialized with the contents of "
"the XML *file* if given."
msgstr ""
"*element* är rotelementet.  Trädet initialiseras med innehållet i XML "
"*filen* om den anges."

msgid ""
"Replaces the root element for this tree.  This discards the current contents "
"of the tree, and replaces it with the given element.  Use with care.  "
"*element* is an element instance."
msgstr ""
"Ersätter rotelementet för det här trädet.  Detta kastar bort det aktuella "
"innehållet i trädet och ersätter det med det angivna elementet.  Använd med "
"försiktighet.  *element* är en elementinstans."

msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr "Samma som :meth:`Element.find`, med start vid trädets rot."

msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr "Samma som :meth:`Element.findall`, med början vid trädets rot."

msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr "Samma som :meth:`Element.findtext`, med början vid trädets rot."

msgid "Returns the root element for this tree."
msgstr "Returnerar rotelementet för detta träd."

msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag to "
"look for (default is to return all elements)."
msgstr ""
"Skapar och returnerar en träditerator för rotelementet.  Iteratorn loopar "
"över alla element i detta träd, i sektionsordning.  *tag* är den tagg som "
"ska sökas (standard är att returnera alla element)."

msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr "Samma som :meth:`Element.iterfind`, med start vid trädets rot."

msgid ""
"Loads an external XML section into this element tree.  *source* is a file "
"name or :term:`file object`.  *parser* is an optional parser instance. If "
"not given, the standard :class:`XMLParser` parser is used.  Returns the "
"section root element."
msgstr ""
"Läser in ett externt XML-avsnitt i detta elementträd.  *source* är ett "
"filnamn eller :term:`filobjekt`.  *parser* är en valfri parser-instans. Om "
"den inte anges används standardparsern :class:`XMLParser`.  Returnerar "
"sektionens rotelement."

msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a :"
"term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, ``True`` "
"for always, ``None`` for only if not US-ASCII or UTF-8 or Unicode (default "
"is ``None``). *default_namespace* sets the default XML namespace (for "
"\"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` "
"(default is ``\"xml\"``). The keyword-only *short_empty_elements* parameter "
"controls the formatting of elements that contain no content.  If ``True`` "
"(the default), they are emitted as a single self-closed tag, otherwise they "
"are emitted as a pair of start/end tags."
msgstr ""
"Skriver elementträdet till en fil, som XML.  *file* är ett filnamn eller "
"ett :term:`filobjekt` som öppnats för skrivning.  *encoding* [1]_ är "
"kodningen för utdata (standard är US-ASCII). *xml_declaration* kontrollerar "
"om en XML-deklaration ska läggas till i filen.  Använd ``False`` för aldrig, "
"``True`` för alltid, ``None`` för endast om inte US-ASCII eller UTF-8 eller "
"Unicode (standard är ``None``). *default_namespace* anger standard XML-"
"namnområde (för \"xmlns\"). *method* är antingen ``\"xml\"``, ``\"html\"`` "
"eller ``\"text\"`` (standard är ``\"xml\"``). Parametern "
"*short_empty_elements*, som endast innehåller nyckelord, styr formateringen "
"av element som inte innehåller något innehåll.  Om ``True`` (standard), "
"skickas de ut som en enda självstängande tagg, annars skickas de ut som ett "
"par start/slut-taggar."

msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note that "
"this may conflict with the type of *file* if it's an open :term:`file "
"object`; make sure you do not try to write a string to a binary stream and "
"vice versa."
msgstr ""
"Utdata är antingen en sträng (:class:`str`) eller binär (:class:`bytes`). "
"Detta styrs av argumentet *encoding*.  Om *encoding* är ``\"unicode\"`` är "
"utdata en sträng, annars är den binär.  Observera att detta kan stå i "
"konflikt med typen av *fil* om det är ett öppet :term:`filobjekt`; se till "
"att du inte försöker skriva en sträng till en binär ström och vice versa."

msgid ""
"The :meth:`write` method now preserves the attribute order specified by the "
"user."
msgstr ""
"Metoden :meth:`write` bevarar nu den attributordning som anges av användaren."

msgid "This is the XML file that is going to be manipulated::"
msgstr "Detta är den XML-fil som ska manipuleras::"

msgid ""
"<html>\n"
"    <head>\n"
"        <title>Example page</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Moved to <a href=\"http://example.org/\">example.org</a>\n"
"        or <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"
msgstr ""
"<html>\n"
"    <head>\n"
"        <title>Exempel-sida</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Flyttad till <a href=\"http://example.org/\">example.org</a>\n"
"        eller <a href=\"http://example.com/\">exempel.com.</a></p>\n"
"    </body>\n"
"</html>"

msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr ""
"Exempel på ändring av attributet \"target\" för varje länk i första stycket::"

msgid ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # Finds first occurrence of tag p in body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # Returns list of all links\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # Iterates through all found links\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"
msgstr ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> träd = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' på 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\") # Hittar första förekomsten av taggen p i "
"body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c> >>> links = list(p.html)\n"
">>> länkar = list(p.iter(\"a\"))   # Returnerar lista över alla länkar\n"
">>> länkar\n"
"[<Element 'a' vid 0xb77ec2ac>, <Element 'a' vid 0xb77ec1cc>]\n"
">>> för i i länkar:             # Itererar genom alla hittade länkar\n"
"... i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"

msgid "QName Objects"
msgstr "QName-objekt"

msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in order "
"to get proper namespace handling on output.  *text_or_uri* is a string "
"containing the QName value, in the form {uri}local, or, if the tag argument "
"is given, the URI part of a QName.  If *tag* is given, the first argument is "
"interpreted as a URI, and this argument is interpreted as a local name. :"
"class:`QName` instances are opaque."
msgstr ""
"QName-omslag.  Detta kan användas för att omsluta ett QName-attributvärde "
"för att få korrekt namnrymdshantering vid utdata.  *text_or_uri* är en "
"sträng som innehåller QName-värdet i formen {uri}local, eller, om argumentet "
"tag anges, URI-delen av ett QName.  Om *tag* anges tolkas det första "
"argumentet som en URI, och detta argument tolkas som ett lokalt namn. :class:"
"`QName`-instanser är opaka."

msgid "TreeBuilder Objects"
msgstr "TreeBuilder-objekt"

msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, end, comment and pi method calls to a well-formed element "
"structure.  You can use this class to build an element structure using a "
"custom XML parser, or a parser for some other XML-like format."
msgstr ""
"Generisk byggare av elementstruktur.  Denna byggare konverterar en sekvens "
"av start-, data-, slut-, kommentar- och pi-metodanrop till en välformad "
"elementstruktur.  Du kan använda den här klassen för att bygga en "
"elementstruktur med hjälp av en anpassad XML-parser eller en parser för "
"något annat XML-liknande format."

msgid ""
"*element_factory*, when given, must be a callable accepting two positional "
"arguments: a tag and a dict of attributes.  It is expected to return a new "
"element instance."
msgstr ""
"*element_factory*, när den ges, måste vara en anropsbar som accepterar två "
"positionella argument: en tagg och ett dict av attribut.  Den förväntas "
"returnera en ny elementinstans."

msgid ""
"The *comment_factory* and *pi_factory* functions, when given, should behave "
"like the :func:`Comment` and :func:`ProcessingInstruction` functions to "
"create comments and processing instructions.  When not given, the default "
"factories will be used.  When *insert_comments* and/or *insert_pis* is true, "
"comments/pis will be inserted into the tree if they appear within the root "
"element (but not outside of it)."
msgstr ""
"Funktionerna *comment_factory* och *pi_factory*, när de anges, bör bete sig "
"som funktionerna :func:`Comment` och :func:`ProcessingInstruction` för att "
"skapa kommentarer och bearbetningsinstruktioner.  Om den inte anges kommer "
"standardfabrikerna att användas.  När *insert_comments* och/eller "
"*insert_pis* är true kommer kommentarer/pis att infogas i trädet om de "
"förekommer i rotelementet (men inte utanför det)."

msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr ""
"Tömmer byggarens buffertar och returnerar dokumentelementet på högsta "
"nivån.  Returnerar en instans av :class:`Element`."

msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr ""
"Lägger till text i det aktuella elementet.  *data* är en sträng.  Detta bör "
"vara antingen en bytestring eller en Unicode-sträng."

msgid ""
"Closes the current element.  *tag* is the element name.  Returns the closed "
"element."
msgstr ""
"Stänger det aktuella elementet.  *tag* är elementets namn.  Returnerar det "
"stängda elementet."

msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary "
"containing element attributes.  Returns the opened element."
msgstr ""
"Öppnar ett nytt element.  *tag* är elementets namn.  *attrs* är en ordbok "
"som innehåller elementattribut.  Returnerar det öppnade elementet."

msgid ""
"Creates a comment with the given *text*.  If ``insert_comments`` is true, "
"this will also add it to the tree."
msgstr ""
"Skapar en kommentar med den angivna *texten*.  Om ``insert_comments`` är "
"true, kommer den också att läggas till i trädet."

msgid ""
"Creates a process instruction with the given *target* name and *text*. If "
"``insert_pis`` is true, this will also add it to the tree."
msgstr ""
"Skapar en processinstruktion med det angivna *målnamnet* och *texten*. Om "
"``insert_pis`` är true, kommer detta också att lägga till den i trädet."

msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the following "
"methods:"
msgstr ""
"Dessutom kan ett anpassat :class:`TreeBuilder`-objekt tillhandahålla "
"följande metoder:"

msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is the "
"public identifier.  *system* is the system identifier.  This method does not "
"exist on the default :class:`TreeBuilder` class."
msgstr ""
"Hanterar en doctype-deklaration.  *name* är doctypens namn.  *pubid* är den "
"offentliga identifieraren.  *system* är systemidentifieraren.  Den här "
"metoden finns inte i standardklassen :class:`TreeBuilder`."

msgid ""
"Is called whenever the parser encounters a new namespace declaration, before "
"the ``start()`` callback for the opening element that defines it. *prefix* "
"is ``''`` for the default namespace and the declared namespace prefix name "
"otherwise.  *uri* is the namespace URI."
msgstr ""
"Anropas när parsern stöter på en ny namnrymdsdeklaration, före ``start()`` "
"callback för det inledande element som definierar den. *prefix* är ``''`` "
"för standardnamnrymden och det deklarerade namnrymdens prefixnamn i annat "
"fall.  *uri* är namnområdets URI."

msgid ""
"Is called after the ``end()`` callback of an element that declared a "
"namespace prefix mapping, with the name of the *prefix* that went out of "
"scope."
msgstr ""
"Anropas efter ``end()`` callback för ett element som deklarerade en mappning "
"av namnrymdsprefix, med namnet på det *prefix* som gick utanför räckvidden."

msgid ""
"A `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ writer.  Arguments are the "
"same as for the :func:`canonicalize` function.  This class does not build a "
"tree but translates the callback events directly into a serialised form "
"using the *write* function."
msgstr ""
"En `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ skribent.  Argumenten är "
"desamma som för funktionen :func:`canonicalize`.  Den här klassen bygger "
"inte ett träd utan översätter återuppringningshändelserna direkt till en "
"serialiserad form med hjälp av funktionen *write*."

msgid "XMLParser Objects"
msgstr "XMLParser-objekt"

msgid ""
"This class is the low-level building block of the module.  It uses :mod:`xml."
"parsers.expat` for efficient, event-based parsing of XML.  It can be fed XML "
"data incrementally with the :meth:`feed` method, and parsing events are "
"translated to a push API - by invoking callbacks on the *target* object.  If "
"*target* is omitted, the standard :class:`TreeBuilder` is used. If "
"*encoding* [1]_ is given, the value overrides the encoding specified in the "
"XML file."
msgstr ""
"Den här klassen är modulens byggsten på låg nivå.  Den använder :mod:`xml."
"parsers.expat` för effektiv, händelsebaserad parsning av XML.  Den kan matas "
"med XML-data stegvis med metoden :meth:`feed`, och parsinghändelser "
"översätts till ett push-API - genom att anropa callbacks på objektet "
"*target*.  Om *target* utelämnas används standardklassen :class:"
"`TreeBuilder`. Om *encoding* [1]_ anges, åsidosätter värdet den kodning som "
"anges i XML-filen."

msgid ""
"Parameters are now :ref:`keyword-only <keyword-only_parameter>`. The *html* "
"argument is no longer supported."
msgstr ""
"Parametrar är nu :ref:`keyword-only <keyword-only_parameter>`. Argumentet "
"*html* stöds inte längre."

msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by default, "
"this is the toplevel document element."
msgstr ""
"Avslutar matningen av data till parsern.  Returnerar resultatet av anropet "
"av ``close()``-metoden för det *mål* som skickades under konstruktionen; som "
"standard är detta dokumentelementet på toppnivå."

msgid "Feeds data to the parser.  *data* is encoded data."
msgstr "Matar in data till parsern.  *data* är kodade data."

msgid ""
"Triggers parsing of any previously fed unparsed data, which can be used to "
"ensure more immediate feedback, in particular with Expat >=2.6.0. The "
"implementation of :meth:`flush` temporarily disables reparse deferral with "
"Expat (if currently enabled) and triggers a reparse. Disabling reparse "
"deferral has security consequences; please see :meth:`xml.parsers.expat."
"xmlparser.SetReparseDeferralEnabled` for details."
msgstr ""
"Utlöser parsning av tidigare matade oanalyserade data, vilket kan användas "
"för att säkerställa mer omedelbar återkoppling, i synnerhet med Expat "
">=2.6.0. Implementeringen av :meth:`flush` inaktiverar tillfälligt reparse "
"deferral med Expat (om det för närvarande är aktiverat) och utlöser en "
"reparse. Att inaktivera reparse deferral har säkerhetsmässiga konsekvenser; "
"se :meth:`xml.parsers.expat.xmlparser.SetReparseDeferralEnabled` för "
"detaljer."

msgid ""
"Note that :meth:`flush` has been backported to some prior releases of "
"CPython as a security fix.  Check for availability of :meth:`flush` using :"
"func:`hasattr` if used in code running across a variety of Python versions."
msgstr ""
"Observera att :meth:`flush` har backporterats till vissa tidigare utgåvor av "
"CPython som en säkerhetsfix.  Kontrollera tillgängligheten av :meth:`flush` "
"med :func:`hasattr` om den används i kod som körs i flera olika Python-"
"versioner."

msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start(tag, attrs_dict)`` method "
"for each opening tag, its ``end(tag)`` method for each closing tag, and data "
"is processed by method ``data(data)``.  For further supported callback "
"methods, see the :class:`TreeBuilder` class.  :meth:`XMLParser.close` calls "
"*target*\\'s method ``close()``. :class:`XMLParser` can be used not only for "
"building a tree structure. This is an example of counting the maximum depth "
"of an XML file::"
msgstr ""
":meth:`XMLParser.feed` anropar *target*:s metod ``start(tag, attrs_dict)`` "
"för varje inledande tagg, dess metod ``end(tag)`` för varje avslutande tagg, "
"och data bearbetas med metoden ``data(data)``.  För fler callback-metoder "
"som stöds, se :class:`TreeBuilder`-klassen. :meth:`XMLParser.close` anropar "
"*target*:s metod ``close()``. :class:`XMLParser` kan inte bara användas för "
"att bygga en trädstruktur. Detta är ett exempel på hur man räknar det "
"maximala djupet på en XML-fil::"

msgid ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # The target object of the parser\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Called for each opening tag.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Called for each closing tag.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # We do not need to do anything with data.\n"
"...     def close(self):    # Called when all data has been parsed.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"
msgstr ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # The target object of the parser\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Called for each opening tag.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Called for each closing tag.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # We do not need to do anything with data.\n"
"...     def close(self):    # Called when all data has been parsed.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"

msgid "XMLPullParser Objects"
msgstr "XMLPullParser-objekt"

msgid ""
"A pull parser suitable for non-blocking applications.  Its input-side API is "
"similar to that of :class:`XMLParser`, but instead of pushing calls to a "
"callback target, :class:`XMLPullParser` collects an internal list of parsing "
"events and lets the user read from it. *events* is a sequence of events to "
"report back.  The supported events are the strings ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-"
"ns\"`` (the \"ns\" events are used to get detailed namespace information).  "
"If *events* is omitted, only ``\"end\"`` events are reported."
msgstr ""
"En pull-parser som lämpar sig för icke-blockerande applikationer.  Dess API "
"på inmatningssidan liknar det för :class:`XMLParser`, men istället för att "
"skicka anrop till ett återuppringningsmål samlar :class:`XMLPullParser` in "
"en intern lista över parsinghändelser och låter användaren läsa från den. "
"*events* är en sekvens av händelser som ska rapporteras tillbaka.  De "
"händelser som stöds är strängarna ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` och ``\"end-ns\"`` "
"(händelserna \"ns\" används för att få detaljerad information om "
"namnrymden).  Om *events* utelämnas, rapporteras endast ``\"end\"``-"
"händelser."

msgid "Feed the given bytes data to the parser."
msgstr "Mata in de givna bytesdata till parsern."

msgid ""
"Signal the parser that the data stream is terminated. Unlike :meth:"
"`XMLParser.close`, this method always returns :const:`None`. Any events not "
"yet retrieved when the parser is closed can still be read with :meth:"
"`read_events`."
msgstr ""
"Signalerar till parsern att dataflödet är avslutat. Till skillnad från :meth:"
"`XMLParser.close` returnerar denna metod alltid :const:`None`. Eventuella "
"händelser som ännu inte hämtats när parsern stängs kan fortfarande läsas "
"med :meth:`read_events`."

msgid ""
"Return an iterator over the events which have been encountered in the data "
"fed to the parser.  The iterator yields ``(event, elem)`` pairs, where "
"*event* is a string representing the type of event (e.g. ``\"end\"``) and "
"*elem* is the encountered :class:`Element` object, or other context value as "
"follows."
msgstr ""
"Returnerar en iterator över de händelser som har påträffats i de data som "
"matats in i parsern.  Iteratorn ger paren ``(event, elem)``, där *event* är "
"en sträng som representerar händelsens typ (t.ex. ``\"end\"``) och *elem* är "
"det påträffade :class:`Element`-objektet, eller annat kontextvärde enligt "
"följande."

msgid "``start``, ``end``: the current Element."
msgstr "``start``, ``slut``: det aktuella elementet."

msgid "``comment``, ``pi``: the current comment / processing instruction"
msgstr ""
"``comment``, ``pi``: den aktuella kommentaren / bearbetningsinstruktionen"

msgid ""
"``start-ns``: a tuple ``(prefix, uri)`` naming the declared namespace "
"mapping."
msgstr ""
"``start-ns``: en tupel ``(prefix, uri)`` som namnger den deklarerade "
"namnrymdsmappningen."

msgid "``end-ns``: :const:`None` (this may change in a future version)"
msgstr "``end-ns``: :const:`None` (detta kan ändras i en framtida version)"

msgid ""
"Events provided in a previous call to :meth:`read_events` will not be "
"yielded again.  Events are consumed from the internal queue only when they "
"are retrieved from the iterator, so multiple readers iterating in parallel "
"over iterators obtained from :meth:`read_events` will have unpredictable "
"results."
msgstr ""
"Händelser som tillhandahållits i ett tidigare anrop till :meth:`read_events` "
"kommer inte att återskapas.  Händelser konsumeras från den interna kön "
"endast när de hämtas från iteratorn, så flera läsare som parallellt itererar "
"över iteratorer som erhållits från :meth:`read_events` kommer att få "
"oförutsägbara resultat."

msgid ""
":class:`XMLPullParser` only guarantees that it has seen the \">\" character "
"of a starting tag when it emits a \"start\" event, so the attributes are "
"defined, but the contents of the text and tail attributes are undefined at "
"that point.  The same applies to the element children; they may or may not "
"be present."
msgstr ""
":class:`XMLPullParser` garanterar bara att den har sett tecknet \">\" i en "
"starttagg när den sänder ut en \"start\"-händelse, så attributen är "
"definierade, men innehållet i text- och tail-attributen är odefinierat vid "
"den tidpunkten.  Detsamma gäller för elementets barn; de kan vara närvarande "
"eller inte."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"XML parse error, raised by the various parsing methods in this module when "
"parsing fails.  The string representation of an instance of this exception "
"will contain a user-friendly error message.  In addition, it will have the "
"following attributes available:"
msgstr ""
"XML-parsefel, som uppstår när de olika parsningsmetoderna i denna modul "
"misslyckas med parsningen.  Strängrepresentationen av en instans av detta "
"undantag kommer att innehålla ett användarvänligt felmeddelande.  Dessutom "
"kommer den att ha följande attribut tillgängliga:"

msgid ""
"A numeric error code from the expat parser. See the documentation of :mod:"
"`xml.parsers.expat` for the list of error codes and their meanings."
msgstr ""
"En numerisk felkod från expat-parsern. Se dokumentationen för :mod:`xml."
"parsers.expat` för en lista över felkoder och deras innebörd."

msgid ""
"A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr "En tupel av *rad*, *kolumn*-nummer, som anger var felet inträffade."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"The encoding string included in XML output should conform to the appropriate "
"standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is not.  See "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and https://"
"www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"Kodningssträngen som ingår i XML-utdata bör överensstämma med lämpliga "
"standarder.  Till exempel är \"UTF-8\" giltig, men \"UTF8\" är det inte.  Se "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl och https://"
"www.iana.org/assignments/character-sets/character-sets.xhtml."
