# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!tracemalloc` --- Trace memory allocations"
msgstr ":mod:`!tracemalloc` --- Spåra minnesallokeringar"

msgid "**Source code:** :source:`Lib/tracemalloc.py`"
msgstr "**Källkod:** :source:`Lib/tracemalloc.py`"

msgid ""
"The tracemalloc module is a debug tool to trace memory blocks allocated by "
"Python. It provides the following information:"
msgstr ""
"Modulen tracemalloc är ett felsökningsverktyg för att spåra minnesblock som "
"allokerats av Python. Den ger följande information:"

msgid "Traceback where an object was allocated"
msgstr "Traceback där ett objekt allokerades"

msgid ""
"Statistics on allocated memory blocks per filename and per line number: "
"total size, number and average size of allocated memory blocks"
msgstr ""
"Statistik över allokerade minnesblock per filnamn och radnummer: total "
"storlek, antal och genomsnittlig storlek på allokerade minnesblock"

msgid "Compute the differences between two snapshots to detect memory leaks"
msgstr ""
"Beräkna skillnaderna mellan två ögonblicksbilder för att upptäcka "
"minnesläckor"

msgid ""
"To trace most memory blocks allocated by Python, the module should be "
"started as early as possible by setting the :envvar:`PYTHONTRACEMALLOC` "
"environment variable to ``1``, or by using :option:`-X` ``tracemalloc`` "
"command line option. The :func:`tracemalloc.start` function can be called at "
"runtime to start tracing Python memory allocations."
msgstr ""
"För att spåra de flesta minnesblock som allokeras av Python bör modulen "
"startas så tidigt som möjligt genom att ställa in miljövariabeln :envvar:"
"`PYTHONTRACEMALLOC` till ``1``, eller genom att använda "
"kommandoradsalternativet :option:`-X` ``tracemalloc``. Funktionen :func:"
"`tracemalloc.start` kan anropas vid körning för att börja spåra Python-"
"minnesallokeringar."

msgid ""
"By default, a trace of an allocated memory block only stores the most recent "
"frame (1 frame). To store 25 frames at startup: set the :envvar:"
"`PYTHONTRACEMALLOC` environment variable to ``25``, or use the :option:`-X` "
"``tracemalloc=25`` command line option."
msgstr ""
"Som standard lagrar en spårning av ett allokerat minnesblock endast den "
"senaste bilden (1 bild). För att lagra 25 bildrutor vid start: sätt "
"miljövariabeln :envvar:`PYTHONTRACEMALLOC` till ``25``, eller använd "
"kommandoradsalternativet :option:`-X` ``tracemalloc=25``."

msgid "Examples"
msgstr "Exempel"

msgid "Display the top 10"
msgstr "Visa de 10 bästa"

msgid "Display the 10 files allocating the most memory::"
msgstr "Visa de 10 filer som allokerar mest minne::"

msgid ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('lineno')\n"
"\n"
"print(\"[ Top 10 ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"
msgstr ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('lineno')\n"
"\n"
"print(\"[ Top 10 ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"

msgid "Example of output of the Python test suite::"
msgstr "Exempel på utdata från Python-testsviten::"

msgid ""
"[ Top 10 ]\n"
"<frozen importlib._bootstrap>:716: size=4855 KiB, count=39328, average=126 "
"B\n"
"<frozen importlib._bootstrap>:284: size=521 KiB, count=3199, average=167 B\n"
"/usr/lib/python3.4/collections/__init__.py:368: size=244 KiB, count=2315, "
"average=108 B\n"
"/usr/lib/python3.4/unittest/case.py:381: size=185 KiB, count=779, "
"average=243 B\n"
"/usr/lib/python3.4/unittest/case.py:402: size=154 KiB, count=378, "
"average=416 B\n"
"/usr/lib/python3.4/abc.py:133: size=88.7 KiB, count=347, average=262 B\n"
"<frozen importlib._bootstrap>:1446: size=70.4 KiB, count=911, average=79 B\n"
"<frozen importlib._bootstrap>:1454: size=52.0 KiB, count=25, average=2131 B\n"
"<string>:5: size=49.7 KiB, count=148, average=344 B\n"
"/usr/lib/python3.4/sysconfig.py:411: size=48.0 KiB, count=1, average=48.0 KiB"
msgstr ""
"[ Top 10 ]\n"
"<frozen importlib._bootstrap>:716: size=4855 KiB, count=39328, average=126 "
"B\n"
"<frozen importlib._bootstrap>:284: size=521 KiB, count=3199, average=167 B\n"
"/usr/lib/python3.4/collections/__init__.py:368: size=244 KiB, count=2315, "
"average=108 B\n"
"/usr/lib/python3.4/unittest/case.py:381: size=185 KiB, count=779, "
"average=243 B\n"
"/usr/lib/python3.4/unittest/case.py:402: size=154 KiB, count=378, "
"average=416 B\n"
"/usr/lib/python3.4/abc.py:133: size=88.7 KiB, count=347, average=262 B\n"
"<frozen importlib._bootstrap>:1446: size=70.4 KiB, count=911, average=79 B\n"
"<frozen importlib._bootstrap>:1454: size=52.0 KiB, count=25, average=2131 B\n"
"<string>:5: size=49.7 KiB, count=148, average=344 B\n"
"/usr/lib/python3.4/sysconfig.py:411: size=48.0 KiB, count=1, average=48.0 KiB"

msgid ""
"We can see that Python loaded ``4855 KiB`` data (bytecode and constants) "
"from modules and that the :mod:`collections` module allocated ``244 KiB`` to "
"build :class:`~collections.namedtuple` types."
msgstr ""
"Vi kan se att Python laddade ``4855 KiB`` data (bytekod och konstanter) från "
"moduler och att modulen :mod:`collections` allokerade ``244 KiB`` för att "
"bygga :class:`~collections.namedtuple`-typer."

msgid "See :meth:`Snapshot.statistics` for more options."
msgstr "Se :meth:`Snapshot.statistics` för fler alternativ."

msgid "Compute differences"
msgstr "Beräkna skillnader"

msgid "Take two snapshots and display the differences::"
msgstr "Ta två ögonblicksbilder och visa skillnaderna::"

msgid ""
"import tracemalloc\n"
"tracemalloc.start()\n"
"# ... start your application ...\n"
"\n"
"snapshot1 = tracemalloc.take_snapshot()\n"
"# ... call the function leaking memory ...\n"
"snapshot2 = tracemalloc.take_snapshot()\n"
"\n"
"top_stats = snapshot2.compare_to(snapshot1, 'lineno')\n"
"\n"
"print(\"[ Top 10 differences ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"
msgstr ""
"import tracemalloc\n"
"tracemalloc.start()\n"
"# ... start your application ...\n"
"\n"
"snapshot1 = tracemalloc.take_snapshot()\n"
"# ... call the function leaking memory ...\n"
"snapshot2 = tracemalloc.take_snapshot()\n"
"\n"
"top_stats = snapshot2.compare_to(snapshot1, 'lineno')\n"
"\n"
"print(\"[ Top 10 differences ]\")\n"
"for stat in top_stats[:10]:\n"
"    print(stat)"

msgid ""
"Example of output before/after running some tests of the Python test suite::"
msgstr ""
"Exempel på utdata före/efter körning av några tester i Python-testsviten::"

msgid ""
"[ Top 10 differences ]\n"
"<frozen importlib._bootstrap>:716: size=8173 KiB (+4428 KiB), count=71332 "
"(+39369), average=117 B\n"
"/usr/lib/python3.4/linecache.py:127: size=940 KiB (+940 KiB), count=8106 "
"(+8106), average=119 B\n"
"/usr/lib/python3.4/unittest/case.py:571: size=298 KiB (+298 KiB), count=589 "
"(+589), average=519 B\n"
"<frozen importlib._bootstrap>:284: size=1005 KiB (+166 KiB), count=7423 "
"(+1526), average=139 B\n"
"/usr/lib/python3.4/mimetypes.py:217: size=112 KiB (+112 KiB), count=1334 "
"(+1334), average=86 B\n"
"/usr/lib/python3.4/http/server.py:848: size=96.0 KiB (+96.0 KiB), count=1 "
"(+1), average=96.0 KiB\n"
"/usr/lib/python3.4/inspect.py:1465: size=83.5 KiB (+83.5 KiB), count=109 "
"(+109), average=784 B\n"
"/usr/lib/python3.4/unittest/mock.py:491: size=77.7 KiB (+77.7 KiB), "
"count=143 (+143), average=557 B\n"
"/usr/lib/python3.4/urllib/parse.py:476: size=71.8 KiB (+71.8 KiB), count=969 "
"(+969), average=76 B\n"
"/usr/lib/python3.4/contextlib.py:38: size=67.2 KiB (+67.2 KiB), count=126 "
"(+126), average=546 B"
msgstr ""
"[ Topp 10 skillnader ]\n"
"<frozen importlib._bootstrap>:716: storlek=8173 KiB (+4428 KiB), antal=71332 "
"(+39369), genomsnitt=117 B\n"
"/usr/lib/python3.4/linecache.py:127: storlek=940 KiB (+940 KiB), antal=8106 "
"(+8106), genomsnitt=119 B\n"
"/usr/lib/python3.4/unittest/case.py:571: storlek=298 KiB (+298 KiB), "
"antal=589 (+589), genomsnitt=519 B\n"
"<frozen importlib._bootstrap>:284: storlek=1005 KiB (+166 KiB), antal=7423 "
"(+1526), genomsnitt=139 B\n"
"/usr/lib/python3.4/mimetypes.py:217: storlek=112 KiB (+112 KiB), antal=1334 "
"(+1334), genomsnitt=86 B\n"
"/usr/lib/python3.4/http/server.py:848: storlek=96,0 KiB (+96,0 KiB), antal=1 "
"(+1), genomsnitt=96,0 KiB\n"
"/usr/lib/python3.4/inspect.py:1465: storlek=83,5 KiB (+83,5 KiB), antal=109 "
"(+109), genomsnitt=784 B\n"
"/usr/lib/python3.4/unittest/mock.py:491: storlek=77,7 KiB (+77,7 KiB), "
"antal=143 (+143), genomsnitt=557 B\n"
"/usr/lib/python3.4/urllib/parse.py:476: storlek=71,8 KiB (+71,8 KiB), "
"antal=969 (+969), genomsnitt=76 B\n"
"/usr/lib/python3.4/contextlib.py:38: storlek=67,2 KiB (+67,2 KiB), antal=126 "
"(+126), genomsnitt=546 B"

msgid ""
"We can see that Python has loaded ``8173 KiB`` of module data (bytecode and "
"constants), and that this is ``4428 KiB`` more than had been loaded before "
"the tests, when the previous snapshot was taken. Similarly, the :mod:"
"`linecache` module has cached ``940 KiB`` of Python source code to format "
"tracebacks, all of it since the previous snapshot."
msgstr ""
"Vi kan se att Python har laddat ``8173 KiB`` moduldata (bytekod och "
"konstanter), och att detta är ``4428 KiB`` mer än vad som hade laddats före "
"testerna, när den föregående ögonblicksbilden togs. På samma sätt har "
"modulen :mod:`linecache` cachat ``940 KiB`` Python-källkod för att formatera "
"spårningar, allt sedan den föregående ögonblicksbilden."

msgid ""
"If the system has little free memory, snapshots can be written on disk using "
"the :meth:`Snapshot.dump` method to analyze the snapshot offline. Then use "
"the :meth:`Snapshot.load` method reload the snapshot."
msgstr ""
"Om systemet har lite ledigt minne kan ögonblicksbilder skrivas på disk med "
"hjälp av metoden :meth:`Snapshot.dump` för att analysera ögonblicksbilden "
"offline. Använd sedan metoden :meth:`Snapshot.load` för att ladda om "
"ögonblicksbilden."

msgid "Get the traceback of a memory block"
msgstr "Hämta spårningen av ett minnesblock"

msgid "Code to display the traceback of the biggest memory block::"
msgstr "Kod för att visa spårningen av det största minnesblocket::"

msgid ""
"import tracemalloc\n"
"\n"
"# Store 25 frames\n"
"tracemalloc.start(25)\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('traceback')\n"
"\n"
"# pick the biggest memory block\n"
"stat = top_stats[0]\n"
"print(\"%s memory blocks: %.1f KiB\" % (stat.count, stat.size / 1024))\n"
"for line in stat.traceback.format():\n"
"    print(line)"
msgstr ""
"import tracemalloc\n"
"\n"
"# Store 25 frames\n"
"tracemalloc.start(25)\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"top_stats = snapshot.statistics('traceback')\n"
"\n"
"# pick the biggest memory block\n"
"stat = top_stats[0]\n"
"print(\"%s memory blocks: %.1f KiB\" % (stat.count, stat.size / 1024))\n"
"for line in stat.traceback.format():\n"
"    print(line)"

msgid ""
"Example of output of the Python test suite (traceback limited to 25 frames)::"
msgstr ""
"Exempel på utdata från Python-testsviten (traceback begränsad till 25 "
"ramar)::"

msgid ""
"903 memory blocks: 870.1 KiB\n"
"  File \"<frozen importlib._bootstrap>\", line 716\n"
"  File \"<frozen importlib._bootstrap>\", line 1036\n"
"  File \"<frozen importlib._bootstrap>\", line 934\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/doctest.py\", line 101\n"
"    import pdb\n"
"  File \"<frozen importlib._bootstrap>\", line 284\n"
"  File \"<frozen importlib._bootstrap>\", line 938\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/test/support/__init__.py\", line 1728\n"
"    import doctest\n"
"  File \"/usr/lib/python3.4/test/test_pickletools.py\", line 21\n"
"    support.run_doctest(pickletools)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1276\n"
"    test_runner()\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 976\n"
"    display_failure=not verbose)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 761\n"
"    match_tests=ns.match_tests)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1563\n"
"    main()\n"
"  File \"/usr/lib/python3.4/test/__main__.py\", line 3\n"
"    regrtest.main_in_temp_cwd()\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 73\n"
"    exec(code, run_globals)\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 160\n"
"    \"__main__\", fname, loader, pkg_name)"
msgstr ""
"903 memory blocks: 870.1 KiB\n"
"  File \"<frozen importlib._bootstrap>\", line 716\n"
"  File \"<frozen importlib._bootstrap>\", line 1036\n"
"  File \"<frozen importlib._bootstrap>\", line 934\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/doctest.py\", line 101\n"
"    import pdb\n"
"  File \"<frozen importlib._bootstrap>\", line 284\n"
"  File \"<frozen importlib._bootstrap>\", line 938\n"
"  File \"<frozen importlib._bootstrap>\", line 1068\n"
"  File \"<frozen importlib._bootstrap>\", line 619\n"
"  File \"<frozen importlib._bootstrap>\", line 1581\n"
"  File \"<frozen importlib._bootstrap>\", line 1614\n"
"  File \"/usr/lib/python3.4/test/support/__init__.py\", line 1728\n"
"    import doctest\n"
"  File \"/usr/lib/python3.4/test/test_pickletools.py\", line 21\n"
"    support.run_doctest(pickletools)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1276\n"
"    test_runner()\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 976\n"
"    display_failure=not verbose)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 761\n"
"    match_tests=ns.match_tests)\n"
"  File \"/usr/lib/python3.4/test/regrtest.py\", line 1563\n"
"    main()\n"
"  File \"/usr/lib/python3.4/test/__main__.py\", line 3\n"
"    regrtest.main_in_temp_cwd()\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 73\n"
"    exec(code, run_globals)\n"
"  File \"/usr/lib/python3.4/runpy.py\", line 160\n"
"    \"__main__\", fname, loader, pkg_name)"

msgid ""
"We can see that the most memory was allocated in the :mod:`importlib` module "
"to load data (bytecode and constants) from modules: ``870.1 KiB``. The "
"traceback is where the :mod:`importlib` loaded data most recently: on the "
"``import pdb`` line of the :mod:`doctest` module. The traceback may change "
"if a new module is loaded."
msgstr ""
"Vi kan se att det mesta minnet allokerades i modulen :mod:`importlib` för "
"att ladda data (bytecode och konstanter) från moduler: ``870,1 KiB``. "
"Spårningen är där :mod:`importlib` laddade data senast: på ``import pdb``-"
"raden i :mod:`doctest`-modulen. Spårningen kan ändras om en ny modul laddas."

msgid "Pretty top"
msgstr "Snygg topp"

msgid ""
"Code to display the 10 lines allocating the most memory with a pretty "
"output, ignoring ``<frozen importlib._bootstrap>`` and ``<unknown>`` files::"
msgstr ""
"Kod för att visa de 10 rader som allokerar mest minne med en vacker utdata, "
"ignorerar filerna ``<frozen importlib._bootstrap>`` och ``<unknown>``::"

msgid ""
"import linecache\n"
"import os\n"
"import tracemalloc\n"
"\n"
"def display_top(snapshot, key_type='lineno', limit=10):\n"
"    snapshot = snapshot.filter_traces((\n"
"        tracemalloc.Filter(False, \"<frozen importlib._bootstrap>\"),\n"
"        tracemalloc.Filter(False, \"<unknown>\"),\n"
"    ))\n"
"    top_stats = snapshot.statistics(key_type)\n"
"\n"
"    print(\"Top %s lines\" % limit)\n"
"    for index, stat in enumerate(top_stats[:limit], 1):\n"
"        frame = stat.traceback[0]\n"
"        print(\"#%s: %s:%s: %.1f KiB\"\n"
"              % (index, frame.filename, frame.lineno, stat.size / 1024))\n"
"        line = linecache.getline(frame.filename, frame.lineno).strip()\n"
"        if line:\n"
"            print('    %s' % line)\n"
"\n"
"    other = top_stats[limit:]\n"
"    if other:\n"
"        size = sum(stat.size for stat in other)\n"
"        print(\"%s other: %.1f KiB\" % (len(other), size / 1024))\n"
"    total = sum(stat.size for stat in top_stats)\n"
"    print(\"Total allocated size: %.1f KiB\" % (total / 1024))\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"display_top(snapshot)"
msgstr ""
"import linecache\n"
"import os\n"
"import tracemalloc\n"
"\n"
"def display_top(snapshot, key_type='lineno', limit=10):\n"
"    snapshot = snapshot.filter_traces((\n"
"        tracemalloc.Filter(False, \"<frozen importlib._bootstrap>\"),\n"
"        tracemalloc.Filter(False, \"<unknown>\"),\n"
"    ))\n"
"    top_stats = snapshot.statistics(key_type)\n"
"\n"
"    print(\"Top %s lines\" % limit)\n"
"    for index, stat in enumerate(top_stats[:limit], 1):\n"
"        frame = stat.traceback[0]\n"
"        print(\"#%s: %s:%s: %.1f KiB\"\n"
"              % (index, frame.filename, frame.lineno, stat.size / 1024))\n"
"        line = linecache.getline(frame.filename, frame.lineno).strip()\n"
"        if line:\n"
"            print('    %s' % line)\n"
"\n"
"    other = top_stats[limit:]\n"
"    if other:\n"
"        size = sum(stat.size for stat in other)\n"
"        print(\"%s other: %.1f KiB\" % (len(other), size / 1024))\n"
"    total = sum(stat.size for stat in top_stats)\n"
"    print(\"Total allocated size: %.1f KiB\" % (total / 1024))\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# ... run your application ...\n"
"\n"
"snapshot = tracemalloc.take_snapshot()\n"
"display_top(snapshot)"

msgid ""
"Top 10 lines\n"
"#1: Lib/base64.py:414: 419.8 KiB\n"
"    _b85chars2 = [(a + b) for a in _b85chars for b in _b85chars]\n"
"#2: Lib/base64.py:306: 419.8 KiB\n"
"    _a85chars2 = [(a + b) for a in _a85chars for b in _a85chars]\n"
"#3: collections/__init__.py:368: 293.6 KiB\n"
"    exec(class_definition, namespace)\n"
"#4: Lib/abc.py:133: 115.2 KiB\n"
"    cls = super().__new__(mcls, name, bases, namespace)\n"
"#5: unittest/case.py:574: 103.1 KiB\n"
"    testMethod()\n"
"#6: Lib/linecache.py:127: 95.4 KiB\n"
"    lines = fp.readlines()\n"
"#7: urllib/parse.py:476: 71.8 KiB\n"
"    for a in _hexdig for b in _hexdig}\n"
"#8: <string>:5: 62.0 KiB\n"
"#9: Lib/_weakrefset.py:37: 60.0 KiB\n"
"    self.data = set()\n"
"#10: Lib/base64.py:142: 59.8 KiB\n"
"    _b32tab2 = [a + b for a in _b32tab for b in _b32tab]\n"
"6220 other: 3602.8 KiB\n"
"Total allocated size: 5303.1 KiB"
msgstr ""
"Top 10 lines\n"
"#1: Lib/base64.py:414: 419.8 KiB\n"
"    _b85chars2 = [(a + b) for a in _b85chars for b in _b85chars]\n"
"#2: Lib/base64.py:306: 419.8 KiB\n"
"    _a85chars2 = [(a + b) for a in _a85chars for b in _a85chars]\n"
"#3: collections/__init__.py:368: 293.6 KiB\n"
"    exec(class_definition, namespace)\n"
"#4: Lib/abc.py:133: 115.2 KiB\n"
"    cls = super().__new__(mcls, name, bases, namespace)\n"
"#5: unittest/case.py:574: 103.1 KiB\n"
"    testMethod()\n"
"#6: Lib/linecache.py:127: 95.4 KiB\n"
"    lines = fp.readlines()\n"
"#7: urllib/parse.py:476: 71.8 KiB\n"
"    for a in _hexdig for b in _hexdig}\n"
"#8: <string>:5: 62.0 KiB\n"
"#9: Lib/_weakrefset.py:37: 60.0 KiB\n"
"    self.data = set()\n"
"#10: Lib/base64.py:142: 59.8 KiB\n"
"    _b32tab2 = [a + b for a in _b32tab for b in _b32tab]\n"
"6220 other: 3602.8 KiB\n"
"Total allocated size: 5303.1 KiB"

msgid "Record the current and peak size of all traced memory blocks"
msgstr ""
"Registrera den aktuella och maximala storleken på alla spårade minnesblock"

msgid ""
"The following code computes two sums like ``0 + 1 + 2 + ...`` inefficiently, "
"by creating a list of those numbers. This list consumes a lot of memory "
"temporarily. We can use :func:`get_traced_memory` and :func:`reset_peak` to "
"observe the small memory usage after the sum is computed as well as the peak "
"memory usage during the computations::"
msgstr ""
"Följande kod beräknar två summor som ``0 + 1 + 2 + ...`` ineffektivt genom "
"att skapa en lista med dessa tal. Denna lista förbrukar mycket minne "
"temporärt. Vi kan använda :func:`get_traced_memory` och :func:`reset_peak` "
"för att observera den lilla minnesanvändningen efter att summan har "
"beräknats samt den maximala minnesanvändningen under beräkningarna::"

msgid ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# Example code: compute a sum with a large temporary list\n"
"large_sum = sum(list(range(100000)))\n"
"\n"
"first_size, first_peak = tracemalloc.get_traced_memory()\n"
"\n"
"tracemalloc.reset_peak()\n"
"\n"
"# Example code: compute a sum with a small temporary list\n"
"small_sum = sum(list(range(1000)))\n"
"\n"
"second_size, second_peak = tracemalloc.get_traced_memory()\n"
"\n"
"print(f\"{first_size=}, {first_peak=}\")\n"
"print(f\"{second_size=}, {second_peak=}\")"
msgstr ""
"import tracemalloc\n"
"\n"
"tracemalloc.start()\n"
"\n"
"# Example code: compute a sum with a large temporary list\n"
"large_sum = sum(list(range(100000)))\n"
"\n"
"first_size, first_peak = tracemalloc.get_traced_memory()\n"
"\n"
"tracemalloc.reset_peak()\n"
"\n"
"# Example code: compute a sum with a small temporary list\n"
"small_sum = sum(list(range(1000)))\n"
"\n"
"second_size, second_peak = tracemalloc.get_traced_memory()\n"
"\n"
"print(f\"{first_size=}, {first_peak=}\")\n"
"print(f\"{second_size=}, {second_peak=}\")"

msgid "Output::"
msgstr "Utdata::"

msgid ""
"first_size=664, first_peak=3592984\n"
"second_size=804, second_peak=29704"
msgstr ""
"first_size=664, first_peak=3592984\n"
"second_size=804, second_peak=29704"

msgid ""
"Using :func:`reset_peak` ensured we could accurately record the peak during "
"the computation of ``small_sum``, even though it is much smaller than the "
"overall peak size of memory blocks since the :func:`start` call. Without the "
"call to :func:`reset_peak`, ``second_peak`` would still be the peak from the "
"computation ``large_sum`` (that is, equal to ``first_peak``). In this case, "
"both peaks are much higher than the final memory usage, and which suggests "
"we could optimise (by removing the unnecessary call to :class:`list`, and "
"writing ``sum(range(...))``)."
msgstr ""
"Genom att använda :func:`reset_peak` säkerställde vi att vi korrekt kunde "
"registrera toppen under beräkningen av ``small_sum``, även om den är mycket "
"mindre än den totala toppstorleken för minnesblock sedan anropet till :func:"
"`start`. Utan anropet till :func:`reset_peak` skulle ``second_peak`` "
"fortfarande vara toppen från beräkningen av ``large_sum`` (dvs. lika med "
"``first_peak``). I det här fallet är båda topparna mycket högre än den "
"slutliga minnesanvändningen, vilket tyder på att vi kan optimera (genom att "
"ta bort det onödiga anropet till :class:`list` och skriva "
"``sum(range(...))``)."

msgid "API"
msgstr "API"

msgid "Functions"
msgstr "Funktioner"

msgid "Clear traces of memory blocks allocated by Python."
msgstr "Tydliga spår av minnesblock som allokerats av Python."

msgid "See also :func:`stop`."
msgstr "Se även :func:`stop`."

msgid ""
"Get the traceback where the Python object *obj* was allocated. Return a :"
"class:`Traceback` instance, or ``None`` if the :mod:`tracemalloc` module is "
"not tracing memory allocations or did not trace the allocation of the object."
msgstr ""
"Hämta spårningen där Python-objektet *obj* allokerades. Returnerar en :class:"
"`Traceback`-instans, eller ``None`` om :mod:`tracemalloc`-modulen inte "
"spårar minnesallokeringar eller inte spårade allokeringen av objektet."

msgid "See also :func:`gc.get_referrers` and :func:`sys.getsizeof` functions."
msgstr ""
"Se även funktionerna :func:`gc.get_referrers` och :func:`sys.getsizeof`."

msgid "Get the maximum number of frames stored in the traceback of a trace."
msgstr ""
"Hämta det maximala antalet bildrutor som lagras i traceback för en trace."

msgid ""
"The :mod:`tracemalloc` module must be tracing memory allocations to get the "
"limit, otherwise an exception is raised."
msgstr ""
"Modulen :mod:`tracemalloc` måste spåra minnesallokeringar för att få fram "
"gränsen, annars uppstår ett undantag."

msgid "The limit is set by the :func:`start` function."
msgstr "Gränsen sätts av funktionen :func:`start`."

msgid ""
"Get the current size and peak size of memory blocks traced by the :mod:"
"`tracemalloc` module as a tuple: ``(current: int, peak: int)``."
msgstr ""
"Hämta den aktuella storleken och toppstorleken på minnesblock som spåras av "
"modulen :mod:`tracemalloc` som en tupel: ``(current: int, peak: int)``."

msgid ""
"Set the peak size of memory blocks traced by the :mod:`tracemalloc` module "
"to the current size."
msgstr ""
"Ställ in den maximala storleken på minnesblock som spåras av modulen :mod:"
"`tracemalloc` till den aktuella storleken."

msgid ""
"Do nothing if the :mod:`tracemalloc` module is not tracing memory "
"allocations."
msgstr ""
"Gör ingenting om modulen :mod:`tracemalloc` inte spårar minnesallokeringar."

msgid ""
"This function only modifies the recorded peak size, and does not modify or "
"clear any traces, unlike :func:`clear_traces`. Snapshots taken with :func:"
"`take_snapshot` before a call to :func:`reset_peak` can be meaningfully "
"compared to snapshots taken after the call."
msgstr ""
"Denna funktion ändrar bara den registrerade toppstorleken och ändrar eller "
"rensar inte några spår, till skillnad från :func:`clear_traces`. "
"Ögonblicksbilder som tagits med :func:`take_snapshot` före ett anrop till :"
"func:`reset_peak` kan på ett meningsfullt sätt jämföras med ögonblicksbilder "
"som tagits efter anropet."

msgid "See also :func:`get_traced_memory`."
msgstr "Se även :func:`get_traced_memory`."

msgid ""
"Get the memory usage in bytes of the :mod:`tracemalloc` module used to store "
"traces of memory blocks. Return an :class:`int`."
msgstr ""
"Hämtar minnesanvändningen i byte för :mod:`tracemalloc`-modulen som används "
"för att lagra spår av minnesblock. Returnerar en :class:`int`."

msgid ""
"``True`` if the :mod:`tracemalloc` module is tracing Python memory "
"allocations, ``False`` otherwise."
msgstr ""
"``True`` om modulen :mod:`tracemalloc`` spårar Python-minnesallokeringar, "
"``False`` annars."

msgid "See also :func:`start` and :func:`stop` functions."
msgstr "Se även funktionerna :func:`start` och :func:`stop`."

msgid ""
"Start tracing Python memory allocations: install hooks on Python memory "
"allocators. Collected tracebacks of traces will be limited to *nframe* "
"frames. By default, a trace of a memory block only stores the most recent "
"frame: the limit is ``1``. *nframe* must be greater or equal to ``1``."
msgstr ""
"Börja spåra Python-minnesallokeringar: installera krokar på Python-"
"minnesallokatorer. Insamlade spårningar av spårningar kommer att begränsas "
"till *nframe*-ramar. Som standard lagrar en spårning av ett minnesblock "
"endast den senaste ramen: gränsen är ``1``. *nframe* måste vara större än "
"eller lika med ``1``."

msgid ""
"You can still read the original number of total frames that composed the "
"traceback by looking at the :attr:`Traceback.total_nframe` attribute."
msgstr ""
"Du kan fortfarande läsa det ursprungliga antalet totala bildrutor som "
"utgjorde traceback genom att titta på attributet :attr:`Traceback."
"total_nframe`."

msgid ""
"Storing more than ``1`` frame is only useful to compute statistics grouped "
"by ``'traceback'`` or to compute cumulative statistics: see the :meth:"
"`Snapshot.compare_to` and :meth:`Snapshot.statistics` methods."
msgstr ""
"Att lagra mer än ``1`` ram är endast användbart för att beräkna statistik "
"grupperad efter ``'traceback'`` eller för att beräkna kumulativ statistik: "
"se metoderna :meth:`Snapshot.compare_to` och :meth:`Snapshot.statistics`."

msgid ""
"Storing more frames increases the memory and CPU overhead of the :mod:"
"`tracemalloc` module. Use the :func:`get_tracemalloc_memory` function to "
"measure how much memory is used by the :mod:`tracemalloc` module."
msgstr ""
"Om du lagrar fler ramar ökar minnes- och processorkostnaden för modulen :mod:"
"`tracemalloc`. Använd funktionen :func:`get_tracemalloc_memory` för att mäta "
"hur mycket minne som används av modulen :mod:`tracemalloc`."

msgid ""
"The :envvar:`PYTHONTRACEMALLOC` environment variable "
"(``PYTHONTRACEMALLOC=NFRAME``) and the :option:`-X` ``tracemalloc=NFRAME`` "
"command line option can be used to start tracing at startup."
msgstr ""
"Miljövariabeln :envvar:`PYTHONTRACEMALLOC` (``PYTHONTRACEMALLOC=NFRAME``) "
"och kommandoradsalternativet :option:`-X` ``tracemalloc=NFRAME`` kan "
"användas för att starta spårning vid uppstart."

msgid ""
"See also :func:`stop`, :func:`is_tracing` and :func:`get_traceback_limit` "
"functions."
msgstr ""
"Se även funktionerna :func:`stop`, :func:`is_tracing` och :func:"
"`get_traceback_limit`."

msgid ""
"Stop tracing Python memory allocations: uninstall hooks on Python memory "
"allocators. Also clears all previously collected traces of memory blocks "
"allocated by Python."
msgstr ""
"Sluta spåra Python-minnesallokeringar: avinstallera krokar på Python-"
"minnesallokatorer. Rensar även alla tidigare insamlade spår av minnesblock "
"som allokerats av Python."

msgid ""
"Call :func:`take_snapshot` function to take a snapshot of traces before "
"clearing them."
msgstr ""
"Anropa funktionen :func:`take_snapshot` för att ta en ögonblicksbild av "
"spåren innan de rensas."

msgid ""
"See also :func:`start`, :func:`is_tracing` and :func:`clear_traces` "
"functions."
msgstr ""
"Se även funktionerna :func:`start`, :func:`is_tracing` och :func:"
"`clear_traces`."

msgid ""
"Take a snapshot of traces of memory blocks allocated by Python. Return a "
"new :class:`Snapshot` instance."
msgstr ""
"Ta en ögonblicksbild av spår av minnesblock som allokerats av Python. "
"Returnerar en ny :class:`Snapshot`-instans."

msgid ""
"The snapshot does not include memory blocks allocated before the :mod:"
"`tracemalloc` module started to trace memory allocations."
msgstr ""
"Ögonblicksbilden innehåller inte minnesblock som allokerats innan modulen :"
"mod:`tracemalloc` började spåra minnesallokeringar."

msgid ""
"Tracebacks of traces are limited to :func:`get_traceback_limit` frames. Use "
"the *nframe* parameter of the :func:`start` function to store more frames."
msgstr ""
"Spårningar av spårningar är begränsade till :func:`get_traceback_limit`-"
"ramar. Använd parametern *nframe* i funktionen :func:`start` för att lagra "
"fler ramar."

msgid ""
"The :mod:`tracemalloc` module must be tracing memory allocations to take a "
"snapshot, see the :func:`start` function."
msgstr ""
"Modulen :mod:`tracemalloc` måste spåra minnesallokeringar för att ta en "
"ögonblicksbild, se funktionen :func:`start`."

msgid "See also the :func:`get_object_traceback` function."
msgstr "Se även funktionen :func:`get_object_traceback`."

msgid "DomainFilter"
msgstr "DomainFilter"

msgid "Filter traces of memory blocks by their address space (domain)."
msgstr "Filtrera spår av minnesblock efter deras adressutrymme (domän)."

msgid ""
"If *inclusive* is ``True`` (include), match memory blocks allocated in the "
"address space :attr:`domain`."
msgstr ""
"Om *inclusive* är ``True`` (include), matcha minnesblock som allokerats i "
"adressrymden :attr:`domain`."

msgid ""
"If *inclusive* is ``False`` (exclude), match memory blocks not allocated in "
"the address space :attr:`domain`."
msgstr ""
"Om *inclusive* är ``False`` (exkludera), matchas minnesblock som inte "
"allokerats i adressutrymmet :attr:`domain`."

msgid "Address space of a memory block (``int``). Read-only property."
msgstr "Adressrymd för ett minnesblock (``int``). Skrivskyddad egenskap."

msgid "Filter"
msgstr "Filtrera"

msgid "Filter on traces of memory blocks."
msgstr "Filtrera på spår av minnesblock."

msgid ""
"See the :func:`fnmatch.fnmatch` function for the syntax of "
"*filename_pattern*. The ``'.pyc'`` file extension is replaced with ``'.py'``."
msgstr ""
"Se funktionen :func:`fnmatch.fnmatch` för syntaxen för *filename_pattern*. "
"Filändelsen ``'.pyc'`` ersätts med ``'.py'``."

msgid "Examples:"
msgstr "Exempel:"

msgid ""
"``Filter(True, subprocess.__file__)`` only includes traces of the :mod:"
"`subprocess` module"
msgstr ""
"``Filter(True, subprocess.__file__)`` innehåller bara spår av modulen :mod:"
"`subprocess"

msgid ""
"``Filter(False, tracemalloc.__file__)`` excludes traces of the :mod:"
"`tracemalloc` module"
msgstr ""
"``Filter(False, tracemalloc.__file__)`` utesluter spår av modulen :mod:"
"`tracemalloc`"

msgid "``Filter(False, \"<unknown>\")`` excludes empty tracebacks"
msgstr "``Filter(False, \"<unknown>\")``` utesluter tomma spårningar"

msgid "The ``'.pyo'`` file extension is no longer replaced with ``'.py'``."
msgstr "Filändelsen ```.pyo`` ersätts inte längre med ```.py``."

msgid "Added the :attr:`domain` attribute."
msgstr "Lagt till attributet :attr:`domain`."

msgid "Address space of a memory block (``int`` or ``None``)."
msgstr "Adressrymd för ett minnesblock (``int`` eller ``None``)."

msgid ""
"tracemalloc uses the domain ``0`` to trace memory allocations made by "
"Python. C extensions can use other domains to trace other resources."
msgstr ""
"tracemalloc använder domänen ``0`` för att spåra minnesallokeringar gjorda "
"av Python. C-tillägg kan använda andra domäner för att spåra andra resurser."

msgid ""
"If *inclusive* is ``True`` (include), only match memory blocks allocated in "
"a file with a name matching :attr:`filename_pattern` at line number :attr:"
"`lineno`."
msgstr ""
"Om *inclusive* är ``True`` (include), matchas endast minnesblock som "
"allokerats i en fil med ett namn som matchar :attr:`filename_pattern` på "
"radnummer :attr:`lineno`."

msgid ""
"If *inclusive* is ``False`` (exclude), ignore memory blocks allocated in a "
"file with a name matching :attr:`filename_pattern` at line number :attr:"
"`lineno`."
msgstr ""
"Om *inclusive* är ``False`` (exkludera), ignorera minnesblock som allokerats "
"i en fil med ett namn som matchar :attr:`filename_pattern` på radnummer :"
"attr:`lineno`."

msgid ""
"Line number (``int``) of the filter. If *lineno* is ``None``, the filter "
"matches any line number."
msgstr ""
"Radnummer (``int``) för filtret. Om *lineno* är ``None``, matchar filtret "
"vilket radnummer som helst."

msgid "Filename pattern of the filter (``str``). Read-only property."
msgstr "Filnamnsmönster för filtret (``str``). Skrivskyddad egenskap."

msgid ""
"If *all_frames* is ``True``, all frames of the traceback are checked. If "
"*all_frames* is ``False``, only the most recent frame is checked."
msgstr ""
"Om *all_frames* är ``True`` kontrolleras alla ramar i tracebacken. Om "
"*all_frames* är ``False`` kontrolleras endast den senaste ramen."

msgid ""
"This attribute has no effect if the traceback limit is ``1``.  See the :func:"
"`get_traceback_limit` function and :attr:`Snapshot.traceback_limit` "
"attribute."
msgstr ""
"Detta attribut har ingen effekt om traceback-gränsen är ``1``.  Se "
"funktionen :func:`get_traceback_limit` och attributet :attr:`Snapshot."
"traceback_limit`."

msgid "Frame"
msgstr "Ram"

msgid "Frame of a traceback."
msgstr "Ram för en spårning."

msgid "The :class:`Traceback` class is a sequence of :class:`Frame` instances."
msgstr ""
"Klassen :class:`Traceback` är en sekvens av instanser av :class:`Frame`."

msgid "Filename (``str``)."
msgstr "Filnamn (``str``)."

msgid "Line number (``int``)."
msgstr "Radnummer (``int``)."

msgid "Snapshot"
msgstr "Snapshot"

msgid "Snapshot of traces of memory blocks allocated by Python."
msgstr "Ögonblicksbild av spår av minnesblock som allokerats av Python."

msgid "The :func:`take_snapshot` function creates a snapshot instance."
msgstr "Funktionen :func:`take_snapshot` skapar en snapshot-instans."

msgid ""
"Compute the differences with an old snapshot. Get statistics as a sorted "
"list of :class:`StatisticDiff` instances grouped by *key_type*."
msgstr ""
"Beräkna skillnaderna med en gammal ögonblicksbild. Hämta statistik som en "
"sorterad lista över :class:`StatisticDiff`-instanser grupperade efter "
"*key_type*."

msgid ""
"See the :meth:`Snapshot.statistics` method for *key_type* and *cumulative* "
"parameters."
msgstr ""
"Se metoden :meth:`Snapshot.statistics` för parametrarna *key_type* och "
"*cumulative*."

msgid ""
"The result is sorted from the biggest to the smallest by: absolute value of :"
"attr:`StatisticDiff.size_diff`, :attr:`StatisticDiff.size`, absolute value "
"of :attr:`StatisticDiff.count_diff`, :attr:`Statistic.count` and then by :"
"attr:`StatisticDiff.traceback`."
msgstr ""
"Resultatet sorteras från det största till det minsta efter: absolut värde "
"av :attr:`StatisticDiff.size_diff`, :attr:`StatisticDiff.size`, absolut "
"värde av :attr:`StatisticDiff.count_diff`, :attr:`Statistic.count` och sedan "
"efter :attr:`StatisticDiff.traceback`."

msgid "Write the snapshot into a file."
msgstr "Skriv in ögonblicksbilden i en fil."

msgid "Use :meth:`load` to reload the snapshot."
msgstr "Använd :meth:`load` för att ladda om ögonblicksbilden."

msgid ""
"Create a new :class:`Snapshot` instance with a filtered :attr:`traces` "
"sequence, *filters* is a list of :class:`DomainFilter` and :class:`Filter` "
"instances.  If *filters* is an empty list, return a new :class:`Snapshot` "
"instance with a copy of the traces."
msgstr ""
"Skapa en ny :class:`Snapshot`-instans med en filtrerad :attr:`traces`-"
"sekvens, *filter* är en lista över :class:`DomainFilter`- och :class:"
"`Filter`-instanser.  Om *filters* är en tom lista, returneras en ny :class:"
"`Snapshot`-instans med en kopia av spåren."

msgid ""
"All inclusive filters are applied at once, a trace is ignored if no "
"inclusive filters match it. A trace is ignored if at least one exclusive "
"filter matches it."
msgstr ""
"Alla inkluderande filter tillämpas på en gång, en spårning ignoreras om inga "
"inkluderande filter matchar den. En spårning ignoreras om minst ett "
"exklusivt filter matchar den."

msgid ":class:`DomainFilter` instances are now also accepted in *filters*."
msgstr ":class:`DomainFilter`-instanser accepteras nu även i *filters*."

msgid "Load a snapshot from a file."
msgstr "Ladda en ögonblicksbild från en fil."

msgid "See also :meth:`dump`."
msgstr "Se även :meth:`dump`."

msgid ""
"Get statistics as a sorted list of :class:`Statistic` instances grouped by "
"*key_type*:"
msgstr ""
"Hämta statistik som en sorterad lista över :class:`Statistic`-instanser "
"grupperade efter *key_type*:"

msgid "key_type"
msgstr "key_type"

msgid "description"
msgstr "beskrivning"

msgid "``'filename'``"
msgstr "``'filename'``"

msgid "filename"
msgstr "filename"

msgid "``'lineno'``"
msgstr "``'lineno'``"

msgid "filename and line number"
msgstr "filnam och radnummer"

msgid "``'traceback'``"
msgstr "``'traceback'``"

msgid "traceback"
msgstr "spårning"

msgid ""
"If *cumulative* is ``True``, cumulate size and count of memory blocks of all "
"frames of the traceback of a trace, not only the most recent frame. The "
"cumulative mode can only be used with *key_type* equals to ``'filename'`` "
"and ``'lineno'``."
msgstr ""
"Om *cumulative* är ``True``, kumuleras storlek och antal minnesblock för "
"alla ramar i spårningen av en spårning, inte bara den senaste ramen. Det "
"kumulativa läget kan endast användas med *key_type* lika med ``'filename'`` "
"och ``'lineno'``."

msgid ""
"The result is sorted from the biggest to the smallest by: :attr:`Statistic."
"size`, :attr:`Statistic.count` and then by :attr:`Statistic.traceback`."
msgstr ""
"Resultatet sorteras från det största till det minsta efter: :attr:`Statistic."
"size`, :attr:`Statistic.count` och sedan efter :attr:`Statistic.traceback`."

msgid ""
"Maximum number of frames stored in the traceback of :attr:`traces`: result "
"of the :func:`get_traceback_limit` when the snapshot was taken."
msgstr ""
"Maximalt antal bildrutor som lagras i spårningen av :attr:`traces`: "
"resultatet av :func:`get_traceback_limit` när ögonblicksbilden togs."

msgid ""
"Traces of all memory blocks allocated by Python: sequence of :class:`Trace` "
"instances."
msgstr ""
"Spårningar av alla minnesblock som allokerats av Python: sekvens av :class:"
"`Trace`-instanser."

msgid ""
"The sequence has an undefined order. Use the :meth:`Snapshot.statistics` "
"method to get a sorted list of statistics."
msgstr ""
"Sekvensen har en odefinierad ordning. Använd metoden :meth:`Snapshot."
"statistics` för att få en sorterad lista med statistik."

msgid "Statistic"
msgstr "Statistik"

msgid "Statistic on memory allocations."
msgstr "Statistik över minnesallokeringar."

msgid ""
":func:`Snapshot.statistics` returns a list of :class:`Statistic` instances."
msgstr ""
":func:`Snapshot.statistics` returnerar en lista med :class:`Statistic`-"
"instanser."

msgid "See also the :class:`StatisticDiff` class."
msgstr "Se även klassen :class:`StatisticDiff`."

msgid "Number of memory blocks (``int``)."
msgstr "Antal minnesblock (``int``)."

msgid "Total size of memory blocks in bytes (``int``)."
msgstr "Total storlek på minnesblock i byte (``int``)."

msgid ""
"Traceback where the memory block was allocated, :class:`Traceback` instance."
msgstr "Traceback där minnesblocket allokerades, :class:`Traceback` instans."

msgid "StatisticDiff"
msgstr "StatisticDiff"

msgid ""
"Statistic difference on memory allocations between an old and a new :class:"
"`Snapshot` instance."
msgstr ""
"Statistisk skillnad på minnesallokeringar mellan en gammal och en ny :class:"
"`Snapshot`-instans."

msgid ""
":func:`Snapshot.compare_to` returns a list of :class:`StatisticDiff` "
"instances. See also the :class:`Statistic` class."
msgstr ""
":func:`Snapshot.compare_to` returnerar en lista med :class:`StatisticDiff`-"
"instanser. Se även klassen :class:`Statistic`."

msgid ""
"Number of memory blocks in the new snapshot (``int``): ``0`` if the memory "
"blocks have been released in the new snapshot."
msgstr ""
"Antal minnesblock i den nya ögonblicksbilden (``int``): ``0`` om "
"minnesblocken har frigjorts i den nya ögonblicksbilden."

msgid ""
"Difference of number of memory blocks between the old and the new snapshots "
"(``int``): ``0`` if the memory blocks have been allocated in the new "
"snapshot."
msgstr ""
"Skillnad i antal minnesblock mellan den gamla och den nya ögonblicksbilden "
"(``int``): ``0`` om minnesblocken har allokerats i den nya ögonblicksbilden."

msgid ""
"Total size of memory blocks in bytes in the new snapshot (``int``): ``0`` if "
"the memory blocks have been released in the new snapshot."
msgstr ""
"Total storlek på minnesblock i byte i den nya ögonblicksbilden (``int``): "
"``0`` om minnesblocken har frigjorts i den nya ögonblicksbilden."

msgid ""
"Difference of total size of memory blocks in bytes between the old and the "
"new snapshots (``int``): ``0`` if the memory blocks have been allocated in "
"the new snapshot."
msgstr ""
"Skillnad i total storlek på minnesblock i byte mellan den gamla och den nya "
"ögonblicksbilden (``int``): ``0`` om minnesblocken har allokerats i den nya "
"ögonblicksbilden."

msgid ""
"Traceback where the memory blocks were allocated, :class:`Traceback` "
"instance."
msgstr "Traceback där minnesblocken allokerades, :class:`Traceback` instans."

msgid "Trace"
msgstr "Spåra"

msgid "Trace of a memory block."
msgstr "Spårning av ett minnesblock."

msgid ""
"The :attr:`Snapshot.traces` attribute is a sequence of :class:`Trace` "
"instances."
msgstr ""
"Attributet :attr:`Snapshot.traces` är en sekvens av instanser av :class:"
"`Trace`."

msgid "Size of the memory block in bytes (``int``)."
msgstr "Storleken på minnesblocket i byte (``int``)."

msgid "Traceback"
msgstr "Spårning"

msgid ""
"Sequence of :class:`Frame` instances sorted from the oldest frame to the "
"most recent frame."
msgstr ""
"Sekvens av :class:`Frame`-instanser sorterade från den äldsta ramen till den "
"senaste ramen."

msgid ""
"A traceback contains at least ``1`` frame. If the ``tracemalloc`` module "
"failed to get a frame, the filename ``\"<unknown>\"`` at line number ``0`` "
"is used."
msgstr ""
"En traceback innehåller minst ``1`` ram. Om modulen ``tracemalloc`` "
"misslyckades med att hämta en ram används filnamnet ``\"<unknown>\"`` på "
"radnummer ``0``."

msgid ""
"When a snapshot is taken, tracebacks of traces are limited to :func:"
"`get_traceback_limit` frames. See the :func:`take_snapshot` function. The "
"original number of frames of the traceback is stored in the :attr:`Traceback."
"total_nframe` attribute. That allows to know if a traceback has been "
"truncated by the traceback limit."
msgstr ""
"När en ögonblicksbild tas begränsas spårningar av spårningar till :func:"
"`get_traceback_limit`-ramar. Se funktionen :func:`take_snapshot`. Det "
"ursprungliga antalet bildrutor i traceback lagras i attributet :attr:"
"`Traceback.total_nframe`. Det gör det möjligt att veta om en traceback har "
"avkortats av traceback-gränsen."

msgid ""
"The :attr:`Trace.traceback` attribute is an instance of :class:`Traceback` "
"instance."
msgstr ""
"Attributet :attr:`Trace.traceback` är en instans av instansen :class:"
"`Traceback`."

msgid ""
"Frames are now sorted from the oldest to the most recent, instead of most "
"recent to oldest."
msgstr ""
"Ramarna sorteras nu från de äldsta till de senaste, i stället för från de "
"senaste till de äldsta."

msgid ""
"Total number of frames that composed the traceback before truncation. This "
"attribute can be set to ``None`` if the information is not available."
msgstr ""
"Totalt antal bildrutor som utgjorde tracebacken före trunkering. Detta "
"attribut kan sättas till ``None`` om informationen inte är tillgänglig."

msgid "The :attr:`Traceback.total_nframe` attribute was added."
msgstr "Attributet :attr:`Traceback.total_nframe` lades till."

msgid ""
"Format the traceback as a list of lines. Use the :mod:`linecache` module to "
"retrieve lines from the source code. If *limit* is set, format the *limit* "
"most recent frames if *limit* is positive. Otherwise, format the "
"``abs(limit)`` oldest frames. If *most_recent_first* is ``True``, the order "
"of the formatted frames is reversed, returning the most recent frame first "
"instead of last."
msgstr ""
"Formatera traceback som en lista med rader. Använd modulen :mod:`linecache` "
"för att hämta rader från källkoden. Om *limit* är inställt, formatera de "
"*limit* senaste ramarna om *limit* är positiv. I annat fall formateras de "
"``abs(limit)`` äldsta ramarna. Om *most_recent_first* är ``True``, vänds "
"ordningen på de formaterade ramarna och den senaste ramen returneras först "
"istället för sist."

msgid ""
"Similar to the :func:`traceback.format_tb` function, except that :meth:`."
"format` does not include newlines."
msgstr ""
"Liknar funktionen :func:`traceback.format_tb`, förutom att :meth:`.format` "
"inte inkluderar nya rader."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"print(\"Traceback (most recent call first):\")\n"
"for line in traceback:\n"
"    print(line)"
msgstr ""
"print(\"Traceback (most recent call first):\")\n"
"for line in traceback:\n"
"    print(line)"

msgid ""
"Traceback (most recent call first):\n"
"  File \"test.py\", line 9\n"
"    obj = Object()\n"
"  File \"test.py\", line 12\n"
"    tb = tracemalloc.get_object_traceback(f())"
msgstr ""
"Traceback (most recent call first):\n"
"  File \"test.py\", line 9\n"
"    obj = Object()\n"
"  File \"test.py\", line 12\n"
"    tb = tracemalloc.get_object_traceback(f())"
