# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "Så här hämtar du internetresurser med urllib-paketet"

msgid "Author"
msgstr "Författare"

msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""
"Du kanske också tycker att följande artikel om att hämta webbresurser med "
"Python är användbar:"

msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"

msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "En handledning om *Basic Authentication*, med exempel i Python."

msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** är en Python-modul för att hämta URL:er (Uniform Resource "
"Locators). Den erbjuder ett mycket enkelt gränssnitt i form av funktionen "
"*urlopen*. Denna kan hämta webbadresser med hjälp av en mängd olika "
"protokoll. Det finns också ett lite mer komplext gränssnitt för att hantera "
"vanliga situationer - som grundläggande autentisering, cookies, proxies och "
"så vidare. Dessa tillhandahålls av objekt som kallas handlers och openers."

msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request stöder hämtning av webbadresser för många \"URL-"
"scheman\" (identifieras av strängen före ``\":\"`` i URL - till exempel "
"``\"ftp\"`` är URL-schemat för ``\"ftp://python.org/\"``) med hjälp av deras "
"associerade nätverksprotokoll (t.ex. FTP, HTTP). Denna handledning fokuserar "
"på det vanligaste fallet, HTTP."

msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"För okomplicerade situationer är *urlopen* mycket lätt att använda. Men så "
"snart du stöter på fel eller icke-triviala fall när du öppnar HTTP-URL:er "
"behöver du en viss förståelse för HyperText Transfer Protocol. Den mest "
"omfattande och auktoritativa referensen till HTTP är :rfc:`2616`. Detta är "
"ett tekniskt dokument som inte är avsett att vara lättläst. Denna HOWTO "
"syftar till att illustrera användningen av *urllib*, med tillräckligt med "
"detaljer om HTTP för att hjälpa dig igenom. Den är inte avsedd att ersätta :"
"mod:`urllib.request`-dokumenten, utan är ett komplement till dem."

msgid "Fetching URLs"
msgstr "Hämta webbadresser"

msgid "The simplest way to use urllib.request is as follows::"
msgstr "Det enklaste sättet att använda urllib.request är enligt följande::"

msgid ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"
msgstr ""
"import urllib.request\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"   html = response.read()"

msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"Om du vill hämta en resurs via URL och lagra den på en tillfällig plats kan "
"du göra det med hjälp av funktionerna :func:`shutil.copyfileobj` och :func:"
"`tempfile.NamedTemporaryFile`::"

msgid ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"
msgstr ""
"import shutil\n"
"import tempfile\n"
"import urllib.request\n"
"\n"
"with urllib.request.urlopen('http://python.org/') as response:\n"
"    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:\n"
"        shutil.copyfileobj(response, tmp_file)\n"
"\n"
"with open(tmp_file.name) as html:\n"
"    pass"

msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"Många användningar av urllib kommer att vara så enkla (notera att vi i "
"stället för en \"http:\"-URL kunde ha använt en URL som börjar med \"ftp:\", "
"\"file:\" etc.).  Syftet med denna handledning är dock att förklara de mer "
"komplicerade fallen, med fokus på HTTP."

msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP är baserat på förfrågningar och svar - klienten gör förfrågningar och "
"servrar skickar svar. urllib.request speglar detta med ett ``Request``-"
"objekt som representerar den HTTP-förfrågan du gör. I sin enklaste form "
"skapar du ett Request-objekt som specificerar den URL du vill hämta. Om du "
"anropar ``urlopen`` med detta Request-objekt returneras ett svarsobjekt för "
"den begärda URL:en. Detta svar är ett filliknande objekt, vilket innebär att "
"du till exempel kan anropa ``.read()`` på svaret::"

msgid ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.request\n"
"\n"
"req = urllib.request.Request('http://python.org/')\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr ""
"Observera att urllib.request använder samma Request-gränssnitt för att "
"hantera alla URL-scheman.  Du kan till exempel göra en FTP-begäran så här::"

msgid "req = urllib.request.Request('ftp://example.com/')"
msgstr "req = urllib.request.Request('ftp://example.com/')"

msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"När det gäller HTTP finns det två extra saker som Request-objekten gör det "
"möjligt för dig att göra: För det första kan du skicka data som ska skickas "
"till servern.  För det andra kan du skicka extra information (\"metadata\") "
"*om* data eller om själva begäran till servern - denna information skickas "
"som HTTP-\"headers\".  Låt oss titta på var och en av dessa i tur och "
"ordning."

msgid "Data"
msgstr "Data"

msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"Ibland vill man skicka data till en URL (ofta hänvisar URL:en till ett CGI-"
"skript (Common Gateway Interface) eller en annan webbapplikation). Med HTTP "
"görs detta ofta med hjälp av en så kallad **POST**-begäran. Det är ofta vad "
"din webbläsare gör när du skickar in ett HTML-formulär som du fyllt i på "
"webben. Alla POSTs behöver inte komma från formulär: du kan använda en POST "
"för att överföra godtyckliga data till din egen applikation. I det vanliga "
"fallet med HTML-formulär måste data kodas på ett standardiserat sätt och "
"sedan skickas till Request-objektet som argumentet ``data``. Kodningen görs "
"med hjälp av en funktion från :mod:`urllib.parse`-biblioteket. ::"

msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # data should be bytes\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"values = {'name' : 'Michael Foord',\n"
"          'location' : 'Northampton',\n"
"          'language' : 'Python' }\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii') # data should be bytes\n"
"req = urllib.request.Request(url, data)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"Observera att andra kodningar ibland krävs (t.ex. för filuppladdning från "
"HTML-formulär - se `HTML Specification, Form Submission <https://www.w3.org/"
"TR/REC-html40/interact/forms.html#h-17.13>`_ för mer information)."

msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"Om du inte skickar med argumentet ``data`` använder urllib en **GET**-"
"begäran. Ett sätt som GET- och POST-begäranden skiljer sig åt är att POST-"
"begäranden ofta har \"bieffekter\": de ändrar systemets tillstånd på något "
"sätt (till exempel genom att göra en beställning på webbplatsen för att få "
"hundra kilo konserverad skräppost levererad till din dörr).  Även om HTTP-"
"standarden klargör att POST-förfrågningar *alltid* ska orsaka bieffekter och "
"GET-förfrågningar *aldrig* ska orsaka bieffekter, finns det inget som "
"hindrar en GET-förfrågan från att ha bieffekter eller en POST-förfrågan från "
"att inte ha några bieffekter. Data kan också skickas i en HTTP GET-begäran "
"genom att koda den i själva URL:en."

msgid "This is done as follows::"
msgstr "Detta görs på följande sätt::"

msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # The order may differ from below.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = {}\n"
">>> data['name'] = 'Somebody Here'\n"
">>> data['location'] = 'Northampton'\n"
">>> data['language'] = 'Python'\n"
">>> url_values = urllib.parse.urlencode(data)\n"
">>> print(url_values)  # The order may differ from below.\n"
"name=Somebody+Here&language=Python&location=Northampton\n"
">>> url = 'http://www.example.com/example.cgi'\n"
">>> full_url = url + '?' + url_values\n"
">>> data = urllib.request.urlopen(full_url)"

msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""
"Observera att den fullständiga URL:en skapas genom att lägga till en ``?`` "
"till URL:en, följt av de kodade värdena."

msgid "Headers"
msgstr "Sidhuvud"

msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""
"Vi kommer här att diskutera en särskild HTTP-header för att illustrera hur "
"man lägger till headers i en HTTP-begäran."

msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"Vissa webbplatser [#]_ ogillar att surfas av program, eller skickar olika "
"versioner till olika webbläsare [#]_. Som standard identifierar urllib sig "
"själv som ``Python-urllib/x.y`` (där ``x`` och ``y`` är Python-versionens "
"större och mindre versionsnummer, t.ex. ``Python-urllib/2.5``), vilket kan "
"förvirra webbplatsen eller helt enkelt inte fungera. Det sätt på vilket en "
"webbläsare identifierar sig är genom ``User-Agent``-headern [#]_. När du "
"skapar ett Request-objekt kan du skicka in en ordbok med rubriker. Följande "
"exempel gör samma förfrågan som ovan, men identifierar sig själv som en "
"version av Internet Explorer [#]_. ::"

msgid ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"
msgstr ""
"import urllib.parse\n"
"import urllib.request\n"
"\n"
"url = 'http://www.someserver.com/cgi-bin/register.cgi'\n"
"user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'\n"
"values = {'name': 'Michael Foord',\n"
"          'location': 'Northampton',\n"
"          'language': 'Python' }\n"
"headers = {'User-Agent': user_agent}\n"
"\n"
"data = urllib.parse.urlencode(values)\n"
"data = data.encode('ascii')\n"
"req = urllib.request.Request(url, data, headers)\n"
"with urllib.request.urlopen(req) as response:\n"
"   the_page = response.read()"

msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"Svaret har också två användbara metoder. Se avsnittet om `info och geturl`_ "
"som kommer efter att vi har tittat på vad som händer när saker och ting går "
"fel."

msgid "Handling Exceptions"
msgstr "Hantering av undantag"

msgid ""
"*urlopen* raises :exc:`~urllib.error.URLError` when it cannot handle a "
"response (though as usual with Python APIs, built-in exceptions such as :exc:"
"`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen* ger upphov till :exc:`~urllib.error.URLError` när det inte kan "
"hantera ett svar (men som vanligt med Python API:er kan inbyggda undantag "
"som :exc:`ValueError`, :exc:`TypeError` etc. också ges upphov till)."

msgid ""
":exc:`~urllib.error.HTTPError` is the subclass of :exc:`~urllib.error."
"URLError` raised in the specific case of HTTP URLs."
msgstr ""
":exc:`~urllib.error.HTTPError` är underklassen till :exc:`~urllib.error."
"URLError` som uppstår i det specifika fallet med HTTP-URL:er."

msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "Undantagsklasserna exporteras från modulen :mod:`urllib.error`."

msgid "URLError"
msgstr "URLError"

msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"Ofta uppstår URLError på grund av att det inte finns någon "
"nätverksanslutning (ingen väg till den angivna servern) eller att den "
"angivna servern inte existerar.  I detta fall kommer det undantag som "
"uppstår att ha ett \"reason\"-attribut, som är en tupel som innehåller en "
"felkod och ett textfelmeddelande."

msgid "e.g. ::"
msgstr "t.ex. ::"

msgid ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo failed')"
msgstr ""
">>> req = urllib.request.Request('http://www.pretend_server.org')\n"
">>> try: urllib.request.urlopen(req)\n"
"... except urllib.error.URLError as e:\n"
"...     print(e.reason)\n"
"...\n"
"(4, 'getaddrinfo failed')"

msgid "HTTPError"
msgstr "HTTPError"

msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`~urllib.error."
"HTTPError`. Typical errors include '404' (page not found), '403' (request "
"forbidden), and '401' (authentication required)."
msgstr ""
"Varje HTTP-svar från servern innehåller en numerisk \"statuskod\". Ibland "
"indikerar statuskoden att servern inte kan uppfylla begäran. "
"Standardhanterarna kommer att hantera vissa av dessa svar åt dig (om svaret "
"till exempel är en \"omdirigering\" som begär att klienten hämtar dokumentet "
"från en annan URL, kommer urllib att hantera det åt dig). För de som inte "
"kan hanteras kommer urlopen att skapa ett :exc:`~urllib.error.HTTPError`. "
"Typiska fel är '404' (sidan hittades inte), '403' (begäran förbjuden) och "
"'401' (autentisering krävs)."

msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr "Se avsnitt 10 i :rfc:`2616` för en referens till alla HTTP-felkoder."

msgid ""
"The :exc:`~urllib.error.HTTPError` instance raised will have an integer "
"'code' attribute, which corresponds to the error sent by the server."
msgstr ""
"Den :exc:`~urllib.error.HTTPError`-instans som skapas kommer att ha ett "
"heltalsattribut 'code', som motsvarar det fel som skickas av servern."

msgid "Error Codes"
msgstr "Felkoder"

msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"Eftersom standardhanterarna hanterar omdirigeringar (koder i intervallet "
"300), och koder i intervallet 100-299 indikerar framgång, kommer du "
"vanligtvis bara att se felkoder i intervallet 400-599."

msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes that shows all the response codes used by :rfc:`2616`. An "
"excerpt from the dictionary is shown below ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` är en användbar ordbok "
"över svarskoder som visar alla de svarskoder som används av :rfc:`2616`. Ett "
"utdrag från ordlistan visas nedan ::"

msgid ""
"responses = {\n"
"    ...\n"
"    <HTTPStatus.OK: 200>: ('OK', 'Request fulfilled, document follows'),\n"
"    ...\n"
"    <HTTPStatus.FORBIDDEN: 403>: ('Forbidden',\n"
"                                  'Request forbidden -- authorization will "
"'\n"
"                                  'not help'),\n"
"    <HTTPStatus.NOT_FOUND: 404>: ('Not Found',\n"
"                                  'Nothing matches the given URI'),\n"
"    ...\n"
"    <HTTPStatus.IM_A_TEAPOT: 418>: (\"I'm a Teapot\",\n"
"                                    'Server refuses to brew coffee because "
"'\n"
"                                    'it is a teapot'),\n"
"    ...\n"
"    <HTTPStatus.SERVICE_UNAVAILABLE: 503>: ('Service Unavailable',\n"
"                                            'The server cannot process the "
"'\n"
"                                            'request due to a high load'),\n"
"    ...\n"
"    }"
msgstr ""
"svar = {\n"
"    ...\n"
"    <HTTPStatus.OK: 200>: ('OK', 'Begäran uppfylld, dokumentet följer'),\n"
"    ...\n"
"    <HTTPStatus.FORBIDDEN: 403>: ('Förbjuden',\n"
"                                  'Begäran förbjuden -- auktorisering kommer "
"'\n"
"                                  'inte hjälpa'),\n"
"    <HTTPStatus.NOT_FOUND: 404>: ('Hittades inte',\n"
"                                  \"Inget matchar den angivna URI:n\"),\n"
"    ...\n"
"    <HTTPStatus.IM_A_TEAPOT: 418>: (\"Jag är en tekanna\",\n"
"                                    \"Servern vägrar att brygga kaffe "
"eftersom '\n"
"                                    'den är en tekanna'),\n"
"    ...\n"
"    <HTTPStatus.SERVICE_UNAVAILABLE: 503>: ('Tjänsten är inte tillgänglig',\n"
"                                            'Servern kan inte behandla '\n"
"                                            'begäran på grund av hög "
"belastning'),\n"
"    ...\n"
"    }"

msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`~urllib.error.HTTPError` instance "
"as a response on the page returned. This means that as well as the code "
"attribute, it also has read, geturl, and info, methods as returned by the "
"``urllib.response`` module::"
msgstr ""
"När ett fel uppstår svarar servern genom att returnera en HTTP-felkod *och* "
"en felsida. Du kan använda :exc:`~urllib.error.HTTPError`-instansen som ett "
"svar på den returnerade sidan. Detta innebär att förutom kodattributet har "
"den också metoderna read, geturl och info, som returneras av modulen "
"``urllib.response``::"

msgid ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional."
"dtd\">\\n\\n\\n<html\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."
msgstr ""
">>> req = urllib.request.Request('http://www.python.org/fish.html')\n"
">>> try:\n"
"...     urllib.request.urlopen(req)\n"
"... except urllib.error.HTTPError as e:\n"
"...     print(e.code)\n"
"...     print(e.read())\n"
"...\n"
"404\n"
"b'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n"
"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional."
"dtd\">\\n\\n\\n<html\n"
"  ...\n"
"  <title>Page Not Found</title>\\n\n"
"  ..."

msgid "Wrapping it Up"
msgstr "Avslutning"

msgid ""
"So if you want to be prepared for :exc:`~urllib.error.HTTPError` *or* :exc:"
"`~urllib.error.URLError` there are two basic approaches. I prefer the second "
"approach."
msgstr ""
"Så om du vill vara beredd på :exc:`~urllib.error.HTTPError` *eller* :exc:"
"`~urllib.error.URLError` finns det två grundläggande tillvägagångssätt. Jag "
"föredrar det andra tillvägagångssättet."

msgid "Number 1"
msgstr "Nummer 1"

msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError, HTTPError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except HTTPError as e:\n"
"    print('The server couldn\\'t fulfill the request.')\n"
"    print('Error code: ', e.code)\n"
"except URLError as e:\n"
"    print('We failed to reach a server.')\n"
"    print('Reason: ', e.reason)\n"
"else:\n"
"    # everything is fine"

msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`~urllib.error.HTTPError`."
msgstr ""
"``except HTTPError`` *måste* komma först, annars kommer ``except URLError`` "
"*också* att fånga ett :exc:`~urllib.error.HTTPError`."

msgid "Number 2"
msgstr "Nummer 2"

msgid ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # everything is fine"
msgstr ""
"from urllib.request import Request, urlopen\n"
"from urllib.error import URLError\n"
"req = Request(someurl)\n"
"try:\n"
"    response = urlopen(req)\n"
"except URLError as e:\n"
"    if hasattr(e, 'reason'):\n"
"        print('We failed to reach a server.')\n"
"        print('Reason: ', e.reason)\n"
"    elif hasattr(e, 'code'):\n"
"        print('The server couldn\\'t fulfill the request.')\n"
"        print('Error code: ', e.code)\n"
"else:\n"
"    # everything is fine"

msgid "info and geturl"
msgstr "info och geturl"

msgid ""
"The response returned by urlopen (or the :exc:`~urllib.error.HTTPError` "
"instance) has two useful methods :meth:`!info` and :meth:`!geturl` and is "
"defined in the module :mod:`urllib.response`."
msgstr ""
"Svaret som returneras av urlopen (eller instansen :exc:`~urllib.error."
"HTTPError`) har två användbara metoder :meth:`!info` och :meth:`!geturl` och "
"definieras i modulen :mod:`urllib.response`."

msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - returnerar den riktiga URL:en för den hämtade sidan. Detta är "
"användbart eftersom ``urlopen`` (eller det öppningsobjekt som används) kan "
"ha följt en omdirigering. URL:en för den hämtade sidan kanske inte är "
"densamma som den begärda URL:en."

msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - detta returnerar ett ordboksliknande objekt som beskriver den "
"hämtade sidan, särskilt de rubriker som skickats av servern. Det är för "
"närvarande en instans av :class:`http.client.HTTPMessage`."

msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"Typiska rubriker är \"Content-length\", \"Content-type\" och så vidare. I "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ finns en "
"användbar lista över HTTP-rubriker med korta förklaringar av deras betydelse "
"och användning."

msgid "Openers and Handlers"
msgstr "Öppnare och hanterare"

msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"När du hämtar en URL använder du en öppnare (en instans av den kanske "
"förvirrande benämnda :class:`urllib.request.OpenerDirector`). Normalt har vi "
"använt standardöppnaren - via ``urlopen`` - men du kan skapa egna öppnare. "
"Öppnare använder hanterare. Alla \"tunga lyft\" görs av hanterarna. Varje "
"hanterare vet hur man öppnar URL:er för ett visst URL-schema (http, ftp, "
"etc.), eller hur man hanterar en aspekt av URL-öppning, till exempel HTTP-"
"omdirigeringar eller HTTP-cookies."

msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""
"Du behöver skapa öppnare om du vill hämta webbadresser med specifika "
"hanterare installerade, t.ex. för att få en öppnare som hanterar cookies "
"eller för att få en öppnare som inte hanterar omdirigeringar."

msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"För att skapa en öppnare instansierar du en ``OpenerDirector`` och anropar "
"sedan ``.add_handler(some_handler_instance)`` upprepade gånger."

msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"Alternativt kan du använda ``build_opener``, som är en bekvämlighetsfunktion "
"för att skapa öppningsobjekt med ett enda funktionsanrop.  ``build_opener`` "
"lägger till flera hanterare som standard, men ger ett snabbt sätt att lägga "
"till fler och/eller åsidosätta standardhanterarna."

msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""
"Andra typer av hanterare som du kanske vill ha kan hantera proxyservrar, "
"autentisering och andra vanliga men lite specialiserade situationer."

msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"``install_opener`` kan användas för att göra ett ``opener``-objekt till "
"(global) standardöppnare. Detta innebär att anrop till ``urlopen`` kommer "
"att använda den öppnare som du har installerat."

msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"Opener-objekt har en ``open``-metod, som kan anropas direkt för att hämta "
"webbadresser på samma sätt som ``urlopen``-funktionen: det finns inget behov "
"av att anropa ``install_opener``, förutom som en bekvämlighet."

msgid "Basic Authentication"
msgstr "Grundläggande autentisering"

msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <https://web.archive.org/web/20201215133350/http://"
"www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""
"För att illustrera hur man skapar och installerar en hanterare kommer vi att "
"använda ``HTTPBasicAuthHandler``. För en mer detaljerad diskussion om detta "
"ämne - inklusive en förklaring av hur Basic Authentication fungerar - se "
"`Basic Authentication Tutorial <https://web.archive.org/web/20201215133350/"
"http://www.voidspace.org.uk/python/articles/authentication.shtml>`__."

msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"När autentisering krävs skickar servern ett huvud (samt felkoden 401) med en "
"begäran om autentisering.  Detta anger autentiseringsschemat och en "
"\"realm\". Headern ser ut som följer: ``WWW-Authenticate: SCHEME "
"realm=\"REALM\"``."

msgid "e.g."
msgstr "t.ex."

msgid "WWW-Authenticate: Basic realm=\"cPanel Users\""
msgstr "WWW-Autenticate: Basic realm=\"cPanel-användare\""

msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"Klienten bör sedan försöka igen med det lämpliga namnet och lösenordet för "
"sfären som ingår som en rubrik i begäran. Detta är \"grundläggande "
"autentisering\". För att förenkla denna process kan vi skapa en instans av "
"``HTTPBasicAuthHandler`` och en öppnare för att använda denna hanterare."

msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"I ``HTTPBasicAuthHandler`` används ett objekt som kallas lösenordshanterare "
"för att hantera mappningen av URL:er och sfärer till lösenord och "
"användarnamn. Om du vet vad sfären är (från autentiseringshuvudet som "
"skickas av servern) kan du använda en ``HTTPPasswordMgr``. Ofta bryr man sig "
"inte om vad sfären är. I så fall är det bekvämt att använda "
"``HTTPPasswordMgrWithDefaultRealm``. Detta gör att du kan ange ett "
"standardanvändarnamn och lösenord för en URL. Detta kommer att anges om du "
"inte tillhandahåller en alternativ kombination för en specifik sfär. Vi "
"anger detta genom att tillhandahålla ``None`` som realm-argument till "
"metoden ``add_password``."

msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"URL:en på högsta nivån är den första URL:en som kräver autentisering. URL:er "
"som är \"djupare\" än den URL du skickar till .add_password() kommer också "
"att matchas. ::"

msgid ""
"# create a password manager\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# Add the username and password.\n"
"# If we knew the realm, we could use it instead of None.\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, username, password)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# create \"opener\" (OpenerDirector instance)\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# use the opener to fetch a URL\n"
"opener.open(a_url)\n"
"\n"
"# Install the opener.\n"
"# Now all calls to urllib.request.urlopen use our opener.\n"
"urllib.request.install_opener(opener)"
msgstr ""
"# skapa en lösenordshanterare\n"
"password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n"
"\n"
"# Lägg till användarnamn och lösenord.\n"
"# Om vi visste realm skulle vi kunna använda det istället för None.\n"
"top_level_url = \"http://example.com/foo/\"\n"
"password_mgr.add_password(None, top_level_url, användarnamn, lösenord)\n"
"\n"
"handler = urllib.request.HTTPBasicAuthHandler(password_mgr)\n"
"\n"
"# skapa \"opener\" (OpenerDirector-instans)\n"
"opener = urllib.request.build_opener(handler)\n"
"\n"
"# använd öppnaren för att hämta en URL\n"
"opener.open(a_url)\n"
"\n"
"# Installera öppnaren.\n"
"# Nu använder alla anrop till urllib.request.urlopen vår öppnare.\n"
"urllib.request.install_opener(öppnare)"

msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`!http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"I exemplet ovan skickade vi bara vår ``HTTPBasicAuthHandler`` till "
"``build_opener``. Som standard har öppnare hanterare för normala situationer "
"-- ``ProxyHandler`` (om en proxyinställning såsom en :envvar:`!http_proxy` "
"är inställd), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."

msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` är i själva verket *endera* en fullständig URL (inklusive "
"\"http:\"-komponenten och värdnamnet och eventuellt portnumret), t.ex. "
"``\"http://example.com/\"`` *eller* en \"auktoritet\" (dvs. värdnamnet, "
"eventuellt inklusive portnumret), t.ex. ``\"example.com\"`` eller "
"``\"example.com:8080\"`` (det senare exemplet inkluderar ett portnummer).  "
"Den eventuella auktoriteten får INTE innehålla komponenten \"userinfo\" - t."
"ex. är \"joe:password@example.com\" inte korrekt."

msgid "Proxies"
msgstr "Proxies"

msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** kommer automatiskt att upptäcka dina proxyinställningar och "
"använda dem. Detta sker genom ``ProxyHandler``, som är en del av den normala "
"hanteringskedjan när en proxyinställning upptäcks.  Normalt är det bra, men "
"det finns tillfällen då det kanske inte är till hjälp [#]_. Ett sätt att "
"göra detta är att ställa in vår egen ``ProxyHandler``, utan några proxyer "
"definierade. Detta görs genom att använda liknande steg som att sätta upp en "
"`Basic Authentication`_ handler: ::"

msgid ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> opener = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"
msgstr ""
">>> proxy_support = urllib.request.ProxyHandler({})\n"
">>> öppnare = urllib.request.build_opener(proxy_support)\n"
">>> urllib.request.install_opener(opener)"

msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""
"För närvarande har ``urllib.request`` *inte* stöd för hämtning av ``https``-"
"platser via en proxy.  Detta kan dock aktiveras genom att utöka urllib."
"request som visas i receptet [#]_."

msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` ignoreras om en variabel ``REQUEST_METHOD`` är inställd; se "
"dokumentationen för :func:`~urllib.request.getproxies`."

msgid "Sockets and Layers"
msgstr "Socklar och lager"

msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""
"Python-stödet för att hämta resurser från webben är uppdelat i flera lager. "
"urllib använder biblioteket :mod:`http.client`, som i sin tur använder "
"socket-biblioteket."

msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""
"Från och med Python 2.3 kan du ange hur länge en socket ska vänta på ett "
"svar innan tidsgränsen överskrids. Detta kan vara användbart i applikationer "
"som måste hämta webbsidor. Som standard har socket-modulen *ingen timeout* "
"och kan hänga sig. För närvarande är socket timeout inte exponerad på http."
"client eller urllib.request nivåerna. Du kan dock ställa in standardtimeout "
"globalt för alla socklar med ::"

msgid ""
"import socket\n"
"import urllib.request\n"
"\n"
"# timeout in seconds\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# this call to urllib.request.urlopen now uses the default timeout\n"
"# we have set in the socket module\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"
msgstr ""
"import socket\n"
"import urllib.request\n"
"\n"
"# timeout in seconds\n"
"timeout = 10\n"
"socket.setdefaulttimeout(timeout)\n"
"\n"
"# this call to urllib.request.urlopen now uses the default timeout\n"
"# we have set in the socket module\n"
"req = urllib.request.Request('http://www.voidspace.org.uk')\n"
"response = urllib.request.urlopen(req)"

msgid "Footnotes"
msgstr "Fotnoter"

msgid "This document was reviewed and revised by John Lee."
msgstr "Detta dokument har granskats och reviderats av John Lee."

msgid "Google for example."
msgstr "Google till exempel."

msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"Browser sniffing är en mycket dålig metod för webbplatsdesign - att bygga "
"webbplatser med hjälp av webbstandarder är mycket mer förnuftigt. Tyvärr "
"skickar många webbplatser fortfarande olika versioner till olika webbläsare."

msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"Användaragenten för MSIE 6 är *'Mozilla/4.0 (kompatibel; MSIE 6.0; Windows "
"NT 5.1; SV1; .NET CLR 1.1.4322)'*"

msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""
"För mer information om HTTP-rubriker, se Snabbreferens till HTTP-rubriker."

msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"I mitt fall måste jag använda en proxy för att komma åt internet på jobbet. "
"Om du försöker hämta *localhost* webbadresser via den här proxyn blockeras "
"de. IE är inställt på att använda proxyn, vilket urllib känner av. För att "
"kunna testa skript med en localhost-server måste jag hindra urllib från att "
"använda proxyn."

msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-proxy-connect-"
"method/>`_."
msgstr ""
"urllib-öppnare för SSL-proxy (CONNECT-metoden): `ASPN kokboksrecept <https://"
"code.activestate.com/recipes/456195-urrlib2-opener-for-ssl-proxy-connect-"
"method/>`_."
