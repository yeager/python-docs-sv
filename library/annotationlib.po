# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!annotationlib` --- Functionality for introspecting annotations"
msgstr ""
":mod:`!annotationlib` --- Funktionalitet för introspektion av annoteringar"

msgid "**Source code:** :source:`Lib/annotationlib.py`"
msgstr "**Källkod:** :source:`Lib/annotationlib.py`"

msgid ""
"The :mod:`!annotationlib` module provides tools for introspecting :term:"
"`annotations <annotation>` on modules, classes, and functions."
msgstr ""
"Modulen :mod:`!annotationlib` tillhandahåller verktyg för introspektion av :"
"term:`annotationer <annotation>` på moduler, klasser och funktioner."

msgid ""
"Annotations are :ref:`lazily evaluated <lazy-evaluation>` and often contain "
"forward references to objects that are not yet defined when the annotation "
"is created. This module provides a set of low-level tools that can be used "
"to retrieve annotations in a reliable way, even in the presence of forward "
"references and other edge cases."
msgstr ""
"Annotationer är :ref:``långsamt utvärderade <lazy-evaluation>` och "
"innehåller ofta framåtriktade referenser till objekt som ännu inte är "
"definierade när annotationen skapas. Den här modulen innehåller en "
"uppsättning lågnivåverktyg som kan användas för att hämta annoteringar på "
"ett tillförlitligt sätt, även om det finns framåtriktade referenser och "
"andra gränsfall."

msgid ""
"This module supports retrieving annotations in three main formats (see :"
"class:`Format`), each of which works best for different use cases:"
msgstr ""
"Den här modulen stöder hämtning av anteckningar i tre huvudformat (se :class:"
"`Format`), som var och en fungerar bäst för olika användningsfall:"

msgid ""
":attr:`~Format.VALUE` evaluates the annotations and returns their value. "
"This is most straightforward to work with, but it may raise errors, for "
"example if the annotations contain references to undefined names."
msgstr ""
":attr:`~Format.VALUE` utvärderar annoteringarna och returnerar deras värde. "
"Detta är enklast att arbeta med, men det kan ge upphov till fel, t.ex. om "
"annotationerna innehåller referenser till odefinierade namn."

msgid ""
":attr:`~Format.FORWARDREF` returns :class:`ForwardRef` objects for "
"annotations that cannot be resolved, allowing you to inspect the annotations "
"without evaluating them. This is useful when you need to work with "
"annotations that may contain unresolved forward references."
msgstr ""
":attr:`~Format.FORWARDREF` returnerar :class:`ForwardRef`-objekt för "
"annoteringar som inte kan lösas, vilket gör att du kan inspektera "
"annoteringarna utan att utvärdera dem. Detta är användbart när du behöver "
"arbeta med annoteringar som kan innehålla olösta framåtriktade referenser."

msgid ""
":attr:`~Format.STRING` returns the annotations as a string, similar to how "
"it would appear in the source file. This is useful for documentation "
"generators that want to display annotations in a readable way."
msgstr ""
":attr:`~Format.STRING` returnerar anteckningarna som en sträng, liknande hur "
"de skulle se ut i källfilen. Detta är användbart för "
"dokumentationsgeneratorer som vill visa anteckningar på ett läsbart sätt."

msgid ""
"The :func:`get_annotations` function is the main entry point for retrieving "
"annotations. Given a function, class, or module, it returns an annotations "
"dictionary in the requested format. This module also provides functionality "
"for working directly with the :term:`annotate function` that is used to "
"evaluate annotations, such as :func:`get_annotate_from_class_namespace` and :"
"func:`call_annotate_function`, as well as the :func:`call_evaluate_function` "
"function for working with :term:`evaluate functions <evaluate function>`."
msgstr ""
"Funktionen :func:`get_annotations` är den huvudsakliga ingångspunkten för "
"att hämta anteckningar. Om en funktion, klass eller modul anges returnerar "
"den en annotationsordbok i det begärda formatet. Den här modulen innehåller "
"också funktioner för att arbeta direkt med :term:`annotate function` som "
"används för att utvärdera anteckningar, till exempel :func:"
"`get_annotate_from_class_namespace` och :func:`call_annotate_function`, samt "
"funktionen :func:`call_evaluate_function` för att arbeta med :term:`evaluate "
"functions <evaluate function>`."

msgid ""
":pep:`649` proposed the current model for how annotations work in Python."
msgstr ""
":pep:`649` föreslog den nuvarande modellen för hur annoteringar fungerar i "
"Python."

msgid ""
":pep:`749` expanded on various aspects of :pep:`649` and introduced the :mod:"
"`!annotationlib` module."
msgstr ""
":pep:`749` utvidgade olika aspekter av :pep:`649` och introducerade modulen :"
"mod:`!annotationlib`."

msgid ""
":ref:`annotations-howto` provides best practices for working with "
"annotations."
msgstr ""
":ref:`annotations-howto` ger bästa praxis för att arbeta med annoteringar."

msgid ""
":pypi:`typing-extensions` provides a backport of :func:`get_annotations` "
"that works on earlier versions of Python."
msgstr ""
":pypi:`typing-extensions` tillhandahåller en backport av :func:"
"`get_annotations` som fungerar på tidigare versioner av Python."

msgid "Annotation semantics"
msgstr "Semantik för annoteringar"

msgid ""
"The way annotations are evaluated has changed over the history of Python 3, "
"and currently still depends on a :ref:`future import <future>`. There have "
"been execution models for annotations:"
msgstr ""
"Hur annoteringar utvärderas har förändrats under Python 3:s historia, och "
"beror för närvarande fortfarande på en :ref:`future import <future>`. Det "
"har funnits exekveringsmodeller för annotationer:"

msgid ""
"*Stock semantics* (default in Python 3.0 through 3.13; see :pep:`3107` and :"
"pep:`526`): Annotations are evaluated eagerly, as they are encountered in "
"the source code."
msgstr ""
"*Stock semantics* (standard i Python 3.0 till och med 3.13; se :pep:`3107` "
"och :pep:`526`): Annoteringar utvärderas ivrigt, när de påträffas i "
"källkoden."

msgid ""
"*Stringified annotations* (used with ``from __future__ import annotations`` "
"in Python 3.7 and newer; see :pep:`563`): Annotations are stored as strings "
"only."
msgstr ""
"*Stringifierade annoteringar* (används med ``from __future__ import "
"annotations`` i Python 3.7 och senare; se :pep:`563`): Annotationer lagras "
"endast som strängar."

msgid ""
"*Deferred evaluation* (default in Python 3.14 and newer; see :pep:`649` and :"
"pep:`749`): Annotations are evaluated lazily, only when they are accessed."
msgstr ""
"*Uppskjuten utvärdering* (standard i Python 3.14 och nyare; se :pep:`649` "
"och :pep:`749`): Annoteringar utvärderas latent, endast när de används."

msgid "As an example, consider the following program::"
msgstr "Som ett exempel kan man tänka sig följande program::"

msgid ""
"def func(a: Cls) -> None:\n"
"    print(a)\n"
"\n"
"class Cls: pass\n"
"\n"
"print(func.__annotations__)"
msgstr ""
"def func(a: Cls) -> Ingen:\n"
"    print(a)\n"
"\n"
"klass Cls: pass\n"
"\n"
"print(func.__annotations__)"

msgid "This will behave as follows:"
msgstr "Detta kommer att bete sig på följande sätt:"

msgid ""
"Under stock semantics (Python 3.13 and earlier), it will throw a :exc:"
"`NameError` at the line where ``func`` is defined, because ``Cls`` is an "
"undefined name at that point."
msgstr ""
"Under standardsemantik (Python 3.13 och tidigare) kommer den att kasta ett :"
"exc:`NameError` på raden där ``func`` definieras, eftersom ``Cls`` är ett "
"odefinierat namn vid den tidpunkten."

msgid ""
"Under stringified annotations (if ``from __future__ import annotations`` is "
"used), it will print ``{'a': 'Cls', 'return': 'None'}``."
msgstr ""
"Under strängifierade anteckningar (om ``from __future__ import annotations`` "
"används) kommer den att skriva ut ``{'a': 'Cls', 'return': 'None'}``."

msgid ""
"Under deferred evaluation (Python 3.14 and later), it will print ``{'a': "
"<class 'Cls'>, 'return': None}``."
msgstr ""
"Under uppskjuten utvärdering (Python 3.14 och senare) kommer den att skriva "
"ut ``{'a': <klass 'Cls'>, 'return': None}``."

msgid ""
"Stock semantics were used when function annotations were first introduced in "
"Python 3.0 (by :pep:`3107`) because this was the simplest, most obvious way "
"to implement annotations. The same execution model was used when variable "
"annotations were introduced in Python 3.6 (by :pep:`526`). However, stock "
"semantics caused problems when using annotations as type hints, such as a "
"need to refer to names that are not yet defined when the annotation is "
"encountered. In addition, there were performance problems with executing "
"annotations at module import time. Therefore, in Python 3.7, :pep:`563` "
"introduced the ability to store annotations as strings using the ``from "
"__future__ import annotations`` syntax. The plan at the time was to "
"eventually make this behavior the default, but a problem appeared: "
"stringified annotations are more difficult to process for those who "
"introspect annotations at runtime. An alternative proposal, :pep:`649`, "
"introduced the third execution model, deferred evaluation, and was "
"implemented in Python 3.14. Stringified annotations are still used if ``from "
"__future__ import annotations`` is present, but this behavior will "
"eventually be removed."
msgstr ""
"Stocksemantik användes när funktionsannoteringar först introducerades i "
"Python 3.0 (av :pep:`3107`) eftersom detta var det enklaste och mest "
"uppenbara sättet att implementera annoteringar. Samma exekveringsmodell "
"användes när variabelannoteringar introducerades i Python 3.6 (av :pep:"
"`526`). Stocksemantik orsakade dock problem när man använde annotationer som "
"typtips, till exempel ett behov av att hänvisa till namn som ännu inte är "
"definierade när annotationen påträffas. Dessutom fanns det prestandaproblem "
"med att exekvera annotationer vid modulimport. Därför introducerade :pep:"
"`563` i Python 3.7 möjligheten att lagra annotationer som strängar med "
"syntaxen ``from __future__ import annotations``. Planen vid den tidpunkten "
"var att så småningom göra detta beteende till standard, men ett problem "
"uppstod: strängifierade annoteringar är svårare att bearbeta för dem som "
"introspekterar annoteringar vid körning. Ett alternativt förslag, :pep:"
"`649`, introducerade den tredje exekveringsmodellen, uppskjuten utvärdering, "
"och implementerades i Python 3.14. Stringifierade annoteringar används "
"fortfarande om ``from __future__ import annotations`` är närvarande, men "
"detta beteende kommer så småningom att tas bort."

msgid "Classes"
msgstr "Klasser"

msgid ""
"An :class:`~enum.IntEnum` describing the formats in which annotations can be "
"returned. Members of the enum, or their equivalent integer values, can be "
"passed to :func:`get_annotations` and other functions in this module, as "
"well as to :attr:`~object.__annotate__` functions."
msgstr ""
"En :class:`~enum.IntEnum` som beskriver de format i vilka anteckningar kan "
"returneras. Medlemmar i enum, eller deras motsvarande heltalsvärden, kan "
"skickas till :func:`get_annotations` och andra funktioner i denna modul, "
"samt till :attr:`~object.__annotate__` funktioner."

msgid "Values are the result of evaluating the annotation expressions."
msgstr "Värdena är resultatet av utvärderingen av annoteringsuttrycken."

msgid ""
"Special value used to signal that an annotate function is being evaluated in "
"a special environment with fake globals. When passed this value, annotate "
"functions should either return the same value as for the :attr:`Format."
"VALUE` format, or raise :exc:`NotImplementedError` to signal that they do "
"not support execution in this environment. This format is only used "
"internally and should not be passed to the functions in this module."
msgstr ""
"Specialvärde som används för att signalera att en annotate-funktion "
"utvärderas i en speciell miljö med falska globaler. När detta värde skickas "
"till annotate-funktioner ska de antingen returnera samma värde som för "
"formatet :attr:`Format.VALUE`, eller ge upphov till :exc:"
"`NotImplementedError` för att signalera att de inte stöder exekvering i "
"denna miljö. Detta format används endast internt och bör inte skickas till "
"funktionerna i denna modul."

msgid ""
"Values are real annotation values (as per :attr:`Format.VALUE` format) for "
"defined values, and :class:`ForwardRef` proxies for undefined values. Real "
"objects may contain references to :class:`ForwardRef` proxy objects."
msgstr ""
"Värdena är verkliga annoteringsvärden (enligt formatet :attr:`Format.VALUE`) "
"för definierade värden och :class:`ForwardRef`-proxyer för odefinierade "
"värden. Verkliga objekt kan innehålla referenser till :class:`ForwardRef` "
"proxyobjekt."

msgid ""
"Values are the text string of the annotation as it appears in the source "
"code, up to modifications including, but not restricted to, whitespace "
"normalizations and constant values optimizations."
msgstr ""
"Värdena är textsträngen i annotationen som den visas i källkoden, upp till "
"ändringar inklusive, men inte begränsat till, normaliseringar av blanksteg "
"och optimeringar av konstantvärden."

msgid ""
"The exact values of these strings may change in future versions of Python."
msgstr ""
"De exakta värdena för dessa strängar kan komma att ändras i framtida "
"versioner av Python."

msgid "A proxy object for forward references in annotations."
msgstr "Ett proxyobjekt för framåtriktade referenser i annotationer."

msgid ""
"Instances of this class are returned when the :attr:`~Format.FORWARDREF` "
"format is used and annotations contain a name that cannot be resolved. This "
"can happen when a forward reference is used in an annotation, such as when a "
"class is referenced before it is defined."
msgstr ""
"Instanser av denna klass returneras när formatet :attr:`~Format.FORWARDREF` "
"används och annotationer innehåller ett namn som inte kan lösas. Detta kan "
"inträffa när en framåtriktad referens används i en annotering, t.ex. när en "
"klass refereras innan den har definierats."

msgid ""
"A string containing the code that was evaluated to produce the :class:"
"`~ForwardRef`. The string may not be exactly equivalent to the original "
"source."
msgstr ""
"En sträng som innehåller den kod som utvärderades för att producera :class:"
"`~ForwardRef`. Strängen kanske inte är exakt likvärdig med den ursprungliga "
"källan."

msgid "Evaluate the forward reference, returning its value."
msgstr "Utvärdera den framåtriktade referensen och återge dess värde."

msgid ""
"If the *format* argument is :attr:`~Format.VALUE` (the default), this method "
"may throw an exception, such as :exc:`NameError`, if the forward reference "
"refers to a name that cannot be resolved. The arguments to this method can "
"be used to provide bindings for names that would otherwise be undefined. If "
"the *format* argument is :attr:`~Format.FORWARDREF`, the method will never "
"throw an exception, but may return a :class:`~ForwardRef` instance. For "
"example, if the forward reference object contains the code "
"``list[undefined]``, where ``undefined`` is a name that is not defined, "
"evaluating it with the :attr:`~Format.FORWARDREF` format will return "
"``list[ForwardRef('undefined')]``. If the *format* argument is :attr:"
"`~Format.STRING`, the method will return :attr:`~ForwardRef.__forward_arg__`."
msgstr ""
"Om argumentet *format* är :attr:`~Format.VALUE` (standard) kan den här "
"metoden ge upphov till ett undantag, t.ex. :exc:`NameError`, om den "
"framåtriktade referensen hänvisar till ett namn som inte kan lösas. "
"Argumenten till denna metod kan användas för att tillhandahålla bindningar "
"för namn som annars skulle vara odefinierade. Om argumentet *format* är :"
"attr:`~Format.FORWARDREF`, kommer metoden aldrig att ge upphov till ett "
"undantag, men kan returnera en :class:`~ForwardRef`-instans. Om till exempel "
"forward reference-objektet innehåller koden ``list[undefined]``, där "
"``undefined`` är ett namn som inte är definierat, kommer utvärderingen med :"
"attr:`~Format.FORWARDREF`-formatet att returnera "
"``list[ForwardRef('undefined')]``. Om argumentet *format* är :attr:`~Format."
"STRING`, kommer metoden att returnera :attr:`~ForwardRef.__forward_arg__`."

msgid ""
"The *owner* parameter provides the preferred mechanism for passing scope "
"information to this method. The owner of a :class:`~ForwardRef` is the "
"object that contains the annotation from which the :class:`~ForwardRef` "
"derives, such as a module object, type object, or function object."
msgstr ""
"Parametern *owner* anger vilken mekanism som föredras för att skicka "
"information om omfattning till denna metod. Ägaren till en :class:"
"`~ForwardRef` är det objekt som innehåller den annotation som :class:"
"`~ForwardRef` härrör från, t.ex. ett modulobjekt, typobjekt eller "
"funktionsobjekt."

msgid ""
"The *globals*, *locals*, and *type_params* parameters provide a more precise "
"mechanism for influencing the names that are available when the :class:"
"`~ForwardRef` is evaluated. *globals* and *locals* are passed to :func:"
"`eval`, representing the global and local namespaces in which the name is "
"evaluated. The *type_params* parameter is relevant for objects created using "
"the native syntax for :ref:`generic classes <generic-classes>` and :ref:"
"`functions <generic-functions>`. It is a tuple of :ref:`type parameters "
"<type-params>` that are in scope while the forward reference is being "
"evaluated. For example, if evaluating a :class:`~ForwardRef` retrieved from "
"an annotation found in the class namespace of a generic class ``C``, "
"*type_params* should be set to ``C.__type_params__``."
msgstr ""
"Parametrarna *globals*, *locals* och *type_params* ger en mer exakt mekanism "
"för att påverka de namn som är tillgängliga när :class:`~ForwardRef` "
"utvärderas. *globals* och *locals* skickas till :func:`eval` och "
"representerar de globala och lokala namnrymder i vilka namnet utvärderas. "
"Parametern *type_params* är relevant för objekt som skapas med den "
"ursprungliga syntaxen för :ref:`generic classes <generic-classes>` och :ref:"
"`functions <generic-functions>`. Det är en tupel av :ref:`typ-parametrar "
"<type-params>` som är i omfattning medan den framåtriktade referensen "
"utvärderas. Om man t.ex. utvärderar en :class:`~ForwardRef` som hämtats från "
"en annotation som finns i klassnamnrymden för en generisk klass ``C``, bör "
"*type_params* sättas till ``C.__type_params__``."

msgid ""
":class:`~ForwardRef` instances returned by :func:`get_annotations` retain "
"references to information about the scope they originated from, so calling "
"this method with no further arguments may be sufficient to evaluate such "
"objects. :class:`~ForwardRef` instances created by other means may not have "
"any information about their scope, so passing arguments to this method may "
"be necessary to evaluate them successfully."
msgstr ""
":class:`~ForwardRef`-instanser som returneras av :func:`get_annotations` "
"behåller referenser till information om det scope de härstammar från, så det "
"kan räcka med att anropa denna metod utan ytterligare argument för att "
"utvärdera sådana objekt. :class:`~ForwardRef`-instanser som skapas på annat "
"sätt kanske inte har någon information om sitt scope, så det kan vara "
"nödvändigt att skicka argument till denna metod för att utvärdera dem "
"framgångsrikt."

msgid ""
"If no *owner*, *globals*, *locals*, or *type_params* are provided and the :"
"class:`~ForwardRef` does not contain information about its origin, empty "
"globals and locals dictionaries are used."
msgstr ""
"Om inga *owner*, *globals*, *locals* eller *type_params* anges och :class:"
"`~ForwardRef` inte innehåller information om sitt ursprung, används tomma "
"globals- och locals-ordlistor."

msgid "Functions"
msgstr "Funktioner"

msgid ""
"Convert an annotations dict containing runtime values to a dict containing "
"only strings. If the values are not already strings, they are converted "
"using :func:`type_repr`. This is meant as a helper for user-provided "
"annotate functions that support the :attr:`~Format.STRING` format but do not "
"have access to the code creating the annotations."
msgstr ""
"Konverterar en annotationsdikt som innehåller runtime-värden till en dikt "
"som bara innehåller strängar. Om värdena inte redan är strängar konverteras "
"de med hjälp av :func:`type_repr`. Detta är tänkt som en hjälp för "
"användartillhandahållna annotate-funktioner som stöder formatet :attr:"
"`~Format.STRING` men som inte har tillgång till koden som skapar "
"annotationerna."

msgid ""
"For example, this is used to implement the :attr:`~Format.STRING` for :class:"
"`typing.TypedDict` classes created through the functional syntax:"
msgstr ""
"Detta används t.ex. för att implementera :attr:`~Format.STRING` för :class:"
"`typing.TypedDict`-klasser som skapats genom den funktionella syntaxen:"

msgid ""
">>> from typing import TypedDict\n"
">>> Movie = TypedDict(\"movie\", {\"name\": str, \"year\": int})\n"
">>> get_annotations(Movie, format=Format.STRING)\n"
"{'name': 'str', 'year': 'int'}"
msgstr ""
">>> from typing import TypedDict\n"
">>> Movie = TypedDict(\"movie\", {\"name\": str, \"year\": int})\n"
">>> get_annotations(Movie, format=Format.STRING)\n"
"{'namn': 'str', 'år': 'int'}"

msgid ""
"Call the :term:`annotate function` *annotate* with the given *format*, a "
"member of the :class:`Format` enum, and return the annotations dictionary "
"produced by the function."
msgstr ""
"Anropa :term:`annotate-funktionen` *annotate* med det angivna *formatet*, en "
"medlem av enum :class:`Format`, och returnera den annoteringsordbok som "
"funktionen har producerat."

msgid ""
"This helper function is required because annotate functions generated by the "
"compiler for functions, classes, and modules only support the :attr:`~Format."
"VALUE` format when called directly. To support other formats, this function "
"calls the annotate function in a special environment that allows it to "
"produce annotations in the other formats. This is a useful building block "
"when implementing functionality that needs to partially evaluate annotations "
"while a class is being constructed."
msgstr ""
"Denna hjälpfunktion behövs eftersom annoteringsfunktioner som genereras av "
"kompilatorn för funktioner, klasser och moduler endast stöder formatet :attr:"
"`~Format.VALUE` när de anropas direkt. För att stödja andra format anropar "
"den här funktionen annotate-funktionen i en speciell miljö som gör det "
"möjligt att producera annotationer i de andra formaten. Detta är en "
"användbar byggsten när man implementerar funktionalitet som delvis behöver "
"utvärdera annotationer medan en klass konstrueras."

msgid ""
"*owner* is the object that owns the annotation function, usually a function, "
"class, or module. If provided, it is used in the :attr:`~Format.FORWARDREF` "
"format to produce a :class:`ForwardRef` object that carries more information."
msgstr ""
"*owner* är det objekt som äger annoteringsfunktionen, vanligtvis en "
"funktion, klass eller modul. Om det anges används det i formatet :attr:"
"`~Format.FORWARDREF` för att producera ett :class:`ForwardRef`-objekt som "
"innehåller mer information."

msgid ""
":PEP:`PEP 649 <649#the-stringizer-and-the-fake-globals-environment>` "
"contains an explanation of the implementation technique used by this "
"function."
msgstr ""
":PEP:`PEP 649 <649#the-stringizer-and-the-fake-globals-environment>` "
"innehåller en förklaring av den implementeringsteknik som används av denna "
"funktion."

msgid ""
"Call the :term:`evaluate function` *evaluate* with the given *format*, a "
"member of the :class:`Format` enum, and return the value produced by the "
"function. This is similar to :func:`call_annotate_function`, but the latter "
"always returns a dictionary mapping strings to annotations, while this "
"function returns a single value."
msgstr ""
"Anropar :term:`evaluate-funktionen` *evaluate* med det angivna *formatet*, "
"en medlem av enum :class:`Format`, och returnerar det värde som funktionen "
"producerar. Detta liknar :func:`call_annotate_function`, men den senare "
"returnerar alltid en ordbok som mappar strängar till annoteringar, medan "
"denna funktion returnerar ett enda värde."

msgid ""
"This is intended for use with the evaluate functions generated for lazily "
"evaluated elements related to type aliases and type parameters:"
msgstr ""
"Detta är avsett att användas med de utvärderingsfunktioner som genereras för "
"latent utvärderade element relaterade till typaliaser och typparametrar:"

msgid ":meth:`typing.TypeAliasType.evaluate_value`, the value of type aliases"
msgstr ":meth:`typing.TypeAliasType.evaluate_value`, värdet av typaliaser"

msgid ":meth:`typing.TypeVar.evaluate_bound`, the bound of type variables"
msgstr ":meth:`typing.TypeVar.evaluate_bound`, bindning av typvariabler"

msgid ""
":meth:`typing.TypeVar.evaluate_constraints`, the constraints of type "
"variables"
msgstr ""
":meth:`typing.TypeVar.evaluate_constraints`, begränsningarna för typvariabler"

msgid ""
":meth:`typing.TypeVar.evaluate_default`, the default value of type variables"
msgstr ""
":meth:`typing.TypeVar.evaluate_default`, standardvärdet för typvariabler"

msgid ""
":meth:`typing.ParamSpec.evaluate_default`, the default value of parameter "
"specifications"
msgstr ""
":meth:`typing.ParamSpec.evaluate_default`, standardvärdet för "
"parameterspecifikationer"

msgid ""
":meth:`typing.TypeVarTuple.evaluate_default`, the default value of type "
"variable tuples"
msgstr ""
":meth:`typing.TypeVarTuple.evaluate_default`, standardvärdet för "
"typvariabeltuplar"

msgid ""
"*owner* is the object that owns the evaluate function, such as the type "
"alias or type variable object."
msgstr ""
"*owner* är det objekt som äger funktionen evaluate, t.ex. typalias eller "
"typvariabelobjekt."

msgid ""
"*format* can be used to control the format in which the value is returned:"
msgstr ""
"*format* kan användas för att styra det format som värdet returneras i:"

msgid ""
">>> type Alias = undefined\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.VALUE)\n"
"Traceback (most recent call last):\n"
"...\n"
"NameError: name 'undefined' is not defined\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.FORWARDREF)\n"
"ForwardRef('undefined')\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.STRING)\n"
"'undefined'"
msgstr ""
">>> typ Alias = odefinierad\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.VALUE)\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"NameError: namnet 'undefined' är inte definierat\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.FORWARDREF)\n"
"ForwardRef('odefinierad')\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.STRING)\n"
"'odefinierad'"

msgid ""
"Retrieve the :term:`annotate function` from a class namespace dictionary "
"*namespace*. Return :const:`!None` if the namespace does not contain an "
"annotate function. This is primarily useful before the class has been fully "
"created (e.g., in a metaclass); after the class exists, the annotate "
"function can be retrieved with ``cls.__annotate__``. See :ref:`below "
"<annotationlib-metaclass>` for an example using this function in a metaclass."
msgstr ""
"Hämtar :term:`annotate function` från en klassnamnrymdsordbok *namnrymd*. "
"Returnerar :const:`!None` om namnrymden inte innehåller någon annotate-"
"funktion. Detta är främst användbart innan klassen har skapats helt (t.ex. i "
"en metaklass); när klassen finns kan annotate-funktionen hämtas med ``cls."
"__annotate__``. Se :ref:`below <annotationlib-metaclass>` för ett exempel på "
"användning av denna funktion i en metaklass."

msgid "Compute the annotations dict for an object."
msgstr "Beräkna annoteringsdikten för ett objekt."

msgid ""
"*obj* may be a callable, class, module, or other object with :attr:`~object."
"__annotate__` or :attr:`~object.__annotations__` attributes. Passing any "
"other object raises :exc:`TypeError`."
msgstr ""
"*obj* kan vara en anropsbar, klass, modul eller annat objekt med :attr:"
"`~object.__annotate__` eller :attr:`~object.__annotations__` attribut. Att "
"skicka något annat objekt ger upphov till :exc:`TypeError`."

msgid ""
"The *format* parameter controls the format in which annotations are "
"returned, and must be a member of the :class:`Format` enum or its integer "
"equivalent. The different formats work as follows:"
msgstr ""
"Parametern *format* styr det format i vilket anteckningarna returneras och "
"måste vara en medlem i enum :class:`Format` eller dess heltalsekvivalent. De "
"olika formaten fungerar på följande sätt:"

msgid ""
"VALUE: :attr:`!object.__annotations__` is tried first; if that does not "
"exist, the :attr:`!object.__annotate__` function is called if it exists."
msgstr ""
"VÄRDE: :attr:`!object.__annotations__` prövas först; om den inte finns "
"anropas funktionen :attr:`!object.__annotate__` om den finns."

msgid ""
"FORWARDREF: If :attr:`!object.__annotations__` exists and can be evaluated "
"successfully, it is used; otherwise, the :attr:`!object.__annotate__` "
"function is called. If it does not exist either, :attr:`!object."
"__annotations__` is tried again and any error from accessing it is re-raised."
msgstr ""
"FORWARDREF: Om :attr:`!object.__annotations__` finns och kan utvärderas "
"framgångsrikt, används den; annars anropas funktionen :attr:`!object."
"__annotate__`. Om den inte heller finns, försöker :attr:`!object."
"__annotations__` igen och eventuella fel från åtkomsten till den tas upp "
"igen."

msgid ""
"STRING: If :attr:`!object.__annotate__` exists, it is called first; "
"otherwise, :attr:`!object.__annotations__` is used and stringified using :"
"func:`annotations_to_string`."
msgstr ""
"STRING: Om :attr:`!object.__annotate__` finns, anropas den först; annars "
"används :attr:`!object.__annotations__` och strängifieras med :func:"
"`annotations_to_string`."

msgid ""
"Returns a dict. :func:`!get_annotations` returns a new dict every time it's "
"called; calling it twice on the same object will return two different but "
"equivalent dicts."
msgstr ""
"Returnerar en dict. :func:`!get_annotations` returnerar en ny dict varje "
"gång den anropas; om den anropas två gånger på samma objekt returneras två "
"olika men likvärdiga dicts."

msgid "This function handles several details for you:"
msgstr "Denna funktion hanterar flera detaljer åt dig:"

msgid ""
"If *eval_str* is true, values of type :class:`!str` will be un-stringized "
"using :func:`eval`. This is intended for use with stringized annotations "
"(``from __future__ import annotations``). It is an error to set *eval_str* "
"to true with formats other than :attr:`Format.VALUE`."
msgstr ""
"Om *eval_str* är true, kommer värden av typen :class:`!str` att avsträngas "
"med hjälp av :func:`eval`. Detta är avsett att användas med strängade "
"annotationer (``from __future__ import annotations``). Det är ett fel att "
"sätta *eval_str* till true med andra format än :attr:`Format.VALUE`."

msgid ""
"If *obj* doesn't have an annotations dict, returns an empty dict. (Functions "
"and methods always have an annotations dict; classes, modules, and other "
"types of callables may not.)"
msgstr ""
"Om *obj* inte har någon annotationsdikt returneras en tom dikt. (Funktioner "
"och metoder har alltid en annotationsdikt; klasser, moduler och andra typer "
"av anropsbara objekt kanske inte har det)"

msgid ""
"Ignores inherited annotations on classes, as well as annotations on "
"metaclasses. If a class doesn't have its own annotations dict, returns an "
"empty dict."
msgstr ""
"Ignorerar ärvda annotationer på klasser, liksom annotationer på metaklasser. "
"Om en klass inte har någon egen annotationsdikt returneras en tom dikt."

msgid ""
"All accesses to object members and dict values are done using ``getattr()`` "
"and ``dict.get()`` for safety."
msgstr ""
"Alla åtkomster till objektmedlemmar och dict-värden görs med hjälp av "
"``getattr()`` och ``dict.get()`` för säkerhets skull."

msgid ""
"*eval_str* controls whether or not values of type :class:`!str` are replaced "
"with the result of calling :func:`eval` on those values:"
msgstr ""
"*eval_str* styr om värden av typen :class:`!str` ska ersättas med resultatet "
"av anropet av :func:`eval` på dessa värden:"

msgid ""
"If eval_str is true, :func:`eval` is called on values of type :class:`!str`. "
"(Note that :func:`!get_annotations` doesn't catch exceptions; if :func:"
"`eval` raises an exception, it will unwind the stack past the :func:`!"
"get_annotations` call.)"
msgstr ""
"Om eval_str är true, anropas :func:`eval` på värden av typen :class:`!str`. "
"(Observera att :func:`!get_annotations` inte fångar upp undantag; om :func:"
"`eval` ger upphov till ett undantag kommer den att spola tillbaka stacken "
"förbi anropet av :func:`!get_annotations`)"

msgid ""
"If *eval_str* is false (the default), values of type :class:`!str` are "
"unchanged."
msgstr ""
"Om *eval_str* är false (standard) är värden av typen :class:`!str` "
"oförändrade."

msgid ""
"*globals* and *locals* are passed in to :func:`eval`; see the documentation "
"for :func:`eval` for more information. If *globals* or *locals* is :const:`!"
"None`, this function may replace that value with a context-specific default, "
"contingent on ``type(obj)``:"
msgstr ""
"*globals* och *locals* skickas in till :func:`eval`; se dokumentationen för :"
"func:`eval` för mer information. Om *globals* eller *locals* är :const:`!"
"None`, kan denna funktion ersätta det värdet med en kontextspecifik "
"standard, beroende på ``type(obj)``:"

msgid "If *obj* is a module, *globals* defaults to ``obj.__dict__``."
msgstr "Om *obj* är en modul är *globals* standardvärdet för ``obj.__dict__``."

msgid ""
"If *obj* is a class, *globals* defaults to ``sys.modules[obj.__module__]."
"__dict__`` and *locals* defaults to the *obj* class namespace."
msgstr ""
"Om *obj* är en klass är *globals* standardvärdet ``sys.modules[obj."
"__module__].__dict__`` och *locals* standardvärdet klassnamnrymden för *obj*."

msgid ""
"If *obj* is a callable, *globals* defaults to :attr:`obj.__globals__ "
"<function.__globals__>`, although if *obj* is a wrapped function (using :"
"func:`functools.update_wrapper`) or a :class:`functools.partial` object, it "
"is unwrapped until a non-wrapped function is found."
msgstr ""
"Om *obj* är en callable är *globals* standardvärdet för :attr:`obj."
"__globals__ <function.__globals__>`, men om *obj* är en omsluten funktion "
"(med :func:`functools.update_wrapper`) eller ett :class:`functools.partial`-"
"objekt, är den omsluten tills en icke omsluten funktion hittas."

msgid ""
"Calling :func:`!get_annotations` is best practice for accessing the "
"annotations dict of any object. See :ref:`annotations-howto` for more "
"information on annotations best practices."
msgstr ""
"Att anropa :func:`!get_annotations` är bästa praxis för att få tillgång till "
"annotationsdikten för ett objekt. Se :ref:`annotations-howto` för mer "
"information om bästa praxis för annotationer."

msgid ""
">>> def f(a: int, b: str) -> float:\n"
"...     pass\n"
">>> get_annotations(f)\n"
"{'a': <class 'int'>, 'b': <class 'str'>, 'return': <class 'float'>}"
msgstr ""
">>> def f(a: int, b: str) -> float:\n"
"... passera\n"
">>> get_annotations(f)\n"
"{'a': <klass 'int'>, 'b': <class 'str'>, 'return': <klass 'float'>}"

msgid ""
"Convert an arbitrary Python value to a format suitable for use by the :attr:"
"`~Format.STRING` format. This calls :func:`repr` for most objects, but has "
"special handling for some objects, such as type objects."
msgstr ""
"Konverterar ett godtyckligt Python-värde till ett format som kan användas "
"av :attr:`~Format.STRING`-formatet. Detta anropar :func:`repr` för de flesta "
"objekt, men har speciell hantering för vissa objekt, t.ex. typobjekt."

msgid ""
"This is meant as a helper for user-provided annotate functions that support "
"the :attr:`~Format.STRING` format but do not have access to the code "
"creating the annotations. It can also be used to provide a user-friendly "
"string representation for other objects that contain values that are "
"commonly encountered in annotations."
msgstr ""
"Detta är tänkt som en hjälp för användartillhandahållna annotate-funktioner "
"som stöder formatet :attr:`~Format.STRING` men som inte har tillgång till "
"koden som skapar annotationerna. Det kan också användas för att "
"tillhandahålla en användarvänlig strängrepresentation för andra objekt som "
"innehåller värden som är vanliga i annoteringar."

msgid "Recipes"
msgstr "Recept"

msgid "Using annotations in a metaclass"
msgstr "Använda annoteringar i en metaklass"

msgid ""
"A :ref:`metaclass <metaclasses>` may want to inspect or even modify the "
"annotations in a class body during class creation. Doing so requires "
"retrieving annotations from the class namespace dictionary. For classes "
"created with ``from __future__ import annotations``, the annotations will be "
"in the ``__annotations__`` key of the dictionary. For other classes with "
"annotations, :func:`get_annotate_from_class_namespace` can be used to get "
"the annotate function, and :func:`call_annotate_function` can be used to "
"call it and retrieve the annotations. Using the :attr:`~Format.FORWARDREF` "
"format will usually be best, because this allows the annotations to refer to "
"names that cannot yet be resolved when the class is created."
msgstr ""
"En :ref:`metaklass <metaclasses>` kan vilja inspektera eller till och med "
"ändra annoteringarna i en klass kropp under klassens skapande. För att göra "
"detta krävs att anteckningar hämtas från klassens namnrymdsordbok. För "
"klasser som skapats med ``from __future__ import annotations`` kommer "
"annotationerna att finnas i nyckeln ``__annotations__`` i ordlistan. För "
"andra klasser med anteckningar kan :func:`get_annotate_from_class_namespace` "
"användas för att hämta anteckningsfunktionen och :func:"
"`call_annotate_function` kan användas för att anropa den och hämta "
"anteckningarna. Att använda formatet :attr:`~Format.FORWARDREF` är oftast "
"bäst, eftersom det gör det möjligt för annoteringarna att referera till namn "
"som ännu inte kan lösas när klassen skapas."

msgid ""
"To modify the annotations, it is best to create a wrapper annotate function "
"that calls the original annotate function, makes any necessary adjustments, "
"and returns the result."
msgstr ""
"För att modifiera annotationerna är det bäst att skapa en annotate-funktion "
"som anropar den ursprungliga annotate-funktionen, gör eventuella nödvändiga "
"justeringar och returnerar resultatet."

msgid ""
"Below is an example of a metaclass that filters out all :class:`typing."
"ClassVar` annotations from the class and puts them in a separate attribute:"
msgstr ""
"Nedan visas ett exempel på en metaklass som filtrerar bort alla :class:"
"`typing.ClassVar`-annoteringar från klassen och placerar dem i ett separat "
"attribut:"

msgid ""
"import annotationlib\n"
"import typing\n"
"\n"
"class ClassVarSeparator(type):\n"
"   def __new__(mcls, name, bases, ns):\n"
"      if \"__annotations__\" in ns:  # from __future__ import annotations\n"
"         annotations = ns[\"__annotations__\"]\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            # Use string comparison for simplicity; a more robust solution\n"
"            # could use annotationlib.ForwardRef.evaluate\n"
"            if value.startswith(\"ClassVar\")\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"         ns[\"__annotations__\"] = {\n"
"            key: value for key, value in annotations.items()\n"
"            if key not in classvar_keys\n"
"         }\n"
"         wrapped_annotate = None\n"
"      elif annotate := annotationlib.get_annotate_from_class_namespace(ns):\n"
"         annotations = annotationlib.call_annotate_function(\n"
"            annotate, format=annotationlib.Format.FORWARDREF\n"
"         )\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            if typing.get_origin(value) is typing.ClassVar\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"\n"
"         def wrapped_annotate(format):\n"
"            annos = annotationlib.call_annotate_function(annotate, format, "
"owner=typ)\n"
"            return {key: value for key, value in annos.items() if key not in "
"classvar_keys}\n"
"\n"
"      else:  # no annotations\n"
"         classvars = {}\n"
"         wrapped_annotate = None\n"
"      typ = super().__new__(mcls, name, bases, ns)\n"
"\n"
"      if wrapped_annotate is not None:\n"
"         # Wrap the original __annotate__ with a wrapper that removes "
"ClassVars\n"
"         typ.__annotate__ = wrapped_annotate\n"
"      typ.classvars = classvars  # Store the ClassVars in a separate "
"attribute\n"
"      return typ"
msgstr ""
"import annotationlib\n"
"import typing\n"
"\n"
"class ClassVarSeparator(type):\n"
"   def __new__(mcls, name, bases, ns):\n"
"      if \"__annotations__\" in ns:  # from __future__ import annotations\n"
"         annotations = ns[\"__annotations__\"]\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            # Use string comparison for simplicity; a more robust solution\n"
"            # could use annotationlib.ForwardRef.evaluate\n"
"            if value.startswith(\"ClassVar\")\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"         ns[\"__annotations__\"] = {\n"
"            key: value for key, value in annotations.items()\n"
"            if key not in classvar_keys\n"
"         }\n"
"         wrapped_annotate = None\n"
"      elif annotate := annotationlib.get_annotate_from_class_namespace(ns):\n"
"         annotations = annotationlib.call_annotate_function(\n"
"            annotate, format=annotationlib.Format.FORWARDREF\n"
"         )\n"
"         classvar_keys = {\n"
"            key for key, value in annotations.items()\n"
"            if typing.get_origin(value) is typing.ClassVar\n"
"         }\n"
"         classvars = {key: annotations[key] for key in classvar_keys}\n"
"\n"
"         def wrapped_annotate(format):\n"
"            annos = annotationlib.call_annotate_function(annotate, format, "
"owner=typ)\n"
"            return {key: value for key, value in annos.items() if key not in "
"classvar_keys}\n"
"\n"
"      else:  # no annotations\n"
"         classvars = {}\n"
"         wrapped_annotate = None\n"
"      typ = super().__new__(mcls, name, bases, ns)\n"
"\n"
"      if wrapped_annotate is not None:\n"
"         # Wrap the original __annotate__ with a wrapper that removes "
"ClassVars\n"
"         typ.__annotate__ = wrapped_annotate\n"
"      typ.classvars = classvars  # Store the ClassVars in a separate "
"attribute\n"
"      return typ"

msgid "Limitations of the ``STRING`` format"
msgstr "Begränsningar av formatet ``STRING``"

msgid ""
"The :attr:`~Format.STRING` format is meant to approximate the source code of "
"the annotation, but the implementation strategy used means that it is not "
"always possible to recover the exact source code."
msgstr ""
"Formatet :attr:`~Format.STRING` är avsett att approximera källkoden för "
"anteckningen, men den implementeringsstrategi som används innebär att det "
"inte alltid är möjligt att återskapa den exakta källkoden."

msgid ""
"First, the stringifier of course cannot recover any information that is not "
"present in the compiled code, including comments, whitespace, "
"parenthesization, and operations that get simplified by the compiler."
msgstr ""
"För det första kan strängifieraren naturligtvis inte återskapa någon "
"information som inte finns i den kompilerade koden, inklusive kommentarer, "
"blanksteg, parenteser och operationer som förenklas av kompilatorn."

msgid ""
"Second, the stringifier can intercept almost all operations that involve "
"names looked up in some scope, but it cannot intercept operations that "
"operate fully on constants. As a corollary, this also means it is not safe "
"to request the ``STRING`` format on untrusted code: Python is powerful "
"enough that it is possible to achieve arbitrary code execution even with no "
"access to any globals or builtins. For example:"
msgstr ""
"För det andra kan stringifieraren fånga upp nästan alla operationer som "
"involverar namn som letas upp i något scope, men den kan inte fånga upp "
"operationer som helt och hållet arbetar med konstanter. Som en följd av "
"detta betyder det också att det inte är säkert att begära ``STRING``-"
"formatet på opålitlig kod: Python är tillräckligt kraftfullt för att det är "
"möjligt att utföra godtycklig kod även utan tillgång till några globaler "
"eller inbyggda program. Till exempel:"

msgid ""
">>> def f(x: (1).__class__.__base__.__subclasses__()[-1].__init__."
"__builtins__[\"print\"](\"Hello world\")): pass\n"
"...\n"
">>> annotationlib.get_annotations(f, format=annotationlib.Format.STRING)\n"
"Hello world\n"
"{'x': 'None'}"
msgstr ""
">>> def f(x: (1).__class__.__base__.__subclasses__()[-1].__init__."
"__builtins__[\"print\"](\"Hello world\")): pass\n"
"...\n"
">>> annotationlib.get_annotations(f, format=annotationlib.Format.STRING)\n"
"Hej världen\n"
"{'x': 'Ingen'}"

msgid ""
"This particular example works as of the time of writing, but it relies on "
"implementation details and is not guaranteed to work in the future."
msgstr ""
"Det här exemplet fungerar i skrivande stund, men det är beroende av "
"implementeringsdetaljer och det finns ingen garanti för att det fungerar i "
"framtiden."

msgid ""
"Among the different kinds of expressions that exist in Python, as "
"represented by the :mod:`ast` module, some expressions are supported, "
"meaning that the ``STRING`` format can generally recover the original source "
"code; others are unsupported, meaning that they may result in incorrect "
"output or an error."
msgstr ""
"Bland de olika typer av uttryck som finns i Python, som representeras av "
"modulen :mod:`ast`, stöds vissa uttryck, vilket innebär att ``STRING``-"
"formatet i allmänhet kan återskapa den ursprungliga källkoden; andra stöds "
"inte, vilket innebär att de kan resultera i felaktig utdata eller ett fel."

msgid "The following are supported (sometimes with caveats):"
msgstr "Följande stöds (ibland med förbehåll):"

msgid ":class:`ast.BinOp`"
msgstr ":class:`ast.BinOp`"

msgid ":class:`ast.UnaryOp`"
msgstr ":class:`ast.UnaryOp`"

msgid ""
":class:`ast.Invert` (``~``), :class:`ast.UAdd` (``+``), and :class:`ast."
"USub` (``-``) are supported"
msgstr ""
":class:`ast.Invert` (``~``), :class:`ast.UAdd` (``+``), och :class:`ast."
"USub` (``-``) stöds"

msgid ":class:`ast.Not` (``not``) is not supported"
msgstr ":class:`ast.Not` (``not``) stöds inte"

msgid ":class:`ast.Dict` (except when using ``**`` unpacking)"
msgstr ":class:`ast.Dict` (utom när du använder ``**`` uppackning)"

msgid ":class:`ast.Set`"
msgstr ":class:`ast.Set`"

msgid ":class:`ast.Compare`"
msgstr ":class:`ast.Compare`"

msgid ":class:`ast.Eq` and :class:`ast.NotEq` are supported"
msgstr ":class:`ast.Eq` och :class:`ast.NotEq` stöds"

msgid ""
":class:`ast.Lt`, :class:`ast.LtE`, :class:`ast.Gt`, and :class:`ast.GtE` are "
"supported, but the operand may be flipped"
msgstr ""
":class:`ast.Lt`, :class:`ast.LtE`, :class:`ast.Gt` och :class:`ast.GtE` "
"stöds, men operanden kan vändas"

msgid ""
":class:`ast.Is`, :class:`ast.IsNot`, :class:`ast.In`, and :class:`ast.NotIn` "
"are not supported"
msgstr ""
":class:`ast.Is`, :class:`ast.IsNot`, :class:`ast.In` och :class:`ast.NotIn` "
"stöds inte"

msgid ":class:`ast.Call` (except when using ``**`` unpacking)"
msgstr ":class:`ast.Call` (utom vid användning av ``**`` uppackning)"

msgid ""
":class:`ast.Constant` (though not the exact representation of the constant; "
"for example, escape sequences in strings are lost; hexadecimal numbers are "
"converted to decimal)"
msgstr ""
":class:`ast.Constant` (dock inte den exakta representationen av konstanten; "
"t.ex. försvinner escape-sekvenser i strängar; hexadecimala tal konverteras "
"till decimal)"

msgid ":class:`ast.Attribute` (assuming the value is not a constant)"
msgstr ":class:`ast.Attribute` (förutsatt att värdet inte är en konstant)"

msgid ":class:`ast.Subscript` (assuming the value is not a constant)"
msgstr ":class:`ast.Subscript` (förutsatt att värdet inte är en konstant)"

msgid ":class:`ast.Starred` (``*`` unpacking)"
msgstr ":class:`ast.Starred` (``*`` uppackning)"

msgid ":class:`ast.Name`"
msgstr ":class:`ast.namn`"

msgid ":class:`ast.List`"
msgstr ":class:`ast.List`"

msgid ":class:`ast.Tuple`"
msgstr ":class:`ast.Tuple`"

msgid ":class:`ast.Slice`"
msgstr ":class:`ast.Slice`"

msgid ""
"The following are unsupported, but throw an informative error when "
"encountered by the stringifier:"
msgstr ""
"Följande stöds inte, men ger ett informativt fel när strängifieraren stöter "
"på dem:"

msgid ""
":class:`ast.FormattedValue` (f-strings; error is not detected if conversion "
"specifiers like ``!r`` are used)"
msgstr ""
":class:`ast.FormattedValue` (f-strängar; felet upptäcks inte om "
"konverteringsspecifikatorer som ``!r`` används)"

msgid ":class:`ast.JoinedStr` (f-strings)"
msgstr ":class:`ast.JoinedStr` (f-strängar)"

msgid "The following are unsupported and result in incorrect output:"
msgstr "Följande stöds inte och resulterar i felaktiga utdata:"

msgid ":class:`ast.BoolOp` (``and`` and ``or``)"
msgstr ":class:`ast.BoolOp` (``och`` och ``eller``)"

msgid ":class:`ast.IfExp`"
msgstr ":class:`ast.IfExp`"

msgid ":class:`ast.Lambda`"
msgstr ":class:`ast.Lambda`"

msgid ":class:`ast.ListComp`"
msgstr ":class:`ast.ListComp`"

msgid ":class:`ast.SetComp`"
msgstr ":class:`ast.SetComp`"

msgid ":class:`ast.DictComp`"
msgstr ":class:`ast.DictComp`"

msgid ":class:`ast.GeneratorExp`"
msgstr ":class:`ast.GeneratorExp`"

msgid ""
"The following are disallowed in annotation scopes and therefore not relevant:"
msgstr ""
"Följande är inte tillåtna i annotationsomfång och är därför inte relevanta:"

msgid ":class:`ast.NamedExpr` (``:=``)"
msgstr ":class:`ast.NamedExpr` (``:=``)"

msgid ":class:`ast.Await`"
msgstr ":class:`ast.Await`"

msgid ":class:`ast.Yield`"
msgstr ":class:`ast.Yield`"

msgid ":class:`ast.YieldFrom`"
msgstr ":class:`ast.YieldFrom`"

msgid "Limitations of the ``FORWARDREF`` format"
msgstr "Begränsningar av formatet ``FORWARDREF``"

msgid ""
"The :attr:`~Format.FORWARDREF` format aims to produce real values as much as "
"possible, with anything that cannot be resolved replaced with :class:"
"`ForwardRef` objects. It is affected by broadly the same Limitations as the :"
"attr:`~Format.STRING` format: annotations that perform operations on "
"literals or that use unsupported expression types may raise exceptions when "
"evaluated using the :attr:`~Format.FORWARDREF` format."
msgstr ""
"Formatet :attr:`~Format.FORWARDREF` syftar till att producera verkliga "
"värden så mycket som möjligt, och allt som inte kan lösas upp ersätts med :"
"class:`ForwardRef`-objekt. Det påverkas av i stort sett samma begränsningar "
"som formatet :attr:`~Format.STRING`: anteckningar som utför operationer på "
"litteraler eller som använder uttryckstyper som inte stöds kan ge upphov "
"till undantag när de utvärderas med formatet :attr:`~Format.FORWARDREF`."

msgid "Below are a few examples of the behavior with unsupported expressions:"
msgstr "Nedan följer några exempel på beteendet med uttryck som inte stöds:"

msgid ""
">>> from annotationlib import get_annotations, Format\n"
">>> def zerodiv(x: 1 / 0): ...\n"
">>> get_annotations(zerodiv, format=Format.STRING)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> get_annotations(zerodiv, format=Format.FORWARDREF)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def ifexp(x: 1 if y else 0): ...\n"
">>> get_annotations(ifexp, format=Format.STRING)\n"
"{'x': '1'}"
msgstr ""
">>> from annotationlib import get_annotations, Format\n"
">>> def zerodiv(x: 1 / 0): ...\n"
">>> get_annotations(zerodiv, format=Format.STRING)\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"ZeroDivisionError: division med noll\n"
">>> get_annotations(zerodiv, format=Format.FORWARDREF)\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"ZeroDivisionError: division med noll\n"
">>> def ifexp(x: 1 if y else 0): ...\n"
">>> get_annotations(ifexp, format=Format.STRING)\n"
"{'x': '1'}"
