# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!email.header`: Internationalized headers"
msgstr ":mod:`!email.header`: Internationaliserade rubriker"

msgid "**Source code:** :source:`Lib/email/header.py`"
msgstr "**Källkod:** :source:`Lib/email/header.py`"

msgid ""
"This module is part of the legacy (``Compat32``) email API.  In the current "
"API encoding and decoding of headers is handled transparently by the "
"dictionary-like API of the :class:`~email.message.EmailMessage` class.  In "
"addition to uses in legacy code, this module can be useful in applications "
"that need to completely control the character sets used when encoding "
"headers."
msgstr ""
"Denna modul är en del av det äldre (``Compat32``) e-post-API:et.  I det "
"nuvarande API:et hanteras kodning och avkodning av rubriker på ett "
"transparent sätt av det ordboksliknande API:et i klassen :class:`~email."
"message.EmailMessage`.  Förutom att den här modulen kan användas i äldre kod "
"kan den vara användbar i applikationer som behöver fullständig kontroll över "
"de teckenuppsättningar som används vid kodning av rubriker."

msgid ""
"The remaining text in this section is the original documentation of the "
"module."
msgstr "Resterande text i detta avsnitt är modulens originaldokumentation."

msgid ""
":rfc:`2822` is the base standard that describes the format of email "
"messages. It derives from the older :rfc:`822` standard which came into "
"widespread use at a time when most email was composed of ASCII characters "
"only.  :rfc:`2822` is a specification written assuming email contains only 7-"
"bit ASCII characters."
msgstr ""
":rfc:`2822` är den basstandard som beskriver formatet för e-postmeddelanden. "
"Den härstammar från den äldre standarden :rfc:`822` som började användas i "
"stor utsträckning vid en tidpunkt då de flesta e-postmeddelanden endast "
"bestod av ASCII-tecken. :rfc:`2822` är en specifikation som är skriven under "
"förutsättning att e-postmeddelanden endast innehåller 7-bitars ASCII-tecken."

msgid ""
"Of course, as email has been deployed worldwide, it has become "
"internationalized, such that language specific character sets can now be "
"used in email messages.  The base standard still requires email messages to "
"be transferred using only 7-bit ASCII characters, so a slew of RFCs have "
"been written describing how to encode email containing non-ASCII characters "
"into :rfc:`2822`\\ -compliant format. These RFCs include :rfc:`2045`, :rfc:"
"`2046`, :rfc:`2047`, and :rfc:`2231`. The :mod:`email` package supports "
"these standards in its :mod:`email.header` and :mod:`email.charset` modules."
msgstr ""
"I takt med att e-post har spridits över hela världen har den naturligtvis "
"internationaliserats, så att språkspecifika teckenuppsättningar nu kan "
"användas i e-postmeddelanden.  Basstandarden kräver fortfarande att e-"
"postmeddelanden överförs med endast 7-bitars ASCII-tecken, så en mängd RFC:"
"er har skrivits som beskriver hur man kodar e-postmeddelanden som innehåller "
"icke-ASCII-tecken till ett format som uppfyller kraven i :rfc:`2822`. Dessa "
"RFC:er inkluderar :rfc:`2045`, :rfc:`2046`, :rfc:`2047` och :rfc:`2231`. "
"Paketet :mod:`email` stöder dessa standarder i modulerna :mod:`email.header` "
"och :mod:`email.charset`."

msgid ""
"If you want to include non-ASCII characters in your email headers, say in "
"the :mailheader:`Subject` or :mailheader:`To` fields, you should use the :"
"class:`Header` class and assign the field in the :class:`~email.message."
"Message` object to an instance of :class:`Header` instead of using a string "
"for the header value.  Import the :class:`Header` class from the :mod:`email."
"header` module. For example::"
msgstr ""
"Om du vill inkludera icke-ASCII-tecken i dina e-postrubriker, t.ex. i "
"fälten :mailheader:`Subject` eller :mailheader:`To`, bör du använda klassen :"
"class:`Header` och tilldela fältet i objektet :class:`~email.message."
"Message` till en instans av :class:`Header` i stället för att använda en "
"sträng som rubrikvärde.  Importera klassen :class:`Header` från modulen :mod:"
"`email.header`. Till exempel::"

msgid ""
">>> from email.message import Message\n"
">>> from email.header import Header\n"
">>> msg = Message()\n"
">>> h = Header('p\\xf6stal', 'iso-8859-1')\n"
">>> msg['Subject'] = h\n"
">>> msg.as_string()\n"
"'Subject: =?iso-8859-1?q?p=F6stal?=\\n\\n'"
msgstr ""
">>> from email.message import Message\n"
">>> from email.header import Header\n"
">>> msg = Message()\n"
">>> h = Header('p\\xf6stal', 'iso-8859-1')\n"
">>> msg['Subject'] = h\n"
">>> msg.as_string()\n"
"'Subject: =?iso-8859-1?q?p=F6stal?=\\n\\n'"

msgid ""
"Notice here how we wanted the :mailheader:`Subject` field to contain a non-"
"ASCII character?  We did this by creating a :class:`Header` instance and "
"passing in the character set that the byte string was encoded in.  When the "
"subsequent :class:`~email.message.Message` instance was flattened, the :"
"mailheader:`Subject` field was properly :rfc:`2047` encoded.  MIME-aware "
"mail readers would show this header using the embedded ISO-8859-1 character."
msgstr ""
"Ser du här hur vi ville att fältet :mailheader:`Subject` skulle innehålla "
"ett icke-ASCII-tecken?  Vi gjorde detta genom att skapa en :class:`Header`-"
"instans och skicka in den teckenuppsättning som bytesträngen var kodad i.  "
"När den efterföljande :class:`~email.message.Message`-instansen plattades "
"till, var fältet :mailheader:`Subject` korrekt :rfc:`2047`-kodat.  MIME-"
"medvetna e-postläsare skulle visa detta huvud med hjälp av det inbäddade "
"ISO-8859-1 tecknet."

msgid "Here is the :class:`Header` class description:"
msgstr "Här är klassbeskrivningen för :class:`Header`:"

msgid ""
"Create a MIME-compliant header that can contain strings in different "
"character sets."
msgstr ""
"Skapa ett MIME-kompatibelt huvud som kan innehålla strängar i olika "
"teckenuppsättningar."

msgid ""
"Optional *s* is the initial header value.  If ``None`` (the default), the "
"initial header value is not set.  You can later append to the header with :"
"meth:`append` method calls.  *s* may be an instance of :class:`bytes` or :"
"class:`str`, but see the :meth:`append` documentation for semantics."
msgstr ""
"Valfritt *s* är det initiala rubrikvärdet.  Om ``None`` (standard) anges "
"inte det initiala rubrikvärdet.  Du kan senare lägga till i sidhuvudet med :"
"meth:`append` metodanrop.  *s* kan vara en instans av :class:`bytes` eller :"
"class:`str`, men se :meth:`append`-dokumentationen för semantik."

msgid ""
"Optional *charset* serves two purposes: it has the same meaning as the "
"*charset* argument to the :meth:`append` method.  It also sets the default "
"character set for all subsequent :meth:`append` calls that omit the "
"*charset* argument.  If *charset* is not provided in the constructor (the "
"default), the ``us-ascii`` character set is used both as *s*'s initial "
"charset and as the default for subsequent :meth:`append` calls."
msgstr ""
"Det valfria *charset* har två syften: det har samma betydelse som argumentet "
"*charset* i metoden :meth:`append`.  Det anger också standardteckensatsen "
"för alla efterföljande :meth:`append`-anrop som utelämnar *charset*-"
"argumentet.  Om *charset* inte anges i konstruktören (standard) används "
"teckenuppsättningen ``us-ascii`` både som *s*:s ursprungliga "
"teckenuppsättning och som standard för efterföljande :meth:`append`-anrop."

msgid ""
"The maximum line length can be specified explicitly via *maxlinelen*.  For "
"splitting the first line to a shorter value (to account for the field header "
"which isn't included in *s*, e.g. :mailheader:`Subject`) pass in the name of "
"the field in *header_name*.  The default *maxlinelen* is 78, and the default "
"value for *header_name* is ``None``, meaning it is not taken into account "
"for the first line of a long, split header."
msgstr ""
"Den maximala radlängden kan anges explicit via *maxlinelen*.  Om du vill "
"dela upp den första raden till ett kortare värde (för att ta hänsyn till "
"fältrubriker som inte ingår i *s*, t.ex. :mailheader:`Subject`) anger du "
"fältets namn i *header_name*.  Standardvärdet för *maxlinelen* är 78 och "
"standardvärdet för *header_name* är ``None``, vilket innebär att det inte "
"tas hänsyn till den första raden i en lång, delad header."

msgid ""
"Optional *continuation_ws* must be :rfc:`2822`\\ -compliant folding "
"whitespace, and is usually either a space or a hard tab character.  This "
"character will be prepended to continuation lines.  *continuation_ws* "
"defaults to a single space character."
msgstr ""
"Det valfria tecknet *continuation_ws* måste vara ett :rfc:`2822` -"
"kompatibelt folding whitespace, och är vanligtvis antingen ett mellanslag "
"eller en hård tabb.  Detta tecken kommer att läggas till på "
"fortsättningsrader.  *continuation_ws* är som standard ett enda "
"mellanslagstecken."

msgid ""
"Optional *errors* is passed straight through to the :meth:`append` method."
msgstr "Valfria *fel* skickas rakt igenom till metoden :meth:`append`."

msgid "Append the string *s* to the MIME header."
msgstr "Lägg till strängen *s* i MIME-rubriken."

msgid ""
"Optional *charset*, if given, should be a :class:`~email.charset.Charset` "
"instance (see :mod:`email.charset`) or the name of a character set, which "
"will be converted to a :class:`~email.charset.Charset` instance.  A value of "
"``None`` (the default) means that the *charset* given in the constructor is "
"used."
msgstr ""
"Det valfria *charset*, om det anges, bör vara en :class:`~email.charset."
"Charset`-instans (se :mod:`email.charset`) eller namnet på en "
"teckenuppsättning, som kommer att konverteras till en :class:`~email.charset."
"Charset`-instans.  Ett värde på ``None`` (standard) innebär att den "
"*charset* som anges i konstruktören används."

msgid ""
"*s* may be an instance of :class:`bytes` or :class:`str`.  If it is an "
"instance of :class:`bytes`, then *charset* is the encoding of that byte "
"string, and a :exc:`UnicodeError` will be raised if the string cannot be "
"decoded with that character set."
msgstr ""
"*s* kan vara en instans av :class:`bytes` eller :class:`str`.  Om det är en "
"instans av :class:`bytes`, så är *charset* kodningen av bytesträngen och "
"ett :exc:`UnicodeError` kommer att uppstå om strängen inte kan avkodas med "
"den teckenuppsättningen."

msgid ""
"If *s* is an instance of :class:`str`, then *charset* is a hint specifying "
"the character set of the characters in the string."
msgstr ""
"Om *s* är en instans av :class:`str`, är *charset* en ledtråd som anger "
"teckenuppsättningen för tecknen i strängen."

msgid ""
"In either case, when producing an :rfc:`2822`\\ -compliant header using :rfc:"
"`2047` rules, the string will be encoded using the output codec of the "
"charset.  If the string cannot be encoded using the output codec, a "
"UnicodeError will be raised."
msgstr ""
"I båda fallen, när ett :rfc:`2822`-kompatibelt huvud produceras med hjälp "
"av :rfc:`2047`-regler, kommer strängen att kodas med hjälp av utdatakodeken "
"för teckenuppsättningen.  Om strängen inte kan kodas med hjälp av "
"utmatningskodeken, kommer ett UnicodeError att uppstå."

msgid ""
"Optional *errors* is passed as the errors argument to the decode call if *s* "
"is a byte string."
msgstr ""
"Valfri *errors* skickas som errors-argument till avkodningsanropet om *s* är "
"en bytesträng."

msgid ""
"Encode a message header into an RFC-compliant format, possibly wrapping long "
"lines and encapsulating non-ASCII parts in base64 or quoted-printable "
"encodings."
msgstr ""
"Koda ett meddelandehuvud till ett RFC-kompatibelt format, eventuellt omsluta "
"långa rader och kapsla in icke-ASCII-delar i base64- eller quoted-printable-"
"kodningar."

msgid ""
"Optional *splitchars* is a string containing characters which should be "
"given extra weight by the splitting algorithm during normal header "
"wrapping.  This is in very rough support of :RFC:`2822`\\'s 'higher level "
"syntactic breaks':  split points preceded by a splitchar are preferred "
"during line splitting, with the characters preferred in the order in which "
"they appear in the string.  Space and tab may be included in the string to "
"indicate whether preference should be given to one over the other as a split "
"point when other split chars do not appear in the line being split.  "
"Splitchars does not affect :RFC:`2047` encoded lines."
msgstr ""
"Valfritt *splitchars* är en sträng som innehåller tecken som bör ges extra "
"vikt av delningsalgoritmen under normal rubrikombrytning.  Detta är ett "
"mycket grovt stöd för :RFC:`2822`'s \"syntaktiska brytningar på högre "
"nivå\": delningspunkter som föregås av en splitchar föredras vid raddelning, "
"med tecknen föredragna i den ordning de förekommer i strängen.  Mellanslag "
"och tabb kan inkluderas i strängen för att ange om det ena ska föredras "
"framför det andra som delningspunkt när andra delningstecken inte förekommer "
"i den rad som delas.  Splitchars påverkar inte :RFC:`2047`-kodade rader."

msgid ""
"*maxlinelen*, if given, overrides the instance's value for the maximum line "
"length."
msgstr ""
"*maxlinelen*, om den anges, åsidosätter instansens värde för den maximala "
"radlängden."

msgid ""
"*linesep* specifies the characters used to separate the lines of the folded "
"header.  It defaults to the most useful value for Python application code "
"(``\\n``), but ``\\r\\n`` can be specified in order to produce headers with "
"RFC-compliant line separators."
msgstr ""
"*linesep* anger de tecken som används för att separera raderna i den vikta "
"sidhuvudet.  Standardvärdet är det mest användbara värdet för Python-"
"programkod (``\\n``), men ``\\r\\n`` kan anges för att producera rubriker "
"med RFC-kompatibla radavgränsare."

msgid "Added the *linesep* argument."
msgstr "Lagt till argumentet *linesep*."

msgid ""
"The :class:`Header` class also provides a number of methods to support "
"standard operators and built-in functions."
msgstr ""
"Klassen :class:`Header` innehåller också ett antal metoder för att stödja "
"standardoperatorer och inbyggda funktioner."

msgid ""
"Returns an approximation of the :class:`Header` as a string, using an "
"unlimited line length.  All pieces are converted to unicode using the "
"specified encoding and joined together appropriately.  Any pieces with a "
"charset of ``'unknown-8bit'`` are decoded as ASCII using the ``'replace'`` "
"error handler."
msgstr ""
"Returnerar en approximation av :class:`Header` som en sträng, med obegränsad "
"radlängd.  Alla delar konverteras till unicode med hjälp av den angivna "
"kodningen och sammanfogas på lämpligt sätt.  Alla delar med en "
"teckenuppsättning på ``'unknown-8bit'`` avkodas som ASCII med hjälp av "
"felhanteraren ``'replace'``."

msgid "Added handling for the ``'unknown-8bit'`` charset."
msgstr "Lagt till hantering av charsetet ``'unknown-8bit'``."

msgid ""
"This method allows you to compare two :class:`Header` instances for equality."
msgstr ""
"Med den här metoden kan du jämföra två :class:`Header`-instanser för att se "
"om de är lika."

msgid ""
"This method allows you to compare two :class:`Header` instances for "
"inequality."
msgstr ""
"Med den här metoden kan du jämföra två :class:`Header`-instanser för "
"ojämlikhet."

msgid ""
"The :mod:`email.header` module also provides the following convenient "
"functions."
msgstr ""
"Modulen :mod:`email.header` innehåller också följande praktiska funktioner."

msgid ""
"Decode a message header value without converting the character set. The "
"header value is in *header*."
msgstr ""
"Avkodar ett meddelandehuvudvärde utan att konvertera teckenuppsättningen. "
"Huvudvärdet finns i *header*."

msgid "For historical reasons, this function may return either:"
msgstr "Av historiska skäl kan denna funktion returnera antingen:"

msgid ""
"A list of pairs containing each of the decoded parts of the header, "
"``(decoded_bytes, charset)``, where *decoded_bytes* is always an instance "
"of :class:`bytes`, and *charset* is either:"
msgstr ""
"En lista med par som innehåller var och en av de avkodade delarna av "
"rubriken, ``(decoded_bytes, charset)``, där *decoded_bytes* alltid är en "
"instans av :class:`bytes`, och *charset* är antingen:"

msgid "A lower case string containing the name of the character set specified."
msgstr ""
"En sträng med gemener som innehåller namnet på den angivna "
"teckenuppsättningen."

msgid "``None`` for non-encoded parts of the header."
msgstr "``None`` för icke-kodade delar av rubriken."

msgid ""
"A list of length 1 containing a pair ``(string, None)``, where *string* is "
"always an instance of :class:`str`."
msgstr ""
"En lista med längden 1 som innehåller paret ``(string, None)``, där *string* "
"alltid är en instans av :class:`str`."

msgid ""
"An :exc:`email.errors.HeaderParseError` may be raised when certain decoding "
"errors occur (e.g. a base64 decoding exception)."
msgstr ""
"En :exc:`email.errors.HeaderParseError` kan uppstå när vissa avkodningsfel "
"inträffar (t.ex. ett base64-avkodningsundantag)."

msgid "Here are examples:"
msgstr "Här är några exempel:"

msgid ""
"This function exists for backwards compatibility only. For new code, we "
"recommend using :class:`email.headerregistry.HeaderRegistry`."
msgstr ""
"Denna funktion finns endast för bakåtkompatibilitet. För ny kod "
"rekommenderar vi att du använder :class:`email.headerregistry."
"HeaderRegistry`."

msgid ""
"Create a :class:`Header` instance from a sequence of pairs as returned by :"
"func:`decode_header`."
msgstr ""
"Skapa en instans av :class:`Header` från en sekvens av par som returneras "
"av :func:`decode_header`."

msgid ""
":func:`decode_header` takes a header value string and returns a sequence of "
"pairs of the format ``(decoded_string, charset)`` where *charset* is the "
"name of the character set."
msgstr ""
":func:`decode_header` tar en rubrikvärdessträng och returnerar en sekvens av "
"par i formatet ``(decoded_string, charset)`` där *charset* är namnet på "
"teckenuppsättningen."

msgid ""
"This function takes one of those sequence of pairs and returns a :class:"
"`Header` instance.  Optional *maxlinelen*, *header_name*, and "
"*continuation_ws* are as in the :class:`Header` constructor."
msgstr ""
"Denna funktion tar en av dessa sekvenser av par och returnerar en :class:"
"`Header`-instans.  De valfria *maxlinelen*, *header_name* och "
"*continuation_ws* är som i konstruktören för :class:`Header`."

msgid ""
"This function exists for backwards compatibility only, and is not "
"recommended for use in new code."
msgstr ""
"Denna funktion finns endast för bakåtkompatibilitet och rekommenderas inte "
"för användning i ny kod."
