# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Compound statements"
msgstr "Compound statements"

msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Compound statements innehåller (grupper av) andra statements; de påverkar "
"eller styr utförandet av dessa andra statements på något sätt.  I allmänhet "
"sträcker sig sammansatta statements över flera rader, men i enkla varianter "
"kan en hel sammansatta statements rymmas på en rad."

msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Satserna :keyword:`if`, :keyword:`while` och :keyword:`for` implementerar "
"traditionella kontrollflödeskonstruktioner. :keyword:`try` specificerar "
"undantagshanterare och/eller uppstädningskod för en grupp satser, medan "
"satsen :keyword:`with` gör det möjligt att exekvera initialiserings- och "
"finaliseringskod runt ett kodblock.  Funktions- och klassdefinitioner är "
"också syntaktiskt sammansatta satser."

msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Ett sammansatt uttalande består av en eller flera \"klausuler\"  En klausul "
"består av en rubrik och en \"svit\"  Klausulrubrikerna i en viss sammansatt "
"sats har alla samma indragningsnivå. Varje klausulrubrik börjar med ett "
"unikt identifierande nyckelord och slutar med kolon.  En svit är en grupp "
"satser som styrs av en klausul.  En svit kan bestå av en eller flera "
"semikolonseparerade enkla satser på samma rad som rubriken, efter rubrikens "
"kolon, eller av en eller flera indragna satser på efterföljande rader.  "
"Endast den senare formen av en svit kan innehålla nästlade sammansatta "
"satser; följande är olagligt, mest för att det inte skulle vara tydligt till "
"vilken :keyword:`if`-sats en följande :keyword:`else`-sats skulle höra::"

msgid "if test1: if test2: print(x)"
msgstr "if test1: if test2: print(x)"

msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Observera också att semikolon binder hårdare än kolon i detta sammanhang, så "
"att i följande exempel utförs antingen alla eller inga av :func:`print`-"
"anropen::"

msgid "if x < y < z: print(x); print(y); print(z)"
msgstr "if x < y < z: print(x); print(y); print(z)"

msgid "Summarizing:"
msgstr "Sammanfatta:"

msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Observera att satser alltid avslutas med en ``NEWLINE``, eventuellt följd av "
"en ``DEDENT``.  Observera också att valfria fortsättningssatser alltid "
"börjar med ett nyckelord som inte kan börja en sats, så det finns inga "
"tvetydigheter (problemet med \"dinglande :nyckelord:`else`\" löses i Python "
"genom att kräva att nästlade :nyckelord:`if`-satser är indragna)."

msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"I formateringen av grammatikreglerna i följande avsnitt placeras varje sats "
"på en separat rad för tydlighetens skull."

msgid "The :keyword:`!if` statement"
msgstr "Nyckelordet: `!if`-satsen"

msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "Satsen :keyword:`if` används för villkorlig exekvering:"

msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Den väljer exakt en av sviterna genom att utvärdera uttrycken ett efter ett "
"tills ett av dem visar sig vara sant (se avsnitt :ref:`booleans` för "
"definition av true och false); då körs den sviten (och ingen annan del av :"
"keyword:`if`-satsen körs eller utvärderas).  Om alla uttryck är falska, "
"utförs sviten i :keyword:`else`-satsen, om den finns."

msgid "The :keyword:`!while` statement"
msgstr "Nyckelordet: `!while`-satsen"

msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"Satsen :keyword:`while` används för upprepad exekvering så länge som ett "
"uttryck är sant:"

msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Detta testar uttrycket upprepade gånger och, om det är sant, körs den första "
"sviten; om uttrycket är falskt (vilket kan vara första gången det testas) "
"körs sviten i :keyword:`!else`-satsen, om den finns, och slingan avslutas."

msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"En :keyword:`break`-sats som exekveras i den första sviten avslutar slingan "
"utan att exekvera :keyword:`!else`-satsens svit.  En :keyword:`continue`-"
"sats som exekveras i den första sviten hoppar över resten av sviten och går "
"tillbaka till att testa uttrycket."

msgid "The :keyword:`!for` statement"
msgstr ":nyckelord:`!for`-satsen"

msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"Satsen :keyword:`for` används för att iterera över elementen i en sekvens (t."
"ex. en sträng, tupel eller lista) eller ett annat itererbart objekt:"

msgid ""
"The :token:`~python-grammar:starred_expression_list` expression is evaluated "
"once; it should yield an :term:`iterable` object. An :term:`iterator` is "
"created for that iterable. The first item provided by the iterator is then "
"assigned to the target list using the standard rules for assignments (see :"
"ref:`assignment`), and the suite is executed. This repeats for each item "
"provided by the iterator. When the iterator is exhausted, the suite in the :"
"keyword:`!else` clause, if present, is executed, and the loop terminates."
msgstr ""
"Uttrycket :token:`~python-grammar:starred_expression_list` utvärderas en "
"gång; det bör ge ett :term:`iterable`-objekt. En :term:`iterator` skapas för "
"denna iterable. Det första objektet som tillhandahålls av iteratorn "
"tilldelas sedan till mållistan med hjälp av standardreglerna för "
"tilldelningar (se :ref:`assignment`), och sviten exekveras. Detta upprepas "
"för varje objekt som tillhandahålls av iteratorn. När iteratorn är uttömd "
"körs sviten i :keyword:`!else`-satsen, om den finns, och loopen avslutas."

msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"En :keyword:`break`-sats som exekveras i den första sviten avslutar slingan "
"utan att exekvera :keyword:`!else`-satsens svit.  En :keyword:`continue`-"
"sats som utförs i den första sviten hoppar över resten av sviten och "
"fortsätter med nästa objekt, eller med :keyword:`!else`-satsen om det inte "
"finns något nästa objekt."

msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"For-slingan gör tilldelningar till variablerna i mållistan. Detta skriver "
"över alla tidigare tilldelningar till dessa variabler, inklusive de som "
"gjorts i sviten av for-slingan::"

msgid ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"
msgstr ""
"för i inom intervall(10):\n"
"    print(i)\n"
"    i = 5 # detta kommer inte att påverka for-slingan\n"
"                      # eftersom i kommer att skrivas över med nästa\n"
"                      # index i intervallet"

msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic "
"sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"Namnen i mållistan raderas inte när slingan är klar, men om sekvensen är tom "
"kommer de inte alls att ha tilldelats av slingan.  Tips: Den inbyggda typen :"
"func:`range` representerar oföränderliga aritmetiska sekvenser av heltal. "
"Till exempel ger iterering av ``range(3)`` successivt 0, 1 och sedan 2."

msgid "Starred elements are now allowed in the expression list."
msgstr "Stjärnmärkta element är nu tillåtna i uttrycksförteckningen."

msgid "The :keyword:`!try` statement"
msgstr ":nyckelord:`!try`-satsen"

msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"Satsen :keyword:`!try` specificerar undantagshanterare och/eller "
"upprensningskod för en grupp satser:"

msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Ytterligare information om undantag finns i avsnittet :ref:`exceptions`, och "
"information om hur man använder :keyword:`raise` för att generera undantag "
"finns i avsnittet :ref:`raise`."

msgid ""
"Support for optionally dropping grouping parentheses when using multiple "
"exception types. See :pep:`758`."
msgstr ""
"Stöd för att eventuellt släppa grupperingsparenteser när flera "
"undantagstyper används. Se :pep:`758`."

msgid ":keyword:`!except` clause"
msgstr ":nyckelord:`!except` klausul"

msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception."
msgstr ""
"Klausulen :keyword:`!except` specificerar en eller flera undantagshanterare. "
"När inget undantag inträffar i :keyword:`try`-satsen utförs ingen "
"undantagshanterare. När ett undantag inträffar i :keyword:`!try`-sviten "
"startas en sökning efter en undantagshanterare. Denna sökning inspekterar :"
"keyword:`!except`-klausulerna i tur och ordning tills en hittas som matchar "
"undantaget. En uttryckslös :keyword:`!except`-klausul, om den finns, måste "
"vara sist; den matchar alla undantag."

msgid ""
"For an :keyword:`!except` clause with an expression, the expression must "
"evaluate to an exception type or a tuple of exception types. Parentheses can "
"be dropped if multiple exception types are provided and the ``as`` clause is "
"not used. The raised exception matches an :keyword:`!except` clause whose "
"expression evaluates to the class or a :term:`non-virtual base class "
"<abstract base class>` of the exception object, or to a tuple that contains "
"such a class."
msgstr ""
"För en :keyword:`!except`-klausul med ett uttryck måste uttrycket utvärderas "
"till en undantagstyp eller en tupel av undantagstyper. Parenteser kan "
"utelämnas om flera undantagstyper anges och ``as``-satsen inte används. Det "
"uppkomna undantaget matchar en :keyword:`!except`-sats vars uttryck "
"utvärderas till klassen eller en :term:`icke-virtuell basklass <abstract "
"base class>` för undantagsobjektet, eller till en tupel som innehåller en "
"sådan klass."

msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr ""
"Om ingen :keyword:`!except`-klausul matchar undantaget fortsätter sökandet "
"efter en undantagshanterare i den omgivande koden och på anropsstacken.  [#]_"

msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"Om utvärderingen av ett uttryck i rubriken till en :keyword:`!except`-sats "
"ger upphov till ett undantag, avbryts den ursprungliga sökningen efter en "
"hanterare och en sökning efter det nya undantaget påbörjas i den omgivande "
"koden och på anropsstacken (det behandlas som om hela :keyword:`try`-satsen "
"gav upphov till undantaget)."

msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that :"
"keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the :"
"keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"När en matchande :keyword:`!except`-klausul hittas, tilldelas undantaget "
"till det mål som anges efter :keyword:`!as`-keywordet i den :keyword:`!"
"except`-klausulen, om det finns, och :keyword:`!except`-klausulens svit "
"exekveras. Alla :keyword:`!except`-klausuler måste ha ett exekverbart block. "
"När slutet av detta block nås, fortsätter exekveringen normalt efter hela :"
"keyword:`try`-satsen. (Detta innebär att om det finns två nästlade hanterare "
"för samma undantag, och undantaget inträffar i :keyword:`!try`-satsen i den "
"inre hanteraren, kommer den yttre hanteraren inte att hantera undantaget)"

msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr ""
"När ett undantag har tilldelats med hjälp av ``as target``, rensas det i "
"slutet av :keyword:`!except`-satsen.  Detta är som om ::"

msgid ""
"except E as N:\n"
"    foo"
msgstr ""
"utom E som N:\n"
"    foo"

msgid "was translated to ::"
msgstr "översattes till ::"

msgid ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"
msgstr ""
"utom E som N:\n"
"    try:\n"
"        foo\n"
"    slutligen: foo\n"
"        del N"

msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"Detta innebär att undantaget måste tilldelas ett annat namn för att kunna "
"referera till det efter :keyword:`!except`-klausulen. Undantag rensas "
"eftersom de med den spårning som är kopplad till dem bildar en referenscykel "
"med stapelramen, vilket håller alla lokala objekt i den ramen vid liv tills "
"nästa skräpsamling sker."

msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When "
"leaving an exception handler, the exception stored in the :mod:`sys` module "
"is reset to its previous value::"
msgstr ""
"Innan en :keyword:`!except`-klausuls svit exekveras lagras undantaget i "
"modulen :mod:`sys`, där det kan nås från :keyword:`!except`-klausulens kropp "
"genom att anropa :func:`sys.exception`. När du lämnar en undantagshanterare "
"återställs undantaget som lagrats i modulen :mod:`sys` till sitt tidigare "
"värde::"

msgid ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"
msgstr ""
">>> print(sys.undantag())\n"
"Ingen\n"
">>> försök:\n"
"... raise TypeError\n"
"... undantag:\n"
"... print(repr(sys.undantag())))\n"
"... försök:\n"
"... raise ValueError (värdefel)\n"
"... utom:\n"
"... print(repr(sys.exception()))\n"
"... print(repr(sys.exception()))\n"
"...\n"
"TypFel()\n"
"VärdeFel()\n"
"TypeError()\n"
">>> print(sys.undantag())\n"
"Ingen"

msgid ":keyword:`!except*` clause"
msgstr ":nyckelord:`!except*` klausul"

msgid ""
"The :keyword:`!except*` clause(s) are used for handling :exc:"
"`ExceptionGroup`\\s. The exception type for matching is interpreted as in "
"the case of :keyword:`except`, but in the case of exception groups we can "
"have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once "
"and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first "
"that matches it. ::"
msgstr ""
"Klausulerna :keyword:`!except*` används för att hantera :exc:"
"`ExceptionGroup`. Undantagstypen för matchning tolkas som i fallet med :"
"keyword:`except`, men i fallet med undantagsgrupper kan vi ha partiella "
"matchningar när typen matchar några av undantagen i gruppen. Detta innebär "
"att flera :keyword:`!except*`-klausuler kan köras, var och en hanterar en "
"del av undantagsgruppen. Varje klausul exekveras högst en gång och hanterar "
"en undantagsgrupp med alla matchande undantag.  Varje undantag i gruppen "
"hanteras av högst en :keyword:`!except*`-sats, den första som matchar det. ::"

msgid ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"
msgstr ""
"&gt;&gt;&gt; försök:\n"
"... raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"... print(f'fångade {type(e)} med nästlade {e.exceptions}')\n"
"... except* OSError som e:\n"
"... print(f'fångade {type(e)} med nästlad {e.exceptions}')\n"
"...\n"
"fångade <class 'ExceptionGroup'> med nästlat (TypeError(2),)\n"
"fångade <class 'ExceptionGroup'> med nästlade (OSError(3), OSError(4))\n"
"  + Undantagsgrupp Traceback (senaste anropet senast):\n"
"  | Fil \"<stdin>\", rad 2, i <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"

msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, along with all exceptions that were raised "
"from within the :keyword:`!except*` clauses. If this list contains more than "
"one exception to reraise, they are combined into an exception group."
msgstr ""
"Eventuella återstående undantag som inte hanterades av någon :keyword:`!"
"except*`-klausul tas upp igen i slutet, tillsammans med alla undantag som "
"togs upp från :keyword:`!except*`-klausulerna. Om denna lista innehåller mer "
"än ett undantag som ska tas upp på nytt, kombineras de till en "
"undantagsgrupp."

msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr ""
"Om det undantag som tas upp inte är en undantagsgrupp och dess typ matchar "
"en av :keyword:`!except*`-klausulerna, fångas det upp och omsluts av en "
"undantagsgrupp med en tom meddelandesträng. ::"

msgid ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"
msgstr ""
">>> försök:\n"
"... raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"... print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"

msgid ""
"An :keyword:`!except*` clause must have a matching expression; it cannot be "
"``except*:``. Furthermore, this expression cannot contain exception group "
"types, because that would have ambiguous semantics."
msgstr ""
"En :keyword:`!except*`-klausul måste ha ett matchande uttryck; det kan inte "
"vara ``except*:``. Dessutom kan detta uttryck inte innehålla "
"undantagsgrupptyper, eftersom det skulle ha en tvetydig semantik."

msgid ""
"It is not possible to mix :keyword:`except` and :keyword:`!except*` in the "
"same :keyword:`try`. :keyword:`break`, :keyword:`continue` and :keyword:"
"`return` cannot appear in an :keyword:`!except*` clause."
msgstr ""
"Det är inte möjligt att blanda :keyword:`except` och :keyword:`!except*` i "
"samma :keyword:`try`. :keyword:`break`, :keyword:`continue` och :keyword:"
"`return` kan inte förekomma i en :keyword:`!except*`-sats."

msgid ":keyword:`!else` clause"
msgstr ":nyckelord:`!else` klausul"

msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"Den valfria :keyword:`!else`-klausulen exekveras om kontrollflödet lämnar :"
"keyword:`try`-sviten, inget undantag har uppstått och ingen :keyword:"
"`return`-, :keyword:`continue`- eller :keyword:`break`-sats har exekverats.  "
"Undantag i :keyword:`!else`-klausulen hanteras inte av de föregående :"
"keyword:`except`-klausulerna."

msgid ":keyword:`!finally` clause"
msgstr ":nyckelord:`!finally` klausul"

msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded. For example, this function returns 42."
msgstr ""
"Om :keyword:`!finally` finns med, anger det en \"cleanup\"-hanterare.  "
"Klausulen :keyword:`try` exekveras, inklusive eventuella klausuler :keyword:"
"`except` och :keyword:`else`.  Om ett undantag inträffar i någon av "
"klausulerna och inte hanteras, sparas undantaget temporärt. Klausulen :"
"keyword:`!finally` exekveras.  Om det finns ett sparat undantag återkommer "
"det i slutet av :keyword:`!finally` -klausulen.  Om klausulen :keyword:`!"
"finally` ger upphov till ett annat undantag, sätts det sparade undantaget "
"som kontext för det nya undantaget. Om :keyword:`!finally`-satsen exekverar "
"en :keyword:`return`-, :keyword:`break`- eller :keyword:`continue`-sats, "
"kasseras det sparade undantaget. Den här funktionen returnerar till exempel "
"42."

msgid ""
"def f():\n"
"    try:\n"
"        1/0\n"
"    finally:\n"
"        return 42"
msgstr ""
"def f():\n"
"    försök:\n"
"        1/0\n"
"    slutligen:\n"
"        retur 42"

msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr ""
"Undantagsinformationen är inte tillgänglig för programmet under exekveringen "
"av :keyword:`!finally`-satsen."

msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"När en :keyword:`return`, :keyword:`break` eller :keyword:`continue`-sats "
"exekveras i :keyword:`try`-sviten av en :keyword:`!try`...\\ :keyword:`!"
"finally`-sats, exekveras även :keyword:`!finally`-klausulen \"på vägen ut\""

msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed. The following function returns "
"'finally'."
msgstr ""
"Returvärdet för en funktion bestäms av den sista :keyword:`return`-satsen "
"som exekveras.  Eftersom :keyword:`!finally`-satsen alltid exekveras, kommer "
"en :keyword:`!return`-sats som exekveras i :keyword:`!finally`-satsen alltid "
"att vara den sista som exekveras. Följande funktion returnerar 'finally'."

msgid ""
"def foo():\n"
"    try:\n"
"        return 'try'\n"
"    finally:\n"
"        return 'finally'"
msgstr ""
"def foo():\n"
"    try:\n"
"        returnera 'try'\n"
"    finally: return 'finally':\n"
"        returnera 'finally'"

msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"Före Python 3.8 var en :keyword:`continue`-sats olaglig i :keyword:`!"
"finally`-satsen på grund av ett problem med implementeringen."

msgid ""
"The compiler emits a :exc:`SyntaxWarning` when a :keyword:`return`, :keyword:"
"`break` or :keyword:`continue` appears in a :keyword:`!finally` block (see :"
"pep:`765`)."
msgstr ""
"Kompilatorn avger en :exc:`SyntaxWarning` när ett :keyword:`return`, :"
"keyword:`break` eller :keyword:`continue` förekommer i ett :keyword:`!"
"finally`-block (se :pep:`765`)."

msgid "The :keyword:`!with` statement"
msgstr ":nyckelord:`!med`-satsen"

msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"Satsen :keyword:`with` används för att omsluta exekveringen av ett block med "
"metoder som definieras av en kontexthanterare (se avsnitt :ref:"
"`kontexthanterare`). Detta gör att vanliga :keyword:`try`...\\ :keyword:"
"`except`...\\ :keyword:`finally` användningsmönster kan kapslas in för "
"bekväm återanvändning."

msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"Exekveringen av :keyword:`with`-satsen med ett \"objekt\" går till på "
"följande sätt:"

msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr ""
"Kontextuttrycket (det uttryck som anges i :token:`~python-grammar:"
"with_item`) utvärderas för att få fram en kontexthanterare."

msgid ""
"The context manager's :meth:`~object.__enter__` is loaded for later use."
msgstr ""
"Kontexthanterarens :meth:`~object.__enter__` laddas för senare användning."

msgid "The context manager's :meth:`~object.__exit__` is loaded for later use."
msgstr ""
"Kontexthanterarens :meth:`~object.__exit__` laddas för senare användning."

msgid "The context manager's :meth:`~object.__enter__` method is invoked."
msgstr "Kontexthanterarens metod :meth:`~object.__enter__` anropas."

msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`~object.__enter__` is assigned to it."
msgstr ""
"Om ett mål ingick i :keyword:`with`-satsen tilldelas det returvärdet från :"
"meth:`~object.__enter__`."

msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`~object."
"__enter__` method returns without an error, then :meth:`~object.__exit__` "
"will always be called. Thus, if an error occurs during the assignment to the "
"target list, it will be treated the same as an error occurring within the "
"suite would be. See step 7 below."
msgstr ""
"Satsen :keyword:`with` garanterar att om metoden :meth:`~object.__enter__` "
"returneras utan fel, så kommer :meth:`~object.__exit__` alltid att anropas. "
"Om ett fel inträffar under tilldelningen till mållistan kommer det alltså "
"att behandlas på samma sätt som ett fel som inträffar inom sviten skulle ha "
"behandlats. Se steg 7 nedan."

msgid "The suite is executed."
msgstr "Sviten är genomförd."

msgid ""
"The context manager's :meth:`~object.__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback are "
"passed as arguments to :meth:`~object.__exit__`. Otherwise, three :const:"
"`None` arguments are supplied."
msgstr ""
"Kontexthanterarens metod :meth:`~object.__exit__` anropas.  Om ett undantag "
"orsakade att sviten avslutades, skickas dess typ, värde och traceback som "
"argument till :meth:`~object.__exit__`. Annars anges tre :const:`None`-"
"argument."

msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`~object.__exit__` method was false, the exception is reraised.  If the "
"return value was true, the exception is suppressed, and execution continues "
"with the statement following the :keyword:`with` statement."
msgstr ""
"Om sviten avslutades på grund av ett undantag och returvärdet från metoden :"
"meth:`~object.__exit__` var falskt, återskapas undantaget.  Om returvärdet "
"var sant undertrycks undantaget och exekveringen fortsätter med det "
"uttalande som följer på :keyword:`with`-satsen."

msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`~object.__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""
"Om sviten avslutades av någon annan anledning än ett undantag ignoreras "
"returvärdet från :meth:`~object.__exit__`, och exekveringen fortsätter på "
"den normala platsen för den typ av avslut som gjordes."

msgid "The following code::"
msgstr "Följande kod::"

msgid ""
"with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"med EXPRESSION som MÅL:\n"
"    SUITE"

msgid "is semantically equivalent to::"
msgstr "är semantiskt ekvivalent med::"

msgid ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"
msgstr ""
"manager = (Uttryck)\n"
"enter = typ(chef).__enter__\n"
"exit = typ(chef).__exit__\n"
"värde = enter(chef)\n"
"hit_except = Falsk\n"
"\n"
"försök:\n"
"    TARGET = värde\n"
"    SUITE\n"
"undantag:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"slutligen:\n"
"    if not hit_except:\n"
"        exit(manager, Ingen, Ingen, Ingen)"

msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"Med mer än ett objekt bearbetas kontexthanterarna som om flera :keyword:"
"`with`-satser var nästlade:"

msgid ""
"with A() as a, B() as b:\n"
"    SUITE"
msgstr ""
"med A() som a, B() som b:\n"
"    SUITE"

msgid ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"
msgstr ""
"med A() som a:\n"
"    med B() som b:\n"
"        SUITE"

msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""
"Du kan också skriva kontexthanterare med flera objekt på flera rader om "
"objekten omges av parenteser. Till exempel::"

msgid ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"
msgstr ""
"med (\n"
"    A() som a,\n"
"    B() som b,\n"
"):\n"
"    SUITE"

msgid "Support for multiple context expressions."
msgstr "Stöd för flera kontextuttryck."

msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""
"Stöd för att använda grupperingsparenteser för att dela upp uttalandet i "
"flera rader."

msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Uttalandet \"med\""

msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Specifikation, bakgrund och exempel för Pythons :keyword:`with`-sats."

msgid "The :keyword:`!match` statement"
msgstr ":nyckelord:`!match`-satsen"

msgid "The match statement is used for pattern matching.  Syntax:"
msgstr "Match-satsen används för mönstermatchning.  Syntax:"

msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""
"I detta avsnitt används enkla citationstecken för att beteckna :ref:` `mjuka "
"nyckelord <soft-keywords>`."

msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""
"Mönstermatchning tar ett mönster som indata (efter ``case``) och ett "
"ämnesvärde (efter ``match``).  Mönstret (som kan innehålla undermönster) "
"matchas mot ämnesvärdet.  Utfallet är följande:"

msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""
"En lyckad eller misslyckad matchning (även kallad ett lyckat eller "
"misslyckat mönster)."

msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""
"Möjlig bindning av matchade värden till ett namn.  Förutsättningarna för "
"detta diskuteras vidare nedan."

msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""
"Nyckelorden ``match`` och ``case`` är :ref:`mjuka nyckelord <soft-keywords>`."

msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Matchning av strukturella mönster: Specifikation"

msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- Matchning av strukturella mönster: Handledning"

msgid "Overview"
msgstr "Översikt"

msgid "Here's an overview of the logical flow of a match statement:"
msgstr "Här följer en översikt över det logiska flödet i ett matchningsbesked:"

msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"Subjektuttrycket ``subject_expr`` utvärderas och ett resulterande "
"subjektvärde erhålls. Om ämnesuttrycket innehåller ett kommatecken "
"konstrueras en tupel med hjälp av :ref:``standardreglerna <typesseq-tuple>``."

msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"Varje mönster i ett ``case_block`` försöker matchas med ämnesvärdet. De "
"specifika reglerna för framgång eller misslyckande beskrivs nedan. "
"Matchningsförsöket kan också binda vissa eller alla fristående namn inom "
"mönstret. De exakta reglerna för mönsterbindning varierar beroende på "
"mönstertyp och anges nedan.  **Namnbindningar som görs under en lyckad "
"mönstermatchning överlever det exekverade blocket och kan användas efter "
"matchningssatsen**."

msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"Vid misslyckade mönstermatchningar kan vissa undermönster lyckas.  Förlita "
"dig inte på att bindningar görs för en misslyckad matchning.  Omvänt ska du "
"inte förlita dig på att variabler förblir oförändrade efter en misslyckad "
"matchning.  Det exakta beteendet är beroende av implementeringen och kan "
"variera.  Detta är ett avsiktligt beslut som fattats för att olika "
"implementationer ska kunna lägga till optimeringar."

msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""
"Om mönstret lyckas utvärderas motsvarande skydd (om sådant finns). I detta "
"fall garanteras att alla namnbindningar har inträffat."

msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""
"Om skyddet utvärderas som sant eller saknas, körs ``block`` inuti "
"``case_block``."

msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr "I annat fall försöker nästa ``case_block`` enligt beskrivningen ovan."

msgid "If there are no further case blocks, the match statement is completed."
msgstr "Om det inte finns några fler fallblock är matchningsöversikten klar."

msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""
"Användare bör i allmänhet aldrig förlita sig på att ett mönster utvärderas.  "
"Beroende på implementering kan tolken cacha värden eller använda andra "
"optimeringar som hoppar över upprepade utvärderingar."

msgid "A sample match statement::"
msgstr "Ett exempel på ett matchningsbesked::"

msgid ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"
msgstr ""
">>> flagga = Falsk\n"
">>> match (100, 200):\n"
"... fall (100, 300):  # Missmatchning: 200 != 300\n"
"... print('Fall 1')\n"
"... case (100, 200) if flag:  # Lyckad matchning, men guard misslyckas\n"
"... print('Fall 2')\n"
"... fall (100, y):  # Matchar och binder y till 200\n"
"... print(f'Fall 3, y: {y}')\n"
"... fall _:  # Mönstret har inte prövats\n"
"... print('Fall 4, jag matchar vad som helst!')\n"
"...\n"
"Fall 3, y: 200"

msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""
"I det här fallet är ``if flag`` en guard.  Läs mer om det i nästa avsnitt."

msgid "Guards"
msgstr "Vakter"

msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"En ``guard`` (som är en del av ``case``) måste lyckas för att koden i "
"``case``-blocket ska kunna exekveras.  Den har formen: :nyckelord:`if` följt "
"av ett uttryck."

msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr "Det logiska flödet i ett ``case``-block med ett ``guard`` följer:"

msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"Kontrollera att mönstret i ``case``-blocket lyckades.  Om mönstret "
"misslyckades utvärderas inte ``guard`` och nästa ``case``-block kontrolleras."

msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "Om mönstret lyckades, utvärdera ``guard``."

msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr "Om villkoret ``guard`` utvärderas som sant, väljs fallblocket."

msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr ""
"Om villkoret ``guard`` utvärderas som falskt, väljs inte ärendeblocket."

msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""
"Om ``guard`` ger upphov till ett undantag under utvärderingen, bubblar "
"undantaget upp."

msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"Guards får ha bieffekter eftersom de är uttryck.  Guard-utvärderingen måste "
"gå från det första till det sista fallblocket, ett i taget, och hoppa över "
"fallblock där inte alla mönster lyckas. (D.v.s. utvärderingen av guarden "
"måste ske i ordning.) Utvärderingen av guarden måste avbrytas när ett "
"fallblock har valts."

msgid "Irrefutable Case Blocks"
msgstr "Obestridliga fallblock"

msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"Ett obestridligt fallblock är ett match-all fallblock.  Ett "
"matchningsuttalande kan ha högst ett oåterkalleligt fallblock och det måste "
"vara det sista."

msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"Ett case-block anses vara oåterkalleligt om det inte har någon guard och om "
"dess mönster är oåterkalleligt.  Ett mönster anses vara oåterkalleligt om vi "
"enbart utifrån dess syntax kan bevisa att det alltid kommer att lyckas.  "
"Endast följande mönster är oåterkalleliga:"

msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ":ref:`as-mönster` vars vänstra sida är oåterkallelig"

msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ":ref:`or-patterns` som innehåller minst ett obestridligt mönster"

msgid ":ref:`capture-patterns`"
msgstr ":ref:`fångstmönster`"

msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-mönster`"

msgid "parenthesized irrefutable patterns"
msgstr "parentes ovedersägliga mönster"

msgid "Patterns"
msgstr "Blockmönster"

msgid "This section uses grammar notations beyond standard EBNF:"
msgstr "I detta avsnitt används grammatiska notationer utöver standard EBNF:"

msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "notationen ``SEP.RULE+`` är en förkortning för ``RULE (SEP RULE)*``"

msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""
"notationen ``!RULE`` är en förkortning för ett negativt framåtblickande "
"påstående"

msgid "The top-level syntax for ``patterns`` is:"
msgstr "Syntaxen på högsta nivå för ``patterns`` är:"

msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"Beskrivningarna nedan innehåller en beskrivning \"i enkla ordalag\" av vad "
"ett mönster gör i illustrationssyfte (tack till Raymond Hettinger för ett "
"dokument som inspirerat de flesta av beskrivningarna). Observera att dessa "
"beskrivningar endast är avsedda som illustrationer och **måste** inte "
"återspegla den underliggande implementeringen.  Dessutom täcker de inte alla "
"giltiga former."

msgid "OR Patterns"
msgstr "OR-mönster"

msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""
"Ett OR-mönster är två eller flera mönster åtskilda av vertikala streck ``|"
"``.  Syntax:"

msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"Endast det sista undermönstret kan vara :ref:`irrefutable "
"<irrefutable_case>`, och varje undermönster måste binda samma uppsättning "
"namn för att undvika tvetydighet."

msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"Ett OR-mönster matchar vart och ett av sina undermönster i tur och ordning "
"med ämnesvärdet, tills ett lyckas.  OR-mönstret anses då vara "
"framgångsrikt.  I annat fall, om inget av undermönstren lyckas, misslyckas "
"OR-mönstret."

msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"Enkelt uttryckt kommer ``P1 | P2 | ...`` att försöka matcha ``P1``, om det "
"misslyckas kommer det att försöka matcha ``P2``, lyckas omedelbart om någon "
"lyckas, misslyckas annars."

msgid "AS Patterns"
msgstr "AS-mönster"

msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""
"Ett AS-mönster matchar ett OR-mönster till vänster om nyckelordet :keyword:"
"`as` mot ett ämne.  Syntax för detta:"

msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a ``_``."
msgstr ""
"Om OR-mönstret misslyckas, misslyckas AS-mönstret.  I annat fall binder AS-"
"mönstret subjektet till namnet till höger om as-nyckelordet och lyckas. "
"``capture_pattern`` kan inte vara en ``_``."

msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""
"Enkelt uttryckt kommer ``P as NAME`` att matcha med ``P``, och vid framgång "
"kommer den att sätta ``NAME = <subject>``."

msgid "Literal Patterns"
msgstr "Bokstavliga mönster"

msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""
"Ett bokstavsmönster motsvarar de flesta :ref:` `literals <literals>` i "
"Python.  Syntax:"

msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"and :ref:`t-strings` are not supported."
msgstr ""
"Regeln ``strings`` och token ``NUMBER`` är definierade i :doc:`standard "
"Python grammar <./grammar>`.  Trippelciterade strängar stöds.  Råa strängar "
"och byte-strängar stöds. :ref:`f-strings` och :ref:`t-strings` stöds inte."

msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"Formerna ``signed_number '+' NUMBER`` och ``signed_number '-' NUMBER`` är "
"till för att uttrycka :ref:`komplexa tal <imaginary>`; de kräver ett reellt "
"tal till vänster och ett imaginärt tal till höger. T.ex. ``3 + 4j``."

msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"Enkelt uttryckt kommer ``LITERAL`` att lyckas endast om ``<subject> == "
"LITERAL``. För singletonerna ``None``, ``True`` och ``False`` används "
"operatorn :keyword:`is`."

msgid "Capture Patterns"
msgstr "Fångstmönster"

msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr "Ett capture-mönster binder ämnesvärdet till ett namn. Syntax:"

msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""
"En enda understrykning ``_`` är inte ett fångstmönster (det är vad ``!'_'`` "
"uttrycker). Det behandlas istället som en :token:`~python-grammar:"
"wildcard_pattern`."

msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"I ett givet mönster kan ett givet namn bara bindas en gång.  T.ex. ``case x, "
"x: ...`` är ogiltigt medan ``case [x] | x: ...`` är tillåtet."

msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"Fångstmönster lyckas alltid.  Bindningen följer scoping-regler som "
"fastställts av operatorn för tilldelningsuttryck i :pep:`572`; namnet blir "
"en lokal variabel i den närmaste innehållande funktionens scope om det inte "
"finns ett tillämpligt :keyword:`global` eller :keyword:`nonlocal` uttalande."

msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""
"Enkelt uttryckt kommer ``NAME`` alltid att lyckas och den kommer att ställa "
"in ``NAME = <subject>``."

msgid "Wildcard Patterns"
msgstr "Jokerteckenmönster"

msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""
"Ett jokerteckenmönster är alltid framgångsrikt (matchar allt) och binder "
"inget namn.  Syntax för:"

msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` är ett :ref:``mjukt nyckelord <soft-keywords>`` inom alla mönster, men "
"bara inom mönster.  Det är en identifierare, som vanligt, även inom "
"``match`` ämnesuttryck, ``guard`` och ``case`` block."

msgid "In simple terms, ``_`` will always succeed."
msgstr "Enkelt uttryckt kommer ``_`` alltid att lyckas."

msgid "Value Patterns"
msgstr "Värdemönster"

msgid "A value pattern represents a named value in Python. Syntax:"
msgstr ""
"Ett värdemönster representerar ett namngivet värde i Python. Syntaxen är"

msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"Det prickade namnet i mönstret söks upp med hjälp av Pythons standardregler "
"för namnupplösning :ref:` <resolve_names>`.  Mönstret lyckas om det funna "
"värdet jämförs med ämnesvärdet (med hjälp av likhetsoperatorn ``==``)."

msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr ""
"Enkelt uttryckt kommer ``NAME1.NAME2`` att lyckas endast om ``<subject> == "
"NAME1.NAME2``"

msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"Om samma värde förekommer flera gånger i samma matchningsuttalande kan "
"tolken cacha det första värdet som hittas och återanvända det i stället för "
"att upprepa samma uppslagning.  Denna cache är strikt knuten till en viss "
"exekvering av en viss matchningssats."

msgid "Group Patterns"
msgstr "Gruppmönster"

msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""
"Ett gruppmönster gör det möjligt för användare att lägga till parenteser "
"runt mönster för att betona den avsedda grupperingen.  I övrigt har det "
"ingen ytterligare syntax. Syntax för gruppmönster:"

msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "Enkelt uttryckt har ``(P)`` samma effekt som ``P``."

msgid "Sequence Patterns"
msgstr "Sekvensmönster"

msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""
"Ett sekvensmönster innehåller flera undermönster som ska matchas mot "
"sekvenselement. Syntaxen liknar uppackningen av en lista eller tupel."

msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""
"Det är ingen skillnad om parenteser eller hakparenteser används för "
"sekvensmönster (t.ex. ``(...)`` vs ``[...]`` )."

msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"Ett enskilt mönster inom parentes utan efterföljande kommatecken (t.ex. ``(3 "
"| 4)``) är ett :ref:``gruppmönster <group-patterns>`. Medan ett enskilt "
"mönster inom hakparenteser (t.ex. ``[3 | 4]``) fortfarande är ett "
"sekvensmönster."

msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"Högst ett stjärnundermönster kan finnas i ett sekvensmönster.  "
"Stjärnsubmönstret kan förekomma i vilken position som helst. Om inget "
"stjärnundermönster förekommer är sekvensmönstret ett sekvensmönster med fast "
"längd; annars är det ett sekvensmönster med variabel längd."

msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""
"Följande är det logiska flödet för att matcha ett sekvensmönster mot ett "
"ämnesvärde:"

msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr "Om ämnesvärdet inte är en sekvens [#]_ misslyckas sekvensmönstret."

msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""
"Om ämnesvärdet är en instans av ``str``, ``bytes`` eller ``bytearray`` "
"misslyckas sekvensmönstret."

msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""
"De följande stegen beror på om sekvensmönstret är fast eller har variabel "
"längd."

msgid "If the sequence pattern is fixed-length:"
msgstr "Om sekvensmönstret är av fast längd:"

msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""
"Om längden på den aktuella sekvensen inte är lika med antalet undermönster "
"misslyckas sekvensmönstret"

msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"Submönster i sekvensmönstret matchas med motsvarande objekt i ämnessekvensen "
"från vänster till höger.  Matchningen stoppas så snart ett undermönster "
"misslyckas.  Om alla undermönster lyckas matcha sina motsvarande objekt, "
"lyckas sekvensmönstret."

msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "Annars, om sekvensmönstret är av variabel längd:"

msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""
"Om längden på den aktuella sekvensen är mindre än antalet icke-stjärnformade "
"undermönster misslyckas sekvensmönstret."

msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""
"De ledande icke-stjärniga undermönstren matchas med sina motsvarande objekt "
"på samma sätt som för sekvenser med fast längd."

msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""
"Om föregående steg lyckas, matchar det stjärnformade undermönstret en lista "
"som består av de återstående ämnesobjekten, exklusive de återstående objekt "
"som motsvarar icke-stjärnformade undermönster som följer på det "
"stjärnformade undermönstret."

msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""
"Återstående submönster som inte är stjärnformade matchas med motsvarande "
"ämnesord, precis som för en sekvens med fast längd."

msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the interpreter "
"in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""
"Längden på ämnessekvensen erhålls via :func:`len` (dvs. via protokollet :"
"meth:`__len__`).  Denna längd kan cachelagras av tolkaren på liknande sätt "
"som :ref:`value patterns <value-patterns>`."

msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""
"Enkelt uttryckt ``[P1, P2, P3,`` ... ``, P<N>]`` matchar endast om alla "
"följande händelser inträffar:"

msgid "check ``<subject>`` is a sequence"
msgstr "kontrollera ``<subject>`` är en sekvens"

msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""
"``P1`` matchar ``<subject>[0]`` (observera att denna matchning också kan "
"binda namn)"

msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""
"``P2`` matchar ``<subject>[1]`` (observera att denna matchning också kan "
"binda namn)"

msgid "... and so on for the corresponding pattern/element."
msgstr "... och så vidare för motsvarande mönster/element."

msgid "Mapping Patterns"
msgstr "Kartläggning av mönster"

msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""
"Ett mappningsmönster innehåller ett eller flera nyckel-värde-mönster.  "
"Syntaxen liknar konstruktionen av en ordbok. Syntax för:"

msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""
"Högst ett dubbelstjärnmönster får finnas i ett mappningsmönster.  "
"Dubbelstjärnmönstret måste vara det sista undermönstret i mappningsmönstret."

msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"Duplicerade nycklar i mappningsmönster är inte tillåtna. Duplicerade "
"bokstavliga nycklar ger upphov till ett :exc:`SyntaxError`. Två nycklar som "
"annars har samma värde kommer att ge upphov till ett :exc:`ValueError` vid "
"körning."

msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""
"Följande är det logiska flödet för att matcha ett mappningsmönster mot ett "
"ämnesvärde:"

msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr "Om ämnesvärdet inte är en mappning [#]_ misslyckas mappningsmönstret."

msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""
"Om varje nyckel som anges i mappningsmönstret finns i ämnesmappningen och "
"mönstret för varje nyckel matchar motsvarande post i ämnesmappningen, lyckas "
"mappningsmönstret."

msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"Om duplicerade nycklar upptäcks i mappningsmönstret anses mönstret vara "
"ogiltigt. Ett :exc:`SyntaxError` uppstår för duplicerade bokstavliga värden; "
"eller ett :exc:`ValueError` för namngivna nycklar med samma värde."

msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`__missing__` or :meth:"
"`~object.__getitem__`."
msgstr ""
"Nyckel-värde-par matchas med hjälp av tvåargumentformen av "
"mappningsobjektets metod ``get()``.  Matchade nyckel-värdepar måste redan "
"finnas i mappningen och får inte skapas i farten via :meth:`__missing__` "
"eller :meth:`~object.__getitem__`."

msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""
"Enkelt uttryckt ``{KEY1: P1, KEY2: P2, ... }`` matchar endast om alla "
"följande händelser inträffar:"

msgid "check ``<subject>`` is a mapping"
msgstr "kontrollera att ``<subject>`` är en mappning"

msgid "``KEY1 in <subject>``"
msgstr "``KEY1 i <subject>``"

msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` matchar ``<subject>[KEY1]``"

msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "... och så vidare för motsvarande KEY/mönsterpar."

msgid "Class Patterns"
msgstr "Klassmönster"

msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""
"Ett klassmönster representerar en klass och dess positions- och "
"nyckelordsargument (om sådana finns).  Syntaxen är"

msgid "The same keyword should not be repeated in class patterns."
msgstr "Samma nyckelord bör inte upprepas i klassmönster."

msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""
"Följande är det logiska flödet för att matcha ett klassmönster mot ett "
"ämnesvärde:"

msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr ""
"Om ``name_or_attr`` inte är en instans av den inbyggda :class:`type` , "
"raise :exc:`TypeError`."

msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr ""
"Om ämnesvärdet inte är en instans av ``name_or_attr`` (testas via :func:"
"`isinstance`) misslyckas klassmönstret."

msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""
"Om det inte finns några mönsterargument lyckas mönstret.  I annat fall beror "
"de efterföljande stegen på om det finns nyckelords- eller "
"positionsargumentmönster."

msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""
"För ett antal inbyggda typer (specificeras nedan) accepteras ett enda "
"positionellt undermönster som matchar hela ämnet; för dessa typer fungerar "
"nyckelordsmönster också som för andra typer."

msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""
"Om det bara finns nyckelordsmönster behandlas de enligt följande, ett efter "
"ett:"

msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. Nyckelordet ses som ett attribut i ämnet."

msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""
"Om detta ger upphov till ett annat undantag än :exc:`AttributeError`, "
"bubblar undantaget upp."

msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr ""
"Om detta ger upphov till :exc:`AttributeError`, har klassmönstret "
"misslyckats."

msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""
"Annars matchas det undermönster som är associerat med nyckelordsmönstret mot "
"subjektets attributvärde.  Om detta misslyckas, misslyckas klassmönstret; om "
"detta lyckas, fortsätter matchningen till nästa nyckelord."

msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr "II. Om alla nyckelordsmönster lyckas, lyckas klassmönstret."

msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"Om det finns positionella mönster konverteras de till nyckelordsmönster med "
"hjälp av attributet :data:`~object.__match_args__` på klassen "
"``name_or_attr`` före matchning:"

msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr ""
"I. Motsvarigheten till ``getattr(cls, \"__match_args__\", ())`` anropas."

msgid "If this raises an exception, the exception bubbles up."
msgstr "Om detta ger upphov till ett undantag, bubblar undantaget upp."

msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr ""
"Om det returnerade värdet inte är en tupel misslyckas konverteringen och :"
"exc:`TypeError` aktiveras."

msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr ""
"Om det finns fler positionsmönster än ``len(cls.__match_args__)``, uppstår :"
"exc:`TypeError`."

msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"Annars konverteras det positionella mönstret ``i`` till ett "
"nyckelordsmönster med ``__match_args__[i]`` som nyckelord.  "
"``__match_args__[i]`` måste vara en sträng; om inte :exc:`TypeError` tas upp."

msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "Om det finns dubbla nyckelord kommer :exc:`TypeError` att tas upp."

msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`klass-mönstermatchning`"

msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr "II. När alla positionsmönster har omvandlats till sökordsmönster,"

msgid "the match proceeds as if there were only keyword patterns."
msgstr "matchningen fortsätter som om det bara fanns nyckelordsmönster."

msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""
"För följande inbyggda typer är hanteringen av positionella submönster "
"annorlunda:"

msgid ":class:`bool`"
msgstr ":class:`bool`"

msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

msgid ":class:`bytes`"
msgstr ":class:`bytes`"

msgid ":class:`dict`"
msgstr ":class:`dict`"

msgid ":class:`float`"
msgstr ":class:`float`"

msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

msgid ":class:`int`"
msgstr ":class:`int`"

msgid ":class:`list`"
msgstr ":class:`lista`"

msgid ":class:`set`"
msgstr ":class:`set`"

msgid ":class:`str`"
msgstr ":class:`str`"

msgid ":class:`tuple`"
msgstr ":class:`tuple`"

msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"Dessa klasser accepterar ett enda positionellt argument, och mönstret där "
"matchas mot hela objektet snarare än ett attribut. Till exempel ``int(0|1)`` "
"matchar värdet ``0``, men inte värdet ``0,0``."

msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""
"Enkelt uttryckt ``CLS(P1, attr=P2)`` matchar endast om följande inträffar:"

msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<subject>, CLS)``"

msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""
"konvertera ``P1`` till ett nyckelordsmönster med ``CLS.__match_args__``"

msgid "For each keyword argument ``attr=P2``:"
msgstr "För varje nyckelordsargument ``attr=P2``:"

msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``harattr(<subject>, \"attr\")``"

msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` matchar ``<subject>.attr``"

msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr "... och så vidare för motsvarande nyckelordsargument/mönsterpar."

msgid "Function definitions"
msgstr "Definitioner av funktioner"

msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"En funktionsdefinition definierar ett användardefinierat funktionsobjekt (se "
"avsnitt :ref:`types`):"

msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"En funktionsdefinition är en exekverbar sats.  När den exekveras binds "
"funktionsnamnet i den aktuella lokala namnrymden till ett funktionsobjekt "
"(ett omslag runt den exekverbara koden för funktionen).  Detta "
"funktionsobjekt innehåller en referens till den aktuella globala namnrymden "
"som den globala namnrymd som ska användas när funktionen anropas."

msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"Funktionsdefinitionen exekverar inte funktionens kropp; denna exekveras "
"först när funktionen anropas. "

msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"En funktionsdefinition kan omslutas av ett eller flera :term:`decorator` -"
"uttryck. Dekoratoruttryck utvärderas när funktionen definieras, i det scope "
"som innehåller funktionsdefinitionen.  Resultatet måste vara en callable, "
"som anropas med funktionsobjektet som enda argument. Det returnerade värdet "
"är bundet till funktionsnamnet i stället för till funktionsobjektet.  Flera "
"dekoratorer tillämpas på ett nästlat sätt. Till exempel följande kod ::"

msgid ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"

msgid "is roughly equivalent to ::"
msgstr "är ungefär likvärdigt med ::"

msgid ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"
msgstr ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"

msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"förutom att den ursprungliga funktionen inte är temporärt bunden till namnet "
"``func``."

msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Funktioner kan dekoreras med valfri giltig :token:`~python-grammar:"
"assignment_expression`. Tidigare var grammatiken mycket mer restriktiv; se :"
"pep:`614` för detaljer."

msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets between the function's name and the opening parenthesis for its "
"parameter list. This indicates to static type checkers that the function is "
"generic. At runtime, the type parameters can be retrieved from the "
"function's :attr:`~function.__type_params__` attribute. See :ref:`generic-"
"functions` for more."
msgstr ""
"En lista med :ref:`typ parametrar <type-params>` kan anges inom hakparentes "
"mellan funktionens namn och den inledande parentesen för dess "
"parameterlista. Detta indikerar för statiska typkontrollanter att funktionen "
"är generisk. Vid körning kan typparametrarna hämtas från funktionens :attr:"
"`~function.__type_params__`-attribut. Se :ref:`generic-functions` för mer "
"information."

msgid "Type parameter lists are new in Python 3.12."
msgstr "Typ-parameterlistor är nya i Python 3.12."

msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"När en eller flera :term:`parametrar <parameter>` har formen *parameter* "
"``=`` *uttryck*, sägs funktionen ha \"default parameter values\"  För en "
"parameter med ett standardvärde kan motsvarande :term:`argument` utelämnas "
"från ett anrop, varvid parameterns standardvärde ersätts.  Om en parameter "
"har ett standardvärde måste alla följande parametrar fram till \"``*``\" "
"också ha ett standardvärde --- detta är en syntaktisk restriktion som inte "
"uttrycks av grammatiken."

msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Standardparametervärden utvärderas från vänster till höger när "
"funktionsdefinitionen exekveras.** Detta innebär att uttrycket utvärderas en "
"gång när funktionen definieras och att samma \"förberäknade\" värde används "
"vid varje anrop.  Detta är särskilt viktigt att förstå när ett "
"standardparametervärde är ett föränderligt objekt, t.ex. en lista eller en "
"ordbok: om funktionen ändrar objektet (t.ex. genom att lägga till ett objekt "
"i en lista), ändras i själva verket standardparametervärdet.  Detta är i "
"allmänhet inte vad som var avsett.  Ett sätt att komma runt detta är att "
"använda ``None`` som standard och uttryckligen testa för det i funktionens "
"kropp, t.ex.::"

msgid ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"
msgstr ""
"def whats_on_the_telly(penguin=None):\n"
"    om penguin är None:\n"
"        penguin = []\n"
"    penguin.append(\"djurparkens egendom\")\n"
"    returnera pingvin"

msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"Semantiken för funktionsanrop beskrivs mer i detalj i avsnitt :ref:`calls`. "
"Ett funktionsanrop tilldelar alltid värden till alla parametrar som nämns i "
"parameterlistan, antingen från positionella argument, från "
"nyckelordsargument eller från standardvärden.  Om formen \"``*identifier``\" "
"finns initialiseras den till en tupel som tar emot eventuella överflödiga "
"positionella parametrar, med den tomma tupeln som standard. Om formen "
"\"``**identifier``\" finns initieras den till en ny ordnad mappning som tar "
"emot eventuella överflödiga nyckelordsargument, med en ny tom mappning av "
"samma typ som standard.  Parametrar efter \"``*``\" eller "
"\"``*identifier``\" är endast nyckelordsparametrar och kan endast skickas "
"med nyckelordsargument.  Parametrar före \"``/``\" är endast "
"positionsparametrar och kan endast överföras med positionsargument."

msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"Syntaxen ``/`` för funktionsparametrar kan användas för att ange parametrar "
"som endast är positionella. Se :pep:`570` för detaljer."

msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``. "
"(As a special case, parameters of the form ``*identifier`` may have an "
"annotation \"``: *expression``\".) Functions may have \"return\" annotation "
"of the form \"``-> expression``\" after the parameter list.  These "
"annotations can be any valid Python expression.  The presence of annotations "
"does not change the semantics of a function. See :ref:`annotations` for more "
"information on annotations."
msgstr ""
"Parametrar kan ha en :term:`annotation <function annotation>` av formen "
"\"``: expression``\" efter parameternamnet.  Alla parametrar kan ha en "
"annotering, även de av formen ``*identifier`` eller ``**identifier``. (Som "
"ett specialfall kan parametrar av formen ``*identifier`` ha annotationen "
"\"``: *uttryck``\") Funktioner kan ha en \"return\"-annotation av formen "
"\"``-&gt; expression``\" efter parameterlistan.  Dessa annotationer kan vara "
"vilket giltigt Python-uttryck som helst.  Förekomsten av annoteringar ändrar "
"inte semantiken för en funktion. Se :ref:`annotations` för mer information "
"om annotationer."

msgid ""
"Parameters of the form \"``*identifier``\" may have an annotation \"``: "
"*expression``\". See :pep:`646`."
msgstr ""
"Parametrar av formen \"``*identifier``\" kan ha en annotation \"``: "
"*uttryck``\". Se :pep:`646`."

msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Det är också möjligt att skapa anonyma funktioner (funktioner som inte är "
"knutna till ett namn) för omedelbar användning i uttryck.  Här används "
"lambda-uttryck, som beskrivs i avsnitt :ref:`lambda`.  Observera att "
"lambdauttrycket bara är en förkortning för en förenklad funktionsdefinition; "
"en funktion som definieras i en \":keyword:`def`\"-sats kan skickas runt "
"eller tilldelas ett annat namn precis som en funktion som definieras av ett "
"lambdauttryck.  Formen \":keyword:`!def`\" är faktiskt mer kraftfull "
"eftersom den tillåter exekvering av flera satser och annoteringar."

msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Programmerarens anmärkning:** Funktioner är första klassens objekt.  En "
"\"``def``\"-sats som exekveras inuti en funktionsdefinition definierar en "
"lokal funktion som kan returneras eller skickas runt.  Fria variabler som "
"används i den nästlade funktionen kan komma åt de lokala variablerna i den "
"funktion som innehåller def. Se avsnitt :ref:`naming` för detaljer."

msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Funktionskommentarer"

msgid "The original specification for function annotations."
msgstr "Den ursprungliga specifikationen för funktionsannoteringar."

msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Tips om typ"

msgid "Definition of a standard meaning for annotations: type hints."
msgstr "Definition av en standardbetydelse för annotationer: typ hints."

msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Syntax för variabelkommentarer"

msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables."
msgstr ""
"Möjlighet att typhinta variabeldeklarationer, inklusive klassvariabler och "
"instansvariabler."

msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Uppskjuten utvärdering av annoteringar"

msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Stöd för framåtriktade referenser inom annotationer genom att bevara "
"annotationer i strängform vid körning istället för ivrig utvärdering."

msgid ":pep:`318` - Decorators for Functions and Methods"
msgstr ":pep:`318` - Dekoratorer för funktioner och metoder"

msgid ""
"Function and method decorators were introduced. Class decorators were "
"introduced in :pep:`3129`."
msgstr ""
"Funktions- och metoddekoratorer introducerades. Klassdekoratorer "
"introducerades i :pep:`3129`."

msgid "Class definitions"
msgstr "Klassdefinitioner"

msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"En klassdefinition definierar ett klassobjekt (se avsnitt :ref:`types`):"

msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"En klassdefinition är ett körbart uttalande.  Arvslistan ger vanligtvis en "
"lista över basklasser (se :ref:`metaclasses` för mer avancerade "
"användningsområden), så varje objekt i listan bör utvärderas till ett "
"klassobjekt som tillåter underklassning.  Klasser utan en arvslista ärver, "
"som standard, från basklassen :class:`object`; därav ::"

msgid ""
"class Foo:\n"
"    pass"
msgstr ""
"klass Foo:\n"
"    pass"

msgid "is equivalent to ::"
msgstr "är likvärdig med ::"

msgid ""
"class Foo(object):\n"
"    pass"
msgstr ""
"klass Foo(objekt):\n"
"    pass"

msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"Klassens svit exekveras sedan i en ny exekveringsram (se :ref:`naming`), med "
"en nyskapad lokal namnrymd och den ursprungliga globala namnrymden. "
"(Vanligtvis innehåller sviten mest funktionsdefinitioner.) När klassens svit "
"är färdig exekverad kasseras dess exekveringsram men dess lokala namnrymd "
"sparas. [#]_ Ett klassobjekt skapas sedan med hjälp av arvslistan för "
"basklasserna och det sparade lokala namnområdet för attributdictionariet.  "
"Klassnamnet är bundet till detta klassobjekt i den ursprungliga lokala "
"namnrymden."

msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's :attr:`~type.__dict__`.  Note that this is reliable only "
"right after the class is created and only for classes that were defined "
"using the definition syntax."
msgstr ""
"Den ordning i vilken attributen definieras i klassens kropp bevaras i den "
"nya klassens :attr:`~type.__dict__`.  Observera att detta endast är "
"tillförlitligt direkt efter att klassen har skapats och endast för klasser "
"som definierades med definitionssyntaxen."

msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"Skapandet av klasser kan anpassas kraftigt med hjälp av :ref:`metaclasses "
"<metaclasses>`."

msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"Klasser kan också dekoreras: precis som när du dekorerar funktioner, ::"

msgid ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"klass Foo: pass"

msgid ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"
msgstr ""
"klass Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"

msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Utvärderingsreglerna för dekoratoruttrycken är desamma som för "
"funktionsdekoratorer.  Resultatet binds sedan till klassnamnet."

msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Klasser kan dekoreras med valfri giltig :token:`~python-grammar:"
"assignment_expression`. Tidigare var grammatiken mycket mer restriktiv; se :"
"pep:`614` för detaljer."

msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets immediately after the class's name. This indicates to static type "
"checkers that the class is generic. At runtime, the type parameters can be "
"retrieved from the class's :attr:`~type.__type_params__` attribute. See :ref:"
"`generic-classes` for more."
msgstr ""
"En lista med :ref:`typ-parametrar <type-params>` kan anges inom "
"hakparenteser omedelbart efter klassens namn. Detta indikerar för statiska "
"typkontrollanter att klassen är generisk. Vid körning kan typ-parametrarna "
"hämtas från klassens :attr:`~type.__type_params__`-attribut. Se :ref:"
"`generic-classes` för mer information."

msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Variabler som definieras i klassdefinitionen är klassattribut; de delas av "
"instanser.  Instansattribut kan ställas in i en metod med ``self.name = "
"value``.  Både klass- och instansattribut är åtkomliga genom notationen "
"\"``self.name``\", och ett instansattribut döljer ett klassattribut med "
"samma namn när det är åtkomligt på detta sätt.  Klassattribut kan användas "
"som standard för instansattribut, men att använda föränderliga värden där "
"kan leda till oväntade resultat. :ref:``Descriptors <descriptors>`` kan "
"användas för att skapa instansvariabler med olika implementationsdetaljer."

msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaklasser i Python 3000"

msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"Förslaget som ändrade deklarationen av metaklasser till den nuvarande "
"syntaxen, och semantiken för hur klasser med metaklasser konstrueras."

msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Klassdekoratorer"

msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"Förslaget som lade till klassdekoratorer.  Funktions- och metoddekoratorer "
"introducerades i :pep:`318`."

msgid "Coroutines"
msgstr "Coroutines"

msgid "Coroutine function definition"
msgstr "Definition av Coroutine-funktion"

msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"Exekveringen av Python coroutines kan avbrytas och återupptas på många "
"ställen (se :term:`coroutine`). uttrycken :keyword:`await`, :keyword:`async "
"for` och :keyword:`async with` kan endast användas i en coroutine-funktion."

msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Funktioner som definieras med syntaxen ``async def`` är alltid coroutine-"
"funktioner, även om de inte innehåller nyckelorden ``await`` eller ``async``."

msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Det är ett :exc:`SyntaxError` att använda ett ``yield from``-uttryck inuti "
"en coroutine-funktion."

msgid "An example of a coroutine function::"
msgstr "Ett exempel på en coroutine-funktion::"

msgid ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"
msgstr ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await någon_coroutine()"

msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""
"``await`` och ``async`` är nu nyckelord; tidigare behandlades de bara som "
"sådana inom en coroutine-funktion."

msgid "The :keyword:`!async for` statement"
msgstr "Nyckelordet: `!async for`-satsen"

msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"En :term:`asynkron iterabel` tillhandahåller en ``__aiter__``-metod som "
"direkt returnerar en :term:`asynkron iterator``, som kan anropa asynkron kod "
"i sin ``__anext__``-metod."

msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"Satsen ``async for`` möjliggör bekväm iteration över asynkrona iterabler."

msgid ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"asynkron för TARGET i ITER:\n"
"    SUITE\n"
"annat:\n"
"    SUITE2"

msgid "Is semantically equivalent to::"
msgstr "Är semantiskt ekvivalent med::"

msgid ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"iter = (ITER)\n"
"iter = typ(iter).__aiter__(iter)\n"
"kör = sant\n"
"\n"
"medan körs:\n"
"    try:\n"
"        TARGET = await typ(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"

msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"Se även :meth:`~object.__aiter__` och :meth:`~object.__anext__` för mer "
"information."

msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Det är ett :exc:`SyntaxError` att använda en ``async for``-sats utanför "
"kroppen på en coroutine-funktion."

msgid "The :keyword:`!async with` statement"
msgstr "Nyckelordet: `!async with`-satsen"

msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"En :term:`asynkron kontexthanterare` är en :term:`kontexthanterare` som kan "
"avbryta exekveringen i sina *enter*- och *exit*-metoder."

msgid ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"async med EXPRESSION som TARGET:\n"
"    SUITE"

msgid ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"
msgstr ""
"manager = (Uttryck)\n"
"aenter = typ(chef).__aenter__\n"
"aexit = typ(manager).__aexit__\n"
"value = await aenter(chef)\n"
"hit_except = Falsk\n"
"\n"
"försök:\n"
"    TARGET = värde\n"
"    SUITE\n"
"undantag:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        höjning\n"
"slutligen:\n"
"    om inte hit_except:\n"
"        await aexit(chef, Ingen, Ingen, Ingen)"

msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"Se även :meth:`~object.__aenter__` och :meth:`~object.__aexit__` för mer "
"information."

msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Det är ett :exc:`SyntaxError` att använda en ``async with``-sats utanför "
"kroppen på en coroutine-funktion."

msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Coroutines med async- och await-syntax"

msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"Förslaget som gjorde coroutines till ett riktigt fristående koncept i Python "
"och lade till stödjande syntax."

msgid "Type parameter lists"
msgstr "Typ parameterlistor"

msgid "Support for default values was added (see :pep:`696`)."
msgstr "Stöd för standardvärden har lagts till (se :pep:`696`)."

msgid ""
":ref:`Functions <def>` (including :ref:`coroutines <async def>`), :ref:"
"`classes <class>` and :ref:`type aliases <type>` may contain a type "
"parameter list::"
msgstr ""
":ref:`Functions <def>` (inklusive :ref:`coroutines <async def>`), :ref:"
"`classes <class>` och :ref:`type aliases <type>` kan innehålla en typ "
"parameter list::"

msgid ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"
msgstr ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"klass Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"typ ListOrSet[T] = list[T] | set[T]"

msgid ""
"Semantically, this indicates that the function, class, or type alias is "
"generic over a type variable. This information is primarily used by static "
"type checkers, and at runtime, generic objects behave much like their non-"
"generic counterparts."
msgstr ""
"Semantiskt sett indikerar detta att funktionen, klassen eller typaliaset är "
"generiskt över en typvariabel. Denna information används främst av statiska "
"typkontrollanter, och vid körning beter sig generiska objekt ungefär som "
"sina icke-generiska motsvarigheter."

msgid ""
"Type parameters are declared in square brackets (``[]``) immediately after "
"the name of the function, class, or type alias. The type parameters are "
"accessible within the scope of the generic object, but not elsewhere. Thus, "
"after a declaration ``def func[T](): pass``, the name ``T`` is not available "
"in the module scope. Below, the semantics of generic objects are described "
"with more precision. The scope of type parameters is modeled with a special "
"function (technically, an :ref:`annotation scope <annotation-scopes>`) that "
"wraps the creation of the generic object."
msgstr ""
"Typparametrar deklareras inom hakparenteser (``[]``) omedelbart efter namnet "
"på funktionen, klassen eller typaliaset. Typ-parametrarna är åtkomliga inom "
"det generiska objektets scope, men inte någon annanstans. Efter en "
"deklaration ``def func[T](): pass`` är således namnet ``T`` inte "
"tillgängligt i modulens scope. Nedan beskrivs semantiken för generiska "
"objekt med större precision. Omfattningen av typparametrar modelleras med en "
"speciell funktion (tekniskt sett en :ref:`annotation scope <annotation-"
"scopes>`) som omsluter skapandet av det generiska objektet."

msgid ""
"Generic functions, classes, and type aliases have a :attr:`~definition."
"__type_params__` attribute listing their type parameters."
msgstr ""
"Generiska funktioner, klasser och typaliaser har ett :attr:`~definition."
"__type_params__`-attribut som listar deras typparametrar."

msgid "Type parameters come in three kinds:"
msgstr "Det finns tre olika typer av parametrar:"

msgid ""
":data:`typing.TypeVar`, introduced by a plain name (e.g., ``T``). "
"Semantically, this represents a single type to a type checker."
msgstr ""
":data:`typing.TypeVar`, inleds med ett vanligt namn (t.ex. ``T``). "
"Semantiskt representerar detta en enda typ för en typkontrollör."

msgid ""
":data:`typing.TypeVarTuple`, introduced by a name prefixed with a single "
"asterisk (e.g., ``*Ts``). Semantically, this stands for a tuple of any "
"number of types."
msgstr ""
":data:`typing.TypeVarTuple`, inleds med ett namn som föregås av en asterisk "
"(t.ex. ``*Ts``). Semantiskt står detta för en tupel av valfritt antal typer."

msgid ""
":data:`typing.ParamSpec`, introduced by a name prefixed with two asterisks "
"(e.g., ``**P``). Semantically, this stands for the parameters of a callable."
msgstr ""
":data:`typing.ParamSpec`, inleds med ett namn som föregås av två asterisker "
"(t.ex. ``**P``). Semantiskt står detta för parametrarna för en callable."

msgid ""
":data:`typing.TypeVar` declarations can define *bounds* and *constraints* "
"with a colon (``:``) followed by an expression. A single expression after "
"the colon indicates a bound (e.g. ``T: int``). Semantically, this means that "
"the :data:`!typing.TypeVar` can only represent types that are a subtype of "
"this bound. A parenthesized tuple of expressions after the colon indicates a "
"set of constraints (e.g. ``T: (str, bytes)``). Each member of the tuple "
"should be a type (again, this is not enforced at runtime). Constrained type "
"variables can only take on one of the types in the list of constraints."
msgstr ""
":data:`typing.TypeVar`-deklarationer kan definiera *gränser* och "
"*begränsningar* med ett kolon (``:``) följt av ett uttryck. Ett enda uttryck "
"efter kolon anger en bound (t.ex. ``T: int``). Semantiskt innebär detta att :"
"data:`!typing.TypeVar` endast kan representera typer som är en subtyp av "
"denna bound. En parentesförsedd tupel av uttryck efter kolon anger en "
"uppsättning begränsningar (t.ex. ``T: (str, bytes)``). Varje medlem i tupeln "
"bör vara en typ (återigen, detta verkställs inte vid körning). Variabler av "
"typen Constrained kan bara anta en av typerna i listan med begränsningar."

msgid ""
"For :data:`!typing.TypeVar`\\ s declared using the type parameter list "
"syntax, the bound and constraints are not evaluated when the generic object "
"is created, but only when the value is explicitly accessed through the "
"attributes ``__bound__`` and ``__constraints__``. To accomplish this, the "
"bounds or constraints are evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`."
msgstr ""
"För :data:`!typing.TypeVar`` som deklareras med hjälp av syntaxen för typ-"
"parameterlistan utvärderas inte bindningarna och begränsningarna när det "
"generiska objektet skapas, utan endast när värdet uttryckligen nås via "
"attributen ``__bound__`` och ``__constraints__``. För att åstadkomma detta "
"utvärderas gränserna eller begränsningarna i en separat :ref:`annotation "
"scope <annotation-scopes>`."

msgid ""
":data:`typing.TypeVarTuple`\\ s and :data:`typing.ParamSpec`\\ s cannot have "
"bounds or constraints."
msgstr ""
":data:`typing.TypeVarTuple` s och :data:`typing.ParamSpec` s kan inte ha "
"gränser eller begränsningar."

msgid ""
"All three flavors of type parameters can also have a *default value*, which "
"is used when the type parameter is not explicitly provided. This is added by "
"appending a single equals sign (``=``) followed by an expression. Like the "
"bounds and constraints of type variables, the default value is not evaluated "
"when the object is created, but only when the type parameter's "
"``__default__`` attribute is accessed. To this end, the default value is "
"evaluated in a separate :ref:`annotation scope <annotation-scopes>`. If no "
"default value is specified for a type parameter, the ``__default__`` "
"attribute is set to the special sentinel object :data:`typing.NoDefault`."
msgstr ""
"Alla tre typerna av typparametrar kan också ha ett *standardvärde*, som "
"används när typparametern inte anges explicit. Detta läggs till genom att "
"lägga till ett enda likhetstecken (``=``) följt av ett uttryck. Precis som "
"typvariablernas gränser och begränsningar utvärderas inte standardvärdet när "
"objektet skapas, utan först när typparameterns attribut ``__default__`` "
"används. Därför utvärderas standardvärdet i en separat :ref:`annotation "
"scope <annotation-scopes>`. Om inget standardvärde anges för en typparameter "
"sätts attributet ``__default__`` till det speciella sentinel-objektet :data:"
"`typing.NoDefault`."

msgid ""
"The following example indicates the full set of allowed type parameter "
"declarations::"
msgstr ""
"Följande exempel visar hela uppsättningen av tillåtna deklarationer av "
"typparametrar::"

msgid ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithDefault,\n"
"   c: TypeVarWithBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."
msgstr ""
"def överdrivet_generisk[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithDefault = int,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple = (int, float),\n"
"   **SimpleParamSpec = (str, bytearray),\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarMedFault,\n"
"   c: TypeVarMedBound,\n"
"   d: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *e: SimpleTypeVarTuple,\n"
"): ..."

msgid "Generic functions"
msgstr "Generiska funktioner"

msgid "Generic functions are declared as follows::"
msgstr "Generiska funktioner deklareras på följande sätt::"

msgid "def func[T](arg: T): ..."
msgstr "def func[T](arg: T): ..."

msgid "This syntax is equivalent to::"
msgstr "Denna syntax är likvärdig med::"

msgid ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    returnera func\n"
"func = TYPE_PARAMS_OF_func()"

msgid ""
"Here ``annotation-def`` indicates an :ref:`annotation scope <annotation-"
"scopes>`, which is not actually bound to any name at runtime. (One other "
"liberty is taken in the translation: the syntax does not go through "
"attribute access on the :mod:`typing` module, but creates an instance of :"
"data:`typing.TypeVar` directly.)"
msgstr ""
"Här anger ``annotation-def`` en :ref:`annotation scope <annotation-scopes>`, "
"som inte är bunden till något namn vid körning. (En annan frihet tas i "
"översättningen: syntaxen går inte genom attributåtkomst på modulen :mod:"
"`typing`, utan skapar en instans av :data:`typing.TypeVar` direkt)"

msgid ""
"The annotations of generic functions are evaluated within the annotation "
"scope used for declaring the type parameters, but the function's defaults "
"and decorators are not."
msgstr ""
"Annoteringarna för generiska funktioner utvärderas inom det "
"annoteringsområde som används för att deklarera typparametrarna, men det gör "
"inte funktionens standardvärden och dekoratorer."

msgid ""
"The following example illustrates the scoping rules for these cases, as well "
"as for additional flavors of type parameters::"
msgstr ""
"Följande exempel illustrerar scopingreglerna för dessa fall, samt för "
"ytterligare varianter av typparametrar::"

msgid ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."
msgstr ""
"@dekorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."

msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the :class:"
"`~typing.TypeVar` bound, this is equivalent to::"
msgstr ""
"Med undantag för :ref:`lazy evaluation <lazy-evaluation>` av :class:`~typing."
"TypeVar`-bindningen, är detta likvärdigt med::"

msgid ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"
msgstr ""
"DEFAULT_OF_arg = någon_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        returnera int\n"
"    # I verkligheten utvärderas BOUND_OF_T() endast på begäran.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    returnera func\n"
"func = dekorator(TYPE_PARAMS_OF_func())"

msgid ""
"The capitalized names like ``DEFAULT_OF_arg`` are not actually bound at "
"runtime."
msgstr ""
"De versala namnen som ``DEFAULT_OF_arg`` är faktiskt inte bundna vid körning."

msgid "Generic classes"
msgstr "Generiska klasser"

msgid "Generic classes are declared as follows::"
msgstr "Generiska klasser deklareras på följande sätt::"

msgid "class Bag[T]: ..."
msgstr "class Bag[T]: ..."

msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    returnera Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"

msgid ""
"Here again ``annotation-def`` (not a real keyword) indicates an :ref:"
"`annotation scope <annotation-scopes>`, and the name ``TYPE_PARAMS_OF_Bag`` "
"is not actually bound at runtime."
msgstr ""
"Även här anger ``annotation-def`` (inte ett riktigt nyckelord) en :ref:"
"`annotation scope <annotation-scopes>`, och namnet ``TYPE_PARAMS_OF_Bag`` är "
"inte faktiskt bundet vid körning."

msgid ""
"Generic classes implicitly inherit from :data:`typing.Generic`. The base "
"classes and keyword arguments of generic classes are evaluated within the "
"type scope for the type parameters, and decorators are evaluated outside "
"that scope. This is illustrated by this example::"
msgstr ""
"Generiska klasser ärver implicit från :data:`typing.Generic`. Basklasserna "
"och nyckelordsargumenten för generiska klasser utvärderas inom typomfånget "
"för typparametrarna, och dekoratorer utvärderas utanför detta omfång. Detta "
"illustreras av detta exempel::"

msgid ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."
msgstr ""
"@dekoratör\n"
"class Bag(Base[T], arg=T): ..."

msgid "This is equivalent to::"
msgstr "Detta är likvärdigt med::"

msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = dekorator(TYPE_PARAMS_OF_Bag())"

msgid "Generic type aliases"
msgstr "Alias för generiska typer"

msgid ""
"The :keyword:`type` statement can also be used to create a generic type "
"alias::"
msgstr ""
"Satsen :keyword:`type` kan också användas för att skapa ett generiskt "
"typalias::"

msgid "type ListOrSet[T] = list[T] | set[T]"
msgstr "typ ListOrSet[T] = list[T] | set[T]"

msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the value, this "
"is equivalent to::"
msgstr ""
"Med undantag för :ref:`långsam utvärdering <lazy-evaluation>` av värdet, är "
"detta likvärdigt med::"

msgid ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # I verkligheten utvärderas värdet lättsinnigt\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"

msgid ""
"Here, ``annotation-def`` (not a real keyword) indicates an :ref:`annotation "
"scope <annotation-scopes>`. The capitalized names like "
"``TYPE_PARAMS_OF_ListOrSet`` are not actually bound at runtime."
msgstr ""
"Här anger ``annotation-def`` (inte ett riktigt nyckelord) en :ref:"
"``annotation scope <annotation-scopes>`. De versala namnen som "
"``TYPE_PARAMS_OF_ListOrSet`` är faktiskt inte bundna vid körning."

msgid "Annotations"
msgstr "Anteckningar"

msgid "Annotations are now lazily evaluated by default."
msgstr "Annotationer utvärderas nu lättsamt som standard."

msgid ""
"Variables and function parameters may carry :term:`annotations "
"<annotation>`, created by adding a colon after the name, followed by an "
"expression::"
msgstr ""
"Variabler och funktionsparametrar kan ha :term:`annotationer <annotation>`, "
"som skapas genom att lägga till ett kolon efter namnet, följt av ett "
"uttryck::"

msgid ""
"x: annotation = 1\n"
"def f(param: annotation): ..."
msgstr ""
"x: anteckning = 1\n"
"def f(param: annotation): ..."

msgid "Functions may also carry a return annotation following an arrow::"
msgstr "Funktioner kan också ha en returannotering som följer en pil::"

msgid "def f() -> annotation: ..."
msgstr "def f() -> annotation: ..."

msgid ""
"Annotations are conventionally used for :term:`type hints <type hint>`, but "
"this is not enforced by the language, and in general annotations may contain "
"arbitrary expressions. The presence of annotations does not change the "
"runtime semantics of the code, except if some mechanism is used that "
"introspects and uses the annotations (such as :mod:`dataclasses` or :func:"
"`functools.singledispatch`)."
msgstr ""
"Annotationer används konventionellt för :term:`type hints <type hint>`, men "
"detta är inte påtvingat av språket, och i allmänhet kan annotationer "
"innehålla godtyckliga uttryck. Förekomsten av annoteringar ändrar inte "
"kodens körtidssemantik, förutom om någon mekanism används som introspekterar "
"och använder annoteringarna (t.ex. :mod:`dataclasses` eller :func:`functools."
"singledispatch`)."

msgid ""
"By default, annotations are lazily evaluated in an :ref:`annotation scope "
"<annotation-scopes>`. This means that they are not evaluated when the code "
"containing the annotation is evaluated. Instead, the interpreter saves "
"information that can be used to evaluate the annotation later if requested. "
"The :mod:`annotationlib` module provides tools for evaluating annotations."
msgstr ""
"Som standard utvärderas annoteringar i ett :ref:`annotation scope "
"<annotation-scopes>`. Detta innebär att de inte utvärderas när koden som "
"innehåller annotationen utvärderas. Istället sparar tolken information som "
"kan användas för att utvärdera annotationen senare om så begärs. Modulen :"
"mod:`annotationlib` tillhandahåller verktyg för att utvärdera annotationer."

msgid ""
"If the :ref:`future statement <future>` ``from __future__ import "
"annotations`` is present, all annotations are instead stored as strings::"
msgstr ""
"Om :ref:`future-satsen <future>` ``from __future__ import annotations`` är "
"närvarande, lagras alla annotationer istället som strängar::"

msgid ""
">>> from __future__ import annotations\n"
">>> def f(param: annotation): ...\n"
">>> f.__annotations__\n"
"{'param': 'annotation'}"
msgstr ""
">>> from __future__ import annotations\n"
">>> def f(param: annotation): ...\n"
">>> f.__annotations__\n"
"{'param': 'annotation'}"

msgid ""
"This future statement will be deprecated and removed in a future version of "
"Python, but not before Python 3.13 reaches its end of life (see :pep:`749`). "
"When it is used, introspection tools like :func:`annotationlib."
"get_annotations` and :func:`typing.get_type_hints` are less likely to be "
"able to resolve annotations at runtime."
msgstr ""
"Detta framtida uttalande kommer att vara föråldrat och tas bort i en "
"framtida version av Python, men inte innan Python 3.13 når sitt livs slut "
"(se :pep:`749`). När det används är det mindre sannolikt att "
"introspektionsverktyg som :func:`annotationlib.get_annotations` och :func:"
"`typing.get_type_hints` kan lösa annoteringar vid körning."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"Undantaget sprids till anropsstacken om det inte finns en :keyword:`finally`-"
"klausul som råkar ge upphov till ett annat undantag. Det nya undantaget gör "
"att det gamla går förlorat."

msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr "Vid mönstermatchning definieras en sekvens som något av följande:"

msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "en klass som ärver från :class:`collections.abc.Sequence`"

msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr ""
"en Python-klass som har registrerats som :class:`collections.abc.Sequence`"

msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""
"en inbyggd klass som har sin (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit "
"inställd"

msgid "a class that inherits from any of the above"
msgstr "en klass som ärver från någon av ovanstående"

msgid "The following standard library classes are sequences:"
msgstr "Följande standardbiblioteksklasser är sekvenser:"

msgid ":class:`array.array`"
msgstr ":class:`array.array`"

msgid ":class:`collections.deque`"
msgstr ":class:`samlingar.deque`"

msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

msgid ":class:`range`"
msgstr ":class:`intervall`"

msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""
"Ämnesvärden av typen ``str``, ``bytes`` och ``bytearray`` matchar inte "
"sekvensmönster."

msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr "Vid mönstermatchning definieras en mappning som något av följande:"

msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "en klass som ärver från :class:`collections.abc.Mapping`"

msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr ""
"en Python-klass som har registrerats som :class:`collections.abc.Mapping`"

msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""
"en inbyggd klass som har sin (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit "
"inställd"

msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr ""
"Standardbiblioteksklasserna :class:`dict` och :class:`types."
"MappingProxyType` är mappningar."

msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's :attr:`~function.__doc__` attribute and "
"therefore the function's :term:`docstring`."
msgstr ""
"En bokstavlig sträng som förekommer som första sats i funktionens kropp "
"omvandlas till funktionens :attr:`~function.__doc__`-attribut och därmed "
"till funktionens :term:`docstring`."

msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's :attr:`~type.__doc__` item and therefore "
"the class's :term:`docstring`."
msgstr ""
"En bokstavlig sträng som förekommer som första sats i klassens kropp "
"omvandlas till namnrymdens :attr:`~type.__doc__`-objekt och därmed till "
"klassens :term:`docstring`."

msgid "compound"
msgstr "förening"

msgid "statement"
msgstr "uttalande"

msgid "clause"
msgstr "klausul"

msgid "suite"
msgstr "svit"

msgid "; (semicolon)"
msgstr "; (semikolon)"

msgid "NEWLINE token"
msgstr "NEWLINE-token"

msgid "DEDENT token"
msgstr "DEDENT-token"

msgid "dangling"
msgstr "dinglande"

msgid "else"
msgstr "annat"

msgid "if"
msgstr "om"

msgid "keyword"
msgstr "sökord"

msgid "elif"
msgstr "elif"

msgid ": (colon)"
msgstr ": (kolon)"

msgid "compound statement"
msgstr "sammansatt uttalande"

msgid "while"
msgstr "medan"

msgid "loop"
msgstr "loop"

msgid "break"
msgstr "bryta"

msgid "continue"
msgstr "fortsätta"

msgid "for"
msgstr "för"

msgid "in"
msgstr "i"

msgid "target"
msgstr "lokation"

msgid "list"
msgstr "lista"

msgid "object"
msgstr "objekt"

msgid "sequence"
msgstr "sekvens"

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "range"
msgstr "intervall"

msgid "try"
msgstr "försök"

msgid "except"
msgstr "utom"

msgid "finally"
msgstr "slutligen"

msgid "as"
msgstr "som"

msgid "except clause"
msgstr "utom klausul"

msgid "module"
msgstr "modul"

msgid "sys"
msgstr "system"

msgid "traceback"
msgstr "spårning"

msgid "except_star"
msgstr "utom_stjärna"

msgid "return"
msgstr "tillbaka"

msgid "with"
msgstr "med"

msgid "with statement"
msgstr "med uttalande"

msgid ", (comma)"
msgstr ", (kommatecken)"

msgid "match"
msgstr "matcha"

msgid "case"
msgstr "referens"

msgid "pattern matching"
msgstr "mönstermatchning"

msgid "match statement"
msgstr "matchningsförklaring"

msgid "guard"
msgstr "vakt"

msgid "irrefutable case block"
msgstr "obestridligt fallblock"

msgid "case block"
msgstr "fallblock"

msgid "! patterns"
msgstr "! mönster"

msgid "AS pattern, OR pattern, capture pattern, wildcard pattern"
msgstr "AS-mönster, OR-mönster, capture-mönster, jokerteckenmönster"

msgid "parameter"
msgstr "parameter"

msgid "function definition"
msgstr "definition av funktion"

msgid "def"
msgstr "def"

msgid "function"
msgstr "funktion"

msgid "definition"
msgstr "definition"

msgid "name"
msgstr "namn"

msgid "binding"
msgstr "bindning"

msgid "user-defined function"
msgstr "användardefinierad funktion"

msgid "() (parentheses)"
msgstr "() (inom parentes)"

msgid "parameter list"
msgstr "parameterlista"

msgid "@ (at)"
msgstr "@ (vid)"

msgid "default"
msgstr "standard"

msgid "value"
msgstr "värde"

msgid "argument"
msgstr "argument"

msgid "= (equals)"
msgstr "= (lika med)"

msgid "/ (slash)"
msgstr "/ (snedstreck)"

msgid "* (asterisk)"
msgstr "* (asterisk)"

msgid "**"
msgstr "**"

msgid "annotations"
msgstr "anteckningar"

msgid "->"
msgstr "->"

msgid "function annotations"
msgstr "funktionskommentarer"

msgid "lambda"
msgstr "lambda"

msgid "expression"
msgstr "uttryck"

msgid "class"
msgstr "klass"

msgid "execution"
msgstr "avrättning"

msgid "frame"
msgstr "ram"

msgid "inheritance"
msgstr "arv"

msgid "docstring"
msgstr "dokumentsträng"

msgid "class definition"
msgstr "klassdefinition"

msgid "expression list"
msgstr "uttrycksförteckning"

msgid "async def"
msgstr "asynkron def"

msgid "async"
msgstr "asynkron"

msgid "await"
msgstr "invänta"

msgid "async for"
msgstr "asynkron för"

msgid "async with"
msgstr "asynkron med"

msgid "type parameters"
msgstr "typ parametrar"
