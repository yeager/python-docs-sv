# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!lzma` --- Compression using the LZMA algorithm"
msgstr ":mod:`!lzma` --- Komprimering med hjälp av LZMA-algoritmen"

msgid "**Source code:** :source:`Lib/lzma.py`"
msgstr "**Källkod:** :source:`Lib/lzma.py`"

msgid ""
"This module provides classes and convenience functions for compressing and "
"decompressing data using the LZMA compression algorithm. Also included is a "
"file interface supporting the ``.xz`` and legacy ``.lzma`` file formats used "
"by the :program:`xz` utility, as well as raw compressed streams."
msgstr ""
"Denna modul innehåller klasser och bekvämlighetsfunktioner för komprimering "
"och dekomprimering av data med hjälp av LZMA-komprimeringsalgoritmen. "
"Dessutom ingår ett filgränssnitt som stöder filformaten ``.xz`` och ``."
"lzma`` som används av verktyget :program:`xz`, samt råkomprimerade strömmar."

msgid ""
"The interface provided by this module is very similar to that of the :mod:"
"`bz2` module. Note that :class:`LZMAFile` and :class:`bz2.BZ2File` are *not* "
"thread-safe, so if you need to use a single :class:`LZMAFile` instance from "
"multiple threads, it is necessary to protect it with a lock."
msgstr ""
"Gränssnittet som tillhandahålls av denna modul är mycket likt det i modulen :"
"mod:`bz2`. Observera att :class:`LZMAFile` och :class:`bz2.BZ2File` är "
"*inte* trådsäkra, så om du behöver använda en enda :class:`LZMAFile`-instans "
"från flera trådar, är det nödvändigt att skydda den med ett lås."

msgid ""
"This exception is raised when an error occurs during compression or "
"decompression, or while initializing the compressor/decompressor state."
msgstr ""
"Detta undantag uppstår när ett fel inträffar under komprimering eller "
"dekomprimering, eller under initiering av kompressor/dekompressortillståndet."

msgid "Reading and writing compressed files"
msgstr "Läsa och skriva komprimerade filer"

msgid ""
"Open an LZMA-compressed file in binary or text mode, returning a :term:`file "
"object`."
msgstr ""
"Öppna en LZMA-komprimerad fil i binär- eller textläge och returnera ett :"
"term:`file-objekt`."

msgid ""
"The *filename* argument can be either an actual file name (given as a :class:"
"`str`, :class:`bytes` or :term:`path-like <path-like object>` object), in "
"which case the named file is opened, or it can be an existing file object to "
"read from or write to."
msgstr ""
"Argumentet *filnamn* kan antingen vara ett faktiskt filnamn (givet som ett :"
"class:`str`, :class:`bytes` eller :term:`path-like <path-like object>`-"
"objekt), i vilket fall den namngivna filen öppnas, eller ett befintligt "
"filobjekt att läsa från eller skriva till."

msgid ""
"The *mode* argument can be any of ``\"r\"``, ``\"rb\"``, ``\"w\"``, "
"``\"wb\"``, ``\"x\"``, ``\"xb\"``, ``\"a\"`` or ``\"ab\"`` for binary mode, "
"or ``\"rt\"``, ``\"wt\"``, ``\"xt\"``, or ``\"at\"`` for text mode. The "
"default is ``\"rb\"``."
msgstr ""
"Argumentet *mode* kan vara något av ``\"r\"``, ``\"rb\"``, ``\"w\"``, "
"``\"wb\"``, ``\"x\"``, ``\"xb\"``, ``\"a\"`` eller ``\"ab\"`` för binärt "
"läge, eller ``\"rt\"``, ``\"wt\"``, ``\"xt\"`` eller ``\"at\"`` för "
"textläge. Standardvärdet är ``\"rb\"``."

msgid ""
"When opening a file for reading, the *format* and *filters* arguments have "
"the same meanings as for :class:`LZMADecompressor`. In this case, the "
"*check* and *preset* arguments should not be used."
msgstr ""
"När en fil öppnas för läsning har argumenten *format* och *filters* samma "
"innebörd som för :class:`LZMADecompressor`. I det här fallet ska argumenten "
"*check* och *preset* inte användas."

msgid ""
"When opening a file for writing, the *format*, *check*, *preset* and "
"*filters* arguments have the same meanings as for :class:`LZMACompressor`."
msgstr ""
"När en fil öppnas för skrivning har argumenten *format*, *check*, *preset* "
"och *filters* samma innebörd som för :class:`LZMACompressor`."

msgid ""
"For binary mode, this function is equivalent to the :class:`LZMAFile` "
"constructor: ``LZMAFile(filename, mode, ...)``. In this case, the "
"*encoding*, *errors* and *newline* arguments must not be provided."
msgstr ""
"För binärt läge är denna funktion likvärdig med :class:`LZMAFile`-"
"konstruktören: ``LZMAFile(filnamn, läge, ...)``. I detta fall får argumenten "
"*encoding*, *errors* och *newline* inte anges."

msgid ""
"For text mode, a :class:`LZMAFile` object is created, and wrapped in an :"
"class:`io.TextIOWrapper` instance with the specified encoding, error "
"handling behavior, and line ending(s)."
msgstr ""
"För textläge skapas ett :class:`LZMAFile`-objekt och omsluts av en :class:"
"`io.TextIOWrapper`-instans med angiven kodning, felhanteringsbeteende och "
"radavslutning(ar)."

msgid "Added support for the ``\"x\"``, ``\"xb\"`` and ``\"xt\"`` modes."
msgstr "Lagt till stöd för lägena ``\"x\"``, ``\"xb\"`` och ``\"xt\"``."

msgid "Accepts a :term:`path-like object`."
msgstr "Accepterar en :term:`path-liknande objekt`."

msgid "Open an LZMA-compressed file in binary mode."
msgstr "Öppna en LZMA-komprimerad fil i binärt läge."

msgid ""
"An :class:`LZMAFile` can wrap an already-open :term:`file object`, or "
"operate directly on a named file. The *filename* argument specifies either "
"the file object to wrap, or the name of the file to open (as a :class:"
"`str`, :class:`bytes` or :term:`path-like <path-like object>` object). When "
"wrapping an existing file object, the wrapped file will not be closed when "
"the :class:`LZMAFile` is closed."
msgstr ""
"En :class:`LZMAFile` kan omsluta ett redan öppet :term:`file-objekt`, eller "
"arbeta direkt på en namngiven fil. Argumentet *filnamn* anger antingen "
"filobjektet som ska omslutas eller namnet på filen som ska öppnas (som ett :"
"class:`str`, :class:`bytes` eller :term:``path-like <path-like object>` "
"objekt). När ett befintligt filobjekt paketeras kommer den paketerade filen "
"inte att stängas när :class:`LZMAFile` stängs."

msgid ""
"The *mode* argument can be either ``\"r\"`` for reading (default), ``\"w\"`` "
"for overwriting, ``\"x\"`` for exclusive creation, or ``\"a\"`` for "
"appending. These can equivalently be given as ``\"rb\"``, ``\"wb\"``, "
"``\"xb\"`` and ``\"ab\"`` respectively."
msgstr ""
"Argumentet *mode* kan vara antingen ``\"r\"`` för läsning (standard), "
"``\"w\"`` för överskrivning, ``\"x\"`` för exklusivt skapande eller "
"``\"a\"`` för tillägg. Dessa kan på motsvarande sätt anges som ``\"rb\"``, "
"``\"wb\"``, ``\"xb\"`` respektive ``\"ab\"``."

msgid ""
"If *filename* is a file object (rather than an actual file name), a mode of "
"``\"w\"`` does not truncate the file, and is instead equivalent to ``\"a\"``."
msgstr ""
"Om *filnamn* är ett filobjekt (snarare än ett faktiskt filnamn), trunkeras "
"inte filen i läget ``\"w\"``, utan motsvarar i stället ``\"a\"``."

msgid ""
"When opening a file for reading, the input file may be the concatenation of "
"multiple separate compressed streams. These are transparently decoded as a "
"single logical stream."
msgstr ""
"När du öppnar en fil för läsning kan inmatningsfilen vara en sammankoppling "
"av flera separata komprimerade strömmar. Dessa avkodas på ett transparent "
"sätt som en enda logisk ström."

msgid ""
":class:`LZMAFile` supports all the members specified by :class:`io."
"BufferedIOBase`, except for :meth:`~io.BufferedIOBase.detach` and :meth:`~io."
"IOBase.truncate`. Iteration and the :keyword:`with` statement are supported."
msgstr ""
":class:`LZMAFile` stöder alla medlemmar som specificeras av :class:`io."
"BufferedIOBase`, förutom :meth:`~io.BufferedIOBase.detach` och :meth:`~io."
"IOBase.truncate`. Iteration och :keyword:`with`-satsen stöds."

msgid "The following method and attributes are also provided:"
msgstr "Följande metod och attribut tillhandahålls också:"

msgid ""
"Return buffered data without advancing the file position. At least one byte "
"of data will be returned, unless EOF has been reached. The exact number of "
"bytes returned is unspecified (the *size* argument is ignored)."
msgstr ""
"Returnerar buffrade data utan att flytta fram filpositionen. Minst en byte "
"data kommer att returneras, såvida inte EOF har uppnåtts. Det exakta antalet "
"bytes som returneras är ospecificerat (argumentet *size* ignoreras)."

msgid ""
"While calling :meth:`peek` does not change the file position of the :class:"
"`LZMAFile`, it may change the position of the underlying file object (e.g. "
"if the :class:`LZMAFile` was constructed by passing a file object for "
"*filename*)."
msgstr ""
"Även om anrop av :meth:`peek` inte ändrar filpositionen för :class:"
"`LZMAFile`, kan det ändra positionen för det underliggande filobjektet (t."
"ex. om :class:`LZMAFile` konstruerades genom att skicka ett filobjekt för "
"*filnamn*)."

msgid "``'rb'`` for reading and ``'wb'`` for writing."
msgstr "``'rb'`` för läsning och ``'wb'`` för skrivning."

msgid ""
"The lzma file name.  Equivalent to the :attr:`~io.FileIO.name` attribute of "
"the underlying :term:`file object`."
msgstr ""
"Namnet på lzma-filen.  Motsvarar attributet :attr:`~io.FileIO.name` för det "
"underliggande :term:`file-objektet`."

msgid "Added support for the ``\"x\"`` and ``\"xb\"`` modes."
msgstr "Lagt till stöd för lägena ``\"x\"`` och ``\"xb\"``."

msgid ""
"The :meth:`~io.BufferedIOBase.read` method now accepts an argument of "
"``None``."
msgstr ""
"Metoden :meth:`~io.BufferedIOBase.read` accepterar nu ett argument på "
"``None``."

msgid "Compressing and decompressing data in memory"
msgstr "Komprimering och dekomprimering av data i minnet"

msgid ""
"Create a compressor object, which can be used to compress data incrementally."
msgstr ""
"Skapa ett kompressorobjekt som kan användas för att komprimera data stegvis."

msgid ""
"For a more convenient way of compressing a single chunk of data, see :func:"
"`compress`."
msgstr ""
"För ett bekvämare sätt att komprimera en enda bit data, se :func:`compress`."

msgid ""
"The *format* argument specifies what container format should be used. "
"Possible values are:"
msgstr ""
"Argumentet *format* anger vilket containerformat som ska användas. Möjliga "
"värden är:"

msgid ":const:`FORMAT_XZ`: The ``.xz`` container format."
msgstr ":const:`FORMAT_XZ`: Containerformatet ``.xz``."

msgid "This is the default format."
msgstr "Detta är standardformatet."

msgid ":const:`FORMAT_ALONE`: The legacy ``.lzma`` container format."
msgstr ":const:`FORMAT_ALONE`: Det äldre containerformatet ``.lzma``."

msgid ""
"This format is more limited than ``.xz`` -- it does not support integrity "
"checks or multiple filters."
msgstr ""
"Detta format är mer begränsat än ``.xz`` - det stöder inte "
"integritetskontroller eller flera filter."

msgid ":const:`FORMAT_RAW`: A raw data stream, not using any container format."
msgstr ""
":const:`FORMAT_RAW`: En rå dataström som inte använder något containerformat."

msgid ""
"This format specifier does not support integrity checks, and requires that "
"you always specify a custom filter chain (for both compression and "
"decompression). Additionally, data compressed in this manner cannot be "
"decompressed using :const:`FORMAT_AUTO` (see :class:`LZMADecompressor`)."
msgstr ""
"Den här formatspecificeraren stöder inte integritetskontroller och kräver "
"att du alltid anger en anpassad filterkedja (för både komprimering och "
"dekomprimering). Dessutom kan data som komprimerats på detta sätt inte "
"dekomprimeras med :const:`FORMAT_AUTO` (se :class:`LZMADecompressor`)."

msgid ""
"The *check* argument specifies the type of integrity check to include in the "
"compressed data. This check is used when decompressing, to ensure that the "
"data has not been corrupted. Possible values are:"
msgstr ""
"Argumentet *check* anger vilken typ av integritetskontroll som ska "
"inkluderas i de komprimerade data. Denna kontroll används vid dekomprimering "
"för att säkerställa att data inte har korrumperats. Möjliga värden är:"

msgid ""
":const:`CHECK_NONE`: No integrity check. This is the default (and the only "
"acceptable value) for :const:`FORMAT_ALONE` and :const:`FORMAT_RAW`."
msgstr ""
":const:`CHECK_NONE`: Ingen integritetskontroll. Detta är standardvärdet (och "
"det enda godtagbara värdet) för :const:`FORMAT_ALONE` och :const:"
"`FORMAT_RAW`."

msgid ":const:`CHECK_CRC32`: 32-bit Cyclic Redundancy Check."
msgstr ":const:`CHECK_CRC32`: 32-bitars kontroll av cyklisk redundans."

msgid ""
":const:`CHECK_CRC64`: 64-bit Cyclic Redundancy Check. This is the default "
"for :const:`FORMAT_XZ`."
msgstr ""
":const:`CHECK_CRC64`: 64-bitars kontroll av cyklisk redundans. Detta är "
"standardinställningen för :const:`FORMAT_XZ`."

msgid ":const:`CHECK_SHA256`: 256-bit Secure Hash Algorithm."
msgstr ":const:`CHECK_SHA256`: 256-bitars säker hashalgoritm."

msgid ""
"If the specified check is not supported, an :class:`LZMAError` is raised."
msgstr ""
"Om den angivna kontrollen inte stöds, genereras ett :class:`LZMAError`."

msgid ""
"The compression settings can be specified either as a preset compression "
"level (with the *preset* argument), or in detail as a custom filter chain "
"(with the *filters* argument)."
msgstr ""
"Komprimeringsinställningarna kan anges antingen som en förinställd "
"komprimeringsnivå (med argumentet *preset*) eller i detalj som en anpassad "
"filterkedja (med argumentet *filters*)."

msgid ""
"The *preset* argument (if provided) should be an integer between ``0`` and "
"``9`` (inclusive), optionally OR-ed with the constant :const:"
"`PRESET_EXTREME`. If neither *preset* nor *filters* are given, the default "
"behavior is to use :const:`PRESET_DEFAULT` (preset level ``6``). Higher "
"presets produce smaller output, but make the compression process slower."
msgstr ""
"Argumentet *preset* (om det anges) bör vara ett heltal mellan ``0`` och "
"``9`` (inklusive), eventuellt OR-at med konstanten :const:`PRESET_EXTREME`. "
"Om varken *preset* eller *filters* anges är standardbeteendet att använda :"
"const:`PRESET_DEFAULT` (förinställningsnivå ``6``). Högre förinställningar "
"ger mindre utdata, men gör komprimeringsprocessen långsammare."

msgid ""
"In addition to being more CPU-intensive, compression with higher presets "
"also requires much more memory (and produces output that needs more memory "
"to decompress). With preset ``9`` for example, the overhead for an :class:"
"`LZMACompressor` object can be as high as 800 MiB. For this reason, it is "
"generally best to stick with the default preset."
msgstr ""
"Förutom att vara mer CPU-intensiv kräver komprimering med högre "
"förinställningar också mycket mer minne (och producerar utdata som behöver "
"mer minne för att dekomprimeras). Med förinställningen ``9`` till exempel, "
"kan overhead för ett :class:`LZMACompressor`-objekt vara så högt som 800 "
"MiB. Av denna anledning är det i allmänhet bäst att hålla sig till "
"standardinställningen."

msgid ""
"The *filters* argument (if provided) should be a filter chain specifier. "
"See :ref:`filter-chain-specs` for details."
msgstr ""
"Argumentet *filters* (om det anges) bör vara en specifikation av en "
"filterkedja. Se :ref:`filter-chain-specs` för detaljer."

msgid ""
"Compress *data* (a :class:`bytes` object), returning a :class:`bytes` object "
"containing compressed data for at least part of the input. Some of *data* "
"may be buffered internally, for use in later calls to :meth:`compress` and :"
"meth:`flush`. The returned data should be concatenated with the output of "
"any previous calls to :meth:`compress`."
msgstr ""
"Komprimerar *data* (ett :class:`bytes`-objekt) och returnerar ett :class:"
"`bytes`-objekt som innehåller komprimerade data för åtminstone en del av "
"indata. En del av *data* kan buffras internt, för användning i senare anrop "
"till :meth:`compress` och :meth:`flush`. De returnerade data bör "
"sammankopplas med utdata från eventuella tidigare anrop till :meth:"
"`compress`."

msgid ""
"Finish the compression process, returning a :class:`bytes` object containing "
"any data stored in the compressor's internal buffers."
msgstr ""
"Avslutar komprimeringsprocessen och returnerar ett :class:`bytes`-objekt som "
"innehåller all data som lagrats i kompressorns interna buffertar."

msgid "The compressor cannot be used after this method has been called."
msgstr "Kompressorn kan inte användas efter att denna metod har anropats."

msgid ""
"Create a decompressor object, which can be used to decompress data "
"incrementally."
msgstr ""
"Skapa ett dekompressorobjekt som kan användas för att dekomprimera data "
"stegvis."

msgid ""
"For a more convenient way of decompressing an entire compressed stream at "
"once, see :func:`decompress`."
msgstr ""
"För ett mer bekvämt sätt att dekomprimera en hel komprimerad ström på en "
"gång, se :func:`decompress`."

msgid ""
"The *format* argument specifies the container format that should be used. "
"The default is :const:`FORMAT_AUTO`, which can decompress both ``.xz`` and "
"``.lzma`` files. Other possible values are :const:`FORMAT_XZ`, :const:"
"`FORMAT_ALONE`, and :const:`FORMAT_RAW`."
msgstr ""
"Argumentet *format* anger vilket containerformat som ska användas. "
"Standardvärdet är :const:`FORMAT_AUTO`, som kan dekomprimera både ``.xz`` "
"och ``.lzma``-filer. Andra möjliga värden är :const:`FORMAT_XZ`, :const:"
"`FORMAT_ALONE` och :const:`FORMAT_RAW`."

msgid ""
"The *memlimit* argument specifies a limit (in bytes) on the amount of memory "
"that the decompressor can use. When this argument is used, decompression "
"will fail with an :class:`LZMAError` if it is not possible to decompress the "
"input within the given memory limit."
msgstr ""
"Argumentet *memlimit* anger en gräns (i byte) för hur mycket minne som "
"dekomprimeraren kan använda. När detta argument används kommer "
"dekomprimeringen att misslyckas med ett :class:`LZMAError` om det inte är "
"möjligt att dekomprimera indata inom den angivna minnesgränsen."

msgid ""
"The *filters* argument specifies the filter chain that was used to create "
"the stream being decompressed. This argument is required if *format* is :"
"const:`FORMAT_RAW`, but should not be used for other formats. See :ref:"
"`filter-chain-specs` for more information about filter chains."
msgstr ""
"Argumentet *filters* anger den filterkedja som användes för att skapa den "
"ström som dekomprimeras. Detta argument krävs om *format* är :const:"
"`FORMAT_RAW`, men ska inte användas för andra format. Se :ref:`filter-chain-"
"specs` för mer information om filterkedjor."

msgid ""
"This class does not transparently handle inputs containing multiple "
"compressed streams, unlike :func:`decompress` and :class:`LZMAFile`. To "
"decompress a multi-stream input with :class:`LZMADecompressor`, you must "
"create a new decompressor for each stream."
msgstr ""
"Den här klassen hanterar inte på ett transparent sätt indata som innehåller "
"flera komprimerade strömmar, till skillnad från :func:`decompress` och :"
"class:`LZMAFile`. För att dekomprimera en inmatning med flera strömmar med :"
"class:`LZMADecompressor` måste du skapa en ny dekompressor för varje ström."

msgid ""
"Decompress *data* (a :term:`bytes-like object`), returning uncompressed data "
"as bytes. Some of *data* may be buffered internally, for use in later calls "
"to :meth:`decompress`. The returned data should be concatenated with the "
"output of any previous calls to :meth:`decompress`."
msgstr ""
"Dekomprimerar *data* (ett :term:`bytesliknande objekt`) och returnerar "
"okomprimerad data som bytes. En del av *data* kan buffras internt, för "
"användning i senare anrop till :meth:`decompress`. Den returnerade datan bör "
"sammanfogas med resultatet från eventuella tidigare anrop till :meth:"
"`decompress`."

msgid ""
"If *max_length* is nonnegative, returns at most *max_length* bytes of "
"decompressed data. If this limit is reached and further output can be "
"produced, the :attr:`~.needs_input` attribute will be set to ``False``. In "
"this case, the next call to :meth:`~.decompress` may provide *data* as "
"``b''`` to obtain more of the output."
msgstr ""
"Om *max_length* är icke-negativ, returneras högst *max_length* byte av "
"dekomprimerade data. Om denna gräns nås och ytterligare utdata kan "
"produceras, kommer attributet :attr:`~.needs_input` att sättas till "
"``False``. I detta fall kan nästa anrop till :meth:`~.decompress` ge *data* "
"som ``b''`` för att få mer av utdata."

msgid ""
"If all of the input data was decompressed and returned (either because this "
"was less than *max_length* bytes, or because *max_length* was negative), "
"the :attr:`~.needs_input` attribute will be set to ``True``."
msgstr ""
"Om alla indata dekomprimerades och returnerades (antingen för att de var "
"mindre än *max_length* bytes eller för att *max_length* var negativ), kommer "
"attributet :attr:`~.needs_input` att sättas till ``True``."

msgid ""
"Attempting to decompress data after the end of stream is reached raises an :"
"exc:`EOFError`.  Any data found after the end of the stream is ignored and "
"saved in the :attr:`~.unused_data` attribute."
msgstr ""
"Försök att dekomprimera data efter att slutet på strömmen har nåtts ger "
"upphov till ett :exc:`EOFError`.  Alla data som hittas efter slutet av "
"strömmen ignoreras och sparas i attributet :attr:`~.unused_data`."

msgid "Added the *max_length* parameter."
msgstr "Parametern *max_length* har lagts till."

msgid ""
"The ID of the integrity check used by the input stream. This may be :const:"
"`CHECK_UNKNOWN` until enough of the input has been decoded to determine what "
"integrity check it uses."
msgstr ""
"ID för den integritetskontroll som används av indataströmmen. Detta kan "
"vara :const:`CHECK_UNKNOWN` tills tillräckligt mycket av inmatningen har "
"avkodats för att avgöra vilken integritetskontroll som används."

msgid "``True`` if the end-of-stream marker has been reached."
msgstr "``True`` om markören för slutet av flödet har nåtts."

msgid "Data found after the end of the compressed stream."
msgstr "Data som hittas efter slutet av den komprimerade strömmen."

msgid "Before the end of the stream is reached, this will be ``b\"\"``."
msgstr "Innan slutet av strömmen nås kommer detta att vara ``b\"\"``."

msgid ""
"``False`` if the :meth:`.decompress` method can provide more decompressed "
"data before requiring new uncompressed input."
msgstr ""
"``False`` om metoden :meth:`.decompress`` kan tillhandahålla mer "
"dekomprimerad data innan den kräver ny okomprimerad inmatning."

msgid ""
"Compress *data* (a :class:`bytes` object), returning the compressed data as "
"a :class:`bytes` object."
msgstr ""
"Komprimera *data* (ett :class:`bytes`-objekt) och returnera den komprimerade "
"datan som ett :class:`bytes`-objekt."

msgid ""
"See :class:`LZMACompressor` above for a description of the *format*, "
"*check*, *preset* and *filters* arguments."
msgstr ""
"Se :class:`LZMACompressor` ovan för en beskrivning av argumenten *format*, "
"*check*, *preset* och *filters*."

msgid ""
"Decompress *data* (a :class:`bytes` object), returning the uncompressed data "
"as a :class:`bytes` object."
msgstr ""
"Dekomprimera *data* (ett :class:`bytes`-objekt) och returnera okomprimerad "
"data som ett :class:`bytes`-objekt."

msgid ""
"If *data* is the concatenation of multiple distinct compressed streams, "
"decompress all of these streams, and return the concatenation of the results."
msgstr ""
"Om *data* är en sammankoppling av flera olika komprimerade flöden, "
"dekomprimera alla dessa flöden och returnera sammankopplingen av resultaten."

msgid ""
"See :class:`LZMADecompressor` above for a description of the *format*, "
"*memlimit* and *filters* arguments."
msgstr ""
"Se :class:`LZMADecompressor` ovan för en beskrivning av argumenten *format*, "
"*memlimit* och *filters*."

msgid "Miscellaneous"
msgstr "Diverse"

msgid ""
"Return ``True`` if the given integrity check is supported on this system."
msgstr ""
"Returnerar ``True`` om den angivna integritetskontrollen stöds på detta "
"system."

msgid ""
":const:`CHECK_NONE` and :const:`CHECK_CRC32` are always supported. :const:"
"`CHECK_CRC64` and :const:`CHECK_SHA256` may be unavailable if you are using "
"a version of :program:`liblzma` that was compiled with a limited feature set."
msgstr ""
":const:`CHECK_NONE` och :const:`CHECK_CRC32` stöds alltid. :const:"
"`CHECK_CRC64` och :const:`CHECK_SHA256` kanske inte är tillgängliga om du "
"använder en version av :program:`liblzma` som kompilerades med en begränsad "
"funktionsuppsättning."

msgid "Specifying custom filter chains"
msgstr "Ange anpassade filterkedjor"

msgid ""
"A filter chain specifier is a sequence of dictionaries, where each "
"dictionary contains the ID and options for a single filter. Each dictionary "
"must contain the key ``\"id\"``, and may contain additional keys to specify "
"filter-dependent options. Valid filter IDs are as follows:"
msgstr ""
"En filterkedjespecifikation är en sekvens av ordböcker, där varje ordbok "
"innehåller ID och alternativ för ett enda filter. Varje ordbok måste "
"innehålla nyckeln ``\"id\"`` och kan innehålla ytterligare nycklar för att "
"ange filterberoende alternativ. Giltiga filter-ID är följande:"

msgid "Compression filters:"
msgstr "Kompressionsfilter:"

msgid ":const:`FILTER_LZMA1` (for use with :const:`FORMAT_ALONE`)"
msgstr ":const:`FILTER_LZMA1` (för användning med :const:`FORMAT_ALONE`)"

msgid ""
":const:`FILTER_LZMA2` (for use with :const:`FORMAT_XZ` and :const:"
"`FORMAT_RAW`)"
msgstr ""
":const:`FILTER_LZMA2` (för användning med :const:`FORMAT_XZ` och :const:"
"`FORMAT_RAW`)"

msgid "Delta filter:"
msgstr "Delta-filter:"

msgid ":const:`FILTER_DELTA`"
msgstr ":const:`FILTER_DELTA`"

msgid "Branch-Call-Jump (BCJ) filters:"
msgstr "BCJ-filter (Branch-Call-Jump):"

msgid ":const:`FILTER_X86`"
msgstr ":const:`FILTER_X86`"

msgid ":const:`FILTER_IA64`"
msgstr ":const:`FILTER_IA64`"

msgid ":const:`FILTER_ARM`"
msgstr ":const:`FILTER_ARM`"

msgid ":const:`FILTER_ARMTHUMB`"
msgstr ":const:`FILTER_ARMTHUMB`"

msgid ":const:`FILTER_POWERPC`"
msgstr ":const:`FILTER_POWERPC`"

msgid ":const:`FILTER_SPARC`"
msgstr ":const:`FILTER_SPARC`"

msgid ""
"A filter chain can consist of up to 4 filters, and cannot be empty. The last "
"filter in the chain must be a compression filter, and any other filters must "
"be delta or BCJ filters."
msgstr ""
"En filterkedja kan bestå av upp till 4 filter och kan inte vara tom. Det "
"sista filtret i kedjan måste vara ett kompressionsfilter och alla andra "
"filter måste vara delta- eller BCJ-filter."

msgid ""
"Compression filters support the following options (specified as additional "
"entries in the dictionary representing the filter):"
msgstr ""
"Komprimeringsfilter har stöd för följande alternativ (anges som ytterligare "
"poster i den ordbok som representerar filtret):"

msgid ""
"``preset``: A compression preset to use as a source of default values for "
"options that are not specified explicitly."
msgstr ""
"``preset``: En förinställning för komprimering som ska användas som källa "
"för standardvärden för alternativ som inte anges explicit."

msgid ""
"``dict_size``: Dictionary size in bytes. This should be between 4 KiB and "
"1.5 GiB (inclusive)."
msgstr ""
"``dict_size``: Ordbokens storlek i byte. Den bör ligga mellan 4 KiB och 1,5 "
"GiB (inklusive)."

msgid "``lc``: Number of literal context bits."
msgstr "``lc``: Antal bitar för bokstavskontext."

msgid ""
"``lp``: Number of literal position bits. The sum ``lc + lp`` must be at most "
"4."
msgstr ""
"``lp``: Antal bitar för bokstavsposition. Summan ``lc + lp`` måste vara "
"högst 4."

msgid "``pb``: Number of position bits; must be at most 4."
msgstr "``pb``: Antal positionsbitar; får vara högst 4."

msgid "``mode``: :const:`MODE_FAST` or :const:`MODE_NORMAL`."
msgstr "``mode``: :const:`MODE_FAST` eller :const:`MODE_NORMAL`."

msgid ""
"``nice_len``: What should be considered a \"nice length\" for a match. This "
"should be 273 or less."
msgstr ""
"``nice_len``: Vad som ska anses vara en \"fin längd\" för en match. Detta "
"bör vara 273 eller mindre."

msgid ""
"``mf``: What match finder to use -- :const:`MF_HC3`, :const:`MF_HC4`, :const:"
"`MF_BT2`, :const:`MF_BT3`, or :const:`MF_BT4`."
msgstr ""
"``mf``: Vilken matchningssökare som ska användas -- :const:`MF_HC3`, :const:"
"`MF_HC4`, :const:`MF_BT2`, :const:`MF_BT3`, eller :const:`MF_BT4`."

msgid ""
"``depth``: Maximum search depth used by match finder. 0 (default) means to "
"select automatically based on other filter options."
msgstr ""
"``depth``: Maximalt sökdjup som används av matchningshittaren. 0 (standard) "
"innebär att du väljer automatiskt baserat på andra filteralternativ."

msgid ""
"The delta filter stores the differences between bytes, producing more "
"repetitive input for the compressor in certain circumstances. It supports "
"one option, ``dist``. This indicates the distance between bytes to be "
"subtracted. The default is 1, i.e. take the differences between adjacent "
"bytes."
msgstr ""
"Deltafiltret lagrar skillnaderna mellan byte, vilket under vissa "
"omständigheter ger mer repetitiv indata till kompressorn. Det har stöd för "
"ett alternativ, ``dist``. Detta anger avståndet mellan byte som ska "
"subtraheras. Standardvärdet är 1, d.v.s. skillnaden mellan intilliggande "
"bytes tas med."

msgid ""
"The BCJ filters are intended to be applied to machine code. They convert "
"relative branches, calls and jumps in the code to use absolute addressing, "
"with the aim of increasing the redundancy that can be exploited by the "
"compressor. These filters support one option, ``start_offset``. This "
"specifies the address that should be mapped to the beginning of the input "
"data. The default is 0."
msgstr ""
"BCJ-filtren är avsedda att tillämpas på maskinkod. De konverterar relativa "
"grenar, anrop och hopp i koden så att absolut adressering används, i syfte "
"att öka den redundans som kan utnyttjas av kompressorn. Dessa filter har "
"stöd för ett alternativ, ``start_offset``. Detta anger vilken adress som ska "
"mappas till början av indata. Standardvärdet är 0."

msgid "Examples"
msgstr "Exempel"

msgid "Reading in a compressed file::"
msgstr "Läsa in en komprimerad fil::"

msgid ""
"import lzma\n"
"with lzma.open(\"file.xz\") as f:\n"
"    file_content = f.read()"
msgstr ""
"import lzma\n"
"with lzma.open(\"file.xz\") as f:\n"
"    file_content = f.read()"

msgid "Creating a compressed file::"
msgstr "Skapa en komprimerad fil::"

msgid ""
"import lzma\n"
"data = b\"Insert Data Here\"\n"
"with lzma.open(\"file.xz\", \"w\") as f:\n"
"    f.write(data)"
msgstr ""
"import lzma\n"
"data = b\"Insert Data Here\"\n"
"with lzma.open(\"file.xz\", \"w\") as f:\n"
"    f.write(data)"

msgid "Compressing data in memory::"
msgstr "Komprimering av data i minnet::"

msgid ""
"import lzma\n"
"data_in = b\"Insert Data Here\"\n"
"data_out = lzma.compress(data_in)"
msgstr ""
"import lzma\n"
"data_in = b\"Insert Data Here\"\n"
"data_out = lzma.compress(data_in)"

msgid "Incremental compression::"
msgstr "Inkrementell komprimering::"

msgid ""
"import lzma\n"
"lzc = lzma.LZMACompressor()\n"
"out1 = lzc.compress(b\"Some data\\n\")\n"
"out2 = lzc.compress(b\"Another piece of data\\n\")\n"
"out3 = lzc.compress(b\"Even more data\\n\")\n"
"out4 = lzc.flush()\n"
"# Concatenate all the partial results:\n"
"result = b\"\".join([out1, out2, out3, out4])"
msgstr ""
"import lzma\n"
"lzc = lzma.LZMACompressor()\n"
"out1 = lzc.compress(b\"Some data\\n\")\n"
"out2 = lzc.compress(b\"Another piece of data\\n\")\n"
"out3 = lzc.compress(b\"Even more data\\n\")\n"
"out4 = lzc.flush()\n"
"# Concatenate all the partial results:\n"
"result = b\"\".join([out1, out2, out3, out4])"

msgid "Writing compressed data to an already-open file::"
msgstr "Skriva komprimerad data till en redan öppen fil::"

msgid ""
"import lzma\n"
"with open(\"file.xz\", \"wb\") as f:\n"
"    f.write(b\"This data will not be compressed\\n\")\n"
"    with lzma.open(f, \"w\") as lzf:\n"
"        lzf.write(b\"This *will* be compressed\\n\")\n"
"    f.write(b\"Not compressed\\n\")"
msgstr ""
"import lzma\n"
"with open(\"file.xz\", \"wb\") as f:\n"
"    f.write(b\"This data will not be compressed\\n\")\n"
"    with lzma.open(f, \"w\") as lzf:\n"
"        lzf.write(b\"This *will* be compressed\\n\")\n"
"    f.write(b\"Not compressed\\n\")"

msgid "Creating a compressed file using a custom filter chain::"
msgstr "Skapa en komprimerad fil med hjälp av en anpassad filterkedja::"

msgid ""
"import lzma\n"
"my_filters = [\n"
"    {\"id\": lzma.FILTER_DELTA, \"dist\": 5},\n"
"    {\"id\": lzma.FILTER_LZMA2, \"preset\": 7 | lzma.PRESET_EXTREME},\n"
"]\n"
"with lzma.open(\"file.xz\", \"w\", filters=my_filters) as f:\n"
"    f.write(b\"blah blah blah\")"
msgstr ""
"import lzma\n"
"my_filters = [\n"
"    {\"id\": lzma.FILTER_DELTA, \"dist\": 5},\n"
"    {\"id\": lzma.FILTER_LZMA2, \"preset\": 7 | lzma.PRESET_EXTREME},\n"
"]\n"
"with lzma.open(\"file.xz\", \"w\", filters=my_filters) as f:\n"
"    f.write(b\"blah blah blah\")"
