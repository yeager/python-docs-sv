# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "What's New in Python 2.2"
msgstr "Vad är nytt i Python 2.2"

msgid "Author"
msgstr "Författare"

msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"Den här artikeln förklarar de nya funktionerna i Python 2.2.2, som släpptes "
"den 14 oktober 2002.  Python 2.2.2 är en buggfixversion av Python 2.2, som "
"ursprungligen släpptes den 21 december 2001."

msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"Python 2.2 kan betraktas som en \"uppstädningsversion\".  Det finns några "
"funktioner som generatorer och iteratorer som är helt nya, men de flesta av "
"ändringarna, även om de är betydande och långtgående, syftar till att rensa "
"upp oegentligheter och mörka hörn i språkdesignen."

msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"Den här artikeln är inte ett försök att ge en fullständig specifikation av "
"de nya funktionerna, utan ger istället en praktisk översikt.  För "
"fullständiga detaljer bör du läsa dokumentationen för Python 2.2, till "
"exempel `Python Library Reference <https://docs.python.org/2.2/lib/lib."
"html>`_ och `Python Reference Manual <https://docs.python.org/2.2/ref/ref."
"html>`_.  Om du vill förstå den fullständiga implementeringen och "
"designrationalen för en ändring, se PEP för en viss ny funktion."

msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "PEP 252 och 253: Ändringar av typ och klass"

msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so "
"it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"De största och mest långtgående förändringarna i Python 2.2 gäller Pythons "
"modell för objekt och klasser.  Ändringarna bör vara bakåtkompatibla, så det "
"är troligt att din kod kommer att fortsätta att köras oförändrad, men "
"ändringarna ger några fantastiska nya funktioner. Innan jag börjar med "
"detta, det längsta och mest komplicerade avsnittet i den här artikeln, ska "
"jag ge en översikt över ändringarna och ge några kommentarer."

msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of "
"the most significant flaws was that it's impossible to subclass Python types "
"implemented in C.  In particular, it's not possible to subclass built-in "
"types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`!UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but "
"there's lots of C code that expects a regular Python list and won't accept "
"a :class:`~collections.UserList` instance."
msgstr ""
"För länge sedan skrev jag en webbsida som listade brister i Pythons design.  "
"En av de mest betydande bristerna var att det är omöjligt att subklassa "
"Python-typer som implementerats i C. I synnerhet är det inte möjligt att "
"subklassa inbyggda typer, så du kan inte bara subklassa, säg, listor för att "
"lägga till en enda användbar metod till dem. Modulen :mod:`!UserList` "
"tillhandahåller en klass som stöder alla metoder för listor och som kan "
"subklassas ytterligare, men det finns massor av C-kod som förväntar sig en "
"vanlig Python-lista och inte accepterar en :class:`~collections.UserList`-"
"instans."

msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr ""
"Python 2.2 åtgärdar detta och lägger samtidigt till några spännande nya "
"funktioner. En kort sammanfattning:"

msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr ""
"Du kan subklassa inbyggda typer som listor och till och med heltal, och dina "
"subklasser ska fungera på alla ställen som kräver den ursprungliga typen."

msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr ""
"Det är nu möjligt att definiera statiska metoder och klassmetoder, utöver de "
"instansmetoder som fanns i tidigare versioner av Python."

msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`~object.__getattr__` can be rewritten to use properties "
"instead, making the resulting code simpler and faster.  As a small side "
"benefit, attributes can now have docstrings, too."
msgstr ""
"Det är också möjligt att automatiskt anropa metoder för att komma åt eller "
"ställa in ett instansattribut genom att använda en ny mekanism som kallas :"
"dfn:`properties`.  Många användningar av :meth:`~object.__getattr__` kan "
"skrivas om för att använda egenskaper istället, vilket gör den resulterande "
"koden enklare och snabbare.  Som en liten sidofördel kan attribut nu också "
"ha docstrings."

msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr ""
"Listan över lagliga attribut för en instans kan begränsas till en viss "
"uppsättning med hjälp av :dfn:`slots`, vilket gör det möjligt att skydda sig "
"mot typfel och kanske göra fler optimeringar möjliga i framtida versioner av "
"Python."

msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the "
"new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being "
"lost."
msgstr ""
"Vissa användare har uttryckt oro över alla dessa förändringar.  Visst, säger "
"de, de nya funktionerna är snygga och lämpar sig för alla möjliga knep som "
"inte var möjliga i tidigare versioner av Python, men de gör också språket "
"mer komplicerat.  Vissa människor har sagt att de alltid har rekommenderat "
"Python för dess enkelhet och känner att dess enkelhet går förlorad."

msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"Personligen tycker jag inte att det finns någon anledning att oroa sig.  "
"Många av de nya funktionerna är ganska esoteriska, och du kan skriva mycket "
"Python-kod utan att någonsin behöva vara medveten om dem.  Att skriva en "
"enkel klass är inte svårare än det någonsin varit, så du behöver inte bry "
"dig om att lära dig eller lära ut dem om de inte faktiskt behövs.  Vissa "
"mycket komplicerade uppgifter som tidigare bara var möjliga från C kommer nu "
"att vara möjliga i ren Python, och enligt min mening är det allt till det "
"bättre."

msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will "
"paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"Jag tänker inte försöka gå igenom varje enskilt hörnfall och liten "
"förändring som krävdes för att få de nya funktionerna att fungera.  Istället "
"kommer det här avsnittet bara att måla de breda penseldragen.  Se avsnitt :"
"ref:`sect-rellinks`, \"Relaterade länkar\", för ytterligare "
"informationskällor om Python 2.2:s nya objektmodell."

msgid "Old and New Classes"
msgstr "Gamla och nya klasser"

msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python.  "
"All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"Först bör du veta att Python 2.2 verkligen har två typer av klasser: "
"klassiska eller gamla klasser och nya klasser.  Klassmodellen i den gamla "
"stilen är exakt densamma som klassmodellen i tidigare versioner av Python.  "
"Alla nya funktioner som beskrivs i det här avsnittet gäller bara för klasser "
"av ny typ. Denna skillnad är inte avsedd att vara för evigt; så småningom "
"kommer klasser i gammal stil att tas bort, möjligen i Python 3.0."

msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A "
"new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"Så hur definierar man en new-style class?  Det gör man genom att subklassa "
"en befintlig new-style class.  De flesta av Pythons inbyggda typer, som "
"heltal, listor, ordböcker och till och med filer, är nu new-style-klasser.  "
"En ny stilklass med namnet :class:`object`, basklassen för alla inbyggda "
"typer, har också lagts till så om ingen inbyggd typ är lämplig kan du bara "
"subklassa :class:`object`::"

msgid ""
"class C(object):\n"
"    def __init__ (self):\n"
"        ...\n"
"    ..."
msgstr ""
"klass C(objekt):\n"
"    def __init__ (self):\n"
"        ...\n"
"    ..."

msgid ""
"This means that :keyword:`class` statements that don't have any base classes "
"are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`!__metaclass__` --- "
"see :pep:`253` for the details --- but it's easier to just subclass :class:"
"`object`.)"
msgstr ""
"Detta innebär att :keyword:`class`-satser som inte har några basklasser "
"alltid är klassiska klasser i Python 2.2. (Egentligen kan du också ändra "
"detta genom att ställa in en variabel på modulnivå som heter :attr:`!"
"__metaclass__` --- se :pep:`253` för detaljerna --- men det är lättare att "
"bara subklassa :class:`object`.)"

msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named :func:"
"`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions any "
"more, but type objects that behave as factories when called. ::"
msgstr ""
"Typobjekten för de inbyggda typerna finns tillgängliga som inbyggda "
"funktioner, namngivna med hjälp av ett smart trick.  Python har alltid haft "
"inbyggda funktioner med namnen :func:`int`, :func:`float` och :func:`str`.  "
"I 2.2 är de inte längre funktioner, utan typobjekt som beter sig som "
"fabriker när de anropas. ::"

msgid ""
">>> int\n"
"<type 'int'>\n"
">>> int('123')\n"
"123"
msgstr ""
">>> int\n"
"<typ 'int'> >>> int('123')\n"
">>> int('123')\n"
"123"

msgid ""
"To make the set of types complete, new type objects such as :func:`dict` "
"and :func:`!file` have been added.  Here's a more interesting example, "
"adding a :meth:`!lock` method to file objects::"
msgstr ""
"För att göra uppsättningen av typer komplett har nya typobjekt som :func:"
"`dict` och :func:`!file` lagts till.  Här är ett mer intressant exempel, där "
"vi lägger till en :meth:`!lock`-metod till filobjekt::"

msgid ""
"class LockableFile(file):\n"
"    def lock (self, operation, length=0, start=0, whence=0):\n"
"        import fcntl\n"
"        return fcntl.lockf(self.fileno(), operation,\n"
"                           length, start, whence)"
msgstr ""
"klass LockableFile(fil):\n"
"    def lock (self, operation, length=0, start=0, whence=0):\n"
"        import fcntl\n"
"        return fcntl.lockf(self.fileno(), operation,\n"
"                           längd, start, whence)"

msgid ""
"The now-obsolete :mod:`!posixfile` module contained a class that emulated "
"all of a file object's methods and also added a :meth:`!lock` method, but "
"this class couldn't be passed to internal functions that expected a built-in "
"file, something which is possible with our new :class:`!LockableFile`."
msgstr ""
"Den numera obsoleta modulen :mod:`!posixfile` innehöll en klass som "
"emulerade alla ett filobjekts metoder och lade även till en :meth:`!lock`-"
"metod, men den här klassen kunde inte skickas till interna funktioner som "
"förväntade sig en inbyggd fil, något som är möjligt med vår nya :class:`!"
"LockableFile`."

msgid "Descriptors"
msgstr "Deskriptorer"

msgid ""
"In previous versions of Python, there was no consistent way to discover what "
"attributes and methods were supported by an object. There were some informal "
"conventions, such as defining :attr:`!__members__` and :attr:`!__methods__` "
"attributes that were lists of names, but often the author of an extension "
"type or a class wouldn't bother to define them.  You could fall back on "
"inspecting the :attr:`~object.__dict__` of an object, but when class "
"inheritance or an arbitrary :meth:`!__getattr__` hook were in use this could "
"still be inaccurate."
msgstr ""
"I tidigare versioner av Python fanns det inget konsekvent sätt att upptäcka "
"vilka attribut och metoder som stöddes av ett objekt. Det fanns några "
"informella konventioner, som att definiera attributen :attr:`!__members__` "
"och :attr:`!__methods__` som var namnlistor, men ofta brydde sig inte "
"författaren till en extensionstyp eller en klass om att definiera dem.  Man "
"kunde falla tillbaka på att inspektera :attr:`~object.__dict__` för ett "
"objekt, men när klassarv eller en godtycklig :meth:`!__getattr__`-krok "
"användes kunde detta fortfarande vara felaktigt."

msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class "
"methods become possible, as well as more exotic constructs."
msgstr ""
"Den stora idén bakom den nya klassmodellen är att ett API för att beskriva "
"attributen hos ett objekt med hjälp av :dfn:`descriptors` har formaliserats. "
"Descriptors specificerar värdet på ett attribut och anger om det är en metod "
"eller ett fält.  Med API:et för deskriptorer blir statiska metoder och "
"klassmetoder möjliga, liksom mer exotiska konstruktioner."

msgid ""
"Attribute descriptors are objects that live inside class objects, and have a "
"few attributes of their own:"
msgstr ""
"Attributbeskrivare är objekt som finns inuti klassobjekt och som har några "
"egna attribut:"

msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` är attributets namn."

msgid ":attr:`~definition.__doc__` is the attribute's docstring."
msgstr ":attr:`~definition.__doc__` är attributets docstring."

msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr ""
"``__get__(object)`` är en metod som hämtar attributvärdet från *object*."

msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr ""
"``__set__(objekt, värde)``` sätter attributet på *objekt* till *värde*."

msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr "``__delete__(object, value)`` raderar attributet *value* i *object*."

msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr ""
"När du till exempel skriver ``obj.x`` är de steg som Python faktiskt utför "
"följande::"

msgid ""
"descriptor = obj.__class__.x\n"
"descriptor.__get__(obj)"
msgstr ""
"descriptor = obj.__class__.x\n"
"descriptor.__get__(obj)"

msgid ""
"For methods, :meth:`descriptor.__get__ <object.__get__>` returns a temporary "
"object that's callable, and wraps up the instance and the method to be "
"called on it. This is also why static methods and class methods are now "
"possible; they have descriptors that wrap up just the method, or the method "
"and the class.  As a brief explanation of these new kinds of methods, static "
"methods aren't passed the instance, and therefore resemble regular "
"functions.  Class methods are passed the class of the object, but not the "
"object itself.  Static and class methods are defined like this::"
msgstr ""
"För metoder returnerar :meth:`descriptor.__get__ <object.__get__>` ett "
"temporärt objekt som kan anropas och som innehåller instansen och den metod "
"som ska anropas på den. Det är också därför som statiska metoder och "
"klassmetoder nu är möjliga; de har deskriptorer som omsluter bara metoden, "
"eller metoden och klassen.  En kort förklaring av dessa nya typer av metoder "
"är att statiska metoder inte får instansen och därför liknar vanliga "
"funktioner.  Klassmetoder får objektets klass, men inte själva objektet.  "
"Statiska metoder och klassmetoder definieras så här::"

msgid ""
"class C(object):\n"
"    def f(arg1, arg2):\n"
"        ...\n"
"    f = staticmethod(f)\n"
"\n"
"    def g(cls, arg1, arg2):\n"
"        ...\n"
"    g = classmethod(g)"
msgstr ""
"klass C(objekt):\n"
"    def f(arg1, arg2):\n"
"        ...\n"
"    f = staticmethod(f)\n"
"\n"
"    def g(cls, arg1, arg2):\n"
"        ...\n"
"    g = klassmetod(g)"

msgid ""
"The :func:`staticmethod` function takes the function :func:`!f`, and returns "
"it wrapped up in a descriptor so it can be stored in the class object.  You "
"might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""
"Funktionen :func:`staticmethod` tar funktionen :func:`!f` och returnerar den "
"inslagen i en deskriptor så att den kan lagras i klassobjektet.  Du kanske "
"förväntar dig att det ska finnas en speciell syntax för att skapa sådana "
"metoder (``def static f``, ``defstatic f()``, eller något liknande) men "
"ingen sådan syntax har definierats ännu; det har lämnats till framtida "
"versioner av Python."

msgid ""
"More new features, such as slots and properties, are also implemented as new "
"kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"Fler nya funktioner, som slots och properties, implementeras också som nya "
"typer av descriptors, och det är inte svårt att skriva en descriptor-klass "
"som gör något nytt.  Det skulle till exempel vara möjligt att skriva en "
"deskriptorklass som gör det möjligt att skriva för- och eftervillkor i "
"Eiffelstil för en metod.  En klass som använder denna funktion skulle kunna "
"definieras så här::"

msgid ""
"from eiffel import eiffelmethod\n"
"\n"
"class C(object):\n"
"    def f(self, arg1, arg2):\n"
"        # The actual function\n"
"        ...\n"
"    def pre_f(self):\n"
"        # Check preconditions\n"
"        ...\n"
"    def post_f(self):\n"
"        # Check postconditions\n"
"        ...\n"
"\n"
"    f = eiffelmethod(f, pre_f, post_f)"
msgstr ""
"från eiffel import eiffelmethod\n"
"\n"
"klass C(objekt):\n"
"    def f(self, arg1, arg2):\n"
"        # Den faktiska funktionen\n"
"        ...\n"
"    def pre_f(self):\n"
"        # Kontrollera förhandsvillkor\n"
"        ...\n"
"    def post_f(self):\n"
"        # Kontrollera eftervillkor\n"
"        ...\n"
"\n"
"    f = eiffelmethod(f, pre_f, post_f)"

msgid ""
"Note that a person using the new :func:`!eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features "
"don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`!eiffelmethod` or "
"the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""
"Observera att en person som använder den nya :func:`!eiffelmethod` inte "
"behöver förstå någonting om deskriptorer.  Det är därför jag tror att de nya "
"funktionerna inte ökar språkets grundläggande komplexitet. Det kommer att "
"finnas några trollkarlar som behöver känna till det för att kunna skriva :"
"func:`!eiffelmethod` eller ZODB eller vad som helst, men de flesta användare "
"kommer bara att skriva kod ovanpå de resulterande biblioteken och ignorera "
"implementationsdetaljerna."

msgid "Multiple Inheritance: The Diamond Rule"
msgstr "Multipel arvbarhet: Diamantregeln"

msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram "
"taken from :pep:`253` by Guido van Rossum)::"
msgstr ""
"Multipel nedärvning har också gjorts mer användbar genom att ändra reglerna "
"för hur namn löses.  Tänk på denna uppsättning klasser (diagrammet är hämtat "
"från :pep:`253` av Guido van Rossum)::"

msgid ""
"      class A:\n"
"        ^ ^  def save(self): ...\n"
"       /   \\\n"
"      /     \\\n"
"     /       \\\n"
"    /         \\\n"
"class B     class C:\n"
"    ^         ^  def save(self): ...\n"
"     \\       /\n"
"      \\     /\n"
"       \\   /\n"
"        \\ /\n"
"      class D"
msgstr ""
"      klass A:\n"
"        ^ ^ def save(self): ...\n"
"       / \\\n"
"      / \\\n"
"     / \\\n"
"    / \\\n"
"klass B klass C:\n"
"    ^ ^ def save(self): ...\n"
"     \n"
"      \\ /\n"
"       \n"
"        \n"
"      klass D"

msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to :"
"meth:`!D.save` will search the classes :class:`!D`, :class:`!B`, and then :"
"class:`!A`, where :meth:`!save` would be found and returned.  :meth:`!C."
"save` would never be found at all.  This is bad, because if :class:`!C`'s :"
"meth:`!save` method is saving some internal state specific to :class:`!C`, "
"not calling it will result in that state never getting saved."
msgstr ""
"Uppslagsregeln för klassiska klasser är enkel men inte särskilt smart; "
"basklasserna söks djupt först, från vänster till höger.  En referens till :"
"meth:`!D.save` kommer att söka i klasserna :class:`!D`, :class:`!B`, och "
"sedan :class:`!A`, där :meth:`!save` skulle hittas och returneras. :meth:`!C."
"save` skulle aldrig hittas alls.  Det här är dåligt, för om :class:`!C`:s :"
"meth:`!save`-metod sparar något internt tillstånd som är specifikt för :"
"class:`!C`, kommer det att resultera i att tillståndet aldrig sparas om den "
"inte anropas."

msgid ""
"New-style classes follow a different algorithm that's a bit more complicated "
"to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"New-style klasser följer en annan algoritm som är lite mer komplicerad att "
"förklara, men som gör rätt sak i den här situationen. (Observera att Python "
"2.3 ändrar denna algoritm till en som ger samma resultat i de flesta fall, "
"men som ger mer användbara resultat för riktigt komplicerade arvsgrafer)"

msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [:class:`!D`, :class:`!B`, :class:`!A`, :class:`!"
"C`, :class:`!A`]."
msgstr ""
"Lista alla basklasser, enligt den klassiska lookup-regeln och inkludera en "
"klass flera gånger om den besöks upprepade gånger.  I exemplet ovan är "
"listan över besökta klasser [:class:`!D`, :class:`!B`, :class:`!A`, :class:`!"
"C`, :class:`!A`]."

msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [:class:`!D`, :class:`!B`, :class:`!C`, :class:`!A`] after "
"dropping duplicates."
msgstr ""
"Sök igenom listan efter dubblerade klasser.  Om några hittas, ta bort alla "
"utom en förekomst och lämna den *sista* i listan.  I exemplet ovan blir "
"listan [:class:`!D`, :class:`!B`, :class:`!C`, :class:`!A`] efter att "
"dubbletter har tagits bort."

msgid ""
"Following this rule, referring to :meth:`!D.save` will return :meth:`!C."
"save`, which is the behaviour we're after.  This lookup rule is the same as "
"the one followed by Common Lisp.  A new built-in function, :func:`super`, "
"provides a way to get at a class's superclasses without having to "
"reimplement Python's algorithm. The most commonly used form will be  "
"``super(class, obj)``, which returns  a bound superclass object (not the "
"actual class object).  This form will be used in methods to call a method in "
"the superclass; for example, :class:`!D`'s :meth:`!save` method would look "
"like this::"
msgstr ""
"Enligt denna regel kommer en hänvisning till :meth:`!D.save` att returnera :"
"meth:`!C.save`, vilket är det beteende vi är ute efter.  Denna uppslagsregel "
"är densamma som den som Common Lisp följer.  En ny inbyggd funktion, :func:"
"`super`, ger ett sätt att komma åt en klass superklasser utan att behöva "
"omimplementera Pythons algoritm. Den vanligaste formen kommer att vara "
"``super(class, obj)``, som returnerar ett bundet superklassobjekt (inte det "
"faktiska klassobjektet).  Denna form kommer att användas i metoder för att "
"anropa en metod i superklassen; till exempel skulle :class:`!D`:s :meth:`!"
"save`-metod se ut så här::"

msgid ""
"class D (B,C):\n"
"    def save (self):\n"
"        # Call superclass .save()\n"
"        super(D, self).save()\n"
"        # Save D's private information here\n"
"        ..."
msgstr ""
"klass D (B,C):\n"
"    def save (self):\n"
"        # Anropa superklassen .save()\n"
"        super(D, self).save()\n"
"        # Spara D:s privata information här\n"
"        ..."

msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often "
"be useful."
msgstr ""
":func:`super` kan också returnera obundna superklassobjekt när den anropas "
"som ``super(class)`` eller ``super(class1, class2)``, men detta kommer "
"förmodligen inte ofta att vara användbart."

msgid "Attribute Access"
msgstr "Attributåtkomst"

msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`~object.__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as ``obj."
"get_parent``.  Python 2.2 adds some new ways of controlling attribute access."
msgstr ""
"Ett stort antal sofistikerade Python-klasser definierar krokar för "
"attributåtkomst med :meth:`~object.__getattr__`; oftast görs detta för "
"enkelhetens skull, för att göra koden mer läsbar genom att automatiskt mappa "
"en attributåtkomst som ``obj.parent`` till ett metodanrop som ``obj."
"get_parent``.  Python 2.2 lägger till några nya sätt att kontrollera "
"attributåtkomst."

msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"För det första stöds ``__getattr__(attr_name)`` fortfarande av new-style "
"klasser, och ingenting har ändrats.  Precis som tidigare kommer den att "
"anropas när ett försök görs att komma åt ``obj.foo`` och inget attribut med "
"namnet ``foo`` hittas i instansens dictionary."

msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`~object.__getattribute__` is *always* called whenever any "
"attribute is accessed, while the old :meth:`~object.__getattr__` is only "
"called if ``foo`` isn't found in the instance's dictionary."
msgstr ""
"New-style klasser har också stöd för en ny metod, "
"``__getattribute__(attr_name)``.  Skillnaden mellan de två metoderna är att :"
"meth:`~object.__getattribute__` *alltid* anropas när något attribut används, "
"medan den gamla :meth:`~object.__getattr__` bara anropas om ``foo`` inte "
"finns i instansens dictionary."

msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`!__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of :"
"attr:`~object.__dict__`. :meth:`~object.__getattr__` methods also end up "
"being called by Python when it checks for other methods such as :meth:"
"`~object.__repr__` or :meth:`!__coerce__`, and so have to be written with "
"this in mind. Finally, calling a function on every attribute access results "
"in a sizable performance loss."
msgstr ""
"Python 2.2:s stöd för :dfn:`properties` kommer dock ofta att vara ett "
"enklare sätt att fånga attributreferenser.  Att skriva en :meth:`!"
"__getattr__`-metod är komplicerat eftersom man för att undvika rekursion "
"inte kan använda vanliga attributåtkomster inuti dem, utan istället måste "
"röra runt med innehållet i :attr:`~object.__dict__`. metoderna :meth:"
"`~object.__getattr__` anropas också av Python när den söker efter andra "
"metoder som :meth:`~object.__repr__` eller :meth:`!__coerce__`, och måste "
"därför skrivas med detta i åtanke. Slutligen leder anrop av en funktion vid "
"varje attributåtkomst till en avsevärd prestandaförlust."

msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you "
"want to define a :attr:`!size` attribute that's computed, but also settable, "
"you could write::"
msgstr ""
":class:`property` är en ny inbyggd typ som innehåller tre funktioner som "
"hämtar, ställer in eller tar bort ett attribut samt en dokumentsträng.  Om "
"du till exempel vill definiera ett :attr:`!size`-attribut som är beräknat, "
"men också inställbart, kan du skriva::"

msgid ""
"class C(object):\n"
"    def get_size (self):\n"
"        result = ... computation ...\n"
"        return result\n"
"    def set_size (self, size):\n"
"        ... compute something based on the size\n"
"        and set internal state appropriately ...\n"
"\n"
"    # Define a property.  The 'delete this attribute'\n"
"    # method is defined as None, so the attribute\n"
"    # can't be deleted.\n"
"    size = property(get_size, set_size,\n"
"                    None,\n"
"                    \"Storage size of this instance\")"
msgstr ""
"klass C(objekt):\n"
"    def get_size (self):\n"
"        result = ... beräkning ...\n"
"        returnerar resultat\n"
"    def set_size (self, storlek):\n"
"        ... beräkna något baserat på storleken\n"
"        och ställa in internt tillstånd på lämpligt sätt ...\n"
"\n"
"    # Definiera en egenskap.  Metoden \"ta bort detta attribut\n"
"    # metoden är definierad som None, så attributet\n"
"    # kan inte tas bort.\n"
"    size = egenskap(get_size, set_size,\n"
"                    None,\n"
"                    \"Lagringsstorlek för denna instans\")"

msgid ""
"That is certainly clearer and easier to write than a pair of :meth:`!"
"__getattr__`/:meth:`!__setattr__` methods that check for the :attr:`!size` "
"attribute and handle it specially while retrieving all other attributes from "
"the instance's :attr:`~object.__dict__`.  Accesses to :attr:`!size` are also "
"the only ones which have to perform the work of calling a function, so "
"references to other attributes run at their usual speed."
msgstr ""
"Det är i alla fall tydligare och enklare att skriva än ett par :meth:`!"
"__getattr__`/:meth:`!__setattr__`-metoder som söker efter attributet :attr:`!"
"size` och hanterar det speciellt medan de hämtar alla andra attribut från "
"instansens :attr:`~object.__dict__`.  Åtkomster till :attr:`!size` är också "
"de enda som måste utföra arbetet med att anropa en funktion, så referenser "
"till andra attribut körs med sin vanliga hastighet."

msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing ``obj."
"new_attr=1``.   A new-style class can define a class attribute named :attr:"
"`~object.__slots__` to limit the legal attributes  to a particular set of "
"names.  An example will make this clear::"
msgstr ""
"Slutligen är det möjligt att begränsa listan över attribut som kan refereras "
"till på ett objekt med hjälp av det nya klassattributet :attr:`~object."
"__slots__`. Python-objekt är vanligtvis mycket dynamiska; när som helst är "
"det möjligt att definiera ett nytt attribut på en instans genom att bara "
"göra ``obj.new_attr=1``.   En klass med ny stil kan definiera ett "
"klassattribut med namnet :attr:`~object.__slots__` för att begränsa de "
"lagliga attributen till en viss uppsättning namn.  Ett exempel kommer att "
"göra detta tydligt::"

msgid ""
">>> class C(object):\n"
"...     __slots__ = ('template', 'name')\n"
"...\n"
">>> obj = C()\n"
">>> print obj.template\n"
"None\n"
">>> obj.template = 'Test'\n"
">>> print obj.template\n"
"Test\n"
">>> obj.newattr = None\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"AttributeError: 'C' object has no attribute 'newattr'"
msgstr ""
"&gt;&gt;&gt; klass C(objekt):\n"
"...     __slots__ = ('mall', 'namn')\n"
"...\n"
"&gt;&gt;&gt; obj = C()\n"
"&gt;&gt;&gt; print obj.template\n"
"Ingen\n"
"&gt;&gt;&gt; obj.template = 'Test'\n"
"&gt;&gt;&gt; Skriv ut obj.mall\n"
"Test\n"
"&gt;&gt;&gt; obj.newattr = Ingen\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i ?\n"
"AttributeError: 'C'-objektet har inget attribut 'newattr'"

msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
"Observera att du får ett :exc:`AttributeError` när du försöker tilldela ett "
"attribut som inte finns med i :attr:`~object.__slots__`."

msgid "Related Links"
msgstr "Relaterade länkar"

msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr ""
"Det här avsnittet har bara varit en snabb översikt över de nya funktionerna "
"och ger en tillräcklig förklaring för att du ska kunna börja programmera, "
"men många detaljer har förenklats eller ignorerats.  Vart ska man gå för att "
"få en mer fullständig bild?"

msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much "
"more detail about the new features while still remaining quite easy to read."
msgstr ""
":ref:`descriptorhowto` är en lång introduktion till descriptor-funktionerna, "
"skriven av Guido van Rossum. Om min beskrivning har väckt din aptit, läs den "
"här handledningen härnäst, eftersom den går in mycket mer i detalj om de nya "
"funktionerna samtidigt som den fortfarande är ganska lättläst."

msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is "
"titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  :"
"pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"Därefter finns det två relevanta PEP:er, :pep:`252` och :pep:`253`. :pep:"
"`252` har titeln \"Making Types Look More Like Classes\" och behandlar "
"descriptor API. :pep:`253` har titeln \"Subtyping Built-in Types\" och "
"beskriver de ändringar av typobjekt som gör det möjligt att subtypa inbyggda "
"objekt.  :pep:`253` är den mest komplicerade PEP:en av de två, och på några "
"ställen kan de nödvändiga förklaringarna av typer och metatyper få ditt "
"huvud att explodera.  Båda PEP:erna skrevs och implementerades av Guido van "
"Rossum, med betydande hjälp från resten av Zope Corp.-teamet."

msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"Slutligen har vi den ultimata auktoriteten: källkoden.  Det mesta av "
"maskineriet för typhanteringen finns i :file:`Objects/typeobject.c`, men du "
"bör bara använda det efter att alla andra vägar har uttömts, inklusive att "
"skicka en fråga till python-list eller python-dev."

msgid "PEP 234: Iterators"
msgstr "PEP 234: Iteratorer"

msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr ""
"Ett annat viktigt tillägg till 2.2 är ett iterationsgränssnitt på både C- "
"och Python-nivå.  Objekt kan definiera hur de kan loopas över av anropare."

msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work "
"is to define a :meth:`~object.__getitem__` method that looks something like "
"this::"
msgstr ""
"I Python-versioner upp till 2.1 är det vanliga sättet att få ``for item in "
"obj`` att fungera att definiera en :meth:`~object.__getitem__`-metod som ser "
"ut ungefär så här::"

msgid ""
"def __getitem__(self, index):\n"
"    return <next item>"
msgstr ""
"def __getitem__(self, index):\n"
"    return <next item>"

msgid ""
":meth:`~object.__getitem__` is more properly used to define an indexing "
"operation on an object so that you can write ``obj[5]`` to retrieve the "
"sixth element.  It's a bit misleading when you're using this only to "
"support :keyword:`for` loops. Consider some file-like object that wants to "
"be looped over; the *index* parameter is essentially meaningless, as the "
"class probably assumes that a series of :meth:`~object.__getitem__` calls "
"will be made with *index* incrementing by one each time.  In other words, "
"the presence of the :meth:`~object.__getitem__` method doesn't mean that "
"using ``file[5]``  to randomly access the sixth element will work, though it "
"really should."
msgstr ""
":meth:`~object.__getitem__` används mer korrekt för att definiera en "
"indexeringsoperation på ett objekt så att du kan skriva ``obj[5]`` för att "
"hämta det sjätte elementet.  Det är lite missvisande när du bara använder "
"detta för att stödja :keyword:`for`-loopar. Tänk på något filliknande objekt "
"som vill loopas över; parametern *index* är i princip meningslös, eftersom "
"klassen förmodligen antar att en serie :meth:`~object.__getitem__`-anrop "
"kommer att göras med *index* som ökar med ett varje gång.  Med andra ord "
"betyder inte förekomsten av metoden :meth:`~object.__getitem__` att det "
"fungerar att använda ``file[5]`` för att slumpmässigt komma åt det sjätte "
"elementet, även om det verkligen borde göra det."

msgid ""
"In Python 2.2, iteration can be implemented separately, and :meth:`~object."
"__getitem__` methods can be limited to classes that really do support random "
"access.  The basic idea of iterators is  simple.  A new built-in function, "
"``iter(obj)`` or ``iter(C, sentinel)``, is used to get an iterator. "
"``iter(obj)`` returns an iterator for the object *obj*, while ``iter(C, "
"sentinel)`` returns an iterator that will invoke the callable object *C* "
"until it returns *sentinel* to signal that the iterator is done."
msgstr ""
"I Python 2.2 kan iteration implementeras separat och :meth:`~object."
"__getitem__`-metoder kan begränsas till klasser som verkligen stöder "
"slumpmässig åtkomst.  Grundidén med iteratorer är enkel.  En ny inbyggd "
"funktion, ``iter(obj)`` eller ``iter(C, sentinel)``, används för att hämta "
"en iterator. ``iter(obj)`` returnerar en iterator för objektet *obj*, medan "
"``iter(C, sentinel)`` returnerar en iterator som kommer att anropa det "
"anropbara objektet *C* tills det returnerar *sentinel* för att signalera att "
"iteratorn är klar."

msgid ""
"Python classes can define an :meth:`!__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator, "
"this method can just return ``self``.  In particular, iterators will usually "
"be their own iterators.  Extension types implemented in C can implement a :c:"
"member:`~PyTypeObject.tp_iter` function in order to return an iterator, and "
"extension types that want to behave as iterators can define a :c:member:"
"`~PyTypeObject.tp_iternext` function."
msgstr ""
"Python-klasser kan definiera en :meth:`!__iter__`-metod, som ska skapa och "
"returnera en ny iterator för objektet; om objektet är sin egen iterator kan "
"denna metod bara returnera ``self``.  I synnerhet iteratorer kommer "
"vanligtvis att vara sina egna iteratorer.  Tilläggstyper implementerade i C "
"kan implementera en :c:member:`~PyTypeObject.tp_iter`-funktion för att "
"returnera en iterator, och tilläggstyper som vill bete sig som iteratorer "
"kan definiera en :c:member:`~PyTypeObject.tp_iternext`-funktion."

msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"Så, efter allt detta, vad gör iteratorer egentligen?  De har en obligatorisk "
"metod, :meth:`next`, som inte tar några argument och returnerar nästa "
"värde.  När det inte finns fler värden att returnera bör anrop av :meth:"
"`next` ge upphov till undantaget :exc:`StopIteration`. ::"

msgid ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> print i\n"
"<iterator object at 0x8116870>\n"
">>> i.next()\n"
"1\n"
">>> i.next()\n"
"2\n"
">>> i.next()\n"
"3\n"
">>> i.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"StopIteration\n"
">>>"
msgstr ""
"&gt;&gt;&gt; L = [1,2,3]\n"
"&gt;&gt;&gt; i = iter(L)\n"
"&gt;&gt;&gt; skriv ut i\n"
"<iterator object at 0x8116870>\n"
"&gt;&gt;&gt; i.nästa()\n"
"1\n"
"&gt;&gt;&gt; i.nästa()\n"
"2\n"
"&gt;&gt;&gt; i.nästa()\n"
"3\n"
"&gt;&gt;&gt; i.nästa()\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i ?\n"
"Stoppa iteration\n"
"&gt;&gt;&gt"

msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`!__iter__` or a :c:"
"member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""
"I 2.2 förväntar sig Pythons :keyword:`for`-sats inte längre en sekvens; den "
"förväntar sig något som :func:`iter` returnerar en iterator för. För "
"bakåtkompatibilitet och bekvämlighet konstrueras en iterator automatiskt för "
"sekvenser som inte implementerar :meth:`!__iter__` eller en :c:member:"
"`~PyTypeObject.tp_iter` slot, så ``for i in [1,2,3]`` kommer fortfarande att "
"fungera.  Varhelst Python-tolken loopar över en sekvens har den ändrats för "
"att använda iteratorprotokollet.  Detta innebär att du kan göra saker som "
"detta::"

msgid ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> a,b,c = i\n"
">>> a,b,c\n"
"(1, 2, 3)"
msgstr ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> a,b,c = i\n"
">>> a,b,c\n"
"(1, 2, 3)"

msgid ""
"Iterator support has been added to some of Python's basic types.   Calling :"
"func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr ""
"Iteratorstöd har lagts till i några av Pythons grundläggande typer.   Om man "
"anropar :func:`iter` på en ordbok returneras en iterator som loopar över "
"dess nycklar::"

msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m: print key, m[key]\n"
"...\n"
"Mar 3\n"
"Feb 2\n"
"Aug 8\n"
"Sep 9\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Jan 1\n"
"Apr 4\n"
"Nov 11\n"
"Dec 12\n"
"Oct 10"
msgstr ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      \"Jul\": 7, \"Aug\": 8, \"Sep\": 9, 'okt': 10, 'nov': 11, 'Dec': "
"12}\n"
">>> for key in m: print key, m[key]\n"
"...\n"
"3 mars\n"
"2 februari\n"
"8 augusti\n"
"9 september\n"
"5 maj\n"
"6 juni\n"
"7 juli\n"
"1 jan\n"
"4 april\n"
"11 november\n"
"12 dec\n"
"10 oktober"

msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`!iterkeys`, :"
"meth:`!itervalues`, or :meth:`!iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on "
"dictionaries, so ``key in dict`` is now equivalent to ``dict.has_key(key)``."
msgstr ""
"Det är bara standardbeteendet.  Om du vill iterera över nycklar, värden "
"eller nyckel/värde-par kan du uttryckligen anropa metoderna :meth:`!"
"iterkeys`, :meth:`!itervalues` eller :meth:`!iteritems` för att få en "
"lämplig iterator. I en mindre relaterad ändring fungerar operatorn :keyword:"
"`in` nu på lexikon, så ``key in dict`` är nu ekvivalent med ``dict."
"has_key(key)``."

msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each "
"line of a file using code like this::"
msgstr ""
"Filer innehåller också en iterator som anropar metoden :meth:`readline` "
"tills det inte finns några fler rader i filen.  Detta innebär att du nu kan "
"läsa varje rad i en fil med kod som denna::"

msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""
"för rad i filen:\n"
"    # gör något för varje rad\n"
"    ..."

msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol "
"only requires a :meth:`next` method."
msgstr ""
"Observera att du bara kan gå framåt i en iterator; det finns inget sätt att "
"hämta föregående element, återställa iteratorn eller göra en kopia av den. "
"Ett iteratorobjekt kan ge sådana ytterligare möjligheter, men "
"iteratorprotokollet kräver bara en :meth:`next`-metod."

msgid ":pep:`234` - Iterators"
msgstr ":pep:`234` - Iteratorer"

msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly "
"by GvR and Tim Peters."
msgstr ""
"Skriven av Ka-Ping Yee och GvR; implementerad av Python Labs, främst av GvR "
"och Tim Peters."

msgid "PEP 255: Simple Generators"
msgstr "PEP 255: Enkla generatorer"

msgid ""
"Generators are another new feature, one that interacts with the introduction "
"of iterators."
msgstr ""
"Generatorer är en annan ny funktion, som samverkar med införandet av "
"iteratorer."

msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"Du är säkert bekant med hur funktionsanrop fungerar i Python eller C. När du "
"anropar en funktion får den ett privat namnområde där dess lokala variabler "
"skapas.  När funktionen når en :keyword:`return`-sats förstörs de lokala "
"variablerna och det resulterande värdet returneras till anroparen.  Ett "
"senare anrop till samma funktion kommer att få en ny uppsättning lokala "
"variabler. Men tänk om de lokala variablerna inte kastades bort när en "
"funktion avslutades? Tänk om du senare kunde återuppta funktionen där den "
"slutade?  Detta är vad generatorer tillhandahåller; de kan betraktas som "
"återupptagbara funktioner."

msgid "Here's the simplest example of a generator function::"
msgstr "Här är det enklaste exemplet på en generatorfunktion::"

msgid ""
"def generate_ints(N):\n"
"    for i in range(N):\n"
"        yield i"
msgstr ""
"def generera_ints(N):\n"
"    för i i intervall(N):\n"
"        avkastning i"

msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"Ett nytt nyckelord, :keyword:`yield`, introducerades för generatorer.  Varje "
"funktion som innehåller en :keyword:`!yield`-sats är en generatorfunktion; "
"detta upptäcks av Pythons bytekodskompilator som kompilerar funktionen "
"speciellt som ett resultat.  Eftersom ett nytt nyckelord introducerades "
"måste generatorer uttryckligen aktiveras i en modul genom att inkludera ett "
"``from __future__ import generators``-sats nära toppen av modulens källkod.  "
"I Python 2.3 kommer detta uttalande att bli onödigt."

msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`!try` block of a :keyword:"
"`try`...\\ :keyword:`finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"När du anropar en generatorfunktion returnerar den inte ett enda värde, utan "
"istället ett generatorobjekt som stöder iteratorprotokollet.  Vid exekvering "
"av :keyword:`yield`-satsen matar generatorn ut värdet på ``i``, på samma "
"sätt som en :keyword:`return`-sats.  Den stora skillnaden mellan :keyword:`!"
"yield` och en :keyword:`!return`-sats är att när man når en :keyword:`!"
"yield` avbryts generatorns exekveringstillstånd och lokala variabler "
"bevaras.  Vid nästa anrop till generatorns ``next()``-metod kommer "
"funktionen att återuppta exekveringen omedelbart efter :keyword:`!yield`-"
"satsen.  (Av komplicerade skäl är :keyword:`!yield`-satsen inte tillåten "
"inuti :keyword:`!try`-blocket i en :keyword:`try`...\\ :keyword:`finally`-"
"sats; läs :pep:`255` för en fullständig förklaring av interaktionen mellan :"
"keyword:`!yield` och undantag)"

msgid "Here's a sample usage of the :func:`!generate_ints` generator::"
msgstr ""
"Här är ett exempel på användning av generatorn :func:`!generate_ints`::"

msgid ""
">>> gen = generate_ints(3)\n"
">>> gen\n"
"<generator object at 0x8117f90>\n"
">>> gen.next()\n"
"0\n"
">>> gen.next()\n"
"1\n"
">>> gen.next()\n"
"2\n"
">>> gen.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"<stdin>\", line 2, in generate_ints\n"
"StopIteration"
msgstr ""
"&gt;&gt;&gt; gen = generera_ints(3)\n"
"&gt;&gt;&gt; gen\n"
"<generator object at 0x8117f90>\n"
"&gt;&gt;&gt; gen.nästa()\n"
"0\n"
"&gt;&gt;&gt; gen.nästa()\n"
"1\n"
"&gt;&gt;&gt; gen.nästa()\n"
"2\n"
"&gt;&gt;&gt; gen.nästa()\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i ?\n"
"  Fil \"<stdin>\", rad 2, i generate_ints\n"
"Stoppa iteration"

msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"Du kan lika gärna skriva ``for i in generate_ints(5)``, eller ``a,b,c = "
"generate_ints(3)``."

msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"I en generatorfunktion kan :keyword:`return` bara användas utan ett värde "
"och signalerar slutet på värdeförloppet; därefter kan generatorn inte "
"returnera några ytterligare värden. :keyword:`!return` med ett värde, t.ex. "
"``return 5``, är ett syntaxfel i en generatorfunktion.  Slutet på "
"generatorns resultat kan också indikeras genom att höja :exc:`StopIteration` "
"manuellt, eller genom att bara låta flödet av exekveringen falla från botten "
"av funktionen."

msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"Du kan uppnå effekten av generatorer manuellt genom att skriva din egen "
"klass och lagra alla lokala variabler i generatorn som instansvariabler.  "
"Att returnera en lista med heltal kan till exempel göras genom att sätta "
"``self.count`` till 0 och låta :meth:`next`-metoden öka ``self.count`` och "
"returnera den. Men för en måttligt komplicerad generator skulle det vara "
"mycket krångligare att skriva en motsvarande klass. :file:`Lib/test/"
"test_generators.py` innehåller ett antal mer intressanta exempel.  Det "
"enklaste implementerar en genomgång av ett träd i ordningsföljd med hjälp av "
"generatorer rekursivt. ::"

msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"        yield t.label\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""
"# En rekursiv generator som genererar trädblad i ordning.\n"
"def inorder(t):\n"
"    if t:\n"
"        för x i inorder(t.left):\n"
"            avkastning x\n"
"        yield t.etikett\n"
"        för x i inorder(t.right):\n"
"            ge x"

msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"Två andra exempel i :file:`Lib/test/test_generators.py` producerar lösningar "
"för N-Queens-problemet (placera $N$ drottningar på ett $NxN$ schackbräde så "
"att ingen drottning hotar en annan) och Knight's Tour (en rutt som tar en "
"springare till varje ruta på ett $NxN$ schackbräde utan att besöka någon "
"ruta två gånger)."

msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www2.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www2.cs.arizona.edu/icon/docs/ipd266.htm gives an idea "
"of what this looks like::"
msgstr ""
"Idén med generatorer kommer från andra programmeringsspråk, särskilt Icon "
"(https://www2.cs.arizona.edu/icon/), där idén med generatorer är central.  I "
"Icon beter sig varje uttryck och funktionsanrop som en generator.  Ett "
"exempel från \"An Overview of the Icon Programming Language\" på https://"
"www2.cs.arizona.edu/icon/docs/ipd266.htm ger en uppfattning om hur detta ser "
"ut::"

msgid ""
"sentence := \"Store it in the neighboring harbor\"\n"
"if (i := find(\"or\", sentence)) > 5 then write(i)"
msgstr ""
"mening := \"Förvara den i den närliggande hamnen\"\n"
"if (i := find(\"eller\", mening)) > 5 då skriv(i)"

msgid ""
"In Icon the :func:`!find` function returns the indexes at which the "
"substring \"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` "
"is first assigned a value of 3, but 3 is less than 5, so the comparison "
"fails, and Icon retries it with the second value of 23.  23 is greater than "
"5, so the comparison now succeeds, and the code prints the value 23 to the "
"screen."
msgstr ""
"I Icon returnerar funktionen :func:`!find` de index där delsträngen \"or\" "
"hittas: 3, 23, 33.  I :keyword:`if`-satsen tilldelas ``i`` först värdet 3, "
"men 3 är mindre än 5, så jämförelsen misslyckas, och Icon gör ett nytt "
"försök med det andra värdet 23. 23 är större än 5, så jämförelsen lyckas nu, "
"och koden skriver ut värdet 23 på skärmen."

msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to "
"other functions or stored in a data structure."
msgstr ""
"Python går inte alls lika långt som Icon när det gäller att anta generatorer "
"som ett centralt koncept.  Generatorer betraktas som en ny del av Pythons "
"kärnspråk, men det är inte obligatoriskt att lära sig eller använda dem; om "
"de inte löser några problem som du har, kan du gärna ignorera dem. En nyhet "
"i Pythons gränssnitt jämfört med Icons är att en generators tillstånd "
"representeras som ett konkret objekt (iteratorn) som kan skickas runt till "
"andra funktioner eller lagras i en datastruktur."

msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Enkla generatorer"

msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"Skriven av Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implementerad "
"mestadels av Neil Schemenauer och Tim Peters, med andra korrigeringar från "
"Python Labs-gänget."

msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: Förenande av långa heltal och heltal"

msgid ""
"In recent versions, the distinction between regular integers, which are 32-"
"bit values on most machines, and long integers, which can be of arbitrary "
"size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`!tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""
"I de senaste versionerna har skillnaden mellan vanliga heltal, som är 32-"
"bitarsvärden på de flesta maskiner, och långa heltal, som kan vara av "
"godtycklig storlek, blivit ett irritationsmoment.  På plattformar som stöder "
"filer som är större än ``2**32`` bytes måste till exempel :meth:`!tell`-"
"metoden för filobjekt returnera ett långt heltal. Det fanns dock olika delar "
"av Python som förväntade sig vanliga heltal och skulle ge upphov till ett "
"fel om ett långt heltal tillhandahölls istället.  Till exempel i Python 1.5 "
"kunde endast vanliga heltal användas som ett skivindex, och ``'abc'[1L:]`` "
"skulle ge upphov till ett :exc:`TypeError`-undantag med meddelandet "
"\"skivindex måste vara int\"."

msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"Python 2.2 kommer att skifta värden från korta till långa heltal vid behov. "
"Suffixet \"L\" behövs inte längre för att ange en lång heltalslitteral, "
"eftersom kompilatorn nu väljer lämplig typ.  (Att använda suffixet 'L' "
"kommer att avrådas i framtida 2.x versioner av Python, utlösa en varning i "
"Python 2.4 och troligen tas bort i Python 3.0.)  Många operationer som "
"tidigare gav upphov till ett :exc:`OverflowError` kommer nu att returnera "
"ett långt heltal som resultat.  Till exempel::"

msgid ""
">>> 1234567890123\n"
"1234567890123L\n"
">>> 2 ** 64\n"
"18446744073709551616L"
msgstr ""
">>> 1234567890123\n"
"1234567890123L\n"
">>> 2 ** 64\n"
"18446744073709551616L"

msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr ""
"I de flesta fall kommer heltal och långa heltal nu att behandlas identiskt.  "
"Du kan fortfarande skilja dem åt med den inbyggda funktionen :func:`type`, "
"men det behövs sällan."

msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - Unifiera långa heltal och heltal"

msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr ""
"Skriven av Moshe Zadka och Guido van Rossum.  Implementerad mestadels av "
"Guido van Rossum."

msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238: Byte av divisionsoperator"

msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"Den mest kontroversiella förändringen i Python 2.2 är början på ett försök "
"att åtgärda ett gammalt designfel som har funnits i Python från början. För "
"närvarande beter sig Pythons divisionsoperator, ``/``, som C: s "
"divisionsoperator när den presenteras med två heltalsargument: den "
"returnerar ett heltalsresultat som trunkeras ner när det skulle finnas en "
"bråkdel.  Till exempel är ``3/2`` 1, inte 1,5, och ``(-1)/2`` är -1, inte "
"-0,5.  Detta innebär att resultatet av division kan variera oväntat beroende "
"på typen av de två operanderna och eftersom Python är dynamiskt typat kan "
"det vara svårt att avgöra de möjliga typerna av operanderna."

msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether "
"it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"(Kontroversen handlar om huruvida detta *verkligen* är ett designfel och om "
"det är värt att bryta befintlig kod för att åtgärda det.  Det har orsakat "
"oändliga diskussioner på python-dev, och i juli 2001 utbröt en storm av "
"syrligt sarkastiska inlägg på :newsgroup:`comp.lang.python`. Jag kommer inte "
"att argumentera för någon av sidorna här utan hålla mig till att beskriva "
"vad som implementerats i 2.2.  Läs :pep:`238` för en sammanfattning av "
"argument och motargument)"

msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr ""
"Eftersom den här förändringen kan bryta kod införs den mycket gradvis. "
"Python 2.2 påbörjar övergången, men bytet kommer inte att vara fullständigt "
"förrän Python 3.0."

msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is "
"0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"Först ska jag låna lite terminologi från :pep:`238`.  \"Sann division\" är "
"den division som de flesta icke-programmerare är bekanta med: 3/2 är 1,5, "
"1/4 är 0,25, och så vidare.  \"Golvdivision\" är vad Pythons ``/``-operator "
"för närvarande gör när den ges heltalsoperander; resultatet är golvet i det "
"värde som returneras av sann division.  \"Klassisk division\" är det "
"nuvarande blandade beteendet hos ``/``; den returnerar resultatet av "
"golvdivision när operanderna är heltal, och returnerar resultatet av sann "
"division när en av operanderna är ett flyttal."

msgid "Here are the changes 2.2 introduces:"
msgstr "Här är de förändringar som 2.2 introducerar:"

msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and "
"``1.0 // 2.0`` is also 0.0."
msgstr ""
"En ny operator, ``//``, är operatorn för våningsdivision. (Ja, vi vet att "
"den ser ut som C++:s kommentarssymbol.) ``//`` utför *alltid* golvdivision "
"oavsett vilken typ operanden har, så ``1 // 2`` är 0 och ``1.0 // 2.0`` är "
"också 0.0."

msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr ""
"``//`` är alltid tillgängligt i Python 2.2; du behöver inte aktivera det med "
"hjälp av ett ``__future__``-sats."

msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"Genom att inkludera en ``from __future__ import division`` i en modul kommer "
"operatorn ``/`` att ändras så att den returnerar resultatet av sann "
"division, så ``1/2`` är 0,5.  Utan ``__future__``-satsen betyder ``/`` "
"fortfarande klassisk division. Standardbetydelsen av ``/`` kommer inte att "
"ändras förrän i Python 3.0."

msgid ""
"Classes can define methods called :meth:`~object.__truediv__` and :meth:"
"`~object.__floordiv__` to overload the two division operators.  At the C "
"level, there are also slots in the :c:type:`PyNumberMethods` structure so "
"extension types can define the two operators."
msgstr ""
"Klasser kan definiera metoder som kallas :meth:`~object.__truediv__` och :"
"meth:`~object.__floordiv__` för att överbelasta de två "
"divisionsoperatorerna.  På C-nivå finns det också platser i strukturen :c:"
"type:`PyNumberMethods` så att tilläggstyper kan definiera de två "
"operatorerna."

msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with :option:"
"`!-Q warn` will cause a warning to be issued whenever division is applied to "
"two integers.  You can use this to find code that's affected by the change "
"and fix it.  By default, Python 2.2 will simply perform classic division "
"without a warning; the warning will be turned on by default in Python 2.3."
msgstr ""
"Python 2.2 stöder några kommandoradsargument för att testa om koden kommer "
"att fungera med den ändrade divisionssemantiken.  Om du kör python med :"
"option:`!-Q warn` kommer en varning att utfärdas när division tillämpas på "
"två heltal.  Du kan använda detta för att hitta kod som påverkas av "
"ändringen och fixa den.  Som standard kommer Python 2.2 helt enkelt att "
"utföra klassisk division utan varning; varningen kommer att aktiveras som "
"standard i Python 2.3."

msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238` - Byte av divisionsoperator"

msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr ""
"Skriven av Moshe Zadka och Guido van Rossum.  Implementerad av Guido van "
"Rossum..."

msgid "Unicode Changes"
msgstr "Unicode-ändringar"

msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"Pythons Unicode-stöd har förbättrats en del i 2.2.  Unicode-strängar lagras "
"vanligtvis som UCS-2, som 16-bitars osignerade heltal. Python 2.2 kan också "
"kompileras för att använda UCS-4, 32-bitars osignerade heltal, som sin "
"interna kodning genom att ange :option:`!--enable-unicode=ucs4` till "
"configure-skriptet.   (Det är också möjligt att ange :option:`!--disable-"
"unicode` för att helt inaktivera Unicode-stöd)"

msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`!unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than "
"65535 will still cause :func:`!unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode "
"characters\"; consult it for further details."
msgstr ""
"När tolken är byggd för att använda UCS-4 (ett \"brett Python\") kan den "
"naturligt hantera Unicode-tecken från U+000000 till U+110000, så intervallet "
"av lagliga värden för funktionen :func:`!unichr` utökas i enlighet med "
"detta.  Om du använder en tolk som är kompilerad för att använda UCS-2 (ett "
"\"smalt Python\"), kommer värden större än 65535 fortfarande att orsaka att :"
"func:`!unichr` ger upphov till ett :exc:`ValueError` undantag. Allt detta "
"beskrivs i :pep:`261`, \"Support for 'wide' Unicode characters\"; se den för "
"ytterligare detaljer."

msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`!encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`!decode` assumes that the string is in "
"the specified encoding and decodes it, returning whatever is returned by the "
"codec."
msgstr ""
"En annan förändring är enklare att förklara. Unicode-strängar har sedan de "
"introducerades haft stöd för en :meth:`!encode`-metod för att konvertera "
"strängen till en vald kodning som UTF-8 eller Latin-1.  En symmetrisk metod "
"``decode([*encoding*])`` har lagts till för 8-bitars strängar (dock inte för "
"Unicode-strängar) i 2.2. :meth:`!decode` antar att strängen är i den angivna "
"kodningen och avkodar den och returnerar vad som returneras av codec."

msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"Med hjälp av denna nya funktion har codecs lagts till för uppgifter som inte "
"är direkt relaterade till Unicode.  Exempelvis har codecs lagts till för uu-"
"kodning, MIME:s base64-kodning och komprimering med modulen :mod:`zlib`::"

msgid ""
">>> s = \"\"\"Here is a lengthy piece of redundant, overly verbose,\n"
"... and repetitive text.\n"
"... \"\"\"\n"
">>> data = s.encode('zlib')\n"
">>> data\n"
"'x\\x9c\\r\\xc9\\xc1\\r\\x80 \\x10\\x04\\xc0?Ul...'\n"
">>> data.decode('zlib')\n"
"'Here is a lengthy piece of redundant, overly verbose,\\nand repetitive text."
"\\n'\n"
">>> print s.encode('uu')\n"
"begin 666 <data>\n"
"M2&5R92!I<R!A(&QE;F=T:'D@<&EE8V4@;V8@<F5D=6YD86YT+\"!O=F5R;'D@\n"
">=F5R8F]S92P*86YD(')E<&5T:71I=F4@=&5X=\"X*\n"
"\n"
"end\n"
">>> \"sheesh\".encode('rot-13')\n"
"'furrfu'"
msgstr ""
"&gt;&gt;&gt; s = \"\"\"Här är en lång bit av överflödig, alltför mångordig,\n"
"... och repetitiv text.\n"
"... \"\"\"\n"
"&gt;&gt;&gt; data = s.encode('zlib')\n"
"&gt;&gt;&gt; data\n"
"'x\\x9c\\r\\xc9\\xc1\\r\\x80 \\x10\\x04\\xc0?Ul...'\n"
"&gt;&gt;&gt; data.decode('zlib')\n"
"\"Här är en lång bit överflödig, alltför mångordig och repetitiv text\n"
"&gt;&gt;&gt; print s.encode('uu')\n"
"börja 666 <data>\n"
"M2&amp;5R92!I<R!A(&QE;F=T:'D@<&EE8V4@;V8@<F5D=6YD86YT+\"!O=F5R;'D@\n"
">=F5R8F]S92P*86YD(')E&lt;&amp;5T:71I=F4@=&amp;5X=\"X*\n"
"\n"
"slut\n"
"&gt;&gt;&gt; \"sheesh\".encode('rot-13')\n"
"'furrfu'"

msgid ""
"To convert a class instance to Unicode, a :meth:`!__unicode__` method can be "
"defined by a class, analogous to :meth:`!__str__`."
msgstr ""
"För att konvertera en klassinstans till Unicode kan en :meth:`!__unicode__`-"
"metod definieras av en klass, analogt med :meth:`!__str__`."

msgid ""
":meth:`!encode`, :meth:`!decode`, and :meth:`!__unicode__` were implemented "
"by Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""
":meth:`!encode`, :meth:`!decode`, och :meth:`!__unicode__` implementerades "
"av Marc-André Lemburg.  Ändringarna för att stödja intern användning av "
"UCS-4 implementerades av Fredrik Lundh och Martin von Löwis."

msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - Stöd för \"breda\" Unicode-tecken"

msgid "Written by Paul Prescod."
msgstr "Skriven av Paul Prescod."

msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: Nästlade scopes"

msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always "
"present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"I Python 2.1 lades statiskt nästlade scopes till som en valfri funktion, som "
"kunde aktiveras med ett ``from __future__ import nested_scopes``-direktiv.  "
"I 2.2 behöver nästlade scopes inte längre aktiveras särskilt, utan finns nu "
"alltid.  Resten av det här avsnittet är en kopia av beskrivningen av nested "
"scopes från mitt dokument \"What's New in Python 2.1\"; om du läste det när "
"2.1 kom ut kan du hoppa över resten av det här avsnittet."

msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to "
"Python's scoping rules.  In Python 2.0, at any given time there are at most "
"three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match "
"their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"Den största förändringen som introducerades i Python 2.1, och som slutfördes "
"i 2.2, är Pythons scoping-regler.  I Python 2.0 finns det vid varje given "
"tidpunkt högst tre namnrymder som används för att leta upp variabelnamn: "
"lokalt, modulnivå och det inbyggda namnrymden.  Detta förvånade ofta "
"människor eftersom det inte stämde överens med deras intuitiva "
"förväntningar.  Till exempel fungerar inte en nästlad rekursiv "
"funktionsdefinition::"

msgid ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."
msgstr ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."

msgid ""
"The function :func:`!g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or "
"in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was "
"a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"Funktionen :func:`!g` kommer alltid att ge upphov till ett :exc:`NameError`-"
"undantag, eftersom bindningen av namnet ``g`` inte finns i vare sig dess "
"lokala namnrymd eller i namnrymden på modulnivå.  Detta är inte mycket av "
"ett problem i praktiken (hur ofta definierar man rekursivt inre funktioner "
"på det här sättet?), men det gjorde det också klumpigare att använda :"
"keyword:`lambda`-uttrycket, och det var ett problem i praktiken. I kod som "
"använder :keyword:`!lambda` kan man ofta hitta lokala variabler som kopieras "
"genom att de skickas som standardvärden för argument. ::"

msgid ""
"def find(self, name):\n"
"    \"Return list of any entries equal to 'name'\"\n"
"    L = filter(lambda x, name=name: x == name,\n"
"               self.list_attribute)\n"
"    return L"
msgstr ""
"def hitta(själv, namn):\n"
"    \"Returnera listan med alla poster som är lika med 'namn'\"\n"
"    L = filter(lambda x, namn=namn: x == namn,\n"
"               self.list_attribut)\n"
"    returnera L"

msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr ""
"Läsbarheten hos Python-kod skriven i en starkt funktionell stil blir därför "
"mycket lidande."

msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put "
"simply, when a given variable name is not assigned a value within a function "
"(by an assignment, or the :keyword:`def`, :keyword:`class`, or :keyword:"
"`import` statements), references to the variable will be looked up in the "
"local namespace of the enclosing scope.  A more detailed explanation of the "
"rules, and a dissection of the implementation, can be found in the PEP."
msgstr ""
"Den mest betydande förändringen i Python 2.2 är att statisk scoping har "
"lagts till i språket för att lösa detta problem.  Som en första effekt är "
"standardargumentet ``namn=namn`` nu onödigt i exemplet ovan.  Enkelt "
"uttryckt, när ett givet variabelnamn inte tilldelas ett värde inom en "
"funktion (genom en tilldelning, eller genom :keyword:`def`, :keyword:"
"`class`, eller :keyword:`import`), kommer referenser till variabeln att "
"sökas i det lokala namnområdet i det omslutande scopet.  En mer detaljerad "
"förklaring av reglerna, och en dissektion av implementationen, finns i PEP."

msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"Denna ändring kan orsaka vissa kompatibilitetsproblem för kod där samma "
"variabelnamn används både på modulnivå och som en lokal variabel inom en "
"funktion som innehåller ytterligare funktionsdefinitioner. Detta verkar dock "
"ganska osannolikt, eftersom sådan kod skulle ha varit ganska förvirrande att "
"läsa från början."

msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the "
"CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into "
"bytecodes has to generate different code to access variables in a containing "
"scope.  ``from module import *`` and ``exec`` make it impossible for the "
"compiler to figure this out, because they add names to the local namespace "
"that are unknowable at compile time. Therefore, if a function contains "
"function definitions or :keyword:`lambda` expressions with free variables, "
"the compiler will flag this by raising a :exc:`SyntaxError` exception."
msgstr ""
"En sidoeffekt av förändringen är att ``from module import *`` och ``exec``-"
"satserna har gjorts olagliga inom ett funktionsomfång under vissa "
"förhållanden.  Pythons referensmanual har hela tiden sagt att ``from module "
"import *`` bara är lagligt på den översta nivån i en modul, men CPython-"
"tolken har aldrig verkställt detta tidigare.  Som en del av implementeringen "
"av nästlade scope måste kompilatorn som förvandlar Python-källkod till "
"bytecodes generera annan kod för att komma åt variabler i ett innehållande "
"scope.  ``from module import *`` och ``exec`` gör det omöjligt för "
"kompilatorn att räkna ut detta, eftersom de lägger till namn i det lokala "
"namnområdet som är okända vid kompileringstillfället. Därför, om en funktion "
"innehåller funktionsdefinitioner eller :keyword:`lambda` uttryck med fria "
"variabler, kommer kompilatorn att flagga detta genom att skapa ett :exc:"
"`SyntaxError` undantag."

msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr ""
"För att göra den föregående förklaringen lite tydligare, här är ett exempel::"

msgid ""
"x = 1\n"
"def f():\n"
"    # The next line is a syntax error\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"
msgstr ""
"x = 1\n"
"def f():\n"
"    # Nästa rad är ett syntaxfel\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"

msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed "
"by :func:`!g`."
msgstr ""
"Rad 4 som innehåller ``exec``-satsen är ett syntaxfel, eftersom ``exec`` "
"skulle definiera en ny lokal variabel med namnet ``x`` vars värde ska nås "
"av :func:`!g`."

msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr ""
"Detta borde inte vara någon större begränsning, eftersom ``exec`` sällan "
"används i den mesta Python-koden (och när det används är det ofta ett tecken "
"på dålig design)."

msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - Statiskt nästlade scopes"

msgid "Written and implemented by Jeremy Hylton."
msgstr "Skriven och implementerad av Jeremy Hylton."

msgid "New and Improved Modules"
msgstr "Nya och förbättrade moduler"

msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module was contributed to the standard "
"library by Fredrik Lundh, providing support for writing XML-RPC clients.  "
"XML-RPC is a simple remote procedure call protocol built on top of HTTP and "
"XML. For example, the following snippet retrieves a list of RSS channels "
"from the O'Reilly Network, and then  lists the recent headlines for one "
"channel::"
msgstr ""
"Modulen :mod:`xmlrpclib <xmlrpc.client>` är ett bidrag till "
"standardbiblioteket från Fredrik Lundh och ger stöd för att skriva XML-RPC-"
"klienter.  XML-RPC är ett enkelt protokoll för fjärrproceduranrop som bygger "
"på HTTP och XML. Följande utdrag hämtar till exempel en lista med RSS-"
"kanaler från O'Reilly Network och listar sedan de senaste rubrikerna för en "
"kanal::"

msgid ""
"import xmlrpclib\n"
"s = xmlrpclib.Server(\n"
"      'http://www.oreillynet.com/meerkat/xml-rpc/server.php')\n"
"channels = s.meerkat.getChannels()\n"
"# channels is a list of dictionaries, like this:\n"
"# [{'id': 4, 'title': 'Freshmeat Daily News'}\n"
"#  {'id': 190, 'title': '32Bits Online'},\n"
"#  {'id': 4549, 'title': '3DGamers'}, ... ]\n"
"\n"
"# Get the items for one channel\n"
"items = s.meerkat.getItems( {'channel': 4} )\n"
"\n"
"# 'items' is another list of dictionaries, like this:\n"
"# [{'link': 'http://freshmeat.net/releases/52719/',\n"
"#   'description': 'A utility which converts HTML to XSL FO.',\n"
"#   'title': 'html2fo 0.3 (Default)'}, ... ]"
msgstr ""
"import xmlrpclib\n"
"s = xmlrpclib.server(\n"
"      'http://www.oreillynet.com/meerkat/xml-rpc/server.php')\n"
"kanaler = s.meerkat.getChannels()\n"
"# kanaler är en lista med ordböcker, så här:\n"
"# [{'id': 4, 'title': 'Freshmeat Daily News'}\n"
"# {'id': 190, 'title': '32Bits Online'},\n"
"# {'id': 4549, 'title': '3DGamers'}, ... ]\n"
"\n"
"# Hämta objekten för en kanal\n"
"objekt = s.meerkat.getItems( {'kanal': 4} )\n"
"\n"
"# \"items\" är en annan lista med ordböcker, så här:\n"
"# [{'link': 'http://freshmeat.net/releases/52719/',\n"
"# 'description': 'Ett verktyg som konverterar HTML till XSL FO.',\n"
"# 'title': 'html2fo 0.3 (Standard)'}, ... ]"

msgid ""
"The :mod:`SimpleXMLRPCServer <xmlrpc.server>` module makes it easy to create "
"straightforward XML-RPC servers.  See http://xmlrpc.scripting.com/ for more "
"information about XML-RPC."
msgstr ""
"Modulen :mod:`SimpleXMLRPCServer <xmlrpc.server>` gör det enkelt att skapa "
"enkla XML-RPC-servrar.  Se http://xmlrpc.scripting.com/ för mer information "
"om XML-RPC."

msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by :rfc:"
"`2104`. (Contributed by Gerhard Häring.)"
msgstr ""
"Den nya modulen :mod:`hmac` implementerar HMAC-algoritmen som beskrivs av :"
"rfc:`2104`. (Bidrag från Gerhard Häring.)"

msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as :attr:`!memberst_mtime` or :attr:`~time.struct_time.tm_year`. The "
"enhanced functions include :func:`~os.stat`, :func:`~os.fstat`, :func:`~os."
"statvfs`, and :func:`~os.fstatvfs` in the :mod:`os` module, and :func:`~time."
"localtime`, :func:`~time.gmtime`, and :func:`~time.strptime` in the :mod:"
"`time` module."
msgstr ""
"Flera funktioner som ursprungligen returnerade långa tuplar returnerar nu "
"pseudosekvenser som fortfarande beter sig som tuplar men som också har "
"minnesvärda attribut som :attr:`!memberst_mtime` eller :attr:`~time."
"struct_time.tm_year`. De förbättrade funktionerna inkluderar :func:`~os."
"stat`, :func:`~os.fstat`, :func:`~os.statvfs` och :func:`~os.fstatvfs` i "
"modulen :mod:`os`, och :func:`~time.localtime`, :func:`~time.gmtime` och :"
"func:`~time.strptime` i modulen :mod:`time`."

msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = os.stat(filename)."
"st_size``."
msgstr ""
"Om du till exempel vill veta storleken på en fil med hjälp av de gamla "
"tuplarna skulle du skriva något i stil med ``file_size = os.stat(filnamn)"
"[stat.ST_SIZE]``, men nu kan det skrivas tydligare som ``file_size = os."
"stat(filnamn).st_size``."

msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr ""
"Den ursprungliga korrigeringen för denna funktion gjordes av Nick Mathewson."

msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"Python-profileraren har genomgått en omfattande omarbetning och olika fel i "
"dess utdata har korrigerats.  (Bidrag från Fred L. Drake, Jr. och Tim "
"Peters.)"

msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the :"
"option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
"Modulen :mod:`socket` kan kompileras för att stödja IPv6; ange alternativet :"
"option:`!--enable-ipv6` i Pythons configure-skript.  (Bidrag från Jun-ichiro "
"\"itojun\" Hagino.)"

msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is "
"for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value is "
"returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""
"Två nya formattecken har lagts till i modulen :mod:`struct` för 64-bitars "
"heltal på plattformar som stöder C :c:expr:`long long`-typen.  ``q`` är för "
"ett signerat 64-bitars heltal, och ``Q`` är för ett osignerat.  Värdet "
"returneras i Pythons long integer-typ.  (Bidrag från Tim Peters.)"

msgid ""
"In the interpreter's interactive mode, there's a new built-in function :func:"
"`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to provide "
"interactive help. ``help(object)`` displays any available help text about "
"*object*.  :func:`help` with no argument puts you in an online help utility, "
"where you can enter the names of functions, classes, or modules to read "
"their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's :mod:"
"`pydoc` module.)"
msgstr ""
"I tolkens interaktiva läge finns en ny inbyggd funktion :func:`help` som "
"använder modulen :mod:`pydoc` som introducerades i Python 2.1 för att ge "
"interaktiv hjälp. ``help(object)`` visar all tillgänglig hjälptext om "
"*object*. :func:`help` utan argument placerar dig i ett online-hjälpverktyg, "
"där du kan ange namnen på funktioner, klasser eller moduler för att läsa "
"deras hjälptext. (Bidrag från Guido van Rossum, som använder Ka-Ping Yee:s "
"modul :mod:`pydoc`)"

msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` "
"and :func:`re.split` functions have been rewritten in C.  Another "
"contributed patch speeds up certain Unicode character ranges by a factor of "
"two, and a new :meth:`~re.finditer`  method that returns an iterator over "
"all the non-overlapping matches in  a given string.  (SRE is maintained by "
"Fredrik Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""
"Olika buggfixar och prestandaförbättringar har gjorts i SRE-motorn som "
"ligger till grund för modulen :mod:`re`.  Till exempel har funktionerna :"
"func:`re.sub` och :func:`re.split` skrivits om i C. En annan patch som har "
"bidragit snabbar upp vissa Unicode-teckenintervall med en faktor två, och en "
"ny :meth:`~re.finditer`-metod som returnerar en iterator över alla icke-"
"överlappande matchningar i en given sträng.  (SRE underhålls av Fredrik "
"Lundh.  BIGCHARSET-patchen är ett bidrag från Martin von Löwis)"

msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over "
"TLS\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib` "
"also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
"Modulen :mod:`smtplib` stöder nu :rfc:`2487`, \"Secure SMTP over TLS\", så "
"det är nu möjligt att kryptera SMTP-trafiken mellan ett Python-program och "
"den e-posttransportagent som får ett meddelande. :mod:`smtplib` stöder också "
"SMTP-autentisering.  (Bidrag från Gerhard Häring.)"

msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
"Modulen :mod:`imaplib`, som underhålls av Piers Lauder, har stöd för flera "
"nya tillägg: NAMESPACE-tillägget som definieras i :rfc:`2342`, SORT, GETACL "
"och SETACL. (Bidrag från Anthony Baxter och Michel Pelletier.)"

msgid ""
"The :mod:`!rfc822` module's parsing of email addresses is now compliant "
"with :rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* "
"going to be changed to ``rfc2822``.)  A new package, :mod:`email`, has also "
"been added for parsing and generating e-mail messages.  (Contributed by "
"Barry Warsaw, and arising out of his work on Mailman.)"
msgstr ""
"Modulen :mod:`!rfc822`:s parsning av e-postadresser är nu kompatibel med :"
"rfc:`2822`, en uppdatering av :rfc:`822`.  (Modulens namn kommer *inte* att "
"ändras till ``rfc2822``.) Ett nytt paket, :mod:`email`, har också lagts till "
"för parsning och generering av e-postmeddelanden.  (Bidraget kommer från "
"Barry Warsaw och är ett resultat av hans arbete med Mailman)"

msgid ""
"The :mod:`difflib` module now contains a new :class:`!Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, :func:`!"
"ndiff` and :func:`!restore`, which respectively return a delta from two "
"sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""
"Modulen :mod:`difflib` innehåller nu en ny klass :class:`!Differ` för att "
"producera mänskligt läsbara listor över förändringar (ett \"delta\") mellan "
"två sekvenser av textrader.  Det finns också två generatorfunktioner, :func:"
"`!ndiff` och :func:`!restore`, som returnerar ett delta från två sekvenser "
"respektive en av originalsekvenserna från ett delta. (Grunt-arbete utfört av "
"David Goodger, från ndiff.py-kod av Tim Peters som sedan gjorde "
"generatoriseringen)"

msgid ""
"New constants :const:`!ascii_letters`, :const:`!ascii_lowercase`, and :const:"
"`!ascii_uppercase` were added to the :mod:`string` module.  There were "
"several modules in the standard library that used :const:`!string.letters` "
"to mean the ranges A-Za-z, but that assumption is incorrect when locales are "
"in use, because :const:`!string.letters` varies depending on the set of "
"legal characters defined by the current locale.  The buggy modules have all "
"been fixed to use :const:`!ascii_letters` instead. (Reported by an unknown "
"person; fixed by Fred L. Drake, Jr.)"
msgstr ""
"Nya konstanter :const:`!ascii_letters`, :const:`!ascii_lowercase` och :const:"
"`!ascii_uppercase` har lagts till i modulen :mod:`string`.  Det fanns flera "
"moduler i standardbiblioteket som använde :const:`!string.letters` för att "
"betyda intervallen A-Za-z, men det antagandet är felaktigt när lokalspråk "
"används, eftersom :const:`!string.letters` varierar beroende på "
"uppsättningen av lagliga tecken som definieras av det aktuella "
"lokalspråket.  De buggiga modulerna har alla åtgärdats så att de använder :"
"const:`!ascii_letters` istället. (Rapporterad av en okänd person; åtgärdad "
"av Fred L. Drake, Jr.)"

msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type "
"databases by the addition of a :class:`~mimetypes.MimeTypes` class, which "
"takes a list of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Modulen :mod:`mimetypes` gör det nu enklare att använda alternativa MIME-"
"typdatabaser genom tillägget av en klass :class:`~mimetypes.MimeTypes`, som "
"tar emot en lista med filnamn som skall analyseras.  (Bidrag från Fred L. "
"Drake, Jr.)"

msgid ""
"A :class:`~threading.Timer` class was added to the :mod:`threading` module "
"that allows scheduling an activity to happen at some future time.  "
"(Contributed by Itamar Shtull-Trauring.)"
msgstr ""
"En :class:`~threading.Timer`-klass lades till i :mod:`threading`-modulen som "
"gör det möjligt att schemalägga en aktivitet till en viss tidpunkt i "
"framtiden.  (Bidrag från Itamar Shtull-Trauring.)"

msgid "Interpreter Changes and Fixes"
msgstr "Ändringar och korrigeringar i tolkprogrammet"

msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"En del av ändringarna påverkar bara personer som arbetar med Python-tolken "
"på C-nivå, eftersom de skriver Python-tilläggsmoduler, bäddar in tolken "
"eller bara hackar på själva tolken. Om du bara skriver Python-kod kommer "
"ingen av de förändringar som beskrivs här att påverka dig särskilt mycket."

msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors "
"of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The "
"existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Profilerings- och spårningsfunktioner kan nu implementeras i C, som kan "
"arbeta i mycket högre hastigheter än Python-baserade funktioner och bör "
"minska omkostnaderna för profilering och spårning.  Detta kommer att vara av "
"intresse för författare av utvecklingsmiljöer för Python.  Två nya C-"
"funktioner har lagts till i Pythons API, :c:func:`PyEval_SetProfile` och :c:"
"func:`PyEval_SetTrace`. De befintliga funktionerna :func:`sys.setprofile` "
"och :func:`sys.settrace` finns fortfarande kvar och har helt enkelt ändrats "
"för att använda det nya gränssnittet på C-nivå.  (Bidrag från Fred L. Drake, "
"Jr.)"

msgid ""
"Another low-level API, primarily of interest to implementers of Python "
"debuggers and development tools, was added. :c:func:"
"`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let a caller "
"walk through all the existing interpreter objects; :c:func:"
"`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` allow "
"looping over all the thread states for a given interpreter.  (Contributed by "
"David Beazley.)"
msgstr ""
"Ytterligare ett API på låg nivå, främst av intresse för implementatörer av "
"Python-debuggar och utvecklingsverktyg, har lagts till. :c:func:"
"`PyInterpreterState_Head` och :c:func:`PyInterpreterState_Next` låter en "
"anropare gå igenom alla befintliga tolkobjekt; :c:func:"
"`PyInterpreterState_ThreadHead` och :c:func:`PyThreadState_Next` tillåter "
"loopning över alla trådstatusar för en given tolk.  (Bidrag från David "
"Beazley.)"

msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug "
"misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"Gränssnittet på C-nivå till skräpsamlaren har ändrats för att göra det "
"lättare att skriva tilläggstyper som stöder skräpsamling och för att felsöka "
"felaktig användning av funktionerna. Olika funktioner har lite olika "
"semantik, så ett antal funktioner måste döpas om.  Tillägg som använder det "
"gamla API:et kommer fortfarande att kompileras men kommer *inte* att delta i "
"garbage collection, så att uppdatera dem för 2.2 bör anses ha ganska hög "
"prioritet."

msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr ""
"Utför följande steg för att uppgradera en tilläggsmodul till det nya API:et:"

msgid "Rename :c:macro:`!Py_TPFLAGS_GC` to :c:macro:`Py_TPFLAGS_HAVE_GC`."
msgstr ""
"Byt namn på :c:macro:`!Py_TPFLAGS_GC` till :c:macro:`Py_TPFLAGS_HAVE_GC`."

msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr ""
"Använd :c:func:`PyObject_GC_New` eller :c:func:`PyObject_GC_NewVar` för att "
"allokera"

msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr "objekt och :c:func:`PyObject_GC_Del` för att avallokera dem."

msgid ""
"Rename :c:func:`!PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and :c:"
"func:`!PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr ""
"Byt namn på :c:func:`!PyObject_GC_Init` till :c:func:`PyObject_GC_Track` "
"och :c:func:`!PyObject_GC_Fini` till :c:func:`PyObject_GC_UnTrack`."

msgid "Remove :c:macro:`!PyGC_HEAD_SIZE` from object size calculations."
msgstr "Ta bort :c:macro:`!PyGC_HEAD_SIZE` från beräkningar av objektstorlek."

msgid ""
"Remove calls to :c:func:`!PyObject_AS_GC` and :c:func:`!PyObject_FROM_GC`."
msgstr ""
"Ta bort anrop till :c:func:`!PyObject_AS_GC` och :c:func:`!PyObject_FROM_GC`."

msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et`` "
"takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following section.)"
msgstr ""
"En ny ``et`` formatsekvens lades till i :c:func:`PyArg_ParseTuple`; ``et`` "
"tar både en parameter och ett kodningsnamn, och konverterar parametern till "
"den givna kodningen om parametern visar sig vara en Unicode-sträng, eller "
"lämnar den ifred om det är en 8-bitars sträng, och antar att den redan är i "
"önskad kodning.  Detta skiljer sig från formattecknet ``es``, som antar att "
"8-bitars strängar är i Pythons standard ASCII-kodning och konverterar dem "
"till den angivna nya kodningen. (Bidrag från M.-A. Lemburg, och används för "
"MBCS-stödet på Windows som beskrivs i följande avsnitt.)"

msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been "
"added that's simpler and presumably faster.  Instead of specifying a format "
"string, the caller simply gives the minimum and maximum number of arguments "
"expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""
"En annan argumentparsingfunktion, :c:func:`PyArg_UnpackTuple`, har lagts "
"till som är enklare och förmodligen snabbare.  Istället för att ange en "
"formatsträng anger anroparen helt enkelt det minsta och största antalet "
"argument som förväntas, och en uppsättning pekare till :c:expr:`PyObject*`-"
"variabler som ska fyllas i med argumentvärden."

msgid ""
"Two new flags :c:macro:`METH_NOARGS` and :c:macro:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses :c:macro:"
"`METH_VARARGS`.  Also, the old :c:macro:`!METH_OLDARGS` style of writing C "
"methods is  now officially deprecated."
msgstr ""
"Två nya flaggor :c:macro:`METH_NOARGS` och :c:macro:`METH_O` finns "
"tillgängliga i metoddefinitionstabeller för att förenkla implementeringen av "
"metoder utan argument eller med ett enda otypat argument. Anrop av sådana "
"metoder är effektivare än anrop av en motsvarande metod som använder :c:"
"macro:`METH_VARARGS`.  Dessutom är den gamla :c:macro:`!METH_OLDARGS`-stilen "
"att skriva C-metoder nu officiellt föråldrad."

msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and :c:func:"
"`PyOS_vsnprintf` were added to provide  cross-platform implementations for "
"the relatively new :c:func:`snprintf` and :c:func:`vsnprintf` C lib APIs. In "
"contrast to the standard :c:func:`sprintf` and :c:func:`!vsprintf` "
"functions, the Python versions check the bounds of the buffer used to "
"protect against buffer overruns. (Contributed by M.-A. Lemburg.)"
msgstr ""
"Två nya omslagsfunktioner, :c:func:`PyOS_snprintf` och :c:func:"
"`PyOS_vsnprintf` lades till för att tillhandahålla plattformsoberoende "
"implementationer för de relativt nya C lib API:erna :c:func:`snprintf` och :"
"c:func:`vsnprintf`. Till skillnad från standardfunktionerna :c:func:"
"`sprintf` och :c:func:`!vsprintf` kontrollerar Python-versionerna gränserna "
"för den buffert som används för att skydda mot buffertöverskridanden. "
"(Bidrag från M.-A. Lemburg.)"

msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
"Funktionen :c:func:`_PyTuple_Resize` har förlorat en oanvänd parameter, så "
"nu tar den 2 parametrar istället för 3. Det tredje argumentet användes "
"aldrig, och kan helt enkelt kasseras när kod från tidigare versioner portas "
"till Python 2.2."

msgid "Other Changes and Fixes"
msgstr "Övriga ändringar och korrigeringar"

msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches "
"and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"Som vanligt fanns det en massa andra förbättringar och buggfixar utspridda i "
"hela källträdet.  En sökning genom CVS-ändringsloggarna visar att det fanns "
"527 korrigeringar och 683 buggfixar mellan Python 2.1 och 2.2; 2.2.1 "
"tillämpade 139 korrigeringar och fixade 143 buggar; 2.2.2 tillämpade 106 "
"korrigeringar och fixade 82 buggar.  Dessa siffror är sannolikt "
"underskattningar."

msgid "Some of the more notable changes are:"
msgstr "Några av de mer anmärkningsvärda förändringarna är:"

msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support "
"MacOS X."
msgstr ""
"Koden för MacOS-porten för Python, som underhålls av Jack Jansen, finns nu i "
"Pythons CVS-huvudträd och många ändringar har gjorts för att stödja MacOS X."

msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework "
"\"glue\" into :file:`/Library/Frameworks/Python.framework` (or another "
"location of choice). For now there is little immediate added benefit to this "
"(actually, there is the disadvantage that you have to change your PATH to be "
"able to find Python), but it is the basis for creating a full-blown Python "
"application, porting the MacPython IDE, possibly using Python as a standard "
"OSA scripting language and much more.\""
msgstr ""
"Den mest betydande förändringen är möjligheten att bygga Python som ett "
"ramverk, vilket aktiveras genom att ange alternativet :option:`!--enable-"
"framework` till configure-skriptet när Python kompileras.  Enligt Jack "
"Jansen, \"Detta installerar en fristående Python-installation plus OS X-"
"ramverket \"glue\" i :file:`/Library/Frameworks/Python.framework` (eller "
"annan valfri plats). För närvarande finns det inte mycket omedelbar nytta "
"med detta (det finns faktiskt en nackdel i att du måste ändra din PATH för "
"att kunna hitta Python), men det är grunden för att skapa en fullfjädrad "
"Python-applikation, porta MacPython IDE, eventuellt använda Python som ett "
"standard OSA-skriptspråk och mycket mer.\""

msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as "
"windowing, QuickTime, scripting, etc. have been ported to OS X, but they've "
"been left commented out in :file:`setup.py`.  People who want to experiment "
"with these modules can uncomment them manually."
msgstr ""
"De flesta av MacPythons verktygslådemoduler, som har gränssnitt mot MacOS "
"API:er som windowing, QuickTime, scripting, etc. har portats till OS X, men "
"de har lämnats okommenterade i :file:`setup.py`.  Personer som vill "
"experimentera med dessa moduler kan kommentera bort dem manuellt."

msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"Nyckelordsargument som skickas till inbyggda funktioner som inte tar emot "
"dem orsakar nu ett :exc:`TypeError`-undantag med meddelandet \"*funktion* "
"tar inga nyckelordsargument\"."

msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of "
"the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the :mod:"
"`weakref` module to become a built-in exception."
msgstr ""
"Svaga referenser, som lades till i Python 2.1 som en tilläggsmodul, är nu en "
"del av kärnan eftersom de används i implementeringen av klasser av ny typ.  "
"Undantaget :exc:`ReferenceError` har därför flyttats från modulen :mod:"
"`weakref` till att bli ett inbyggt undantag."

msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"Ett nytt skript, :file:`Tools/scripts/cleanfuture.py` av Tim Peters, tar "
"automatiskt bort föråldrade ``__future__``-satser från Pythons källkod."

msgid ""
"An additional *flags* argument has been added to the built-in function :func:"
"`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"Ett ytterligare *flags*-argument har lagts till i den inbyggda funktionen :"
"func:`compile`, så att beteendet hos ``__future__``-satser nu kan observeras "
"korrekt i simulerade skal, som de som presenteras av IDLE och andra "
"utvecklingsmiljöer.  Detta beskrivs i :pep:`264`. (Bidrag från Michael "
"Hudson.)"

msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to "
"embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"Den nya licensen som introducerades med Python 1.6 var inte GPL-kompatibel.  "
"Detta är åtgärdat genom några mindre textändringar i 2.2-licensen, så det är "
"nu lagligt att bädda in Python i ett GPL-program igen.  Observera att Python "
"i sig inte är GPL, utan istället är under en licens som i huvudsak är "
"likvärdig med BSD-licensen, precis som den alltid har varit.  "
"Licensändringarna tillämpades också på Python 2.0.1 och 2.1.1 utgåvorna."

msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default "
"encoding turns out to be an annoyance.  On Unix, the locale's character set "
"is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"När Python får ett Unicode-filnamn i Windows konverterar Python det nu till "
"en MBCS-kodad sträng, som används av Microsofts fil-API:er.  Eftersom MBCS "
"uttryckligen används av fil-API:erna, visar sig Pythons val av ASCII som "
"standardkodning vara ett irritationsmoment.  På Unix används lokalens "
"teckenuppsättning om ``locale.nl_langinfo(CODESET)`` är tillgänglig.  "
"(Windows-stöd har tillhandahållits av Mark Hammond med hjälp av Marc-André "
"Lemburg. Unix-stöd har lagts till av Martin von Löwis)"

msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr ""
"Stöd för stora filer är nu aktiverat i Windows.  (Bidrag från Tim Peters.)"

msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
"Skriptet :file:`Tools/scripts/ftpmirror.py` analyserar nu en :file:`.netrc`-"
"fil, om du har en sådan. (Bidrag från Mike Romberg.)"

msgid ""
"Some features of the object returned by the :func:`!xrange` function are now "
"deprecated, and trigger warnings when they're accessed; they'll disappear in "
"Python 2.3. :class:`!xrange` objects tried to pretend they were full "
"sequence types by supporting slicing, sequence multiplication, and the :"
"keyword:`in` operator, but these features were rarely used and therefore "
"buggy.  The :meth:`!tolist` method and the :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` attributes are also being deprecated.  At the C level, the "
"fourth argument to the :c:func:`!PyRange_New` function, ``repeat``, has also "
"been deprecated."
msgstr ""
"Vissa egenskaper hos objektet som returneras av funktionen :func:`!xrange` "
"är nu föråldrade och utlöser varningar när de används; de kommer att "
"försvinna i Python 2.3. :class:`!xrange`-objekt försökte låtsas att de var "
"fullständiga sekvenstyper genom att stödja skivning, sekvensmultiplikation "
"och operatorn :keyword:`in`, men dessa egenskaper användes sällan och var "
"därför buggiga.  Metoden :meth:`!tolist` och attributen :attr:`!start`, :"
"attr:`!stop` och :attr:`!step` är också föråldrade.  På C-nivå har det "
"fjärde argumentet till funktionen :c:func:`!PyRange_New`, ``repeat``, också "
"utgått."

msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a "
"case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"Det fanns ett antal korrigeringar till implementationen av ordböcker, "
"mestadels för att åtgärda potentiella dumpningar av kärnan om en ordbok "
"innehåller objekt som i smyg ändrade sitt hashvärde eller muterade den "
"ordbok de ingick i. Under en tid föll python-dev in i en lugn rytm där "
"Michael Hudson hittade ett fall som dumpade kärnan, Tim Peters fixade "
"buggen, Michael hittade ett annat fall och så gick det runt och runt."

msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""
"På Windows kan Python nu kompileras med Borland C tack vare ett antal "
"patchar som Stephen Hansen har bidragit med, även om resultatet inte är "
"fullt funktionellt ännu.  (Men det här *är* ett framsteg...)"

msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""
"Ännu en Windows-förbättring: Wise Solutions erbjöd generöst PythonLabs att "
"använda deras InstallerMaster 8.1-system.  Tidigare PythonLabs Windows-"
"installatörer använde Wise 5.0a, som började visa sin ålder.  (Paketerat av "
"Tim Peters.)"

msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David "
"Bolen.)"
msgstr ""
"Filer som slutar på ``.pyw`` kan nu importeras i Windows. ``.pyw`` är något "
"som bara finns i Windows och används för att indikera att ett skript måste "
"köras med PYTHONW.EXE istället för PYTHON.EXE för att förhindra att en DOS-"
"konsol dyker upp för att visa utdata.  Denna patch gör det möjligt att "
"importera sådana skript, ifall de också kan användas som moduler.  "
"(Implementerad av David Bolen.)"

msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by :c:func:"
"`dlopen` using the :func:`sys.getdlopenflags` and :func:`sys.setdlopenflags` "
"functions. (Contributed by Bram Stolk.)"
msgstr ""
"På plattformar där Python använder C-funktionen :c:func:`dlopen` för att "
"ladda tilläggsmoduler är det nu möjligt att ställa in flaggorna som används "
"av :c:func:`dlopen` med hjälp av funktionerna :func:`sys.getdlopenflags` "
"och :func:`sys.setdlopenflags`. (Bidrag från Bram Stolk.)"

msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating-point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""
"Den inbyggda funktionen :func:`pow` har inte längre stöd för 3 argument när "
"flyttal anges. ``pow(x, y, z)`` returnerar ``(x**y) % z``, men detta är "
"aldrig användbart för flyttal och slutresultatet varierar oförutsägbart "
"beroende på plattform.  Ett anrop som ``pow(2.0, 8.0, 7.0)`` kommer nu att "
"ge upphov till ett :exc:`TypeError` undantag."

msgid "Acknowledgements"
msgstr "Tack till"

msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack "
"Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, "
"Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van "
"Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"Författaren vill tacka följande personer för förslag, korrigeringar och "
"hjälp med olika utkast till denna artikel: Fred Bremmer, Keith Briggs, "
"Andrew Dalke, Fred L. Drake, Jr, Carel Fellinger, David Goodger, Mark "
"Hammond, Stephen Hansen, Michael Hudson, Jack Jansen, Marc-André Lemburg, "
"Martin von Löwis, Fredrik Lundh, Michael McLay, Nick Mathewson, Paul Moore, "
"Gustavo Niemeyer, Don O'Donnell, Joonas Paalasma, Tim Peters, Jens Quade, "
"Tom Reinhardt, Neil Schemenauer, Guido van Rossum, Greg Ward, Edward "
"Welbourne."
