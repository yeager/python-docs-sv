# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!codecs` --- Codec registry and base classes"
msgstr ":mod:`!kodekar` --- Kodek-register och basklasser"

msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**Källkod:** :source:`Lib/kodekar.py`"

msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes (and "
"decode bytes to text), but there are also codecs provided that encode text "
"to text, and bytes to bytes. Custom codecs may encode and decode between "
"arbitrary types, but some module features are restricted to be used "
"specifically with :term:`text encodings <text encoding>` or with codecs that "
"encode to :class:`bytes`."
msgstr ""
"Denna modul definierar basklasser för standard Python-kodekar (kodare och "
"avkodare) och ger tillgång till det interna Python-kodek-registret, som "
"hanterar uppslagningsprocessen för kodek och felhantering. De flesta "
"standardkodeker är :term:`textkodningar <text encoding>`, som kodar text "
"till byte (och avkodar byte till text), men det finns också kodeker som "
"kodar text till text och byte till byte. Anpassade kodekar kan koda och "
"avkoda mellan godtyckliga typer, men vissa modulfunktioner är begränsade "
"till att användas specifikt med :term:`text encodings <text encoding>` eller "
"med kodekar som kodar till :class:`bytes`."

msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr ""
"Modulen definierar följande funktioner för kodning och avkodning med valfri "
"kodek:"

msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "Kodar *obj* med hjälp av den kodek som registrerats för *kodning*."

msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Errors* kan anges för att ställa in önskat felhanteringssystem. "
"Standardfelhanteringen är ``'strict'`` vilket innebär att kodningsfel ger "
"upphov till :exc:`ValueError` (eller en mer kodek-specifik underklass, t."
"ex. :exc:`UnicodeEncodeError`). Se :ref:`kodek-base-classes` för mer "
"information om felhantering för kodek."

msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "Avkodar *obj* med hjälp av den kodek som registrerats för *encoding*."

msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Errors* kan anges för att ställa in önskat felhanteringssystem. "
"Standardfelhanteringen är ``'strict'`` vilket innebär att avkodningsfel ger "
"upphov till :exc:`ValueError` (eller en mer kodek-specifik underklass, t."
"ex. :exc:`UnicodeDecodeError`). Se :ref:`kodek-base-classes` för mer "
"information om felhantering för kodek."

msgid ""
"Return a mapping suitable for encoding with a custom single-byte encoding. "
"Given a :class:`str` *string* of up to 256 characters representing a "
"decoding table, returns either a compact internal mapping object "
"``EncodingMap`` or a :class:`dictionary <dict>` mapping character ordinals "
"to byte values. Raises a :exc:`TypeError` on invalid input."
msgstr ""
"Returnerar en mappning som är lämplig för kodning med en anpassad single-"
"byte-kodning. Givet en :class:`str` *string* på upp till 256 tecken som "
"representerar en avkodningstabell, returnerar antingen ett kompakt internt "
"mappningsobjekt ``EncodingMap`` eller en :class:`dictionary <dict>` som "
"mappar teckenordinaler till bytevärden. Utlöser ett :exc:`TypeError` vid "
"ogiltig indata."

msgid "The full details for each codec can also be looked up directly:"
msgstr "Fullständig information om varje kodek kan också hämtas direkt:"

msgid ""
"Looks up the codec info in the Python codec registry and returns a :class:"
"`CodecInfo` object as defined below."
msgstr ""
"Letar upp kodek-info i Pythons kodek-register och returnerar ett :class:"
"`KodekInfo`-objekt enligt definitionen nedan."

msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the :class:"
"`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"Kodningar söks först upp i registrets cacheminne. Om de inte hittas "
"genomsöks listan över registrerade sökfunktioner. Om inget :class:"
"`KodekInfo`-objekt hittas genereras ett :exc:`LookupError`. I annat fall "
"lagras :class:`KodekInfo`-objektet i cacheminnet och returneras till "
"anroparen."

msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr ""
"Kodek-detaljer vid sökning i kodek-registret. Konstruktörens argument lagras "
"i attribut med samma namn:"

msgid "The name of the encoding."
msgstr "Namnet på kodningen."

msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and :meth:"
"`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface <codec-"
"objects>`). The functions or methods are expected to work in a stateless "
"mode."
msgstr ""
"De statslösa kodnings- och avkodningsfunktionerna. Dessa måste vara "
"funktioner eller metoder som har samma gränssnitt som metoderna :meth:"
"`~Kodek.encode` och :meth:`~Kodek.decode` för Kodek-instanser (se :ref:"
"`Kodek Interface <kodek-objects>`). Funktionerna eller metoderna förväntas "
"fungera i ett statslöst läge."

msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes :class:"
"`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"Klasser eller fabriksfunktioner för inkrementella kodare och avkodare. Dessa "
"måste tillhandahålla det gränssnitt som definieras av basklasserna :class:"
"`IncrementalEncoder` respektive :class:`IncrementalDecoder`. Inkrementella "
"kodekar kan bibehålla tillstånd."

msgid ""
"Stream writer and reader classes or factory functions. These have to provide "
"the interface defined by the base classes :class:`StreamWriter` and :class:"
"`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"Klasser eller fabriksfunktioner för stream writer och reader. Dessa måste "
"tillhandahålla det gränssnitt som definieras av basklasserna :class:"
"`StreamWriter` respektive :class:`StreamReader`. Stream kodekar kan "
"upprätthålla tillstånd."

msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr ""
"För att förenkla åtkomsten till de olika kodek-komponenterna tillhandahåller "
"modulen dessa ytterligare funktioner som använder :func:`lookup` för kodek-"
"uppslagningen:"

msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr ""
"Leta upp kodek för den givna kodningen och returnera dess kodningsfunktion."

msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr "Utlöser ett :exc:`LookupError` om kodningen inte kan hittas."

msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr ""
"Leta upp kodek för den givna kodningen och returnera dess avkodningsfunktion."

msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr ""
"Leta upp kodek för den angivna kodningen och returnera dess inkrementella "
"kodningsklass eller fabriksfunktion."

msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr ""
"Utlöser ett :exc:`LookupError` om kodningen inte kan hittas eller om kodek "
"inte stöder en inkrementell kodare."

msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr ""
"Leta upp kodek för den givna kodningen och returnera dess inkrementella "
"avkodarklass eller fabriksfunktion."

msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr ""
"Utlöser ett :exc:`LookupError` om kodningen inte kan hittas eller om kodek "
"inte stöder en inkrementell avkodare."

msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamReader` class or factory function."
msgstr ""
"Leta upp kodek för den angivna kodningen och returnera dess :class:"
"`StreamReader` klass eller fabriksfunktion."

msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamWriter` class or factory function."
msgstr ""
"Leta upp kodek för den angivna kodningen och returnera dess :class:"
"`StreamWriter` klass eller fabriksfunktion."

msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr ""
"Anpassade kodekar görs tillgängliga genom att registrera en lämplig "
"kodekarökfunktion:"

msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters with hyphens and "
"spaces converted to underscores, and return a :class:`CodecInfo` object. In "
"case a search function cannot find a given encoding, it should return "
"``None``."
msgstr ""
"Registrera en kodek-sökfunktion. Sökfunktioner förväntas ta ett argument, "
"vilket är kodningsnamnet i gemener med bindestreck och mellanslag "
"konverterade till understreck, och returnera ett :class:`KodekInfo`-objekt. "
"Om en sökfunktion inte kan hitta en given kodning bör den returnera ``None``."

msgid "Hyphens and spaces are converted to underscore."
msgstr "Bindestreck och mellanslag omvandlas till understreck."

msgid ""
"Unregister a codec search function and clear the registry's cache. If the "
"search function is not registered, do nothing."
msgstr ""
"Avregistrera en kodek-sökfunktion och rensa registrets cache. Om "
"sökfunktionen inte är registrerad gör du ingenting."

msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"Den inbyggda modulen :func:`open` och den tillhörande modulen :mod:`io` "
"rekommenderas för arbete med kodade textfiler, men den här modulen "
"innehåller ytterligare funktioner och klasser som gör det möjligt att "
"använda ett större antal kodekar vid arbete med binära filer:"

msgid ""
"Open an encoded file using the given *mode* and return an instance of :class:"
"`StreamReaderWriter`, providing transparent encoding/decoding. The default "
"file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"Öppna en kodad fil med det angivna *läget* och returnera en instans av :"
"class:`StreamReaderWriter`, vilket ger transparent kodning/avkodning. "
"Standardläget för filen är ``'r'``, vilket innebär att filen öppnas i "
"läsläge."

msgid ""
"If *encoding* is not ``None``, then the underlying encoded files are always "
"opened in binary mode. No automatic conversion of ``'\\n'`` is done on "
"reading and writing. The *mode* argument may be any binary mode acceptable "
"to the built-in :func:`open` function; the ``'b'`` is automatically added."
msgstr ""
"Om *encoding* inte är ``None`` öppnas de underliggande kodade filerna alltid "
"i binärt läge. Ingen automatisk konvertering av ``'\\n'`` görs vid läsning "
"och skrivning. Argumentet *mode* kan vara vilket binärt läge som helst som "
"är acceptabelt för den inbyggda funktionen :func:`open`; ``'b'`` läggs "
"automatiskt till."

msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr ""
"*encoding* anger den kodning som ska användas för filen. Alla kodningar som "
"kodar till och avkodar från bytes är tillåtna, och de datatyper som stöds av "
"filmetoderna beror på vilken kodek som används."

msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* kan anges för att definiera felhanteringen. Standardinställningen "
"är ``'strict'`` vilket gör att ett :exc:`ValueError` skapas om ett "
"kodningsfel uppstår."

msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr ""
"*buffring* har samma betydelse som för den inbyggda funktionen :func:`open`. "
"Standardvärdet är -1, vilket innebär att standardbuffertstorleken kommer att "
"användas."

msgid "The ``'U'`` mode has been removed."
msgstr "Läget ``'U`` har tagits bort."

msgid ":func:`codecs.open` has been superseded by :func:`open`."
msgstr ":func:`kodekar.open` har ersatts av :func:`open`."

msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr ""
"Returnerar en :class:`StreamRecoder`-instans, en omsluten version av *file* "
"som ger transparent omkodning. Originalfilen stängs när den omslutna "
"versionen stängs."

msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"Data som skrivs till den omslutna filen avkodas enligt den angivna "
"*data_encoding* och skrivs sedan till originalfilen som byte med "
"*file_encoding*. Bytes som läses från originalfilen avkodas enligt "
"*file_encoding* och resultatet kodas med hjälp av *data_encoding*."

msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr "Om *file_encoding* inte anges, används *data_encoding* som standard."

msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* kan anges för att definiera felhanteringen. Standardvärdet är "
"``'strict'``, vilket gör att :exc:`ValueError` aktiveras om ett kodningsfel "
"inträffar."

msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. *iterator* must yield :class:`str` objects. This function is a :"
"term:`generator`. The *errors* argument (as well as any other keyword "
"argument) is passed through to the incremental encoder."
msgstr ""
"Använder en inkrementell kodare för att iterativt koda indata som "
"tillhandahålls av *iterator*. *iterator* måste ge :class:`str`-objekt. Denna "
"funktion är en :term:`generator`. Argumentet *errors* (liksom alla andra "
"nyckelordsargument) skickas vidare till den inkrementella kodaren."

msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"Denna funktion kräver att kodek accepterar text :class:`str`-objekt att "
"koda. Därför stöder den inte bytes-till-bytes-kodare som ``base64_codec``."

msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. *iterator* must yield :class:`bytes` objects. This function is "
"a :term:`generator`. The *errors* argument (as well as any other keyword "
"argument) is passed through to the incremental decoder."
msgstr ""
"Använder en inkrementell avkodare för att iterativt avkoda indata som "
"tillhandahålls av *iterator*. *iterator* måste ge :class:`bytes`-objekt. "
"Denna funktion är en :term:`generator`. Argumentet *errors* (liksom alla "
"andra nyckelordsargument) skickas vidare till den inkrementella avkodaren."

msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with :func:"
"`iterencode`."
msgstr ""
"Denna funktion kräver att kodek accepterar :class:`bytes`-objekt för "
"avkodning. Därför stöder den inte text-till-text-kodare som ``rot_13``, även "
"om ``rot_13`` kan användas på motsvarande sätt med :func:`iterencode`."

msgid ""
"Return a :class:`tuple` containing the raw bytes of *buffer*, a :ref:`buffer-"
"compatible object <bufferobjects>` or :class:`str` (encoded to UTF-8 before "
"processing), and their length in bytes."
msgstr ""
"Returnerar en :class:`tuple` som innehåller de råa bytena i *buffer*, ett :"
"ref:`buffer-kompatibelt objekt <bufferobjects>` eller :class:`str` (kodat "
"till UTF-8 före bearbetning), och deras längd i byte."

msgid "The *errors* argument is ignored."
msgstr "Argumentet *errors* ignoreras."

msgid ""
">>> codecs.readbuffer_encode(b\"Zito\")\n"
"(b'Zito', 4)"
msgstr ""
">>> kodekar.readbuffer_encode(b\"Zito\")\n"
"(b\"Zito\", 4)"

msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr ""
"Modulen innehåller också följande konstanter som är användbara för att läsa "
"och skriva till plattformsberoende filer:"

msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or :const:"
"`BOM_UTF16_LE` depending on the platform's native byte order, :const:`BOM` "
"is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for :const:"
"`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The others "
"represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"Dessa konstanter definierar olika byte-sekvenser och är Unicode byte order "
"marks (BOMs) för flera kodningar. De används i UTF-16- och UTF-32-"
"dataströmmar för att ange den byteordning som används, och i UTF-8 som en "
"Unicode-signatur. :const:`BOM_UTF16` är antingen :const:`BOM_UTF16_BE` "
"eller :const:`BOM_UTF16_LE` beroende på plattformens inbyggda byteordning, :"
"const:`BOM` är ett alias för :const:`BOM_UTF16`, :const:`BOM_LE` för :const:"
"`BOM_UTF16_LE` och :const:`BOM_BE` för :const:`BOM_UTF16_BE`. De andra "
"representerar BOM i UTF-8- och UTF-32-kodningar."

msgid "Codec Base Classes"
msgstr "Kodek-basklasser"

msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis "
"for custom codec implementations."
msgstr ""
"Modulen :mod:`kodekar` definierar en uppsättning basklasser som definierar "
"gränssnitten för att arbeta med kodek-objekt och kan också användas som "
"grund för anpassade kodek-implementeringar."

msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless encoder/"
"decoder to implement the file protocols. Codec authors also need to define "
"how the codec will handle encoding and decoding errors."
msgstr ""
"Varje kodek måste definiera fyra gränssnitt för att kunna användas som kodek "
"i Python: stateless encoder, stateless decoder, stream reader och stream "
"writer. Strömläsaren och strömskrivaren återanvänder vanligtvis den "
"statslösa kodaren/avkodaren för att implementera filprotokollen. Kodek-"
"författare måste också definiera hur kodek ska hantera kodnings- och "
"avkodningsfel."

msgid "Error Handlers"
msgstr "Felhanterare"

msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument:"
msgstr ""
"För att förenkla och standardisera felhanteringen kan kodekar implementera "
"olika felhanteringsscheman genom att acceptera strängargumentet *errors*:"

msgid ""
"The following error handlers can be used with all Python :ref:`standard-"
"encodings` codecs:"
msgstr ""
"Följande felhanterare kan användas med alla Python :ref:`standard-encodings`-"
"kodekar:"

msgid "Value"
msgstr "Värde"

msgid "Meaning"
msgstr "Betydelse"

msgid "``'strict'``"
msgstr "``'strikt```"

msgid ""
"Raise :exc:`UnicodeError` (or a subclass), this is the default. Implemented "
"in :func:`strict_errors`."
msgstr ""
"Utlöser :exc:`UnicodeError` (eller en underklass), detta är standard. "
"Implementerad i :func:`strict_errors`."

msgid "``'ignore'``"
msgstr "```ignore```"

msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr ""
"Ignorera de felaktiga uppgifterna och fortsätt utan ytterligare meddelande. "
"Implementerad i :func:`ignore_errors`."

msgid "``'replace'``"
msgstr "``'ersätta'```"

msgid ""
"Replace with a replacement marker. On encoding, use ``?`` (ASCII character). "
"On decoding, use ``�`` (U+FFFD, the official REPLACEMENT CHARACTER). "
"Implemented in :func:`replace_errors`."
msgstr ""
"Ersätt med en ersättningsmarkör. Vid kodning, använd ``?`` (ASCII-tecken). "
"Vid avkodning, använd ``�`` (U+FFFD, det officiella ERSÄTTNINGSKARAKTERET). "
"Implementerad i :func:`replace_errors`."

msgid "``'backslashreplace'``"
msgstr "``'backslashreplace'``"

msgid ""
"Replace with backslashed escape sequences. On encoding, use hexadecimal form "
"of Unicode code point with formats :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :"
"samp:`\\\\U{xxxxxxxx}`. On decoding, use hexadecimal form of byte value with "
"format :samp:`\\\\x{hh}`. Implemented in :func:`backslashreplace_errors`."
msgstr ""
"Ersätt med bakåtstreckade escapesekvenser. Vid kodning, använd hexadecimal "
"form av Unicode kodpunkt med formaten :samp:`\\\\x{hh}` :samp:`\\u{xxxx}` :"
"samp:`\\U{xxxxxxxx}`. Vid avkodning, använd hexadecimal form av bytevärdet "
"med formatet :samp:`\\\\x{hh}`. Implementerad i :func:"
"`backslashreplace_errors`."

msgid "``'surrogateescape'``"
msgstr "``'surrogatlandskap'``"

msgid ""
"On decoding, replace byte with individual surrogate code ranging from "
"``U+DC80`` to ``U+DCFF``. This code will then be turned back into the same "
"byte when the ``'surrogateescape'`` error handler is used when encoding the "
"data. (See :pep:`383` for more.)"
msgstr ""
"Vid avkodning ersätts byte med individuell surrogatkod från ``U+DC80`` till "
"``U+DCFF``. Denna kod kommer sedan att omvandlas tillbaka till samma byte "
"när felhanteraren ``'surrogateescape'`` används vid kodning av data. (Se :"
"pep:`383` för mer information.)"

msgid ""
"The following error handlers are only applicable to encoding (within :term:"
"`text encodings <text encoding>`):"
msgstr ""
"Följande felhanterare är endast tillämpliga på kodning (inom :term:"
"`textkodning <text encoding>`):"

msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'`` ``"

msgid ""
"Replace with XML/HTML numeric character reference, which is a decimal form "
"of Unicode code point with format :samp:`&#{num};`. Implemented in :func:"
"`xmlcharrefreplace_errors`."
msgstr ""
"Ersätt med XML/HTML numerisk teckenreferens, som är en decimalform av "
"Unicode kodpunkt med formatet :samp:`&#{num};`. Implementerad i :func:"
"`xmlcharrefreplace_errors`."

msgid "``'namereplace'``"
msgstr "``'namnbytare'```"

msgid ""
"Replace with ``\\N{...}`` escape sequences, what appears in the braces is "
"the Name property from Unicode Character Database. Implemented in :func:"
"`namereplace_errors`."
msgstr ""
"Ersätt med ``\\N{...}`` escape-sekvenser, det som visas inom hakparenteserna "
"är egenskapen Name från Unicode Character Database. Implementerad i :func:"
"`namereplace_errors`."

msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr "Dessutom är följande felhanterare specifik för de angivna kodekar:"

msgid "Codecs"
msgstr "Kodekar"

msgid "``'surrogatepass'``"
msgstr "``'surrogatpass``"

msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

msgid ""
"Allow encoding and decoding surrogate code point (``U+D800`` - ``U+DFFF``) "
"as normal code point. Otherwise these codecs treat the presence of surrogate "
"code point in :class:`str` as an error."
msgstr ""
"Tillåt kodning och avkodning av surrogatkodpunkt (``U+D800`` - ``U+DFFF``) "
"som normal kodpunkt. Annars behandlar dessa kodekar förekomsten av "
"surrogatkodpunkt i :class:`str` som ett fel."

msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr "Felhanterarna ``'surrogateescape'`` och ``'surrogatepass'``."

msgid ""
"The ``'surrogatepass'`` error handler now works with utf-16\\* and utf-32\\* "
"codecs."
msgstr ""
"Felhanteraren ``'surrogatepass'`` fungerar nu med utf-16\\* och utf-32\\* "
"kodekar."

msgid "The ``'namereplace'`` error handler."
msgstr "Felhanteraren för ``'namereplace'``."

msgid ""
"The ``'backslashreplace'`` error handler now works with decoding and "
"translating."
msgstr ""
"Felhanteraren ``'backslashreplace'`` fungerar nu med avkodning och "
"översättning."

msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr ""
"Uppsättningen av tillåtna värden kan utökas genom att registrera en ny "
"namngiven felhanterare:"

msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""
"Registrera felhanteringsfunktionen *error_handler* under namnet *name*. "
"Argumentet *error_handler* kommer att anropas under kodning och avkodning i "
"händelse av ett fel, när *name* anges som felparameter."

msgid ""
"For encoding, *error_handler* will be called with a :exc:"
"`UnicodeEncodeError` instance, which contains information about the location "
"of the error. The error handler must either raise this or a different "
"exception, or return a tuple with a replacement for the unencodable part of "
"the input and a position where encoding should continue. The replacement may "
"be either :class:`str` or :class:`bytes`. If the replacement is bytes, the "
"encoder will simply copy them into the output buffer. If the replacement is "
"a string, the encoder will encode the replacement. Encoding continues on "
"original input at the specified position. Negative position values will be "
"treated as being relative to the end of the input string. If the resulting "
"position is out of bound an :exc:`IndexError` will be raised."
msgstr ""
"För kodning kommer *error_handler* att anropas med en :exc:"
"`UnicodeEncodeError`-instans, som innehåller information om var felet finns. "
"Felhanteraren måste antingen lyfta detta eller ett annat undantag, eller "
"returnera en tupel med en ersättning för den okodbara delen av indata och en "
"position där kodningen ska fortsätta. Ersättningen kan vara antingen :class:"
"`str` eller :class:`bytes`. Om ersättningen är bytes kommer kodaren helt "
"enkelt att kopiera dem till utmatningsbufferten. Om ersättningen är en "
"sträng kommer kodaren att koda ersättningen. Kodningen fortsätter på den "
"ursprungliga inmatningen vid den angivna positionen. Negativa "
"positionsvärden behandlas som om de är i förhållande till slutet av den "
"inmatade strängen. Om den resulterande positionen är utanför gränsen kommer "
"ett :exc:`IndexError` att visas."

msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""
"Avkodning och översättning fungerar på samma sätt, förutom att :exc:"
"`UnicodeDecodeError` eller :exc:`UnicodeTranslateError` kommer att skickas "
"till felhanteraren och att ersättningen från felhanteraren kommer att läggas "
"in i utdata direkt."

msgid ""
"Previously registered error handlers (including the standard error handlers) "
"can be looked up by name:"
msgstr ""
"Tidigare registrerade felhanterare (inklusive standardfelhanterare) kan "
"sökas upp med namn:"

msgid "Return the error handler previously registered under the name *name*."
msgstr ""
"Returnerar den felhanterare som tidigare registrerats under namnet *name*."

msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr "Utlöser ett :exc:`LookupError` om handläggaren inte kan hittas."

msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr ""
"Följande standardfelhanterare är också tillgängliga som funktioner på "
"modulnivå:"

msgid "Implements the ``'strict'`` error handling."
msgstr "Implementerar felhanteringen ``'strict``."

msgid "Each encoding or decoding error raises a :exc:`UnicodeError`."
msgstr ""
"Varje kodnings- eller avkodningsfel ger upphov till ett :exc:`UnicodeError`."

msgid "Implements the ``'ignore'`` error handling."
msgstr "Implementerar felhanteringen ``'ignorera'``."

msgid ""
"Malformed data is ignored; encoding or decoding is continued without further "
"notice."
msgstr ""
"Missbildade data ignoreras; kodning eller avkodning fortsätter utan "
"ytterligare meddelande."

msgid "Implements the ``'replace'`` error handling."
msgstr "Implementerar felhanteringen ``'replace'``."

msgid ""
"Substitutes ``?`` (ASCII character) for encoding errors or ``�`` (U+FFFD, "
"the official REPLACEMENT CHARACTER) for decoding errors."
msgstr ""
"Ersätter ``?`` (ASCII-tecken) för kodningsfel eller ``�`` (U+FFFD, det "
"officiella ERSÄTTNINGSKARAKTERET) för avkodningsfel."

msgid "Implements the ``'backslashreplace'`` error handling."
msgstr "Implementerar felhanteringen ``'backslashreplace'``."

msgid ""
"Malformed data is replaced by a backslashed escape sequence. On encoding, "
"use the hexadecimal form of Unicode code point with formats :samp:`\\\\x{hh}"
"` :samp:`\\\\u{xxxx}` :samp:`\\\\U{xxxxxxxx}`. On decoding, use the "
"hexadecimal form of byte value with format :samp:`\\\\x{hh}`."
msgstr ""
"Missbildade data ersätts av en bakåtstreckad escape-sekvens. Vid kodning, "
"använd den hexadecimala formen av Unicode code point med formaten :samp:`\\"
"\\x{hh}` :samp:`\\u{xxxx}` :samp:`\\U{xxxxxxxx}`. Vid avkodning används den "
"hexadecimala formen av bytevärdet med formatet :samp:`\\\\x{hh}`."

msgid "Works with decoding and translating."
msgstr "Arbetar med avkodning och översättning."

msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding within :"
"term:`text encoding` only)."
msgstr ""
"Implementerar felhanteringen ``'xmlcharrefreplace'`` (endast för kodning "
"inom :term:`textkodning`)."

msgid ""
"The unencodable character is replaced by an appropriate XML/HTML numeric "
"character reference, which is a decimal form of Unicode code point with "
"format :samp:`&#{num};` ."
msgstr ""
"Det icke-kodbara tecknet ersätts av en lämplig XML/HTML numerisk "
"teckenreferens, som är en decimalform av Unicode-kodpunkt med formatet :samp:"
"`&#{num};` ."

msgid ""
"Implements the ``'namereplace'`` error handling (for encoding within :term:"
"`text encoding` only)."
msgstr ""
"Implementerar felhanteringen ``'namereplace'`` (endast för kodning inom :"
"term:`textkodning`)."

msgid ""
"The unencodable character is replaced by a ``\\N{...}`` escape sequence. The "
"set of characters that appear in the braces is the Name property from "
"Unicode Character Database. For example, the German lowercase letter ``'ß'`` "
"will be converted to byte sequence ``\\N{LATIN SMALL LETTER SHARP S}`` ."
msgstr ""
"Det icke-kodbara tecknet ersätts av en ``N{...}`` escape-sekvens. "
"Uppsättningen av tecken som visas inom hakparenteserna är egenskapen Name "
"från Unicode Character Database. Till exempel kommer den tyska gemena "
"bokstaven ``'ß'`` att konverteras till byte-sekvensen ``\\N{LATIN SMALL "
"LETTER SHARP S}`` ."

msgid "Stateless Encoding and Decoding"
msgstr "Statlös kodning och avkodning"

msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr ""
"Basklassen :class:`Kodek` definierar dessa metoder som också definierar "
"funktionsgränssnitten för den statslösa kodaren och avkodaren:"

msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a "
"bytes object using a particular character set encoding (e.g., ``cp1252`` or "
"``iso-8859-1``)."
msgstr ""
"Kodar objektet *input* och returnerar en tupel (utgångsobjekt, förbrukad "
"längd). Till exempel :term:`text encoding` konverterar ett strängobjekt till "
"ett bytesobjekt med hjälp av en viss teckenuppsättningskodning (t.ex. "
"``cp1252`` eller ``iso-8859-1``)."

msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr ""
"Argumentet *errors* definierar vilken felhantering som ska tillämpas. "
"Standardinställningen är ``'strict'`` hantering."

msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamWriter` for codecs which have to keep state in order to make encoding "
"efficient."
msgstr ""
"Metoden får inte lagra tillstånd i :class:`Kodek`-instansen. Använd :class:"
"`StreamWriter` för kodekar som måste behålla tillstånd för att göra "
"kodningen effektiv."

msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"Kodaren måste kunna hantera inmatning med noll längd och returnera ett tomt "
"objekt av typen output-objekt i denna situation."

msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""
"Avkodar objektet *input* och returnerar en tupel (utgångsobjekt, förbrukad "
"längd). Till exempel, för en :term:`text encoding`, omvandlar decoding ett "
"bytes-objekt som kodats med en viss teckenuppsättningskodning till ett "
"strängobjekt."

msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object "
"or one which provides the read-only buffer interface -- for example, buffer "
"objects and memory mapped files."
msgstr ""
"För textkodningar och bytes-till-bytes-kodekar måste *input* vara ett bytes-"
"objekt eller ett objekt som tillhandahåller gränssnittet för skrivskyddade "
"buffertar - t.ex. buffertobjekt och minnesmappade filer."

msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamReader` for codecs which have to keep state in order to make decoding "
"efficient."
msgstr ""
"Metoden får inte lagra tillstånd i :class:`Kodek`-instansen. Använd :class:"
"`StreamReader` för kodekar som måste behålla tillstånd för att göra "
"avkodningen effektiv."

msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"Avkodaren måste kunna hantera inmatning med noll längd och returnera ett "
"tomt objekt av typen output-objekt i denna situation."

msgid "Incremental Encoding and Decoding"
msgstr "Inkrementell kodning och avkodning"

msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. Encoding/"
"decoding the input isn't done with one call to the stateless encoder/decoder "
"function, but with multiple calls to the :meth:`~IncrementalEncoder.encode`/:"
"meth:`~IncrementalDecoder.decode` method of the incremental encoder/decoder. "
"The incremental encoder/decoder keeps track of the encoding/decoding process "
"during method calls."
msgstr ""
"Klasserna :class:`IncrementalEncoder` och :class:`IncrementalDecoder` "
"tillhandahåller det grundläggande gränssnittet för inkrementell kodning och "
"avkodning. Kodning/avkodning av indata görs inte med ett anrop till den "
"statslösa kodar/avkodarfunktionen, utan med flera anrop till :meth:"
"`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode`-metoden för "
"den inkrementella kodaren/avkodaren. Den inkrementella kodaren/avkodaren "
"håller reda på kodnings-/avkodningsprocessen under metodanropen."

msgid ""
"The joined output of calls to the :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` method is the same as if all the single inputs "
"were joined into one, and this input was encoded/decoded with the stateless "
"encoder/decoder."
msgstr ""
"Det sammanfogade resultatet av anrop till metoden :meth:`~IncrementalEncoder."
"encode`/:meth:`~IncrementalDecoder.decode` är detsamma som om alla enskilda "
"indata hade sammanfogats till ett, och detta indata hade kodats/avkodats med "
"den statslösa kodaren/avkodaren."

msgid "IncrementalEncoder Objects"
msgstr "Objekt för inkrementell kodare"

msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec registry."
msgstr ""
"Klassen :class:`IncrementalEncoder` används för att koda en inmatning i "
"flera steg. Den definierar följande metoder som varje inkrementell kodare "
"måste definiera för att vara kompatibel med Pythons kodek-register."

msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr "Konstruktör för en instans av :class:`IncrementalEncoder`."

msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Alla inkrementella kodare måste tillhandahålla detta konstruktörsgränssnitt. "
"De är fria att lägga till ytterligare nyckelordsargument, men endast de som "
"definieras här används av Pythons kodek-register."

msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalEncoder` kan implementera olika felhanteringssystem genom "
"att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-handlers` "
"för möjliga värden."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalEncoder` object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`IncrementalEncoder`-objektets livstid."

msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to :meth:"
"`encode` *final* must be true (the default is false)."
msgstr ""
"Kodar *objekt* (med hänsyn tagen till kodarens aktuella tillstånd) och "
"returnerar det resulterande kodade objektet. Om detta är det sista anropet "
"till :meth:`encode` måste *final* vara true (standard är false)."

msgid ""
"Reset the encoder to the initial state. The output is discarded: call ``."
"encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""
"Återställ kodaren till det ursprungliga tillståndet. Utdata kastas: anropa "
"``.encode(object, final=True)``, och skicka en tom byte- eller textsträng om "
"det behövs, för att återställa kodaren och få utdata."

msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States "
"that are more complicated than integers can be converted into an integer by "
"marshaling/pickling the state and encoding the bytes of the resulting string "
"into an integer.)"
msgstr ""
"Returnerar det aktuella tillståndet för kodaren som måste vara ett heltal. "
"Implementationen bör se till att ```0`` är det vanligaste tillståndet. "
"(Tillstånd som är mer komplicerade än heltal kan konverteras till ett heltal "
"genom att marshala/pickla tillståndet och koda bytena i den resulterande "
"strängen till ett heltal)"

msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr ""
"Ställ in kodarens tillstånd till *state*. *state* måste vara ett "
"kodartillstånd som returneras av :meth:`getstate`."

msgid "IncrementalDecoder Objects"
msgstr "IncrementalDecoder Objekt"

msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec registry."
msgstr ""
"Klassen :class:`IncrementalDecoder` används för att avkoda en indata i flera "
"steg. Den definierar följande metoder som varje inkrementell avkodare måste "
"definiera för att vara kompatibel med Pythons kodek-register."

msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr "Konstruktör för en instans av :class:`IncrementalDecoder`."

msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Alla inkrementella avkodare måste tillhandahålla detta "
"konstruktörsgränssnitt. Det står dem fritt att lägga till ytterligare "
"nyckelordsargument, men endast de som definieras här används av Pythons "
"kodek-register."

msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalDecoder` kan implementera olika felhanteringssystem genom "
"att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-handlers` "
"för möjliga värden."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalDecoder` object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`IncrementalDecoder`-objektets livstid."

msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to :meth:"
"`decode` *final* must be true (the default is false). If *final* is true the "
"decoder must decode the input completely and must flush all buffers. If this "
"isn't possible (e.g. because of incomplete byte sequences at the end of the "
"input) it must initiate error handling just like in the stateless case "
"(which might raise an exception)."
msgstr ""
"Avkodar *objekt* (med hänsyn tagen till avkodarens aktuella tillstånd) och "
"returnerar det avkodade objektet. Om detta är det sista anropet till :meth:"
"`decode` måste *final* vara true (standardvärdet är false). Om *final* är "
"true måste avkodaren avkoda indata helt och hållet och tömma alla buffertar. "
"Om detta inte är möjligt (t.ex. på grund av ofullständiga byte-sekvenser i "
"slutet av indata) måste den initiera felhantering precis som i det statslösa "
"fallet (vilket kan leda till ett undantag)."

msgid "Reset the decoder to the initial state."
msgstr "Återställer dekodern till utgångsläget."

msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""
"Returnerar avkodarens aktuella tillstånd. Detta måste vara en tupel med två "
"poster, den första måste vara bufferten som innehåller den fortfarande "
"oavkodade inmatningen. Den andra måste vara ett heltal och kan vara "
"ytterligare tillståndsinformation. (Implementationen bör se till att ``0`` "
"är den vanligaste ytterligare tillståndsinformationen) Om denna ytterligare "
"tillståndsinformation är ``0`` måste det vara möjligt att ställa in "
"avkodaren till det tillstånd som inte har någon buffrad indata och ``0`` som "
"ytterligare tillståndsinformation, så att matning av den tidigare buffrade "
"indata till avkodaren återför den till föregående tillstånd utan att "
"producera någon utdata. (Ytterligare tillståndsinformation som är mer "
"komplicerad än heltal kan konverteras till ett heltal genom att marshala/"
"pickla informationen och koda bytena i den resulterande strängen till ett "
"heltal)"

msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr ""
"Ställ in avkodarens tillstånd till *state*. *state* måste vara ett "
"avkodartillstånd som returneras av :meth:`getstate`."

msgid "Stream Encoding and Decoding"
msgstr "Kodning och avkodning av strömmar"

msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`!encodings.utf_8` for an example of how this is done."
msgstr ""
"Klasserna :class:`StreamWriter` och :class:`StreamReader` tillhandahåller "
"generiska arbetsgränssnitt som kan användas för att implementera nya "
"kodningsundermoduler mycket enkelt. Se :mod:`!encodings.utf_8` för ett "
"exempel på hur detta görs."

msgid "StreamWriter Objects"
msgstr "StreamWriter-objekt"

msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Klassen :class:`StreamWriter` är en underklass till :class:`Kodek` och "
"definierar följande metoder som alla streamwriters måste definiera för att "
"vara kompatibla med Pythons kodek-register."

msgid "Constructor for a :class:`StreamWriter` instance."
msgstr "Konstruktör för en :class:`StreamWriter`-instans."

msgid ""
"All stream writers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Alla strömskrivare måste tillhandahålla detta konstruktörsgränssnitt. De är "
"fria att lägga till ytterligare nyckelordsargument, men endast de som "
"definieras här används av Pythons kodek-register."

msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Argumentet *stream* måste vara ett filliknande objekt som är öppet för att "
"skriva text eller binära data, beroende på vad som är lämpligt för den "
"specifika kodeken."

msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"Klassen :class:`StreamWriter` kan implementera olika felhanteringssystem "
"genom att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-"
"handlers` för de standardfelhanterare som den underliggande stream-kodek kan "
"stödja."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`StreamWriter`-objektets livstid."

msgid "Writes the object's contents encoded to the stream."
msgstr "Skriver objektets innehåll kodat till strömmen."

msgid ""
"Writes the concatenated iterable of strings to the stream (possibly by "
"reusing the :meth:`write` method). Infinite or very large iterables are not "
"supported. The standard bytes-to-bytes codecs do not support this method."
msgstr ""
"Skriver den konkatenerade iterationen av strängar till strömmen (eventuellt "
"genom att återanvända metoden :meth:`write`). Oändliga eller mycket stora "
"iterabler stöds inte. De vanliga bytes-till-bytes-kodekerna stöder inte "
"denna metod."

msgid "Resets the codec buffers used for keeping internal state."
msgstr ""
"Återställer kodek-buffertarna som används för att hålla internt tillstånd."

msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan "
"the whole stream to recover state."
msgstr ""
"Genom att anropa den här metoden kan man säkerställa att data på utdatasidan "
"försätts i ett rent tillstånd som gör det möjligt att lägga till nya data "
"utan att behöva skanna om hela flödet till ett återställt tillstånd."

msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Förutom ovanstående metoder måste :class:`StreamWriter` också ärva alla "
"andra metoder och attribut från den underliggande strömmen."

msgid "StreamReader Objects"
msgstr "StreamReader-objekt"

msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Klassen :class:`StreamReader` är en underklass till :class:`Kodek` och "
"definierar följande metoder som varje strömläsare måste definiera för att "
"vara kompatibel med Pythons kodek-register."

msgid "Constructor for a :class:`StreamReader` instance."
msgstr "Konstruktor för en :class:`StreamReader`-instans."

msgid ""
"All stream readers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Alla strömläsare måste tillhandahålla detta konstruktörsgränssnitt. De är "
"fria att lägga till ytterligare nyckelordsargument, men endast de som "
"definieras här används av Pythons kodek-register."

msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Argumentet *stream* måste vara ett filliknande objekt som är öppet för "
"läsning av text eller binära data, beroende på vad som är lämpligt för den "
"specifika kodeken."

msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"Klassen :class:`StreamReader` kan implementera olika felhanteringssystem "
"genom att tillhandahålla nyckelordsargumentet *errors*. Se :ref:`error-"
"handlers` för de standardfelhanterare som den underliggande stream-kodek kan "
"stödja."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr ""
"Argumentet *errors* kommer att tilldelas ett attribut med samma namn. Genom "
"att tilldela detta attribut blir det möjligt att växla mellan olika "
"felhanteringsstrategier under :class:`StreamReader`-objektets livstid."

msgid ""
"The set of allowed values for the *errors* argument can be extended with :"
"func:`register_error`."
msgstr ""
"Uppsättningen av tillåtna värden för argumentet *errors* kan utökas med :"
"func:`register_error`."

msgid "Decodes data from the stream and returns the resulting object."
msgstr "Avkodar data från strömmen och returnerar det resulterande objektet."

msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to "
"return. The :func:`read` method will never return more data than requested, "
"but it might return less, if there is not enough available."
msgstr ""
"Argumentet *chars* anger antalet avkodade kodpunkter eller byte som ska "
"returneras. Metoden :func:`read` kommer aldrig att returnera mer data än vad "
"som begärts, men den kan returnera mindre om det inte finns tillräckligt med "
"data tillgängligt."

msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as "
"much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""
"Argumentet *size* anger det ungefärliga maximala antalet kodade bytes eller "
"kodpunkter som ska läsas för avkodning. Avkodaren kan ändra denna "
"inställning på lämpligt sätt. Standardvärdet -1 anger att så mycket som "
"möjligt ska läsas och avkodas. Denna parameter är avsedd att förhindra att "
"stora filer måste avkodas i ett steg."

msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr ""
"Flaggan *firstline* anger att det skulle räcka att bara returnera den första "
"raden om det finns avkodningsfel på senare rader."

msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""
"Metoden bör använda en girig lässtrategi, vilket innebär att den bör läsa så "
"mycket data som tillåts inom definitionen av kodningen och den givna "
"storleken, t.ex. om valfria kodningsändelser eller tillståndsmarkörer finns "
"tillgängliga i strömmen, bör dessa också läsas."

msgid "Read one line from the input stream and return the decoded data."
msgstr "Läs en rad från inmatningsflödet och returnera de avkodade data."

msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr ""
"*size*, om den anges, skickas som size-argument till strömningens :meth:"
"`read`-metod."

msgid ""
"If *keepends* is false line-endings will be stripped from the lines returned."
msgstr ""
"Om *keepends* är false kommer radavslut att tas bort från de returnerade "
"raderna."

msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr ""
"Läs alla tillgängliga rader i inmatningsströmmen och returnera dem som en "
"lista med rader."

msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are "
"included in the list entries if *keepends* is true."
msgstr ""
"Radavslut implementeras med hjälp av kodek:ens metod :meth:`decode` och "
"inkluderas i listans poster om *keepends* är true."

msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's :meth:"
"`read` method."
msgstr ""
"*sizehint*, om den anges, skickas som argumentet *size* till strömningens "
"metod :meth:`read`."

msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr ""
"Observera att ingen ompositionering av strömmen ska ske. Denna metod är "
"främst avsedd för att kunna återhämta sig efter avkodningsfel."

msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Förutom ovanstående metoder måste :class:`StreamReader` också ärva alla "
"andra metoder och attribut från den underliggande strömmen."

msgid "StreamReaderWriter Objects"
msgstr "StreamReaderWriter-objekt"

msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ""
":class:`StreamReaderWriter` är en bekvämlighetsklass som gör det möjligt att "
"paketera strömmar som fungerar i både läs- och skrivläge."

msgid ""
"The design is such that one can use the factory functions returned by the :"
"func:`lookup` function to construct the instance."
msgstr ""
"Designen är sådan att man kan använda de fabriksfunktioner som returneras "
"av :func:`lookup`-funktionen för att konstruera instansen."

msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like "
"object. *Reader* and *Writer* must be factory functions or classes providing "
"the :class:`StreamReader` and :class:`StreamWriter` interface resp. Error "
"handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"Skapar en instans av :class:`StreamReaderWriter`. *stream* måste vara ett "
"filliknande objekt. *Reader* och *Writer* måste vara fabriksfunktioner eller "
"klasser som tillhandahåller gränssnittet :class:`StreamReader` respektive :"
"class:`StreamWriter`. Felhantering sker på samma sätt som definierats för "
"stream-läsare och -skrivare."

msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of :"
"class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
":class:`StreamReaderWriter`-instanser definierar de kombinerade gränssnitten "
"för klasserna :class:`StreamReader` och :class:`StreamWriter`. De ärver alla "
"andra metoder och attribut från den underliggande strömmen."

msgid "StreamRecoder Objects"
msgstr "StreamRecoder-objekt"

msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr ""
":class:`StreamRecoder` översätter data från en kodning till en annan, vilket "
"ibland är användbart när man har att göra med olika kodningsmiljöer."

msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to "
"code calling :meth:`~StreamReader.read` and :meth:`~StreamWriter.write`, "
"while *Reader* and *Writer* work on the backend — the data in *stream*."
msgstr ""
"Skapar en :class:`StreamRecoder`-instans som implementerar en "
"tvåvägskonvertering: *encode* och *decode* arbetar på frontend - data som är "
"synlig för kod som anropar :meth:`~StreamReader.read` och :meth:"
"`~StreamWriter.write`, medan *Reader* och *Writer* arbetar på backend - data "
"i *stream*."

msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1 "
"to UTF-8 and back."
msgstr ""
"Du kan använda dessa objekt för att göra transparenta omkodningar, t.ex. "
"från Latin-1 till UTF-8 och tillbaka."

msgid "The *stream* argument must be a file-like object."
msgstr "Argumentet *stream* måste vara ett filliknande objekt."

msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""
"Argumenten *encode* och *decode* måste följa gränssnittet :class:`Kodek`. "
"*Reader* och *Writer* måste vara fabriksfunktioner eller klasser som "
"tillhandahåller objekt av gränssnittet :class:`StreamReader` respektive :"
"class:`StreamWriter`."

msgid ""
"Error handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"Felhanteringen sker på samma sätt som definierats för strömläsare och "
"strömskrivare."

msgid ""
":class:`StreamRecoder` instances define the combined interfaces of :class:"
"`StreamReader` and :class:`StreamWriter` classes. They inherit all other "
"methods and attributes from the underlying stream."
msgstr ""
":class:`StreamRecoder`-instanser definierar de kombinerade gränssnitten för "
"klasserna :class:`StreamReader` och :class:`StreamWriter`. De ärver alla "
"andra metoder och attribut från den underliggande strömmen."

msgid "Encodings and Unicode"
msgstr "Kodningar och Unicode"

msgid ""
"Strings are stored internally as sequences of code points in range "
"``U+0000``--``U+10FFFF``. (See :pep:`393` for more details about the "
"implementation.) Once a string object is used outside of CPU and memory, "
"endianness and how these arrays are stored as bytes become an issue. As with "
"other codecs, serialising a string into a sequence of bytes is known as "
"*encoding*, and recreating the string from the sequence of bytes is known as "
"*decoding*. There are a variety of different text serialisation codecs, "
"which are collectivity referred to as :term:`text encodings <text encoding>`."
msgstr ""
"Strängar lagras internt som sekvenser av kodpunkter i intervallet "
"``U+0000``--``U+10FFFF``. (Se :pep:`393` för mer information om "
"implementeringen.) När ett strängobjekt används utanför CPU och minne blir "
"endianness och hur dessa arrayer lagras som byte ett problem. Precis som med "
"andra kodekar kallas serialisering av en sträng till en sekvens av byte för "
"*encoding* och återskapande av strängen från sekvensen av byte för "
"*decoding*. Det finns en mängd olika kodekar för textserialisering, som "
"kollektivt kallas :term:`text encodings <text encoding>`."

msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""
"Den enklaste textkodningen (kallad ``'latin-1'`` eller ``'iso-8859-1'``) "
"mappar kodpunkterna 0--255 till bytena ``0x0``--``0xff``, vilket innebär att "
"ett strängobjekt som innehåller kodpunkter över ``U+00FF`` inte kan kodas "
"med denna kodek. Om du gör det kommer ett :exc:`UnicodeEncodeError` att "
"uppstå som ser ut som följande (även om detaljerna i felmeddelandet kan "
"skilja sig åt): ``UnicodeEncodeError: 'latin-1' kodek kan inte koda tecknet "
"'\\u1234' i position 3: ordinal not in range(256)```."

msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""
"Det finns en annan grupp av kodningar (de s.k. charmap-kodningarna) som "
"väljer en annan delmängd av alla Unicode-kodpunkter och hur dessa kodpunkter "
"mappas till bytena ``0x0``--``0xff``. För att se hur detta görs är det bara "
"att öppna t.ex. :file:`encodings/cp1252.py` (som är en kodning som används "
"främst på Windows). Där finns en strängkonstant med 256 tecken som visar "
"vilket tecken som är mappat till vilket bytevärde."

msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE`` "
"respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a "
"little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of "
"a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte "
"Order Mark\"). This is the Unicode character ``U+FEFF``. This character can "
"be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in a "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a "
"second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO "
"WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine "
"the storage layout of the encoded bytes, and vanishes once the byte sequence "
"has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` it's a "
"normal character that will be decoded like any other."
msgstr ""
"Alla dessa kodningar kan bara koda 256 av de 1114112 kodpunkter som "
"definieras i Unicode. Ett enkelt och okomplicerat sätt att lagra varje "
"Unicode-kodpunkt är att lagra varje kodpunkt som fyra på varandra följande "
"byte. Det finns två möjligheter: lagra bytena i big endian- eller little "
"endian-ordning. Dessa två kodningar kallas ``UTF-32-BE`` respektive ``UTF-32-"
"LE``. Nackdelen med dem är att om man t.ex. använder ``UTF-32-BE`` på en "
"little endian-maskin måste man alltid byta byte vid kodning och avkodning. "
"``UTF-32`` undviker detta problem: byte kommer alltid att vara i naturlig "
"endian. När dessa byte läses av en CPU med en annan endianness, måste byte "
"dock bytas ut. För att kunna upptäcka endianness för en ``UTF-16`` eller "
"``UTF-32`` byte-sekvens, finns det så kallade BOM (\"Byte Order Mark\"). "
"Detta är Unicode-tecknet ``U+FEFF``. Detta tecken kan prependlas till varje "
"``UTF-16`` eller ``UTF-32`` byte-sekvens. Den byteväxlade versionen av detta "
"tecken (``0xFFFE``) är ett olagligt tecken som inte får förekomma i en "
"Unicode-text. Så när det första tecknet i en ``UTF-16`` eller ``UTF-32`` "
"byte-sekvens ser ut att vara en ``U+FFFE`` måste bytena bytas vid "
"avkodningen. Tyvärr hade tecknet ``U+FEFF`` ett andra syfte som ett ``ZERO "
"WIDTH NO-BREAK SPACE``: ett tecken som inte har någon bredd och inte "
"tillåter att ett ord delas upp. Det kan t.ex. användas för att ge ledtrådar "
"till en ligaturalgoritm. Med Unicode 4.0 har användningen av ``U+FEFF`` som "
"ett ``ZERO WIDTH NO-BREAK SPACE`` utgått (med ``U+2060`` (``WORD JOINER``) "
"som tar över denna roll). Unicode-programvara måste dock fortfarande kunna "
"hantera ``U+FEFF`` i båda rollerna: som BOM är det en enhet för att bestämma "
"lagringslayouten för de kodade byte, och försvinner när byte-sekvensen har "
"avkodats till en sträng; som ``ZERO WIDTH NO-BREAK SPACE`` är det ett "
"normalt tecken som kommer att avkodas som alla andra."

msgid ""
"There's another encoding that is able to encode the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists "
"of two parts: marker bits (the most significant bits) and payload bits. The "
"marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""
"Det finns en annan kodning som kan koda hela utbudet av Unicode-tecken: "
"UTF-8. UTF-8 är en 8-bitars kodning, vilket innebär att det inte finns några "
"problem med byteordningen i UTF-8. Varje byte i en UTF-8-bytessekvens består "
"av två delar: markörbitar (de mest signifikanta bitarna) och nyttolastbitar. "
"Markörbitarna är en sekvens av noll till fyra ``1``-bitar följt av en ``0``-"
"bit. Unicode-tecken kodas så här (x är payload-bitar, som när de "
"sammankopplas ger Unicode-tecknet):"

msgid "Range"
msgstr "Intervall"

msgid "Encoding"
msgstr "Avkodning"

msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

msgid "0xxxxxxx"
msgstr "0xxxxxxx"

msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx"

msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr ""
"Den minst signifikanta biten i Unicode-tecknet är den längst till höger "
"liggande x-biten."

msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""
"Eftersom UTF-8 är en 8-bitars kodning krävs ingen BOM och varje ``U+FEFF``-"
"tecken i den avkodade strängen (även om det är det första tecknet) behandlas "
"som ett ``ZERO WIDTH NO-BREAK SPACE``."

msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences. "
"To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python calls ``\"utf-8-sig\"``) "
"for its Notepad program: Before any of the Unicode characters is written to "
"the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: "
"``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any "
"charmap encoded file starts with these byte values (which would e.g. map to"
msgstr ""
"Utan extern information är det omöjligt att på ett tillförlitligt sätt "
"avgöra vilken kodning som användes för att koda en sträng. Varje charmap-"
"kodning kan avkoda vilken slumpmässig byte-sekvens som helst. Det är dock "
"inte möjligt med UTF-8, eftersom UTF-8-bytessekvenser har en struktur som "
"inte tillåter godtyckliga bytessekvenser. För att öka tillförlitligheten med "
"vilken en UTF-8-kodning kan upptäckas uppfann Microsoft en variant av UTF-8 "
"(som Python kallar ``\"utf-8-sig\"``) för sitt Notepad-program: Innan något "
"av Unicode-tecknen skrivs till filen, skrivs en UTF-8-kodad BOM (som ser ut "
"så här som en byte-sekvens: ``0xef``, ``0xbb``, ``0xbf``). Eftersom det är "
"ganska osannolikt att någon charmap-kodad fil börjar med dessa bytevärden "
"(som t.ex. skulle motsvara"

msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "LATINSKA LILLA BOKSTAVEN I MED DIACERESE"

msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "HÖGERPEKANDE DUBBELVINKELCITATIONSTECKEN"

msgid "INVERTED QUESTION MARK"
msgstr "INVERTERAT FRÅGETECKEN"

msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding "
"can be correctly guessed from the byte sequence. So here the BOM is not used "
"to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""
"i iso-8859-1), ökar detta sannolikheten för att en ``utf-8-sig``-kodning kan "
"gissas korrekt från byte-sekvensen. Här används alltså inte BOM för att "
"avgöra vilken byteordning som använts för att generera byte-sekvensen, utan "
"som en signatur som hjälper till att gissa kodningen. Vid kodning skriver "
"utf-8-sig-kodek ``0xef``, ``0xbb``, ``0xbf`` som de tre första bytena till "
"filen. Vid avkodning kommer ``utf-8-sig`` att hoppa över dessa tre byte om "
"de förekommer som de tre första byte i filen. I UTF-8 är användningen av BOM "
"avrådd och bör i allmänhet undvikas."

msgid "Standard Encodings"
msgstr "Standardkodningar"

msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases because they are equivalent when "
"normalized by :func:`~encodings.normalize_encoding`. For example, "
"``'utf-8'`` is a valid alias for the ``'utf_8'`` codec."
msgstr ""
"Python kommer med ett antal inbyggda kodekar, antingen implementerade som C-"
"funktioner eller med lexikon som mappningstabeller. I följande tabell listas "
"kodekar med namn, tillsammans med några vanliga alias och de språk som "
"kodningen sannolikt används för. Varken listan över alias eller listan över "
"språk är avsedd att vara uttömmande. Observera att stavningsalternativ som "
"endast skiljer sig åt i versaler eller använder bindestreck istället för "
"understreck också är giltiga alias eftersom de är likvärdiga när de "
"normaliseras med :func:`~encodings.normalize_encoding`. Till exempel är "
"``'utf-8'`` ett giltigt alias för kodek ``'utf_8'``."

msgid ""
"The below table lists the most common aliases, for a complete list refer to "
"the source :source:`aliases.py <Lib/encodings/aliases.py>` file."
msgstr ""
"I tabellen nedan listas de vanligaste alias, en fullständig lista finns i "
"filen source :source:`aliases.py <Lib/encodings/aliases.py>`."

msgid ""
"On Windows, ``cpXXX`` codecs are available for all code pages. But only "
"codecs listed in the following table are guarantead to exist on other "
"platforms."
msgstr ""
"På Windows finns kodekar av typen ``cpXXX`` tillgängliga för alla kodsidor. "
"Men endast kodekar som anges i följande tabell finns garanterat på andra "
"plattformar."

msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython "
"for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16, "
"utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower execution."
msgstr ""
"Vissa vanliga kodningar kan kringgå kodekar-uppslagningsmaskineriet för att "
"förbättra prestandan. Dessa optimeringsmöjligheter känns bara igen av "
"CPython för en begränsad uppsättning (skiftlägesokänsliga) alias: utf-8, "
"utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (endast Windows), ascii, "
"us-ascii, utf-16, utf16, utf-32, utf32, och samma sak med understreck "
"istället för bindestreck. Om du använder alternativa alias för dessa "
"kodningar kan det leda till långsammare körning."

msgid "Optimization opportunity recognized for us-ascii."
msgstr "Optimeringsmöjlighet erkänd för us-ascii."

msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""
"Många av teckenuppsättningarna stöder samma språk. De varierar i fråga om "
"enskilda tecken (t.ex. om EURO-tecknet stöds eller inte) och i fråga om "
"tilldelningen av tecken till kodpositioner. I synnerhet för de europeiska "
"språken finns normalt följande varianter:"

msgid "an ISO 8859 codeset"
msgstr "en ISO 8859-kodset"

msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr ""
"en Microsoft Windows-kodsida som vanligtvis härrör från en 8859-kod, men som "
"ersätter kontrolltecken med ytterligare grafiska tecken"

msgid "an IBM EBCDIC code page"
msgstr "en IBM EBCDIC-kodsida"

msgid "an IBM PC code page, which is ASCII compatible"
msgstr "en IBM PC-kodsida, som är ASCII-kompatibel"

msgid "Codec"
msgstr "Kodek"

msgid "Aliases"
msgstr "Alias"

msgid "Languages"
msgstr "Språk"

msgid "ascii"
msgstr "ascii"

msgid "646, us-ascii"
msgstr "646, us-ascii"

msgid "English"
msgstr "Engelska"

msgid "big5"
msgstr "big5"

msgid "big5-tw, csbig5"
msgstr "big5-tw, csbig5"

msgid "Traditional Chinese"
msgstr "Traditionell kinesiska"

msgid "big5hkscs"
msgstr "big5hkscs"

msgid "big5-hkscs, hkscs"
msgstr "big5-hkscs, hkscs"

msgid "cp037"
msgstr "cp037"

msgid "IBM037, IBM039"
msgstr "IBM037, IBM039"

msgid "cp273"
msgstr "cp273"

msgid "273, IBM273, csIBM273"
msgstr "273, IBM273, csIBM273"

msgid "German"
msgstr "Tyska"

msgid "cp424"
msgstr "cp424"

msgid "EBCDIC-CP-HE, IBM424"
msgstr "EBCDIC-CP-HE, IBM424"

msgid "Hebrew"
msgstr "Hebreiska"

msgid "cp437"
msgstr "cp437"

msgid "437, IBM437"
msgstr "437, IBM437"

msgid "cp500"
msgstr "cp500"

msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"

msgid "Western Europe"
msgstr "Västeuropa"

msgid "cp720"
msgstr "cp720"

msgid "Arabic"
msgstr "Arabiska"

msgid "cp737"
msgstr "cp737"

msgid "Greek"
msgstr "Grekiska"

msgid "cp775"
msgstr "cp775"

msgid "IBM775"
msgstr "IBM775"

msgid "Baltic languages"
msgstr "Baltiska språk"

msgid "cp850"
msgstr "cp850"

msgid "850, IBM850"
msgstr "850, IBM850"

msgid "cp852"
msgstr "cp852"

msgid "852, IBM852"
msgstr "852, IBM852"

msgid "Central and Eastern Europe"
msgstr "Central- och Östeuropa"

msgid "cp855"
msgstr "cp855"

msgid "855, IBM855"
msgstr "855, IBM855"

msgid "Belarusian, Bulgarian, Macedonian, Russian, Serbian"
msgstr "Vitryska, bulgariska, makedonska, ryska, serbiska"

msgid "cp856"
msgstr "cp856"

msgid "cp857"
msgstr "cp857"

msgid "857, IBM857"
msgstr "857, IBM857"

msgid "Turkish"
msgstr "Turkiska"

msgid "cp858"
msgstr "cp858"

msgid "858, IBM858"
msgstr "858, IBM858"

msgid "cp860"
msgstr "cp860"

msgid "860, IBM860"
msgstr "860, IBM860"

msgid "Portuguese"
msgstr "Portugisiska"

msgid "cp861"
msgstr "cp861"

msgid "861, CP-IS, IBM861"
msgstr "861, CP-IS, IBM861"

msgid "Icelandic"
msgstr "Icelandic"

msgid "cp862"
msgstr "cp862"

msgid "862, IBM862"
msgstr "862, IBM862"

msgid "cp863"
msgstr "cp863"

msgid "863, IBM863"
msgstr "863, IBM863"

msgid "Canadian"
msgstr "Canadian"

msgid "cp864"
msgstr "cp864"

msgid "IBM864"
msgstr "IBM864"

msgid "cp865"
msgstr "cp865"

msgid "865, IBM865"
msgstr "865, IBM865"

msgid "Danish, Norwegian"
msgstr "Danska, Norska"

msgid "cp866"
msgstr "cp866"

msgid "866, IBM866"
msgstr "866, IBM866"

msgid "Russian"
msgstr "Russian"

msgid "cp869"
msgstr "cp869"

msgid "869, CP-GR, IBM869"
msgstr "869, CP-GR, IBM869"

msgid "cp874"
msgstr "cp874"

msgid "Thai"
msgstr "Thai"

msgid "cp875"
msgstr "cp875"

msgid "cp932"
msgstr "cp932"

msgid "932, ms932, mskanji, ms-kanji, windows-31j"
msgstr "932, ms932, mskanji, ms-kanji, windows-31j"

msgid "Japanese"
msgstr "Japanska"

msgid "cp949"
msgstr "cp949"

msgid "949, ms949, uhc"
msgstr "949, ms949, uhc"

msgid "Korean"
msgstr "Koreanska"

msgid "cp950"
msgstr "cp950"

msgid "950, ms950"
msgstr "950, ms950"

msgid "cp1006"
msgstr "cp1006"

msgid "Urdu"
msgstr "Urdu"

msgid "cp1026"
msgstr "cp1026"

msgid "ibm1026"
msgstr "ibm1026"

msgid "cp1125"
msgstr "cp1125"

msgid "1125, ibm1125, cp866u, ruscii"
msgstr "1125, ibm1125, cp866u, ruscii"

msgid "Ukrainian"
msgstr "Ukrainian"

msgid "cp1140"
msgstr "cp1140"

msgid "ibm1140"
msgstr "ibm1140"

msgid "cp1250"
msgstr "cp1250"

msgid "windows-1250"
msgstr "windows-1250"

msgid "cp1251"
msgstr "cp1251"

msgid "windows-1251"
msgstr "windows-1251"

msgid "cp1252"
msgstr "cp1252"

msgid "windows-1252"
msgstr "windows-1252"

msgid "cp1253"
msgstr "cp1253"

msgid "windows-1253"
msgstr "windows-1253"

msgid "cp1254"
msgstr "cp1254"

msgid "windows-1254"
msgstr "windows-1254"

msgid "cp1255"
msgstr "cp1255"

msgid "windows-1255"
msgstr "windows-1255"

msgid "cp1256"
msgstr "cp1256"

msgid "windows-1256"
msgstr "windows-1256"

msgid "cp1257"
msgstr "cp1257"

msgid "windows-1257"
msgstr "windows-1257"

msgid "cp1258"
msgstr "cp1258"

msgid "windows-1258"
msgstr "windows-1258"

msgid "Vietnamese"
msgstr "Vietnamesisk"

msgid "euc_jp"
msgstr "euc_jp"

msgid "eucjp, ujis, u-jis"
msgstr "eucjp, ujis, u-jis"

msgid "euc_jis_2004"
msgstr "euc_jis_2004"

msgid "jisx0213, eucjis2004"
msgstr "jisx0213, eucjis2004"

msgid "euc_jisx0213"
msgstr "euc_jisx0213"

msgid "eucjisx0213"
msgstr "eucjisx0213"

msgid "euc_kr"
msgstr "euc_kr"

msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr ""
"euckr, koreanska, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"

msgid "gb2312"
msgstr "gb2312"

msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"kinesiska, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"

msgid "Simplified Chinese"
msgstr "Förenklad kinesiska"

msgid "gbk"
msgstr "gbk"

msgid "936, cp936, ms936"
msgstr "936, cp936, ms936"

msgid "Unified Chinese"
msgstr "Unifierad kinesiska"

msgid "gb18030"
msgstr "gb18030"

msgid "gb18030-2000"
msgstr "gb18030-2000"

msgid "hz"
msgstr "hz"

msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "hzgb, hz-gb, hz-gb-2312"

msgid "iso2022_jp"
msgstr "iso2022_jp"

msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "csiso2022jp, iso2022jp, iso-2022-jp"

msgid "iso2022_jp_1"
msgstr "iso2022_jp_1"

msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "iso2022jp-1, iso-2022-jp-1"

msgid "iso2022_jp_2"
msgstr "iso2022_jp_2"

msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "iso2022jp-2, iso-2022-jp-2"

msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr "Japanska, koreanska, förenklad kinesiska, Västeuropa, grekiska"

msgid "iso2022_jp_2004"
msgstr "iso2022_jp_2004"

msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "iso2022jp-2004, iso-2022-jp-2004"

msgid "iso2022_jp_3"
msgstr "iso2022_jp_3"

msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "iso2022jp-3, iso-2022-jp-3"

msgid "iso2022_jp_ext"
msgstr "iso2022_jp_ext"

msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "iso2022jp-ext, iso-2022-jp-ext"

msgid "iso2022_kr"
msgstr "iso2022_kr"

msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "csiso2022kr, iso2022kr, iso-2022-kr"

msgid "latin_1"
msgstr "latin_1"

msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"

msgid "iso8859_2"
msgstr "iso8859_2"

msgid "iso-8859-2, latin2, L2"
msgstr "iso-8859-2, latin2, L2"

msgid "iso8859_3"
msgstr "iso8859_3"

msgid "iso-8859-3, latin3, L3"
msgstr "iso-8859-3, latin3, L3"

msgid "Esperanto, Maltese"
msgstr "Esperanto, Maltese"

msgid "iso8859_4"
msgstr "iso8859_4"

msgid "iso-8859-4, latin4, L4"
msgstr "iso-8859-4, latin4, L4"

msgid "iso8859_5"
msgstr "iso8859_5"

msgid "iso-8859-5, cyrillic"
msgstr "iso-8859-5, cyrillic"

msgid "iso8859_6"
msgstr "iso8859_6"

msgid "iso-8859-6, arabic"
msgstr "iso-8859-6, arabic"

msgid "iso8859_7"
msgstr "iso8859_7"

msgid "iso-8859-7, greek, greek8"
msgstr "iso-8859-7, greek, greek8"

msgid "iso8859_8"
msgstr "iso8859_8"

msgid "iso-8859-8, hebrew"
msgstr "iso-8859-8, hebrew"

msgid "iso8859_9"
msgstr "iso8859_9"

msgid "iso-8859-9, latin5, L5"
msgstr "iso-8859-9, latin5, L5"

msgid "iso8859_10"
msgstr "iso8859_10"

msgid "iso-8859-10, latin6, L6"
msgstr "iso-8859-10, latin6, L6"

msgid "Nordic languages"
msgstr "Nordiska språk"

msgid "iso8859_11"
msgstr "iso8859_11"

msgid "iso-8859-11, thai"
msgstr "iso-8859-11, thai"

msgid "Thai languages"
msgstr "Thailändska språk"

msgid "iso8859_13"
msgstr "iso8859_13"

msgid "iso-8859-13, latin7, L7"
msgstr "iso-8859-13, latin7, L7"

msgid "iso8859_14"
msgstr "iso8859_14"

msgid "iso-8859-14, latin8, L8"
msgstr "iso-8859-14, latin8, L8"

msgid "Celtic languages"
msgstr "Keltiska språk"

msgid "iso8859_15"
msgstr "iso8859_15"

msgid "iso-8859-15, latin9, L9"
msgstr "iso-8859-15, latin9, L9"

msgid "iso8859_16"
msgstr "iso8859_16"

msgid "iso-8859-16, latin10, L10"
msgstr "iso-8859-16, latin10, L10"

msgid "South-Eastern Europe"
msgstr "Sydöstra Europa"

msgid "johab"
msgstr "johab"

msgid "cp1361, ms1361"
msgstr "cp1361, ms1361"

msgid "koi8_r"
msgstr "koi8_r"

msgid "koi8_t"
msgstr "koi8_t"

msgid "Tajik"
msgstr "Tadzjikiska"

msgid "koi8_u"
msgstr "koi8_u"

msgid "kz1048"
msgstr "kz1048"

msgid "kz_1048, strk1048_2002, rk1048"
msgstr "kz_1048, strk1048_2002, rk1048"

msgid "Kazakh"
msgstr "Kazakiskt"

msgid "mac_cyrillic"
msgstr "mac_cyrillic"

msgid "maccyrillic"
msgstr "maccyrillic"

msgid "mac_greek"
msgstr "mac_greek"

msgid "macgreek"
msgstr "macgreek"

msgid "mac_iceland"
msgstr "mac_iceland"

msgid "maciceland"
msgstr "maciceland"

msgid "mac_latin2"
msgstr "mac_latin2"

msgid "maclatin2, maccentraleurope, mac_centeuro"
msgstr "maclatin2, maccentraleurope, mac_centeuro"

msgid "mac_roman"
msgstr "mac_roman"

msgid "macroman, macintosh"
msgstr "macroman, macintosh"

msgid "mac_turkish"
msgstr "mac_turkish"

msgid "macturkish"
msgstr "macturkish"

msgid "ptcp154"
msgstr "ptcp154"

msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "csptcp154, pt154, cp154, cyrillic-asian"

msgid "shift_jis"
msgstr "shift_jis"

msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "csshiftjis, shiftjis, sjis, s_jis"

msgid "shift_jis_2004"
msgstr "shift_jis_2004"

msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "shiftjis2004, sjis_2004, sjis2004"

msgid "shift_jisx0213"
msgstr "shift_jisx0213"

msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "shiftjisx0213, sjisx0213, s_jisx0213"

msgid "utf_32"
msgstr "utf_32"

msgid "U32, utf32"
msgstr "U32, utf32"

msgid "all languages"
msgstr "alla språk"

msgid "utf_32_be"
msgstr "utf_32_be"

msgid "UTF-32BE"
msgstr "UTF-32BE"

msgid "utf_32_le"
msgstr "utf_32_le"

msgid "UTF-32LE"
msgstr "UTF-32LE"

msgid "utf_16"
msgstr "utf_16"

msgid "U16, utf16"
msgstr "U16, utf16"

msgid "utf_16_be"
msgstr "utf_16_be"

msgid "UTF-16BE"
msgstr "UTF-16BE"

msgid "utf_16_le"
msgstr "utf_16_le"

msgid "UTF-16LE"
msgstr "UTF-16LE"

msgid "utf_7"
msgstr "utf_7"

msgid "U7, unicode-1-1-utf-7"
msgstr "U7, unicode-1-1-utf-7"

msgid "utf_8"
msgstr "utf_8"

msgid "U8, UTF, utf8, cp65001"
msgstr "U8, UTF, utf8, cp65001"

msgid "utf_8_sig"
msgstr "utf_8_sig"

msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""
"Kodarna utf-16\\* och utf-32\\* tillåter inte längre att surrogatkodpunkter "
"(``U+D800``--``U+DFFF``) kodas. Avkodarna utf-32\\* avkodar inte längre byte-"
"sekvenser som motsvarar surrogatkodpunkter."

msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr "``cp65001`` är nu ett alias till ``utf_8``."

msgid "On Windows, ``cpXXX`` codecs are now available for all code pages."
msgstr ""
"I Windows är kodekar av typen ``cpXXX`` nu tillgängliga för alla kodsidor."

msgid "Python Specific Encodings"
msgstr "Python-specifika kodningar"

msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""
"Ett antal fördefinierade kodekar är specifika för Python, så deras kodek-"
"namn har ingen betydelse utanför Python. Dessa listas i tabellerna nedan "
"baserat på de förväntade in- och utdatatyperna (notera att även om "
"textkodningar är det vanligaste användningsområdet för kodekar, stöder den "
"underliggande kodek-infrastrukturen godtyckliga datatransformationer snarare "
"än bara textkodningar). För asymmetriska kodekar beskriver den angivna "
"betydelsen kodningsriktningen."

msgid "Text Encodings"
msgstr "Kodning av text"

msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and :"
"term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""
"Följande kodekar ger :class:`str` till :class:`bytes`-kodning och :term:"
"`bytes-like object` till :class:`str`-avkodning, på samma sätt som Unicodes "
"textkodning."

msgid "idna"
msgstr "idna"

msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr ""
"Implementera :rfc:`3490`, se även :mod:`encodings.idna`. Endast "
"``errors='strict'`` stöds."

msgid "mbcs"
msgstr "mbcs"

msgid "ansi, dbcs"
msgstr "ansi, dbcs"

msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr "Endast för Windows: Koda operanden enligt ANSI-kodsidan (CP_ACP)."

msgid "oem"
msgstr "original"

msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr "Endast för Windows: Koda operanden enligt OEM-kodsidan (CP_OEMCP)."

msgid "palmos"
msgstr "palmos"

msgid "Encoding of PalmOS 3.5."
msgstr "Kodning av PalmOS 3.5."

msgid "punycode"
msgstr "punycode"

msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr "Implementera :rfc:`3492`. Stateful kodekar stöds inte."

msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

msgid ""
"Latin-1 encoding with :samp:`\\\\u{XXXX}` and :samp:`\\\\U{XXXXXXXX}` for "
"other code points. Existing backslashes are not escaped in any way. It is "
"used in the Python pickle protocol."
msgstr ""
"Latin-1-kodning med :samp:`\\\\u{XXXX}` och :samp:`\\\\U{XXXXXXXX}` för "
"andra kodpunkter. Befintliga backslashes escapas inte på något sätt. Det "
"används i Pythons pickle-protokoll."

msgid "undefined"
msgstr "odefinerad"

msgid "This Codec should only be used for testing purposes."
msgstr "Denna kodek bör endast användas för teständamål."

msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr ""
"Utlös ett undantag för alla konverteringar, även tomma strängar. "
"Felhanteraren ignoreras."

msgid "unicode_escape"
msgstr "unicode_escape"

msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""
"Kodning lämplig som innehållet i en Unicode-litteral i ASCII-kodad Python-"
"källkod, förutom att citattecken inte escapas. Avkodning från Latin-1-"
"källkod. Tänk på att Python-källkod faktiskt använder UTF-8 som standard."

msgid "\"unicode_internal\" codec is removed."
msgstr "kodek \"unicode_internal\" har tagits bort."

msgid "Binary Transforms"
msgstr "Binära transformationer"

msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` "
"to :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""
"Följande kodekar tillhandahåller binära transformationer: :term:`bytes-like "
"object` till :class:`bytes` mappningar. De stöds inte av :meth:`bytes."
"decode` (som endast producerar :class:`str` utdata)."

msgid "Encoder / decoder"
msgstr "Kodare / avkodare"

msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

msgid "base64, base_64"
msgstr "base64, base_64"

msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr ""
"Konverterar operanden till multiline MIME base64 (resultatet innehåller "
"alltid en efterföljande ``'\\n'``)."

msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr ""
"accepterar alla :term:`bytes-like object` som indata för kodning och "
"avkodning"

msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"

msgid "bz2_codec"
msgstr "bz2_codec"

msgid "bz2"
msgstr "bz2"

msgid "Compress the operand using bz2."
msgstr "Komprimera operanden med hjälp av bz2."

msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ":meth:`bz2.compress` / :meth:`bz2.decompress`"

msgid "hex_codec"
msgstr "hex_codec"

msgid "hex"
msgstr "hex"

msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr ""
"Konvertera operanden till hexadecimal representation, med två siffror per "
"byte."

msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"

msgid "quopri_codec"
msgstr "quopri_codec"

msgid "quopri, quotedprintable, quoted_printable"
msgstr "quopri, citerat tryckbart, citerat_tryckbart"

msgid "Convert the operand to MIME quoted printable."
msgstr "Konvertera operanden till MIME quoted printable."

msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ":meth:`quopri.encode` med ``quotetabs=True`` / :meth:`quopri.decode`"

msgid "uu_codec"
msgstr "uu_codec"

msgid "uu"
msgstr "uu"

msgid "Convert the operand using uuencode."
msgstr "Konvertera operanden med hjälp av uuencode."

msgid "zlib_codec"
msgstr "zlib_codec"

msgid "zip, zlib"
msgstr "zip, zlib"

msgid "Compress the operand using gzip."
msgstr "Komprimera operanden med hjälp av gzip."

msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""
"Förutom :term:`bytesliknande objekt <bytes-like object>` accepterar "
"``'base64_codec'`` även ASCII-instanser av :class:`str` för avkodning"

msgid "Restoration of the binary transforms."
msgstr "Återställning av de binära transformationerna."

msgid "Restoration of the aliases for the binary transforms."
msgstr "Återställande av alias för de binära transformationerna."

msgid "Text Transforms"
msgstr "Text omvandlas"

msgid ""
"The following codec provides a text transform: a :class:`str` to :class:"
"`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""
"Följande kodek tillhandahåller en texttransformation: en mappning från :"
"class:`str` till :class:`str`. Den stöds inte av :meth:`str.encode` (som "
"bara producerar :class:`bytes`)."

msgid "rot_13"
msgstr "rot_13"

msgid "rot13"
msgstr "rot13"

msgid "Return the Caesar-cypher encryption of the operand."
msgstr "Returnerar Caesar-cypherkrypteringen av operanden."

msgid "Restoration of the ``rot_13`` text transform."
msgstr "Återställande av textomvandlingen ``rot_13``."

msgid "Restoration of the ``rot13`` alias."
msgstr "Återskapande av aliaset ``rot13``."

msgid ":mod:`encodings` --- Encodings package"
msgstr ":mod:`encodings` --- Paket för kodning"

msgid "This module implements the following functions:"
msgstr "Denna modul implementerar följande funktioner:"

msgid "Normalize encoding name *encoding*."
msgstr "Normalisera kodningsnamnet *encoding*."

msgid ""
"Normalization works as follows: all non-alphanumeric characters except the "
"dot used for Python package names are collapsed and replaced with a single "
"underscore, leading and trailing underscores are removed. For example, ``'  "
"-;#'`` becomes ``'_'``."
msgstr ""
"Normalisering fungerar på följande sätt: alla icke-alfanumeriska tecken utom "
"punkten som används för Python-paketnamn kollapsar och ersätts med ett enda "
"understreck, ledande och efterföljande understreck tas bort. Till exempel, "
"``' -;#'`` blir ``'_'``."

msgid "Note that *encoding* should be ASCII only."
msgstr "Observera att *kodning* endast ska vara ASCII."

msgid ""
"The following functions should not be used directly, except for testing "
"purposes; :func:`codecs.lookup` should be used instead."
msgstr ""
"Följande funktioner bör inte användas direkt, förutom för teständamål; :func:"
"`kodekar.lookup` bör användas istället."

msgid ""
"Search for the codec module corresponding to the given encoding name "
"*encoding*."
msgstr ""
"Sök efter den kodek-modul som motsvarar det angivna kodningsnamnet "
"*encoding*."

msgid ""
"This function first normalizes the *encoding* using :func:"
"`normalize_encoding`, then looks for a corresponding alias. It attempts to "
"import a codec module from the encodings package using either the alias or "
"the normalized name. If the module is found and defines a valid "
"``getregentry()`` function that returns a :class:`codecs.CodecInfo` object, "
"the codec is cached and returned."
msgstr ""
"Den här funktionen normaliserar först *kodningen* med :func:"
"`normalize_encoding` och letar sedan efter ett motsvarande alias. Den "
"försöker importera en kodek-modul från encodings-paketet med hjälp av "
"antingen aliaset eller det normaliserade namnet. Om modulen hittas och "
"definierar en giltig ``getregentry()``-funktion som returnerar ett :class:"
"`kodekar.KodekInfo`-objekt, cachelagras kodeken och returneras."

msgid ""
"If the codec module defines a ``getaliases()`` function any returned aliases "
"are registered for future use."
msgstr ""
"Om kodek-modulen definierar en ``getaliases()``-funktion registreras alla "
"returnerade alias för framtida användning."

msgid ""
"Search for a Windows code page encoding *encoding* of the form ``cpXXXX``."
msgstr "Sök efter en Windows-kodsideskodning *encoding* av formen ``cpXXXX``."

msgid ""
"If the code page is valid and supported, return a :class:`codecs.CodecInfo` "
"object for it."
msgstr ""
"Om kodsidan är giltig och stöds, returneras ett :class:`kodekar.KodekInfo`-"
"objekt för den."

msgid "Availability"
msgstr "Tillgänglighet"

msgid "This module implements the following exception:"
msgstr "Denna modul implementerar följande undantag:"

msgid "Raised when a codec is invalid or incompatible."
msgstr "Utlöses när en kodek är ogiltig eller inkompatibel."

msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ""
":mod:`encodings.idna` --- Internationaliserade domännamn i applikationer"

msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""
"Denna modul implementerar :rfc:`3490` (Internationalized Domain Names in "
"Applications) och :rfc:`3492` (Nameprep: En strängprep-profil för "
"internationaliserade domännamn (IDN)). Den bygger på kodningen ``punycode`` "
"och :mod:`stringprep`."

msgid ""
"If you need the IDNA 2008 standard from :rfc:`5891` and :rfc:`5895`, use the "
"third-party :pypi:`idna` module."
msgstr ""
"Om du behöver IDNA 2008-standarden från :rfc:`5891` och :rfc:`5895`, använd "
"tredjepartsmodulen :pypi:`idna`."

msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as ``www."
"Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding (ACE, "
"such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain "
"name is then used in all places where arbitrary characters are not allowed "
"by the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so "
"on. This conversion is carried out in the application; if possible invisible "
"to the user: The application should transparently convert Unicode domain "
"labels to IDNA on the wire, and convert back ACE labels to Unicode before "
"presenting them to the user."
msgstr ""
"Dessa RFC:er definierar tillsammans ett protokoll för att stödja icke-ASCII-"
"tecken i domännamn. Ett domännamn som innehåller icke-ASCII-tecken (t.ex. "
"``www.Alliancefrançaise.nu``) konverteras till en ASCII-kompatibel kodning "
"(ACE, t.ex. ``www.xn--alliancefranaise-npb.nu``). ACE-formen av domännamnet "
"används sedan på alla ställen där godtyckliga tecken inte tillåts av "
"protokollet, t.ex. DNS-frågor, HTTP :mailheader:`Host`-fält och så vidare. "
"Denna konvertering utförs i applikationen och är om möjligt osynlig för "
"användaren: Programmet bör på ett transparent sätt konvertera Unicode-"
"domänetiketter till IDNA på kabeln och konvertera tillbaka ACE-etiketter "
"till Unicode innan de presenteras för användaren."

msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into "
"labels based on the separator characters defined in :rfc:`section 3.1 of RFC "
"3490 <3490#section-3.1>` and converting each label to ACE as required, and "
"conversely separating an input byte string into labels based on the ``.`` "
"separator and converting any ACE labels found into unicode. Furthermore, "
"the :mod:`socket` module transparently converts Unicode host names to ACE, "
"so that applications need not be concerned about converting host names "
"themselves when they pass them to the socket module. On top of that, modules "
"that have host names as function parameters, such as :mod:`http.client` and :"
"mod:`ftplib`, accept Unicode host names (:mod:`http.client` then also "
"transparently sends an IDNA hostname in the :mailheader:`Host` field if it "
"sends that field at all)."
msgstr ""
"Python stöder denna konvertering på flera sätt: kodeken ``idna`` utför "
"konvertering mellan Unicode och ACE, separerar en inmatningssträng i "
"etiketter baserat på de separatortecken som definieras i :rfc:`section 3.1 "
"of RFC 3490 <3490#section-3.1>` och konverterar varje etikett till ACE efter "
"behov, och omvänt separerar en inmatad bytesträng i etiketter baserat på "
"separatorn ``.`` och konverterar alla ACE-etiketter som hittas till Unicode. "
"Modulen :mod:`socket` konverterar dessutom Unicode-värdnamn till ACE på ett "
"transparent sätt, så att program inte behöver bekymra sig om att konvertera "
"värdnamn själva när de skickar dem till socket-modulen. Dessutom accepterar "
"moduler som har värdnamn som funktionsparametrar, t.ex. :mod:`http.client` "
"och :mod:`ftplib`, Unicode-värdnamn (:mod:`http.client` skickar då också på "
"ett transparent sätt ett IDNA-värdnamn i fältet :mailheader:`Host` om den "
"alls skickar det fältet)."

msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no "
"automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""
"När värdnamn tas emot från kabeln (t.ex. vid omvänd namnuppslagning) sker "
"ingen automatisk konvertering till Unicode: program som vill presentera "
"sådana värdnamn för användaren måste avkoda dem till Unicode."

msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""
"Modulen :mod:`encodings.idna` implementerar också nameprep-proceduren, som "
"utför vissa normaliseringar på värdnamn, för att uppnå skiftlägesokänslighet "
"för internationella domännamn och för att förena liknande tecken. Nameprep-"
"funktionerna kan användas direkt om så önskas."

msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr ""
"Returnerar den namnpreppade versionen av *label*. Implementationen "
"förutsätter för närvarande frågesträngar, så ``AllowUnassigned`` är sant."

msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` "
"is assumed to be false."
msgstr ""
"Konverterar en etikett till ASCII, enligt specifikationen i :rfc:`3490`. "
"``UseSTD3ASCIIRules`` antas vara false."

msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr ""
"Konverterar en etikett till Unicode, enligt specifikationen i :rfc:`3490`."

msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ":mod:`encodings.mbcs` --- Windows ANSI-kodning"

msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr "Denna modul implementerar ANSI-kodsidan (CP_ACP)."

msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used "
"to encode, and ``'ignore'`` to decode."
msgstr ""
"Före 3.2 ignorerades argumentet *errors*; ``'replace'`` användes alltid för "
"kodning och ``'ignore'`` för avkodning."

msgid "Support any error handler."
msgstr "Stödjer alla felhanterare."

msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ":mod:`encodings.utf_8_sig` --- UTF-8-kodek med BOM-signatur"

msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""
"Denna modul implementerar en variant av UTF-8-kodek. Vid kodning kommer en "
"UTF-8-kodad BOM att prependlas till de UTF-8-kodade bytena. För den stateful-"
"kodaren görs detta endast en gång (vid den första skrivningen till "
"byteflödet). Vid avkodning kommer en valfri UTF-8-kodad BOM i början av "
"datan att hoppas över."

msgid "Unicode"
msgstr "Unicode"

msgid "encode"
msgstr "koda"

msgid "decode"
msgstr "avkoda"

msgid "streams"
msgstr "strömmar"

msgid "stackable"
msgstr "stapelbar"

msgid "strict"
msgstr "strikt"

msgid "error handler's name"
msgstr "felhanterarens namn"

msgid "ignore"
msgstr "ignorera"

msgid "replace"
msgstr "ersätta"

msgid "backslashreplace"
msgstr "backslashreplace"

msgid "surrogateescape"
msgstr "surrogatutvandring"

msgid "? (question mark)"
msgstr "? (frågetecken)"

msgid "replacement character"
msgstr "ersättningskaraktär"

msgid "\\ (backslash)"
msgstr "\\ (backslash)"

msgid "escape sequence"
msgstr "utrymningssekvens"

msgid "\\x"
msgstr "\\x"

msgid "\\u"
msgstr "\\u"

msgid "\\U"
msgstr "\\U"

msgid "xmlcharrefreplace"
msgstr "xmlcharrefreplace"

msgid "namereplace"
msgstr "namnbytare"

msgid "surrogatepass"
msgstr "surrogatpass"
