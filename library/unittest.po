# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!unittest` --- Unit testing framework"
msgstr ":mod:`!unittest` --- Ramverk för enhetstestning"

msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Källkod:** :source:`Lib/unittest/__init__.py`"

msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Om du redan är bekant med de grundläggande testkoncepten kanske du vill "
"hoppa över till :ref:`listan över assert-metoder <assert-methods>`.)"

msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"Ramverket för enhetstestning :mod:`unittest` inspirerades ursprungligen av "
"JUnit och har en liknande smak som de stora ramverken för enhetstestning i "
"andra språk.  Det stöder testautomatisering, delning av installations- och "
"avstängningskod för tester, aggregering av tester i samlingar och oberoende "
"av testerna från rapporteringsramverket."

msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"För att uppnå detta stöder :mod:`unittest` några viktiga koncept på ett "
"objektorienterat sätt:"

msgid "test fixture"
msgstr "test fixture"

msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"En :dfn:`test fixture` representerar de förberedelser som krävs för att "
"utföra ett eller flera tester, och alla tillhörande rensningsåtgärder.  Det "
"kan t.ex. handla om att skapa tillfälliga databaser eller proxydatabaser, "
"kataloger eller att starta en serverprocess."

msgid "test case"
msgstr "test case"

msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"Ett :dfn:`testfall` är en individuell enhet för testning.  Det kontrollerar "
"ett specifikt svar på en viss uppsättning indata. :mod:`unittest` "
"tillhandahåller en basklass, :class:`TestCase`, som kan användas för att "
"skapa nya testfall."

msgid "test suite"
msgstr "test suite"

msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"En :dfn:`testsvit` är en samling av testfall, testsviter eller båda.  Den "
"används för att samla ihop tester som ska utföras tillsammans."

msgid "test runner"
msgstr "test runner"

msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"En :dfn:`test runner` är en komponent som orkestrerar utförandet av tester "
"och ger resultatet till användaren.  Runnern kan använda ett grafiskt "
"gränssnitt, ett textgränssnitt eller returnera ett speciellt värde för att "
"ange resultatet av testkörningen."

msgid "Module :mod:`doctest`"
msgstr "Modul :mod:`doctest`"

msgid "Another test-support module with a very different flavor."
msgstr "En annan teststödsmodul med en helt annan smak."

msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"Enkel testning av Smalltalk: Med mönster <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"Kent Becks originalartikel om testning av ramverk med hjälp av det mönster "
"som delas av :mod:`unittest`."

msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Tredjeparts unittest-ramverk med en lättare syntax för att skriva tester.  "
"Till exempel, ``assert func(10) == 42``."

msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"taxonomin för testverktyg för Python <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"En omfattande lista över testverktyg för Python, inklusive ramverk för "
"funktionstestning och bibliotek med låtsasobjekt."

msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Sändlista för testning i Python <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"En specialintressegrupp för diskussion om testning och testverktyg i Python."

msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://www.jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"Skriptet :file:`Tools/unittestgui/unittestgui.py` i Python-"
"källdistributionen är ett GUI-verktyg för att upptäcka och utföra tester.  "
"Detta är främst avsett för att underlätta användningen för dem som är nya "
"inom enhetstestning.  För produktionsmiljöer rekommenderas att tester drivs "
"av ett kontinuerligt integrationssystem som `Buildbot <https://buildbot.net/"
">`_, `Jenkins <https://www.jenkins.io/>`_, `GitHub Actions <https://github."
"com/features/actions>`_ eller `AppVeyor <https://www.appveyor.com/>`_."

msgid "Basic example"
msgstr "Grundläggande exempel"

msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"Modulen :mod:`unittest` innehåller en stor uppsättning verktyg för att "
"konstruera och köra tester.  Detta avsnitt visar att en liten delmängd av "
"verktygen räcker för att uppfylla de flesta användares behov."

msgid "Here is a short script to test three string methods::"
msgstr "Här är ett kort skript för att testa tre strängmetoder::"

msgid ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"import unittest\n"
"\n"
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_upper(self):\n"
"        self.assertEqual('foo'.upper(), 'FOO')\n"
"\n"
"    def test_isupper(self):\n"
"        self.assertTrue('FOO'.isupper())\n"
"        self.assertFalse('Foo'.isupper())\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', 'world'])\n"
"        # check that s.split fails when the separator is not a string\n"
"        with self.assertRaises(TypeError):\n"
"            s.split(2)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"

msgid ""
"A test case is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Ett testfall skapas genom subklassning av :class:`unittest.TestCase`.  De "
"tre enskilda testerna definieras med metoder vars namn börjar med "
"bokstäverna ``test``.  Denna namngivningskonvention informerar testlöparen "
"om vilka metoder som representerar tester."

msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"Kärnan i varje test är ett anrop till :meth:`~TestCase.assertEqual` för att "
"kontrollera ett förväntat resultat; :meth:`~TestCase.assertTrue` eller :meth:"
"`~TestCase.assertFalse` för att verifiera ett villkor; eller :meth:"
"`~TestCase.assertRaises` för att verifiera att ett specifikt undantag tas "
"upp.  Dessa metoder används istället för :keyword:`assert`-satsen så att "
"testlöparen kan samla alla testresultat och producera en rapport."

msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Med metoderna :meth:`~TestCase.setUp` och :meth:`~TestCase.tearDown` kan du "
"definiera instruktioner som ska utföras före och efter varje testmetod. De "
"beskrivs mer i detalj i avsnittet :ref:``organizing-tests``."

msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"Det sista blocket visar ett enkelt sätt att köra testerna. :func:`unittest."
"main` ger ett kommandoradsgränssnitt till testskriptet.  När ovanstående "
"skript körs från kommandoraden ger det en utdata som ser ut så här::"

msgid ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"
msgstr ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"

msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Om du anger alternativet ``-v`` i ditt testskript kommer :func:`unittest."
"main` att aktivera en högre nivå av ordrikedom och producera följande "
"utdata::"

msgid ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"
msgstr ""
"test_isupper (__main__.TestStringMethods.test_isupper) ... ok\n"
"test_split (__main__.TestStringMethods.test_split) ... ok\n"
"test_upper (__main__.TestStringMethods.test_upper) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.001s\n"
"\n"
"OK"

msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Exemplen ovan visar de vanligaste :mod:`unittest`-funktionerna som är "
"tillräckliga för att uppfylla många vardagliga testbehov.  I resten av "
"dokumentationen utforskas hela funktionsuppsättningen från första början."

msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr ""
"Beteendet att returnera ett värde från en testmetod (annat än standardvärdet "
"``None``) är nu föråldrat."

msgid "Command-Line Interface"
msgstr "Kommandoradsgränssnitt"

msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Modulen unittest kan användas från kommandoraden för att köra tester från "
"moduler, klasser eller till och med enskilda testmetoder::"

msgid ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"
msgstr ""
"python -m unittest test_modul1 test_modul2\n"
"python -m unittest test_modul.TestClass\n"
"python -m unittest test_modul.TestClass.test_method"

msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Du kan skicka in en lista med valfri kombination av modulnamn och "
"fullständigt kvalificerade klass- eller metodnamn."

msgid "Test modules can be specified by file path as well::"
msgstr "Testmoduler kan också anges med filväg::"

msgid "python -m unittest tests/test_something.py"
msgstr "python -m unittest tester/test_något.py"

msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Detta gör att du kan använda skalets filnamnskomplettering för att ange "
"testmodulen. Den angivna filen måste fortfarande vara importerbar som en "
"modul. Sökvägen konverteras till ett modulnamn genom att \".py\" tas bort "
"och sökvägsavgränsare konverteras till \".\". Om du vill köra en testfil som "
"inte kan importeras som en modul bör du istället köra filen direkt."

msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Du kan köra tester med fler detaljer (högre verbosity) genom att skicka in "
"flaggan -v::"

msgid "python -m unittest -v test_module"
msgstr "python -m unittest -v test_modul"

msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr "När den körs utan argument startas :ref:`unittest-test-discovery`::"

msgid "python -m unittest"
msgstr "python -m unittest"

msgid "For a list of all the command-line options::"
msgstr "För en lista över alla kommandoradsalternativ::"

msgid "python -m unittest -h"
msgstr "python -m unittest -h"

msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"I tidigare versioner var det bara möjligt att köra enskilda testmetoder och "
"inte moduler eller klasser."

msgid ""
"Output is colorized by default and can be :ref:`controlled using environment "
"variables <using-on-controlling-color>`."
msgstr ""
"Utdata är färgade som standard och kan :ref:`kontrolleras med hjälp av "
"miljövariabler <using-on-controlling-color>`."

msgid "Command-line options"
msgstr "Alternativ för kommandoraden"

msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` stöder dessa kommandoradsalternativ:"

msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Standardutdata- och standardfelströmmarna buffras under testkörningen. "
"Utdata under ett godkänt test kasseras. Utdata ekas normalt vid misslyckat "
"eller felaktigt test och läggs till i felmeddelandena."

msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
":kbd:`Control-C` under testkörningen väntar på att det aktuella testet skall "
"avslutas och rapporterar sedan alla resultat så här långt. En andra :kbd:"
"`Control-C` ger upphov till det normala :exc:`KeyboardInterrupt` undantaget."

msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Se `Signalhantering`_ för de funktioner som tillhandahåller denna "
"funktionalitet."

msgid "Stop the test run on the first error or failure."
msgstr "Avbryt testkörningen vid första felet eller misslyckandet."

msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"Kör endast testmetoder och klasser som matchar mönstret eller delsträngen. "
"Det här alternativet kan användas flera gånger, och då inkluderas alla "
"testfall som matchar något av de angivna mönstren."

msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Mönster som innehåller ett jokertecken (``*``) matchas mot testnamnet med "
"hjälp av :meth:`fnmatch.fnmatchcase`; annars används enkel skiftlägeskänslig "
"delsträngsmatchning."

msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Mönster matchas mot det fullständigt kvalificerade testmetodnamnet som "
"importeras av testladdaren."

msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Till exempel matchar ``-k foo`` ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, men inte ``bar_tests.FooTest."
"test_something``."

msgid "Show local variables in tracebacks."
msgstr "Visa lokala variabler i spårningar."

msgid "Show the N slowest test cases (N=0 for all)."
msgstr "Visa de N långsammaste testfallen (N=0 för alla)."

msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "Kommandoradsalternativen ``-b``, ``-c`` och ``-f`` har lagts till."

msgid "The command-line option ``--locals``."
msgstr "Kommandoradsalternativet ``--locals``."

msgid "The command-line option ``-k``."
msgstr "Kommandoradsalternativet ``-k``."

msgid "The command-line option ``--durations``."
msgstr "Kommandoradsalternativet ``--durations``."

msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"Kommandoraden kan också användas för att upptäcka tester, för att köra alla "
"tester i ett projekt eller bara en delmängd."

msgid "Test Discovery"
msgstr "Testupptäckt"

msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"Unittest stöder enkel testupptäckt. För att vara kompatibla med testupptäckt "
"måste alla testfiler vara :ref:`modules <tut-modules>` eller :ref:`packages "
"<tut-packages>` som kan importeras från projektets toppkatalog (detta "
"innebär att deras filnamn måste vara giltiga :ref:`identifiers "
"<identifiers>`)."

msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"Testupptäckt implementeras i :meth:`TestLoader.discover`, men kan också "
"användas från kommandoraden. Den grundläggande kommandoradsanvändningen är::"

msgid ""
"cd project_directory\n"
"python -m unittest discover"
msgstr ""
"cd projekt_katalog\n"
"python -m unittest discover"

msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Som en genväg är ``python -m unittest`` ekvivalent med ``python -m unittest "
"discover``. Om du vill skicka argument till testdiscovery måste "
"underkommandot ``discover`` användas explicit."

msgid "The ``discover`` sub-command has the following options:"
msgstr "Underkommandot ``discover`` har följande alternativ:"

msgid "Verbose output"
msgstr "Utförlig utdata"

msgid "Directory to start discovery (``.`` default)"
msgstr "Katalog för att starta upptäckten (``.`` standard)"

msgid "Pattern to match test files (``test*.py`` default)"
msgstr "Mönster för att matcha testfiler (``test*.py`` standard)"

msgid "Top level directory of project (defaults to start directory)"
msgstr "Projektets katalog på högsta nivån (standard är startkatalogen)"

msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Alternativen :option:`-s`, :option:`-p` och :option:`-t` kan anges som "
"positionella argument i den ordningen. Följande två kommandorader är "
"likvärdiga::"

msgid ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""
msgstr ""
"python -m unittest discover -s project_directory -p \"*_test.py\"\n"
"python -m unittest discover project_directory \"*_test.py\""

msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Förutom att ange en sökväg är det möjligt att ange ett paketnamn, t.ex. "
"``myproject.subpackage.test``, som startkatalog. Det paketnamn som du anger "
"importeras då och dess plats i filsystemet används som startkatalog."

msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"Test discovery laddar tester genom att importera dem. När testdiscovery har "
"hittat alla testfiler från den startkatalog du anger omvandlar den "
"sökvägarna till paketnamn som ska importeras. Till exempel :file:`foo/bar/"
"baz.py` importeras som ``foo.bar.baz``."

msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Om du har ett paket installerat globalt och försöker utföra testdiscovery på "
"en annan kopia av paketet, kan importen ske från fel ställe. Om detta händer "
"kommer test discovery att varna dig och avsluta."

msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Om du anger startkatalogen som ett paketnamn i stället för en sökväg till en "
"katalog antar discover att den plats som den importerar från är den plats "
"som du avsåg, så att du inte får varningen."

msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Testmoduler och testpaket kan anpassa laddning och upptäckt av tester genom "
"protokollet `load_tests`_."

msgid "Test discovery supports :term:`namespace packages <namespace package>`."
msgstr "Test discovery stöder :term:`namespace packages <namespace package>`."

msgid ""
"Test discovery dropped the :term:`namespace packages <namespace package>` "
"support. It has been broken since Python 3.7. Start directory and its "
"subdirectories containing tests must be regular package that have ``__init__."
"py`` file."
msgstr ""
"Test discovery släppte :term:`namespace packages <namespace package>`-"
"stödet. Det har varit trasigt sedan Python 3.7. Startkatalog och dess "
"underkataloger som innehåller tester måste vara vanliga paket som har filen "
"``__init__.py``."

msgid ""
"If the start directory is the dotted name of the package, the ancestor "
"packages can be namespace packages."
msgstr ""
"Om startkatalogen är paketets prickade namn kan förfäderspaketen vara "
"namnrymdspaket."

msgid ""
"Test discovery supports :term:`namespace package` as start directory again. "
"To avoid scanning directories unrelated to Python, tests are not searched in "
"subdirectories that do not contain ``__init__.py``."
msgstr ""
"Testupptäckt stöder :term:`namespace package` som startkatalog igen. För att "
"undvika att skanna kataloger som inte är relaterade till Python, söks inte "
"tester i underkataloger som inte innehåller ``__init__.py``."

msgid "Organizing test code"
msgstr "Organisering av testkod"

msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"De grundläggande byggstenarna i enhetstestning är :dfn:`testfall` --- "
"enskilda scenarier som måste ställas upp och kontrolleras för korrekthet.  "
"I :mod:`unittest` representeras testfall av :class:`unittest.TestCase`-"
"instanser. För att skapa egna testfall måste du skriva subklasser av :class:"
"`TestCase` eller använda :class:`FunctionTestCase`."

msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"Testkoden för en :class:`TestCase`-instans bör vara helt fristående, så att "
"den kan köras antingen isolerat eller i godtycklig kombination med valfritt "
"antal andra testfall."

msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"Den enklaste :class:`TestCase`-underklassen kommer helt enkelt att "
"implementera en testmetod (dvs. en metod vars namn börjar med ``test``) för "
"att utföra specifik testkod::"

msgid ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"
msgstr ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def test_default_widget_size(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50))"

msgid ""
"Note that in order to test something, we use one of the :ref:`assert\\* "
"methods <assert-methods>` provided by the :class:`TestCase` base class.  If "
"the test fails, an exception will be raised with an explanatory message, "
"and :mod:`unittest` will identify the test case as a :dfn:`failure`.  Any "
"other exceptions will be treated as :dfn:`errors`."
msgstr ""
"Observera att för att testa något använder vi en av metoderna :ref:"
"`assert\\* <assert-methods>` som tillhandahålls av basklassen :class:"
"`TestCase`.  Om testet misslyckas kommer ett undantag att uppstå med ett "
"förklarande meddelande, och :mod:`unittest` kommer att identifiera "
"testfallet som ett :dfn:`failure`.  Alla andra undantag kommer att behandlas "
"som :dfn:`errors`."

msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Testerna kan vara många och deras uppbyggnad kan vara repetitiv.  "
"Lyckligtvis kan vi eliminera uppstartskoden genom att implementera en metod "
"som heter :meth:`~TestCase.setUp`, som testramverket automatiskt anropar för "
"varje enskilt test vi kör::"

msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"
msgstr ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def test_default_widget_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_widget_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"

msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"Den ordning i vilken de olika testerna kommer att köras bestäms genom att "
"sortera testmetodernas namn med hänsyn till den inbyggda ordningen för "
"strängar."

msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Om metoden :meth:`~TestCase.setUp` ger upphov till ett undantag medan testet "
"körs, kommer ramverket att anse att testet har drabbats av ett fel och "
"testmetoden kommer inte att utföras."

msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"På samma sätt kan vi tillhandahålla en :meth:`~TestCase.tearDown`-metod som "
"städar upp efter att testmetoden har körts::"

msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"
msgstr ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()"

msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Om :meth:`~TestCase.setUp` lyckades kommer :meth:`~TestCase.tearDown` att "
"köras oavsett om testmetoden lyckades eller inte."

msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"En sådan arbetsmiljö för testkoden kallas för en :dfn:`testfixtur`.  En ny "
"TestCase-instans skapas som en unik testfixtur som används för att utföra "
"varje enskild testmetod.  Således kommer :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown` och :meth:`~TestCase.__init__` att anropas en gång per "
"test."

msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Det rekommenderas att du använder TestCase-implementationer för att gruppera "
"tester tillsammans enligt de funktioner de testar. :mod:`unittest` "
"tillhandahåller en mekanism för detta: :dfn:`test suite`, representerad av :"
"mod:`unittest`:s :class:`TestSuite`-klass.  I de flesta fall kommer ett "
"anrop till :func:`unittest.main` att göra det rätta och samla in alla "
"modulens testfall åt dig och köra dem."

msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Men om du vill anpassa uppbyggnaden av din testsvit kan du göra det själv::"

msgid ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"
msgstr ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_widget_size'))\n"
"    suite.addTest(WidgetTestCase('test_widget_resize'))\n"
"    return suite\n"
"\n"
"if __name__ == '__main__':\n"
"    runner = unittest.TextTestRunner()\n"
"    runner.run(suite())"

msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Du kan placera definitionerna av testfall och testsviter i samma moduler som "
"den kod de ska testa (t.ex. :file:`widget.py`), men det finns flera fördelar "
"med att placera testkoden i en separat modul, t.ex. :file:`test_widget.py`:"

msgid "The test module can be run standalone from the command line."
msgstr "Testmodulen kan köras fristående från kommandoraden."

msgid "The test code can more easily be separated from shipped code."
msgstr "Testkoden kan lättare separeras från den levererade koden."

msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Det är mindre frestande att utan goda skäl ändra testkoden så att den passar "
"den kod som testas."

msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr "Testkod bör modifieras mycket mer sällan än den kod som den testar."

msgid "Tested code can be refactored more easily."
msgstr "Testad kod kan lättare omarbetas."

msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Tester för moduler som är skrivna i C måste ändå vara i separata moduler, så "
"varför inte vara konsekvent?"

msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr "Om teststrategin ändras behöver källkoden inte ändras."

msgid "Re-using old test code"
msgstr "Återanvändning av gammal testkod"

msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Vissa användare kommer att upptäcka att de har befintlig testkod som de vill "
"köra från :mod:`unittest`, utan att konvertera varje gammal testfunktion "
"till en :class:`TestCase`-underklass."

msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"Av denna anledning tillhandahåller :mod:`unittest` en :class:"
"`FunctionTestCase`-klass. Denna subklass av :class:`TestCase` kan användas "
"för att paketera en befintlig testfunktion.  Funktioner för uppbyggnad och "
"nedmontering kan också tillhandahållas."

msgid "Given the following test function::"
msgstr "Givet följande testfunktion::"

msgid ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."
msgstr ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."

msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"kan man skapa en motsvarande testfallsinstans på följande sätt, med valfria "
"metoder för uppbyggnad och nedmontering::"

msgid ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"
msgstr ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"

msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Även om :class:`FunctionTestCase` kan användas för att snabbt konvertera en "
"befintlig testbas till ett :mod:`unittest` -baserat system, rekommenderas "
"inte detta tillvägagångssätt.  Att ta sig tid att skapa korrekta :class:"
"`TestCase`-subklasser kommer att göra framtida refaktoriseringar av tester "
"oändligt mycket enklare."

msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"I vissa fall kan de befintliga testerna ha skrivits med modulen :mod:"
"`doctest`.  Om så är fallet tillhandahåller :mod:`doctest` en :class:"
"`DocTestSuite`-klass som automatiskt kan bygga :class:`unittest.TestSuite`-"
"instanser från de befintliga :mod:`doctest`-baserade testerna."

msgid "Skipping tests and expected failures"
msgstr "Skippa tester och förväntade misslyckanden"

msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest har stöd för att hoppa över enskilda testmetoder och till och med "
"hela klasser av tester.  Dessutom finns det stöd för att markera ett test "
"som ett \"förväntat misslyckande\", ett test som är trasigt och kommer att "
"misslyckas, men som inte bör räknas som ett misslyckande i :class:"
"`TestResult`."

msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"Att hoppa över ett test är helt enkelt en fråga om att använda :func:`skip` :"
"term:`decorator` eller en av dess villkorliga varianter, anropa :meth:"
"`TestCase.skipTest` inom en :meth:`~TestCase.setUp` eller testmetod, eller "
"att direkt ställa in :exc:`SkipTest`."

msgid "Basic skipping looks like this::"
msgstr "Grundläggande hoppning ser ut så här::"

msgid ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires "
"Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"
msgstr ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires "
"Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass\n"
"\n"
"    def test_maybe_skipped(self):\n"
"        if not external_resource_available():\n"
"            self.skipTest(\"external resource not available\")\n"
"        # test code that depends on the external resource\n"
"        pass"

msgid "This is the output of running the example above in verbose mode::"
msgstr "Så här ser resultatet ut när du kör exemplet ovan i verbose-läge::"

msgid ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in "
"this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating "
"skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped "
"'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped "
"'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"
msgstr ""
"test_format (__main__.MyTestCase.test_format) ... skipped 'not supported in "
"this library version'\n"
"test_nothing (__main__.MyTestCase.test_nothing) ... skipped 'demonstrating "
"skipping'\n"
"test_maybe_skipped (__main__.MyTestCase.test_maybe_skipped) ... skipped "
"'external resource not available'\n"
"test_windows_support (__main__.MyTestCase.test_windows_support) ... skipped "
"'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 4 tests in 0.005s\n"
"\n"
"OK (skipped=4)"

msgid "Classes can be skipped just like methods::"
msgstr "Klasser kan hoppas över precis som metoder:"

msgid ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"
msgstr ""
"@unittest.skip(\"visar klasshoppning\")\n"
"klass MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        passera"

msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` kan också hoppa över testet.  Detta är användbart när "
"en resurs som behöver konfigureras inte är tillgänglig."

msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "Förväntade fel använder dekoratorn :func:`expectedFailure`. ::"

msgid ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"
msgstr ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"

msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Det är enkelt att skapa egna dekoratorer för att hoppa över tester genom att "
"skapa en dekorator som anropar :func:`skip` på testet när den vill att det "
"ska hoppas över.  Denna dekorator hoppar över testet om inte det passerade "
"objektet har ett visst attribut::"

msgid ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"
msgstr ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} har inte {!r}\".format(obj, attr))"

msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Följande dekoratorer och undantag implementerar testöverhoppning och "
"förväntade fel:"

msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Hoppa ovillkorligen över det dekorerade testet.  *reason* bör beskriva "
"varför testet hoppas över."

msgid "Skip the decorated test if *condition* is true."
msgstr "Hoppa över det dekorerade testet om *villkoret* är sant."

msgid "Skip the decorated test unless *condition* is true."
msgstr "Hoppa över det dekorerade testet om inte *villkoret* är sant."

msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"Markera testet som ett förväntat misslyckande eller fel.  Om testet "
"misslyckas eller fel uppstår i själva testfunktionen (snarare än i någon av "
"metoderna i :dfn:`test fixture`) kommer det att betraktas som en framgång.  "
"Om testet godkänns kommer det att betraktas som ett misslyckande."

msgid "This exception is raised to skip a test."
msgstr "Detta undantag görs för att hoppa över ett test."

msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Vanligtvis kan du använda :meth:`TestCase.skipTest` eller någon av "
"dekoratorerna för att hoppa över istället för att ta upp detta direkt."

msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Överhoppade tester kommer inte att ha :meth:`~TestCase.setUp` eller :meth:"
"`~TestCase.tearDown` körda runt dem. Överhoppade klasser kommer inte att ha :"
"meth:`~TestCase.setUpClass` eller :meth:`~TestCase.tearDownClass` körda. "
"Överhoppade moduler kommer inte att få :func:`setUpModule` eller :func:"
"`tearDownModule` körda."

msgid "Distinguishing test iterations using subtests"
msgstr "Särskiljande av testiterationer med hjälp av deltest"

msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"När det finns mycket små skillnader mellan dina tester, t.ex. några "
"parametrar, kan du med unittest skilja dem åt inuti en testmetod med hjälp "
"av kontexthanteraren :meth:`~TestCase.subTest`."

msgid "For example, the following test::"
msgstr "Till exempel följande test::"

msgid ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"
msgstr ""
"class NumbersTest(unittest.TestCase):\n"
"\n"
"    def test_even(self):\n"
"        \"\"\"\n"
"        Test that numbers between 0 and 5 are all even.\n"
"        \"\"\"\n"
"        for i in range(0, 6):\n"
"            with self.subTest(i=i):\n"
"                self.assertEqual(i % 2, 0)"

msgid "will produce the following output::"
msgstr "kommer att ge följande utdata::"

msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Test that numbers between 0 and 5 are all even.\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 11, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=1)\n"
"Testar att alla tal mellan 0 och 5 är jämna.\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 11, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=3)\n"
"Testar att alla tal mellan 0 och 5 är jämna.\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 11, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0\n"
"\n"
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even) (i=5)\n"
"Testar att alla tal mellan 0 och 5 är jämna.\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 11, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"AssertionError: 1 != 0"

msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Utan att använda ett deltest skulle exekveringen avbrytas efter det första "
"felet, och felet skulle vara svårare att diagnostisera eftersom värdet på "
"``i`` inte skulle visas::"

msgid ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (most recent call last):\n"
"  File \"subtests.py\", line 32, in test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError: 1 != 0"
msgstr ""
"======================================================================\n"
"FAIL: test_even (__main__.NumbersTest.test_even)\n"
"----------------------------------------------------------------------\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"subtests.py\", rad 32, i test_even\n"
"    self.assertEqual(i % 2, 0)\n"
"AssertionError (påståendefel): 1 != 0"

msgid "Classes and functions"
msgstr "Klasser och funktioner"

msgid "This section describes in depth the API of :mod:`unittest`."
msgstr ""
"I det här avsnittet beskrivs API:et för :mod:`unittest` på ett djupgående "
"sätt."

msgid "Test cases"
msgstr "Testfall"

msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Instanser av klassen :class:`TestCase` representerar de logiska "
"testenheterna i :mod:`unittest`-universumet.  Den här klassen är avsedd att "
"användas som basklass, där specifika tester implementeras av konkreta "
"underklasser.  Den här klassen implementerar det gränssnitt som testköraren "
"behöver för att kunna köra testerna, och metoder som testkoden kan använda "
"för att kontrollera och rapportera olika typer av fel."

msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Varje instans av :class:`TestCase` kommer att köra en enda basmetod: metoden "
"med namnet *methodName*. I de flesta användningar av :class:`TestCase` "
"kommer du varken att ändra *methodName* eller återimplementera "
"standardmetoden ``runTest()``."

msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` kan instansieras framgångsrikt utan att ange ett "
"*methodName*. Detta gör det lättare att experimentera med :class:`TestCase` "
"från den interaktiva tolken."

msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
":class:`TestCase`-instanser tillhandahåller tre grupper av metoder: en grupp "
"som används för att köra testet, en annan som används av "
"testimplementeringen för att kontrollera villkor och rapportera fel, och "
"några undersökningsmetoder som gör det möjligt att samla in information om "
"själva testet."

msgid "Methods in the first group (running the test) are:"
msgstr "Metoder i den första gruppen (som kör testet) är:"

msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Metod som anropas för att förbereda testfixturen.  Den anropas omedelbart "
"innan testmetoden anropas; förutom :exc:`AssertionError` eller :exc:"
"`SkipTest` kommer alla undantag som denna metod ger upphov till att "
"betraktas som fel snarare än som ett misslyckat test. "
"Standardimplementationen gör ingenting."

msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Metod som anropas omedelbart efter att testmetoden har anropats och "
"resultatet registrerats.  Denna metod anropas även om testmetoden gav upphov "
"till ett undantag, så implementeringen i underklasser kan behöva vara "
"särskilt noggrann med att kontrollera det interna tillståndet.  Varje "
"undantag, annat än :exc:`AssertionError` eller :exc:`SkipTest`, som anropas "
"av denna metod kommer att betraktas som ett ytterligare fel snarare än ett "
"misslyckat test (vilket ökar det totala antalet rapporterade fel). Denna "
"metod kommer endast att anropas om :meth:`setUp` lyckas, oavsett resultatet "
"av testmetoden. Standardimplementeringen gör ingenting."

msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"En klassmetod som anropas innan tester i en enskild klass körs. "
"``setUpClass`` anropas med klassen som enda argument och måste vara "
"dekorerad som en :func:`classmethod`::"

msgid ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."

msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Se `Klass- och modulfixturer`_ för mer information."

msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"En klassmetod som anropas efter att testerna i en enskild klass har körts. "
"``tearDownClass`` anropas med klassen som enda argument och måste vara "
"dekorerad som en :meth:`classmethod`::"

msgid ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."
msgstr ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."

msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Kör testet och samla in resultatet i :class:`TestResult`-objektet som "
"skickas som *result*.  Om *result* utelämnas eller är ``None`` skapas ett "
"temporärt resultatobjekt (genom att anropa metoden :meth:"
"`defaultTestResult`) och används. Resultatobjektet returneras till :meth:"
"`run`:s anropare."

msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"Samma effekt kan uppnås genom att helt enkelt anropa :class:`TestCase`-"
"instansen."

msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Tidigare versioner av ``run`` returnerade inte resultatet. Inte heller att "
"anropa en instans."

msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Om du anropar detta under en testmetod eller :meth:`setUp` hoppar du över "
"det aktuella testet.  Se :ref:`unittest-skipping` för mer information."

msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Returnerar en kontexthanterare som exekverar det bifogade kodblocket som ett "
"subtest.  *msg* och *params* är valfria, godtyckliga värden som visas när "
"ett deltest misslyckas, vilket gör att du kan identifiera dem tydligt."

msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Ett testfall kan innehålla ett obegränsat antal subtestdeklarationer, och de "
"kan vara godtyckligt nästlade."

msgid "See :ref:`subtests` for more information."
msgstr "Se :ref:`subtests` för mer information."

msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Kör testet utan att samla in resultatet.  Detta gör att undantag som uppstår "
"i testet kan vidarebefordras till den som anropar och kan användas för att "
"köra tester under en debugger."

msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"Klassen :class:`TestCase` innehåller flera assert-metoder för att "
"kontrollera och rapportera fel.  I följande tabell listas de vanligaste "
"metoderna (se tabellerna nedan för fler assert-metoder):"

msgid "Method"
msgstr "Metod"

msgid "Checks that"
msgstr "Kontrollerar att"

msgid "New in"
msgstr "Ny i"

msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

msgid "``a == b``"
msgstr "``a == b```"

msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

msgid "``a != b``"
msgstr "``a != b``"

msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

msgid "``a is b``"
msgstr "``a is b``"

msgid "3.1"
msgstr "3.1"

msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

msgid "``a is not b``"
msgstr "``a is not b``"

msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

msgid "``x is None``"
msgstr "``x is None``"

msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

msgid "``x is not None``"
msgstr "``x is not None``"

msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

msgid "``a in b``"
msgstr "``a in b``"

msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

msgid "``a not in b``"
msgstr "``a not in b``"

msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

msgid "3.2"
msgstr "3.2"

msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

msgid ":meth:`assertIsSubclass(a, b) <TestCase.assertIsSubclass>`"
msgstr ":meth:`assertIsSubclass(a, b) <TestCase.assertIsSubclass>`"

msgid "``issubclass(a, b)``"
msgstr "``issubclass(a, b)``"

msgid "3.14"
msgstr "3.14"

msgid ":meth:`assertNotIsSubclass(a, b) <TestCase.assertNotIsSubclass>`"
msgstr ":meth:`assertNotIsSubclass(a, b) <TestCase.assertNotIsSubclass>`"

msgid "``not issubclass(a, b)``"
msgstr "``not issubclass(a, b)``"

msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"Alla assert-metoder accepterar ett *msg*-argument som, om det anges, används "
"som felmeddelande vid misslyckande (se även :data:`longMessage`). Observera "
"att nyckelordsargumentet *msg* endast kan skickas till :meth:"
"`assertRaises`, :meth:`assertRaisesRegex`, :meth:`assertWarns`, :meth:"
"`assertWarnsRegex` när de används som kontexthanterare."

msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Testa att *first* och *second* är lika stora.  Om värdena inte jämförs lika "
"kommer testet att misslyckas."

msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"Dessutom, om *first* och *second* är exakt samma typ och en av list, tuple, "
"dict, set, frozenset eller str eller någon typ som en underklass registrerar "
"med :meth:`addTypeEqualityFunc` kommer den typspecifika likhetsfunktionen "
"att anropas för att generera ett mer användbart standardfelmeddelande (se "
"även :ref:`list of type-specific methods <type-specific-methods>`)."

msgid "Added the automatic calling of type-specific equality function."
msgstr "Lagt till automatisk anrop av typspecifik likhetsfunktion."

msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
":meth:`assertMultiLineEqual` tillagd som standardfunktion för typjämförelse "
"för jämförelse av strängar."

msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Testa att *first* och *second* inte är lika.  Om värdena är lika med "
"varandra kommer testet att misslyckas."

msgid "Test that *expr* is true (or false)."
msgstr "Testa att *expr* är sant (eller falskt)."

msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Observera att detta är likvärdigt med ``bool(expr) is True`` och inte med "
"``expr is True`` (använd ``assertIs(expr, True)`` för det senare).  Denna "
"metod bör också undvikas när mer specifika metoder finns tillgängliga (t.ex. "
"``assertEqual(a, b)`` istället för ``assertTrue(a == b)``), eftersom de ger "
"ett bättre felmeddelande vid fel."

msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "Testa att *first* och *second* är (eller inte är) samma objekt."

msgid "Test that *expr* is (or is not) ``None``."
msgstr "Testa att *expr* är (eller inte är) ``None``."

msgid "Test that *member* is (or is not) in *container*."
msgstr "Testa att *member* är (eller inte är) i *container*."

msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Testa att *obj* är (eller inte är) en instans av *cls* (som kan vara en "
"klass eller en tupel av klasser, vilket stöds av :func:`isinstance`). För "
"att kontrollera den exakta typen, använd :func:`assertIs(type(obj), cls) "
"<assertIs>`."

msgid ""
"Test that *cls* is (or is not) a subclass of *superclass* (which can be a "
"class or a tuple of classes, as supported by :func:`issubclass`). To check "
"for the exact type, use :func:`assertIs(cls, superclass) <assertIs>`."
msgstr ""
"Testa att *cls* är (eller inte är) en underklass till *superclass* (som kan "
"vara en klass eller en tupel av klasser, vilket stöds av :func:"
"`issubclass`). För att kontrollera den exakta typen, använd :func:"
"`assertIs(cls, superclass) <assertIs>`."

msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"Det är också möjligt att kontrollera produktionen av undantag, varningar och "
"loggmeddelanden med hjälp av följande metoder:"

msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` ger upphov till *exc*"

msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)``` ger upphov till *exc* och meddelandet matchar regex "
"*r*"

msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` ger upphov till *varning*"

msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` ger upphov till *warn* och meddelandet matchar regex "
"*r*"

msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "Blocket ``with`` loggar på *logger* med lägsta *nivå*"

msgid "3.4"
msgstr "3.4"

msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"

msgid "The ``with`` block does not log on"
msgstr "Blocket ``with`` loggar inte in"

msgid "*logger* with minimum *level*"
msgstr "*logger* med lägsta *nivå*"

msgid "3.10"
msgstr "3.10"

msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Testar att ett undantag utlöses när *callable* anropas med eventuella "
"positionella eller nyckelordsargument som också skickas till :meth:"
"`assertRaises`.  Testet godkänns om *exception* utlöses, är ett fel om ett "
"annat undantag utlöses eller misslyckas om inget undantag utlöses. För att "
"fånga upp något av en grupp undantag kan en tupel som innehåller "
"undantagsklasserna skickas som *exception*."

msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Om endast argumenten *exception* och eventuellt *msg* anges, returneras en "
"kontexthanterare så att koden som testas kan skrivas inline i stället för "
"som en funktion::"

msgid ""
"with self.assertRaises(SomeException):\n"
"    do_something()"
msgstr ""
"with self.assertRaises(SomeException):\n"
"    do_something()"

msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"När den används som kontexthanterare accepterar :meth:`assertRaises` det "
"extra nyckelordsargumentet *msg*."

msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"Kontexthanteraren lagrar det fångade undantagsobjektet i dess :attr:"
"`exception`-attribut.  Detta kan vara användbart om avsikten är att utföra "
"ytterligare kontroller på det undantag som uppstått:"

msgid ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"
msgstr ""
"med self.assertRaises(SomeException) som cm:\n"
"    gör_något()\n"
"\n"
"the_exception = cm.undantag\n"
"self.assertEqual(the_exception.error_code, 3)"

msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Lagt till möjligheten att använda :meth:`assertRaises` som en "
"kontexthanterare."

msgid "Added the :attr:`exception` attribute."
msgstr "Lagt till attributet :attr:`exception`."

msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Lagt till nyckelordsargumentet *msg* när det används som en kontexthanterare."

msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"Som :meth:`assertRaises` men testar också att *regex* matchar "
"strängrepresentationen av det undantag som uppstod.  *regex* kan vara ett "
"objekt för reguljära uttryck eller en sträng som innehåller ett reguljärt "
"uttryck som är lämpligt för användning av :func:`re.search`.  Exempel::"

msgid ""
"self.assertRaisesRegex(ValueError, \"invalid literal for.*XYZ'$\",\n"
"                       int, 'XYZ')"
msgstr ""
"self.assertRaisesRegex(ValueError,\"ogiltig bokstav för.*XYZ'$\",\n"
"                       int, 'XYZ')"

msgid "or::"
msgstr "eller::"

msgid ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"
msgstr ""
"med self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"

msgid "Added under the name ``assertRaisesRegexp``."
msgstr "Tillagd under namnet ``assertRaisesRegexp``."

msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Omdöpta till :meth:`assertRaisesRegex`."

msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"Testar att en varning utlöses när *callable* anropas med positionella eller "
"nyckelordsargument som också skickas till :meth:`assertWarns`.  Testet "
"godkänns om *warning* utlöses och misslyckas om så inte är fallet.  Varje "
"undantag är ett fel. För att fånga någon av en grupp varningar kan en tupel "
"som innehåller varningsklasserna skickas som *warnings*."

msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Om endast argumenten *warning* och eventuellt *msg* anges, returneras en "
"kontexthanterare så att koden som testas kan skrivas inline i stället för "
"som en funktion::"

msgid ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"
msgstr ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"

msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"När :meth:`assertWarns` används som en kontexthanterare accepteras det extra "
"nyckelordsargumentet *msg*."

msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"Kontexthanteraren lagrar det fångade varningsobjektet i attributet :attr:"
"`warning` och källraden som utlöste varningarna i attributen :attr:"
"`filename` och :attr:`lineno`. Detta kan vara användbart om avsikten är att "
"utföra ytterligare kontroller på den fångade varningen:"

msgid ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"
msgstr ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"

msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""
"Denna metod fungerar oavsett vilka varningsfilter som finns på plats när den "
"anropas."

msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
"Som :meth:`assertWarns` men testar också att *regex* matchar meddelandet i "
"den utlösta varningen.  *regex* kan vara ett objekt för reguljära uttryck "
"eller en sträng som innehåller ett reguljärt uttryck som är lämpligt för "
"användning av :func:`re.search`.  Exempel::"

msgid ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"
msgstr ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"

msgid ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"
msgstr ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"

msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"En kontexthanterare som testar att minst ett meddelande loggas på *logger* "
"eller ett av dess barn, med minst den angivna *level*."

msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"Om *logger* anges ska det vara ett :class:`logging.Logger'-objekt eller ett :"
"class:`str` som anger namnet på en logger.  Standard är rotloggern, som "
"fångar upp alla meddelanden som inte blockerats av en icke-spridande logger "
"i nedstigande led."

msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :const:`logging.ERROR`).  "
"The default is :const:`logging.INFO`."
msgstr ""
"Om *level* anges ska det vara antingen en numerisk loggningsnivå eller dess "
"strängmotsvarighet (t.ex. antingen ``\"ERROR\"`` eller :const:`logging."
"ERROR`).  Standardvärdet är :const:`logging.INFO`."

msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"Testet godkänns om minst ett meddelande som sänds ut i ``with``-blocket "
"uppfyller villkoren *logger* och *level*, annars misslyckas det."

msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""
"Objektet som returneras av kontexthanteraren är en inspelningshjälp som "
"håller reda på de matchande loggmeddelandena.  Det har två attribut:"

msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"En lista med :class:`logging.LogRecord`-objekt för de matchande "
"loggmeddelandena."

msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"En lista med :class:`str`-objekt med formaterade utdata från matchande "
"meddelanden."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"with self.assertLogs('foo', level='INFO') as cm:\n"
"    logging.getLogger('foo').info('first message')\n"
"    logging.getLogger('foo.bar').error('second message')\n"
"self.assertEqual(cm.output, ['INFO:foo:first message',\n"
"                             'ERROR:foo.bar:second message'])"
msgstr ""
"med self.assertLogs('foo', level='INFO') som cm:\n"
"    logging.getLogger('foo').info('första meddelandet')\n"
"    logging.getLogger('foo.bar').error('andra meddelandet')\n"
"self.assertEqual(cm.output, ['INFO:foo:första meddelandet',\n"
"                             'ERROR:foo.bar:andra meddelandet'])"

msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr ""
"En kontexthanterare som testar att inga meddelanden loggas på *logger* eller "
"ett av dess underordnade objekt, med minst den angivna *level*."

msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"Om *logger* anges ska det vara ett :class:`logging.Logger'-objekt eller ett :"
"class:`str` som anger namnet på en logger.  Standard är rotloggaren, som "
"fångar upp alla meddelanden."

msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
"Till skillnad från :meth:`assertLogs` kommer inget att returneras av "
"kontexthanteraren."

msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Det finns också andra metoder som används för att utföra mer specifika "
"kontroller, t.ex:"

msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

msgid "``a > b``"
msgstr "``a > b``"

msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

msgid "``a >= b``"
msgstr "``a >= b```"

msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

msgid "``a < b``"
msgstr "``a < b```"

msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

msgid "``a <= b``"
msgstr "``a <= b```"

msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

msgid "``r.search(s)``"
msgstr "``r.sök(s)```"

msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

msgid "``not r.search(s)``"
msgstr "``inte r.sök(s)``"

msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""
"*a* och *b* har samma element i samma antal, oberoende av deras ordning."

msgid ":meth:`assertStartsWith(a, b) <TestCase.assertStartsWith>`"
msgstr ":meth:`assertStartsWith(a, b) <TestCase.assertStartsWith>`"

msgid "``a.startswith(b)``"
msgstr "``a.startswith(b)``"

msgid ":meth:`assertNotStartsWith(a, b) <TestCase.assertNotStartsWith>`"
msgstr ":meth:`assertNotStartsWith(a, b) <TestCase.assertNotStartsWith>`"

msgid "``not a.startswith(b)``"
msgstr "``not a.startswith(b)``"

msgid ":meth:`assertEndsWith(a, b) <TestCase.assertEndsWith>`"
msgstr ":meth:`assertEndsWith(a, b) <TestCase.assertEndsWith>`"

msgid "``a.endswith(b)``"
msgstr "``a.endswith(b)``"

msgid ":meth:`assertNotEndsWith(a, b) <TestCase.assertNotEndsWith>`"
msgstr ":meth:`assertNotEndsWith(a, b) <TestCase.assertNotEndsWith>`"

msgid "``not a.endswith(b)``"
msgstr "``not a.endswith(b)``"

msgid ":meth:`assertHasAttr(a, b) <TestCase.assertHasAttr>`"
msgstr ":meth:`assertHasAttr(a, b) <TestCase.assertHasAttr>`"

msgid "``hastattr(a, b)``"
msgstr "``hastattr(a, b)``"

msgid ":meth:`assertNotHasAttr(a, b) <TestCase.assertNotHasAttr>`"
msgstr ":meth:`assertNotHasAttr(a, b) <TestCase.assertNotHasAttr>`"

msgid "``not hastattr(a, b)``"
msgstr "``not hastattr(a, b)``"

msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"Testa att *first* och *second* är ungefär (eller inte ungefär) lika genom "
"att beräkna skillnaden, avrunda till det angivna antalet decimaler (standard "
"7) och jämföra med noll.  Observera att dessa metoder avrundar värdena till "
"det angivna antalet *decimaler* (dvs. som funktionen :func:`round`) och inte "
"till *signifikanta siffror*."

msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Om *delta* anges i stället för *places* måste skillnaden mellan *first* och "
"*second* vara mindre eller lika med (eller större än) *delta*."

msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr ""
"Att ange både *delta* och *places* ger upphov till ett :exc:`TypeError`."

msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` betraktar automatiskt nästan lika objekt som "
"jämför lika. :meth:`assertNotAlmostEqual` misslyckas automatiskt om objekten "
"jämför lika.  Lade till nyckelordsargumentet *delta*."

msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Testar att *first* är >, >=, < eller <= än *second* beroende på "
"metodnamnet.  Om inte, kommer testet att misslyckas::"

msgid ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""
msgstr ""
">>> self.assertGreaterEqual(3, 4)\n"
"Påståendefel (AssertionError): \"3\" oväntat inte större än eller lika med "
"\"4\""

msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"Testar att en *regex*-sökning matchar (eller inte matchar) *text*.  Om "
"sökningen misslyckas kommer felmeddelandet att innehålla mönstret och *text* "
"(eller mönstret och den del av *text* som oväntat matchade).  *regex* kan "
"vara ett objekt för reguljära uttryck eller en sträng som innehåller ett "
"reguljärt uttryck som är lämpligt för användning av :func:`re.search`."

msgid "Added under the name ``assertRegexpMatches``."
msgstr "Tillagd under namnet ``assertRegexpMatches``."

msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""
"Metoden ``assertRegexpMatches()`` har bytt namn till :meth:`.assertRegex`."

msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"Testa att sekvensen *först* innehåller samma element som *andra*, oavsett "
"deras ordning. Om de inte gör det genereras ett felmeddelande som listar "
"skillnaderna mellan sekvenserna."

msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"Duplicerade element ignoreras *inte* vid jämförelse av *första* och *andra*. "
"Det kontrolleras om varje element har samma antal i båda sekvenserna. "
"Likvärdig med: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"men fungerar även med sekvenser av icke-hashbara objekt."

msgid ""
"Test that the Unicode or byte string *s* starts (or does not start) with a "
"*prefix*. *prefix* can also be a tuple of strings to try."
msgstr ""
"Testar att Unicode- eller byte-strängen *s* börjar (eller inte börjar) med "
"ett *prefix*. *prefix* kan också vara en tupel av strängar som ska testas."

msgid ""
"Test that the Unicode or byte string *s* ends (or does not end) with a "
"*suffix*. *suffix* can also be a tuple of strings to try."
msgstr ""
"Testar att Unicode- eller byte-strängen *s* slutar (eller inte slutar) med "
"ett *suffix*. *suffix* kan också vara en tupel av strängar som ska testas."

msgid "Test that the object *obj* has (or has not) an attribute *name*."
msgstr "Testar att objektet *obj* har (eller inte har) ett attribut *name*."

msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"Metoden :meth:`assertEqual` skickar jämlikhetskontrollen för objekt av samma "
"typ till olika typspecifika metoder.  Dessa metoder är redan implementerade "
"för de flesta av de inbyggda typerna, men det är också möjligt att "
"registrera nya metoder med :meth:`addTypeEqualityFunc`:"

msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"Registrerar en typspecifik metod som anropas av :meth:`assertEqual` för att "
"kontrollera om två objekt av exakt samma *typobj* (inte underklasser) är "
"lika.  *function* måste ta två positionella argument och ett tredje msg=None "
"nyckelordsargument precis som :meth:`assertEqual` gör.  Den måste ge upphov "
"till :data:`self.failureException(msg) <failureException>` när ojämlikhet "
"mellan de två första parametrarna upptäcks -- eventuellt ge användbar "
"information och förklara ojämlikheterna i detalj i felmeddelandet."

msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
"Listan över typspecifika metoder som automatiskt används av :meth:`~TestCase."
"assertEqual` sammanfattas i följande tabell.  Observera att det vanligtvis "
"inte är nödvändigt att anropa dessa metoder direkt."

msgid "Used to compare"
msgstr "Används för att jämföra"

msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

msgid "strings"
msgstr "strängar"

msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

msgid "sequences"
msgstr "sekvenser"

msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

msgid "lists"
msgstr "listor"

msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

msgid "tuples"
msgstr "tupler"

msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

msgid "sets or frozensets"
msgstr "uppsättningar eller frozensets"

msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

msgid "dicts"
msgstr "dikter"

msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"Testa att den flerradiga strängen *first* är lika med strängen *second*. Om "
"strängarna inte är lika kommer en diff av de två strängarna som belyser "
"skillnaderna att inkluderas i felmeddelandet. Den här metoden används som "
"standard när strängar jämförs med :meth:`assertEqual`."

msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"Testar att två sekvenser är lika.  Om en *seq_type* anges måste både *first* "
"och *second* vara instanser av *seq_type*, annars uppstår ett fel.  Om "
"sekvenserna är olika konstrueras ett felmeddelande som visar skillnaden "
"mellan de två."

msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Denna metod anropas inte direkt av :meth:`assertEqual`, men den används för "
"att implementera :meth:`assertListEqual` och :meth:`assertTupleEqual`."

msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"Testar att två listor eller tupler är lika.  Om så inte är fallet "
"konstrueras ett felmeddelande som endast visar skillnaderna mellan de två.  "
"Ett felmeddelande visas också om någon av parametrarna är av fel typ. Dessa "
"metoder används som standard när listor eller tupler jämförs med :meth:"
"`assertEqual`."

msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Testar att två uppsättningar är lika.  Om inte, konstrueras ett "
"felmeddelande som listar skillnaderna mellan uppsättningarna.  Den här "
"metoden används som standard när man jämför uppsättningar eller frozensets "
"med :meth:`assertEqual`."

msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""
"Misslyckas om *first* eller *second* inte har någon :meth:`set.difference`-"
"metod."

msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Testa att två ordböcker är likvärdiga.  Om inte, konstrueras ett "
"felmeddelande som visar skillnaderna i ordböckerna. Denna metod kommer att "
"användas som standard för att jämföra ordböcker i anrop till :meth:"
"`assertEqual`."

msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""
"Slutligen tillhandahåller :class:`TestCase` följande metoder och attribut:"

msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"Signalerar ovillkorligt att testet misslyckats, med *msg* eller ``None`` som "
"felmeddelande."

msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"Detta klassattribut anger det undantag som testmetoden ger upphov till.  Om "
"ett testramverk behöver använda ett specialiserat undantag, eventuellt för "
"att bära ytterligare information, måste det underklassa detta undantag för "
"att \"spela rättvist\" med ramverket.  Det initiala värdet för detta "
"attribut är :exc:`AssertionError`."

msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"Detta klassattribut avgör vad som händer när ett anpassat felmeddelande "
"skickas som msg-argument till ett assertXYY-anrop som misslyckas. ``True`` "
"är standardvärdet. I det här fallet läggs det anpassade meddelandet till i "
"slutet av standardmeddelandet om misslyckande. När värdet är satt till "
"``False`` ersätter det anpassade meddelandet standardmeddelandet."

msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"Klassinställningen kan åsidosättas i enskilda testmetoder genom att tilldela "
"ett instansattribut, self.longMessage, till ``True`` eller ``False`` innan "
"assert-metoderna anropas."

msgid "The class setting gets reset before each test call."
msgstr "Klassinställningen återställs före varje testanrop."

msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Detta attribut styr den maximala längden på differenser som skrivs ut av "
"assert-metoder som rapporterar differenser vid fel. Standardvärdet är 80*8 "
"tecken. Assert-metoder som påverkas av detta attribut är :meth:"
"`assertSequenceEqual` (inklusive alla sekvensjämförelsemetoder som delegeras "
"till den), :meth:`assertDictEqual` och :meth:`assertMultiLineEqual`."

msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Om du anger ``maxDiff`` till ``None`` innebär det att det inte finns någon "
"maximal längd på diffar."

msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"Testramverk kan använda följande metoder för att samla in information om "
"testet:"

msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"Returnerar antalet tester som representeras av detta testobjekt.  För :class:"
"`TestCase`-instanser kommer detta alltid att vara ``1``."

msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Returnerar en instans av den testresultatklass som ska användas för denna "
"testfallsklass (om ingen annan resultatinstans har angetts för :meth:`run`-"
"metoden)."

msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"För :class:`TestCase`-instanser kommer detta alltid att vara en instans av :"
"class:`TestResult`; underklasser till :class:`TestCase` bör åsidosätta detta "
"vid behov."

msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Returnerar en sträng som identifierar det specifika testfallet.  Detta är "
"vanligtvis det fullständiga namnet på testmetoden, inklusive modul- och "
"klassnamnet."

msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"Returnerar en beskrivning av testet, eller ``None`` om ingen beskrivning har "
"angetts.  Standardimplementeringen av denna metod returnerar den första "
"raden i testmetodens dokumentsträng, om den finns tillgänglig, eller "
"``None``."

msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"I 3.1 ändrades detta så att testnamnet lades till i den korta beskrivningen "
"även om det fanns en docstring.  Detta orsakade kompatibilitetsproblem med "
"unittest-tillägg och tillägget av testnamnet flyttades till :class:"
"`TextTestResult` i Python 3.2."

msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
"Lägg till en funktion som ska anropas efter :meth:`tearDown` för att rensa "
"resurser som använts under testet. Funktioner kommer att anropas i omvänd "
"ordning mot den ordning de läggs till (:abbr:`LIFO (sist in, först ut)`).  "
"De anropas med alla argument och nyckelordsargument som skickas in i :meth:"
"`addCleanup` när de läggs till."

msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Om :meth:`setUp` misslyckas, vilket innebär att :meth:`tearDown` inte "
"anropas, anropas ändå eventuella cleanup-funktioner som lagts till."

msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""
"Ange den medföljande :term:`context manager`.  Om det lyckas, lägg också "
"till dess :meth:`~object.__exit__`-metod som en uppstädningsfunktion med :"
"meth:`addCleanup` och returnera resultatet av :meth:`~object.__enter__`-"
"metoden."

msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Denna metod anropas ovillkorligen efter :meth:`tearDown`, eller efter :meth:"
"`setUp` om :meth:`setUp` ger upphov till ett undantag."

msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"Den är ansvarig för att anropa alla upprensningsfunktioner som lagts till "
"av :meth:`addCleanup`. Om du vill att rensningsfunktionerna ska anropas "
"*före* :meth:`tearDown` kan du anropa :meth:`doCleanups` själv."

msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` plockar metoder från stacken med rensningsfunktioner en i "
"taget, så att den kan anropas när som helst."

msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
"Lägg till en funktion som ska anropas efter :meth:`tearDownClass` för att "
"städa upp resurser som använts under testklassen. Funktioner kommer att "
"anropas i omvänd ordning mot den ordning de läggs till (:abbr:`LIFO (sist "
"in, först ut)`). De anropas med alla argument och nyckelordsargument som "
"skickas in i :meth:`addClassCleanup` när de läggs till."

msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Om :meth:`setUpClass` misslyckas, vilket innebär att :meth:`tearDownClass` "
"inte anropas, så kommer eventuella cleanup-funktioner som lagts till ändå "
"att anropas."

msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Ange den medföljande :term:`context manager`.  Om det lyckas, lägg också "
"till dess :meth:`~object.__exit__`-metod som en uppstädningsfunktion med :"
"meth:`addClassCleanup` och returnera resultatet av :meth:`~object.__enter__`-"
"metoden."

msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"Denna metod anropas ovillkorligen efter :meth:`tearDownClass`, eller efter :"
"meth:`setUpClass` om :meth:`setUpClass` ger upphov till ett undantag."

msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"Den är ansvarig för att anropa alla uppstädningsfunktioner som lagts till "
"av :meth:`addClassCleanup`. Om du vill att rensningsfunktionerna ska anropas "
"*före* :meth:`tearDownClass` kan du själv anropa :meth:`doClassCleanups`."

msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doClassCleanups` plockar bort metoder från stacken med "
"rensningsfunktioner en i taget, så att den kan anropas när som helst."

msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"Denna klass tillhandahåller ett API som liknar :class:`TestCase` och "
"accepterar även coroutines som testfunktioner."

msgid ""
"The *loop_factory* passed to :class:`asyncio.Runner`. Override in subclasses "
"with :class:`asyncio.EventLoop` to avoid using the asyncio policy system."
msgstr ""
"Den *loop_factory* som skickas till :class:`asyncio.Runner`. Åsidosätt i "
"underklasser med :class:`asyncio.EventLoop` för att undvika att använda "
"asyncios policysystem."

msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"Metod som anropas för att förbereda testfixturen. Detta anropas efter :meth:"
"`setUp`. Detta anropas omedelbart innan testmetoden anropas; förutom :exc:"
"`AssertionError` eller :exc:`SkipTest`, kommer alla undantag som denna metod "
"ger upphov till att betraktas som ett fel snarare än ett misslyckat test. "
"Standardimplementationen gör ingenting."

msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"Metod som anropas omedelbart efter att testmetoden har anropats och "
"resultatet registrerats.  Detta anropas före :meth:`tearDown`. Den anropas "
"även om testmetoden gav upphov till ett undantag, så implementeringen i "
"underklasser kan behöva vara särskilt noggrann med att kontrollera det "
"interna tillståndet.  Varje undantag, annat än :exc:`AssertionError` eller :"
"exc:`SkipTest`, som anropas av denna metod kommer att betraktas som ett "
"ytterligare fel snarare än ett testfel (vilket ökar det totala antalet "
"rapporterade fel). Denna metod kommer endast att anropas om :meth:"
"`asyncSetUp` lyckas, oavsett resultatet av testmetoden. "
"Standardimplementeringen gör ingenting."

msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"Den här metoden accepterar en coroutine som kan användas som en "
"rensningsfunktion."

msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""
"Ange den medföljande :term:`asynkron kontexthanterare`.  Om det lyckas, lägg "
"också till dess :meth:`~object.__aexit__`-metod som en uppstädningsfunktion "
"med :meth:`addAsyncCleanup` och returnera resultatet av :meth:`~object."
"__aenter__`-metoden."

msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"Skapar en ny händelseslinga för att köra testet och samlar in resultatet i :"
"class:`TestResult`-objektet som skickas som *result*.  Om *result* utelämnas "
"eller är ``None`` skapas ett temporärt resultatobjekt (genom att anropa "
"metoden :meth:`defaultTestResult`) och används. Resultatobjektet returneras "
"till :meth:`run`:s anropare. I slutet av testet avbryts alla uppgifter i "
"händelseslingan."

msgid "An example illustrating the order::"
msgstr "Ett exempel som illustrerar ordningen::"

msgid ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"events = []\n"
"\n"
"\n"
"class Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example."
"com\")\n"
"        self.assertEqual(response.status_code, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"if __name__ == \"__main__\":\n"
"    unittest.main()"
msgstr ""
"from unittest import IsolatedAsyncioTestCase\n"
"\n"
"händelser = []\n"
"\n"
"\n"
"klass Test(IsolatedAsyncioTestCase):\n"
"\n"
"\n"
"    def setUp(self):\n"
"        events.append(\"setUp\")\n"
"\n"
"    async def asyncSetUp(self):\n"
"        self._async_connection = await AsyncConnection()\n"
"        events.append(\"asyncSetUp\")\n"
"\n"
"    async def test_response(self):\n"
"        events.append(\"test_response\")\n"
"        response = await self._async_connection.get(\"https://example."
"com\")\n"
"        self.assertEqual(svar.status_kod, 200)\n"
"        self.addAsyncCleanup(self.on_cleanup)\n"
"\n"
"    def tearDown(self):\n"
"        events.append(\"tearDown\")\n"
"\n"
"    async def asyncTearDown(self):\n"
"        await self._async_connection.close()\n"
"        events.append(\"asyncTearDown\")\n"
"\n"
"    async def on_cleanup(self):\n"
"        events.append(\"cleanup\")\n"
"\n"
"om __name__ == \"__main__\":\n"
"    unittest.main()"

msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"Efter att testet körts skulle ``events`` innehålla ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."

msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"Denna klass implementerar den del av :class:`TestCase`-gränssnittet som gör "
"det möjligt för testköraren att köra testet, men tillhandahåller inte de "
"metoder som testkoden kan använda för att kontrollera och rapportera fel.  "
"Detta används för att skapa testfall med hjälp av äldre testkod, vilket gör "
"att den kan integreras i ett :mod:`unittest`-baserat testramverk."

msgid "Grouping tests"
msgstr "Gruppering av tester"

msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"Denna klass representerar en sammanställning av enskilda testfall och "
"testsviter. Klassen presenterar det gränssnitt som testlöparen behöver för "
"att kunna köra den som vilket annat testfall som helst.  Att köra en :class:"
"`TestSuite`-instans är samma sak som att iterera över sviten och köra varje "
"test individuellt."

msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"Om *tests* anges måste det vara en iterabel av enskilda testfall eller andra "
"testsviter som kommer att användas för att bygga upp sviten initialt. "
"Ytterligare metoder tillhandahålls för att lägga till testfall och sviter "
"till samlingen senare."

msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
":class:`TestSuite`-objekt beter sig ungefär som :class:`TestCase`-objekt, "
"förutom att de inte implementerar ett test.  Istället används de för att "
"samla ihop tester till grupper av tester som ska köras tillsammans. Det "
"finns några ytterligare metoder för att lägga till tester i :class:"
"`TestSuite`-instanser:"

msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "Lägg till ett :class:`TestCase` eller :class:`TestSuite` till sviten."

msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"Lägg till alla tester från en iterabel med instanser av :class:`TestCase` "
"och :class:`TestSuite` till denna testsvit."

msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"Detta är likvärdigt med att iterera över *tester* och anropa :meth:`addTest` "
"för varje element."

msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ":class:`TestSuite` delar följande metoder med :class:`TestCase`:"

msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"Kör de tester som är associerade med denna svit och samla in resultatet i "
"testresultatobjektet som skickas som *result*.  Observera att till skillnad "
"från :meth:`TestCase.run` kräver :meth:`TestSuite.run` att resultatobjektet "
"skickas in."

msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"Kör de tester som är kopplade till denna svit utan att samla in resultatet. "
"Detta gör att undantag som uppstår i testet kan vidarebefordras till den som "
"anropar och kan användas för att köra tester under en debugger."

msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Returnerar antalet tester som representeras av detta testobjekt, inklusive "
"alla enskilda tester och undergrupper."

msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`!__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"Tester som grupperas av en :class:`TestSuite` nås alltid genom iteration. "
"Underklasser kan lata tillhandahålla tester genom att åsidosätta :meth:`!"
"__iter__`. Observera att den här metoden kan anropas flera gånger på en enda "
"svit (t.ex. när man räknar tester eller jämför för likhet) så de tester som "
"returneras av upprepade iterationer före :meth:`TestSuite.run` måste vara "
"desamma för varje anropsiteration. Efter :meth:`TestSuite.run` bör anropare "
"inte förlita sig på de tester som returneras av denna metod om inte "
"anroparen använder en subklass som åsidosätter :meth:`TestSuite."
"_removeTestAtIndex` för att bevara testreferenser."

msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`!__iter__` wasn't sufficient "
"for providing tests."
msgstr ""
"I tidigare versioner hade :class:`TestSuite` tillgång till tester direkt "
"snarare än genom iteration, så att åsidosätta :meth:`!__iter__` var inte "
"tillräckligt för att tillhandahålla tester."

msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"I tidigare versioner behöll :class:`TestSuite` referenser till varje :class:"
"`TestCase` efter :meth:`TestSuite.run`. Underklasser kan återställa detta "
"beteende genom att åsidosätta :meth:`TestSuite._removeTestAtIndex`."

msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"I den typiska användningen av ett :class:`TestSuite`-objekt anropas :meth:"
"`run`-metoden av en :class:`TestRunner` snarare än av slutanvändarens "
"testprogram."

msgid "Loading and running tests"
msgstr "Ladda och köra tester"

msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
"Klassen :class:`TestLoader` används för att skapa testsviter från klasser "
"och moduler.  Normalt finns det inget behov av att skapa en instans av den "
"här klassen; modulen :mod:`unittest` tillhandahåller en instans som kan "
"delas som :data:`unittest.defaultTestLoader`.  Om du använder en underklass "
"eller instans kan du dock anpassa vissa konfigurerbara egenskaper."

msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader`-objekt har följande attribut:"

msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""
"En lista över de icke-fatala fel som uppstår vid laddning av tester. "
"Återställs inte av laddaren vid någon tidpunkt. Fatala fel signaleras genom "
"att den relevanta metoden ger upphov till ett undantag för den som anropar. "
"Icke-fatala fel indikeras också av ett syntetiskt test som kommer att ge "
"upphov till det ursprungliga felet när det körs."

msgid ":class:`TestLoader` objects have the following methods:"
msgstr ":class:`TestLoader`-objekt har följande metoder:"

msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""
"Returnerar en svit av alla testfall som ingår i den :class:`TestCase`-"
"deriverade :class:`testCaseClass`."

msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
"En testfallsinstans skapas för varje metod som namnges av :meth:"
"`getTestCaseNames`. Som standard är detta de metodnamn som börjar med "
"``test``. Om :meth:`getTestCaseNames` inte returnerar några metoder, men "
"metoden :meth:`runTest` är implementerad, skapas ett enda testfall för den "
"metoden istället."

msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"Returnerar en svit av alla testfall som ingår i den givna modulen. Den här "
"metoden söker i *module* efter klasser som härrör från :class:`TestCase` och "
"skapar en instans av klassen för varje testmetod som definieras för klassen."

msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Även om det kan vara praktiskt att använda en hierarki av :class:`TestCase`-"
"avledda klasser för att dela fixturer och hjälpfunktioner, är det inte så "
"bra att definiera testmetoder på basklasser som inte är avsedda att "
"instansieras direkt med den här metoden.  Det kan dock vara användbart när "
"fixturerna är olika och definieras i underklasser."

msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"Om en modul tillhandahåller en ``load_tests``-funktion kommer den att "
"anropas för att ladda testerna. Detta gör det möjligt för moduler att "
"anpassa testladdningen. Detta är `load_tests-protokollet`_.  Argumentet "
"*pattern* skickas som det tredje argumentet till ``load_tests``."

msgid "Support for ``load_tests`` added."
msgstr "Stöd för ``load_tests`` har lagts till."

msgid "Support for a keyword-only argument *pattern* has been added."
msgstr ""
"Stöd för ett argument *pattern* som endast innehåller nyckelord har lagts "
"till."

msgid ""
"The undocumented and unofficial *use_load_tests* parameter has been removed."
msgstr ""
"Den odokumenterade och inofficiella parametern *use_load_tests* har tagits "
"bort."

msgid "Return a suite of all test cases given a string specifier."
msgstr ""
"Returnerar en svit med alla testfall som anges med en strängspecifikator."

msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"Specificeraren *name* är ett \"prickat namn\" som kan leda till antingen en "
"modul, en testfallsklass, en testmetod i en testfallsklass, en instans av :"
"class:`TestSuite` eller ett anropsbart objekt som returnerar en instans av :"
"class:`TestCase` eller :class:`TestSuite`.  Dessa kontroller tillämpas i den "
"ordning som anges här, dvs. en metod i en möjlig testfallsklass kommer att "
"uppfattas som \"en testmetod i en testfallsklass\", snarare än \"ett "
"anropbart objekt\"."

msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"Om du till exempel har en modul :mod:`SampleTests` som innehåller en :class:"
"`TestCase`-avledd klass :class:`SampleTestCase` med tre testmetoder (:meth:"
"`test_one`, :meth:`test_two` och :meth:`test_three`), skulle specifikatorn "
"``'SampleTests.SampleTestCase'`` göra att den här metoden returnerar en svit "
"som kör alla tre testmetoderna. Om specifikatorn ``'SampleTests."
"SampleTestCase.test_two'`` används kommer metoden att returnera en testsvit "
"som endast kör testmetoden :meth:`test_two`. Specificeraren kan hänvisa till "
"moduler och paket som inte har importerats; de kommer att importeras som en "
"bieffekt."

msgid "The method optionally resolves *name* relative to the given *module*."
msgstr ""
"Metoden löser valfritt upp *namn* i förhållande till den angivna *modulen*."

msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"Om ett :exc:`ImportError` eller :exc:`AttributeError` inträffar när *name* "
"genomkorsas kommer ett syntetiskt test som ger upphov till felet att "
"returneras. Dessa fel ingår i de fel som ackumuleras av self.errors."

msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"Liknar :meth:`loadTestsFromName`, men tar en sekvens av namn i stället för "
"ett enda namn.  Returvärdet är en testsvit som stöder alla tester som "
"definierats för varje namn."

msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Returnerar en sorterad sekvens av metodnamn som finns inom *testCaseClass*; "
"detta bör vara en subklass av :class:`TestCase`."

msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Hitta alla testmoduler genom att söka i underkataloger från den angivna "
"startkatalogen och returnera ett TestSuite-objekt som innehåller dem. Endast "
"testfiler som matchar *mönster* kommer att laddas. (Med hjälp av "
"mönstermatchning i shell-stil.) Endast modulnamn som är importerbara (dvs. "
"giltiga Python-identifierare) laddas."

msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then *top_level_dir* must "
"be specified separately."
msgstr ""
"Alla testmoduler måste kunna importeras från den översta nivån i projektet. "
"Om startkatalogen inte är den översta katalogen måste *top_level_dir* anges "
"separat."

msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"Om importen av en modul misslyckas, t.ex. på grund av ett syntaxfel, "
"registreras detta som ett enda fel och upptäckten fortsätter.  Om importen "
"misslyckas på grund av att :exc:`SkipTest` aktiveras, registreras det som en "
"skip istället för ett fel."

msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"Om ett paket (en katalog som innehåller en fil med namnet :file:`__init__."
"py`) hittas, kommer paketet att kontrolleras för en ``load_tests``-funktion. "
"Om en sådan finns kommer den att kallas ``package.load_tests(loader, tests, "
"pattern)``. Testdiscovery ser till att ett paket bara kontrolleras för "
"tester en gång under en anrop, även om load_tests-funktionen själv anropar "
"``loader.discover``."

msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"Om ``load_tests`` existerar så rekurserar discovery *inte* in i paketet, "
"``load_tests`` ansvarar för att ladda alla tester i paketet."

msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves."
msgstr ""
"Mönstret lagras avsiktligt inte som ett attribut för laddaren, så att "
"paketen kan fortsätta att upptäcka sig själva."

msgid ""
"*top_level_dir* is stored internally, and used as a default to any nested "
"calls to ``discover()``. That is, if a package's ``load_tests`` calls "
"``loader.discover()``, it does not need to pass this argument."
msgstr ""
"*top_level_dir* lagras internt och används som standard för alla nästlade "
"anrop till ``discover()``. Det vill säga, om ett pakets ``load_tests`` "
"anropar ``loader.discover()``, behöver det inte skicka detta argument."

msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* kan vara både ett punktat modulnamn och en katalog."

msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"Moduler som ger upphov till :exc:`SkipTest` vid import registreras som "
"överhoppningar, inte fel."

msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr ""
"*start_dir* kan vara en :term:`namespace packages <namespace package>`."

msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"Sökvägarna sorteras innan de importeras så att exekveringsordningen blir "
"densamma även om det underliggande filsystemets ordning inte är beroende av "
"filnamnet."

msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""
"Hittade paket kontrolleras nu för ``load_tests`` oavsett om deras sökväg "
"matchar *pattern*, eftersom det är omöjligt för ett paketnamn att matcha "
"standardmönstret."

msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7, and Python 3.11 officially removes it."
msgstr ""
"*start_dir* kan inte vara en :term:`namespace packages <namespace package>`. "
"Det har varit trasigt sedan Python 3.7, och Python 3.11 tar officiellt bort "
"det."

msgid "*top_level_dir* is only stored for the duration of *discover* call."
msgstr ""
"*top_level_dir* lagras endast under den tid som *discover*-anropet pågår."

msgid "*start_dir* can once again be a :term:`namespace package`."
msgstr "*start_dir* kan återigen vara en :term:`namespace package`."

msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Följande attribut för en :class:`TestLoader` kan konfigureras antingen genom "
"subklassning eller genom tilldelning på en instans:"

msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"Sträng som anger prefixet för metodnamn som ska tolkas som testmetoder.  "
"Standardvärdet är ``'test'``."

msgid ""
"This affects :meth:`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Detta påverkar :meth:`getTestCaseNames` och alla ``loadTestsFrom*``-metoder."

msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Funktion som ska användas för att jämföra metodnamn när de sorteras i :meth:"
"`getTestCaseNames` och alla ``loadTestsFrom*``-metoder."

msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"Anropsbart objekt som konstruerar en testsvit från en lista med tester. Inga "
"metoder på det resulterande objektet behövs.  Standardvärdet är klassen :"
"class:`TestSuite`."

msgid "This affects all the ``loadTestsFrom*`` methods."
msgstr "Detta påverkar alla ``loadTestsFrom*``-metoder."

msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr ""
"Lista över testnamnsmönster med jokertecken i Unix-shell-stil som "
"testmetoder måste matcha för att inkluderas i testsviter (se alternativet ``-"
"k``)."

msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"Om detta attribut inte är ``None`` (standard) måste alla testmetoder som ska "
"ingå i testsviter matcha ett av mönstren i listan. Observera att matchningar "
"alltid utförs med :meth:`fnmatch.fnmatchcase`, så till skillnad från mönster "
"som skickas till alternativet ``-k`` måste enkla delsträngsmönster "
"konverteras med hjälp av jokertecken ``*``."

msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Denna klass används för att sammanställa information om vilka tester som har "
"lyckats och vilka som har misslyckats."

msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Ett :class:`TestResult`-objekt lagrar resultaten av en uppsättning tester.  "
"Klasserna :class:`TestCase` och :class:`TestSuite` säkerställer att "
"resultaten registreras på rätt sätt; testförfattare behöver inte oroa sig "
"för att registrera resultatet av testerna."

msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"Testramverk som bygger på :mod:`unittest` kan vilja ha tillgång till :class:"
"`TestResult`-objektet som genereras genom att köra en uppsättning tester för "
"rapporteringsändamål; en :class:`TestResult`-instans returneras av :meth:"
"`TestRunner.run`-metoden för detta ändamål."

msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
":class:`TestResult`-instanser har följande attribut som är av intresse när "
"man granskar resultatet av en uppsättning tester:"

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"En lista som innehåller 2-tupler av :class:`TestCase`-instanser och strängar "
"som innehåller formaterade spårningar. Varje tupel representerar ett test "
"som gav upphov till ett oväntat undantag."

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :ref:`assert\\* methods <assert-methods>`."
msgstr ""
"En lista som innehåller 2-tupler av :class:`TestCase`-instanser och strängar "
"som innehåller formaterade spårningar. Varje tupel representerar ett test "
"där ett fel uttryckligen signalerades med hjälp av :ref:`assert\\*-metoderna "
"<assert-methods>`."

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"En lista som innehåller 2-tupel av :class:`TestCase`-instanser och strängar "
"som anger orsaken till att testet hoppar över."

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"En lista som innehåller 2-tupler av :class:`TestCase`-instanser och strängar "
"som innehåller formaterade spårningar.  Varje tupel representerar ett "
"förväntat misslyckande eller fel i testfallet."

msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"En lista som innehåller :class:`TestCase`-instanser som var markerade som "
"förväntade misslyckanden, men som lyckades."

msgid ""
"A list containing 2-tuples of test case names and floats representing the "
"elapsed time of each test which was run."
msgstr ""
"En lista som innehåller 2-tuples av testfallsnamn och floats som "
"representerar den förflutna tiden för varje test som kördes."

msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr "Sätts till ``True`` när testkörningen ska stoppas med :meth:`stop`."

msgid "The total number of tests run so far."
msgstr "Det totala antalet tester som körts hittills."

msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"Om inställningen är true kommer ``sys.stdout`` och ``sys.stderr`` att "
"buffras mellan anropen av :meth:`startTest` och :meth:`stopTest`. Insamlad "
"utdata kommer endast att ekas till de riktiga ``sys.stdout`` och ``sys."
"stderr`` om testet misslyckas eller felar. Alla utdata bifogas också till "
"felmeddelandet."

msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Om inställningen är true kommer :meth:`stop` att anropas vid det första "
"misslyckandet eller felet, vilket stoppar testkörningen."

msgid "If set to true then local variables will be shown in tracebacks."
msgstr "Om värdet är true kommer lokala variabler att visas i spårningar."

msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Returnerar ``True`` om alla tester som körts hittills har godkänts, annars "
"returneras ``False``."

msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"Returnerar ``False`` om det fanns några :attr:`unexpectedSuccesses` från "
"tester markerade med :func:`expectedFailure` dekoratorn."

msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"Denna metod kan anropas för att signalera att den uppsättning tester som "
"körs bör avbrytas genom att sätta attributet :attr:`shouldStop` till "
"``True``. :class:`TestRunner`-objekt bör respektera denna flagga och "
"återvända utan att köra några ytterligare tester."

msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Den här funktionen används t.ex. av klassen :class:`TextTestRunner` för att "
"stoppa testramverket när användaren signalerar ett avbrott från "
"tangentbordet.  Interaktiva verktyg som tillhandahåller :class:`TestRunner`-"
"implementationer kan använda detta på liknande sätt."

msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Följande metoder i klassen :class:`TestResult` används för att underhålla de "
"interna datastrukturerna och kan utökas i underklasser för att stödja "
"ytterligare rapporteringskrav.  Detta är särskilt användbart för att bygga "
"verktyg som stöder interaktiv rapportering medan tester körs."

msgid "Called when the test case *test* is about to be run."
msgstr "Anropas när testfallet *test* ska köras."

msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "Anropas efter att testfallet *test* har utförts, oavsett resultat."

msgid "Called once before any tests are executed."
msgstr "Anropas en gång innan några tester utförs."

msgid "Called once after all tests are executed."
msgstr "Anropas en gång efter att alla tester har utförts."

msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Anropas när testfallet *test* ger upphov till ett oväntat undantag. *err* är "
"en tupel av den form som returneras av :func:`sys.exc_info`: ``(type, value, "
"traceback)``."

msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, formatted_err)`` till "
"instansens attribut :attr:`errors`, där *formatted_err* är en formaterad "
"återgång som härrör från *err*."

msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Anropas när testfallet *test* signalerar ett misslyckande. *err* är en tupel "
"av den form som returneras av :func:`sys.exc_info`: ``(type, value, "
"traceback)``."

msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, formatted_err)`` till "
"instansens attribut :attr:`failures`, där *formatted_err* är en formaterad "
"återgång som härrör från *err*."

msgid "Called when the test case *test* succeeds."
msgstr "Anropas när testfallet *test* lyckas."

msgid "The default implementation does nothing."
msgstr "Standardimplementeringen gör ingenting."

msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Anropas när testfallet *test* hoppar över.  *reason* är den anledning som "
"testet angav för att hoppa över."

msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, reason)`` till "
"instansens attribut :attr:`skipped`."

msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr ""
"Anropas när testfallet *test* misslyckas eller felar, men var markerat med :"
"func:`expectedFailure`-dekoratorn."

msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"Standardimplementeringen lägger till en tupel ``(test, formatted_err)`` till "
"instansens attribut :attr:`expectedFailures`, där *formatted_err* är en "
"formaterad återgång som härrör från *err*."

msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
"Anropas när testfallet *test* markerades med dekoratorn :func:"
"`expectedFailure`, men lyckades."

msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"Standardimplementeringen lägger till testet till instansens attribut :attr:"
"`unexpectedSuccesses`."

msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"Anropas när ett deltest är avslutat.  *test* är det testfall som motsvarar "
"testmetoden.  *subtest* är en anpassad :class:`TestCase`-instans som "
"beskriver subtestet."

msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Om *outcome* är :const:`None`, lyckades deltestet.  Annars misslyckades det "
"med ett undantag där *outcome* är en tupel av den form som returneras av :"
"func:`sys.exc_info`: ``(type, value, traceback)``."

msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"Standardimplementeringen gör ingenting när resultatet är en framgång, och "
"registrerar misslyckade deltest som normala misslyckanden."

msgid ""
"Called when the test case finishes.  *elapsed* is the time represented in "
"seconds, and it includes the execution of cleanup functions."
msgstr ""
"Anropas när testfallet är avslutat.  *elapsed* är tiden i sekunder och "
"inkluderar exekvering av rensningsfunktioner."

msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`. Subclasses should accept ``**kwargs`` to ensure "
"compatibility as the interface changes."
msgstr ""
"En konkret implementation av :class:`TestResult` som används av :class:"
"`TextTestRunner`. Underklasser bör acceptera ``**kwargs`` för att "
"säkerställa kompatibilitet när gränssnittet ändras."

msgid "Added the *durations* keyword parameter."
msgstr "Nyckelordsparametern *durations* har lagts till."

msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Instans av klassen :class:`TestLoader` som är avsedd att delas.  Om ingen "
"anpassning av :class:`TestLoader` behövs, kan denna instans användas "
"istället för att upprepade gånger skapa nya instanser."

msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"En grundläggande implementering av en testlöpare som matar ut resultat till "
"en ström. Om *stream* är ``None`` används standardvärdet :data:`sys.stderr` "
"som utdataflöde. Den här klassen har några konfigurerbara parametrar, men är "
"i grunden mycket enkel.  Grafiska applikationer som kör testsviter bör "
"tillhandahålla alternativa implementationer. Sådana implementationer bör "
"acceptera ``**kwargs`` eftersom gränssnittet för att konstruera löpare "
"ändras när funktioner läggs till i unittest."

msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`.  This behavior "
"can be overridden using Python's :option:`!-Wd` or :option:`!-Wa` options "
"(see :ref:`Warning control <using-on-warnings>`) and leaving *warnings* to "
"``None``."
msgstr ""
"Som standard visar den här löparen :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` och :exc:`ImportWarning` "
"även om de är :ref:`ignorerade som standard <warning-ignored>`.  Detta "
"beteende kan åsidosättas genom att använda Pythons :option:`!-Wd` eller :"
"option:`!-Wa` (se :ref:`Warning control <using-on-warnings>`) och lämna "
"*warnings* till ``None``."

msgid "Added the *warnings* parameter."
msgstr "Parametern *warnings* har lagts till."

msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""
"Standardströmmen är inställd på :data:`sys.stderr` vid instantiering "
"istället för vid import."

msgid "Added the *tb_locals* parameter."
msgstr "Parametern *tb_locals* har lagts till."

msgid "Added the *durations* parameter."
msgstr "Parametern *durations* har lagts till."

msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Denna metod returnerar den instans av ``TestResult`` som används av :meth:"
"`run`. Den är inte avsedd att anropas direkt, men kan åsidosättas i "
"subklasser för att tillhandahålla ett eget ``TestResult``."

msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` instansierar klassen eller anropsbarheten som skickas i "
"``TextTestRunner`` konstruktören som ``resultclass`` argument. "
"Standardvärdet är :class:`TextTestResult` om ingen ``resultclass`` anges. "
"Resultatklassen instansieras med följande argument::"

msgid "stream, descriptions, verbosity"
msgstr "stream, descriptions, verbosity"

msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"Denna metod är det huvudsakliga publika gränssnittet till "
"``TextTestRunner``. Denna metod tar en :class:`TestSuite` eller :class:"
"`TestCase` instans. Ett :class:`TestResult` skapas genom att anropa :func:"
"`_makeResult` och testet(en) körs och resultaten skrivs ut till stdout."

msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Ett kommandoradsprogram som laddar en uppsättning tester från *modul* och "
"kör dem; detta är främst till för att göra testmoduler praktiskt körbara. "
"Den enklaste användningen av denna funktion är att inkludera följande rad i "
"slutet av ett testskript::"

msgid ""
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main()"

msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""
"Du kan köra tester med mer detaljerad information genom att ange argumentet "
"verbosity::"

msgid ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"
msgstr ""
"if __name__ == '__main__':\n"
"    unittest.main(ordrikhet=2)"

msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"Argumentet *defaultTest* är antingen namnet på ett enskilt test eller en "
"iterabel med testnamn som ska köras om inga testnamn anges via *argv*.  Om "
"det inte specificeras eller ``None`` och inga testnamn anges via *argv*, "
"körs alla tester som finns i *module*."

msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"Argumentet *argv* kan vara en lista med alternativ som skickas till "
"programmet, där det första elementet är programnamnet.  Om inget anges eller "
"``None``, används värdena i :data:`sys.argv`."

msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success (0) or failure (1) of the tests run. An exit "
"code of 5 indicates that no tests were run or skipped."
msgstr ""
"Argumentet *testRunner* kan antingen vara en testlöparklass eller en redan "
"skapad instans av den. Som standard anropar ``main`` :func:`sys.exit` med en "
"utgångskod som anger om testerna som körts lyckades (0) eller misslyckades "
"(1). En exit-kod på 5 anger att inga tester kördes eller att de hoppades "
"över."

msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"Argumentet *testLoader* måste vara en instans av :class:`TestLoader`, och "
"standardvärdet är :data:`defaultTestLoader`."

msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` kan användas från den interaktiva tolken genom att skicka in "
"argumentet ``exit=False``. Detta visar resultatet på standardutmatningen "
"utan att anropa :func:`sys.exit`::"

msgid ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"
msgstr ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"

msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"Parametrarna *failfast*, *catchbreak* och *buffer* har samma effekt som "
"`kommandoradsalternativen`_ med samma namn."

msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"Argumentet *warnings* anger det :ref:`varningsfilter <warning-filter>` som "
"ska användas när testerna körs.  Om det inte anges kommer det att förbli "
"``None`` om ett :option:`!-W`-alternativ skickas till :program:`python` (se :"
"ref:`Warning control <using-on-warnings>`), annars kommer det att sättas "
"till ``'default'``."

msgid ""
"Calling ``main`` returns an object with the ``result`` attribute that "
"contains the result of the tests run as a :class:`unittest.TestResult`."
msgstr ""
"Anrop av ``main`` returnerar ett objekt med attributet ``result`` som "
"innehåller resultatet av de tester som körts som en :class:`unittest."
"TestResult`."

msgid "The *exit* parameter was added."
msgstr "Parametern *exit* har lagts till."

msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Parametrarna *verbosity*, *failfast*, *catchbreak*, *buffer* och *warnings* "
"har lagts till."

msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""
"Parametern *defaultTest* har ändrats så att den även accepterar en iterabel "
"med testnamn."

msgid "load_tests Protocol"
msgstr "load_tests Protokoll"

msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Moduler eller paket kan anpassa hur tester laddas från dem under normala "
"testkörningar eller testupptäckt genom att implementera en funktion som "
"heter ``load_tests``."

msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Om en testmodul definierar ``load_tests`` kommer den att anropas av :meth:"
"`TestLoader.loadTestsFromModule` med följande argument::"

msgid "load_tests(loader, standard_tests, pattern)"
msgstr "load_tests(loader, standard_tests, pattern)"

msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""
"där *mönster* skickas rakt igenom från ``loadTestsFromModule``.  "
"Standardvärdet är ``None``."

msgid "It should return a :class:`TestSuite`."
msgstr "Den bör returnera en :class:`TestSuite`."

msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* är den instans av :class:`TestLoader` som gör inläsningen. "
"*standard_tests* är de tester som laddas som standard från modulen. Det är "
"vanligt att testmoduler bara vill lägga till eller ta bort tester från "
"standarduppsättningen av tester. Det tredje argumentet används när paket "
"laddas som en del av testupptäckten."

msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"En typisk ``load_tests``-funktion som laddar tester från en specifik "
"uppsättning :class:`TestCase`-klasser kan se ut på följande sätt::"

msgid ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"
msgstr ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"

msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"Om discovery startas i en katalog som innehåller ett paket, antingen från "
"kommandoraden eller genom att anropa :meth:`TestLoader.discover`, kommer "
"paketet :file:`__init__.py` att kontrolleras med avseende på "
"``load_tests``.  Om den funktionen inte finns kommer discovery att rekursera "
"i paketet som om det vore en katalog.  Annars kommer upptäckten av paketets "
"tester att överlåtas till ``load_tests`` som anropas med följande argument::"

msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"Detta bör returnera en :class:`TestSuite` som representerar alla tester från "
"paketet. (``standard_tests`` kommer endast att innehålla tester som hämtats "
"från :file:`__init__.py`.)"

msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Eftersom mönstret skickas in i ``load_tests`` är paketet fritt att fortsätta "
"(och eventuellt modifiera) testupptäckten. En \"gör ingenting\" "
"``load_tests`` funktion för ett testpaket skulle se ut som::"

msgid ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"
msgstr ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"

msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"Discovery kontrollerar inte längre om paketnamn matchar *pattern* eftersom "
"det är omöjligt att paketnamn matchar standardmönstret."

msgid "Class and Module Fixtures"
msgstr "Klass- och modulfixturer"

msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"Fixturer på klass- och modulnivå är implementerade i :class:`TestSuite`. När "
"testsviten stöter på ett test från en ny klass anropas :meth:`tearDownClass` "
"från den tidigare klassen (om det finns en sådan), följt av :meth:"
"`setUpClass` från den nya klassen."

msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"På samma sätt om ett test är från en annan modul än det föregående testet så "
"körs ``tearDownModule`` från den föregående modulen, följt av "
"``setUpModule`` från den nya modulen."

msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"Efter att alla tester har körts körs de slutliga ``tearDownClass`` och "
"``tearDownModule``."

msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"Observera att delade fixturer inte fungerar bra med [potentiella] funktioner "
"som testparallellisering och att de bryter testisolering. De bör användas "
"med försiktighet."

msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"Standardordningen för tester som skapas av unittests testladdare är att "
"gruppera alla tester från samma moduler och klasser tillsammans. Detta "
"kommer att leda till att ``setUpClass`` / ``setUpModule`` (etc) anropas "
"exakt en gång per klass och modul. Om du slumpar ordningen, så att tester "
"från olika moduler och klasser ligger intill varandra, kan dessa delade "
"fixture-funktioner anropas flera gånger under en enda testkörning."

msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"Delade fixturer är inte avsedda att fungera med sviter med icke-"
"standardiserad ordningsföljd. En ``BaseTestSuite`` finns fortfarande för "
"ramverk som inte vill stödja delade fixturer."

msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"Om det uppstår några undantag under någon av de delade fixturfunktionerna "
"rapporteras testet som ett fel. Eftersom det inte finns någon motsvarande "
"testinstans skapas ett ``_ErrorHolder``-objekt (som har samma gränssnitt som "
"ett :class:`TestCase`) för att representera felet. Om du bara använder "
"standardtestköraren unittest spelar den här detaljen ingen roll, men om du "
"är ramverksförfattare kan det vara relevant."

msgid "setUpClass and tearDownClass"
msgstr "setUpClass och tearDownClass"

msgid "These must be implemented as class methods::"
msgstr "Dessa måste implementeras som klassmetoder::"

msgid ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"
msgstr ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"

msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"Om du vill att ``setUpClass`` och ``tearDownClass`` på basklasser skall "
"anropas måste du själv anropa dem. Implementationerna i :class:`TestCase` är "
"tomma."

msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"Om ett undantag uppstår under en ``setUpClass`` så körs inte testerna i "
"klassen och ``tearDownClass`` körs inte. Klasser som hoppats över kommer "
"inte att få ``setUpClass`` eller ``tearDownClass`` körda. Om undantaget är "
"ett :exc:`SkipTest`-undantag kommer klassen att rapporteras som att den har "
"hoppats över istället för som ett fel."

msgid "setUpModule and tearDownModule"
msgstr "setUpModule och tearDownModule"

msgid "These should be implemented as functions::"
msgstr "Dessa bör implementeras som funktioner::"

msgid ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"
msgstr ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"

msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"Om ett undantag uppstår i en ``setUpModule`` kommer inget av testerna i "
"modulen att köras och ``tearDownModule`` kommer inte att köras. Om "
"undantaget är ett :exc:`SkipTest`-undantag kommer modulen att rapporteras "
"som att den har hoppats över istället för som ett fel."

msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"Om du vill lägga till uppstädningskod som måste köras även vid undantag "
"använder du ``addModuleCleanup``:"

msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
"Lägg till en funktion som ska anropas efter :func:`tearDownModule` för att "
"städa upp resurser som använts under testklassen. Funktioner kommer att "
"anropas i omvänd ordning mot den ordning de läggs till (:abbr:`LIFO (sist "
"in, först ut)`). De anropas med alla argument och nyckelordsargument som "
"skickas in i :meth:`addModuleCleanup` när de läggs till."

msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Om :meth:`setUpModule` misslyckas, vilket innebär att :func:`tearDownModule` "
"inte anropas, så kommer eventuella cleanup-funktioner som lagts till ändå "
"att anropas."

msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Ange den medföljande :term:`context manager`.  Om det lyckas, lägg även till "
"dess :meth:`~object.__exit__`-metod som en uppstädningsfunktion med :func:"
"`addModuleCleanup` och returnera resultatet av :meth:`~object.__enter__`-"
"metoden."

msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"Denna funktion anropas ovillkorligen efter :func:`tearDownModule`, eller "
"efter :func:`setUpModule` om :func:`setUpModule` ger upphov till ett "
"undantag."

msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"Den är ansvarig för att anropa alla upprensningsfunktioner som lagts till "
"av :func:`addModuleCleanup`. Om du vill att rensningsfunktionerna ska "
"anropas *före* :func:`tearDownModule` kan du anropa :func:`doModuleCleanups` "
"själv."

msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` plockar bort metoder från stacken med "
"rensningsfunktioner en i taget, så att den kan anropas när som helst."

msgid "Signal Handling"
msgstr "Signalhantering"

msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"Kommandoradsalternativet :option:`-c/--catch <unittest -c>` till unittest, "
"tillsammans med parametern ``catchbreak`` till :func:`unittest.main`, ger en "
"mer vänlig hantering av kontroll-C under en testkörning. Med catch break-"
"beteendet aktiverat kommer control-C att låta det pågående testet slutföras, "
"och testkörningen kommer sedan att avslutas och rapportera alla resultat så "
"här långt. En andra kontroll-c kommer att ge upphov till en :exc:"
"`KeyboardInterrupt` på vanligt sätt."

msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"Signalhanteraren för kontroll-c försöker vara kompatibel med kod eller "
"tester som installerar sin egen :const:`signal.SIGINT`-hanterare. Om "
"``unittest``-hanteraren anropas men *inte* är den installerade :const:"
"`signal.SIGINT`-hanteraren, d.v.s. den har ersatts av systemet som testas "
"och delegerats till, anropas standardhanteraren. Detta är normalt det "
"förväntade beteendet hos kod som ersätter en installerad hanterare och "
"delegerar till den. För enskilda tester som behöver ``unittest`` kontroll-c "
"hantering inaktiverad kan :func:`removeHandler` dekoratorn användas."

msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Det finns ett fåtal funktioner för ramverksförfattare som gör det möjligt "
"att hantera kontroll-c-funktioner i testramverk."

msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Installera control-c hanteraren. När en :const:`signal.SIGINT` tas emot "
"(vanligtvis som svar på att användaren trycker på control-c) kommer alla "
"registrerade resultat att anropas :meth:`~TestResult.stop`."

msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Registrera ett :class:`TestResult`-objekt för kontrollhantering. Genom att "
"registrera ett resultat lagras en svag referens till det, så det hindrar "
"inte att resultatet samlas in i en soptunna."

msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"Registrering av ett :class:`TestResult`-objekt har inga bieffekter om "
"kontroll-c-hantering inte är aktiverad, så testramverk kan ovillkorligen "
"registrera alla resultat de skapar oberoende av om hantering är aktiverad "
"eller inte."

msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Ta bort ett registrerat resultat. När ett resultat har tagits bort kommer :"
"meth:`~TestResult.stop` inte längre att anropas på det resultatobjektet som "
"svar på ett kontroll-c."

msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
"När den anropas utan argument tar denna funktion bort kontroll-c-hanteraren "
"om den har installerats. Denna funktion kan också användas som en "
"testdekorator för att tillfälligt ta bort hanteraren medan testet körs::"

msgid ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
msgstr ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
