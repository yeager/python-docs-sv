# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!array` --- Efficient arrays of numeric values"
msgstr ":mod:`!array` --- Effektiva arrayer av numeriska värden"

msgid ""
"This module defines an object type which can compactly represent an array of "
"basic values: characters, integers, floating-point numbers.  Arrays are "
"sequence types and behave very much like lists, except that the type of "
"objects stored in them is constrained.  The type is specified at object "
"creation time by using a :dfn:`type code`, which is a single character.  The "
"following type codes are defined:"
msgstr ""
"Denna modul definierar en objekttyp som på ett kompakt sätt kan representera "
"en array av grundläggande värden: tecken, heltal, flyttal.  Arrayer är "
"sekvenstyper och beter sig ungefär som listor, med undantag för att typen av "
"objekt som lagras i dem är begränsad.  Typen anges när objektet skapas med "
"hjälp av en :dfn:`type code`, som är ett enda tecken.  Följande typkoder är "
"definierade:"

msgid "Type code"
msgstr "Typkod"

msgid "C Type"
msgstr "C Type"

msgid "Python Type"
msgstr "Python Type"

msgid "Minimum size in bytes"
msgstr "Minsta storlek i byte"

msgid "Notes"
msgstr "Anteckningar"

msgid "``'b'``"
msgstr "``'b'``"

msgid "signed char"
msgstr "signed char"

msgid "int"
msgstr "int"

msgid "1"
msgstr "1"

msgid "``'B'``"
msgstr "``'B'``"

msgid "unsigned char"
msgstr "unsigned char"

msgid "``'u'``"
msgstr "``'u'``"

msgid "wchar_t"
msgstr "wchar_t"

msgid "Unicode character"
msgstr "Unicode-tecken"

msgid "2"
msgstr "2"

msgid "\\(1)"
msgstr "\\(1)"

msgid "``'w'``"
msgstr "``'w'``"

msgid "Py_UCS4"
msgstr "Py_UCS4"

msgid "4"
msgstr "4"

msgid "``'h'``"
msgstr "``'h'``"

msgid "signed short"
msgstr "signed short"

msgid "``'H'``"
msgstr "``'H'``"

msgid "unsigned short"
msgstr "unsigned short"

msgid "``'i'``"
msgstr "``'i'``"

msgid "signed int"
msgstr "signed int"

msgid "``'I'``"
msgstr "``'I'``"

msgid "unsigned int"
msgstr "unsigned int"

msgid "``'l'``"
msgstr "``'l'``"

msgid "signed long"
msgstr "signed long"

msgid "``'L'``"
msgstr "``'L'``"

msgid "unsigned long"
msgstr "unsigned long"

msgid "``'q'``"
msgstr "``'q'``"

msgid "signed long long"
msgstr "signed long long"

msgid "8"
msgstr "8"

msgid "``'Q'``"
msgstr "``'Q'``"

msgid "unsigned long long"
msgstr "unsigned long long"

msgid "``'f'``"
msgstr "``'f'``"

msgid "float"
msgstr "float"

msgid "``'d'``"
msgstr "``'d'``"

msgid "double"
msgstr "double"

msgid "Notes:"
msgstr "Anteckningar:"

msgid "It can be 16 bits or 32 bits depending on the platform."
msgstr "Den kan vara 16 bitar eller 32 bitar beroende på plattform."

msgid ""
"``array('u')`` now uses :c:type:`wchar_t` as C type instead of deprecated "
"``Py_UNICODE``. This change doesn't affect its behavior because "
"``Py_UNICODE`` is alias of :c:type:`wchar_t` since Python 3.3."
msgstr ""
"``array('u')`` använder nu :c:type:`wchar_t` som C-typ istället för "
"föråldrade ``Py_UNICODE``. Denna ändring påverkar inte dess beteende "
"eftersom ``Py_UNICODE`` är alias för :c:type:`wchar_t` sedan Python 3.3."

msgid "Please migrate to ``'w'`` typecode."
msgstr "Migrera till ``'w'`` typkod."

msgid ""
"The actual representation of values is determined by the machine "
"architecture (strictly speaking, by the C implementation).  The actual size "
"can be accessed through the :attr:`array.itemsize` attribute."
msgstr ""
"Den faktiska representationen av värden bestäms av maskinarkitekturen "
"(strängt taget av C-implementeringen).  Den faktiska storleken kan nås via "
"attributet :attr:`array.itemsize`."

msgid "The module defines the following item:"
msgstr "Modulen definierar följande objekt:"

msgid "A string with all available type codes."
msgstr "En sträng med alla tillgängliga typkoder."

msgid "The module defines the following type:"
msgstr "Modulen definierar följande typ:"

msgid ""
"A new array whose items are restricted by *typecode*, and initialized from "
"the optional *initializer* value, which must be a :class:`bytes` or :class:"
"`bytearray` object, a Unicode string, or iterable over elements of the "
"appropriate type."
msgstr ""
"En ny array vars element begränsas av *typecode* och initieras från det "
"valfria värdet *initializer*, som måste vara ett :class:`bytes`- eller :"
"class:`bytearray`-objekt, en Unicode-sträng eller en iterabel över element "
"av lämplig typ."

msgid ""
"If given a :class:`bytes` or :class:`bytearray` object, the initializer is "
"passed to the new array's :meth:`frombytes` method; if given a Unicode "
"string, the initializer is passed to the :meth:`fromunicode` method; "
"otherwise, the initializer's iterator is passed to the :meth:`extend` method "
"to add initial items to the array."
msgstr ""
"Om den ges ett :class:`bytes` eller :class:`bytearray`-objekt skickas "
"initialiseraren till den nya arrayens :meth:`frombytes`-metod; om den ges en "
"Unicode-sträng skickas initialiseraren till :meth:`fromunicode`-metoden; "
"annars skickas initialiserarens iterator till :meth:`extend`-metoden för att "
"lägga till initiala objekt i arrayen."

msgid ""
"Array objects support the ordinary sequence operations of indexing, slicing, "
"concatenation, and multiplication.  When using slice assignment, the "
"assigned value must be an array object with the same type code; in all other "
"cases, :exc:`TypeError` is raised. Array objects also implement the buffer "
"interface, and may be used wherever :term:`bytes-like objects <bytes-like "
"object>` are supported."
msgstr ""
"Array-objekt stöder de vanliga sekvensoperationerna indexering, skivning, "
"konkatenering och multiplicering.  Vid användning av slice assignment måste "
"det tilldelade värdet vara ett array-objekt med samma typkod; i alla andra "
"fall uppstår :exc:`TypeError`. Array-objekt implementerar också "
"buffertgränssnittet och kan användas överallt där :term:`bytesliknande "
"objekt <bytes-like object>` stöds."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``array.__new__`` with arguments "
"``typecode``, ``initializer``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``array.__new__`` med argumenten "
"``typecode``, ``initializer``."

msgid "The typecode character used to create the array."
msgstr "Typkodstecknet som användes för att skapa arrayen."

msgid "The length in bytes of one array item in the internal representation."
msgstr "Längden i byte för ett arrayobjekt i den interna representationen."

msgid "Append a new item with value *x* to the end of the array."
msgstr "Lägg till ett nytt objekt med värdet *x* i slutet av arrayen."

msgid ""
"Return a tuple ``(address, length)`` giving the current memory address and "
"the length in elements of the buffer used to hold array's contents.  The "
"size of the memory buffer in bytes can be computed as ``array.buffer_info()"
"[1] * array.itemsize``.  This is occasionally useful when working with low-"
"level (and inherently unsafe) I/O interfaces that require memory addresses, "
"such as certain :c:func:`!ioctl` operations.  The returned numbers are valid "
"as long as the array exists and no length-changing operations are applied to "
"it."
msgstr ""
"Returnerar en tupel ``(adress, längd)`` som ger den aktuella minnesadressen "
"och längden i element för den buffert som används för att hålla arrayens "
"innehåll.  Storleken på minnesbufferten i byte kan beräknas som ``array."
"buffer_info()[1] * array.itemsize``.  Detta är ibland användbart när man "
"arbetar med lågnivå (och i sig osäkra) I/O-gränssnitt som kräver "
"minnesadresser, t.ex. vissa :c:func:`!ioctl`-operationer.  De returnerade "
"siffrorna är giltiga så länge som arrayen existerar och inga "
"längdförändrande operationer tillämpas på den."

msgid ""
"When using array objects from code written in C or C++ (the only way to "
"effectively make use of this information), it makes more sense to use the "
"buffer interface supported by array objects.  This method is maintained for "
"backward compatibility and should be avoided in new code.  The buffer "
"interface is documented in :ref:`bufferobjects`."
msgstr ""
"När du använder array-objekt från kod skriven i C eller C++ (det enda sättet "
"att effektivt använda denna information) är det mer meningsfullt att använda "
"buffertgränssnittet som stöds av array-objekt.  Denna metod bibehålls för "
"bakåtkompatibilitet och bör undvikas i ny kod.  Buffertgränssnittet finns "
"dokumenterat i :ref:`bufferobjects`."

msgid ""
"\"Byteswap\" all items of the array.  This is only supported for values "
"which are 1, 2, 4, or 8 bytes in size; for other types of values, :exc:"
"`RuntimeError` is raised.  It is useful when reading data from a file "
"written on a machine with a different byte order."
msgstr ""
"\"Byteswap\" alla objekt i arrayen.  Detta stöds endast för värden som är 1, "
"2, 4 eller 8 byte stora; för andra typer av värden uppstår :exc:"
"`RuntimeError`.  Det är användbart när man läser data från en fil som "
"skrivits på en maskin med en annan byteordning."

msgid "Return the number of occurrences of *x* in the array."
msgstr "Returnerar antalet förekomster av *x* i arrayen."

msgid ""
"Append items from *iterable* to the end of the array.  If *iterable* is "
"another array, it must have *exactly* the same type code; if not, :exc:"
"`TypeError` will be raised.  If *iterable* is not an array, it must be "
"iterable and its elements must be the right type to be appended to the array."
msgstr ""
"Lägger till objekt från *iterable* till slutet av arrayen.  Om *iterable* är "
"en annan array, måste den ha *exakt* samma typkod; om inte, kommer :exc:"
"`TypeError` att tas upp.  Om *iterable* inte är en array måste den vara "
"iterabel och dess element måste vara av rätt typ för att kunna läggas till i "
"arrayen."

msgid ""
"Appends items from the :term:`bytes-like object`, interpreting its content "
"as an array of machine values (as if it had been read from a file using the :"
"meth:`fromfile` method)."
msgstr ""
"Lägger till objekt från :term:`bytes-like object` och tolkar dess innehåll "
"som en array av maskinvärden (som om det hade lästs från en fil med metoden :"
"meth:`fromfile`)."

msgid ":meth:`!fromstring` is renamed to :meth:`frombytes` for clarity."
msgstr ""
":meth:`!fromstring` byter namn till :meth:`frombytes` för tydlighetens skull."

msgid ""
"Read *n* items (as machine values) from the :term:`file object` *f* and "
"append them to the end of the array.  If less than *n* items are available, :"
"exc:`EOFError` is raised, but the items that were available are still "
"inserted into the array."
msgstr ""
"Läser *n* objekt (som maskinvärden) från :term:`filobjektet` *f* och lägger "
"till dem i slutet av arrayen.  Om färre än *n* objekt är tillgängliga, "
"genereras :exc:`EOFError`, men de objekt som var tillgängliga infogas "
"fortfarande i arrayen."

msgid ""
"Append items from the list.  This is equivalent to ``for x in list: a."
"append(x)`` except that if there is a type error, the array is unchanged."
msgstr ""
"Lägger till objekt från listan.  Detta är likvärdigt med ``for x in list: a."
"append(x)`` förutom att om det finns ett typfel är arrayen oförändrad."

msgid ""
"Extends this array with data from the given Unicode string. The array must "
"have type code ``'u'`` or ``'w'``; otherwise a :exc:`ValueError` is raised. "
"Use ``array.frombytes(unicodestring.encode(enc))`` to append Unicode data to "
"an array of some other type."
msgstr ""
"Utökar denna array med data från den angivna Unicode-strängen. Arrayen måste "
"ha typkoden ``'u'`` eller ``'w'``; annars uppstår ett :exc:`ValueError`. "
"Använd ``array.frombytes(unicodestring.encode(enc))`` för att lägga till "
"Unicode-data till en array av någon annan typ."

msgid ""
"Return the smallest *i* such that *i* is the index of the first occurrence "
"of *x* in the array.  The optional arguments *start* and *stop* can be "
"specified to search for *x* within a subsection of the array.  Raise :exc:"
"`ValueError` if *x* is not found."
msgstr ""
"Returnerar den minsta *i* så att *i* är index för den första förekomsten av "
"*x* i arrayen.  De valfria argumenten *start* och *stop* kan anges för att "
"söka efter *x* inom en underavdelning av arrayen.  Utlöser :exc:`ValueError` "
"om *x* inte hittas."

msgid "Added optional *start* and *stop* parameters."
msgstr "Valfria parametrar *start* och *stop* har lagts till."

msgid ""
"Insert a new item with value *x* in the array before position *i*. Negative "
"values are treated as being relative to the end of the array."
msgstr ""
"Infoga ett nytt objekt med värdet *x* i arrayen före position *i*. Negativa "
"värden behandlas som relativa till slutet av arrayen."

msgid ""
"Removes the item with the index *i* from the array and returns it. The "
"optional argument defaults to ``-1``, so that by default the last item is "
"removed and returned."
msgstr ""
"Tar bort objektet med index *i* från arrayen och returnerar det. Det valfria "
"argumentet är som standard ``-1``, så att det sista objektet som standard "
"tas bort och returneras."

msgid "Remove the first occurrence of *x* from the array."
msgstr "Ta bort den första förekomsten av *x* från arrayen."

msgid "Remove all elements from the array."
msgstr "Ta bort alla element från arrayen."

msgid "Reverse the order of the items in the array."
msgstr "Omvänd ordning på objekten i arrayen."

msgid ""
"Convert the array to an array of machine values and return the bytes "
"representation (the same sequence of bytes that would be written to a file "
"by the :meth:`tofile` method.)"
msgstr ""
"Omvandla arrayen till en array med maskinvärden och returnera "
"bytesrepresentationen (samma sekvens av bytes som skulle skrivas till en fil "
"med metoden :meth:`tofile`)"

msgid ":meth:`!tostring` is renamed to :meth:`tobytes` for clarity."
msgstr ""
":meth:`!tostring` byter namn till :meth:`tobytes` för tydlighetens skull."

msgid "Write all items (as machine values) to the :term:`file object` *f*."
msgstr "Skriv alla objekt (som maskinvärden) till :term:`file object` *f*."

msgid "Convert the array to an ordinary list with the same items."
msgstr "Omvandla arrayen till en vanlig lista med samma objekt."

msgid ""
"Convert the array to a Unicode string.  The array must have a type ``'u'`` "
"or ``'w'``; otherwise a :exc:`ValueError` is raised. Use ``array.tobytes()."
"decode(enc)`` to obtain a Unicode string from an array of some other type."
msgstr ""
"Konverterar arrayen till en Unicode-sträng.  Arrayen måste vara av typen "
"``'u'`` eller ``'w'``, annars uppstår ett :exc:`ValueError`. Använd ``array."
"tobytes().decode(enc)`` för att få en Unicode-sträng från en array av någon "
"annan typ."

msgid ""
"The string representation of array objects has the form ``array(typecode, "
"initializer)``. The *initializer* is omitted if the array is empty, "
"otherwise it is a Unicode string if the *typecode* is ``'u'`` or ``'w'``, "
"otherwise it is a list of numbers. The string representation is guaranteed "
"to be able to be converted back to an array with the same type and value "
"using :func:`eval`, so long as the :class:`~array.array` class has been "
"imported using ``from array import array``. Variables ``inf`` and ``nan`` "
"must also be defined if it contains corresponding floating-point values. "
"Examples::"
msgstr ""
"Strängrepresentationen av array-objekt har formen ``array(typecode, "
"initializer)``. *initialiseraren* utelämnas om arrayen är tom, annars är det "
"en Unicode-sträng om *typkoden* är ``'u'`` eller ``'w'``, annars är det en "
"lista med siffror. Strängrepresentationen kan garanterat konverteras "
"tillbaka till en array med samma typ och värde med hjälp av :func:`eval`, så "
"länge som klassen :class:`~array.array` har importerats med ``from array "
"import array``. Variablerna ``inf`` och ``nan`` måste också definieras om de "
"innehåller motsvarande värden i flyttal. Exempel::"

msgid ""
"array('l')\n"
"array('w', 'hello \\u2641')\n"
"array('l', [1, 2, 3, 4, 5])\n"
"array('d', [1.0, 2.0, 3.14, -inf, nan])"
msgstr ""
"array('l')\n"
"array('w', 'hej \\u2641')\n"
"array('l', [1, 2, 3, 4, 5])\n"
"array('d', [1,0, 2,0, 3,14, -inf, nan])"

msgid "Module :mod:`struct`"
msgstr "Modul :mod:`struct`"

msgid "Packing and unpacking of heterogeneous binary data."
msgstr "Packning och uppackning av heterogena binära data."

msgid "`NumPy <https://numpy.org/>`_"
msgstr "`NumPy <https://numpy.org/>`_"

msgid "The NumPy package defines another array type."
msgstr "NumPy-paketet definierar en annan array-typ."

msgid "arrays"
msgstr "arrays"
