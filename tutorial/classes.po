# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-09 14:17+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Classes"
msgstr "Klasser"

msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Klasser är ett sätt att paketera data och funktionalitet tillsammans.  Genom "
"att skapa en ny klass skapas en ny *typ* av objekt, vilket gör det möjligt "
"att skapa nya *instanser* av den typen.  Varje klassinstans kan ha attribut "
"kopplade till sig för att bibehålla sitt tillstånd.  Klassinstanser kan "
"också ha metoder (definierade av klassen) för att ändra sitt tillstånd."

msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Jämfört med andra programmeringsspråk lägger Pythons klassmekanism till "
"klasser med ett minimum av ny syntax och semantik.  Det är en blandning av "
"de klassmekanismer som finns i C++ och Modula-3.  Python-klasser har alla "
"standardfunktioner för objektorienterad programmering: klassens arvsmekanism "
"tillåter flera basklasser, en härledd klass kan åsidosätta alla metoder i "
"sin basklass eller sina basklasser och en metod kan anropa metoden i en "
"basklass med samma namn.  Objekt kan innehålla godtyckliga mängder och typer "
"av data.  Precis som för moduler är klasser en del av Pythons dynamiska "
"natur: de skapas under körning och kan modifieras ytterligare efter "
"skapandet."

msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"I C++-terminologi är klassmedlemmar (inklusive datamedlemmar) normalt "
"*public* (utom se nedan :ref:`tut-private`) och alla medlemsfunktioner är "
"*virtuella*.  Precis som i Modula-3 finns det inga kortkommandon för att "
"referera till objektets medlemmar från dess metoder: metodfunktionen "
"deklareras med ett explicit första argument som representerar objektet, "
"vilket tillhandahålls implicit av anropet.  Precis som i Smalltalk är "
"klasserna i sig själva objekt.  Detta ger semantik för import och "
"namnändring.  Till skillnad från C++ och Modula-3 kan inbyggda typer "
"användas som basklasser för utvidgning av användaren.  Precis som i C++ kan "
"de flesta inbyggda operatorer med speciell syntax (aritmetiska operatorer, "
"subskription etc.) omdefinieras för klassinstanser."

msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(I brist på allmänt accepterad terminologi för att tala om klasser kommer "
"jag ibland att använda Smalltalk- och C++-termer.  Jag skulle använda "
"Modula-3-termer, eftersom dess objektorienterade semantik ligger närmare "
"Python än C++, men jag förväntar mig att få läsare har hört talas om det)"

msgid "A Word About Names and Objects"
msgstr "Några ord om namn och objekt"

msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Objekten är individuella och flera namn (i flera scopes) kan bindas till "
"samma objekt.  Detta är känt som aliasing i andra språk.  Detta uppskattas "
"vanligtvis inte vid en första anblick av Python, och kan säkert ignoreras "
"när man hanterar oföränderliga bastyper (tal, strängar, tupler).  Aliasing "
"har dock en möjligen överraskande effekt på semantiken i Python-kod som "
"involverar föränderliga objekt som listor, ordböcker och de flesta andra "
"typer. Detta används vanligtvis till förmån för programmet, eftersom alias "
"beter sig som pekare i vissa avseenden.  Till exempel är det billigt att "
"skicka ett objekt eftersom endast en pekare skickas av implementationen; och "
"om en funktion ändrar ett objekt som skickas som ett argument kommer den som "
"anropar att se förändringen --- detta eliminerar behovet av två olika "
"mekanismer för argumentpassning som i Pascal."

msgid "Python Scopes and Namespaces"
msgstr "Python Scopes och namnområden"

msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Innan jag introducerar klasser måste jag först berätta något om Pythons "
"scope-regler.  Klassdefinitioner spelar några snygga trick med namnrymder, "
"och du måste veta hur scopes och namnrymder fungerar för att förstå vad som "
"händer. För övrigt är kunskap om detta ämne användbart för alla avancerade "
"Python-programmerare."

msgid "Let's begin with some definitions."
msgstr "Låt oss börja med några definitioner."

msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"En *namnrymd* är en mappning från namn till objekt.  De flesta namnrymder är "
"för närvarande implementerade som Python-ordlistor, men det är normalt inte "
"märkbart på något sätt (förutom prestanda), och det kan ändras i framtiden.  "
"Exempel på namnrymder är: uppsättningen inbyggda namn (som innehåller "
"funktioner som :func:`abs` och inbyggda namn på undantag), de globala namnen "
"i en modul och de lokala namnen i en funktionsinstruktion.  På sätt och vis "
"utgör också uppsättningen av attribut för ett objekt ett namnområde.  Det "
"viktiga att veta om namnrymder är att det inte finns någon som helst "
"relation mellan namn i olika namnrymder; till exempel kan två olika moduler "
"båda definiera en funktion ``maximize`` utan förvirring --- användare av "
"modulerna måste prefixera den med modulnamnet."

msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"Förresten, jag använder ordet *attribut* för alla namn som följer efter en "
"punkt --- till exempel, i uttrycket ``z.real`` är ``real`` ett attribut för "
"objektet ``z``.  I strikt mening är referenser till namn i moduler "
"attributreferenser: i uttrycket ``modname.funcname`` är ``modname`` ett "
"modulobjekt och ``funcname`` är ett attribut till det.  I det här fallet "
"råkar det finnas en enkel mappning mellan modulens attribut och de globala "
"namn som definieras i modulen: de delar samma namnrymd!  "

msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"Attributen kan vara skrivskyddade eller skrivbara.  I det senare fallet är "
"det möjligt att tilldela attribut.  Modulattribut är skrivbara: du kan "
"skriva ``modname.the_answer = 42``.  Skrivbara attribut kan också tas bort "
"med :keyword:`del`.  Till exempel, ``del modname.the_answer`` kommer att ta "
"bort attributet :attr:`!the_answer` från objektet som heter ``modname``."

msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Namnrymder skapas vid olika tidpunkter och har olika livslängd.  Namnrymden "
"som innehåller de inbyggda namnen skapas när Python-tolken startar och "
"raderas aldrig.  Det globala namnrymden för en modul skapas när "
"moduldefinitionen läses in; normalt varar modulnamnrymder också tills tolken "
"avslutas.  De satser som utförs av tolkens anrop på toppnivå, antingen "
"inlästa från en skriptfil eller interaktivt, betraktas som en del av en "
"modul som heter :mod:`__main__`, och de har därför ett eget globalt "
"namnområde.  (De inbyggda namnen finns faktiskt också i en modul; denna "
"kallas :mod:`builtins`)"

msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"Det lokala namnrymden för en funktion skapas när funktionen anropas och "
"raderas när funktionen returneras eller ger upphov till ett undantag som "
"inte hanteras inom funktionen.  (Egentligen skulle \"glömma\" vara ett "
"bättre sätt att beskriva vad som faktiskt händer)  Naturligtvis har "
"rekursiva anrop alla sina egna lokala namnrymder."

msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"En *scope* är en textuell region i ett Python-program där en namnrymd är "
"direkt åtkomlig.  \"Direkt åtkomlig\" betyder här att en okvalificerad "
"referens till ett namn försöker hitta namnet i namnrymden."

msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"Även om scopes bestäms statiskt används de dynamiskt. När som helst under "
"exekveringen finns det 3 eller 4 nästlade scopes vars namnrymder är direkt "
"åtkomliga:"

msgid "the innermost scope, which is searched first, contains the local names"
msgstr "det innersta omfånget, som söks först, innehåller de lokala namnen"

msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"scopen för alla inneslutande funktioner, som genomsöks med början från "
"närmaste inneslutande scope, innehåller icke-lokala, men även icke-globala "
"namn"

msgid "the next-to-last scope contains the current module's global names"
msgstr "det näst sista omfånget innehåller den aktuella modulens globala namn"

msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"det yttersta omfånget (söks sist) är namnrymden som innehåller inbyggda namn"

msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Om ett namn deklareras som globalt, går alla referenser och tilldelningar "
"direkt till det näst sista scope som innehåller modulens globala namn.  För "
"att återbinda variabler som finns utanför det innersta scopet kan :keyword:"
"`nonlocal` användas; om de inte deklareras som icke-lokala är dessa "
"variabler skrivskyddade (ett försök att skriva till en sådan variabel skapar "
"helt enkelt en *ny* lokal variabel i det innersta scopet, medan den "
"identiskt namngivna yttre variabeln lämnas oförändrad)."

msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Vanligtvis refererar det lokala omfånget till de lokala namnen på den "
"(textuellt) aktuella funktionen.  Utanför funktioner refererar det lokala "
"omfånget till samma namnrymd som det globala omfånget: modulens namnrymd. "
"Klassdefinitioner placerar ytterligare en namnrymd i det lokala omfånget."

msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Det är viktigt att inse att omfattningar bestäms textuellt: den globala "
"omfattningen av en funktion som definieras i en modul är den modulens "
"namnrymd, oavsett varifrån eller med vilket alias funktionen anropas.  Å "
"andra sidan görs den faktiska sökningen efter namn dynamiskt, vid körning "
"--- språkdefinitionen utvecklas dock mot statisk namnupplösning, vid "
"\"kompileringstid\", så lita inte på dynamisk namnupplösning!  (Faktum är "
"att lokala variabler redan bestäms statiskt)"

msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"En speciell finess med Python är att -- om inget :keyword:`global` eller :"
"keyword:`nonlocal` statement är i kraft -- assignments till namn alltid går "
"in i det innersta scope. Tilldelningar kopierar inte data --- de binder bara "
"namn till objekt.  Detsamma gäller för borttagningar: uttalandet ``del x`` "
"tar bort bindningen av ``x`` från det namnområde som refereras av det lokala "
"scopet.  Faktum är att alla operationer som introducerar nya namn använder "
"det lokala omfånget: i synnerhet :keyword:`import`-satser och "
"funktionsdefinitioner binder modul- eller funktionsnamnet i det lokala "
"omfånget."

msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"Satsen :keyword:`global` kan användas för att ange att vissa variabler finns "
"i det globala omfånget och bör återföras dit; satsen :keyword:`nonlocal` "
"anger att vissa variabler finns i ett omslutande omfång och bör återföras "
"dit."

msgid "Scopes and Namespaces Example"
msgstr "Exempel på scopes och namnområden"

msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Detta är ett exempel som visar hur man refererar till olika scopes och "
"namnområden, och hur :keyword:`global` och :keyword:`nonlocal` påverkar "
"variabelbindning::"

msgid ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"
msgstr ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"lokal spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        icke-lokalt skräppost\n"
"        spam = \"icke-lokalt skräppost\"\n"
"\n"
"    def do_global():\n"
"        global skräppost\n"
"        spam = \"global skräppost\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"Efter lokal tilldelning:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"Efter icke-lokal tilldelning:\", spam)\n"
"    do_global()\n"
"    print(\"Efter global tilldelning:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"I global omfattning:\", spam)"

msgid "The output of the example code is:"
msgstr "Utmatningen av exempelkoden är:"

msgid ""
"After local assignment: test spam\n"
"After nonlocal assignment: nonlocal spam\n"
"After global assignment: nonlocal spam\n"
"In global scope: global spam"
msgstr ""
"Efter lokalt uppdrag: test spam\n"
"Efter icke-lokalt uppdrag: icke-lokalt spam\n"
"Efter global tilldelning: icke-lokalt spam\n"
"I global omfattning: global skräppost"

msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"Observera att *local*-tilldelningen (som är standard) inte ändrade "
"*scope_test*:s bindning av *spam*.  Tilldelningen :keyword:`nonlocal` "
"ändrade *scope_test*:s bindning av *spam*, och tilldelningen :keyword:"
"`global` ändrade bindningen på modulnivå."

msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"Du kan också se att det inte fanns någon tidigare bindning för *spam* före "
"tilldelningen :keyword:`global`."

msgid "A First Look at Classes"
msgstr "En första titt på klasserna"

msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Classes introducerar lite ny syntax, tre nya objekttyper och en del ny "
"semantik."

msgid "Class Definition Syntax"
msgstr "Klassdefinition Syntax"

msgid "The simplest form of class definition looks like this::"
msgstr "Den enklaste formen av klassdefinition ser ut så här::"

msgid ""
"class ClassName:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"klass Klassnamn:\n"
"   <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"   <statement-N>"

msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Klassdefinitioner måste, precis som funktionsdefinitioner (:keyword:`def`-"
"satser), exekveras innan de får någon effekt.  (Man skulle kunna tänka sig "
"att placera en klassdefinition i en gren av en :keyword:`if`-sats, eller "
"inuti en funktion)"

msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"I praktiken är satserna i en klassdefinition oftast funktionsdefinitioner, "
"men andra satser är tillåtna och ibland användbara --- vi återkommer till "
"detta senare.  Funktionsdefinitionerna i en klass har normalt en speciell "
"form av argumentlista, dikterad av anropskonventionerna för metoder --- "
"återigen, detta förklaras senare."

msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"När en klassdefinition skrivs in skapas ett nytt namnområde som används som "
"det lokala området --- alla tilldelningar till lokala variabler går alltså "
"till detta nya namnområde.  I synnerhet funktionsdefinitioner binder namnet "
"på den nya funktionen här."

msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""
"När en klassdefinition lämnas på normalt sätt (via slutet) skapas ett "
"*klassobjekt*.  Detta är i princip ett omslag runt innehållet i det namnrymd "
"som skapats av klassdefinitionen; vi lär oss mer om klassobjekt i nästa "
"avsnitt.  Det ursprungliga lokala omfånget (det som gällde precis innan "
"klassdefinitionen skrevs in) återställs och klassobjektet binds här till det "
"klassnamn som anges i klassdefinitionens rubrik (:class:`!ClassName` i "
"exemplet)."

msgid "Class Objects"
msgstr "Klassobjekt"

msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Klassobjekt stöder två typer av operationer: attributreferenser och "
"instansiering."

msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Attributreferenser* använder den standardsyntax som används för alla "
"attributreferenser i Python: ``obj.name``.  Giltiga attributnamn är alla de "
"namn som fanns i klassens namnrymd när klassobjektet skapades.  Så, om "
"klassdefinitionen såg ut så här::"

msgid ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"
msgstr ""
"klass MyClass:\n"
"    \"\"\"En enkel exempelklass\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hej världen'"

msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`~type.__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"så är ``MyClass.i`` och ``MyClass.f`` giltiga attributreferenser, som "
"returnerar ett heltal respektive ett funktionsobjekt. Klassattribut kan "
"också tilldelas, så du kan ändra värdet på ``MyClass.i`` genom tilldelning. :"
"attr:`~type.__doc__` är också ett giltigt attribut, som returnerar den "
"dokumentsträng som tillhör klassen: ``\"En enkel exempelklass\"``."

msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"Klass *instantiering* använder funktionsnotation.  Låtsas bara att "
"klassobjektet är en parameterlös funktion som returnerar en ny instans av "
"klassen. Till exempel (med antagande av ovanstående klass)::"

msgid "x = MyClass()"
msgstr "x = MyClass()"

msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"skapar en ny *instans* av klassen och tilldelar detta objekt till den lokala "
"variabeln ``x``."

msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""
"Instantiering (\"anrop\" av ett klassobjekt) skapar ett tomt objekt. Många "
"klasser vill skapa objekt med instanser som är anpassade till ett visst "
"initialt tillstånd. Därför kan en klass definiera en speciell metod med "
"namnet :meth:`~object.__init__`, så här::"

msgid ""
"def __init__(self):\n"
"    self.data = []"
msgstr ""
"def __init__(self):\n"
"    self.data = []"

msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"När en klass definierar en :meth:`~object.__init__`-metod, anropar "
"klassinstantiering automatiskt :meth:`!__init__` för den nyskapade "
"klassinstansen.  Så i det här exemplet kan en ny, initialiserad instans "
"erhållas genom att::"

msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"Naturligtvis kan metoden :meth:`~object.__init__` ha argument för större "
"flexibilitet.  I så fall skickas de argument som ges till operatorn för "
"klassinstantiering vidare till :meth:`!__init__`.  Till exempel ::"

msgid ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"
msgstr ""
">>> klass Komplex:\n"
"... def __init__(self, realpart, imagpart):\n"
"... self.r = realpart\n"
"... self.i = imagpart\n"
"...\n"
">>> x = Komplex(3,0, -4,5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"

msgid "Instance Objects"
msgstr "Instansobjekt"

msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Vad kan vi nu göra med instansobjekt?  De enda operationer som förstås av "
"instansobjekt är attributreferenser.  Det finns två typer av giltiga "
"attributnamn: dataattribut och metoder."

msgid ""
"*Data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*Dataattribut* motsvarar \"instansvariabler\" i Smalltalk och "
"\"datamedlemmar\" i C++.  Dataattribut behöver inte deklareras; precis som "
"lokala variabler uppstår de när de först tilldelas.  Om till exempel ``x`` "
"är instansen av :class:`!MyClass` som skapades ovan, kommer följande kod att "
"skriva ut värdet ``16``, utan att lämna några spår::"

msgid ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"
msgstr ""
"x.counter = 1\n"
"medan x.counter < 10:\n"
"    x.räknare = x.räknare * 2\n"
"print(x.räknare)\n"
"radera x.räknare"

msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object."
msgstr ""
"Den andra typen av instansattributreferens är en *metod*. En metod är en "
"funktion som \"hör till\" ett objekt."

msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Giltiga metodnamn för ett instansobjekt beror på dess klass.  Per definition "
"definierar alla attribut för en klass som är funktionsobjekt motsvarande "
"metoder för dess instanser.  Så i vårt exempel är ``x.f`` en giltig "
"metodreferens, eftersom ``MyClass.f`` är en funktion, men ``x.i`` är det "
"inte, eftersom ``MyClass.i`` inte är det.  Men ``x.f`` är inte samma sak som "
"``MyClass.f`` --- det är ett *metodobjekt*, inte ett funktionsobjekt."

msgid "Method Objects"
msgstr "Metod Objekt"

msgid "Usually, a method is called right after it is bound::"
msgstr "Vanligtvis anropas en metod direkt efter att den har bundits::"

msgid "x.f()"
msgstr "x.f()"

msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"I exemplet :class:`!MyClass` kommer detta att returnera strängen ``'hello "
"world'``. Det är dock inte nödvändigt att anropa en metod direkt: ``x.f`` är "
"ett metodobjekt som kan sparas och anropas vid ett senare tillfälle.  Till "
"exempel::"

msgid ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"
msgstr ""
"xf = x.f\n"
"medan True:\n"
"    print(xf())"

msgid "will continue to print ``hello world`` until the end of time."
msgstr "kommer att fortsätta att skriva ut \"Hello World\" till tidens ände."

msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"Vad händer egentligen när en metod anropas?  Du kanske har lagt märke till "
"att ``x.f()`` anropades utan argument ovan, trots att funktionsdefinitionen "
"för :meth:`!f` angav ett argument.  Vad hände med argumentet? Python gör väl "
"ett undantag när en funktion som kräver ett argument anropas utan något --- "
"även om argumentet faktiskt inte används..."

msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"Egentligen har du kanske gissat svaret: det speciella med metoder är att "
"instansobjektet skickas som funktionens första argument.  I vårt exempel är "
"anropet ``x.f()`` exakt likvärdigt med ``MyClass.f(x)``.  I allmänhet är "
"anrop av en metod med en lista med *n* argument likvärdigt med anrop av "
"motsvarande funktion med en argumentlista som skapas genom att infoga "
"metodens instansobjekt före det första argumentet."

msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""
"I allmänhet fungerar metoder på följande sätt.  När ett icke-dataattribut "
"för en instans refereras, söks instansens klass. Om namnet anger ett giltigt "
"klassattribut som är ett funktionsobjekt, packas referenser till både "
"instansobjektet och funktionsobjektet in i ett metodobjekt.  När "
"metodobjektet anropas med en argumentlista, konstrueras en ny argumentlista "
"av instansobjektet och argumentlistan, och funktionsobjektet anropas med "
"denna nya argumentlista."

msgid "Class and Instance Variables"
msgstr "Klass- och instansvariabler"

msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"Generellt sett är instansvariabler för data som är unika för varje instans "
"och klassvariabler för attribut och metoder som delas av alla instanser av "
"klassen::"

msgid ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"
msgstr ""
"klass Hund:\n"
"\n"
"    kind = \"canine\" # klassvariabel som delas av alla instanser\n"
"\n"
"    def __init__(self, namn):\n"
"        self.name = name # instansvariabel som är unik för varje instans\n"
"\n"
">>> d = Hund('Fido')\n"
">>> e = Hund('Buddy')\n"
">>> d.kind # delas av alla hundar\n"
"'canine'\n"
">>> e.kind # delas av alla hundar\n"
"'canine'\n"
">>> d.name # unikt för d\n"
"'Fido'\n"
">>> e.name # unikt för e\n"
"'Buddy'"

msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Som diskuterats i :ref:`tut-object` kan delade data ha överraskande effekter "
"när det gäller :term:`mutable`-objekt som listor och ordböcker. Till exempel "
"bör listan *tricks* i följande kod inte användas som en klassvariabel "
"eftersom bara en enda lista skulle delas av alla *Dog*-instanser::"

msgid ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"
msgstr ""
"klass Hund:\n"
"\n"
"    tricks = [] # felaktig användning av en klassvariabel\n"
"\n"
"    def __init__(self, namn):\n"
"        self.name = namn\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Hund('Fido')\n"
">>> e = Hund('Buddy')\n"
">>> d.add_trick('rulla över')\n"
">>> e.add_trick('spela död')\n"
">>> d.tricks # delas oväntat av alla hundar\n"
"['roll over', 'play dead']"

msgid "Correct design of the class should use an instance variable instead::"
msgstr "Korrekt design av klassen bör använda en instansvariabel istället::"

msgid ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"
msgstr ""
"klass Hund:\n"
"\n"
"    def __init__(self, namn):\n"
"        self.name = namn\n"
"        self.tricks = [] # skapar en ny tom lista för varje hund\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Hund('Fido')\n"
">>> e = Hund('Buddy')\n"
">>> d.add_trick('rulla över')\n"
">>> e.add_trick('spela död')\n"
">>> d.tricks\n"
"['vält']\n"
">>> e.tricks\n"
"['spela död']"

msgid "Random Remarks"
msgstr "Slumpmässiga kommentarer"

msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Om samma attributnamn förekommer både i en instans och i en klass, "
"prioriterar attributuppslagningen instansen::"

msgid ""
">>> class Warehouse:\n"
"...    purpose = 'storage'\n"
"...    region = 'west'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"storage west\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'east'\n"
">>> print(w2.purpose, w2.region)\n"
"storage east"
msgstr ""
">>> klass Lager:\n"
"... ändamål = 'förvaring'\n"
"... region = 'väst'\n"
"...\n"
">>> w1 = Lager()\n"
">>> print(w1.purpose, w1.region)\n"
"förvaring väst\n"
">>> w2 = Lager()\n"
">>> w2.region = 'öst'\n"
">>> print(w2.syfte, w2.region)\n"
"förvaring öst"

msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Dataattribut kan refereras till av metoder såväl som av vanliga användare "
"(\"klienter\") av ett objekt.  Med andra ord är klasser inte användbara för "
"att implementera rena abstrakta datatyper.  Faktum är att ingenting i Python "
"gör det möjligt att genomdriva datahölje --- allt är baserat på konvention.  "
"(Å andra sidan kan Python-implementationen, skriven i C, helt dölja "
"implementationsdetaljer och kontrollera åtkomst till ett objekt om det "
"behövs; detta kan användas av tillägg till Python skrivna i C.)"

msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Klienter bör använda dataattribut med försiktighet --- klienter kan förstöra "
"invarianter som upprätthålls av metoderna genom att stämpla på sina "
"dataattribut.  Observera att klienter kan lägga till egna dataattribut till "
"ett instansobjekt utan att påverka metodernas giltighet, så länge "
"namnkonflikter undviks --- återigen kan en namngivningskonvention spara "
"mycket huvudvärk här."

msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Det finns ingen förkortning för att referera till dataattribut (eller andra "
"metoder!) inom metoder.  Jag tycker att detta faktiskt ökar metodernas "
"läsbarhet: det finns ingen risk för att man blandar ihop lokala variabler "
"och instansvariabler när man tittar igenom en metod."

msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Ofta kallas det första argumentet i en metod för ``self``.  Detta är inget "
"annat än en konvention: namnet ``self`` har absolut ingen speciell betydelse "
"för Python.  Observera dock att om du inte följer konventionen kan din kod "
"vara mindre läsbar för andra Python-programmerare, och det är också tänkbart "
"att ett *class browser*-program kan skrivas som förlitar sig på en sådan "
"konvention."

msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Varje funktionsobjekt som är ett klassattribut definierar en metod för "
"instanser av den klassen.  Det är inte nödvändigt att funktionsdefinitionen "
"är textuellt innesluten i klassdefinitionen: att tilldela ett "
"funktionsobjekt till en lokal variabel i klassen är också ok.  Till exempel::"

msgid ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"
msgstr ""
"# Funktion definierad utanför klassen\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"klassen C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hej världen'\n"
"\n"
"    h = g"

msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"Nu är ``f``, ``g`` och ``h`` alla attribut av klassen :class:`!C` som "
"refererar till funktionsobjekt, och följaktligen är de alla metoder för "
"instanser av :class:`!C` --- ``h`` är exakt ekvivalent med ``g``.  Notera "
"att denna praxis oftast bara tjänar till att förvirra läsaren av ett program."

msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Metoder kan anropa andra metoder genom att använda metodattribut för "
"argumentet ``self``::"

msgid ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"
msgstr ""
"klass Väska:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"

msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Metoder kan referera till globala namn på samma sätt som vanliga "
"funktioner.  Det globala scope som associeras med en metod är den modul som "
"innehåller dess definition.  (En klass används aldrig som globalt scope.) "
"Även om det sällan finns någon bra anledning att använda globala data i en "
"metod, finns det många legitima användningsområden för det globala scopet: "
"För det första kan funktioner och moduler som importeras till det globala "
"scopet användas av metoder, liksom funktioner och klasser som definieras i "
"det.  Vanligtvis är klassen som innehåller metoden själv definierad i detta "
"globala scope, och i nästa avsnitt hittar vi några goda skäl till varför en "
"metod skulle vilja referera till sin egen klass."

msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Varje värde är ett objekt och har därför en *klass* (även kallad *typ*). Den "
"lagras som ``object.__class__``."

msgid "Inheritance"
msgstr "Ärftlighet"

msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Naturligtvis skulle en språkfunktion inte vara värd namnet \"klass\" utan "
"att stödja arv.  Syntaxen för en härledd klassdefinition ser ut så här::"

msgid ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"klass AvleddaKlassnamn(BasKlassnamn):\n"
"   <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"   <statement-N>"

msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace accessible "
"from the scope containing the derived class definition.  In place of a base "
"class name, other arbitrary expressions are also allowed.  This can be "
"useful, for example, when the base class is defined in another module::"
msgstr ""
"Namnet :class:`!BaseClassName` måste definieras i en namnrymd som är "
"tillgänglig från det scope som innehåller den härledda klassdefinitionen.  I "
"stället för ett basklassnamn är även andra godtyckliga uttryck tillåtna.  "
"Detta kan vara användbart t.ex. när basklassen är definierad i en annan "
"modul::"

msgid "class DerivedClassName(modname.BaseClassName):"
msgstr "class AvleddaKlassnamn(modnamn.BasKlassnamn):"

msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"Exekveringen av en härledd klassdefinition sker på samma sätt som för en "
"basklass. När klassobjektet konstrueras kommer basklassen ihåg.  Detta "
"används för att lösa attributreferenser: om ett efterfrågat attribut inte "
"finns i klassen, fortsätter sökningen i basklassen.  Denna regel tillämpas "
"rekursivt om basklassen i sig själv är härledd från någon annan klass."

msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Det finns inget speciellt med instansiering av härledda klasser: "
"``DerivedClassName()`` skapar en ny instans av klassen.  Metodreferenser "
"löses på följande sätt: motsvarande klassattribut söks, vid behov nedåt i "
"kedjan av basklasser, och metodreferensen är giltig om detta ger ett "
"funktionsobjekt."

msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Härledda klasser kan åsidosätta metoder i sina basklasser.  Eftersom metoder "
"inte har några speciella privilegier när de anropar andra metoder i samma "
"objekt, kan en metod i en basklass som anropar en annan metod som definieras "
"i samma basklass sluta med att anropa en metod i en härledd klass som "
"åsidosätter den.  (För C++-programmerare: alla metoder i Python är i "
"praktiken ``virtuella``)"

msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"En överordnad metod i en härledd klass kan i själva verket vilja utvidga "
"snarare än att bara ersätta basklassens metod med samma namn. Det finns ett "
"enkelt sätt att anropa basklassmetoden direkt: bara anropa ``BaseClassName."
"methodname(self, arguments)``.  Detta är ibland användbart för klienter "
"också.  (Observera att detta endast fungerar om basklassen är tillgänglig "
"som ``BaseClassName`` i det globala omfånget)"

msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python har två inbyggda funktioner som arbetar med nedärvning:"

msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Använd :func:`isinstance` för att kontrollera en instants typ: "
"``isinstance(obj, int)`` kommer att vara ``True`` endast om ``obj."
"__class__`` är :class:`int` eller någon klass härledd från :class:`int`."

msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Använd :func:`issubclass` för att kontrollera klassens arv: "
"``issubclass(bool, int)`` är ``True`` eftersom :class:`bool` är en subklass "
"av :class:`int`.  Men ``issubclass(float, int)`` är ``False`` eftersom :"
"class:`float` inte är en subklass av :class:`int`."

msgid "Multiple Inheritance"
msgstr "Multipel nedärvning"

msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python stöder också en form av multipel nedärvning.  En klassdefinition med "
"flera basklasser ser ut så här::"

msgid ""
"class DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"klass AvleddaKlassnamn(Bas1, Bas2, Bas3):\n"
"   <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"   <statement-N>"

msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"För de flesta ändamål och i de enklaste fallen kan du tänka dig att "
"sökningen efter attribut som ärvs från en överordnad klass sker med djupet "
"först, från vänster till höger, och inte två gånger i samma klass där det "
"finns en överlappning i hierarkin. Om ett attribut inte hittas i :class:`!"
"DerivedClassName`, söks det alltså i :class:`!Base1`, sedan (rekursivt) i "
"basklasserna i :class:`!Base1`, och om det inte hittas där, söks det i :"
"class:`!Base2`, och så vidare."

msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"I själva verket är det något mer komplext än så; metodresolutionsordningen "
"ändras dynamiskt för att stödja kooperativa anrop till :func:`super`.  Detta "
"tillvägagångssätt är känt i vissa andra språk med flera arv som call-next-"
"method och är kraftfullare än superanropet som finns i språk med enstaka arv."

msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see :ref:`python_2.3_mro`."
msgstr ""
"Dynamisk ordning är nödvändig eftersom alla fall av multipel nedärvning "
"uppvisar en eller flera diamantrelationer (där minst en av de överordnade "
"klasserna kan nås via flera vägar från den underordnade klassen).  Till "
"exempel ärver alla klasser från :class:`object`, så alla fall av multipel "
"nedärvning ger mer än en väg för att nå :class:`object`.  För att förhindra "
"att basklasserna anropas mer än en gång linjäriserar den dynamiska "
"algoritmen sökordningen på ett sätt som bevarar den vänster-till-höger-"
"ordning som anges i varje klass, som bara anropar varje överordnad klass en "
"gång och som är monoton (vilket innebär att en klass kan underordnas utan "
"att det påverkar rangordningen för dess överordnade klasser). Sammantaget "
"gör dessa egenskaper det möjligt att utforma tillförlitliga och utbyggbara "
"klasser med multipel arvbarhet.  För mer detaljer, se :ref:`python_2.3_mro`."

msgid "Private Variables"
msgstr "Privata variabler"

msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"\"Privata\" instansvariabler som inte kan nås annat än från insidan av ett "
"objekt finns inte i Python.  Det finns dock en konvention som följs av de "
"flesta Python-koder: ett namn som inleds med ett understreck (t.ex. "
"``_spam``) ska behandlas som en icke-publik del av API:et (oavsett om det är "
"en funktion, en metod eller en datamedlem).  Det bör betraktas som en "
"implementeringsdetalj och kan ändras utan föregående meddelande."

msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Eftersom det finns ett giltigt användningsområde för klassprivata medlemmar "
"(nämligen att undvika namnkrockar mellan namn och namn som definieras av "
"underklasser), finns det begränsat stöd för en sådan mekanism, kallad :dfn:"
"`name mangling`.  Varje identifierare av formen ``__spam`` (minst två "
"inledande understrykningar, högst en efterföljande understrykning) ersätts "
"textuellt med ``_klassnamn__spam``, där ``klassnamn`` är det aktuella "
"klassnamnet med inledande understrykning(ar) borttagna.  Denna mangling görs "
"utan hänsyn till identifierarens syntaktiska position, så länge den "
"förekommer inom definitionen av en klass."

msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
"Specifikationerna för :ref:`privat namnmangling <private-name-mangling>` för "
"detaljer och specialfall."

msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"Namnmangling är användbart för att låta underklasser åsidosätta metoder utan "
"att bryta metodanrop inom klassen.  Till exempel::"

msgid ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"
msgstr ""
"klass Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        för objekt i iterabel:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update # privat kopia av den ursprungliga update()-metoden\n"
"\n"
"klass MappingSubclass(Mapping):\n"
"\n"
"    def update(self, nycklar, värden):\n"
"        # ger ny signatur för update()\n"
"        # men bryter inte __init__()\n"
"        for item in zip(nycklar, värden):\n"
"            self.items_list.append(item)"

msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"Exemplet ovan skulle fungera även om ``MappingSubclass`` skulle införa en "
"``__update`` identifierare eftersom den ersätts med ``_Mapping__update`` i "
"klassen ``Mapping`` respektive ``_MappingSubclass__update`` i klassen "
"``MappingSubclass``."

msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Observera att mangling-reglerna främst är utformade för att undvika olyckor; "
"det är fortfarande möjligt att komma åt eller ändra en variabel som anses "
"vara privat.  Detta kan till och med vara användbart under speciella "
"omständigheter, t.ex. i felsökaren."

msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Observera att kod som skickas till ``exec()`` eller ``eval()`` inte anser "
"att klassnamnet på den anropande klassen är den aktuella klassen; detta "
"liknar effekten av ``global``-satsen, vars effekt också är begränsad till "
"kod som byte-kompileras tillsammans.  Samma begränsning gäller för "
"``getattr()``, ``setattr()`` och ``delattr()``, samt vid direkt hänvisning "
"till ``__dict__``."

msgid "Odds and Ends"
msgstr "Lite av varje"

msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"Ibland är det användbart att ha en datatyp som liknar Pascals \"record\" "
"eller C:s \"struct\", som samlar ihop några namngivna dataobjekt. Det "
"idiomatiska tillvägagångssättet är att använda :mod:`dataclasses` för detta "
"ändamål::"

msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataklass\n"
"klass Anställd:\n"
"    namn: str\n"
"    avdelning: str\n"
"    lön: int"

msgid ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"
msgstr ""
">>> john = Anställd('john', 'datorlaboratorium', 1000)\n"
">>> john.dept\n"
"'datorlaboratorium'\n"
">>> john.lön\n"
"1000"

msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"En del av Python-koden som förväntar sig en viss abstrakt datatyp kan ofta "
"skickas till en klass som emulerar metoderna för den datatypen istället.  Om "
"du till exempel har en funktion som formaterar data från ett filobjekt kan "
"du definiera en klass med metoderna :meth:`~io.TextIOBase.read` och :meth:"
"`~io.TextIOBase.readline` som hämtar data från en strängbuffert istället, "
"och skicka den som argument."

msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Instansmetodobjekt <instance-methods>` har också attribut: :attr:`m."
"__self__ <method.__self__>` är instansobjektet med metoden :meth:`!m`, och :"
"attr:`m.__func__ <method.__func__>` är :ref:`funktionsobjektet <user-defined-"
"funcs>` som motsvarar metoden."

msgid "Iterators"
msgstr "Iteratorer"

msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Vid det här laget har du säkert märkt att de flesta containerobjekt kan "
"loopas över med hjälp av en :keyword:`for`-sats::"

msgid ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"
msgstr ""
"för element i [1, 2, 3]:\n"
"    print(element)\n"
"för element i (1, 2, 3):\n"
"    print(element)\n"
"for key in {'ett':1, 'två':2}:\n"
"    print(nyckel)\n"
"för char i \"123\":\n"
"    print(char)\n"
"for line in open(\"minfil.txt\"):\n"
"    print(rad, end='')"

msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Denna typ av åtkomst är tydlig, kortfattad och bekväm.  Användningen av "
"iteratorer genomsyrar och förenar Python.  Bakom kulisserna anropar :keyword:"
"`for`-satsen :func:`iter` på containerobjektet.  Funktionen returnerar ett "
"iteratorobjekt som definierar metoden :meth:`~iterator.__next__` som öppnar "
"elementen i containern ett i taget.  När det inte finns några fler element "
"ger :meth:`~iterator.__next__` upphov till ett :exc:`StopIteration`-undantag "
"som säger till :keyword:`!for`-slingan att avslutas.  Du kan anropa metoden :"
"meth:`~iterator.__next__` med hjälp av den inbyggda funktionen :func:`next`; "
"detta exempel visar hur det fungerar::"

msgid ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"
msgstr ""
"&gt;&gt;&gt; s = 'abc'\n"
"&gt;&gt;&gt; det = iter(s)\n"
"&gt;&gt;&gt; det\n"
"<str_iterator object at 0x10c90e650>\n"
"&gt;&gt;&gt; nästa(den)\n"
"'a'\n"
"&gt;&gt;&gt; nästa(den)\n"
"'b'\n"
"&gt;&gt;&gt; nästa(den)\n"
"'c'\n"
"&gt;&gt;&gt; nästa(det)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"    nästa(det)\n"
"Stoppa iteration"

msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""
"Efter att ha sett mekaniken bakom iteratorprotokollet är det enkelt att "
"lägga till iteratorbeteende i dina klasser.  Definiera en :meth:`~container."
"__iter__`-metod som returnerar ett objekt med en :meth:`~iterator.__next__`-"
"metod.  Om klassen definierar :meth:`!__next__`, så kan :meth:`!__iter__` "
"bara returnera ``self``::"

msgid ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"
msgstr ""
"klass Omvänd:\n"
"    \"\"\"Iterator för att loopa över en sekvens baklänges.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"

msgid ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"
msgstr ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse-objektet vid 0x00A1DB50>\n"
">>> för char i rev:\n"
"... print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"

msgid "Generators"
msgstr "Generatorer"

msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
":term:`Generators <generator>` är ett enkelt och kraftfullt verktyg för att "
"skapa iteratorer.  De skrivs som vanliga funktioner men använder :keyword:"
"`yield`-satsen när de vill returnera data.  Varje gång :func:`next` anropas "
"fortsätter generatorn där den slutade (den kommer ihåg alla datavärden och "
"vilket uttalande som senast kördes).  Ett exempel visar att generatorer kan "
"vara trivialt enkla att skapa::"

msgid ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"
msgstr ""
"def reverse(data):\n"
"    för index i intervall(len(data)-1, -1, -1):\n"
"        avkastning data[index]"

msgid ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"
msgstr ""
">>> for char in reverse('golf'):\n"
"... print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"

msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""
"Allt som kan göras med generatorer kan också göras med klassbaserade "
"iteratorer enligt beskrivningen i föregående avsnitt.  Det som gör "
"generatorer så kompakta är att metoderna :meth:`~iterator.__iter__` och :"
"meth:`~generator.__next__` skapas automatiskt."

msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"En annan viktig egenskap är att de lokala variablerna och "
"exekveringstillståndet sparas automatiskt mellan anropen.  Detta gjorde "
"funktionen enklare att skriva och mycket tydligare än ett tillvägagångssätt "
"som använder instansvariabler som ``self.index`` och ``self.data``."

msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Förutom automatiskt skapande av metoder och sparande av programstatus ger "
"generatorer automatiskt upphov till :exc:`StopIteration` när de avslutas. I "
"kombination gör dessa funktioner det enkelt att skapa iteratorer utan större "
"ansträngning än att skriva en vanlig funktion."

msgid "Generator Expressions"
msgstr "Generatoruttryck"

msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Vissa enkla generatorer kan kodas kortfattat som uttryck med en syntax som "
"liknar listförståelser men med parenteser istället för hakparenteser. Dessa "
"uttryck är utformade för situationer där generatorn används direkt av en "
"omslutande funktion.  Generatoruttryck är mer kompakta men mindre mångsidiga "
"än fullständiga generatordefinitioner och tenderar att vara mer "
"minnesvänliga än motsvarande listkomprehensioner."

msgid "Examples::"
msgstr "Exempel::"

msgid ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"
msgstr ""
">>> sum(i*i för i i intervall(10))                 # summa av kvadrater\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y för x,y i zip(xvec, yvec))         # punktprodukt\n"
"260\n"
"\n"
">>> unika_ord = set(ord för rad i sida för ord i rad.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name ``__dict__`` is an attribute but "
"not a global name. Obviously, using this violates the abstraction of "
"namespace implementation, and should be restricted to things like post-"
"mortem debuggers."
msgstr ""
"Med undantag för en sak.  Modulobjekt har ett hemligt skrivskyddat attribut "
"som heter :attr:`~object.__dict__` som returnerar den ordbok som används för "
"att implementera modulens namnrymd; namnet ``__dict__`` är ett attribut men "
"inte ett globalt namn. Att använda detta bryter naturligtvis mot "
"abstraktionen i implementeringen av namnrymden och bör begränsas till saker "
"som debuggar efter avslutat arbete."

msgid "object"
msgstr "objekt"

msgid "method"
msgstr "metod"

msgid "name"
msgstr "namn"

msgid "mangling"
msgstr "mangling"
