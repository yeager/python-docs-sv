# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!ctypes` --- A foreign function library for Python"
msgstr ":mod:`!ctypes` --- Ett bibliotek med främmande funktioner för Python"

msgid "**Source code:** :source:`Lib/ctypes`"
msgstr "**Källkod:** :source:`Lib/ctypes`"

msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` är ett bibliotek med främmande funktioner för Python.  Det "
"tillhandahåller C-kompatibla datatyper och gör det möjligt att anropa "
"funktioner i DLL:er eller delade bibliotek.  Det kan användas för att "
"paketera dessa bibliotek i ren Python."

msgid "ctypes tutorial"
msgstr "ctypes handledning"

msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"Observera: I kodproverna i den här handledningen används :mod:`doctest` för "
"att säkerställa att de faktiskt fungerar.  Eftersom vissa kodprover beter "
"sig olika under Linux, Windows eller macOS innehåller de doctest-direktiv i "
"kommentarerna."

msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"Observera: I vissa kodexempel hänvisas till typen ctypes :class:`c_int`.  På "
"plattformar där ``sizeof(long) == sizeof(int)`` är det ett alias till :class:"
"`c_long`. Så du bör inte bli förvirrad om :class:`c_long` skrivs ut när du "
"förväntar dig :class:`c_int` --- de är faktiskt samma typ."

msgid "Loading dynamic link libraries"
msgstr "Ladda dynamiska länkbibliotek"

msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` exporterar objekten *cdll*, och i Windows *windll* och "
"*oledll*, för laddning av dynamiska länkbibliotek."

msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`!HRESULT` error code. "
"The error code is used to automatically raise an :class:`OSError` exception "
"when the function call fails."
msgstr ""
"Du laddar bibliotek genom att komma åt dem som attribut till dessa objekt. "
"*cdll* laddar bibliotek som exporterar funktioner med hjälp av "
"standardkonventionen ``cdecl``, medan *windll*-bibliotek anropar funktioner "
"med hjälp av konventionen ``stdcall``. *oledll* använder också "
"anropskonventionen ``stdcall`` och antar att funktionerna returnerar en "
"Windows :c:type:`!HRESULT`-felkod. Felkoden används för att automatiskt "
"skapa ett :class:`OSError`-undantag när funktionsanropet misslyckas."

msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Windows-fel gav tidigare upphov till :exc:`WindowsError`, som nu är ett "
"alias för :exc:`OSError`."

msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the ``cdecl`` "
"calling convention::"
msgstr ""
"Här är några exempel för Windows. Observera att ``msvcrt`` är MS standard C-"
"bibliotek som innehåller de flesta standard C-funktioner och använder "
"``cdecl`` anropskonventionen::"

msgid ""
">>> from ctypes import *\n"
">>> print(windll.kernel32)\n"
"<WinDLL 'kernel32', handle ... at ...>\n"
">>> print(cdll.msvcrt)\n"
"<CDLL 'msvcrt', handle ... at ...>\n"
">>> libc = cdll.msvcrt\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> print(windll.kernel32)\n"
"<WinDLL 'kernel32', handtag ... vid ...> >>> print(windll msvcrt)\n"
">>> print(cdll.msvcrt)\n"
"<CDLL 'msvcrt', handtag ... vid ...>\n"
">>> libc = cdll.msvcrt\n"
">>>"

msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows lägger till det vanliga filsuffixet ``.dll`` automatiskt."

msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"Om du använder standard C-biblioteket via ``cdll.msvcrt`` kommer du att "
"använda en föråldrad version av biblioteket som kan vara inkompatibel med "
"den som används av Python. Där det är möjligt, använd Pythons inbyggda "
"funktionalitet, eller importera och använd modulen ``msvcrt``."

msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`~LibraryLoader.LoadLibrary` method of the dll loaders "
"should be used, or you should load the library by creating an instance of "
"CDLL by calling the constructor::"
msgstr ""
"Under Linux måste filnamnet *inklusive* tillägget anges för att ladda ett "
"bibliotek, så attributåtkomst kan inte användas för att ladda bibliotek. "
"Antingen bör metoden :meth:`~LibraryLoader.LoadLibrary` i dll-laddarna "
"användas, eller så bör du ladda biblioteket genom att skapa en instans av "
"CDLL genom att anropa konstruktören::"

msgid ""
">>> cdll.LoadLibrary(\"libc.so.6\")\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>> libc = CDLL(\"libc.so.6\")\n"
">>> libc\n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>>"
msgstr ""
">>> cdll.LoadLibrary(\"libc.so.6\")\n"
"<CDLL 'libc.so.6', handtag ... vid ...> >>> libc = CDLL(\"libc.so.6\")\n"
">>> libc = CDLL(\"libc.so.6\")\n"
">>> libc\n"
"<CDLL 'libc.so.6', handtag ... vid ...>\n"
">>>"

msgid "Accessing functions from loaded dlls"
msgstr "Åtkomst till funktioner från inlästa dll-filer"

msgid "Functions are accessed as attributes of dll objects::"
msgstr "Funktioner är åtkomliga som attribut till dll-objekt::"

msgid ""
">>> libc.printf\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.GetModuleHandleA)\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.MyOwnFunction)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 239, in __getattr__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function 'MyOwnFunction' not found\n"
">>>"
msgstr ""
"&gt;&gt;&gt; libc.printf\n"
"<_FuncPtr object at 0x...>\n"
"&gt;&gt;&gt; print(windll.kernel32.GetModuleHandleA)\n"
"<_FuncPtr object at 0x...>\n"
"&gt;&gt;&gt; Skriv ut(windll.kernel32.MyOwnFunction)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"ctypes.py\", rad 239, i __getattr__\n"
"    func = _StdcallFuncPtr(namn, self)\n"
"AttributeError: funktionen 'MyOwnFunction' hittades inte\n"
"&gt;&gt;&gt"

msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with a ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"Observera att Win32-systemdLL:er som ``kernel32`` och ``user32`` ofta "
"exporterar både ANSI- och UNICODE-versioner av en funktion. UNICODE-"
"versionen exporteras med ``W`` som tillägg till namnet, medan ANSI-versionen "
"exporteras med ``A`` som tillägg till namnet. Win32-funktionen "
"``GetModuleHandle``, som returnerar ett *modulhandtag* för ett givet "
"modulnamn, har följande C-prototyp, och ett makro används för att exponera "
"en av dem som ``GetModuleHandle`` beroende på om UNICODE är definierat eller "
"inte::"

msgid ""
"/* ANSI version */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* UNICODE version */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"
msgstr ""
"/* ANSI-version */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* UNICODE-version */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"

msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* försöker inte välja en av dem med magi, du måste komma åt den "
"version du behöver genom att ange ``GetModuleHandleA`` eller "
"``GetModuleHandleW`` uttryckligen, och sedan anropa den med bytes- "
"respektive strängobjekt."

msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"Ibland exporterar dll-filer funktioner med namn som inte är giltiga Python-"
"identifierare, som ``\"??2@YAPAXI@Z\"``. I det här fallet måste du använda :"
"func:`getattr` för att hämta funktionen::"

msgid ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")\n"
"<_FuncPtr object at 0x...>\n"
">>>"
msgstr ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")\n"
"<_FuncPtr-objekt på 0x ...>\n"
">>>"

msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"I Windows exporterar vissa dll-filer funktioner inte efter namn utan efter "
"ordinal. Dessa funktioner kan nås genom att indexera dll-objektet med "
"ordinalnumret::"

msgid ""
">>> cdll.kernel32[1]\n"
"<_FuncPtr object at 0x...>\n"
">>> cdll.kernel32[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"ctypes.py\", line 310, in __getitem__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function ordinal 0 not found\n"
">>>"
msgstr ""
"&gt;&gt;&gt; cdll.kernel32[1]\n"
"<_FuncPtr object at 0x...>\n"
"&gt;&gt;&gt; cdll.kernel32[0]\n"
"Återkoppling (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"ctypes.py\", rad 310, i __getitem__\n"
"    func = _StdcallFuncPtr(namn, self)\n"
"AttributeError: funktionen ordinal 0 hittades inte\n"
"&gt;&gt;&gt"

msgid "Calling functions"
msgstr "Anropsfunktioner"

msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``rand()`` function, which takes no arguments and returns a pseudo-"
"random integer::"
msgstr ""
"Du kan anropa dessa funktioner som alla andra Python-anropbara funktioner. I "
"det här exemplet används funktionen ``rand()``, som inte tar några argument "
"och returnerar ett pseudoslumpmässigt heltal::"

msgid ""
">>> print(libc.rand())\n"
"1804289383"
msgstr ""
">>> print(libc.rand())\n"
"1804289383"

msgid ""
"On Windows, you can call the ``GetModuleHandleA()`` function, which returns "
"a win32 module handle (passing ``None`` as single argument to call it with a "
"``NULL`` pointer)::"
msgstr ""
"I Windows kan du anropa funktionen ``GetModuleHandleA()``, som returnerar "
"ett win32-modulhandtag (genom att ange ``None`` som enda argument kan du "
"anropa den med en ``NULL``-pekare)::"

msgid ""
">>> print(hex(windll.kernel32.GetModuleHandleA(None)))\n"
"0x1d000000\n"
">>>"
msgstr ""
">>> print(hex(windll.kernel32.GetModuleHandleA(None)))\n"
"0x1d000000\n"
">>>"

msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
":exc:`ValueError` uppstår när du anropar en ``stdcall``-funktion med "
"anropskonventionen ``cdecl``, eller vice versa::"

msgid ""
">>> cdll.kernel32.GetModuleHandleA(None)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with not enough arguments (4 bytes "
"missing)\n"
">>>\n"
"\n"
">>> windll.msvcrt.printf(b\"spam\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: Procedure probably called with too many arguments (4 bytes in "
"excess)\n"
">>>"
msgstr ""
"&gt;&gt;&gt; cdll.kernel32.HämtaModulHandleA(Ingen)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError (värdefel): Proceduren anropades troligen med för få argument (4 "
"byte saknas)\n"
"&gt;&gt;&gt\n"
"\n"
"&gt;&gt;&gt; windll.msvcrt.printf(b\"spam\")\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError (värdefel): Proceduren anropades förmodligen med för många "
"argument (4 byte i överskott)\n"
"&gt;&gt;&gt"

msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"För att ta reda på den korrekta anropskonventionen måste du titta i C-"
"headerfilen eller dokumentationen för den funktion du vill anropa."

msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"I Windows använder :mod:`ctypes` win32-strukturerad undantagshantering för "
"att förhindra krascher på grund av generella skyddsfel när funktioner "
"anropas med ogiltiga argumentvärden::"

msgid ""
">>> windll.kernel32.GetModuleHandleA(32)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"OSError: exception: access violation reading 0x00000020\n"
">>>"
msgstr ""
"&gt;&gt;&gt; windll.kernel32.HämtaModuleHandleA(32)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"OSError: undantag: åtkomstöverträdelse vid läsning av 0x00000020\n"
"&gt;&gt;&gt"

msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"Det finns dock tillräckligt många sätt att krascha Python med :mod:`ctypes`, "
"så du bör vara försiktig ändå.  Modulen :mod:`faulthandler` kan vara till "
"hjälp vid felsökning av krascher (t.ex. från segmenteringsfel som orsakas av "
"felaktiga anrop till C-biblioteket)."

msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:expr:"
"`char *` or :c:expr:`wchar_t *`).  Python integers are passed as the "
"platform's default C :c:expr:`int` type, their value is masked to fit into "
"the C type."
msgstr ""
"``None``, heltal, bytesobjekt och (unicode) strängar är de enda Python-"
"objekt som direkt kan användas som parametrar i dessa funktionsanrop. "
"``None`` skickas som en C ``NULL`` pekare, bytesobjekt och strängar skickas "
"som pekare till minnesblocket som innehåller deras data (:c:expr:`char *` "
"eller :c:expr:`wchar_t *`).  Python heltal skickas som plattformens standard "
"C :c:expr:`int`-typ, deras värde maskeras för att passa in i C-typen."

msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"Innan vi går vidare med att anropa funktioner med andra parametertyper måste "
"vi lära oss mer om datatyperna :mod:`ctypes`."

msgid "Fundamental data types"
msgstr "Grundläggande datatyper"

msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes` definierar ett antal primitiva C-kompatibla datatyper:"

msgid "ctypes type"
msgstr "ctypes typ"

msgid "C type"
msgstr "C-typ"

msgid "Python type"
msgstr "Python-typ"

msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

msgid "bool (1)"
msgstr "bool (1)"

msgid ":class:`c_char`"
msgstr ":class:`c_char`"

msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

msgid "1-character bytes object"
msgstr "1-teckens bytes objekt"

msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

msgid ":c:type:`wchar_t`"
msgstr ":c:typ:`wchar_t`"

msgid "1-character string"
msgstr "1-teckens sträng"

msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

msgid "int"
msgstr "int"

msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

msgid ":class:`c_short`"
msgstr ":class:`c_short`"

msgid ":c:expr:`short`"
msgstr ":c:expr:`kort`"

msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

msgid ":class:`c_int`"
msgstr ":class:`c_int`"

msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

msgid ":class:`c_int8`"
msgstr ":class:`c_int8`"

msgid ":c:type:`int8_t`"
msgstr ":c:typ:`int8_t`"

msgid ":class:`c_int16`"
msgstr ":class:`c_int16`"

msgid ":c:type:`int16_t`"
msgstr ":c:typ:`int16_t`"

msgid ":class:`c_int32`"
msgstr ":class:`c_int32`"

msgid ":c:type:`int32_t`"
msgstr ":c:typ:`int32_t`"

msgid ":class:`c_int64`"
msgstr ":class:`c_int64`"

msgid ":c:type:`int64_t`"
msgstr ":c:typ:`int64_t`"

msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

msgid ":class:`c_uint8`"
msgstr ":class:`c_uint8`"

msgid ":c:type:`uint8_t`"
msgstr ":c:typ:`uint8_t`"

msgid ":class:`c_uint16`"
msgstr ":class:`c_uint16`"

msgid ":c:type:`uint16_t`"
msgstr ":c:typ:`uint16_t`"

msgid ":class:`c_uint32`"
msgstr ":class:`c_uint32`"

msgid ":c:type:`uint32_t`"
msgstr ":c:typ:`uint32_t`"

msgid ":class:`c_uint64`"
msgstr ":class:`c_uint64`"

msgid ":c:type:`uint64_t`"
msgstr ":c:typ:`uint64_t`"

msgid ":class:`c_long`"
msgstr ":class:`c_long`"

msgid ":c:expr:`long`"
msgstr ":c:expr:`lång`"

msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ":c:expr:`__int64` eller :c:expr:`long long`"

msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned __int64` eller :c:expr:`unsigned long long`"

msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

msgid ":c:type:`size_t`"
msgstr ":c:typ:`storlek_t`"

msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

msgid ":c:type:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` eller :c:expr:`Py_ssize_t`"

msgid ":class:`c_time_t`"
msgstr ":class:`c_time_t`"

msgid ":c:type:`time_t`"
msgstr ":c:typ:`time_t`"

msgid ":class:`c_float`"
msgstr ":class:`c_float`"

msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

msgid "float"
msgstr "flyt"

msgid ":class:`c_double`"
msgstr ":class:`c_double`"

msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

msgid ":c:expr:`long double`"
msgstr ":c:expr:`lång dubbel`"

msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

msgid ":c:expr:`char *` (NUL terminated)"
msgstr ":c:expr:`char *` (NUL-terminerad)"

msgid "bytes object or ``None``"
msgstr "bytes objekt eller ``None``"

msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ":c:expr:`wchar_t *` (NUL-terminerad)"

msgid "string or ``None``"
msgstr "sträng eller ``None``"

msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

msgid ":c:expr:`void *`"
msgstr ":c:expr:`void *`"

msgid "int or ``None``"
msgstr "int eller ``None``"

msgid "The constructor accepts any object with a truth value."
msgstr "Konstruktören accepterar alla objekt med ett sanningsvärde."

msgid ""
"Additionally, if IEC 60559 compatible complex arithmetic (Annex G) is "
"supported in both C and ``libffi``, the following complex types are "
"available:"
msgstr ""
"Dessutom, om IEC 60559-kompatibel komplex aritmetik (bilaga G) stöds i både "
"C och ``libffi``, är följande komplexa typer tillgängliga:"

msgid ":class:`c_float_complex`"
msgstr ":class:`c_float_complex`"

msgid ":c:expr:`float complex`"
msgstr ":c:expr:`flöde komplex`"

msgid "complex"
msgstr "komplex"

msgid ":class:`c_double_complex`"
msgstr ":class:`c_double_complex`"

msgid ":c:expr:`double complex`"
msgstr ":c:expr:`dubbel komplex`"

msgid ":class:`c_longdouble_complex`"
msgstr ":class:`c_longdouble_complex`"

msgid ":c:expr:`long double complex`"
msgstr ":c:expr:`lång dubbel komplex`"

msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"Alla dessa typer kan skapas genom att anropa dem med en valfri "
"initialiserare av rätt typ och värde::"

msgid ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Hello, World\")\n"
"c_wchar_p(140018365411392)\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"
msgstr ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Hej, världen\")\n"
"c_wchar_p(140018365411392)\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"

msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr ""
"Eftersom dessa typer är mutabla kan deras värde också ändras i efterhand::"

msgid ""
">>> i = c_int(42)\n"
">>> print(i)\n"
"c_long(42)\n"
">>> print(i.value)\n"
"42\n"
">>> i.value = -99\n"
">>> print(i.value)\n"
"-99\n"
">>>"
msgstr ""
">>> i = c_int(42)\n"
">>> skriv ut(i)\n"
"c_long(42)\n"
">>> print(i.värde)\n"
"42\n"
">>> i.värde = -99\n"
">>> skriv ut(i.värde)\n"
"-99\n"
">>>"

msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python string objects are immutable)::"
msgstr ""
"Genom att tilldela ett nytt värde till instanser av pekartyperna :class:"
"`c_char_p`, :class:`c_wchar_p` och :class:`c_void_p` ändras den "
"*minnesplats* de pekar på, *inte innehållet* i minnesblocket (naturligtvis "
"inte, eftersom Pythons strängobjekt är oföränderliga)::"

msgid ""
">>> s = \"Hello, World\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> print(c_s)\n"
"c_wchar_p(139966785747344)\n"
">>> print(c_s.value)\n"
"Hello World\n"
">>> c_s.value = \"Hi, there\"\n"
">>> print(c_s)              # the memory location has changed\n"
"c_wchar_p(139966783348904)\n"
">>> print(c_s.value)\n"
"Hi, there\n"
">>> print(s)                # first object is unchanged\n"
"Hello, World\n"
">>>"
msgstr ""
">>> s = \"Hej, världen\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> skriv ut(c_s)\n"
"c_wchar_p(139966785747344)\n"
">>> print(c_s.värde)\n"
"Hej världen\n"
">>> c_s.value = \"Hej, där\"\n"
">>> print(c_s) # minnesplatsen har ändrats\n"
"c_wchar_p(139966783348904)\n"
">>> skriv ut(c_s.värde)\n"
"Hej, där\n"
">>> print(s) # första objektet är oförändrat\n"
"Hallå, världen\n"
">>>"

msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"Du bör dock vara försiktig så att du inte skickar dem till funktioner som "
"förväntar sig pekare till föränderligt minne. Om du behöver föränderliga "
"minnesblock har ctypes en :func:`create_string_buffer`-funktion som skapar "
"dessa på olika sätt.  Det aktuella innehållet i minnesblocket kan nås (eller "
"ändras) med egenskapen ``raw``; om du vill komma åt det som en NUL-avslutad "
"sträng, använd egenskapen ``value``::"

msgid ""
">>> from ctypes import *\n"
">>> p = create_string_buffer(3)            # create a 3 byte buffer, "
"initialized to NUL bytes\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Hello\")     # create a buffer containing a "
"NUL terminated string\n"
">>> print(sizeof(p), repr(p.raw))\n"
"6 b'Hello\\x00'\n"
">>> print(repr(p.value))\n"
"b'Hello'\n"
">>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.value = b\"Hi\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> p = create_string_buffer(3) # skapa en buffert på 3 byte, initialiserad "
"till NUL-byte\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Hello\") # skapa en buffert som innehåller "
"en NUL-avslutad sträng\n"
">>> print(sizeof(p), repr(p.raw))\n"
"6 b'Hej\\x00'\n"
">>> skriv ut(repr(p.värde))\n"
"b'Hej'\n"
">>> p = create_string_buffer(b\"Hello\", 10) # skapa en buffert på 10 byte\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.värde = b\"Hej\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n"
">>>"

msgid ""
"The :func:`create_string_buffer` function replaces the old :func:`!c_buffer` "
"function (which is still available as an alias).  To create a mutable memory "
"block containing unicode characters of the C type :c:type:`wchar_t`, use "
"the :func:`create_unicode_buffer` function."
msgstr ""
"Funktionen :func:`create_string_buffer` ersätter den gamla funktionen :func:"
"`!c_buffer` (som fortfarande är tillgänglig som alias).  För att skapa ett "
"föränderligt minnesblock som innehåller unicode-tecken av C-typen :c:type:"
"`wchar_t`, använd funktionen :func:`create_unicode_buffer`."

msgid "Calling functions, continued"
msgstr "Anropsfunktioner, fortsättning"

msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"Observera att printf skriver ut till den riktiga standardutdatakanalen, "
"*inte* till :data:`sys.stdout`, så dessa exempel fungerar bara vid "
"konsolprompten, inte från *IDLE* eller *PythonWin*::"

msgid ""
">>> printf = libc.printf\n"
">>> printf(b\"Hello, %s\\n\", b\"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"Hello, %S\\n\", \"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"%d bottles of beer\\n\", 42)\n"
"42 bottles of beer\n"
"19\n"
">>> printf(b\"%f bottles of beer\\n\", 42.5)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: Don't know how to convert "
"parameter 2\n"
">>>"
msgstr ""
"&gt;&gt;&gt; printf = libc.printf\n"
"&gt;&gt;&gt; printf(b\"Hej, %s\\n\", b\"Världen!\")\n"
"Hej, världen!\n"
"14\n"
"&gt;&gt;&gt; printf(b\"Hej, %S\\n\", \"Världen!\")\n"
"Hej, världen!\n"
"14\n"
"&gt;&gt;&gt; printf(b\"%d flaskor öl\\n\", 42)\n"
"42 flaskor öl\n"
"19\n"
"&gt;&gt;&gt; printf(b\"%f flaskor öl\\n\", 42.5)\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: Vet inte hur man konverterar "
"parameter 2\n"
"&gt;&gt;&gt"

msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"Som tidigare nämnts måste alla Python-typer utom heltal, strängar och "
"bytesobjekt förpackas i sin motsvarande :mod:`ctypes`-typ, så att de kan "
"konverteras till den nödvändiga C-datatypen::"

msgid ""
">>> printf(b\"An int %d, a double %f\\n\", 1234, c_double(3.14))\n"
"An int 1234, a double 3.140000\n"
"31\n"
">>>"
msgstr ""
">>> printf(b\"Ett int %d, en dubbel %f\\n\", 1234, c_double(3.14))\n"
"Ett int 1234, en dubbel 3,140000\n"
"31\n"
">>>"

msgid "Calling variadic functions"
msgstr "Anrop av variadiska funktioner"

msgid ""
"On a lot of platforms calling variadic functions through ctypes is exactly "
"the same as calling functions with a fixed number of parameters. On some "
"platforms, and in particular ARM64 for Apple Platforms, the calling "
"convention for variadic functions is different than that for regular "
"functions."
msgstr ""
"På många plattformar är det exakt samma sak att anropa variadiska funktioner "
"via ctypes som att anropa funktioner med ett fast antal parametrar. På vissa "
"plattformar, och i synnerhet ARM64 för Apple-plattformar, är "
"anropskonventionen för variadiska funktioner annorlunda än för vanliga "
"funktioner."

msgid ""
"On those platforms it is required to specify the :attr:`~_CFuncPtr.argtypes` "
"attribute for the regular, non-variadic, function arguments:"
msgstr ""
"På dessa plattformar är det nödvändigt att ange attributet :attr:`~_CFuncPtr."
"argtypes` för de vanliga, icke-variadiska, funktionsargumenten:"

msgid "libc.printf.argtypes = [ctypes.c_char_p]"
msgstr "libc.printf.argtypes = [ctypes.c_char_p]"

msgid ""
"Because specifying the attribute does not inhibit portability it is advised "
"to always specify :attr:`~_CFuncPtr.argtypes` for all variadic functions."
msgstr ""
"Eftersom angivandet av attributet inte hindrar portabilitet rekommenderas "
"att alltid ange :attr:`~_CFuncPtr.argtypes` för alla variadiska funktioner."

msgid "Calling functions with your own custom data types"
msgstr "Anropa funktioner med dina egna anpassade datatyper"

msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments. :mod:`ctypes` looks for "
"an :attr:`!_as_parameter_` attribute and uses this as the function argument. "
"The attribute must be an integer, string, bytes, a :mod:`ctypes` instance, "
"or an object with an :attr:`!_as_parameter_` attribute::"
msgstr ""
"Du kan också anpassa :mod:`ctypes` argumentkonvertering så att instanser av "
"dina egna klasser kan användas som funktionsargument. :mod:`ctypes` letar "
"efter ett :attr:`!_as_parameter_`-attribut och använder detta som "
"funktionsargument. Attributet måste vara ett heltal, en sträng, bytes, en :"
"mod:`ctypes`-instans eller ett objekt med ett :attr:`!_as_parameter_`-"
"attribut:"

msgid ""
">>> class Bottles:\n"
"...     def __init__(self, number):\n"
"...         self._as_parameter_ = number\n"
"...\n"
">>> bottles = Bottles(42)\n"
">>> printf(b\"%d bottles of beer\\n\", bottles)\n"
"42 bottles of beer\n"
"19\n"
">>>"
msgstr ""
">>> klass Flaskor:\n"
"... def __init__(self, number):\n"
"... self._as_parameter_ = antal\n"
"...\n"
">>> flaskor = Flaskor(42)\n"
">>> printf(b\"%d flaskor öl\\n\", flaskor)\n"
"42 flaskor öl\n"
"19\n"
">>>"

msgid ""
"If you don't want to store the instance's data in the :attr:`!"
"_as_parameter_` instance variable, you could define a :class:`property` "
"which makes the attribute available on request."
msgstr ""
"Om du inte vill lagra instansens data i instansvariabeln :attr:`!"
"_as_parameter_` kan du definiera en :class:`property` som gör attributet "
"tillgängligt på begäran."

msgid "Specifying the required argument types (function prototypes)"
msgstr "Ange de nödvändiga argumenttyperna (funktionsprototyper)"

msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`~_CFuncPtr.argtypes` attribute."
msgstr ""
"Det är möjligt att ange vilka argumenttyper som krävs för funktioner som "
"exporteras från DLL:er genom att ange attributet :attr:`~_CFuncPtr.argtypes`."

msgid ""
":attr:`~_CFuncPtr.argtypes` must be a sequence of C data types (the :func:`!"
"printf` function is probably not a good example here, because it takes a "
"variable number and different types of parameters depending on the format "
"string, on the other hand this is quite handy to experiment with this "
"feature)::"
msgstr ""
":attr:`~_CFuncPtr.argtypes` måste vara en sekvens av C-datatyper "
"(funktionen :func:`!printf` är förmodligen inte ett bra exempel här, "
"eftersom den tar ett variabelt antal och olika typer av parametrar beroende "
"på formatsträngen, å andra sidan är det ganska praktiskt att experimentera "
"med den här funktionen)::"

msgid ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"String '%s', Int %d, Double %f\\n\", b\"Hi\", 10, 2.2)\n"
"String 'Hi', Int 10, Double 2.200000\n"
"37\n"
">>>"
msgstr ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"Sträng '%s', Int %d, Dubbel %f\\n\", b\"Hej\", 10, 2,2)\n"
"Sträng \"Hi\", Int 10, Dubbel 2,200000\n"
"37\n"
">>>"

msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"Genom att ange ett format skyddar man sig mot inkompatibla argumenttyper "
"(precis som en prototyp för en C-funktion) och försöker konvertera "
"argumenten till giltiga typer::"

msgid ""
">>> printf(b\"%d %d %d\", 1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: 'int' object cannot be "
"interpreted as ctypes.c_char_p\n"
">>> printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n"
"X 2 3.000000\n"
"13\n"
">>>"
msgstr ""
"&gt;&gt;&gt; printf(b\"%d %d %d\", 1, 2, 3)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ctypes.ArgumentError: argument 2: TypeError: objektet 'int' kan inte tolkas "
"som ctypes.c_char_p\n"
"&gt;&gt;&gt; printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n"
"X 2 3.000000\n"
"13\n"
"&gt;&gt;&gt"

msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`~_CData.from_param` class method for them to be "
"able to use them in the :attr:`~_CFuncPtr.argtypes` sequence. The :meth:"
"`~_CData.from_param` class method receives the Python object passed to the "
"function call, it should do a typecheck or whatever is needed to make sure "
"this object is acceptable, and then return the object itself, its :attr:`!"
"_as_parameter_` attribute, or whatever you want to pass as the C function "
"argument in this case. Again, the result should be an integer, string, "
"bytes, a :mod:`ctypes` instance, or an object with an :attr:`!"
"_as_parameter_` attribute."
msgstr ""
"Om du har definierat dina egna klasser som du skickar till funktionsanrop, "
"måste du implementera en :meth:`~_CData.from_param` klassmetod för att de "
"ska kunna använda dem i :attr:`~_CFuncPtr.argtypes` sekvensen. Klassmetoden :"
"meth:`~_CData.from_param` tar emot Python-objektet som skickas till "
"funktionsanropet, den bör göra en typkontroll eller vad som behövs för att "
"se till att detta objekt är acceptabelt och sedan returnera själva objektet, "
"dess :attr:`!_as_parameter_`-attribut eller vad du vill skicka som C-"
"funktionsargument i det här fallet. Återigen bör resultatet vara ett heltal, "
"en sträng, bytes, en :mod:`ctypes`-instans eller ett objekt med ett :attr:`!"
"_as_parameter_`-attribut."

msgid "Return types"
msgstr "Typer av avkastning"

msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  Other "
"return types can be specified by setting the :attr:`~_CFuncPtr.restype` "
"attribute of the function object."
msgstr ""
"Som standard antas funktioner returnera C :c:expr:`int`-typen.  Andra "
"returtyper kan anges genom att ställa in attributet :attr:`~_CFuncPtr."
"restype` för funktionsobjektet."

msgid ""
"The C prototype of :c:func:`time` is ``time_t time(time_t *)``. Because :c:"
"type:`time_t` might be of a different type than the default return type :c:"
"expr:`int`, you should specify the :attr:`!restype` attribute::"
msgstr ""
"C-prototypen för :c:func:`time` är ``time_t time(time_t *)``. Eftersom :c:"
"type:`time_t` kan vara av en annan typ än standardreturtypen :c:expr:`int`, "
"bör du ange attributet :attr:`!restype`::"

msgid ">>> libc.time.restype = c_time_t"
msgstr ">>> libc.time.restype = c_time_t"

msgid "The argument types can be specified using :attr:`~_CFuncPtr.argtypes`::"
msgstr "Argumenttyperna kan anges med hjälp av :attr:`~_CFuncPtr.argtypes`::"

msgid ">>> libc.time.argtypes = (POINTER(c_time_t),)"
msgstr ">>> libc.time.argtypes = (POINTER(c_time_t),)"

msgid ""
"To call the function with a ``NULL`` pointer as first argument, use "
"``None``::"
msgstr ""
"Om du vill anropa funktionen med en ``NULL``-pekare som första argument "
"använder du ``None``::"

msgid ""
">>> print(libc.time(None))\n"
"1150640792"
msgstr ""
">>> print(libc.time(None))\n"
"1150640792"

msgid ""
"Here is a more advanced example, it uses the :func:`!strchr` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"Här är ett mer avancerat exempel, det använder funktionen :func:`!strchr`, "
"som förväntar sig en strängpekare och en char, och returnerar en pekare till "
"en sträng::"

msgid ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"8059983\n"
">>> strchr.restype = c_char_p    # c_char_p is a pointer to a string\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"None\n"
">>>"
msgstr ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"8059983\n"
">>> strchr.restype = c_char_p # c_char_p är en pekare till en sträng\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"Ingen\n"
">>>"

msgid ""
"If you want to avoid the :func:`ord(\"x\") <ord>` calls above, you can set "
"the :attr:`~_CFuncPtr.argtypes` attribute, and the second argument will be "
"converted from a single character Python bytes object into a C char:"
msgstr ""
"Om du vill undvika :func:`ord(\"x\") <ord>`-anropen ovan kan du ställa in "
"attributet :attr:`~_CFuncPtr.argtypes`, och det andra argumentet konverteras "
"från ett Python bytes-objekt med ett tecken till ett C char:"

msgid ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (most recent call last):\n"
"ctypes.ArgumentError: argument 2: TypeError: one character bytes, bytearray "
"or integer expected\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"None\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>>"
msgstr ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b\"def\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (senaste anropet senast):\n"
"ctypes.ArgumentError: argument 2: TypeError: ett tecken bytes, bytearray "
"eller heltal förväntas\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"Ingen\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"b'def'\n"
">>>"

msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`~_CFuncPtr.restype` attribute, if the foreign "
"function returns an integer.  The callable will be called with the *integer* "
"the C function returns, and the result of this call will be used as the "
"result of your function call. This is useful to check for error return "
"values and automatically raise an exception::"
msgstr ""
"Du kan också använda ett anropbart Python-objekt (t.ex. en funktion eller en "
"klass) som attributet :attr:`~_CFuncPtr.restype`, om den utländska "
"funktionen returnerar ett heltal.  Det anropbara objektet kommer att anropas "
"med det *integer* som C-funktionen returnerar, och resultatet av detta anrop "
"kommer att användas som resultatet av ditt funktionsanrop. Detta är "
"användbart för att kontrollera felaktiga returvärden och automatiskt skapa "
"ett undantag::"

msgid ""
">>> GetModuleHandle = windll.kernel32.GetModuleHandleA\n"
">>> def ValidHandle(value):\n"
"...     if value == 0:\n"
"...         raise WinError()\n"
"...     return value\n"
"...\n"
">>>\n"
">>> GetModuleHandle.restype = ValidHandle\n"
">>> GetModuleHandle(None)\n"
"486539264\n"
">>> GetModuleHandle(\"something silly\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 3, in ValidHandle\n"
"OSError: [Errno 126] The specified module could not be found.\n"
">>>"
msgstr ""
"&gt;&gt;&gt; GetModuleHandle = windll.kernel32.GetModuleHandleA\n"
"&gt;&gt;&gt; def ValidHandle(värde):\n"
"... om värde == 0:\n"
"... raise WinError()\n"
"... returnera värde\n"
"...\n"
"&gt;&gt;&gt\n"
"&gt;&gt;&gt; GetModuleHandle.restype = GiltigHandle\n"
"&gt;&gt;&gt; HämtaModulHandle(Ingen)\n"
"486539264\n"
"&gt;&gt;&gt; GetModuleHandle(\"något fånigt\")\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"<stdin>\", rad 3, i ValidHandle\n"
"OSError: [Errno 126] Den angivna modulen kunde inte hittas.\n"
"&gt;&gt;&gt"

msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` är en funktion som anropar Windows ``FormatMessage()`` api för "
"att få strängrepresentationen av en felkod, och *returnerar* ett undantag. "
"``WinError`` tar en valfri felkodsparameter, om ingen används anropar den :"
"func:`GetLastError` för att hämta den."

msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`~_CFuncPtr.errcheck` attribute; see the reference manual "
"for details."
msgstr ""
"Observera att en mycket kraftfullare felkontrollmekanism är tillgänglig via "
"attributet :attr:`~_CFuncPtr.errcheck`; se referenshandboken för mer "
"information."

msgid "Passing pointers (or: passing parameters by reference)"
msgstr "Passera pekare (eller: passera parametrar genom referens)"

msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"Ibland förväntar sig en C api-funktion en *pekare* till en datatyp som "
"parameter, förmodligen för att skriva till motsvarande plats, eller om data "
"är för stora för att skickas med värde. Detta kallas också att *överföra "
"parametrar genom referens*."

msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` exporterar funktionen :func:`byref` som används för att skicka "
"parametrar som referenser.  Samma effekt kan uppnås med funktionen :func:"
"`pointer`, även om :func:`pointer` gör mycket mer arbete eftersom den "
"konstruerar ett riktigt pekarobjekt, så det är snabbare att använda :func:"
"`byref` om du inte behöver pekarobjektet i Python själv::"

msgid ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = create_string_buffer(b'\\000' * 32)\n"
">>> print(i.value, f.value, repr(s.value))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"...             byref(i), byref(f), s)\n"
"3\n"
">>> print(i.value, f.value, repr(s.value))\n"
"1 3.1400001049 b'Hello'\n"
">>>"
msgstr ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = skapa_sträng_buffer(b'\\000' * 32)\n"
">>> print(i.värde, f.värde, repr(s.värde))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"... byref(i), byref(f), s)\n"
"3\n"
">>> print(i.värde, f.värde, repr(s.värde))\n"
"1 3.1400001049 b'Hello'\n"
">>>"

msgid "Structures and unions"
msgstr "Strukturer och fackföreningar"

msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`~Structure._fields_` attribute.  :attr:`!"
"_fields_` must be a list of *2-tuples*, containing a *field name* and a "
"*field type*."
msgstr ""
"Strukturer och unioner måste härledas från basklasserna :class:`Structure` "
"och :class:`Union` som definieras i modulen :mod:`ctypes`. Varje underklass "
"måste definiera ett attribut :attr:`~Structure._fields_`. :attr:`!_fields_` "
"måste vara en lista med *2-tuples*, innehållande ett *fältsnamn* och en "
"*fältstyp*."

msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"Fälttypen måste vara en :mod:`ctypes`-typ som :class:`c_int`, eller någon "
"annan härledd :mod:`ctypes`-typ: struktur, union, array, pekare."

msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"Här följer ett enkelt exempel på en POINT-struktur, som innehåller två "
"heltal med namnen *x* och *y*, och som också visar hur man initialiserar en "
"struktur i konstruktorn::"

msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"...                 (\"y\", c_int)]\n"
"...\n"
">>> point = POINT(10, 20)\n"
">>> print(point.x, point.y)\n"
"10 20\n"
">>> point = POINT(y=5)\n"
">>> print(point.x, point.y)\n"
"0 5\n"
">>> POINT(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: too many initializers\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"...                 (\"y\", c_int)]\n"
"...\n"
">>> point = POINT(10, 20)\n"
">>> print(point.x, point.y)\n"
"10 20\n"
">>> point = POINT(y=5)\n"
">>> print(point.x, point.y)\n"
"0 5\n"
">>> POINT(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: too many initializers\n"
">>>"

msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"Det går dock att bygga mycket mer komplicerade strukturer.  En struktur kan "
"i sig innehålla andra strukturer genom att använda en struktur som fälttyp."

msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"Här är en RECT-struktur som innehåller två POINTs med namnen *upperleft* och "
"*lowerright*::"

msgid ""
">>> class RECT(Structure):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"...                 (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(point)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"
msgstr ""
">>> klass RECT(Struktur):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"... (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(punkt)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"

msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"Nästlade strukturer kan också initialiseras i konstruktorn på flera sätt::"

msgid ""
">>> r = RECT(POINT(1, 2), POINT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"
msgstr ""
">>> r = RECT(PUNKT(1, 2), PUNKT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"

msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information. See :class:"
"`CField`::"
msgstr ""
"Field :term:`descriptor`\\s kan hämtas från *class*, de är användbara för "
"felsökning eftersom de kan ge användbar information. Se :class:`CField`::"

msgid ""
">>> POINT.x\n"
"<ctypes.CField 'x' type=c_int, ofs=0, size=4>\n"
">>> POINT.y\n"
"<ctypes.CField 'y' type=c_int, ofs=4, size=4>\n"
">>>"
msgstr ""
">>> POINT.x\n"
"<ctypes.CField 'x' type=c_int, ofs=0, size=4>\n"
">>> POINT.y\n"
"<ctypes.CField 'y' type=c_int, ofs=4, size=4> >>> POINT.y\n"
">>>"

msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` har inte stöd för att skicka unioner eller strukturer med "
"bitfält till funktioner med värde.  Även om detta kan fungera på 32-bitars "
"x86, garanteras det inte av biblioteket att det fungerar i det allmänna "
"fallet.  Unioner och strukturer med bitfält bör alltid skickas till "
"funktioner med pekare."

msgid "Structure/union layout, alignment and byte order"
msgstr "Struktur/unionens layout, inriktning och byteordning"

msgid ""
"By default, Structure and Union fields are laid out in the same way the C "
"compiler does it.  It is possible to override this behavior entirely by "
"specifying a :attr:`~Structure._layout_` class attribute in the subclass "
"definition; see the attribute documentation for details."
msgstr ""
"Som standard är Structure- och Union-fälten utformade på samma sätt som C-"
"kompilatorn gör det.  Det är möjligt att helt åsidosätta detta beteende "
"genom att ange ett :attr:`~Structure._layout_`-klassattribut i "
"underklassdefinitionen; se attributdokumentationen för detaljer."

msgid ""
"It is possible to specify the maximum alignment for the fields by setting "
"the :attr:`~Structure._pack_` class attribute to a positive integer. This "
"matches what ``#pragma pack(n)`` does in MSVC."
msgstr ""
"Det är möjligt att ange den maximala inriktningen för fälten genom att "
"ställa in klassattributet :attr:`~Structure._pack_` till ett positivt "
"heltal. Detta matchar vad ``#pragma pack(n)`` gör i MSVC."

msgid ""
"It is also possible to set a minimum alignment for how the subclass itself "
"is packed in the same way ``#pragma align(n)`` works in MSVC. This can be "
"achieved by specifying a :attr:`~Structure._align_` class attribute in the "
"subclass definition."
msgstr ""
"Det är också möjligt att ange en minsta inriktning för hur själva subklassen "
"ska packas på samma sätt som ``#pragma align(n)`` fungerar i MSVC. Detta kan "
"uppnås genom att ange ett :attr:`~Structure._align_` klassattribut i "
"underklassdefinitionen."

msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` använder den ursprungliga byteordningen för strukturer och "
"unioner.  Om du vill bygga strukturer med en annan byteordning kan du "
"använda någon av basklasserna :class:`BigEndianStructure`, :class:"
"`LittleEndianStructure`, :class:`BigEndianUnion` och :class:"
"`LittleEndianUnion`.  Dessa klasser kan inte innehålla pekarfält."

msgid "Bit fields in structures and unions"
msgstr "Bitfält i strukturer och fackföreningar"

msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`~Structure._fields_` tuples::"
msgstr ""
"Det är möjligt att skapa strukturer och unioner som innehåller bitfält. "
"Bitfält är endast möjliga för heltalsfält, bitbredden anges som det tredje "
"objektet i :attr:`~Structure._fields_`-tuplerna::"

msgid ""
">>> class Int(Structure):\n"
"...     _fields_ = [(\"first_16\", c_int, 16),\n"
"...                 (\"second_16\", c_int, 16)]\n"
"...\n"
">>> print(Int.first_16)\n"
"<ctypes.CField 'first_16' type=c_int, ofs=0, bit_size=16, bit_offset=0>\n"
">>> print(Int.second_16)\n"
"<ctypes.CField 'second_16' type=c_int, ofs=0, bit_size=16, bit_offset=16>"
msgstr ""
">>> klass Int(Struktur):\n"
"...     _fields_ = [(\"first_16\", c_int, 16),\n"
"... (\"second_16\", c_int, 16)]\n"
"...\n"
">>> print(Int.första_16)\n"
"<ctypes.CField 'first_16' type=c_int, ofs=0, bit_size=16, bit_offset=0>\n"
">>> print(Int.andra_16)\n"
"<ctypes.CField 'second_16' type=c_int, ofs=0, bit_size=16, bit_offset=16>"

msgid ""
"It is important to note that bit field allocation and layout in memory are "
"not defined as a C standard; their implementation is compiler-specific. By "
"default, Python will attempt to match the behavior of a \"native\" compiler "
"for the current platform. See the :attr:`~Structure._layout_` attribute for "
"details on the default behavior and how to change it."
msgstr ""
"Det är viktigt att notera att allokering av bitfält och layout i minnet inte "
"definieras som en C-standard; implementeringen av dem är kompilatorspecifik. "
"Som standard kommer Python att försöka matcha beteendet hos en \"native\"-"
"kompilator för den aktuella plattformen. Se attributet :attr:`~Structure."
"_layout_` för detaljer om standardbeteendet och hur man ändrar det."

msgid "Arrays"
msgstr "Arrayer"

msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"Arrayer är sekvenser som innehåller ett fast antal instanser av samma typ."

msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""
"Det rekommenderade sättet att skapa array-typer är genom att multiplicera en "
"datatyp med ett positivt heltal::"

msgid "TenPointsArrayType = POINT * 10"
msgstr "TenPointsArrayType = PUNKT * 10"

msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"Här är ett exempel på en något artificiell datatyp, en struktur som bland "
"annat innehåller 4 POINTs::"

msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class MyStruct(Structure):\n"
"...     _fields_ = [(\"a\", c_int),\n"
"...                 (\"b\", c_float),\n"
"...                 (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class MyStruct(Structure):\n"
"...     _fields_ = [(\"a\", c_int),\n"
"...                 (\"b\", c_float),\n"
"...                 (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"

msgid "Instances are created in the usual way, by calling the class::"
msgstr "Instanser skapas på vanligt sätt, genom att anropa class::"

msgid ""
"arr = TenPointsArrayType()\n"
"for pt in arr:\n"
"    print(pt.x, pt.y)"
msgstr ""
"arr = TenPointsArrayType()\n"
"för pt i arr:\n"
"    print(pt.x, pt.y)"

msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"Ovanstående kod skriver ut en serie ``0 0`` rader, eftersom matrisens "
"innehåll är initialiserat till nollor."

msgid "Initializers of the correct type can also be specified::"
msgstr "Initialiserare av rätt typ kan också anges::"

msgid ""
">>> from ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10 object at 0x...>\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10-objekt vid 0x...> >>> för i i ii\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"

msgid "Pointers"
msgstr "Pekare"

msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"Pekarinstanser skapas genom att anropa funktionen :func:`pointer` på en :mod:"
"`ctypes`-typ::"

msgid ""
">>> from ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pointer(i)\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pekare(i)\n"
">>>"

msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"Pekarinstanser har ett :attr:`~_Pointer.contents`-attribut som returnerar "
"det objekt som pekaren pekar på, ``i``-objektet ovan::"

msgid ""
">>> pi.contents\n"
"c_long(42)\n"
">>>"
msgstr ""
">>> pi.innehåll\n"
"c_long(42)\n"
">>>"

msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"Observera att :mod:`ctypes` inte har OOR (original object return), utan "
"konstruerar ett nytt, likvärdigt objekt varje gång du hämtar ett attribut::"

msgid ""
">>> pi.contents is i\n"
"False\n"
">>> pi.contents is pi.contents\n"
"False\n"
">>>"
msgstr ""
">>> pi.innehåll är i\n"
"Falskt\n"
">>> pi.innehåll är pi.innehåll\n"
"Falskt\n"
">>>"

msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"Om du tilldelar en annan :class:`c_int`-instans till pekarens "
"innehållsattribut skulle pekaren peka på den minnesplats där detta är "
"lagrat::"

msgid ""
">>> i = c_int(99)\n"
">>> pi.contents = i\n"
">>> pi.contents\n"
"c_long(99)\n"
">>>"
msgstr ""
">>> i = c_int(99)\n"
">>> pi.innehåll = i\n"
">>> pi.innehåll\n"
"c_long(99)\n"
">>>"

msgid "Pointer instances can also be indexed with integers::"
msgstr "Pekarinstanser kan också indexeras med heltal::"

msgid ""
">>> pi[0]\n"
"99\n"
">>>"
msgstr ""
">>> pi[0]\n"
"99\n"
">>>"

msgid "Assigning to an integer index changes the pointed to value::"
msgstr "Genom att tilldela ett heltalsindex ändras det pekade till värdet::"

msgid ""
">>> print(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> print(i)\n"
"c_long(22)\n"
">>>"
msgstr ""
">>> skriv ut(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> skriv ut(i)\n"
"c_long(22)\n"
">>>"

msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"Det är också möjligt att använda index som skiljer sig från 0, men du måste "
"veta vad du gör, precis som i C: Du kan komma åt eller ändra godtyckliga "
"minnesplatser. I allmänhet använder du bara den här funktionen om du får en "
"pekare från en C-funktion och du *vet* att pekaren faktiskt pekar på en "
"array i stället för på ett enda objekt."

msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"Bakom kulisserna gör funktionen :func:`pointer` mer än att bara skapa "
"pekarinstanser, den måste först skapa pekar*typer*. Detta görs med "
"funktionen :func:`POINTER`, som accepterar vilken typ som helst av :mod:"
"`ctypes` och returnerar en ny typ::"

msgid ""
">>> PI = POINTER(c_int)\n"
">>> PI\n"
"<class 'ctypes.LP_c_long'>\n"
">>> PI(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: expected c_long instead of int\n"
">>> PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
">>>"
msgstr ""
"&gt;&gt;&gt; PI = POINTER(c_int)\n"
"&gt;&gt;&gt; PI\n"
"<class 'ctypes.LP_c_long'>\n"
"&gt;&gt;&gt; PI(42)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: förväntade c_long istället för int\n"
"&gt;&gt;&gt; PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
"&gt;&gt;&gt"

msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"Anrop av pekartypen utan ett argument skapar en ``NULL``-pekare. ``NULL`` "
"pekare har ett ``False`` boolean värde::"

msgid ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"False\n"
">>>"
msgstr ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"Falsk\n"
">>>"

msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` kontrollerar för ``NULL`` vid dereferencing av pekare (men "
"dereferencing av ogiltiga icke ``NULL`` pekare skulle krascha Python)::"

msgid ""
">>> null_ptr[0]\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>"
msgstr ""
">>> null_ptr[0]\n"
"Traceback (senaste anropet senast):\n"
"    ....\n"
"Värdefel: Tillgång till NULL-pekare\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (senaste anropet senast):\n"
"    ....\n"
"Värdefel (ValueError): Tillgång till NULL-pekare\n"
">>>"

msgid "Thread safety without the GIL"
msgstr "Trådsäkerhet utan GIL"

msgid ""
"From Python 3.13 onward, the :term:`GIL` can be disabled on :term:`free "
"threaded <free threading>` builds. In ctypes, reads and writes to a single "
"object concurrently is safe, but not across multiple objects:"
msgstr ""
"Från Python 3.13 och framåt kan :term:`GIL` inaktiveras på :term:``free "
"threaded <free threading>`-byggnader. I ctypes är samtidiga läsningar och "
"skrivningar till ett enda objekt säkra, men inte över flera objekt:"

msgid ""
">>> number = c_int(42)\n"
">>> pointer_a = pointer(number)\n"
">>> pointer_b = pointer(number)"
msgstr ""
">>> nummer = c_int(42)\n"
">>> pekare_a = pekare(nummer)\n"
">>> pekare_b = pekare(nummer)"

msgid ""
"In the above, it's only safe for one object to read and write to the address "
"at once if the GIL is disabled. So, ``pointer_a`` can be shared and written "
"to across multiple threads, but only if ``pointer_b`` is not also attempting "
"to do the same. If this is an issue, consider using a :class:`threading."
"Lock` to synchronize access to memory:"
msgstr ""
"I ovanstående exempel är det bara säkert för ett objekt att läsa och skriva "
"till adressen samtidigt om GIL är inaktiverat. Så, ``pointer_a`` kan delas "
"och skrivas till över flera trådar, men bara om ``pointer_b`` inte också "
"försöker göra detsamma. Om detta är ett problem kan du överväga att använda "
"en :class:`threading.Lock` för att synkronisera åtkomst till minnet:"

msgid ""
">>> import threading\n"
">>> lock = threading.Lock()\n"
">>> # Thread 1\n"
">>> with lock:\n"
"...    pointer_a.contents = 24\n"
">>> # Thread 2\n"
">>> with lock:\n"
"...    pointer_b.contents = 42"
msgstr ""
">>> import threading\n"
">>> lock = threading.Lock()\n"
">>> # Thread 1\n"
">>> with lock:\n"
"...    pointer_a.contents = 24\n"
">>> # Thread 2\n"
">>> with lock:\n"
"...    pointer_b.contents = 42"

msgid "Type conversions"
msgstr "Typkonverteringar"

msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`~_CFuncPtr.argtypes` list of a function or "
"as the type of a member field in a structure definition, only instances of "
"exactly the same type are accepted.  There are some exceptions to this rule, "
"where ctypes accepts other objects.  For example, you can pass compatible "
"array instances instead of pointer types.  So, for ``POINTER(c_int)``, "
"ctypes accepts an array of c_int::"
msgstr ""
"Vanligtvis gör ctypes en strikt typkontroll.  Detta innebär att om du har "
"``POINTER(c_int)`` i :attr:`~_CFuncPtr.argtypes`-listan för en funktion "
"eller som typ för ett medlemsfält i en strukturdefinition, accepteras endast "
"instanser av exakt samma typ.  Det finns några undantag från denna regel, "
"där ctypes accepterar andra objekt.  Du kan t.ex. skicka kompatibla array-"
"instanser i stället för pekartyper.  Så för ``POINTER(c_int)`` accepterar "
"ctypes en array av c_int::"

msgid ""
">>> class Bar(Structure):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.values = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"...     print(bar.values[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"
msgstr ""
">>> klass Bar(Struktur):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.värden = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"... print(bar.värden[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"

msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`~_CFuncPtr.argtypes`, an object "
"of the pointed type (``c_int`` in this case) can be passed to the function.  "
"ctypes will apply the required :func:`byref` conversion in this case "
"automatically."
msgstr ""
"Dessutom, om ett funktionsargument uttryckligen deklareras vara en pekartyp "
"(t.ex. ``POINTER(c_int)``) i :attr:`~_CFuncPtr.argtypes`, kan ett objekt av "
"pekartypen (``c_int`` i detta fall) skickas till funktionen. ctypes kommer "
"att tillämpa den nödvändiga :func:`byref`-konverteringen i detta fall "
"automatiskt."

msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"För att ställa in ett fält av typen POINTER till ``NULL`` kan du tilldela "
"``None``::"

msgid ""
">>> bar.values = None\n"
">>>"
msgstr ""
">>> bar.värden = Ingen\n"
">>>"

msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"Ibland har man instanser av inkompatibla typer.  I C kan du casta en typ "
"till en annan typ. :mod:`ctypes` tillhandahåller en :func:`cast`-funktion "
"som kan användas på samma sätt.  Strukturen ``Bar`` som definieras ovan "
"accepterar ``POINTER(c_int)`` pekare eller :class:`c_int` matriser för sitt "
"``values`` fält, men inte instanser av andra typer::"

msgid ""
">>> bar.values = (c_byte * 4)()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long "
"instance\n"
">>>"
msgstr ""
"&gt;&gt;&gt; bar.värden = (c_byte * 4)()\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: inkompatibla typer, c_byte_Array_4-instans istället för LP_c_long-"
"instans\n"
"&gt;&gt;&gt"

msgid "For these cases, the :func:`cast` function is handy."
msgstr "I dessa fall är funktionen :func:`cast` praktisk."

msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
"Funktionen :func:`cast` kan användas för att casta en ctypes-instans till en "
"pekare på en annan ctypes-datatyp. :func:`cast` tar två parametrar, ett "
"ctypes-objekt som är eller kan konverteras till en pekare av något slag och "
"en ctypes-pekartyp.  Den returnerar en instans av det andra argumentet, som "
"refererar till samma minnesblock som det första argumentet::"

msgid ""
">>> a = (c_byte * 4)()\n"
">>> cast(a, POINTER(c_int))\n"
"<ctypes.LP_c_long object at ...>\n"
">>>"
msgstr ""
">>> a = (c_byte * 4)()\n"
">>> cast(a, POINTER(c_int))\n"
"<ctypes.LP_c_long-objekt vid ...>\n"
">>>"

msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"Så :func:`cast` kan användas för att tilldela fältet ``values`` i ``Bar`` "
"strukturen::"

msgid ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.values[0])\n"
"0\n"
">>>"
msgstr ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.värden[0])\n"
"0\n"
">>>"

msgid "Incomplete Types"
msgstr "Ofullständiga typer"

msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*Ofullständiga typer* är strukturer, unioner eller matriser vars medlemmar "
"ännu inte har specificerats. I C specificeras de genom forward-"
"deklarationer, som definieras senare::"

msgid ""
"struct cell; /* forward declaration */\n"
"\n"
"struct cell {\n"
"    char *name;\n"
"    struct cell *next;\n"
"};"
msgstr ""
"struct cell; /* framåtdeklaration */\n"
"\n"
"struct cell {\n"
"    char *namn;\n"
"    strukturcell *nästa;\n"
"};"

msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr ""
"Den raka översättningen till ctypes-kod skulle vara denna, men det fungerar "
"inte::"

msgid ""
">>> class cell(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in cell\n"
"NameError: name 'cell' is not defined\n"
">>>"
msgstr ""
"&gt;&gt;&gt; klass cell(Struktur):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"... (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"<stdin>\", rad 2, i cell\n"
"NameError: namnet 'cell' är inte definierat\n"
"&gt;&gt;&gt"

msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`~Structure._fields_` attribute later, after the class statement::"
msgstr ""
"eftersom den nya ``class cell`` inte är tillgänglig i själva "
"klassuttalandet. I :mod:`ctypes` kan vi definiera klassen ``cell`` och "
"ställa in attributet :attr:`~Structure._fields_` senare, efter "
"klassuttalandet::"

msgid ""
">>> from ctypes import *\n"
">>> class cell(Structure):\n"
"...     pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"...                  (\"next\", POINTER(cell))]\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class cell(Structure):\n"
"...     pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"...                  (\"next\", POINTER(cell))]\n"
">>>"

msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"Låt oss prova det. Vi skapar två instanser av ``cell``, och låter dem peka "
"på varandra, och följer slutligen pekarkedjan några gånger::"

msgid ""
">>> c1 = cell()\n"
">>> c1.name = b\"foo\"\n"
">>> c2 = cell()\n"
">>> c2.name = b\"bar\"\n"
">>> c1.next = pointer(c2)\n"
">>> c2.next = pointer(c1)\n"
">>> p = c1\n"
">>> for i in range(8):\n"
"...     print(p.name, end=\" \")\n"
"...     p = p.next[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar\n"
">>>"
msgstr ""
">>> c1 = cell()\n"
">>> c1.namn = b\"foo\"\n"
">>> c2 = cell()\n"
">>> c2.namn = b\"bar\"\n"
">>> c1.nästa = pekare(c2)\n"
">>> c2.nästa = pekare(c1)\n"
">>> p = c1\n"
">>> för i i intervall(8):\n"
"... print(p.namn, end=\" \")\n"
"... p = p.nästa[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar foo bar\n"
">>>"

msgid "Callback functions"
msgstr "Återkallelsefunktioner"

msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` gör det möjligt att skapa C-kallbara funktionspoängare från "
"Python-kallbara funktioner. Dessa kallas ibland för *callback-funktioner*."

msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"Först måste du skapa en klass för återuppringningsfunktionen. Klassen känner "
"till anropskonventionen, returtypen och antalet och typerna av argument som "
"denna funktion kommer att ta emot."

msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
"Fabriksfunktionen :func:`CFUNCTYPE` skapar typer för "
"återuppringningsfunktioner med hjälp av anropskonventionen ``cdecl``. I "
"Windows skapar fabriksfunktionen :func:`WINFUNCTYPE` typer för "
"återkallningsfunktioner med hjälp av anropskonventionen ``stdcall``."

msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"Båda dessa fabriksfunktioner anropas med resultattypen som första argument, "
"och callback-funktionernas förväntade argumenttyper som resterande argument."

msgid ""
"I will present an example here which uses the standard C library's :c:func:`!"
"qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`!qsort` will be used to sort an array of integers::"
msgstr ""
"Jag kommer här att presentera ett exempel som använder standard C-"
"bibliotekets :c:func:`!qsort`-funktion, som används för att sortera objekt "
"med hjälp av en callback-funktion. :c:func:`!qsort` kommer att användas för "
"att sortera en array av heltal::"

msgid ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = None\n"
">>>"
msgstr ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = Ingen\n"
">>>"

msgid ""
":func:`!qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""
":func:`!qsort` måste anropas med en pekare till de data som skall sorteras, "
"antalet objekt i dataarrayen, storleken på ett objekt och en pekare till "
"jämförelsefunktionen, callback. Callbacken anropas sedan med två pekare till "
"objekt och måste returnera ett negativt heltal om det första objektet är "
"mindre än det andra, en nolla om de är lika stora och ett positivt heltal "
"annars."

msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"Så vår callback-funktion tar emot pekare till heltal och måste returnera ett "
"heltal. Först skapar vi ``typ`` för callback-funktionen::"

msgid ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"
msgstr ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"

msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr ""
"För att komma igång, här är en enkel callback som visar de värden den får "
"skickade till sig::"

msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"
msgstr ""
">>> def py_cmp_func(a, b):\n"
"... print(\"py_cmp_func\", a[0], b[0])\n"
"... return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"

msgid "The result::"
msgstr "Resultatet::"

msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"
msgstr ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"

msgid "Now we can actually compare the two items and return a useful result::"
msgstr ""
"Nu kan vi faktiskt jämföra de två objekten och returnera ett användbart "
"resultat::"

msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>>\n"
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""
">>> def py_cmp_func(a, b):\n"
"... print(\"py_cmp_func\", a[0], b[0])\n"
"... return a[0] - b[0]\n"
"...\n"
">>>\n"
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"

msgid "As we can easily check, our array is sorted now::"
msgstr "Som vi lätt kan kontrollera är vår matris nu sorterad::"

msgid ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"
msgstr ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"

msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr ""
"Funktionsfabrikerna kan användas som dekoratorfabriker, så vi kan lika gärna "
"skriva::"

msgid ""
">>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
"... def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""
">>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
"... def py_cmp_func(a, b):\n"
"... print(\"py_cmp_func\", a[0], b[0])\n"
"... return a[0] - b[0]\n"
"...\n"
">>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"

msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"Se till att du behåller referenser till :func:`CFUNCTYPE`-objekt så länge "
"som de används från C-kod. :mod:`ctypes` gör inte det, och om du inte gör "
"det kan de bli garbage collected, vilket kraschar ditt program när en "
"callback görs."

msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"Observera också att om återuppringningsfunktionen anropas i en tråd som "
"skapats utanför Pythons kontroll (t.ex. av den utländska kod som anropar "
"återuppringningen), skapar ctypes en ny dummy Python-tråd vid varje anrop. "
"Detta beteende är korrekt för de flesta ändamål, men det innebär att värden "
"som lagras med :class:`threading.local` *inte* kommer att överleva mellan "
"olika anrop, även när dessa anrop görs från samma C-tråd."

msgid "Accessing values exported from dlls"
msgstr "Tillgång till värden exporterade från dll-filer"

msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_Version`, Python "
"runtime version number encoded in a single constant integer."
msgstr ""
"Vissa delade bibliotek exporterar inte bara funktioner, utan även variabler. "
"Ett exempel i själva Python-biblioteket är :c:data:`Py_Version`, Pythons "
"versionsnummer för runtime kodat i ett enda konstant heltal."

msgid ""
":mod:`ctypes` can access values like this with the :meth:`~_CData.in_dll` "
"class methods of the type.  *pythonapi* is a predefined symbol giving access "
"to the Python C api::"
msgstr ""
":mod:`ctypes` kan komma åt värden som detta med :meth:`~_CData.in_dll` "
"klassmetoderna för typen.  *pythonapi* är en fördefinierad symbol som ger "
"tillgång till Python C api::"

msgid ""
">>> version = ctypes.c_int.in_dll(ctypes.pythonapi, \"Py_Version\")\n"
">>> print(hex(version.value))\n"
"0x30c00a0"
msgstr ""
">>> version = ctypes.c_int.in_dll(ctypes.pythonapi, \"Py_Version\")\n"
">>> print(hex(version.värde))\n"
"0x30c00a0"

msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"Ett utökat exempel som också demonstrerar användningen av pekare kommer åt :"
"c:data:`PyImport_FrozenModules`-pekaren som exporteras av Python."

msgid "Quoting the docs for that value:"
msgstr "Citerar dokumenten för det värdet:"

msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Denna pekare initialiseras så att den pekar på en array av :c:struct:"
"`_frozen`-poster, som avslutas med en post vars alla medlemmar är ``NULL`` "
"eller noll.  När en fryst modul importeras söks den i den här tabellen.  "
"Tredjepartskod kan använda detta för att skapa en dynamiskt skapad samling "
"av frysta moduler."

msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"Så att manipulera denna pekare kan till och med visa sig vara användbart. "
"För att begränsa exemplets storlek visar vi bara hur denna tabell kan läsas "
"med :mod:`ctypes`::"

msgid ""
">>> from ctypes import *\n"
">>>\n"
">>> class struct_frozen(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"code\", POINTER(c_ubyte)),\n"
"...                 (\"size\", c_int),\n"
"...                 (\"get_code\", POINTER(c_ubyte)),  # Function pointer\n"
"...                ]\n"
"...\n"
">>>"
msgstr ""
">>> från ctypes import *\n"
">>>\n"
">>> klass struct_frozen(Struktur):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"... (\"code\", POINTER(c_ubyte)),\n"
"... (\"size\", c_int),\n"
"... (\"get_code\", POINTER(c_ubyte)), # Funktionspekare\n"
"...                ]\n"
"...\n"
">>>"

msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the pointer "
"to the table::"
msgstr ""
"Vi har definierat datatypen :c:struct:`_frozen`, så vi kan hämta pekaren "
"till tabellen::"

msgid ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> table = FrozenTable.in_dll(pythonapi, \"_PyImport_FrozenBootstrap\")\n"
">>>"
msgstr ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> tabell = FrozenTable.in_dll(pythonapi, \"_PyImport_FrozenBootstrap\")\n"
">>>"

msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"Eftersom ``table`` är en ``pekare`` till arrayen av ``struct_frozen``-poster "
"kan vi iterera över den, men vi måste bara se till att vår slinga avslutas, "
"eftersom pekare inte har någon storlek. Förr eller senare skulle det "
"förmodligen krascha med en access violation eller vad som helst, så det är "
"bättre att bryta sig ur slingan när vi träffar ``NULL``-ingången::"

msgid ""
">>> for item in table:\n"
"...     if item.name is None:\n"
"...         break\n"
"...     print(item.name.decode(\"ascii\"), item.size)\n"
"...\n"
"_frozen_importlib 31764\n"
"_frozen_importlib_external 41499\n"
"zipimport 12345\n"
">>>"
msgstr ""
">>> för objekt i tabellen:\n"
"... om item.name är None:\n"
"... break\n"
"... print(objekt.namn.decode(\"ascii\")), objekt.storlek)\n"
"...\n"
"_frozen_importlib 31764\n"
"_frozen_importlib_external 41499\n"
"zipimport 12345\n"
">>>"

msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"Det faktum att standard Python har en frusen modul och ett fruset paket "
"(indikeras av den negativa ``size``-medlemmen) är inte välkänt, det används "
"bara för testning. Prova det till exempel med ``import __hello__``."

msgid "Surprises"
msgstr "Överraskningar"

msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"Det finns vissa kanter i :mod:`ctypes` där man kan förvänta sig något annat "
"än vad som faktiskt händer."

msgid "Consider the following example::"
msgstr "Tänk på följande exempel::"

msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class RECT(Structure):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # now swap the two points\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"
msgstr ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class RECT(Structure):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # now swap the two points\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"

msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"Hm. Vi förväntade oss verkligen att det sista uttalandet skulle skriva ut "
"``3 4 1 2``. Vad var det som hände? Här är stegen i raden ``rc.a, rc.b = rc."
"b, rc.a`` ovan::"

msgid ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"
msgstr ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"

msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"Observera att ``temp0`` och ``temp1`` är objekt som fortfarande använder den "
"interna bufferten i ``rc``-objektet ovan. Så när du kör ``rc.a = temp0`` "
"kopieras buffertinnehållet i ``temp0`` till ``rc`` buffert.  Detta ändrar i "
"sin tur innehållet i ``temp1``. Så den sista uppgiften ``rc.b = temp1`` har "
"inte den förväntade effekten."

msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Tänk på att när du hämtar underobjekt från Structure, Unions och Arrays "
"*kopieras* inte underobjektet, utan istället hämtas ett omslagsobjekt som "
"har åtkomst till rotobjektets underliggande buffert."

msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr ""
"Ett annat exempel som kan bete sig annorlunda än vad man förväntar sig är "
"detta::"

msgid ""
">>> s = c_char_p()\n"
">>> s.value = b\"abc def ghi\"\n"
">>> s.value\n"
"b'abc def ghi'\n"
">>> s.value is s.value\n"
"False\n"
">>>"
msgstr ""
">>> s = c_char_p()\n"
">>> s.värde = b\"abc def ghi\"\n"
">>> s.värde\n"
"b'abc def ghi'\n"
">>> s.value är s.value\n"
"Falskt\n"
">>>"

msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr ""
"Objekt som instansieras från :class:`c_char_p` kan bara ha sitt värde "
"inställt på bytes eller heltal."

msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"Varför skriver den ut ``False``? ctypes-instanser är objekt som innehåller "
"ett minnesblock plus några :term:`descriptor`` som har åtkomst till "
"innehållet i minnet. När ett Python-objekt lagras i minnesblocket lagras "
"inte själva objektet, utan istället lagras objektets ``innehåll``.  Om du "
"öppnar innehållet igen konstrueras ett nytt Python-objekt varje gång!"

msgid "Variable-sized data types"
msgstr "Datatyper med variabel storlek"

msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""
":mod:`ctypes` ger visst stöd för arrayer och strukturer med variabel storlek."

msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
"Funktionen :func:`resize` kan användas för att ändra storlek på "
"minnesbufferten för ett befintligt ctypes-objekt.  Funktionen tar objektet "
"som första argument och den begärda storleken i byte som andra argument.  "
"Minnesblocket kan inte göras mindre än det naturliga minnesblock som anges "
"av objektets typ, ett :exc:`ValueError` uppstår om detta försöker:"

msgid ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> resize(short_array, 4)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: minimum size is 8\n"
">>> resize(short_array, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"
msgstr ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> ändra storlek(short_array, 4)\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"ValueError: minsta storlek är 8\n"
">>> storleksändring(kort_matris, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"

msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"Detta är bra, men hur skulle man komma åt de ytterligare element som finns i "
"denna array?  Eftersom typen fortfarande bara känner till 4 element, får vi "
"fel vid åtkomst till andra element::"

msgid ""
">>> short_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (most recent call last):\n"
"    ...\n"
"IndexError: invalid index\n"
">>>"
msgstr ""
">>> kort_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"IndexError: ogiltigt index\n"
">>>"

msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"Ett annat sätt att använda datatyper med variabel storlek med :mod:`ctypes` "
"är att använda Pythons dynamiska natur och (om)definiera datatypen efter att "
"den önskade storleken redan är känd, från fall till fall."

msgid "ctypes reference"
msgstr "ctypes referens"

msgid "Finding shared libraries"
msgstr "Hitta delade bibliotek"

msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"När du programmerar i ett kompilerat språk används delade bibliotek när du "
"kompilerar/länkar ett program och när programmet körs."

msgid ""
"The purpose of the :func:`~ctypes.util.find_library` function is to locate a "
"library in a way similar to what the compiler or runtime loader does (on "
"platforms with several versions of a shared library the most recent should "
"be loaded), while the ctypes library loaders act like when a program is run, "
"and call the runtime loader directly."
msgstr ""
"Syftet med funktionen :func:`~ctypes.util.find_library` är att hitta ett "
"bibliotek på ett sätt som liknar det som kompilatorn eller runtime-laddaren "
"gör (på plattformar med flera versioner av ett delat bibliotek bör den "
"senaste laddas), medan ctypes-biblioteksladdarna fungerar som när ett "
"program körs och anropar runtime-laddaren direkt."

msgid ""
"The :mod:`!ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""
"Modulen :mod:`!ctypes.util` innehåller en funktion som kan hjälpa till att "
"bestämma vilket bibliotek som ska laddas."

msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Försöker hitta ett bibliotek och returnerar ett sökvägsnamn.  *name* är "
"biblioteksnamnet utan något prefix som *lib*, suffix som ``.so``, ``.dylib`` "
"eller versionsnummer (detta är den form som används för posix-"
"länkalternativet :option:`!-l`).  Om inget bibliotek kan hittas returneras "
"``None``."

msgid "The exact functionality is system dependent."
msgstr "Den exakta funktionaliteten är systemberoende."

msgid ""
"On Linux, :func:`~ctypes.util.find_library` tries to run external programs "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library "
"file. It returns the filename of the library file."
msgstr ""
"På Linux försöker :func:`~ctypes.util.find_library` köra externa program (``/"
"sbin/ldconfig``, ``gcc``, ``objdump`` och ``ld``) för att hitta "
"biblioteksfilen. Den returnerar filnamnet på biblioteksfilen."

msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"Under Linux används värdet för miljövariabeln ``LD_LIBRARY_PATH`` vid "
"sökning efter bibliotek, om ett bibliotek inte kan hittas på något annat "
"sätt."

msgid "Here are some examples::"
msgstr "Här är några exempel::"

msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"
msgstr ""
">>> från ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"

msgid ""
"On macOS and Android, :func:`~ctypes.util.find_library` uses the system's "
"standard naming schemes and paths to locate the library, and returns a full "
"pathname if successful::"
msgstr ""
"På macOS och Android använder :func:`~ctypes.util.find_library` systemets "
"standardnamngivningsscheman och sökvägar för att hitta biblioteket och "
"returnerar ett fullständigt söknamn om det lyckas::"

msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> find_library(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> find_library(\"AGL\")\n"
"'/System/Library/Frameworks/AGL.framework/AGL'\n"
">>>"
msgstr ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> find_library(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> find_library(\"AGL\")\n"
"'/System/Library/Frameworks/AGL.framework/AGL'\n"
">>>"

msgid ""
"On Windows, :func:`~ctypes.util.find_library` searches along the system "
"search path, and returns the full pathname, but since there is no predefined "
"naming scheme a call like ``find_library(\"c\")`` will fail and return "
"``None``."
msgstr ""
"På Windows söker :func:`~ctypes.util.find_library` längs systemets sökväg "
"och returnerar det fullständiga sökvägsnamnet, men eftersom det inte finns "
"något fördefinierat namngivningsschema kommer ett anrop som "
"``find_library(\"c\")`` att misslyckas och returnera ``None``."

msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`~ctypes.util.find_library` "
"to locate the library at runtime."
msgstr ""
"Om du omsluter ett delat bibliotek med :mod:`ctypes`, kan det *vara* bättre "
"att bestämma det delade bibliotekets namn under utvecklingstiden och "
"hårdkoda det i omslutningsmodulen istället för att använda :func:`~ctypes."
"util.find_library` för att hitta biblioteket vid körning."

msgid "Listing loaded shared libraries"
msgstr "Listning av laddade delade bibliotek"

msgid ""
"When writing code that relies on code loaded from shared libraries, it can "
"be useful to know which shared libraries have already been loaded into the "
"current process."
msgstr ""
"När du skriver kod som förlitar sig på kod som laddats från delade bibliotek "
"kan det vara bra att veta vilka delade bibliotek som redan har laddats i den "
"aktuella processen."

msgid ""
"The :mod:`!ctypes.util` module provides the :func:`~ctypes.util.dllist` "
"function, which calls the different APIs provided by the various platforms "
"to help determine which shared libraries have already been loaded into the "
"current process."
msgstr ""
"Modulen :mod:`!ctypes.util` tillhandahåller funktionen :func:`~ctypes.util."
"dllist`, som anropar de olika API:er som tillhandahålls av de olika "
"plattformarna för att avgöra vilka delade bibliotek som redan har laddats in "
"i den aktuella processen."

msgid ""
"The exact output of this function will be system dependent. On most "
"platforms, the first entry of this list represents the current process "
"itself, which may be an empty string. For example, on glibc-based Linux, the "
"return may look like::"
msgstr ""
"Den exakta utmatningen av denna funktion är systemberoende. På de flesta "
"plattformar representerar den första posten i listan själva den aktuella "
"processen, som kan vara en tom sträng. På glibc-baserad Linux kan till "
"exempel returen se ut som::"

msgid ""
">>> from ctypes.util import dllist\n"
">>> dllist()\n"
"['', 'linux-vdso.so.1', '/lib/x86_64-linux-gnu/libm.so.6', '/lib/x86_64-"
"linux-gnu/libc.so.6', ... ]"
msgstr ""
">>> from ctypes.util import dllist\n"
">>> dllist()\n"
"['', 'linux-vdso.so.1', '/lib/x86_64-linux-gnu/libm.so.6', '/lib/x86_64-"
"linux-gnu/libc.so.6', ... ]"

msgid "Loading shared libraries"
msgstr "Ladda delade bibliotek"

msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"Det finns flera sätt att ladda in delade bibliotek i Python-processen.  Ett "
"sätt är att instansiera en av följande klasser:"

msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:expr:`int`."
msgstr ""
"Instanser av denna klass representerar laddade delade bibliotek. Funktioner "
"i dessa bibliotek använder standard C-anropskonventionen och antas "
"returnera :c:expr:`int`."

msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"I Windows kan det misslyckas att skapa en :class:`CDLL`-instans även om DLL-"
"namnet finns. När en DLL som är beroende av den inlästa DLL:en inte hittas, "
"uppstår ett :exc:`OSError`-fel med meddelandet *\"[WinError 126] Den angivna "
"modulen kunde inte hittas\".* Detta felmeddelande innehåller inte namnet på "
"den DLL som saknas eftersom Windows API inte returnerar denna information, "
"vilket gör det svårt att diagnostisera detta fel. För att lösa det här felet "
"och avgöra vilken DLL som inte hittas måste du hitta listan över beroende "
"DLL:er och avgöra vilken som inte hittas med hjälp av Windows felsöknings- "
"och spårningsverktyg."

msgid "The *name* parameter can now be a :term:`path-like object`."
msgstr "Parametern *namn* kan nu vara en :term:`path-liknande objekt`."

msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"microsofts DUMPBIN-verktyg <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- Ett verktyg för att hitta DLL-beroenden."

msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed to "
"return the windows specific :class:`HRESULT` code.  :class:`HRESULT` values "
"contain information specifying whether the function call failed or "
"succeeded, together with additional error code.  If the return value signals "
"a failure, an :class:`OSError` is automatically raised."
msgstr ""
"Instanser av denna klass representerar inlästa delade bibliotek, funktioner "
"i dessa bibliotek använder anropskonventionen ``stdcall`` och antas "
"returnera den Windows-specifika :class:`HRESULT`-koden. :class:`HRESULT`-"
"värden innehåller information som anger om funktionsanropet misslyckades "
"eller lyckades, tillsammans med ytterligare felkod.  Om returvärdet "
"signalerar ett misslyckande, skapas automatiskt ett :class:`OSError`."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
":exc:`WindowsError` used to be raised, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"tidigare användes :exc:`WindowsError`, som nu är ett alias för :exc:"
"`OSError`."

msgid ""
"Instances of this class represent loaded shared libraries, functions in "
"these libraries use the ``stdcall`` calling convention, and are assumed to "
"return :c:expr:`int` by default."
msgstr ""
"Instanser av den här klassen representerar laddade delade bibliotek, "
"funktioner i dessa bibliotek använder anropskonventionen ``stdcall`` och "
"antas returnera :c:expr:`int` som standard."

msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"Python :term:`global interpreter lock` släpps innan anrop av någon funktion "
"som exporteras av dessa bibliotek, och återfås efteråt."

msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Instanser av denna klass beter sig som :class:`CDLL`-instanser, förutom att "
"Python GIL *inte* släpps under funktionsanropet, och efter att funktionen "
"har exekverats kontrolleras Pythons felflagga. Om fel-flaggan är satt, "
"uppstår ett Python-undantag."

msgid "Thus, this is only useful to call Python C api functions directly."
msgstr ""
"Därför är detta endast användbart för att anropa Python C api-funktioner "
"direkt."

msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platform's :c:func:`!"
"dlopen` or :c:func:`!LoadLibrary` function is used to load the library into "
"the process, and to get a handle to it."
msgstr ""
"Alla dessa klasser kan instansieras genom att anropa dem med minst ett "
"argument, sökvägen till det delade biblioteket.  Om du har ett befintligt "
"handtag till ett redan laddat delat bibliotek kan det skickas som den "
"namngivna parametern ``handle``, annars används den underliggande "
"plattformens funktion :c:func:`!dlopen` eller :c:func:`!LoadLibrary` för att "
"ladda biblioteket i processen och för att få ett handtag till det."

msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"Parametern *mode* kan användas för att ange hur biblioteket laddas.  För mer "
"information, se :manpage:`dlopen(3)` manpage.  I Windows ignoreras *mode*.  "
"På posix-system läggs RTLD_NOW alltid till och är inte konfigurerbart."

msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the system's :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""
"Parametern *use_errno*, när den är satt till true, aktiverar en ctypes-"
"mekanism som gör det möjligt att komma åt systemets :data:`errno`-felnummer "
"på ett säkert sätt. :mod:`ctypes` upprätthåller en trådlokal kopia av "
"systemets :data:`errno`-variabel; om du anropar utländska funktioner som "
"skapats med ``use_errno=True`` byts :data:`errno`-värdet före "
"funktionsanropet ut mot ctypes privata kopia, och samma sak händer "
"omedelbart efter funktionsanropet."

msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"Funktionen :func:`ctypes.get_errno` returnerar värdet på den privata kopian "
"av ctypes, och funktionen :func:`ctypes.set_errno` ändrar den privata kopian "
"av ctypes till ett nytt värde och returnerar det tidigare värdet."

msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`!SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"Parametern *use_last_error*, när den är satt till true, aktiverar samma "
"mekanism för Windows-felkoden som hanteras av Windows API-funktionerna :func:"
"`GetLastError` och :func:`!SetLastError`; :func:`ctypes.get_last_error` och :"
"func:`ctypes.set_last_error` används för att begära och ändra ctypes privata "
"kopia av Windows-felkoden."

msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load, which avoids issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""
"Parametern *winmode* används i Windows för att ange hur biblioteket laddas "
"(eftersom *mode* ignoreras). Den tar alla värden som är giltiga för Win32 "
"API:s flaggparameter ``LoadLibraryEx``. När den utelämnas är "
"standardinställningen att använda de flaggor som ger den säkraste DLL-"
"laddningen, vilket undviker problem som DLL-kapning. Att ange den "
"fullständiga sökvägen till DLL:en är det säkraste sättet att se till att "
"rätt bibliotek och beroenden laddas."

msgid "Added *winmode* parameter."
msgstr "Lagt till parametern *winmode*."

msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"Flagga som ska användas som *mode*-parameter.  På plattformar där denna "
"flagga inte är tillgänglig definieras den som heltalet noll."

msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"Flagga att använda som *mode*-parameter.  På plattformar där detta inte är "
"tillgängligt är det samma sak som *RTLD_GLOBAL*."

msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"Det standardläge som används för att ladda delade bibliotek.  I OSX 10.3 är "
"detta *RTLD_GLOBAL*, annars är det samma som *RTLD_LOCAL*."

msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"Instanser av dessa klasser har inga publika metoder.  Funktioner som "
"exporteras av det delade biblioteket kan nås som attribut eller via index.  "
"Observera att om du använder funktionen via ett attribut cachas resultatet "
"och därför returneras samma objekt varje gång om du använder den upprepade "
"gånger.  Å andra sidan returnerar åtkomst via ett index ett nytt objekt "
"varje gång::"

msgid ""
">>> from ctypes import CDLL\n"
">>> libc = CDLL(\"libc.so.6\")  # On Linux\n"
">>> libc.time == libc.time\n"
"True\n"
">>> libc['time'] == libc['time']\n"
"False"
msgstr ""
">>> från ctypes import CDLL\n"
">>> libc = CDLL(\"libc.so.6\") # På Linux\n"
">>> libc.time == libc.time\n"
"Sann\n"
">>> libc['time'] == libc['time']\n"
"False"

msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"Följande publika attribut finns tillgängliga, deras namn börjar med ett "
"understreck för att inte krocka med exporterade funktionsnamn:"

msgid "The system handle used to access the library."
msgstr "Det systemhandtag som används för att komma åt biblioteket."

msgid "The name of the library passed in the constructor."
msgstr "Namnet på det bibliotek som skickas i konstruktören."

msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`~LibraryLoader.LoadLibrary` method, or by retrieving the "
"library as attribute of the loader instance."
msgstr ""
"Delade bibliotek kan också laddas med hjälp av ett av de prefabricerade "
"objekten, som är instanser av klassen :class:`LibraryLoader`, antingen genom "
"att anropa metoden :meth:`~LibraryLoader.LoadLibrary` eller genom att hämta "
"biblioteket som attribut för laddningsinstansen."

msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"Klass som laddar delade bibliotek.  *dlltype* bör vara en av typerna :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL` eller :class:`OleDLL`."

msgid ""
":meth:`!__getattr__` has special behavior: It allows loading a shared "
"library by accessing it as attribute of a library loader instance.  The "
"result is cached, so repeated attribute accesses return the same library "
"each time."
msgstr ""
":meth:`!__getattr__` har ett speciellt beteende: Det gör det möjligt att "
"ladda ett delat bibliotek genom att komma åt det som attribut för en "
"biblioteksladdningsinstans.  Resultatet cachas, så upprepade "
"attributåtkomster returnerar samma bibliotek varje gång."

msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"Ladda in ett delat bibliotek i processen och returnera det.  Denna metod "
"returnerar alltid en ny instans av biblioteket."

msgid "These prefabricated library loaders are available:"
msgstr "Dessa prefabricerade bibliotekslastare finns tillgängliga:"

msgid "Creates :class:`CDLL` instances."
msgstr "Skapar :class:`CDLL`-instanser."

msgid "Creates :class:`WinDLL` instances."
msgstr "Skapar :class:`WinDLL`-instanser."

msgid "Creates :class:`OleDLL` instances."
msgstr "Skapar :class:`OleDLL`-instanser."

msgid "Creates :class:`PyDLL` instances."
msgstr "Skapar :class:`PyDLL`-instanser."

msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"För direkt åtkomst till C Python Api finns ett färdigt Python shared library-"
"objekt tillgängligt:"

msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:expr:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`!restype` attribute to use these functions."
msgstr ""
"En instans av :class:`PyDLL` som exponerar Python C API-funktioner som "
"attribut.  Observera att alla dessa funktioner antas returnera C :c:expr:"
"`int`, vilket naturligtvis inte alltid är sant, så du måste tilldela rätt :"
"attr:`!restype`-attribut för att använda dessa funktioner."

msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"Att ladda ett bibliotek via något av dessa objekt ger upphov till en :ref:"
"`auditing event <auditing>` ``ctypes.dlopen`` med strängargumentet ``name``, "
"namnet som används för att ladda biblioteket."

msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"Åtkomst till en funktion i ett laddat bibliotek ger upphov till en "
"granskningshändelse ``ctypes.dlsym`` med argumenten ``library`` "
"(biblioteksobjektet) och ``name`` (symbolens namn som en sträng eller ett "
"heltal)."

msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"I de fall då endast bibliotekshandtaget är tillgängligt i stället för "
"objektet, ger åtkomst till en funktion upphov till en granskningshändelse "
"``ctypes.dlsym/handle`` med argumenten ``handle`` (det råa "
"bibliotekshandtaget) och ``name``."

msgid "Foreign functions"
msgstr "Utländska funktioner"

msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader."
msgstr ""
"Som förklarades i föregående avsnitt kan utländska funktioner nås som "
"attribut till inlästa delade bibliotek.  De funktionsobjekt som skapas på "
"detta sätt accepterar som standard valfritt antal argument, accepterar "
"valfria ctypes-datainstanser som argument och returnerar den "
"standardresultattyp som anges av biblioteksladdaren."

msgid ""
"They are instances of a private local class :class:`!_FuncPtr` (not exposed "
"in :mod:`!ctypes`) which inherits from the private :class:`_CFuncPtr` class:"
msgstr ""
"De är instanser av en privat lokal klass :class:`!_FuncPtr` (inte exponerad "
"i :mod:`!ctypes`) som ärver från den privata klassen :class:`_CFuncPtr`:"

msgid ""
">>> import ctypes\n"
">>> lib = ctypes.CDLL(None)\n"
">>> issubclass(lib._FuncPtr, ctypes._CFuncPtr)\n"
"True\n"
">>> lib._FuncPtr is ctypes._CFuncPtr\n"
"False"
msgstr ""
">>> import ctypes\n"
">>> lib = ctypes.CDLL(None)\n"
">>> issubclass(lib._FuncPtr, ctypes._CFuncPtr)\n"
"Sant\n"
">>> lib._FuncPtr är ctypes._CFuncPtr\n"
"Falsk"

msgid "Base class for C callable foreign functions."
msgstr "Basklass för C-anropsbara utländska funktioner."

msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"Instanser av utländska funktioner är också C-kompatibla datatyper; de "
"representerar C-funktionspoängare."

msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"Detta beteende kan anpassas genom att tilldela speciella attribut till det "
"utländska funktionsobjektet."

msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""
"Tilldela en ctypes-typ för att ange resultattypen för den främmande "
"funktionen. Använd ``None`` för :c:expr:`void`, en funktion som inte "
"returnerar någonting."

msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:expr:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`!restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"Det är möjligt att tilldela ett anropbart Python-objekt som inte är en "
"ctypes-typ, i det här fallet antas funktionen returnera en C :c:expr:`int`, "
"och den anropbara kommer att anropas med detta heltal, vilket möjliggör "
"ytterligare bearbetning eller felkontroll.  Att använda detta är föråldrat, "
"för mer flexibel efterbehandling eller felkontroll, använd en ctypes-datatyp "
"som :attr:`!restype` och tilldela en anropbar till attributet :attr:"
"`errcheck`."

msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"Tilldela en tupel av ctypes-typer för att ange de argumenttyper som "
"funktionen accepterar.  Funktioner som använder anropskonventionen "
"``stdcall`` kan bara anropas med samma antal argument som längden på denna "
"tupel; funktioner som använder anropskonventionen C accepterar även "
"ytterligare, ospecificerade argument."

msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`~_CData.from_param` class method of the items in the :attr:`argtypes` "
"tuple, this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""
"När en utländsk funktion anropas skickas varje faktiskt argument till "
"klassmetoden :meth:`~_CData.from_param` för objekten i tupeln :attr:"
"`argtypes`, denna metod gör det möjligt att anpassa det faktiska argumentet "
"till ett objekt som den utländska funktionen accepterar.  Exempelvis kommer "
"ett :class:`c_char_p`-objekt i :attr:`argtypes`-tupeln att konvertera en "
"sträng som skickas som argument till ett bytes-objekt med hjälp av ctypes "
"konverteringsregler."

msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`~_CData.from_param` method which returns a "
"value usable as argument (integer, string, ctypes instance).  This allows "
"defining adapters that can adapt custom objects as function parameters."
msgstr ""
"Nytt: Det är nu möjligt att lägga in objekt i argtypes som inte är ctypes-"
"typer, men varje objekt måste ha en :meth:`~_CData.from_param`-metod som "
"returnerar ett värde som kan användas som argument (heltal, sträng, ctypes-"
"instans).  Detta gör det möjligt att definiera adaptrar som kan anpassa "
"anpassade objekt som funktionsparametrar."

msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Tilldela en Python-funktion eller en annan anropbar funktion till detta "
"attribut. Den anropsbara funktionen kommer att anropas med tre eller fler "
"argument:"

msgid ""
"*result* is what the foreign function returns, as specified by the :attr:`!"
"restype` attribute."
msgstr ""
"*result* är vad den främmande funktionen returnerar, enligt vad som anges av "
"attributet :attr:`!restype`."

msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* är själva det främmande funktionsobjektet, vilket gör det möjligt att "
"återanvända samma anropsbara objekt för att kontrollera eller efterbehandla "
"resultaten av flera funktioner."

msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* är en tupel som innehåller de parametrar som ursprungligen "
"skickades till funktionsanropet, vilket gör det möjligt att specialisera "
"beteendet på de argument som används."

msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"Det objekt som den här funktionen returnerar kommer att returneras från det "
"utländska funktionsanropet, men den kan också kontrollera resultatvärdet och "
"skapa ett undantag om det utländska funktionsanropet misslyckades."

msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"set_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""
"I Windows, när ett främmande funktionsanrop ger upphov till ett "
"systemundantag (t.ex. på grund av en åtkomstöverträdelse), kommer det att "
"fångas upp och ersättas med ett lämpligt Python-undantag. Dessutom kommer en "
"granskningshändelse ``ctypes.set_exception`` med argumentet ``code`` att "
"uppstå, vilket gör det möjligt för en granskningskrok att ersätta undantaget "
"med sitt eget."

msgid ""
"Some ways to invoke foreign function calls as well as some of the functions "
"in this module may raise an auditing event ``ctypes.call_function`` with "
"arguments ``function pointer`` and ``arguments``."
msgstr ""
"Vissa sätt att anropa utländska funktioner samt vissa av funktionerna i "
"denna modul kan ge upphov till en granskningshändelse ``ctypes."
"call_function`` med argumenten ``function pointer`` och ``arguments``."

msgid "Function prototypes"
msgstr "Prototyper av funktioner"

msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"Utländska funktioner kan också skapas genom instansiering av "
"funktionsprototyper. Funktionsprototyper liknar funktionsprototyper i C; de "
"beskriver en funktion (returtyp, argumenttyper, anropskonvention) utan att "
"definiera en implementation.  Fabriksfunktionerna måste anropas med önskad "
"resultattyp och funktionens argumenttyper och kan användas som "
"dekoratorfabriker och som sådana tillämpas på funktioner genom syntaxen "
"``@wrapper``. Se :ref:`ctypes-callback-functions` för exempel."

msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"Den returnerade funktionsprototypen skapar funktioner som använder C:s "
"standardkonvention för anrop.  Funktionen kommer att frigöra GIL under "
"anropet.  Om *use_errno* är satt till true, kommer ctypes privata kopia av "
"systemvariabeln :data:`errno` att bytas ut mot det verkliga värdet för :data:"
"`errno` före och efter anropet; *use_last_error* gör samma sak för Windows "
"felkod."

msgid ""
"The returned function prototype creates functions that use the ``stdcall`` "
"calling convention.  The function will release the GIL during the call.  "
"*use_errno* and *use_last_error* have the same meaning as above."
msgstr ""
"Den returnerade funktionsprototypen skapar funktioner som använder "
"anropskonventionen ``stdcall``.  Funktionen kommer att frigöra GIL under "
"anropet.  *use_errno* och *use_last_error* har samma betydelse som ovan."

msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"Den returnerade funktionsprototypen skapar funktioner som använder Pythons "
"anropskonvention.  Funktionen kommer *inte* att frigöra GIL under anropet."

msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"Funktionsprototyper som skapas av dessa fabriksfunktioner kan instansieras "
"på olika sätt, beroende på typen och antalet parametrar i anropet:"

msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""
"Returnerar en utländsk funktion på den angivna adressen som måste vara ett "
"heltal."

msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Skapa en anropsbar C-funktion (en callback-funktion) från en Python "
"*callable*."

msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"Returnerar en utländsk funktion som exporteras av ett delat bibliotek. "
"*func_spec* måste vara en 2-tupel ``(name_or_ordinal, library)``. Det första "
"elementet är namnet på den exporterade funktionen som en sträng, eller den "
"exporterade funktionens ordinal som ett litet heltal.  Det andra elementet "
"är den delade biblioteksinstansen."

msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"Returnerar en utländsk funktion som anropar en COM-metod. *vtbl_index* är "
"index i den virtuella funktionstabellen, ett litet icke-negativt heltal. "
"*name* är namnet på COM-metoden. *iid* är en valfri pekare till "
"gränssnittsidentifieraren som används vid utökad felrapportering."

msgid ""
"If *iid* is not specified, an :exc:`OSError` is raised if the COM method "
"call fails. If *iid* is specified, a :exc:`~ctypes.COMError` is raised "
"instead."
msgstr ""
"Om *iid* inte specificeras, genereras ett :exc:`OSError` om COM-metodanropet "
"misslyckas. Om *iid* specificeras, genereras istället ett :exc:`~ctypes."
"COMError`."

msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`!argtypes` tuple."
msgstr ""
"COM-metoder använder en speciell anropskonvention: De kräver en pekare till "
"COM-gränssnittet som första argument, utöver de parametrar som anges i :attr:"
"`!argtypes`-tupeln."

msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"Den valfria parametern *paramflags* skapar omslag för utländska funktioner "
"med mycket mer funktionalitet än de funktioner som beskrivs ovan."

msgid ""
"*paramflags* must be a tuple of the same length as :attr:`~_CFuncPtr."
"argtypes`."
msgstr ""
"*paramflags* måste vara en tupel av samma längd som :attr:`~_CFuncPtr."
"argtypes`."

msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"Varje objekt i denna tupel innehåller ytterligare information om en "
"parameter, det måste vara en tupel som innehåller ett, två eller tre objekt."

msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""
"Den första posten är ett heltal som innehåller en kombination av "
"riktningsflaggor för parametern:"

msgid "1"
msgstr "1"

msgid "Specifies an input parameter to the function."
msgstr "Anger en inparameter till funktionen."

msgid "2"
msgstr "2"

msgid "Output parameter.  The foreign function fills in a value."
msgstr "Parameter för utdata.  Den utländska funktionen fyller i ett värde."

msgid "4"
msgstr "4"

msgid "Input parameter which defaults to the integer zero."
msgstr "Inmatningsparameter som som standard är heltalet noll."

msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"Den andra valfria posten är parameternamnet som en sträng.  Om detta anges "
"kan den utländska funktionen anropas med namngivna parametrar."

msgid "The optional third item is the default value for this parameter."
msgstr "Den valfria tredje posten är standardvärdet för denna parameter."

msgid ""
"The following example demonstrates how to wrap the Windows ``MessageBoxW`` "
"function so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"Följande exempel visar hur man slår in Windows ``MessageBoxW``-funktionen så "
"att den stöder standardparametrar och namngivna argument. C-deklarationen "
"från Windows header-fil är denna::"

msgid ""
"WINUSERAPI int WINAPI\n"
"MessageBoxW(\n"
"    HWND hWnd,\n"
"    LPCWSTR lpText,\n"
"    LPCWSTR lpCaption,\n"
"    UINT uType);"
msgstr ""
"WINUSERAPI int WINAPI\n"
"MessageBoxW(\n"
"    HWND hWnd,\n"
"    LPCWSTR lpText,\n"
"    LPCWSTR lpCaption,\n"
"    UINT uType);"

msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "Här är förpackningen med :mod:`ctypes`::"

msgid ""
">>> from ctypes import c_int, WINFUNCTYPE, windll\n"
">>> from ctypes.wintypes import HWND, LPCWSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", "
"\"Hello from ctypes\"), (1, \"flags\", 0)\n"
">>> MessageBox = prototype((\"MessageBoxW\", windll.user32), paramflags)"
msgstr ""
">>> from ctypes import c_int, WINFUNCTYPE, windll\n"
">>> from ctypes.wintypes import HWND, LPCWSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", "
"\"Hello from ctypes\"), (1, \"flags\", 0)\n"
">>> MessageBox = prototype((\"MessageBoxW\", windll.user32), paramflags)"

msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr ""
"Den utländska funktionen ``MessageBox`` kan nu anropas på följande sätt::"

msgid ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Spam, spam, spam\")\n"
">>> MessageBox(flags=2, text=\"foo bar\")"
msgstr ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Skräppost, skräppost, skräppost\")\n"
">>> MessageBox(flaggor=2, text=\"foo bar\")"

msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"Ett andra exempel demonstrerar utdataparametrar.  Win32-funktionen "
"``GetWindowRect`` hämtar dimensionerna för ett angivet fönster genom att "
"kopiera dem till ``RECT``-strukturen som anroparen måste tillhandahålla.  "
"Här är C-deklarationen::"

msgid ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"
msgstr ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"

msgid ""
">>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n"
">>> from ctypes.wintypes import BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"
msgstr ""
">>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n"
">>> from ctypes.wintypes import BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"

msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"Funktioner med utparametrar returnerar automatiskt utparametervärdet om det "
"finns ett enda, eller en tupel som innehåller utparametervärdena om det "
"finns fler än ett, så funktionen GetWindowRect returnerar nu en RECT-instans "
"när den anropas."

msgid ""
"Output parameters can be combined with the :attr:`~_CFuncPtr.errcheck` "
"protocol to do further output processing and error checking.  The win32 "
"``GetWindowRect`` api function returns a ``BOOL`` to signal success or "
"failure, so this function could do the error checking, and raises an "
"exception when the api call failed::"
msgstr ""
"Utdataparametrar kan kombineras med :attr:`~_CFuncPtr.errcheck`-protokollet "
"för att göra ytterligare utdatabehandling och felkontroll.  Win32 "
"``GetWindowRect`` api-funktionen returnerar en ``BOOL`` för att signalera "
"framgång eller misslyckande, så den här funktionen kan göra felkontrollen "
"och ger upphov till ett undantag när api-anropet misslyckades::"

msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     return args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""
">>> def errcheck(resultat, func, args):\n"
"... om inte resultat:\n"
"... raise WinError()\n"
"... returnerar args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"

msgid ""
"If the :attr:`~_CFuncPtr.errcheck` function returns the argument tuple it "
"receives unchanged, :mod:`ctypes` continues the normal processing it does on "
"the output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
"Om funktionen :attr:`~_CFuncPtr.errcheck` returnerar den argumenttupel som "
"den tar emot oförändrad, fortsätter :mod:`ctypes` med den normala "
"bearbetning som den gör på utdataparametrarna.  Om du vill returnera en "
"tupel av fönsterkoordinater istället för en ``RECT``-instans, kan du hämta "
"fälten i funktionen och returnera dem istället, den normala bearbetningen "
"kommer inte längre att äga rum::"

msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     rc = args[1]\n"
"...     return rc.left, rc.top, rc.bottom, rc.right\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""
">>> def errcheck(resultat, func, args):\n"
"... om inte resultat:\n"
"... raise WinError()\n"
"... rc = args[1]\n"
"... return rc.vänster, rc.topp, rc.botten, rc.höger\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"

msgid "Utility functions"
msgstr "Verktygsfunktioner"

msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""
"Returnerar minnesbuffertens adress som heltal.  *obj* måste vara en instans "
"av en ctypes-typ."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.addressof`` med "
"argumentet ``obj``."

msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""
"Returnerar anpassningskraven för en ctypes-typ. *obj_or_type* måste vara en "
"ctypes-typ eller -instans."

msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"Returnerar en lättviktspekare till *obj*, som måste vara en instans av en "
"ctypes-typ.  *offset* är som standard noll och måste vara ett heltal som "
"läggs till det interna pekarvärdet."

msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` motsvarar denna C-kod::"

msgid "(((char *)&obj) + offset)"
msgstr "(((char *)&obj) + offset)"

msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"Det returnerade objektet kan endast användas som en parameter i ett "
"främmande funktionsanrop. Det fungerar på samma sätt som ``pointer(obj)``, "
"men konstruktionen är mycket snabbare."

msgid ""
"Copies a COM pointer from *src* to *dst* and returns the Windows specific :c:"
"type:`!HRESULT` value."
msgstr ""
"Kopierar en COM-pekare från *src* till *dst* och returnerar det Windows-"
"specifika :c:type:`!HRESULT`-värdet."

msgid ""
"If *src* is not ``NULL``, its ``AddRef`` method is called, incrementing the "
"reference count."
msgstr ""
"Om *src* inte är ``NULL`` anropas dess metod ``AddRef``, vilket ökar "
"referensantalet."

msgid ""
"In contrast, the reference count of *dst* will not be decremented before "
"assigning the new value. Unless *dst* is ``NULL``, the caller is responsible "
"for decrementing the reference count by calling its ``Release`` method when "
"necessary."
msgstr ""
"Däremot kommer referensantalet för *dst* inte att decimeras innan det nya "
"värdet tilldelas. Om inte *dst* är ``NULL`` är anroparen ansvarig för att "
"decimera referensantalet genom att anropa dess ``Release``-metod vid behov."

msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"Denna funktion liknar cast-operatorn i C. Den returnerar en ny instans av "
"*type* som pekar på samma minnesblock som *obj*.  *typ* måste vara en "
"pekartyp och *obj* måste vara ett objekt som kan tolkas som en pekare."

msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"Denna funktion skapar en föränderlig teckenbuffert. Det returnerade objektet "
"är en ctypes-array av :class:`c_char`."

msgid ""
"If *size* is given (and not ``None``), it must be an :class:`int`. It "
"specifies the size of the returned array."
msgstr ""
"Om *size* anges (och inte ``None``) måste det vara en :class:`int`. Den "
"anger storleken på den returnerade arrayen."

msgid ""
"If the *init* argument is given, it must be :class:`bytes`. It is used to "
"initialize the array items. Bytes not initialized this way are set to zero "
"(NUL)."
msgstr ""
"Om *init*-argumentet anges måste det vara :class:`bytes`. Det används för "
"att initialisera arrayobjekten. Bytes som inte initieras på detta sätt sätts "
"till noll (NUL)."

msgid ""
"If *size* is not given (or if it is ``None``), the buffer is made one "
"element larger than *init*, effectively adding a NUL terminator."
msgstr ""
"Om *size* inte anges (eller om den är ``None``) görs bufferten ett element "
"större än *init*, vilket innebär att en NUL-terminator läggs till."

msgid ""
"If both arguments are given, *size* must not be less than ``len(init)``."
msgstr "Om båda argumenten anges får *size* inte vara mindre än ``len(init)``."

msgid ""
"If *size* is equal to ``len(init)``, a NUL terminator is not added. Do not "
"treat such a buffer as a C string."
msgstr ""
"Om *size* är lika med ``len(init)``, läggs ingen NUL-terminator till. "
"Behandla inte en sådan buffert som en C-sträng."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
">>> bytes(create_string_buffer(2))\n"
"b'\\x00\\x00'\n"
">>> bytes(create_string_buffer(b'ab'))\n"
"b'ab\\x00'\n"
">>> bytes(create_string_buffer(b'ab', 2))\n"
"b'ab'\n"
">>> bytes(create_string_buffer(b'ab', 4))\n"
"b'ab\\x00\\x00'\n"
">>> bytes(create_string_buffer(b'abcdef', 2))\n"
"Traceback (most recent call last):\n"
"   ...\n"
"ValueError: byte string too long"
msgstr ""
">>> bytes(skapa_sträng_buffer(2))\n"
"b'\\x00\\x00'\n"
">>> byte(skapa_sträng_buffer(b'ab'))\n"
"b'ab\\x00'\n"
">>> byte(skapa_sträng_buffer(b'ab', 2))\n"
"b'ab'\n"
">>> byte(skapa_sträng_buffer(b'ab', 4))\n"
"b'ab\\x00\\x00'\n"
">>> byte(skapa_sträng_buffert(b'abcdef', 2))\n"
"Traceback (senaste anropet senast):\n"
"   ...\n"
"ValueError: byte-strängen är för lång"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"med argumenten ``init``, ``size``."

msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"Denna funktion skapar en mutabel unicode-teckenbuffert. Det returnerade "
"objektet är en ctypes-array av :class:`c_wchar`."

msgid ""
"The function takes the same arguments as :func:`~create_string_buffer` "
"except *init* must be a string and *size* counts :class:`c_wchar`."
msgstr ""
"Funktionen tar samma argument som :func:`~create_string_buffer` förutom att "
"*init* måste vara en sträng och *size* räknar :class:`c_wchar`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"med argumenten ``init``, ``size``."

msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllCanUnloadNow function that the "
"_ctypes extension dll exports."
msgstr ""
"Denna funktion är en krok som gör det möjligt att implementera COM-servrar i "
"processen med ctypes.  Den anropas från funktionen DllCanUnloadNow som "
"exporteras av tilläggsdivisionen _ctypes."

msgid ""
"This function is a hook which allows implementing in-process COM servers "
"with ctypes.  It is called from the DllGetClassObject function that the "
"``_ctypes`` extension dll exports."
msgstr ""
"Denna funktion är en krok som gör det möjligt att implementera COM-servrar i "
"processen med ctypes.  Den anropas från funktionen DllGetClassObject som "
"exporteras av dll-tillägget ``_ctypes``."

msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Försöker hitta ett bibliotek och returnerar ett sökvägsnamn.  *name* är "
"biblioteksnamnet utan något prefix som ``lib``, suffix som ``.so``, ``."
"dylib`` eller versionsnummer (detta är den form som används för posix-"
"länkaralternativet :option:`!-l`).  Om inget bibliotek kan hittas returneras "
"``None``."

msgid ""
"Returns the filename of the VC runtime library used by Python, and by the "
"extension modules.  If the name of the library cannot be determined, "
"``None`` is returned."
msgstr ""
"Returnerar filnamnet på det VC runtime-bibliotek som används av Python och "
"av tilläggsmodulerna.  Om namnet på biblioteket inte kan fastställas "
"returneras ``None``."

msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"Om du behöver frigöra minne, t.ex. minne som har allokerats av en "
"tilläggsmodul med ett anrop till funktionen ``free(void *)``, är det viktigt "
"att du använder funktionen i samma bibliotek som allokerade minnet."

msgid ""
"Try to provide a list of paths of the shared libraries loaded into the "
"current process.  These paths are not normalized or processed in any way.  "
"The function can raise :exc:`OSError` if the underlying platform APIs fail. "
"The exact functionality is system dependent."
msgstr ""
"Försök att tillhandahålla en lista med sökvägar till de delade bibliotek som "
"laddats in i den aktuella processen.  Dessa sökvägar är inte normaliserade "
"eller bearbetade på något sätt.  Funktionen kan ge upphov till :exc:"
"`OSError` om de underliggande plattforms-API:erna misslyckas. Den exakta "
"funktionaliteten är systemberoende."

msgid ""
"On most platforms, the first element of the list represents the current "
"executable file. It may be an empty string."
msgstr ""
"På de flesta plattformar representerar det första elementet i listan den "
"aktuella körbara filen. Det kan vara en tom sträng."

msgid ""
"Returns a textual description of the error code *code*.  If no error code is "
"specified, the last error code is used by calling the Windows API function :"
"func:`GetLastError`."
msgstr ""
"Returnerar en textuell beskrivning av felkoden *code*.  Om ingen felkod "
"anges används den senaste felkoden genom att anropa Windows API-funktionen :"
"func:`GetLastError`."

msgid ""
"Returns the last error code set by Windows in the calling thread. This "
"function calls the Windows ``GetLastError()`` function directly, it does not "
"return the ctypes-private copy of the error code."
msgstr ""
"Returnerar den senaste felkoden som ställts in av Windows i den anropande "
"tråden. Denna funktion anropar Windows-funktionen ``GetLastError()`` direkt, "
"den returnerar inte den ctypes-privata kopian av felkoden."

msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"Returnerar det aktuella värdet av den ctypes-privata kopian av "
"systemvariabeln :data:`errno` i den anropande tråden."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.get_errno`` utan "
"argument."

msgid ""
"Returns the current value of the ctypes-private copy of the system :data:`!"
"LastError` variable in the calling thread."
msgstr ""
"Returnerar det aktuella värdet av den ctypes-privata kopian av "
"systemvariabeln :data:`!LastError` i den anropande tråden."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.get_last_error`` utan "
"argument."

msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"Samma som standard C memmove biblioteksfunktionen: kopierar *count* bytes "
"från *src* till *dst*. *dst* och *src* måste vara heltal eller ctypes-"
"instanser som kan konverteras till pekare."

msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"Samma som standardfunktionen memset i C-biblioteket: fyller minnesblocket på "
"adress *dst* med *count* byte av värdet *c*. *dst* måste vara ett heltal som "
"anger en adress, eller en ctypes-instans."

msgid ""
"Create or return a ctypes pointer type. Pointer types are cached and reused "
"internally, so calling this function repeatedly is cheap. *type* must be a "
"ctypes type."
msgstr ""
"Skapa eller returnera en ctypes-pekartyp. Pekartyperna cachas och "
"återanvänds internt, så det är billigt att anropa denna funktion upprepade "
"gånger. *type* måste vara en ctypes-typ."

msgid ""
"The resulting pointer type is cached in the ``__pointer_type__`` attribute "
"of *type*. It is possible to set this attribute before the first call to "
"``POINTER`` in order to set a custom pointer type. However, doing this is "
"discouraged: manually creating a suitable pointer type is difficult without "
"relying on implementation details that may change in future Python versions."
msgstr ""
"Den resulterande pekartypen cachelagras i attributet ``__pointer_type__`` "
"för *type*. Det är möjligt att ställa in detta attribut före det första "
"anropet till ``POINTER`` för att ställa in en anpassad pekartyp. Det är dock "
"inte rekommenderat att göra detta: att manuellt skapa en lämplig pekartyp är "
"svårt utan att förlita sig på implementationsdetaljer som kan ändras i "
"framtida Python-versioner."

msgid ""
"Create a new pointer instance, pointing to *obj*. The returned object is of "
"the type ``POINTER(type(obj))``."
msgstr ""
"Skapa en ny pekarinstans som pekar på *obj*. Det returnerade objektet är av "
"typen ``POINTER(type(obj))``."

msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"Observera: Om du bara vill skicka en pekare till ett objekt till ett "
"främmande funktionsanrop bör du använda ``byref(obj)`` som är mycket "
"snabbare."

msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"Den här funktionen ändrar storleken på internminnesbufferten för *obj*, som "
"måste vara en instans av en ctypes-typ.  Det är inte möjligt att göra "
"bufferten mindre än den ursprungliga storleken för objekttypen, som anges av "
"``sizeof(type(obj))``, men det är möjligt att förstora bufferten."

msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"Ställ in det aktuella värdet för den ctypes-privata kopian av "
"systemvariabeln :data:`errno` i den anropande tråden till *värde* och "
"returnera det tidigare värdet."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.set_errno`` med "
"argumentet ``errno``."

msgid ""
"Sets the current value of the ctypes-private copy of the system :data:`!"
"LastError` variable in the calling thread to *value* and return the previous "
"value."
msgstr ""
"Ställer in det aktuella värdet för den ctypes-privata kopian av "
"systemvariabeln :data:`!LastError` i den anropande tråden till *värde* och "
"returnerar det tidigare värdet."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.set_last_error`` med "
"argumentet ``error``."

msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"Returnerar storleken i byte på en minnesbuffert för en ctypes-typ eller "
"instans. Gör samma sak som C-operatorn ``sizeof``."

msgid ""
"Return the byte string at *void \\*ptr*. If *size* is specified, it is used "
"as size, otherwise the string is assumed to be zero-terminated."
msgstr ""
"Returnerar byte-strängen på *void \\*ptr*. Om *size* anges används den som "
"storlek, annars antas strängen vara nollavslutad."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.string_at`` med "
"argumenten ``ptr``, ``size``."

msgid ""
"Creates an instance of :exc:`OSError`.  If *code* is not specified, :func:"
"`GetLastError` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""
"Skapar en instans av :exc:`OSError`.  Om *code* inte är specificerad "
"anropas :func:`GetLastError` för att bestämma felkoden. Om *descr* inte "
"anges, anropas :func:`FormatError` för att få en textuell beskrivning av "
"felet."

msgid ""
"An instance of :exc:`WindowsError` used to be created, which is now an alias "
"of :exc:`OSError`."
msgstr ""
"Tidigare skapades en instans av :exc:`WindowsError`, som nu är ett alias av :"
"exc:`OSError`."

msgid ""
"Return the wide-character string at *void \\*ptr*. If *size* is specified, "
"it is used as the number of characters of the string, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""
"Returnerar den breda teckensträngen på *void \\*ptr*. Om *size* anges "
"används det som antal tecken i strängen, annars antas strängen vara "
"nollavslutad."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``ptr``, ``size``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.wstring_at`` med "
"argumenten ``ptr``, ``size``."

msgid ""
"Return a :class:`memoryview` object of length *size* that references memory "
"starting at *void \\*ptr*."
msgstr ""
"Returnera ett :class:`memoryview`-objekt av längd *storlek* som refererar "
"till minnet som börjar vid *void \\*ptr*."

msgid ""
"If *readonly* is true, the returned :class:`!memoryview` object can not be "
"used to modify the underlying memory. (Changes made by other means will "
"still be reflected in the returned object.)"
msgstr ""
"Om *readonly* är true kan det returnerade :class:`!memoryview`-objektet inte "
"användas för att ändra det underliggande minnet. (Ändringar som gjorts på "
"annat sätt kommer fortfarande att återspeglas i det returnerade objektet)"

msgid ""
"This function is similar to :func:`string_at` with the key difference of not "
"making a copy of the specified memory. It is a semantically equivalent (but "
"more efficient) alternative to ``memoryview((c_byte * size)."
"from_address(ptr))``. (While :meth:`~_CData.from_address` only takes "
"integers, *ptr* can also be given as a :class:`ctypes.POINTER` or a :func:"
"`~ctypes.byref` object.)"
msgstr ""
"Denna funktion liknar :func:`string_at` med den viktiga skillnaden att den "
"inte gör en kopia av det angivna minnet. Det är ett semantiskt likvärdigt "
"(men mer effektivt) alternativ till ``memoryview((c_byte * size)."
"from_address(ptr))``. (Medan :meth:`~_CData.from_address` bara tar heltal, "
"kan *ptr* också ges som ett :class:`ctypes.POINTER` eller ett :func:`~ctypes."
"byref`-objekt)"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.memoryview_at`` with "
"arguments ``address``, ``size``, ``readonly``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.memoryview_at`` med "
"argumenten ``address``, ``size``, ``readonly``."

msgid "Data types"
msgstr "Datatyper"

msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"Denna icke-offentliga klass är den gemensamma basklassen för alla ctypes-"
"datatyper. Bland annat innehåller alla instanser av ctypes-typen ett "
"minnesblock som innehåller C-kompatibla data; adressen till minnesblocket "
"returneras av hjälpfunktionen :func:`addressof`. En annan instansvariabel "
"exponeras som :attr:`_objects`; denna innehåller andra Python-objekt som "
"måste hållas vid liv ifall minnesblocket innehåller pekare."

msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"Vanliga metoder för ctypes-datatyper, dessa är alla klassmetoder (för att "
"vara exakt är de metoder för :term:`metaclass`):"

msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"Denna metod returnerar en ctypes-instans som delar buffert med *käll*-"
"objektet.  Objektet *källa* måste stödja gränssnittet för skrivbar buffert.  "
"Den valfria parametern *offset* anger en förskjutning i källbufferten i "
"byte; standardvärdet är noll.  Om källbufferten inte är tillräckligt stor "
"uppstår ett :exc:`ValueError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` med "
"argumenten ``pointer``, ``size``, ``offset``."

msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"Denna metod skapar en ctypes-instans genom att kopiera bufferten från "
"*källans* objektbuffert som måste vara läsbar.  Den valfria parametern "
"*offset* anger en förskjutning i källbufferten i byte; standardvärdet är "
"noll.  Om källbufferten inte är tillräckligt stor uppstår ett :exc:"
"`ValueError`."

msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"Den här metoden returnerar en ctypes-typinstans som använder det minne som "
"anges av *address*, som måste vara ett heltal."

msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""
"Denna metod, och andra som indirekt anropar denna metod, ger upphov till en :"
"ref:``auditing event <auditing>``ctypes.cdata`` med argumentet ``address``."

msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`~_CFuncPtr.argtypes` tuple; it must return an "
"object that can be used as a function call parameter."
msgstr ""
"Denna metod anpassar *obj* till en ctypes-typ.  Den anropas med det faktiska "
"objekt som används i ett utländskt funktionsanrop när typen finns i den "
"utländska funktionens :attr:`~_CFuncPtr.argtypes`-tupel; den måste returnera "
"ett objekt som kan användas som parameter för funktionsanropet."

msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"Alla ctypes-datatyper har en standardimplementering av denna classmethod som "
"normalt returnerar *obj* om det är en instans av typen.  Vissa typer "
"accepterar även andra objekt."

msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"Denna metod returnerar en ctypes-typinstans som exporteras av ett delat "
"bibliotek. *name* är namnet på den symbol som exporterar data, *library* är "
"det laddade delade biblioteket."

msgid "Common class variables of ctypes data types:"
msgstr "Gemensamma klassvariabler för ctypes-datatyper:"

msgid ""
"The pointer type that was created by calling :func:`POINTER` for "
"corresponding ctypes data type. If a pointer type was not yet created, the "
"attribute is missing."
msgstr ""
"Den pekartyp som skapades genom anrop av :func:`POINTER` för motsvarande "
"ctypes-datatyp. Om en pekartyp ännu inte skapats saknas attributet."

msgid "Common instance variables of ctypes data types:"
msgstr "Vanliga instansvariabler för ctypes datatyper:"

msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"Ibland äger inte ctypes-datainstanser det minnesblock de innehåller, utan de "
"delar istället en del av minnesblocket för ett basobjekt.  Den skrivskyddade "
"medlemmen :attr:`_b_base_` är det rot-ctypes-objekt som äger minnesblocket."

msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"Denna skrivskyddade variabel är sann när ctypes-datainstansen har allokerat "
"minnesblocket själv, annars falsk."

msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"Denna medlem är antingen ``None`` eller en ordbok som innehåller Python-"
"objekt som måste hållas vid liv så att minnesblockets innehåll hålls "
"giltigt.  Detta objekt är endast exponerat för felsökning; ändra aldrig "
"innehållet i denna ordbok."

msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"Denna icke-offentliga klass är basklass för alla grundläggande ctypes-"
"datatyper. Den nämns här eftersom den innehåller de gemensamma attributen "
"för de grundläggande ctypes-datatyperna. :class:`_SimpleCData` är en "
"underklass till :class:`_CData`, så den ärver deras metoder och attribut. "
"ctypes-datatyper som inte är och inte innehåller pekare kan nu picklas."

msgid "Instances have a single attribute:"
msgstr "Instanser har ett enda attribut:"

msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""
"Detta attribut innehåller det faktiska värdet för instansen. För heltals- "
"och pekartyper är det ett heltal, för teckentyper är det ett objekt eller en "
"sträng med enstaka teckenbytes, för teckenspekartyper är det ett objekt "
"eller en sträng med Python-bytes."

msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"När attributet ``value`` hämtas från en ctypes-instans returneras vanligtvis "
"ett nytt objekt varje gång. :mod:`ctypes` implementerar *inte* "
"originalobjektretur, alltid konstrueras ett nytt objekt.  Detsamma gäller "
"för alla andra ctypes-objektinstanser."

msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`~_CFuncPtr.restype` of :class:`c_char_p`, you "
"will always receive a Python bytes object, *not* a :class:`c_char_p` "
"instance."
msgstr ""
"Grundläggande datatyper, när de returneras som resultat av anrop från "
"främmande funktioner, eller till exempel genom att hämta "
"strukturfältmedlemmar eller arrayobjekt, konverteras transparent till "
"ursprungliga Python-typer.  Med andra ord, om en utländsk funktion har en :"
"attr:`~_CFuncPtr.restype` av :class:`c_char_p`, kommer du alltid att få ett "
"Python bytes-objekt, *inte* en :class:`c_char_p`-instans."

msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`!restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"Underklasser av grundläggande datatyper ärver *inte* detta beteende. Så om "
"en utländsk funktion :attr:`!restype` är en subklass av :class:`c_void_p`, "
"kommer du att få en instans av denna subklass från funktionsanropet. "
"Naturligtvis kan du få pekarens värde genom att komma åt attributet "
"``value``."

msgid "These are the fundamental ctypes data types:"
msgstr "Dessa är de grundläggande ctypes-datatyperna:"

msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""
"Representerar C:s datatyp :c:expr:`signed char` och tolkar värdet som ett "
"litet heltal.  Konstruktören accepterar en valfri heltalsinitialiserare; "
"ingen kontroll av överflöd görs."

msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"Representerar C :c:expr:`char`-datatypen och tolkar värdet som ett enda "
"tecken.  Konstruktören accepterar en valfri stränginitialiserare, strängens "
"längd måste vara exakt ett tecken."

msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""
"Representerar datatypen C :c:expr:`char *` när den pekar på en nollavslutad "
"sträng.  För en allmän teckenpekare som också kan peka på binära data måste "
"``POINTER(c_char)`` användas.  Konstruktören accepterar en heltalsadress "
"eller ett bytes-objekt."

msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representerar datatypen C :c:expr:`double`.  Konstruktören accepterar en "
"valfri float-initialiserare."

msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"Representerar datatypen C :c:expr:`long double`.  Konstruktorn accepterar en "
"valfri float-initialiserare.  På plattformar där ``sizeof(long double) == "
"sizeof(double)`` är det ett alias till :class:`c_double`."

msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representerar datatypen C :c:expr:`float`.  Konstruktören accepterar en "
"valfri float-initialiserare."

msgid ""
"Represents the C :c:expr:`double complex` datatype, if available.  The "
"constructor accepts an optional :class:`complex` initializer."
msgstr ""
"Representerar C :c:expr:`double complex`-datatypen, om den finns "
"tillgänglig.  Konstruktören accepterar en valfri :class:`complex`-"
"initialiserare."

msgid ""
"Represents the C :c:expr:`float complex` datatype, if available.  The "
"constructor accepts an optional :class:`complex` initializer."
msgstr ""
"Representerar C :c:expr:`float complex`-datatypen, om sådan finns.  "
"Konstruktören accepterar en valfri :class:`complex`-initialiserare."

msgid ""
"Represents the C :c:expr:`long double complex` datatype, if available.  The "
"constructor accepts an optional :class:`complex` initializer."
msgstr ""
"Representerar C :c:expr:`long double complex`-datatypen, om den finns "
"tillgänglig.  Konstruktören accepterar en valfri :class:`complex`-"
"initialiserare."

msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"Representerar datatypen C :c:expr:`signed int`.  Konstruktorn accepterar en "
"valfri heltalsinitialiserare; ingen kontroll av överflöd görs.  På "
"plattformar där ``sizeof(int) == sizeof(long)`` är det ett alias till :class:"
"`c_long`."

msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  It is an alias for :"
"class:`c_byte`."
msgstr ""
"Representerar C 8-bitars :c:expr:`signed int`-datatypen.  Det är ett alias "
"för :class:`c_byte`."

msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""
"Representerar C 16-bitars :c:expr:`signed int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_short`."

msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""
"Representerar C 32-bitars :c:expr:`signed int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_int`."

msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"Representerar C 64-bitars :c:expr:`signed int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_longlong`."

msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`signed long`.  Konstruktören accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`signed long long`.  Konstruktören "
"accepterar en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`signed short`.  Konstruktören accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

msgid "Represents the C :c:type:`size_t` datatype."
msgstr "Representerar datatypen C :c:type:`size_t`."

msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "Representerar datatypen C :c:type:`ssize_t`."

msgid "Represents the C :c:type:`time_t` datatype."
msgstr "Representerar datatypen C :c:type:`time_t`."

msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"Representerar C :c:expr:`unsigned char`-datatypen, tolkar värdet som ett "
"litet heltal.  Konstruktören accepterar en valfri heltalsinitialiserare; "
"ingen kontroll av överflöd görs."

msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned int`.  Konstruktorn accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs.  På "
"plattformar där ``sizeof(int) == sizeof(long)`` är det ett alias för :class:"
"`c_ulong`."

msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  It is an alias for :"
"class:`c_ubyte`."
msgstr ""
"Representerar C 8-bitars datatypen :c:expr:`unsigned int`.  Det är ett alias "
"för :class:`c_ubyte`."

msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"Representerar C 16-bitars :c:expr:`unsigned int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_ushort`."

msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"Representerar C 32-bitars :c:expr:`unsigned int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_uint`."

msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"Representerar C 64-bitars :c:expr:`unsigned int`-datatypen.  Vanligtvis ett "
"alias för :class:`c_ulonglong`."

msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned long`.  Konstruktören accepterar "
"en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned long long`.  Konstruktören "
"accepterar en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representerar datatypen C :c:expr:`unsigned short`.  Konstruktören "
"accepterar en valfri heltalsinitialiserare; ingen kontroll av överflöd görs."

msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"Representerar C :c:expr:`void *`-typen.  Värdet representeras som ett "
"heltal. Konstruktören accepterar en valfri heltalsinitialiserare."

msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"Representerar datatypen C :c:type:`wchar_t` och tolkar värdet som en unicode-"
"sträng med ett tecken.  Konstruktören accepterar en valfri "
"stränginitialiserare, strängens längd måste vara exakt ett tecken."

msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"Representerar datatypen C :c:expr:`wchar_t *`, som måste vara en pekare till "
"en nollavslutad bred teckensträng.  Konstruktören accepterar en "
"heltalsadress eller en sträng."

msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"Representerar C:s datatyp :c:expr:`bool` (mer exakt :c:expr:`_Bool` från "
"C99).  Dess värde kan vara ``True`` eller ``False``, och konstruktören "
"accepterar alla objekt som har ett sanningsvärde."

msgid ""
"Represents a :c:type:`!HRESULT` value, which contains success or error "
"information for a function or method call."
msgstr ""
"Representerar ett värde av :c:type:`!HRESULT`, som innehåller information om "
"framgång eller fel för ett funktions- eller metodanrop."

msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""
"Representerar datatypen C :c:expr:`PyObject *`.  Anrop av detta utan "
"argument skapar en ``NULL`` :c:expr:`PyObject *`-pekare."

msgid ":class:`!py_object` is now a :term:`generic type`."
msgstr ":class:`!py_object` är nu en :term:`generisk typ`."

msgid ""
"The :mod:`!ctypes.wintypes` module provides quite some other Windows "
"specific data types, for example :c:type:`!HWND`, :c:type:`!WPARAM`, or :c:"
"type:`!DWORD`. Some useful structures like :c:type:`!MSG` or :c:type:`!RECT` "
"are also defined."
msgstr ""
"Modulen :mod:`!ctypes.wintypes` tillhandahåller en hel del andra Windows-"
"specifika datatyper, till exempel :c:type:`!HWND`, :c:type:`!WPARAM` eller :"
"c:type:`!DWORD`. Några användbara strukturer som :c:type:`!MSG` eller :c:"
"type:`!RECT` är också definierade."

msgid "Structured data types"
msgstr "Strukturerade datatyper"

msgid "Abstract base class for unions in native byte order."
msgstr "Abstrakt basklass för unioner i inbyggd byte-ordning."

msgid ""
"Unions share common attributes and behavior with structures; see :class:"
"`Structure` documentation for details."
msgstr ""
"Unions har samma attribut och beteende som strukturer; se :class:`Structure`-"
"dokumentationen för mer information."

msgid "Abstract base class for unions in *big endian* byte order."
msgstr "Abstrakt basklass för unioner i *big endian* byteordning."

msgid "Abstract base class for unions in *little endian* byte order."
msgstr "Abstrakt basklass för unioner i byteordning *little endian*."

msgid "Abstract base class for structures in *big endian* byte order."
msgstr "Abstrakt basklass för strukturer i *big endian* byteordning."

msgid "Abstract base class for structures in *little endian* byte order."
msgstr "Abstrakt basklass för strukturer i byteordning *little endian*."

msgid ""
"Structures and unions with non-native byte order cannot contain pointer type "
"fields, or any other data types containing pointer type fields."
msgstr ""
"Strukturer och unioner med icke inhemsk byteordning kan inte innehålla fält "
"av pekartyp eller andra datatyper som innehåller fält av pekartyp."

msgid "Abstract base class for structures in *native* byte order."
msgstr "Abstrakt basklass för strukturer i *nativ* byte-ordning."

msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"Konkreta struktur- och unionstyper måste skapas genom att underklassa en av "
"dessa typer och åtminstone definiera en klassvariabel :attr:`_fields_`. :mod:"
"`ctypes` skapar :term:`descriptor` som gör det möjligt att läsa och skriva "
"fälten genom direkt attributåtkomst.  Dessa är"

msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"En sekvens som definierar strukturfälten.  Elementen måste vara 2-tupler "
"eller 3-tupler.  Det första objektet är fältets namn, det andra objektet "
"anger fältets typ; det kan vara vilken ctypes-datatyp som helst."

msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
"För fält av heltalstyp som :class:`c_int` kan ett tredje valfritt element "
"anges.  Det måste vara ett litet positivt heltal som definierar fältets "
"bitbredd."

msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"Fältnamn måste vara unika inom en struktur eller union.  Detta kontrolleras "
"inte, endast ett fält kan nås när namnen upprepas."

msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"Det är möjligt att definiera klassvariabeln :attr:`_fields_` *efter* den "
"class-sats som definierar underklassen Structure, vilket gör det möjligt att "
"skapa datatyper som direkt eller indirekt refererar till sig själva::"

msgid ""
"class List(Structure):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"
msgstr ""
"klass Lista(Struktur):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"

msgid ""
"The :attr:`!_fields_` class variable can only be set once. Later assignments "
"will raise an :exc:`AttributeError`."
msgstr ""
"Klassvariabeln :attr:`!_fields_` kan bara ställas in en gång. Senare "
"tilldelningar kommer att ge upphov till ett :exc:`AttributeError`."

msgid ""
"Additionally, the :attr:`!_fields_` class variable must be defined before "
"the structure or union type is first used: an instance or subclass is "
"created, :func:`sizeof` is called on it, and so on. Later assignments to :"
"attr:`!_fields_` will raise an :exc:`AttributeError`. If :attr:`!_fields_` "
"has not been set before such use, the structure or union will have no own "
"fields, as if :attr:`!_fields_` was empty."
msgstr ""
"Dessutom måste klassvariabeln :attr:`!_fields_` definieras innan struktur- "
"eller unionstypen används första gången: en instans eller underklass "
"skapas, :func:`sizeof` anropas på den, och så vidare. Senare tilldelningar "
"till :attr:`!_fields_` kommer att ge upphov till ett :exc:`AttributeError`. "
"Om :attr:`!_fields_` inte har ställts in innan sådan användning, kommer "
"strukturen eller unionen inte att ha några egna fält, som om :attr:`!"
"_fields_` var tom."

msgid ""
"Sub-subclasses of structure types inherit the fields of the base class plus "
"the :attr:`_fields_` defined in the sub-subclass, if any."
msgstr ""
"Subsubklasser av strukturtyper ärver fälten i basklassen plus de :attr:"
"`_fields_` som definieras i subsubklassen, om sådana finns."

msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect. Setting this "
"attribute to 0 is the same as not setting it at all."
msgstr ""
"Ett valfritt litet heltal som gör det möjligt att åsidosätta inriktningen av "
"strukturfälten i instansen. :attr:`_pack_` måste redan vara definierat när :"
"attr:`_fields_` tilldelas, annars har det ingen effekt. Att sätta detta "
"attribut till 0 är samma sak som att inte sätta det alls."

msgid "This is only implemented for the MSVC-compatible memory layout."
msgstr "Detta är endast implementerat för den MSVC-kompatibla minneslayouten."

msgid ""
"For historical reasons, if :attr:`!_pack_` is non-zero, the MSVC-compatible "
"layout will be used by default. On non-Windows platforms, this default is "
"deprecated and is slated to become an error in Python 3.19. If it is "
"intended, set :attr:`~Structure._layout_` to ``'ms'`` explicitly."
msgstr ""
"Av historiska skäl, om :attr:`!_pack_` är icke-noll, kommer den MSVC-"
"kompatibla layouten att användas som standard. På icke-Windows-plattformar "
"är denna standard föråldrad och kommer att bli ett fel i Python 3.19. Om det "
"är avsett, sätt :attr:`~Structure._layout_` till ``'ms'`` explicit."

msgid ""
"An optional small integer that allows overriding the alignment of the "
"structure when being packed or unpacked to/from memory. Setting this "
"attribute to 0 is the same as not setting it at all."
msgstr ""
"Ett valfritt litet heltal som gör det möjligt att åsidosätta strukturens "
"inriktning när den packas eller packas upp till/från minnet. Att sätta detta "
"attribut till 0 är samma sak som att inte sätta det alls."

msgid ""
"An optional string naming the struct/union layout. It can currently be set "
"to:"
msgstr ""
"En valfri sträng som namnger struct/union-layouten. Den kan för närvarande "
"vara inställd på:"

msgid ""
"``\"ms\"``: the layout used by the Microsoft compiler (MSVC). On GCC and "
"Clang, this layout can be selected with ``__attribute__((ms_struct))``."
msgstr ""
"``\"ms\"``: den layout som används av Microsofts kompilator (MSVC). I GCC "
"och Clang kan denna layout väljas med ``__attribute__((ms_struct))``."

msgid ""
"``\"gcc-sysv\"``: the layout used by GCC with the System V or “SysV-like” "
"data model, as used on Linux and macOS. With this layout, :attr:`~Structure."
"_pack_` must be unset or zero."
msgstr ""
"``\"gcc-sysv\"``: den layout som används av GCC med datamodellen System V "
"eller \"SysV-liknande\", som används på Linux och macOS. Med den här "
"layouten måste :attr:`~Structure._pack_` vara unset eller noll."

msgid ""
"If not set explicitly, ``ctypes`` will use a default that matches the "
"platform conventions. This default may change in future Python releases (for "
"example, when a new platform gains official support, or when a difference "
"between similar platforms is found). Currently the default will be:"
msgstr ""
"Om det inte anges explicit kommer ``ctypes`` att använda en standard som "
"matchar plattformens konventioner. Denna standard kan ändras i framtida "
"Python-utgåvor (till exempel när en ny plattform får officiellt stöd, eller "
"när en skillnad mellan liknande plattformar upptäcks). För närvarande kommer "
"standardvärdet att vara:"

msgid "On Windows: ``\"ms\"``"
msgstr "I Windows: ``\"ms\"``"

msgid ""
"When :attr:`~Structure._pack_` is specified: ``\"ms\"``. (This is "
"deprecated; see :attr:`~Structure._pack_` documentation.)"
msgstr ""
"När :attr:`~Structure._pack_` anges: ``\"ms\"``. (Detta är föråldrat; se :"
"attr:`~Structure._pack_` dokumentation)"

msgid "Otherwise: ``\"gcc-sysv\"``"
msgstr "Annars: ``\"gcc-sysv\"``"

msgid ""
":attr:`!_layout_` must already be defined when :attr:`~Structure._fields_` "
"is assigned, otherwise it will have no effect."
msgstr ""
":attr:`!_layout_` måste redan vara definierad när :attr:`~Structure."
"_fields_` tilldelas, annars har den ingen effekt."

msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"En valfri sekvens som listar namnen på namnlösa (anonyma) fält. :attr:"
"`_anonymous_` måste redan vara definierat när :attr:`_fields_` tilldelas, "
"annars har det ingen effekt."

msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"De fält som anges i denna variabel måste vara av strukturtyp eller "
"unionstyp. :mod:`ctypes` skapar deskriptorer i strukturtypen som gör det "
"möjligt att komma åt de nästlade fälten direkt, utan att behöva skapa "
"struktur- eller unionsfältet."

msgid "Here is an example type (Windows)::"
msgstr "Här är ett exempel på en typ (Windows)::"

msgid ""
"class _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"class TYPEDESC(Structure):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"
msgstr ""
"klass _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"klass TYPEDESC(Struktur):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"

msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"Strukturen ``TYPEDESC`` beskriver en COM-datatyp, fältet ``vt`` anger vilket "
"av unionsfälten som är giltigt.  Eftersom fältet ``u`` är definierat som ett "
"anonymt fält är det nu möjligt att komma åt medlemmarna direkt från TYPEDESC-"
"instansen. ``td.lptdesc`` och ``td.u.lptdesc`` är likvärdiga, men den förra "
"är snabbare eftersom den inte behöver skapa en tillfällig unionsinstans::"

msgid ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"
msgstr ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"

msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"Det är möjligt att definiera sub-subklasser av strukturer, de ärver fälten i "
"basklassen.  Om subklassdefinitionen har en separat variabel :attr:"
"`_fields_`, läggs de fält som anges i denna till basklassens fält."

msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"Struktur- och unionskonstruktörer accepterar både positionella argument och "
"nyckelordsargument.  Positionella argument används för att initiera "
"medlemsfält i samma ordning som de visas i :attr:`_fields_`.  Nyckelord i "
"konstruktorn tolkas som attributtilldelningar, vilket innebär att de "
"initierar :attr:`_fields_` med samma namn eller skapar nya attribut för namn "
"som inte finns i :attr:`_fields_`."

msgid ""
"Descriptor for fields of a :class:`Structure` and :class:`Union`. For "
"example::"
msgstr ""
"Deskriptor för fält i en :class:`Structure` och :class:`Union`. Till "
"exempel::"

msgid ""
">>> class Color(Structure):\n"
"...     _fields_ = (\n"
"...         ('red', c_uint8),\n"
"...         ('green', c_uint8),\n"
"...         ('blue', c_uint8),\n"
"...         ('intense', c_bool, 1),\n"
"...         ('blinking', c_bool, 1),\n"
"...    )\n"
"...\n"
">>> Color.red\n"
"<ctypes.CField 'red' type=c_ubyte, ofs=0, size=1>\n"
">>> Color.green.type\n"
"<class 'ctypes.c_ubyte'>\n"
">>> Color.blue.byte_offset\n"
"2\n"
">>> Color.intense\n"
"<ctypes.CField 'intense' type=c_bool, ofs=3, bit_size=1, bit_offset=0>\n"
">>> Color.blinking.bit_offset\n"
"1"
msgstr ""
">>> klass Färg(Struktur):\n"
"...     _fält_ = (\n"
"... ('röd', c_uint8),\n"
"... ('green', c_uint8),\n"
"... ('blue', c_uint8),\n"
"... ('intense', c_bool, 1),\n"
"... ('blinkande', c_bool, 1),\n"
"...    )\n"
"...\n"
">>> Färg.röd\n"
"<ctypes.CField 'red' type=c_ubyte, ofs=0, size=1>\n"
">>> Färg.grön.typ\n"
"<klass 'ctypes.c_ubyte'> >>> Färg.blå.byte_off\n"
">>> Färg.blå.byte_offset\n"
"2\n"
">>> Färg.intensiv\n"
"<ctypes.CField 'intense' type=c_bool, ofs=3, bit_size=1, bit_offset=0>\n"
">>> Färg.blinkande.bit_offset\n"
"1"

msgid "All attributes are read-only."
msgstr "Alla attribut är skrivskyddade."

msgid ""
":class:`!CField` objects are created via :attr:`~Structure._fields_`; do not "
"instantiate the class directly."
msgstr ""
":class:`!CField`-objekt skapas via :attr:`~Structure._fields_`; instansiera "
"inte klassen direkt."

msgid ""
"Previously, descriptors only had ``offset`` and ``size`` attributes and a "
"readable string representation; the :class:`!CField` class was not available "
"directly."
msgstr ""
"Tidigare hade deskriptorer endast attributen ``offset`` och ``size`` och en "
"läsbar strängrepresentation; klassen :class:`!CField` var inte direkt "
"tillgänglig."

msgid "Name of the field, as a string."
msgstr "Namn på fältet, som en sträng."

msgid "Type of the field, as a :ref:`ctypes class <ctypes-data-types>`."
msgstr "Typ av fält, som en :ref:`ctypes class <ctypes-data-types>`."

msgid "Offset of the field, in bytes."
msgstr "Offset för fältet, i byte."

msgid ""
"For bitfields, this is the offset of the underlying byte-aligned *storage "
"unit*; see :attr:`~CField.bit_offset`."
msgstr ""
"För bitfält är detta offset för den underliggande byte-alignerade "
"*lagringsenheten*; se :attr:`~CField.bit_offset`."

msgid "Size of the field, in bytes."
msgstr "Storlek på fältet, i byte."

msgid ""
"For bitfields, this is the size of the underlying *storage unit*. Typically, "
"it has the same size as the bitfield's type."
msgstr ""
"För bitfields är detta storleken på den underliggande *lagringsenheten*. "
"Vanligtvis har den samma storlek som bitfältets typ."

msgid "For non-bitfields, equivalent to :attr:`~CField.byte_size`."
msgstr "För fält som inte är bitfält, motsvarande :attr:`~CField.byte_size`."

msgid ""
"For bitfields, this contains a backwards-compatible bit-packed value that "
"combines :attr:`~CField.bit_size` and :attr:`~CField.bit_offset`. Prefer "
"using the explicit attributes instead."
msgstr ""
"För bitfält innehåller detta ett bakåtkompatibelt bitpackat värde som "
"kombinerar :attr:`~CField.bit_size` och :attr:`~CField.bit_offset`. Föredrar "
"att använda de explicita attributen istället."

msgid "True if this is a bitfield."
msgstr "True om detta är ett bitfält."

msgid ""
"The location of a bitfield within its *storage unit*, that is, within :attr:"
"`~CField.byte_size` bytes of memory starting at :attr:`~CField.byte_offset`."
msgstr ""
"Platsen för ett bitfält inom dess *lagringsenhet*, det vill säga inom :attr:"
"`~CField.byte_size` bytes minne med början vid :attr:`~CField.byte_offset`."

msgid ""
"To get the field's value, read the storage unit as an integer, :ref:`shift "
"left <shifting>` by :attr:`!bit_offset` and take the :attr:`!bit_size` least "
"significant bits."
msgstr ""
"För att få fältets värde, läs lagringsenheten som ett heltal, :ref:`shift "
"left <shifting>` med :attr:`!bit_offset` och ta de :attr:`!bit_size` minst "
"signifikanta bitarna."

msgid ""
"For non-bitfields, :attr:`!bit_offset` is zero and :attr:`!bit_size` is "
"equal to ``byte_size * 8``."
msgstr ""
"För icke-bitfält är :attr:`!bit_offset` noll och :attr:`!bit_size` är lika "
"med ``byte_size * 8``."

msgid ""
"True if this field is anonymous, that is, it contains nested sub-fields that "
"should be merged into a containing structure or union."
msgstr ""
"True om fältet är anonymt, dvs. innehåller nästlade underfält som bör slås "
"samman till en innehållande struktur eller union."

msgid "Arrays and pointers"
msgstr "Arrayer och pekare"

msgid "Abstract base class for arrays."
msgstr "Abstrakt basklass för arrayer."

msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a non-negative integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"Det rekommenderade sättet att skapa konkreta array-typer är att multiplicera "
"valfri :mod:`ctypes`-datatyp med ett icke-negativt heltal.  Alternativt kan "
"du underklassa den här typen och definiera klassvariablerna :attr:`_length_` "
"och :attr:`_type_`. Array-element kan läsas och skrivas med hjälp av "
"standardåtkomst för subscript och slice; för slice-läsning är det "
"resulterande objektet *inte* i sig självt en :class:`Array`."

msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"Ett positivt heltal som anger antalet element i matrisen. Subskriptioner "
"utanför intervallet resulterar i ett :exc:`IndexError`. Kommer att "
"returneras av :func:`len`."

msgid "Specifies the type of each element in the array."
msgstr "Anger typen för varje element i matrisen."

msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""
"Array-underklassens konstruktörer accepterar positionella argument som "
"används för att initiera elementen i ordning."

msgid ""
"Create an array. Equivalent to ``type * length``, where *type* is a :mod:"
"`ctypes` data type and *length* an integer."
msgstr ""
"Skapar en array. Motsvarar ``type * length``, där *type* är en :mod:`ctypes`-"
"datatyp och *length* ett heltal."

msgid ""
"This function is :term:`soft deprecated` in favor of multiplication. There "
"are no plans to remove it."
msgstr ""
"Denna funktion är :term:`soft deprecated` till förmån för multiplikation. "
"Det finns inga planer på att ta bort den."

msgid "Private, abstract base class for pointers."
msgstr "Privat, abstrakt basklass för pekare."

msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"Konkreta pekartyper skapas genom att anropa :func:`POINTER` med den typ som "
"ska pekas på; detta görs automatiskt av :func:`pointer`."

msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"Om en pekare pekar på en array kan dess element läsas och skrivas med hjälp "
"av standardåtkomst för subscript och slice.  Pekarobjekt har ingen storlek, "
"så :func:`len` kommer att ge upphov till :exc:`TypeError`.  Negativa "
"subscripts läser från minnet *före* pekaren (som i C), och out-of-range "
"subscripts kraschar förmodligen med en access violation (om du har tur)."

msgid "Specifies the type pointed to."
msgstr "Anger vilken typ som pekas ut."

msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
"Returnerar det objekt som pekaren till pekar på.  Om du tilldelar detta "
"attribut ändras pekaren till att peka på det tilldelade objektet."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"Detta undantag uppstår när ett anrop av en utländsk funktion inte kan "
"konvertera ett av de passerade argumenten."

msgid "This exception is raised when a COM method call failed."
msgstr "Detta undantag uppstår när ett COM-metodanrop misslyckades."

msgid "The integer value representing the error code."
msgstr "Heltalsvärdet som representerar felkoden."

msgid "The error message."
msgstr "Felmeddelandet."

msgid "The 5-tuple ``(descr, source, helpfile, helpcontext, progid)``."
msgstr "5-tupeln ``(descr, source, helpfile, helpcontext, progid)``."

msgid ""
"*descr* is the textual description.  *source* is the language-dependent "
"``ProgID`` for the class or application that raised the error.  *helpfile* "
"is the path of the help file.  *helpcontext* is the help context "
"identifier.  *progid* is the ``ProgID`` of the interface that defined the "
"error."
msgstr ""
"*descr* är den textuella beskrivningen.  *source* är det språkberoende "
"``ProgID`` för den klass eller det program som orsakade felet.  *helpfile* "
"är sökvägen till hjälpfilen.  *helpcontext* är identifieraren för "
"hjälpsammanhanget.  *progid* är ``ProgID`` för det gränssnitt som "
"definierade felet."
