# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!pkgutil` --- Package extension utility"
msgstr ":mod:`!pkgutil` --- Verktyg för pakettillägg"

msgid "**Source code:** :source:`Lib/pkgutil.py`"
msgstr "**Källkod:** :source:`Lib/pkgutil.py`"

msgid ""
"This module provides utilities for the import system, in particular package "
"support."
msgstr ""
"Denna modul innehåller verktyg för importsystemet, i synnerhet paketstöd."

msgid "A namedtuple that holds a brief summary of a module's info."
msgstr ""
"En namntuple som innehåller en kort sammanfattning av en moduls information."

msgid ""
"Extend the search path for the modules which comprise a package.  Intended "
"use is to place the following code in a package's :file:`__init__.py`::"
msgstr ""
"Utöka sökvägen för de moduler som ingår i ett paket.  Avsedd användning är "
"att placera följande kod i ett pakets :file:`__init__.py`::"

msgid ""
"from pkgutil import extend_path\n"
"__path__ = extend_path(__path__, __name__)"
msgstr ""
"from pkgutil import extend_path\n"
"__path__ = extend_path(__path__, __name__)"

msgid ""
"For each directory on :data:`sys.path` that has a subdirectory that matches "
"the package name, add the subdirectory to the package's :attr:`~module."
"__path__`. This is useful if one wants to distribute different parts of a "
"single logical package as multiple directories."
msgstr ""
"För varje katalog i :data:`sys.path` som har en underkatalog som matchar "
"paketnamnet, lägg till underkatalogen i paketets :attr:`~module.__path__`. "
"Detta är användbart om man vill distribuera olika delar av ett enda logiskt "
"paket som flera kataloger."

msgid ""
"It also looks for :file:`\\*.pkg` files beginning where ``*`` matches the "
"*name* argument.  This feature is similar to :file:`\\*.pth` files (see the :"
"mod:`site` module for more information), except that it doesn't special-case "
"lines starting with ``import``.  A :file:`\\*.pkg` file is trusted at face "
"value: apart from skipping blank lines and ignoring comments, all entries "
"found in a :file:`\\*.pkg` file are added to the path, regardless of whether "
"they exist on the filesystem (this is a feature)."
msgstr ""
"Den letar också efter :file:`\\*.pkg`-filer som börjar där ``*`` matchar "
"argumentet *name*.  Den här funktionen liknar :file:`\\*.pth`-filer (se "
"modulen :mod:`site` för mer information), förutom att den inte "
"specialklassar rader som börjar med ``import``.  En :file:`\\*.pkg`-fil "
"tolkas som den är: förutom att tomma rader hoppas över och kommentarer "
"ignoreras, läggs alla poster som finns i en :file:`\\*.pkg`-fil till i "
"sökvägen, oavsett om de finns i filsystemet eller inte (detta är en "
"funktion)."

msgid ""
"If the input path is not a list (as is the case for frozen packages) it is "
"returned unchanged.  The input path is not modified; an extended copy is "
"returned.  Items are only appended to the copy at the end."
msgstr ""
"Om indatasökvägen inte är en lista (vilket är fallet för frysta paket) "
"returneras den oförändrad.  Inmatningsvägen ändras inte; en utökad kopia "
"returneras.  Objekten läggs bara till i kopian i slutet."

msgid ""
"It is assumed that :data:`sys.path` is a sequence.  Items of :data:`sys."
"path` that are not strings referring to existing directories are ignored. "
"Unicode items on :data:`sys.path` that cause errors when used as filenames "
"may cause this function to raise an exception (in line with :func:`os.path."
"isdir` behavior)."
msgstr ""
"Det antas att :data:`sys.path` är en sekvens.  Element i :data:`sys.path` "
"som inte är strängar som hänvisar till befintliga kataloger ignoreras. "
"Unicode-objekt i :data:`sys.path` som orsakar fel när de används som filnamn "
"kan leda till att denna funktion ger upphov till ett undantag (i linje med :"
"func:`os.path.isdir`-beteendet)."

msgid "Retrieve a :term:`finder` for the given *path_item*."
msgstr "Hämta en :term:`finder` för den angivna *path_item*."

msgid ""
"The returned finder is cached in :data:`sys.path_importer_cache` if it was "
"newly created by a path hook."
msgstr ""
"Den returnerade sökaren cachelagras i :data:`sys.path_importer_cache` om den "
"nyligen skapades av en sökvägskrok."

msgid ""
"The cache (or part of it) can be cleared manually if a rescan of :data:`sys."
"path_hooks` is necessary."
msgstr ""
"Cachen (eller en del av den) kan tömmas manuellt om en ny sökning av :data:"
"`sys.path_hooks` är nödvändig."

msgid ""
"Updated to be based directly on :mod:`importlib` rather than relying on the "
"package internal :pep:`302` import emulation."
msgstr ""
"Uppdaterad för att baseras direkt på :mod:`importlib` snarare än att förlita "
"sig på paketets interna :pep:`302` import-emulering."

msgid "Yield :term:`finder` objects for the given module name."
msgstr "Ger :term:`finder`-objekt för det angivna modulnamnet."

msgid ""
"If *fullname* contains a ``'.'``, the finders will be for the package "
"containing *fullname*, otherwise they will be all registered top level "
"finders (i.e. those on both :data:`sys.meta_path` and :data:`sys."
"path_hooks`)."
msgstr ""
"Om *fullname* innehåller en ``'.'`` kommer sökarna att vara för paketet som "
"innehåller *fullname*, annars kommer de att vara alla registrerade sökare på "
"högsta nivån (dvs. de på både :data:`sys.meta_path` och :data:`sys."
"path_hooks`)."

msgid ""
"If the named module is in a package, that package is imported as a side "
"effect of invoking this function."
msgstr ""
"Om den namngivna modulen ingår i ett paket importeras paketet som en "
"bieffekt av att funktionen anropas."

msgid "If no module name is specified, all top level finders are produced."
msgstr "Om inget modulnamn anges produceras alla sökare på högsta nivån."

msgid ""
"Yields :class:`ModuleInfo` for all submodules on *path*, or, if *path* is "
"``None``, all top-level modules on :data:`sys.path`."
msgstr ""
"Ger :class:`ModuleInfo` för alla undermoduler på *path*, eller, om *path* är "
"``None``, alla moduler på högsta nivån på :data:`sys.path`."

msgid ""
"*path* should be either ``None`` or a list of paths to look for modules in."
msgstr ""
"*path* ska vara antingen ``None`` eller en lista med sökvägar där moduler "
"ska sökas."

msgid ""
"*prefix* is a string to output on the front of every module name on output."
msgstr ""
"*prefix* är en sträng som ska skrivas ut i början av varje modulnamn vid "
"utmatning."

msgid ""
"Only works for a :term:`finder` which defines an ``iter_modules()`` method. "
"This interface is non-standard, so the module also provides implementations "
"for :class:`importlib.machinery.FileFinder` and :class:`zipimport."
"zipimporter`."
msgstr ""
"Fungerar endast för en :term:`finder` som definierar en metod "
"``iter_modules()``. Detta gränssnitt är inte standard, så modulen "
"tillhandahåller även implementeringar för :class:`importlib.machinery."
"FileFinder` och :class:`zipimport.zipimporter`."

msgid ""
"Yields :class:`ModuleInfo` for all modules recursively on *path*, or, if "
"*path* is ``None``, all accessible modules."
msgstr ""
"Ger :class:`ModuleInfo` för alla moduler rekursivt på *path*, eller, om "
"*path* är ``None``, alla tillgängliga moduler."

msgid ""
"Note that this function must import all *packages* (*not* all modules!) on "
"the given *path*, in order to access the ``__path__`` attribute to find "
"submodules."
msgstr ""
"Observera att denna funktion måste importera alla *paket* (*inte* alla "
"moduler!) på den angivna *vägen* för att kunna komma åt attributet "
"``__path__`` och hitta undermoduler."

msgid ""
"*onerror* is a function which gets called with one argument (the name of the "
"package which was being imported) if any exception occurs while trying to "
"import a package.  If no *onerror* function is supplied, :exc:"
"`ImportError`\\s are caught and ignored, while all other exceptions are "
"propagated, terminating the search."
msgstr ""
"*onerror* är en funktion som anropas med ett argument (namnet på det paket "
"som importerades) om något undantag inträffar när du försöker importera ett "
"paket.  Om ingen *onerror*-funktion tillhandahålls fångas och ignoreras :exc:"
"`ImportError`, medan alla andra undantag sprids och avslutar sökningen."

msgid "Examples::"
msgstr "Exempel::"

msgid ""
"# list all modules python can access\n"
"walk_packages()\n"
"\n"
"# list all submodules of ctypes\n"
"walk_packages(ctypes.__path__, ctypes.__name__ + '.')"
msgstr ""
"# list all modules python can access\n"
"walk_packages()\n"
"\n"
"# list all submodules of ctypes\n"
"walk_packages(ctypes.__path__, ctypes.__name__ + '.')"

msgid "Get a resource from a package."
msgstr "Hämta en resurs från ett paket."

msgid ""
"This is a wrapper for the :term:`loader` :meth:`get_data <importlib.abc."
"ResourceLoader.get_data>` API.  The *package* argument should be the name of "
"a package, in standard module format (``foo.bar``).  The *resource* argument "
"should be in the form of a relative filename, using ``/`` as the path "
"separator.  The parent directory name ``..`` is not allowed, and nor is a "
"rooted name (starting with a ``/``)."
msgstr ""
"Detta är en omslagslösning för API:et :term:`loader` :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>`.  Argumentet *package* ska vara "
"namnet på ett paket, i standardmodulformat (``foo.bar``).  Argumentet "
"*resource* ska vara i form av ett relativt filnamn, med ``/`` som "
"sökvägsavgränsare.  Det överordnade katalognamnet ``..`` är inte tillåtet, "
"och inte heller ett rotat namn (som börjar med ``/``)."

msgid ""
"The function returns a binary string that is the contents of the specified "
"resource."
msgstr ""
"Funktionen returnerar en binär sträng som är innehållet i den angivna "
"resursen."

msgid ""
"For packages located in the filesystem, which have already been imported, "
"this is the rough equivalent of::"
msgstr ""
"För paket som finns i filsystemet och som redan har importerats är detta den "
"ungefärliga motsvarigheten till::"

msgid ""
"d = os.path.dirname(sys.modules[package].__file__)\n"
"data = open(os.path.join(d, resource), 'rb').read()"
msgstr ""
"d = os.path.dirname(sys.modules[package].__file__)\n"
"data = open(os.path.join(d, resource), 'rb').read()"

msgid ""
"If the package cannot be located or loaded, or it uses a :term:`loader` "
"which does not support :meth:`get_data <importlib.abc.ResourceLoader."
"get_data>`, then ``None`` is returned.  In particular, the :term:`loader` "
"for :term:`namespace packages <namespace package>` does not support :meth:"
"`get_data <importlib.abc.ResourceLoader.get_data>`."
msgstr ""
"Om paketet inte kan hittas eller laddas, eller om det använder en :term:"
"`loader` som inte stöder :meth:`get_data <importlib.abc.ResourceLoader."
"get_data>`, returneras ``None``.  I synnerhet har :term:`loader` för :term:"
"`namespace packages <namespace package>` inte stöd för :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>`."

msgid "Resolve a name to an object."
msgstr "Återkopplar ett namn till ett objekt."

msgid ""
"This functionality is used in numerous places in the standard library (see :"
"issue:`12915`) - and equivalent functionality is also in widely used third-"
"party packages such as setuptools, Django and Pyramid."
msgstr ""
"Denna funktionalitet används på många ställen i standardbiblioteket (se :"
"issue:`12915`) - och motsvarande funktionalitet finns också i allmänt "
"använda tredjepartspaket som setuptools, Django och Pyramid."

msgid ""
"It is expected that *name* will be a string in one of the following formats, "
"where W is shorthand for a valid Python identifier and dot stands for a "
"literal period in these pseudo-regexes:"
msgstr ""
"Det förväntas att *namn* är en sträng i något av följande format, där W är "
"en kortform för en giltig Python-identifierare och punkt står för en "
"bokstavlig punkt i dessa pseudo-regexer:"

msgid "``W(.W)*``"
msgstr "``W(.W)*``"

msgid "``W(.W)*:(W(.W)*)?``"
msgstr "``W(.W)*:(W(.W)*)?``"

msgid ""
"The first form is intended for backward compatibility only. It assumes that "
"some part of the dotted name is a package, and the rest is an object "
"somewhere within that package, possibly nested inside other objects. Because "
"the place where the package stops and the object hierarchy starts can't be "
"inferred by inspection, repeated attempts to import must be done with this "
"form."
msgstr ""
"Den första formen är endast avsedd för bakåtkompatibilitet. Den förutsätter "
"att en del av det prickade namnet är ett paket och att resten är ett objekt "
"någonstans i paketet, eventuellt nästlat inuti andra objekt. Eftersom "
"platsen där paketet slutar och objekthierarkin börjar inte kan utläsas genom "
"inspektion, måste upprepade försök att importera göras med den här formen."

msgid ""
"In the second form, the caller makes the division point clear through the "
"provision of a single colon: the dotted name to the left of the colon is a "
"package to be imported, and the dotted name to the right is the object "
"hierarchy within that package. Only one import is needed in this form. If it "
"ends with the colon, then a module object is returned."
msgstr ""
"I det andra formuläret klargör den som ringer upp uppdelningen genom att "
"använda ett enda kolon: det prickade namnet till vänster om kolon är ett "
"paket som ska importeras och det prickade namnet till höger är "
"objekthierarkin inom det paketet. Endast en import behövs i denna form. Om "
"den slutar med ett kolon returneras ett modulobjekt."

msgid ""
"The function will return an object (which might be a module), or raise one "
"of the following exceptions:"
msgstr ""
"Funktionen kommer att returnera ett objekt (som kan vara en modul) eller ge "
"upphov till något av följande undantag:"

msgid ":exc:`ValueError` -- if *name* isn't in a recognised format."
msgstr ":exc:`ValueError` -- om *namn* inte är i ett erkänt format."

msgid ":exc:`ImportError` -- if an import failed when it shouldn't have."
msgstr ""
":exc:`ImportError` -- om en import misslyckades när den inte borde ha gjort "
"det."

msgid ""
":exc:`AttributeError` -- If a failure occurred when traversing the object "
"hierarchy within the imported package to get to the desired object."
msgstr ""
":exc:`AttributeError` -- Om ett fel uppstod när objekthierarkin i det "
"importerade paketet genomkorsades för att komma till det önskade objektet."
