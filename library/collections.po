# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!collections` --- Container datatypes"
msgstr ":mod:`!collections` --- Datatyper för behållare"

msgid "**Source code:** :source:`Lib/collections/__init__.py`"
msgstr "**Källkod:** :source:`Lib/collections/__init__.py`"

msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, :class:"
"`dict`, :class:`list`, :class:`set`, and :class:`tuple`."
msgstr ""
"Denna modul implementerar specialiserade datatyper för containrar som ger "
"alternativ till Pythons inbyggda containrar för allmänna ändamål, :class:"
"`dict`, :class:`list`, :class:`set` och :class:`tuple`."

msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

msgid "factory function for creating tuple subclasses with named fields"
msgstr "fabriksfunktion för att skapa tuple-subklasser med namngivna fält"

msgid ":class:`deque`"
msgstr ":class:`deque`"

msgid "list-like container with fast appends and pops on either end"
msgstr "listliknande behållare med snabba tillägg och öppningar i båda ändar"

msgid ":class:`ChainMap`"
msgstr ":class:`KedjeMap`"

msgid "dict-like class for creating a single view of multiple mappings"
msgstr "diktliknande klass för att skapa en enda vy av flera mappningar"

msgid ":class:`Counter`"
msgstr ":class:`Counter`"

msgid "dict subclass for counting :term:`hashable` objects"
msgstr "dict-underklass för räkning av :term:`hashable`-objekt"

msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

msgid "dict subclass that remembers the order entries were added"
msgstr "dict-underklass som kommer ihåg i vilken ordning posterna lades till"

msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

msgid "dict subclass that calls a factory function to supply missing values"
msgstr ""
"dict-underklass som anropar en fabriksfunktion för att leverera saknade "
"värden"

msgid ":class:`UserDict`"
msgstr ":class:`UserDict`"

msgid "wrapper around dictionary objects for easier dict subclassing"
msgstr "omslag runt ordboksobjekt för enklare underklassning av ordböcker"

msgid ":class:`UserList`"
msgstr ":class:`UserList`"

msgid "wrapper around list objects for easier list subclassing"
msgstr "omslag runt listobjekt för enklare underklassning av listor"

msgid ":class:`UserString`"
msgstr ":class:`UserString`"

msgid "wrapper around string objects for easier string subclassing"
msgstr "omslag runt strängobjekt för enklare underklassning av strängar"

msgid ":class:`ChainMap` objects"
msgstr ":class:`ChainMap`-objekt"

msgid ""
"A :class:`ChainMap` class is provided for quickly linking a number of "
"mappings so they can be treated as a single unit.  It is often much faster "
"than creating a new dictionary and running multiple :meth:`~dict.update` "
"calls."
msgstr ""
"En :class:`ChainMap`-klass tillhandahålls för att snabbt länka ett antal "
"mappningar så att de kan behandlas som en enda enhet.  Det är ofta mycket "
"snabbare än att skapa en ny ordbok och köra flera :meth:`~dict.update`-anrop."

msgid ""
"The class can be used to simulate nested scopes and is useful in templating."
msgstr ""
"Klassen kan användas för att simulera nästlade scopes och är användbar i "
"templating."

msgid ""
"A :class:`ChainMap` groups multiple dicts or other mappings together to "
"create a single, updateable view.  If no *maps* are specified, a single "
"empty dictionary is provided so that a new chain always has at least one "
"mapping."
msgstr ""
"En :class:`ChainMap` grupperar flera dicts eller andra mappningar "
"tillsammans för att skapa en enda, uppdaterbar vy.  Om inga *mappningar* "
"anges, tillhandahålls en enda tom ordbok så att en ny kedja alltid har minst "
"en mappning."

msgid ""
"The underlying mappings are stored in a list.  That list is public and can "
"be accessed or updated using the *maps* attribute.  There is no other state."
msgstr ""
"De underliggande mappningarna lagras i en lista.  Listan är offentlig och "
"kan nås eller uppdateras med hjälp av attributet *maps*.  Det finns inget "
"annat tillstånd."

msgid ""
"Lookups search the underlying mappings successively until a key is found.  "
"In contrast, writes, updates, and deletions only operate on the first "
"mapping."
msgstr ""
"Lookups söker igenom de underliggande mappningarna successivt tills en "
"nyckel hittas.  Skrivningar, uppdateringar och borttagningar påverkar "
"däremot bara den första mappningen."

msgid ""
"A :class:`ChainMap` incorporates the underlying mappings by reference.  So, "
"if one of the underlying mappings gets updated, those changes will be "
"reflected in :class:`ChainMap`."
msgstr ""
"En :class:`ChainMap` innehåller de underliggande mappningarna genom "
"referens.  Så om en av de underliggande mappningarna uppdateras, kommer "
"dessa ändringar att återspeglas i :class:`ChainMap`."

msgid ""
"All of the usual dictionary methods are supported.  In addition, there is a "
"*maps* attribute, a method for creating new subcontexts, and a property for "
"accessing all but the first mapping:"
msgstr ""
"Alla de vanliga metoderna för ordböcker stöds.  Dessutom finns ett *maps*-"
"attribut, en metod för att skapa nya underkontexter och en egenskap för att "
"komma åt alla mappningar utom den första:"

msgid ""
"A user updateable list of mappings.  The list is ordered from first-searched "
"to last-searched.  It is the only stored state and can be modified to change "
"which mappings are searched.  The list should always contain at least one "
"mapping."
msgstr ""
"En lista med mappningar som kan uppdateras av användaren.  Listan är ordnad "
"från först sökta till sist sökta.  Det är det enda lagrade tillståndet och "
"kan modifieras för att ändra vilka mappningar som ska sökas.  Listan bör "
"alltid innehålla minst en mappning."

msgid ""
"Returns a new :class:`ChainMap` containing a new map followed by all of the "
"maps in the current instance.  If ``m`` is specified, it becomes the new map "
"at the front of the list of mappings; if not specified, an empty dict is "
"used, so that a call to ``d.new_child()`` is equivalent to: ``ChainMap({}, "
"*d.maps)``. If any keyword arguments are specified, they update passed map "
"or new empty dict. This method is used for creating subcontexts that can be "
"updated without altering values in any of the parent mappings."
msgstr ""
"Returnerar en ny :class:`ChainMap` som innehåller en ny karta följd av alla "
"kartor i den aktuella instansen.  Om ``m`` specificeras blir det den nya "
"kartan längst fram i listan över mappningar; om den inte specificeras "
"används en tom dict, så att ett anrop till ``d.new_child()`` är likvärdigt "
"med: ``ChainMap({}, *d.maps)``. Om några nyckelordsargument anges uppdaterar "
"de den map som skickas eller en ny tom dict. Den här metoden används för att "
"skapa underkontexter som kan uppdateras utan att ändra värden i någon av de "
"överordnade mappningarna."

msgid "The optional ``m`` parameter was added."
msgstr "Den valfria parametern ``m`` har lagts till."

msgid "Keyword arguments support was added."
msgstr "Stöd för sökordsargument har lagts till."

msgid ""
"Property returning a new :class:`ChainMap` containing all of the maps in the "
"current instance except the first one.  This is useful for skipping the "
"first map in the search.  Use cases are similar to those for the :keyword:"
"`nonlocal` keyword used in :term:`nested scopes <nested scope>`.  The use "
"cases also parallel those for the built-in :func:`super` function.  A "
"reference to ``d.parents`` is equivalent to: ``ChainMap(*d.maps[1:])``."
msgstr ""
"Egenskap som returnerar en ny :class:`ChainMap` som innehåller alla kartor i "
"den aktuella instansen utom den första.  Detta är användbart för att hoppa "
"över den första kartan i sökningen.  Användningsfallen liknar dem för "
"nyckelordet :keyword:`nonlocal` som används i :term:`nested scopes <nested "
"scope>`.  Användningsfallen är också parallella med dem för den inbyggda "
"funktionen :func:`super`.  En referens till ``d.parents`` är likvärdig med: "
"``ChainMap(*d.maps[1:])``."

msgid ""
"Note, the iteration order of a :class:`ChainMap` is determined by scanning "
"the mappings last to first::"
msgstr ""
"Observera att iterationsordningen för en :class:`ChainMap` bestäms genom att "
"skanna mappningarna från sist till först::"

msgid ""
">>> baseline = {'music': 'bach', 'art': 'rembrandt'}\n"
">>> adjustments = {'art': 'van gogh', 'opera': 'carmen'}\n"
">>> list(ChainMap(adjustments, baseline))\n"
"['music', 'art', 'opera']"
msgstr ""
">>> baseline = {'music': 'bach', 'konst': 'rembrandt'}\n"
">>> justeringar = {'konst': 'van gogh', 'opera': 'carmen'}\n"
">>> list(ChainMap(justeringar, baslinje))\n"
"['musik', 'konst', 'opera']"

msgid ""
"This gives the same ordering as a series of :meth:`dict.update` calls "
"starting with the last mapping::"
msgstr ""
"Detta ger samma ordning som en serie :meth:`dict.update`-anrop som börjar "
"med den sista mappningen::"

msgid ""
">>> combined = baseline.copy()\n"
">>> combined.update(adjustments)\n"
">>> list(combined)\n"
"['music', 'art', 'opera']"
msgstr ""
">>> kombinerad = baslinje.kopiera()\n"
">>> kombinerad.uppdatera(justeringar)\n"
">>> list(kombinerad)\n"
"['musik', 'konst', 'opera']"

msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr ""
"Lagt till stöd för operatorerna ``|`` och ``|=``, specificerat i :pep:`584`."

msgid ""
"The `MultiContext class <https://github.com/enthought/codetools/blob/4.0.0/"
"codetools/contexts/multi_context.py>`_ in the Enthought `CodeTools package "
"<https://github.com/enthought/codetools>`_ has options to support writing to "
"any mapping in the chain."
msgstr ""
"Klassen `MultiContext <https://github.com/enthought/codetools/blob/4.0.0/"
"codetools/contexts/multi_context.py>`_ i Enthoughts `CodeTools-paket "
"<https://github.com/enthought/codetools>`_ har alternativ för att stödja "
"skrivning till alla mappningar i kedjan."

msgid ""
"Django's `Context class <https://github.com/django/django/blob/main/django/"
"template/context.py>`_ for templating is a read-only chain of mappings.  It "
"also features pushing and popping of contexts similar to the :meth:"
"`~collections.ChainMap.new_child` method and the :attr:`~collections."
"ChainMap.parents` property."
msgstr ""
"Djangos `Context class <https://github.com/django/django/blob/main/django/"
"template/context.py>`_ för templating är en skrivskyddad kedja av "
"mappningar.  Den innehåller också pushing och popping av kontexter som "
"liknar metoden :meth:`~collections.ChainMap.new_child` och egenskapen :attr:"
"`~collections.ChainMap.parents`."

msgid ""
"The `Nested Contexts recipe <https://code.activestate.com/recipes/577434-"
"nested-contexts-a-chain-of-mapping-objects/>`_ has options to control "
"whether writes and other mutations apply only to the first mapping or to any "
"mapping in the chain."
msgstr ""
"Receptet \"Nested Contexts\" <https://code.activestate.com/recipes/577434-"
"nested-contexts-a-chain-of-mapping-objects/>`_ har alternativ för att styra "
"om skrivningar och andra mutationer endast ska gälla den första mappningen "
"eller alla mappningar i kedjan."

msgid ""
"A `greatly simplified read-only version of Chainmap <https://code."
"activestate.com/recipes/305268/>`_."
msgstr ""
"En \"kraftigt förenklad skrivskyddad version av Chainmap <https://code."
"activestate.com/recipes/305268/>`_."

msgid ":class:`ChainMap` Examples and Recipes"
msgstr ":class:`ChainMap` Exempel och recept"

msgid "This section shows various approaches to working with chained maps."
msgstr "I detta avsnitt visas olika sätt att arbeta med kedjade kartor."

msgid "Example of simulating Python's internal lookup chain::"
msgstr "Exempel på simulering av Pythons interna lookup-kedja::"

msgid ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"
msgstr ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"

msgid ""
"Example of letting user specified command-line arguments take precedence "
"over environment variables which in turn take precedence over default "
"values::"
msgstr ""
"Exempel på att låta användarspecifika kommandoradsargument ha företräde "
"framför miljövariabler som i sin tur har företräde framför standardvärden::"

msgid ""
"import os, argparse\n"
"\n"
"defaults = {'color': 'red', 'user': 'guest'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--user')\n"
"parser.add_argument('-c', '--color')\n"
"namespace = parser.parse_args()\n"
"command_line_args = {k: v for k, v in vars(namespace).items() if v is not "
"None}\n"
"\n"
"combined = ChainMap(command_line_args, os.environ, defaults)\n"
"print(combined['color'])\n"
"print(combined['user'])"
msgstr ""
"import os, argparse\n"
"\n"
"defaults = {'color': 'red', 'user': 'guest'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--user')\n"
"parser.add_argument('-c', '--color')\n"
"namespace = parser.parse_args()\n"
"command_line_args = {k: v for k, v in vars(namespace).items() if v is not "
"None}\n"
"\n"
"combined = ChainMap(command_line_args, os.environ, defaults)\n"
"print(combined['color'])\n"
"print(combined['user'])"

msgid ""
"Example patterns for using the :class:`ChainMap` class to simulate nested "
"contexts::"
msgstr ""
"Exempel på mönster för användning av klassen :class:`ChainMap` för att "
"simulera nästlade kontexter::"

msgid ""
"c = ChainMap()        # Create root context\n"
"d = c.new_child()     # Create nested child context\n"
"e = c.new_child()     # Child of c, independent from d\n"
"e.maps[0]             # Current context dictionary -- like Python's "
"locals()\n"
"e.maps[-1]            # Root context -- like Python's globals()\n"
"e.parents             # Enclosing context chain -- like Python's nonlocals\n"
"\n"
"d['x'] = 1            # Set value in current context\n"
"d['x']                # Get first key in the chain of contexts\n"
"del d['x']            # Delete from current context\n"
"list(d)               # All nested values\n"
"k in d                # Check all nested values\n"
"len(d)                # Number of nested values\n"
"d.items()             # All nested items\n"
"dict(d)               # Flatten into a regular dictionary"
msgstr ""
"c = ChainMap() # Skapa rotkontext\n"
"d = c.new_child() # Skapa ett nästlat barnkontext\n"
"e = c.new_child() # Barn till c, oberoende av d\n"
"e.maps[0] # Aktuell kontextordbok -- som Pythons locals()\n"
"e.maps[-1] # Rotkontext -- som Pythons globals()\n"
"e.parents # Omslutande kontextkedja -- som Pythons nonlocals\n"
"\n"
"d['x'] = 1 # Ange värde i aktuell kontext\n"
"d['x'] # Hämta första nyckeln i kedjan av kontexter\n"
"del d['x'] # Ta bort från aktuell kontext\n"
"list(d) # Alla nästlade värden\n"
"k in d # Kontrollera alla nästlade värden\n"
"len(d) # Antal nästlade värden\n"
"d.items() # Alla nästlade objekt\n"
"dict(d) # Plattas ut till en vanlig ordbok"

msgid ""
"The :class:`ChainMap` class only makes updates (writes and deletions) to the "
"first mapping in the chain while lookups will search the full chain.  "
"However, if deep writes and deletions are desired, it is easy to make a "
"subclass that updates keys found deeper in the chain::"
msgstr ""
"Klassen :class:`ChainMap` gör bara uppdateringar (skrivningar och "
"raderingar) till den första mappningen i kedjan medan uppslagningar söker i "
"hela kedjan.  Men om djupa skrivningar och raderingar önskas är det enkelt "
"att skapa en underklass som uppdaterar nycklar som finns djupare i kedjan::"

msgid ""
"class DeepChainMap(ChainMap):\n"
"    'Variant of ChainMap that allows direct updates to inner scopes'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                mapping[key] = value\n"
"                return\n"
"        self.maps[0][key] = value\n"
"\n"
"    def __delitem__(self, key):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                del mapping[key]\n"
"                return\n"
"        raise KeyError(key)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': "
"'yellow'})\n"
">>> d['lion'] = 'orange'         # update an existing key two levels down\n"
">>> d['snake'] = 'red'           # new keys get added to the topmost dict\n"
">>> del d['elephant']            # remove an existing key one level down\n"
">>> d                            # display result\n"
"DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})"
msgstr ""
"klass DeepChainMap(ChainMap):\n"
"    'Variant av ChainMap som tillåter direkta uppdateringar till inre "
"scopes'\n"
"\n"
"    def __setitem__(self, nyckel, värde):\n"
"        för mappning i self.maps:\n"
"            if nyckel i mappning:\n"
"                mappning[nyckel] = värde\n"
"                returnera\n"
"        self.maps[0][nyckel] = värde\n"
"\n"
"    def __delitem__(self, nyckel):\n"
"        för mappning i self.maps:\n"
"            om nyckel i mappning:\n"
"                del mappning[nyckel]\n"
"                return\n"
"        raise KeyError(nyckel)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'svart'}, {'elefant': 'blå'}, {'lejon': "
"'gul'})\n"
">>> d['lion'] = 'orange' # uppdatera en befintlig nyckel två nivåer ner\n"
">>> d['snake'] = 'red' # nya nycklar läggs till i den översta dict\n"
">>> del d['elephant'] # ta bort en befintlig nyckel en nivå ner\n"
">>> d # visa resultat\n"
"DeepChainMap({'zebra': 'svart', 'orm': 'röd'}, {}, {'lejon': 'orange'})"

msgid ":class:`Counter` objects"
msgstr ":class:`Counter`-objekt"

msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr ""
"Ett räkneverktyg tillhandahålls för att stödja praktiska och snabba "
"räkningar. Till exempel::"

msgid ""
">>> # Tally occurrences of words in a list\n"
">>> cnt = Counter()\n"
">>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:\n"
"...     cnt[word] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})\n"
"\n"
">>> # Find the ten most common words in Hamlet\n"
">>> import re\n"
">>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(words).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]"
msgstr ""
">>> # Räkna upp förekomster av ord i en lista\n"
">>> cnt = Räknare()\n"
">>> for word in ['röd', 'blå', 'röd', 'grön', 'blå', 'blå']:\n"
"... cnt[ord] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'blå': 3, 'röd': 2, 'grön': 1})\n"
"\n"
">>> # Hitta de tio vanligaste orden i Hamlet\n"
">>> import re\n"
">>> ord = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(ord).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('du', 554), ('en', 546), ('min', 514), ('hamlet', 471), ('i', 451)]"

msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting :term:`hashable` "
"objects. It is a collection where elements are stored as dictionary keys and "
"their counts are stored as dictionary values.  Counts are allowed to be any "
"integer value including zero or negative counts.  The :class:`Counter` class "
"is similar to bags or multisets in other languages."
msgstr ""
"En :class:`Counter` är en :class:`dict`-underklass för att räkna :term:"
"`hashable`-objekt. Det är en samling där element lagras som nycklar i en "
"ordbok och deras antal lagras som ordboksvärden.  Antalet kan vara vilket "
"heltalsvärde som helst, inklusive noll eller negativa värden.  Klassen :"
"class:`Counter` liknar påsar eller multisets i andra språk."

msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr ""
"Element räknas från en *iterable* eller initialiseras från en annan "
"*mapping* (eller räknare):"

msgid ""
"Counter objects have a dictionary interface except that they return a zero "
"count for missing items instead of raising a :exc:`KeyError`:"
msgstr ""
"Counter-objekt har ett dictionary-gränssnitt förutom att de returnerar ett "
"nollvärde för saknade objekt i stället för att ge upphov till ett :exc:"
"`KeyError`:"

msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr ""
"Att nollställa ett räkneverk tar inte bort ett element från ett räkneverk. "
"Använd ``del`` för att ta bort det helt:"

msgid ""
"As a :class:`dict` subclass, :class:`Counter` inherited the capability to "
"remember insertion order.  Math operations on *Counter* objects also "
"preserve order.  Results are ordered according to when an element is first "
"encountered in the left operand and then by the order encountered in the "
"right operand."
msgstr ""
"Som en underklass till :class:`dict` ärvde :class:`Counter` förmågan att "
"komma ihåg inmatningsordning.  Matematiska operationer på *Counter*-objekt "
"bevarar också ordningen.  Resultaten sorteras efter när ett element först "
"påträffas i den vänstra operanden och sedan efter den ordning som det "
"påträffas i den högra operanden."

msgid ""
"Counter objects support additional methods beyond those available for all "
"dictionaries:"
msgstr ""
"Counter-objekt stöder ytterligare metoder utöver de som är tillgängliga för "
"alla ordböcker:"

msgid ""
"Return an iterator over elements repeating each as many times as its count.  "
"Elements are returned in the order first encountered. If an element's count "
"is less than one, :meth:`elements` will ignore it."
msgstr ""
"Returnerar en iterator över element som upprepar varje element lika många "
"gånger som dess antal.  Elementen returneras i den ordning de först "
"påträffades. Om ett elements antal är mindre än ett kommer :meth:`elements` "
"att ignorera det."

msgid ""
"Return a list of the *n* most common elements and their counts from the most "
"common to the least.  If *n* is omitted or ``None``, :meth:`most_common` "
"returns *all* elements in the counter. Elements with equal counts are "
"ordered in the order first encountered:"
msgstr ""
"Returnerar en lista med de *n* vanligaste elementen och deras antal från det "
"vanligaste till det minst vanliga.  Om *n* utelämnas eller ``None`` "
"returnerar :meth:`most_common` *alla* element i räknaren. Element med lika "
"antal ordnas i den ordning som de först påträffades:"

msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr ""
"Element subtraheras från en *iterable* eller från en annan *mappning* (eller "
"räknare).  Som :meth:`dict.update` men subtraherar räkningar istället för "
"att ersätta dem.  Både ingångar och utgångar kan vara noll eller negativa."

msgid "Compute the sum of the counts."
msgstr "Beräkna summan av räkningarna."

msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr ""
"De vanliga ordboksmetoderna är tillgängliga för :class:`Counter`-objekt, "
"förutom två som fungerar annorlunda för räknare."

msgid "This class method is not implemented for :class:`Counter` objects."
msgstr "Denna klassmetod är inte implementerad för :class:`Counter`-objekt."

msgid ""
"Elements are counted from an *iterable* or added-in from another *mapping* "
"(or counter).  Like :meth:`dict.update` but adds counts instead of replacing "
"them.  Also, the *iterable* is expected to be a sequence of elements, not a "
"sequence of ``(key, value)`` pairs."
msgstr ""
"Element räknas från en *iterable* eller läggs till från en annan *mappning* "
"(eller räknare).  Som :meth:`dict.update` men lägger till räkningar istället "
"för att ersätta dem.  Dessutom förväntas *iterable* vara en sekvens av "
"element, inte en sekvens av par av typen ``(nyckel, värde)``."

msgid ""
"Counters support rich comparison operators for equality, subset, and "
"superset relationships: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. All of "
"those tests treat missing elements as having zero counts so that "
"``Counter(a=1) == Counter(a=1, b=0)`` returns true."
msgstr ""
"Counters stöder omfattande jämförelseoperatorer för jämlikhet, delmängd och "
"övermängdsrelationer: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. Alla "
"dessa tester behandlar saknade element som om de har noll i antal, så att "
"``Counter(a=1) == Counter(a=1, b=0)`` returnerar sant."

msgid "Rich comparison operations were added."
msgstr "Rika jämförelseoperationer har lagts till."

msgid ""
"In equality tests, missing elements are treated as having zero counts. "
"Formerly, ``Counter(a=3)`` and ``Counter(a=3, b=0)`` were considered "
"distinct."
msgstr ""
"I likhetstester behandlas saknade element som om de hade noll räkningar. "
"Tidigare ansågs ``Counter(a=3)`` och ``Counter(a=3, b=0)`` vara skilda."

msgid "Common patterns for working with :class:`Counter` objects::"
msgstr "Vanliga mönster för att arbeta med :class:`Counter`-objekt::"

msgid ""
"c.total()                       # total of all counts\n"
"c.clear()                       # reset all counts\n"
"list(c)                         # list unique elements\n"
"set(c)                          # convert to a set\n"
"dict(c)                         # convert to a regular dictionary\n"
"c.items()                       # access the (elem, cnt) pairs\n"
"Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs\n"
"c.most_common()[:-n-1:-1]       # n least common elements\n"
"+c                              # remove zero and negative counts"
msgstr ""
"c.total() # summa av alla räkningar\n"
"c.clear() # återställ alla räkningar\n"
"list(c) # lista unika element\n"
"set(c) # konvertera till en uppsättning\n"
"dict(c) # konvertera till en vanlig ordbok\n"
"c.items() # tillgång till paren (elem, cnt)\n"
"Counter(dict(list_of_pairs))    # konvertera från en lista med (elem, cnt)-"
"par\n"
"c.most_common()[:-n-1:-1] # n minst gemensamma element\n"
"+c # ta bort noll och negativa räkningar"

msgid ""
"Several mathematical operations are provided for combining :class:`Counter` "
"objects to produce multisets (counters that have counts greater than zero). "
"Addition and subtraction combine counters by adding or subtracting the "
"counts of corresponding elements.  Intersection and union return the minimum "
"and maximum of corresponding counts.  Equality and inclusion compare "
"corresponding counts.  Each operation can accept inputs with signed counts, "
"but the output will exclude results with counts of zero or less."
msgstr ""
"Flera matematiska operationer finns för att kombinera :class:`Counter`-"
"objekt för att producera multisets (räknare som har antal större än noll). "
"Addition och subtraktion kombinerar räknare genom att addera eller "
"subtrahera räknevärdena för motsvarande element.  Intersection och union "
"returnerar minimum och maximum av motsvarande räkningar.  Equality och "
"inclusion jämför motsvarande räkningar.  Varje operation kan acceptera "
"inmatningar med signerade räkningar, men utmatningen kommer att utesluta "
"resultat med räkningar på noll eller mindre."

msgid ""
">>> c = Counter(a=3, b=1)\n"
">>> d = Counter(a=1, b=2)\n"
">>> c + d                       # add two counters together:  c[x] + d[x]\n"
"Counter({'a': 4, 'b': 3})\n"
">>> c - d                       # subtract (keeping only positive counts)\n"
"Counter({'a': 2})\n"
">>> c & d                       # intersection:  min(c[x], d[x])\n"
"Counter({'a': 1, 'b': 1})\n"
">>> c | d                       # union:  max(c[x], d[x])\n"
"Counter({'a': 3, 'b': 2})\n"
">>> c == d                      # equality:  c[x] == d[x]\n"
"False\n"
">>> c <= d                      # inclusion:  c[x] <= d[x]\n"
"False"
msgstr ""
">>> c = Räknare(a=3, b=1)\n"
">>> d = Räknare(a=1, b=2)\n"
">>> c + d # lägg till två räknare tillsammans: c[x] + d[x]\n"
"Räknare({'a': 4, 'b': 3})\n"
">>> c - d # subtrahera (behåller endast positiva räkningar)\n"
"Räknare({'a': 2})\n"
">>> c & d # skärningspunkt: min(c[x], d[x])\n"
"Räknare({'a': 1, 'b': 1})\n"
">>> c | d # union: max(c[x], d[x])\n"
"Räknare({'a': 3, 'b': 2})\n"
">>> c == d # jämlikhet: c[x] == d[x]\n"
"Falskt\n"
">>> c <= d # inkludering: c[x] <= d[x]\n"
"False"

msgid ""
"Unary addition and subtraction are shortcuts for adding an empty counter or "
"subtracting from an empty counter."
msgstr ""
"Unary addition och subtraction är genvägar för att addera en tom räknare "
"eller subtrahera från en tom räknare."

msgid ""
"Added support for unary plus, unary minus, and in-place multiset operations."
msgstr ""
"Stöd för unary plus, unary minus och in-place multiset-operationer har lagts "
"till."

msgid ""
"Counters were primarily designed to work with positive integers to represent "
"running counts; however, care was taken to not unnecessarily preclude use "
"cases needing other types or negative values.  To help with those use cases, "
"this section documents the minimum range and type restrictions."
msgstr ""
"Räknare utformades i första hand för att fungera med positiva heltal för att "
"representera löpande räkningar, men man var noga med att inte i onödan "
"utesluta användningsfall som behövde andra typer eller negativa värden.  För "
"att hjälpa till med dessa användningsfall dokumenterar detta avsnitt "
"minimiintervall och typbegränsningar."

msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be numbers "
"representing counts, but you *could* store anything in the value field."
msgstr ""
"Klassen :class:`Counter` är i sig en dictionary-subklass utan några "
"restriktioner för dess nycklar och värden.  Värdena är avsedda att vara "
"siffror som representerar antal, men du *kan* lagra vad som helst i "
"värdefältet."

msgid ""
"The :meth:`~Counter.most_common` method requires only that the values be "
"orderable."
msgstr ""
"Metoden :meth:`~Counter.most_common` kräver endast att värdena är "
"ordningsbara."

msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only "
"support addition and subtraction.  So fractions, floats, and decimals would "
"work and negative values are supported.  The same is also true for :meth:"
"`~Counter.update` and :meth:`~Counter.subtract` which allow negative and "
"zero values for both inputs and outputs."
msgstr ""
"För in-place-operationer som ``c[key] += 1`` behöver värdetypen bara stödja "
"addition och subtraktion.  Så bråk, flyttal och decimaler skulle fungera och "
"negativa värden stöds.  Detsamma gäller även för :meth:`~Counter.update` "
"och :meth:`~Counter.subtract` som tillåter negativa och nollvärden för både "
"in- och utdata."

msgid ""
"The multiset methods are designed only for use cases with positive values. "
"The inputs may be negative or zero, but only outputs with positive values "
"are created.  There are no type restrictions, but the value type needs to "
"support addition, subtraction, and comparison."
msgstr ""
"Multiset-metoderna är endast avsedda för användningsfall med positiva "
"värden. Ingångsvärdena kan vara negativa eller noll, men endast utgångar med "
"positiva värden skapas.  Det finns inga typbegränsningar, men värdetypen "
"måste stödja addition, subtraktion och jämförelse."

msgid ""
"The :meth:`~Counter.elements` method requires integer counts.  It ignores "
"zero and negative counts."
msgstr ""
"Metoden :meth:`~Counter.elements` kräver heltalsräkningar.  Den ignorerar "
"noll och negativa räkningar."

msgid ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-base/html_node/Bag."
"html>`_ in Smalltalk."
msgstr ""
"`Bag-klass <https://www.gnu.org/software/smalltalk/manual-base/html_node/Bag."
"html>`_ i Smalltalk."

msgid ""
"Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr ""
"Wikipedia-inlägg för `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."

msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ handledning med exempel."

msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth, "
"Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise "
"19*."
msgstr ""
"För matematiska operationer på flermängder och deras användningsområden, se "
"*Knuth, Donald. The Art of Computer Programming Volume II, avsnitt 4.6.3, "
"övning 19*."

msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`::"
msgstr ""
"För att räkna upp alla distinkta fleruppsättningar av en viss storlek över "
"en viss uppsättning element, se :func:`itertools."
"combinations_with_replacement`::"

msgid ""
"map(Counter, combinations_with_replacement('ABC', 2)) # --> AA AB AC BB BC CC"
msgstr ""
"map(Räknare, kombinationer_med_ersättning('ABC', 2)) # --> AA AB AC BB BC CC"

msgid ":class:`deque` objects"
msgstr ":class:`deque`-objekt"

msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is "
"empty."
msgstr ""
"Returnerar ett nytt deque-objekt som initierats från vänster till höger "
"(med :meth:`append`) med data från *iterable*.  Om *iterable* inte anges är "
"det nya deque-objektet tomt."

msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same *O*\\ (1) performance in either direction."
msgstr ""
"Deques är en generalisering av staplar och köer (namnet uttalas \"deck\" och "
"är en förkortning av \"double-ended queue\").  Deques stöder trådsäkra, "
"minneseffektiva appends och pops från vardera sidan av deque med ungefär "
"samma *O*\\ (1) prestanda i båda riktningarna."

msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur *O*\\ (*n*) memory movement costs "
"for ``pop(0)`` and ``insert(0, v)`` operations which change both the size "
"and position of the underlying data representation."
msgstr ""
"Även om :class:`list`-objekt stöder liknande operationer är de optimerade "
"för snabba operationer med fasta längder och medför *O*\\ (*n*) "
"minnesförflyttningskostnader för operationerna ``pop(0)`` och ``insert(0, "
"v)`` som ändrar både storleken och positionen för den underliggande "
"datarepresentationen."

msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an arbitrary "
"length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where "
"only the most recent activity is of interest."
msgstr ""
"Om *maxlen* inte anges eller är ``None``, kan deques växa till godtycklig "
"längd.  I annat fall är deque begränsad till den angivna maximala längden.  "
"När en deque med begränsad längd är full, när nya objekt läggs till, "
"kasseras ett motsvarande antal objekt från den motsatta änden.  Deques med "
"begränsad längd har en funktionalitet som liknar filtret ``tail`` i Unix. De "
"är också användbara för att spåra transaktioner och andra datapooler där "
"endast den senaste aktiviteten är av intresse."

msgid "Deque objects support the following methods:"
msgstr "Deque-objekt stöder följande metoder:"

msgid "Add *x* to the right side of the deque."
msgstr "Lägg till *x* på höger sida av deque."

msgid "Add *x* to the left side of the deque."
msgstr "Lägg till *x* på vänster sida av deque."

msgid "Remove all elements from the deque leaving it with length 0."
msgstr "Ta bort alla element från deque och lämna den med längd 0."

msgid "Create a shallow copy of the deque."
msgstr "Skapa en ytlig kopia av deque."

msgid "Count the number of deque elements equal to *x*."
msgstr "Räkna antalet deque-element som är lika med *x*."

msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr ""
"Förläng höger sida av deque genom att lägga till element från iterable-"
"argumentet."

msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr ""
"Förläng vänster sida av deque genom att lägga till element från *iterable*. "
"Observera att serien av vänstra appends resulterar i att ordningen på "
"elementen i iterable-argumentet vänds."

msgid ""
"Return the position of *x* in the deque (at or after index *start* and "
"before index *stop*).  Returns the first match or raises :exc:`ValueError` "
"if not found."
msgstr ""
"Returnerar positionen för *x* i deque (vid eller efter index *start* och "
"före index *stop*).  Returnerar den första matchningen eller ger :exc:"
"`ValueError` om den inte hittas."

msgid "Insert *x* into the deque at position *i*."
msgstr "Sätt in *x* i deque på position *i*."

msgid ""
"If the insertion would cause a bounded deque to grow beyond *maxlen*, an :"
"exc:`IndexError` is raised."
msgstr ""
"Om införandet skulle leda till att en avgränsad deque växer bortom *maxlen*, "
"kommer ett :exc:`IndexError` att uppstå."

msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr ""
"Tar bort och returnerar ett element från höger sida av deque. Om inga "
"element finns, uppstår ett :exc:`IndexError`."

msgid ""
"Remove and return an element from the left side of the deque. If no elements "
"are present, raises an :exc:`IndexError`."
msgstr ""
"Tar bort och returnerar ett element från vänster sida av deque. Om inga "
"element finns, uppstår ett :exc:`IndexError`."

msgid ""
"Remove the first occurrence of *value*.  If not found, raises a :exc:"
"`ValueError`."
msgstr ""
"Tar bort den första förekomsten av *värde*.  Om det inte hittas, uppstår "
"ett :exc:`ValueError`."

msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr "Vänd elementen i deque på plats och returnera sedan ``None``."

msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left."
msgstr ""
"Rotera dekanen *n* steg åt höger.  Om *n* är negativ, rotera till vänster."

msgid ""
"When the deque is not empty, rotating one step to the right is equivalent to "
"``d.appendleft(d.pop())``, and rotating one step to the left is equivalent "
"to ``d.append(d.popleft())``."
msgstr ""
"När deque inte är tom är rotation ett steg åt höger likvärdigt med ``d."
"appendleft(d.pop())``, och rotation ett steg åt vänster är likvärdigt med "
"``d.append(d.popleft())``."

msgid "Deque objects also provide one read-only attribute:"
msgstr "Deque-objekt har också ett skrivskyddat attribut:"

msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "Maximal storlek på en deque eller ``None`` om den är obegränsad."

msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as ``d[0]`` "
"to access the first element.  Indexed access is *O*\\ (1) at both ends but "
"slows to *O*\\ (*n*) in the middle.  For fast random access, use lists "
"instead."
msgstr ""
"Förutom ovanstående stöder deques iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, medlemskapstestning "
"med operatorn :keyword:`in` och subskriptreferenser som ``d[0]`` för åtkomst "
"till det första elementet.  Indexerad åtkomst är *O*\\ (1) i båda ändar men "
"saktar ner till *O*\\ (*n*) i mitten.  För snabb slumpmässig åtkomst, använd "
"listor istället."

msgid ""
"Starting in version 3.5, deques support ``__add__()``, ``__mul__()``, and "
"``__imul__()``."
msgstr ""
"Från och med version 3.5 har deques stöd för ``__add__()``, ``__mul__()`` "
"och ``__imul__()``."

msgid "Example:"
msgstr "Exempel:"

msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # make a new deque with three items\n"
">>> for elem in d:                   # iterate over the deque's elements\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # add a new entry to the right side\n"
">>> d.appendleft('f')                # add a new entry to the left side\n"
">>> d                                # show the representation of the deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # return and remove the rightmost item\n"
"'j'\n"
">>> d.popleft()                      # return and remove the leftmost item\n"
"'f'\n"
">>> list(d)                          # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # peek at leftmost item\n"
"'g'\n"
">>> d[-1]                            # peek at rightmost item\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # list the contents of a deque in "
"reverse\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # search the deque\n"
"True\n"
">>> d.extend('jkl')                  # add multiple elements at once\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # right rotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # left rotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # make a new deque in reverse order\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # empty the deque\n"
">>> d.pop()                          # cannot pop from an empty deque\n"
"Traceback (most recent call last):\n"
"    File \"<pyshell#6>\", line 1, in -toplevel-\n"
"        d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() reverses the input "
"order\n"
">>> d\n"
"deque(['c', 'b', 'a'])"
msgstr ""
">>> from collections import deque\n"
">>> d = deque('ghi') # skapa en ny deque med tre objekt\n"
">>> för elem i d:                   # iterera över deques element\n"
"... print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j') # lägg till en ny post på höger sida\n"
">>> d.appendleft('f') # lägg till en ny post på vänster sida\n"
">>> d # visa representationen av deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop() # returnera och ta bort objektet längst till höger\n"
"'j'\n"
">>> d.popleft() # returnera och ta bort objektet längst till vänster\n"
"'f'\n"
">>> list(d) # lista innehållet i deque\n"
"['g', 'h', 'i']\n"
">>> d[0] # kika på objektet längst till vänster\n"
"'g'\n"
">>> d[-1] # kika på objektet längst till höger\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # lista innehållet i en deque i omvänd "
"ordning\n"
"['i', 'h', 'g']\n"
">>> 'h' i d # sök i deque\n"
"True\n"
">>> d.extend('jkl') # lägg till flera element på en gång\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1) # högerrotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1) # vänsterrotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # gör en ny deque i omvänd ordning\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear() # töm deque\n"
">>> d.pop() # kan inte popa från en tom deque\n"
"Återkoppling (senaste anropet sist):\n"
"    Fil \"<pyshell#6>\", rad 1, i -toplevel-\n"
"        d.pop()\n"
"IndexError: popa från en tom deque\n"
"\n"
">>> d.extendleft('abc') # extendleft() vänder på inmatningsordningen\n"
">>> d\n"
"deque(['c', 'b', 'a'])"

msgid ":class:`deque` Recipes"
msgstr ":class:`deque` Recept"

msgid "This section shows various approaches to working with deques."
msgstr "I detta avsnitt visas olika sätt att arbeta med deques."

msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr ""
"Deques med begränsad längd ger funktionalitet som liknar filtret ``tail`` i "
"Unix::"

msgid ""
"def tail(filename, n=10):\n"
"    'Return the last n lines of a file'\n"
"    with open(filename) as f:\n"
"        return deque(f, n)"
msgstr ""
"def tail(filnamn, n=10):\n"
"    'Returnera de sista n raderna i en fil'\n"
"    med open(filnamn) som f:\n"
"        returnera deque(f, n)"

msgid ""
"Another approach to using deques is to maintain a sequence of recently added "
"elements by appending to the right and popping to the left::"
msgstr ""
"Ett annat sätt att använda deques är att upprätthålla en sekvens av nyligen "
"tillagda element genom att appendiera till höger och poppa till vänster::"

msgid ""
"def moving_average(iterable, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterable)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / n"
msgstr ""
"def glidande_medelvärde(iterabel, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40,0 42,0 45,0 43,0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterabel)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = summa(d)\n"
"    för elem i it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        ger s / n"

msgid ""
"A `round-robin scheduler <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ can be implemented with input iterators stored in a :"
"class:`deque`.  Values are yielded from the active iterator in position "
"zero.  If that iterator is exhausted, it can be removed with :meth:`~deque."
"popleft`; otherwise, it can be cycled back to the end with the :meth:`~deque."
"rotate` method::"
msgstr ""
"En `round-robin schemaläggare <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ kan implementeras med inmatningsiteratorer lagrade i en :"
"class:`deque`.  Värden erhålls från den aktiva iteratorn i position noll.  "
"Om den iteratorn är uttömd kan den tas bort med :meth:`~deque.popleft`; "
"annars kan den cyklas tillbaka till slutet med :meth:`~deque.rotate`-"
"metoden::"

msgid ""
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iterators = deque(map(iter, iterables))\n"
"    while iterators:\n"
"        try:\n"
"            while True:\n"
"                yield next(iterators[0])\n"
"                iterators.rotate(-1)\n"
"        except StopIteration:\n"
"            # Remove an exhausted iterator.\n"
"            iterators.popleft()"
msgstr ""
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iteratorer = deque(map(iter, iterables))\n"
"    while iterators:\n"
"        försök:\n"
"            while True:\n"
"                yield next(iteratorer[0])\n"
"                iteratorer.rotera(-1)\n"
"        except StopIteration:\n"
"            # Ta bort en uttömd iterator.\n"
"            iteratorer.popleft()"

msgid ""
"The :meth:`~deque.rotate` method provides a way to implement :class:`deque` "
"slicing and deletion.  For example, a pure Python implementation of ``del "
"d[n]`` relies on the ``rotate()`` method to position elements to be popped::"
msgstr ""
"Metoden :meth:`~deque.rotate` ger ett sätt att implementera :class:`deque` "
"skivning och borttagning.  Till exempel, en ren Python-implementering av "
"``del d[n]`` förlitar sig på ``rotate()``-metoden för att positionera "
"element som ska poppas::"

msgid ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"
msgstr ""
"def delete_nth(d, n):\n"
"    d.rotera(-n)\n"
"    d.popleft()\n"
"    d.rotera(n)"

msgid ""
"To implement :class:`deque` slicing, use a similar approach applying :meth:"
"`~deque.rotate` to bring a target element to the left side of the deque. "
"Remove old entries with :meth:`~deque.popleft`, add new entries with :meth:"
"`~deque.extend`, and then reverse the rotation. With minor variations on "
"that approach, it is easy to implement Forth style stack manipulations such "
"as ``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ""
"För att implementera :class:`deque` slicing, använd ett liknande "
"tillvägagångssätt med :meth:`~deque.rotate` för att föra ett målelement till "
"vänster sida av deque. Ta bort gamla poster med :meth:`~deque.popleft`, lägg "
"till nya poster med :meth:`~deque.extend`, och vänd sedan rotationen. Med "
"mindre variationer på detta tillvägagångssätt är det lätt att implementera "
"stackmanipulationer i Forth-stil som ``dup``, ``drop``, ``wap``, ``over``, "
"``pick``, ``rot`` och ``roll``."

msgid ":class:`defaultdict` objects"
msgstr ":class:`defaultdict`-objekt"

msgid ""
"Return a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""
"Returnerar ett nytt ordboksliknande objekt. :class:`defaultdict` är en "
"subklass av den inbyggda :class:`dict`-klassen.  Den åsidosätter en metod "
"och lägger till en skrivbar instansvariabel.  Resterande funktionalitet är "
"densamma som för klassen :class:`dict` och dokumenteras inte här."

msgid ""
"The first argument provides the initial value for the :attr:"
"`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""
"Det första argumentet anger det initiala värdet för attributet :attr:"
"`default_factory`; standardvärdet är ``None``. Alla återstående argument "
"behandlas på samma sätt som om de skickades till :class:`dict`-"
"konstruktören, inklusive nyckelordsargument."

msgid ""
":class:`defaultdict` objects support the following method in addition to the "
"standard :class:`dict` operations:"
msgstr ""
":class:`defaultdict`-objekt stöder följande metod utöver de vanliga :class:"
"`dict`-operationerna:"

msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a :exc:"
"`KeyError` exception with the *key* as argument."
msgstr ""
"Om attributet :attr:`default_factory` är ``None``, utlöses ett :exc:"
"`KeyError` undantag med *key* som argument."

msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""
"Om :attr:`default_factory` inte är ``None`` anropas den utan argument för "
"att ange ett standardvärde för den angivna *key*, detta värde infogas i "
"ordlistan för *key* och returneras."

msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ""
"Om anrop av :attr:`default_factory` ger upphov till ett undantag, sprids "
"detta undantag oförändrat."

msgid ""
"This method is called by the :meth:`~object.__getitem__` method of the :"
"class:`dict` class when the requested key is not found; whatever it returns "
"or raises is then returned or raised by :meth:`~object.__getitem__`."
msgstr ""
"Denna metod anropas av :meth:`~object.__getitem__`-metoden i :class:`dict`-"
"klassen när den begärda nyckeln inte hittas; vad den returnerar eller väcker "
"returneras eller väcks sedan av :meth:`~object.__getitem__`."

msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides :"
"meth:`~object.__getitem__`. This means that :meth:`~dict.get` will, like "
"normal dictionaries, return ``None`` as a default rather than using :attr:"
"`default_factory`."
msgstr ""
"Observera att :meth:`__missing__` *inte* anropas för några andra operationer "
"än :meth:`~object.__getitem__`. Detta innebär att :meth:`~dict.get` kommer, "
"precis som vanliga ordböcker, att returnera ``None`` som standard istället "
"för att använda :attr:`default_factory`."

msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ":class:`defaultdict`-objekt har stöd för följande instansvariabel:"

msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr ""
"Detta attribut används av metoden :meth:`__missing__`; det initialiseras "
"från det första argumentet till konstruktören, om det finns, eller till "
"``None``, om det saknas."

msgid ""
"Added merge (``|``) and update (``|=``) operators, specified in :pep:`584`."
msgstr ""
"Lagt till operatorer för sammanslagning (``|``) och uppdatering (``|=``), "
"specificerade i :pep:`584`."

msgid ":class:`defaultdict` Examples"
msgstr ":class:`defaultdict` Exempel"

msgid ""
"Using :class:`list` as the :attr:`~defaultdict.default_factory`, it is easy "
"to group a sequence of key-value pairs into a dictionary of lists:"
msgstr ""
"Med :class:`list` som :attr:`~defaultdict.default_factory` är det enkelt att "
"gruppera en sekvens av nyckel-värde-par till en ordbok med listor:"

msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the :attr:`~defaultdict."
"default_factory` function which returns an empty :class:`list`.  The :meth:`!"
"list.append` operation then attaches the value to the new list.  When keys "
"are encountered again, the look-up proceeds normally (returning the list for "
"that key) and the :meth:`!list.append` operation adds another value to the "
"list. This technique is simpler and faster than an equivalent technique "
"using :meth:`dict.setdefault`:"
msgstr ""
"När varje nyckel påträffas för första gången finns den inte redan i "
"mappningen, så en post skapas automatiskt med hjälp av funktionen :attr:"
"`~defaultdict.default_factory` som returnerar en tom :class:`list`.  "
"Operationen :meth:`!list.append` lägger sedan till värdet i den nya listan.  "
"När nycklar påträffas igen fortsätter uppslagningen normalt (listan för den "
"nyckeln returneras) och operationen :meth:`!list.append` lägger till ett "
"annat värde i listan. Denna teknik är enklare och snabbare än motsvarande "
"teknik som använder :meth:`dict.setdefault`:"

msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`int` makes the :"
"class:`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""
"Om du ställer in :attr:`~defaultdict.default_factory` till :class:`int` "
"blir :class:`defaultdict` användbar för räkning (som en påse eller multiset "
"på andra språk):"

msgid ""
"When a letter is first encountered, it is missing from the mapping, so the :"
"attr:`~defaultdict.default_factory` function calls :func:`int` to supply a "
"default count of zero.  The increment operation then builds up the count for "
"each letter."
msgstr ""
"När en bokstav först påträffas saknas den i mappningen, så funktionen :attr:"
"`~defaultdict.default_factory` anropar :func:`int` för att ange ett "
"standardantal på noll.  Inkrementoperationen bygger sedan upp räkningen för "
"varje bokstav."

msgid ""
"The function :func:`int` which always returns zero is just a special case of "
"constant functions.  A faster and more flexible way to create constant "
"functions is to use a lambda function which can supply any constant value "
"(not just zero):"
msgstr ""
"Funktionen :func:`int` som alltid returnerar noll är bara ett specialfall av "
"konstantfunktioner.  Ett snabbare och mer flexibelt sätt att skapa "
"konstantfunktioner är att använda en lambda-funktion som kan ge vilket "
"konstant värde som helst (inte bara noll):"

msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`set` makes the :"
"class:`defaultdict` useful for building a dictionary of sets:"
msgstr ""
"Om du ställer in :attr:`~defaultdict.default_factory` på :class:`set` blir :"
"class:`defaultdict` användbar för att bygga en ordbok med set:"

msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ":func:`namedtuple` Fabriksfunktion för tupler med namngivna fält"

msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr ""
"Namngivna tupler tilldelar varje position i en tupel en betydelse och "
"möjliggör mer läsbar och självdokumenterande kod.  De kan användas överallt "
"där vanliga tuplar används, och de ger möjlighet att komma åt fält med namn "
"i stället för positionsindex."

msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as "
"well as being indexable and iterable.  Instances of the subclass also have a "
"helpful docstring (with *typename* and *field_names*) and a helpful :meth:"
"`~object.__repr__` method which lists the tuple contents in a ``name=value`` "
"format."
msgstr ""
"Returnerar en ny tuple-subklass med namnet *typename*.  Den nya underklassen "
"används för att skapa tuple-liknande objekt som har fält som är tillgängliga "
"genom attributuppslagning samt indexerbara och itererbara.  Instanser av "
"subklassen har också en användbar docstring (med *typename* och "
"*field_names*) och en användbar :meth:`~object.__repr__`-metod som listar "
"tuple-innehållet i ett ``namn=värde``-format."

msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, y'``."
msgstr ""
"*field_names* är en sekvens av strängar, t.ex. ``['x', 'y']``. Alternativt "
"kan *field_names* vara en enda sträng där varje fältnamn separeras med "
"blanksteg och/eller kommatecken, t.ex. ``'x y'`` eller ``'x, y'``."

msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a :"
"mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, or *raise*."
msgstr ""
"Alla giltiga Python-identifierare kan användas för ett fältnamn utom namn "
"som börjar med ett understreck.  Giltiga identifierare består av bokstäver, "
"siffror och understreck men börjar inte med en siffra eller ett understreck "
"och kan inte vara ett :mod:`nyckelord` som *class*, *for*, *return*, "
"*global*, *pass* eller *raise*."

msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword ``def`` "
"and the duplicate fieldname ``abc``."
msgstr ""
"Om *rename* är true ersätts ogiltiga fältnamn automatiskt med "
"positionsnamn.  Till exempel konverteras ``['abc', 'def', 'ghi', 'abc']`` "
"till ``['abc', '_1', 'ghi', '_3']``, vilket eliminerar nyckelordet ``def`` "
"och det dubbla fältnamnet ``abc``."

msgid ""
"*defaults* can be ``None`` or an :term:`iterable` of default values. Since "
"fields with a default value must come after any fields without a default, "
"the *defaults* are applied to the rightmost parameters.  For example, if the "
"fieldnames are ``['x', 'y', 'z']`` and the defaults are ``(1, 2)``, then "
"``x`` will be a required argument, ``y`` will default to ``1``, and ``z`` "
"will default to ``2``."
msgstr ""
"*defaults* kan vara ``None`` eller en :term:`iterable` av standardvärden. "
"Eftersom fält med ett standardvärde måste komma efter fält utan ett "
"standardvärde, tillämpas *defaults* på parametrarna längst till höger.  Om "
"fältnamnen till exempel är ``['x', 'y', 'z']`` och standardvärdena är ``(1, "
"2)``, kommer ``x`` att vara ett obligatoriskt argument, ``y`` kommer att "
"vara standardvärdet ``1`` och ``z`` kommer att vara standardvärdet ``2``."

msgid ""
"If *module* is defined, the :attr:`~type.__module__` attribute of the named "
"tuple is set to that value."
msgstr ""
"Om *module* definieras sätts attributet :attr:`~type.__module__` i den "
"namngivna tupeln till det värdet."

msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr ""
"Namngivna tuple-instanser har inga ordböcker per instans, så de är lätta och "
"kräver inte mer minne än vanliga tupler."

msgid ""
"To support pickling, the named tuple class should be assigned to a variable "
"that matches *typename*."
msgstr ""
"För att stödja pickling bör den namngivna tuple-klassen tilldelas en "
"variabel som matchar *typename*."

msgid "Added support for *rename*."
msgstr "Lagt till stöd för *rename*."

msgid ""
"The *verbose* and *rename* parameters became :ref:`keyword-only arguments "
"<keyword-only_parameter>`."
msgstr ""
"Parametrarna *verbose* och *rename* blev :ref:`keyword-only arguments "
"<keyword-only_parameter>`."

msgid "Added the *module* parameter."
msgstr "Parametern *module* har lagts till."

msgid "Removed the *verbose* parameter and the :attr:`!_source` attribute."
msgstr "Parametern *verbose* och attributet :attr:`!_source` har tagits bort."

msgid ""
"Added the *defaults* parameter and the :attr:`~somenamedtuple."
"_field_defaults` attribute."
msgstr ""
"Lagt till parametern *defaults* och attributet :attr:`~somenamedtuple."
"_field_defaults`."

msgid ""
">>> # Basic example\n"
">>> Point = namedtuple('Point', ['x', 'y'])\n"
">>> p = Point(11, y=22)     # instantiate with positional or keyword "
"arguments\n"
">>> p[0] + p[1]             # indexable like the plain tuple (11, 22)\n"
"33\n"
">>> x, y = p                # unpack like a regular tuple\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # fields also accessible by name\n"
"33\n"
">>> p                       # readable __repr__ with a name=value style\n"
"Point(x=11, y=22)"
msgstr ""
">>> # Grundläggande exempel\n"
">>> Point = namntuple('Point', ['x', 'y'])\n"
">>> p = Point(11, y=22) # instansiera med positionella eller "
"nyckelordsargument\n"
">>> p[0] + p[1] # indexerbar som den vanliga tupeln (11, 22)\n"
"33\n"
">>> x, y = p # packa upp som en vanlig tupel\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y # fälten är också tillgängliga via namn\n"
"33\n"
">>> p # läsbar __repr__ med en name=value-stil\n"
"Punkt(x=11, y=22)"

msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""
"Namngivna tupler är särskilt användbara för att tilldela fältnamn till "
"resultattuplar som returneras av modulerna :mod:`csv` eller :mod:`sqlite3`::"

msgid ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, "
"paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", "
"\"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM "
"employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"
msgstr ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, "
"paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", "
"\"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM "
"employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"

msgid ""
"In addition to the methods inherited from tuples, named tuples support three "
"additional methods and two attributes.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr ""
"Utöver de metoder som ärvs från tuples har named tuples stöd för ytterligare "
"tre metoder och två attribut.  För att undvika konflikter med fältnamn "
"börjar metod- och attributnamnen med ett understreck."

msgid ""
"Class method that makes a new instance from an existing sequence or iterable."
msgstr ""
"Klassmetod som skapar en ny instans från en befintlig sekvens eller iterabel."

msgid ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"
msgstr ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Punkt(x=11, y=22)"

msgid ""
"Return a new :class:`dict` which maps field names to their corresponding "
"values:"
msgstr ""
"Returnerar en ny :class:`dict` som mappar fältnamn till deras motsvarande "
"värden:"

msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"
msgstr ""
">>> p = Punkt(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"

msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr ""
"Returnerar en :class:`OrderedDict` istället för en vanlig :class:`dict`."

msgid ""
"Returns a regular :class:`dict` instead of an :class:`OrderedDict`. As of "
"Python 3.7, regular dicts are guaranteed to be ordered.  If the extra "
"features of :class:`OrderedDict` are required, the suggested remediation is "
"to cast the result to the desired type: ``OrderedDict(nt._asdict())``."
msgstr ""
"Returnerar en vanlig :class:`dict` istället för en :class:`OrderedDict`. "
"Från och med Python 3.7 garanteras att vanliga dicts är ordnade.  Om de "
"extra funktionerna i :class:`OrderedDict` krävs, är den föreslagna lösningen "
"att casta resultatet till önskad typ: ``OrderedDict(nt._asdict())``."

msgid ""
"Return a new instance of the named tuple replacing specified fields with new "
"values::"
msgstr ""
"Returnerar en ny instans av den namngivna tupeln genom att ersätta angivna "
"fält med nya värden::"

msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], "
"timestamp=time.now())"
msgstr ""
">>> p = Punkt(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Punkt(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"... inventory[partnum] = record._replace(price=nya priser[partnum], "
"timestamp=time.now())"

msgid ""
"Named tuples are also supported by generic function :func:`copy.replace`."
msgstr ""
"Namngivna tupler stöds också av den generiska funktionen :func:`copy."
"replace`."

msgid ""
"Raise :exc:`TypeError` instead of :exc:`ValueError` for invalid keyword "
"arguments."
msgstr ""
"Utlös :exc:`TypeError` istället för :exc:`ValueError` för ogiltiga "
"nyckelordsargument."

msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr ""
"Tupel med strängar som listar fältnamnen.  Användbar för introspektion och "
"för att skapa nya namngivna tupeltyper från befintliga namngivna tuplar."

msgid ""
">>> p._fields            # view the field names\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"
msgstr ""
">>> p._fields # visa fältnamnen\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'röd grön blå')\n"
">>> Pixel = namntupel('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, röd=128, grön=255, blå=0)"

msgid "Dictionary mapping field names to default values."
msgstr "Ordbok som mappar fältnamn till standardvärden."

msgid ""
">>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0])\n"
">>> Account._field_defaults\n"
"{'balance': 0}\n"
">>> Account('premium')\n"
"Account(type='premium', balance=0)"
msgstr ""
">>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0])\n"
">>> Account._field_defaults\n"
"{\"saldo\": 0}\n"
">>> Konto('premium')\n"
"Konto(typ='premium', saldo=0)"

msgid ""
"To retrieve a field whose name is stored in a string, use the :func:"
"`getattr` function:"
msgstr ""
"Om du vill hämta ett fält vars namn lagras i en sträng använder du "
"funktionen :func:`getattr`:"

msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr ""
"Om du vill konvertera en ordbok till en namngiven tupel använder du "
"dubbelstjärneoperatorn (enligt beskrivningen i :ref:`tut-unpacking-"
"arguments`):"

msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr ""
"Eftersom en named tuple är en vanlig Python-klass är det lätt att lägga till "
"eller ändra funktionalitet med en subklass.  Så här lägger du till ett "
"beräknat fält och ett utskriftsformat med fast bredd:"

msgid ""
">>> class Point(namedtuple('Point', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @property\n"
"...     def hypot(self):\n"
"...         return (self.x ** 2 + self.y ** 2) ** 0.5\n"
"...     def __str__(self):\n"
"...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, "
"self.hypot)\n"
"\n"
">>> for p in Point(3, 4), Point(14, 5/7):\n"
"...     print(p)\n"
"Point: x= 3.000  y= 4.000  hypot= 5.000\n"
"Point: x=14.000  y= 0.714  hypot=14.018"
msgstr ""
">>> class Point(namedtuple('Point', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @egenskap\n"
"... def hypot(self):\n"
"... return (self.x ** 2 + self.y ** 2) ** 0,5\n"
"... def __str__(self):\n"
"... return 'Punkt: x=%6.3f y=%6.3f hypot=%6.3f' % (self.x, self.y, self."
"hypot)\n"
"\n"
">>> for p in Point(3, 4), Point(14, 5/7):\n"
"... print(p)\n"
"Punkt: x= 3,000 y= 4,000 hypot= 5,000\n"
"Punkt: x=14,000 y= 0,714 hypot=14,018"

msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr ""
"Den subklass som visas ovan sätter ``__slots__`` till en tom tupel.  Detta "
"hjälper till att hålla minneskraven låga genom att förhindra skapandet av "
"instansordböcker."

msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`~somenamedtuple._fields` "
"attribute:"
msgstr ""
"Subklassning är inte användbart för att lägga till nya, lagrade fält.  "
"Istället skapar du helt enkelt en ny namngiven tupeltyp från attributet :"
"attr:`~somenamedtuple._fields`:"

msgid ""
"Docstrings can be customized by making direct assignments to the ``__doc__`` "
"fields:"
msgstr ""
"Dokumentsträngar kan anpassas genom att göra direkta tilldelningar till "
"fälten ``__doc__``:"

msgid "Property docstrings became writeable."
msgstr "Property docstrings blev skrivbara."

msgid ""
"See :class:`typing.NamedTuple` for a way to add type hints for named "
"tuples.  It also provides an elegant notation using the :keyword:`class` "
"keyword::"
msgstr ""
"Se :class:`typing.NamedTuple` för ett sätt att lägga till typhintar för "
"namngivna tupler.  Det ger också en elegant notation med hjälp av "
"nyckelordet :keyword:`class`::"

msgid ""
"class Component(NamedTuple):\n"
"    part_number: int\n"
"    weight: float\n"
"    description: Optional[str] = None"
msgstr ""
"class Komponent(NamedTuple):\n"
"    part_number: int\n"
"    vikt: float\n"
"    description (beskrivning): Valfri[str] = Ingen"

msgid ""
"See :meth:`types.SimpleNamespace` for a mutable namespace based on an "
"underlying dictionary instead of a tuple."
msgstr ""
"Se :meth:`types.SimpleNamespace` för en föränderlig namnrymd som baseras på "
"en underliggande ordbok i stället för en tupel."

msgid ""
"The :mod:`dataclasses` module provides a decorator and functions for "
"automatically adding generated special methods to user-defined classes."
msgstr ""
"Modulen :mod:`dataclasses` innehåller en dekorator och funktioner för att "
"automatiskt lägga till genererade specialmetoder till användardefinierade "
"klasser."

msgid ":class:`OrderedDict` objects"
msgstr ":class:`OrderedDict`-objekt"

msgid ""
"Ordered dictionaries are just like regular dictionaries but have some extra "
"capabilities relating to ordering operations.  They have become less "
"important now that the built-in :class:`dict` class gained the ability to "
"remember insertion order (this new behavior became guaranteed in Python 3.7)."
msgstr ""
"Ordnade ordböcker är precis som vanliga ordböcker men har några extra "
"funktioner som rör ordningsoperationer.  De har blivit mindre viktiga nu när "
"den inbyggda :class:`dict`-klassen har fått förmågan att komma ihåg "
"insättningsordning (detta nya beteende blev garanterat i Python 3.7)."

msgid "Some differences from :class:`dict` still remain:"
msgstr "Vissa skillnader från :class:`dict` kvarstår fortfarande:"

msgid ""
"The regular :class:`dict` was designed to be very good at mapping "
"operations.  Tracking insertion order was secondary."
msgstr ""
"Den vanliga :class:`dict` utformades för att vara mycket bra på "
"mappningsoperationer.  Att spåra insättningsordning var sekundärt."

msgid ""
"The :class:`OrderedDict` was designed to be good at reordering operations. "
"Space efficiency, iteration speed, and the performance of update operations "
"were secondary."
msgstr ""
":class:`OrderedDict` utformades för att vara bra på omordningsoperationer. "
"Utrymmeseffektivitet, iterationshastighet och prestanda för "
"uppdateringsoperationer var sekundära."

msgid ""
"The :class:`OrderedDict` algorithm can handle frequent reordering operations "
"better than :class:`dict`.  As shown in the recipes below, this makes it "
"suitable for implementing various kinds of LRU caches."
msgstr ""
"Algoritmen :class:`OrderedDict` kan hantera frekventa omordningsoperationer "
"bättre än :class:`dict`.  Som visas i recepten nedan gör detta att den "
"lämpar sig för implementering av olika typer av LRU-cacher."

msgid ""
"The equality operation for :class:`OrderedDict` checks for matching order."
msgstr ""
"Jämlikhetsoperationen för :class:`OrderedDict` kontrollerar matchande "
"ordning."

msgid ""
"A regular :class:`dict` can emulate the order sensitive equality test with "
"``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."
msgstr ""
"En vanlig :class:`dict` kan emulera det ordningskänsliga likhetstestet med "
"``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."

msgid ""
"The :meth:`~OrderedDict.popitem` method of :class:`OrderedDict` has a "
"different signature.  It accepts an optional argument to specify which item "
"is popped."
msgstr ""
"Metoden :meth:`~OrderedDict.popitem` i :class:`OrderedDict` har en annan "
"signatur.  Den accepterar ett valfritt argument för att specificera vilket "
"objekt som ska poppas."

msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=True)`` "
"with ``d.popitem()`` which is guaranteed to pop the rightmost (last) item."
msgstr ""
"En vanlig :class:`dict` kan efterlikna OrderedDicts ``od."
"popitem(last=True)`` med ``d.popitem()`` som garanterat öppnar det längst "
"till höger (sista) objektet."

msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=False)`` "
"with ``(k := next(iter(d)), d.pop(k))`` which will return and remove the "
"leftmost (first) item if it exists."
msgstr ""
"En vanlig :class:`dict` kan emulera OrderedDicts ``od.popitem(last=False)`` "
"med ``(k := next(iter(d)), d.pop(k))`` som returnerar och tar bort det "
"längst till vänster (första) objektet om det finns."

msgid ""
":class:`OrderedDict` has a :meth:`~OrderedDict.move_to_end` method to "
"efficiently reposition an element to an endpoint."
msgstr ""
":class:`OrderedDict` har en :meth:`~OrderedDict.move_to_end`-metod för att "
"effektivt flytta ett element till en slutpunkt."

msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.move_to_end(k, "
"last=True)`` with ``d[k] = d.pop(k)`` which will move the key and its "
"associated value to the rightmost (last) position."
msgstr ""
"En vanlig :class:`dict` kan emulera OrderedDicts ``od.move_to_end(k, "
"last=True)`` med ``d[k] = d.pop(k)`` vilket flyttar nyckeln och dess "
"associerade värde till den högra (sista) positionen."

msgid ""
"A regular :class:`dict` does not have an efficient equivalent for "
"OrderedDict's ``od.move_to_end(k, last=False)`` which moves the key and its "
"associated value to the leftmost (first) position."
msgstr ""
"En vanlig :class:`dict` har inte någon effektiv motsvarighet till "
"OrderedDicts ``od.move_to_end(k, last=False)`` som flyttar nyckeln och dess "
"associerade värde till den vänstra (första) positionen."

msgid ""
"Until Python 3.8, :class:`dict` lacked a :meth:`~object.__reversed__` method."
msgstr ""
"Fram till Python 3.8 saknade :class:`dict` en :meth:`~object.__reversed__`-"
"metod."

msgid ""
"Return an instance of a :class:`dict` subclass that has methods specialized "
"for rearranging dictionary order."
msgstr ""
"Returnerar en instans av en :class:`dict`-underklass som har metoder "
"specialiserade på att omorganisera ordningsföljden i ordböcker."

msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a "
"(key, value) pair.  The pairs are returned in :abbr:`LIFO (last-in, first-"
"out)` order if *last* is true or :abbr:`FIFO (first-in, first-out)` order if "
"false."
msgstr ""
"Metoden :meth:`popitem` för ordnade lexikon returnerar och tar bort ett "
"(nyckel, värde)-par.  Paren returneras i :abbr:`LIFO (last-in, first-out)` "
"ordning om *last* är sant eller :abbr:`FIFO (first-in, first-out)` ordning "
"om false."

msgid ""
"Move an existing *key* to either end of an ordered dictionary.  The item is "
"moved to the right end if *last* is true (the default) or to the beginning "
"if *last* is false.  Raises :exc:`KeyError` if the *key* does not exist:"
msgstr ""
"Flytta en befintlig *key* till endera änden av en ordnad ordbok.  Objektet "
"flyttas till den högra änden om *last* är true (standard) eller till början "
"om *last* är false.  Utlöser :exc:`KeyError` om *nyckeln* inte finns:"

msgid ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"
msgstr ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"

msgid ""
"In addition to the usual mapping methods, ordered dictionaries also support "
"reverse iteration using :func:`reversed`."
msgstr ""
"Förutom de vanliga mappningsmetoderna stöder ordnade lexikon även omvänd "
"iteration med hjälp av :func:`reversed`."

msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive and "
"are roughly equivalent to ``list(od1.items())==list(od2.items())``."
msgstr ""
"Likhetstester mellan :class:`OrderedDict`-objekt är ordningskänsliga och "
"motsvarar ungefär ``list(od1.items())==list(od2.items())``."

msgid ""
"Equality tests between :class:`OrderedDict` objects and other :class:"
"`~collections.abc.Mapping` objects are order-insensitive like regular "
"dictionaries.  This allows :class:`OrderedDict` objects to be substituted "
"anywhere a regular dictionary is used."
msgstr ""
"Jämlikhetstester mellan :class:`OrderedDict`-objekt och andra :class:"
"`~collections.abc.Mapping`-objekt är okänsliga för ordning som vanliga "
"ordböcker.  Detta gör att :class:`OrderedDict`-objekt kan ersättas var som "
"helst där en vanlig ordbok används."

msgid ""
"The items, keys, and values :term:`views <dictionary view>` of :class:"
"`OrderedDict` now support reverse iteration using :func:`reversed`."
msgstr ""
"Objekten, nycklarna och värdena :term:`views <dictionary view>` i :class:"
"`OrderedDict` stöder nu omvänd iteration med :func:`reversed`."

msgid ""
"With the acceptance of :pep:`468`, order is retained for keyword arguments "
"passed to the :class:`OrderedDict` constructor and its :meth:`~dict.update` "
"method."
msgstr ""
"Med godkännandet av :pep:`468`, behålls ordningen för nyckelordsargument som "
"skickas till :class:`OrderedDict`-konstruktören och dess :meth:`~dict."
"update`-metod."

msgid ":class:`OrderedDict` Examples and Recipes"
msgstr ":class:`OrderedDict` Exempel och recept"

msgid ""
"It is straightforward to create an ordered dictionary variant that remembers "
"the order the keys were *last* inserted. If a new entry overwrites an "
"existing entry, the original insertion position is changed and moved to the "
"end::"
msgstr ""
"Det är enkelt att skapa en ordnad ordboksvariant som kommer ihåg den ordning "
"som nycklarna *senast* infogades. Om en ny post skriver över en befintlig "
"post, ändras den ursprungliga inmatningspositionen och flyttas till slutet::"

msgid ""
"class LastUpdatedOrderedDict(OrderedDict):\n"
"    'Store items in the order the keys were last added'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        super().__setitem__(key, value)\n"
"        self.move_to_end(key)"
msgstr ""
"class LastUpdatedOrderedDict(OrderedDict):\n"
"    \"Lagra objekt i den ordning som nycklarna senast lades till\n"
"\n"
"    def __setitem__(self, nyckel, värde):\n"
"        super().__setitem__(nyckel, värde)\n"
"        self.move_to_end(nyckel)"

msgid ""
"An :class:`OrderedDict` would also be useful for implementing variants of :"
"func:`functools.lru_cache`:"
msgstr ""
"En :class:`OrderedDict` skulle också vara användbar för att implementera "
"varianter av :func:`functools.lru_cache`:"

msgid ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class TimeBoundedLRU:\n"
"    \"LRU Cache that invalidates and refreshes old entries.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (timestamp, result)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            timestamp, result = self.cache[args]\n"
"            if time() - timestamp <= self.maxage:\n"
"                return result\n"
"        result = self.func(*args)\n"
"        self.cache[args] = time(), result\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return result"
msgstr ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class TimeBoundedLRU:\n"
"    \"LRU Cache that invalidates and refreshes old entries.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (timestamp, result)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            timestamp, result = self.cache[args]\n"
"            if time() - timestamp <= self.maxage:\n"
"                return result\n"
"        result = self.func(*args)\n"
"        self.cache[args] = time(), result\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return result"

msgid ""
"class MultiHitLRUCache:\n"
"    \"\"\" LRU cache that defers caching a result until\n"
"        it has been requested multiple times.\n"
"\n"
"        To avoid flushing the LRU cache with one-time requests,\n"
"        we don't cache until a request has been made more than once.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):\n"
"        self.requests = OrderedDict()   # { uncached_key : request_count }\n"
"        self.cache = OrderedDict()      # { cached_key : function_result }\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests  # max number of uncached requests\n"
"        self.maxsize = maxsize          # max number of stored return "
"values\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        result = self.func(*args)\n"
"        self.requests[args] = self.requests.get(args, 0) + 1\n"
"        if self.requests[args] <= self.cache_after:\n"
"            self.requests.move_to_end(args)\n"
"            if len(self.requests) > self.maxrequests:\n"
"                self.requests.popitem(last=False)\n"
"        else:\n"
"            self.requests.pop(args, None)\n"
"            self.cache[args] = result\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        return result"
msgstr ""
"klass MultiHitLRUCache:\n"
"    \"\"\" LRU-cache som väntar med att cachelagra ett resultat tills\n"
"        tills det har begärts flera gånger.\n"
"\n"
"        För att undvika att LRU-cachen töms med engångsförfrågningar,\n"
"        vi inte cachelagring förrän en begäran har gjorts mer än en gång.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):\n"
"        self.requests = OrderedDict() # { uncached_key : request_count }\n"
"        self.cache = OrderedDict() # { cached_key : funktion_resultat }\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests # max antal icke-cachade "
"förfrågningar\n"
"        self.maxsize = maxsize # max antal lagrade returvärden\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        om args i self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        resultat = self.func(*args)\n"
"        self.requests[args] = self.requests.get(args, 0) + 1\n"
"        if self.requests[args] <= self.cache_after:\n"
"            self.requests.move_to_end(args)\n"
"            if len(self.requests) > self.maxrequests:\n"
"                self.requests.popitem(last=False)\n"
"        annat:\n"
"            self.requests.pop(args, None)\n"
"            self.cache[args] = resultat\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        returnera resultat"

msgid ":class:`UserDict` objects"
msgstr ":class:`UserDict`-objekt"

msgid ""
"The class, :class:`UserDict` acts as a wrapper around dictionary objects. "
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`dict`; however, this class can be easier to "
"work with because the underlying dictionary is accessible as an attribute."
msgstr ""
"Klassen :class:`UserDict` fungerar som ett omslag runt ordboksobjekt. "
"Behovet av denna klass har delvis ersatts av möjligheten att subklassa "
"direkt från :class:`dict`; denna klass kan dock vara lättare att arbeta med "
"eftersom den underliggande ordboken är tillgänglig som ett attribut."

msgid ""
"Class that simulates a dictionary.  The instance's contents are kept in a "
"regular dictionary, which is accessible via the :attr:`data` attribute of :"
"class:`UserDict` instances.  If *initialdata* is provided, :attr:`data` is "
"initialized with its contents; note that a reference to *initialdata* will "
"not be kept, allowing it to be used for other purposes."
msgstr ""
"Klass som simulerar en ordbok.  Instansens innehåll sparas i en vanlig "
"ordbok, som är tillgänglig via attributet :attr:`data` i :class:`UserDict`-"
"instanser.  Om *initialdata* anges initialiseras :attr:`data` med dess "
"innehåll; notera att en referens till *initialdata* inte sparas, vilket gör "
"att den kan användas för andra ändamål."

msgid ""
"In addition to supporting the methods and operations of mappings, :class:"
"`UserDict` instances provide the following attribute:"
msgstr ""
"Förutom att stödja metoder och operationer för mappningar, ger :class:"
"`UserDict`-instanser följande attribut:"

msgid ""
"A real dictionary used to store the contents of the :class:`UserDict` class."
msgstr ""
"En riktig ordbok som används för att lagra innehållet i :class:`UserDict`-"
"klassen."

msgid ":class:`UserList` objects"
msgstr ":class:`UserList`-objekt"

msgid ""
"This class acts as a wrapper around list objects.  It is a useful base class "
"for your own list-like classes which can inherit from them and override "
"existing methods or add new ones.  In this way, one can add new behaviors to "
"lists."
msgstr ""
"Den här klassen fungerar som ett hölje runt listobjekt.  Det är en användbar "
"basklass för dina egna listliknande klasser som kan ärva från dem och "
"åsidosätta befintliga metoder eller lägga till nya.  På så sätt kan man "
"lägga till nya beteenden i listor."

msgid ""
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`list`; however, this class can be easier to "
"work with because the underlying list is accessible as an attribute."
msgstr ""
"Behovet av denna klass har delvis ersatts av möjligheten att subklassa "
"direkt från :class:`list`; denna klass kan dock vara lättare att arbeta med "
"eftersom den underliggande listan är tillgänglig som ett attribut."

msgid ""
"Class that simulates a list.  The instance's contents are kept in a regular "
"list, which is accessible via the :attr:`data` attribute of :class:"
"`UserList` instances.  The instance's contents are initially set to a copy "
"of *list*, defaulting to the empty list ``[]``.  *list* can be any iterable, "
"for example a real Python list or a :class:`UserList` object."
msgstr ""
"Klass som simulerar en lista.  Instansens innehåll sparas i en vanlig lista, "
"som är tillgänglig via attributet :attr:`data` i :class:`UserList`-"
"instanser.  Instansens innehåll är initialt inställt på en kopia av *list*, "
"med den tomma listan ``[]`` som standard.  *list* kan vara vilken iterabel "
"som helst, t.ex. en riktig Python-lista eller ett :class:`UserList`-objekt."

msgid ""
"In addition to supporting the methods and operations of mutable sequences, :"
"class:`UserList` instances provide the following attribute:"
msgstr ""
"Förutom att stödja metoder och operationer för muterbara sekvenser, ger :"
"class:`UserList`-instanser följande attribut:"

msgid ""
"A real :class:`list` object used to store the contents of the :class:"
"`UserList` class."
msgstr ""
"Ett verkligt :class:`list`-objekt som används för att lagra innehållet i :"
"class:`UserList`-klassen."

msgid ""
"**Subclassing requirements:** Subclasses of :class:`UserList` are expected "
"to offer a constructor which can be called with either no arguments or one "
"argument.  List operations which return a new sequence attempt to create an "
"instance of the actual implementation class.  To do so, it assumes that the "
"constructor can be called with a single parameter, which is a sequence "
"object used as a data source."
msgstr ""
"**Subklassningskrav:** Subklasser av :class:`UserList` förväntas erbjuda en "
"konstruktor som kan anropas med antingen inga argument eller ett argument.  "
"Listoperationer som returnerar en ny sekvens försöker skapa en instans av "
"den faktiska implementationsklassen.  För att göra detta förutsätts att "
"konstruktören kan anropas med en enda parameter, som är ett sekvensobjekt "
"som används som datakälla."

msgid ""
"If a derived class does not wish to comply with this requirement, all of the "
"special methods supported by this class will need to be overridden; please "
"consult the sources for information about the methods which need to be "
"provided in that case."
msgstr ""
"Om en härledd klass inte vill uppfylla detta krav måste alla specialmetoder "
"som stöds av denna klass åsidosättas; se källorna för information om vilka "
"metoder som måste tillhandahållas i så fall."

msgid ":class:`UserString` objects"
msgstr ":class:`UserString`-objekt"

msgid ""
"The class, :class:`UserString` acts as a wrapper around string objects. The "
"need for this class has been partially supplanted by the ability to subclass "
"directly from :class:`str`; however, this class can be easier to work with "
"because the underlying string is accessible as an attribute."
msgstr ""
"Klassen :class:`UserString` fungerar som ett omslag runt strängobjekt. "
"Behovet av denna klass har delvis ersatts av möjligheten att subklassa "
"direkt från :class:`str`; denna klass kan dock vara lättare att arbeta med "
"eftersom den underliggande strängen är tillgänglig som ett attribut."

msgid ""
"Class that simulates a string object.  The instance's content is kept in a "
"regular string object, which is accessible via the :attr:`data` attribute "
"of :class:`UserString` instances.  The instance's contents are initially set "
"to a copy of *seq*.  The *seq* argument can be any object which can be "
"converted into a string using the built-in :func:`str` function."
msgstr ""
"Klass som simulerar ett strängobjekt.  Instansens innehåll förvaras i ett "
"vanligt strängobjekt, som är tillgängligt via attributet :attr:`data` i :"
"class:`UserString`-instanser.  Instansens innehåll sätts initialt till en "
"kopia av *seq*.  Argumentet *seq* kan vara vilket objekt som helst som kan "
"konverteras till en sträng med hjälp av den inbyggda funktionen :func:`str`."

msgid ""
"In addition to supporting the methods and operations of strings, :class:"
"`UserString` instances provide the following attribute:"
msgstr ""
"Förutom att stödja metoder och operationer för strängar, ger :class:"
"`UserString`-instanser följande attribut:"

msgid ""
"A real :class:`str` object used to store the contents of the :class:"
"`UserString` class."
msgstr ""
"Ett verkligt :class:`str`-objekt som används för att lagra innehållet i :"
"class:`UserString`-klassen."

msgid ""
"New methods ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable``, and ``maketrans``."
msgstr ""
"Nya metoder ```getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable`` och ``maketrans``."
