# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!atexit` --- Exit handlers"
msgstr ":mod:`!atexit` --- Exit-hanterare"

msgid ""
"The :mod:`atexit` module defines functions to register and unregister "
"cleanup functions.  Functions thus registered are automatically executed "
"upon normal interpreter termination.  :mod:`atexit` runs these functions in "
"the *reverse* order in which they were registered; if you register ``A``, "
"``B``, and ``C``, at interpreter termination time they will be run in the "
"order ``C``, ``B``, ``A``."
msgstr ""
"Modulen :mod:`atexit` definierar funktioner för att registrera och "
"avregistrera rensningsfunktioner.  Funktioner som registrerats på detta sätt "
"körs automatiskt vid normal avslutning av tolken. :mod:`atexit` kör dessa "
"funktioner i *omvänd* ordning som de registrerades i; om du registrerar "
"``A``, ``B`` och ``C`` kommer de vid avslutning av tolken att köras i "
"ordningen ``C``, ``B``, ``A``."

msgid ""
"**Note:** The functions registered via this module are not called when the "
"program is killed by a signal not handled by Python, when a Python fatal "
"internal error is detected, or when :func:`os._exit` is called."
msgstr ""
"**De funktioner som registreras via denna modul anropas inte när programmet "
"dödas av en signal som inte hanteras av Python, när ett fatalt internt fel i "
"Python upptäcks eller när :func:`os._exit` anropas."

msgid ""
"**Note:** The effect of registering or unregistering functions from within a "
"cleanup function is undefined."
msgstr ""
"**Note:** Effekten av att registrera eller avregistrera funktioner inom en "
"rensningsfunktion är odefinierad."

msgid ""
"When used with C-API subinterpreters, registered functions are local to the "
"interpreter they were registered in."
msgstr ""
"När de används med C-API-undertolkar är registrerade funktioner lokala för "
"den tolk de registrerades i."

msgid ""
"Register *func* as a function to be executed at termination.  Any optional "
"arguments that are to be passed to *func* must be passed as arguments to :"
"func:`register`.  It is possible to register the same function and arguments "
"more than once."
msgstr ""
"Registrera *func* som en funktion som ska exekveras vid avslutning.  "
"Eventuella valfria argument som ska skickas till *func* måste skickas som "
"argument till :func:`register`.  Det är möjligt att registrera samma "
"funktion och argument mer än en gång."

msgid ""
"At normal program termination (for instance, if :func:`sys.exit` is called "
"or the main module's execution completes), all functions registered are "
"called in last in, first out order.  The assumption is that lower level "
"modules will normally be imported before higher level modules and thus must "
"be cleaned up later."
msgstr ""
"Vid normal programavslutning (t.ex. om :func:`sys.exit` anropas eller om "
"huvudmodulens exekvering avslutas) anropas alla registrerade funktioner i "
"ordningen sist in, först ut.  Antagandet är att moduler på lägre nivå "
"normalt kommer att importeras före moduler på högre nivå och därför måste "
"rensas upp senare."

msgid ""
"If an exception is raised during execution of the exit handlers, a traceback "
"is printed (unless :exc:`SystemExit` is raised) and the exception "
"information is saved.  After all exit handlers have had a chance to run, the "
"last exception to be raised is re-raised."
msgstr ""
"Om ett undantag uppstår under exekveringen av exit-hanterarna skrivs en "
"spårning ut (såvida inte :exc:`SystemExit` uppstår) och informationen om "
"undantaget sparas.  När alla exit-hanterare har haft en chans att köras, "
"aktiveras det sista undantaget som aktiverades på nytt."

msgid ""
"This function returns *func*, which makes it possible to use it as a "
"decorator."
msgstr ""
"Denna funktion returnerar *func*, vilket gör det möjligt att använda den som "
"en dekorator."

msgid ""
"Starting new threads or calling :func:`os.fork` from a registered function "
"can lead to race condition between the main Python runtime thread freeing "
"thread states while internal :mod:`threading` routines or the new process "
"try to use that state. This can lead to crashes rather than clean shutdown."
msgstr ""
"Att starta nya trådar eller anropa :func:`os.fork` från en registrerad "
"funktion kan leda till tävlingsförhållanden mellan Pythons huvudtråd som "
"frigör trådtillstånd medan interna :mod:`threading`-rutiner eller den nya "
"processen försöker använda det tillståndet. Detta kan leda till krascher "
"snarare än ren avstängning."

msgid ""
"Attempts to start a new thread or :func:`os.fork` a new process in a "
"registered function now leads to :exc:`RuntimeError`."
msgstr ""
"Försök att starta en ny tråd eller :func:`os.fork` en ny process i en "
"registrerad funktion leder nu till :exc:`RuntimeError`."

msgid ""
"Remove *func* from the list of functions to be run at interpreter shutdown. :"
"func:`unregister` silently does nothing if *func* was not previously "
"registered.  If *func* has been registered more than once, every occurrence "
"of that function in the :mod:`atexit` call stack will be removed.  Equality "
"comparisons (``==``) are used internally during unregistration, so function "
"references do not need to have matching identities."
msgstr ""
"Ta bort *func* från listan över funktioner som ska köras när tolken stängs "
"av. :func:`unregister` gör ingenting om *func* inte registrerats tidigare.  "
"Om *func* har registrerats mer än en gång kommer varje förekomst av den "
"funktionen i anropsstacken :mod:`atexit` att tas bort.  "
"Jämlikhetsjämförelser (``==``) används internt under avregistreringen, så "
"funktionsreferenser behöver inte ha matchande identiteter."

msgid "Module :mod:`readline`"
msgstr "Modul :mod:`readline`"

msgid ""
"Useful example of :mod:`atexit` to read and write :mod:`readline` history "
"files."
msgstr ""
"Användbart exempel på :mod:`atexit` för att läsa och skriva :mod:`readline` "
"historikfiler."

msgid ":mod:`atexit` Example"
msgstr ":mod:`atexit` Exempel"

msgid ""
"The following simple example demonstrates how a module can initialize a "
"counter from a file when it is imported and save the counter's updated value "
"automatically when the program terminates without relying on the application "
"making an explicit call into this module at termination. ::"
msgstr ""
"Följande enkla exempel visar hur en modul kan initiera en räknare från en "
"fil när den importeras och spara räknarens uppdaterade värde automatiskt när "
"programmet avslutas utan att vara beroende av att programmet gör ett "
"uttryckligt anrop till denna modul vid avslutningen. ::"

msgid ""
"try:\n"
"    with open('counterfile') as infile:\n"
"        _count = int(infile.read())\n"
"except FileNotFoundError:\n"
"    _count = 0\n"
"\n"
"def incrcounter(n):\n"
"    global _count\n"
"    _count = _count + n\n"
"\n"
"def savecounter():\n"
"    with open('counterfile', 'w') as outfile:\n"
"        outfile.write('%d' % _count)\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(savecounter)"
msgstr ""
"try:\n"
"    with open('counterfile') as infile:\n"
"        _count = int(infile.read())\n"
"except FileNotFoundError:\n"
"    _count = 0\n"
"\n"
"def incrcounter(n):\n"
"    global _count\n"
"    _count = _count + n\n"
"\n"
"def savecounter():\n"
"    with open('counterfile', 'w') as outfile:\n"
"        outfile.write('%d' % _count)\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(savecounter)"

msgid ""
"Positional and keyword arguments may also be passed to :func:`register` to "
"be passed along to the registered function when it is called::"
msgstr ""
"Positionella argument och nyckelordsargument kan också skickas till :func:"
"`register` för att skickas vidare till den registrerade funktionen när den "
"anropas::"

msgid ""
"def goodbye(name, adjective):\n"
"    print('Goodbye %s, it was %s to meet you.' % (name, adjective))\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(goodbye, 'Donny', 'nice')\n"
"# or:\n"
"atexit.register(goodbye, adjective='nice', name='Donny')"
msgstr ""
"def goodbye(name, adjective):\n"
"    print('Goodbye %s, it was %s to meet you.' % (name, adjective))\n"
"\n"
"import atexit\n"
"\n"
"atexit.register(goodbye, 'Donny', 'nice')\n"
"# or:\n"
"atexit.register(goodbye, adjective='nice', name='Donny')"

msgid "Usage as a :term:`decorator`::"
msgstr "Användning som :term:`decorator`::"

msgid ""
"import atexit\n"
"\n"
"@atexit.register\n"
"def goodbye():\n"
"    print('You are now leaving the Python sector.')"
msgstr ""
"import atexit\n"
"\n"
"@atexit.register\n"
"def goodbye():\n"
"    print('You are now leaving the Python sector.')"

msgid "This only works with functions that can be called without arguments."
msgstr "Detta fungerar endast med funktioner som kan anropas utan argument."
