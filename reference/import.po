# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "The import system"
msgstr "Importsystemet"

msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"Python-kod i en :term:`modul` får tillgång till koden i en annan modul genom "
"att :term:`importera` den.  Satsen :keyword:`import` är det vanligaste "
"sättet att anropa importmaskineriet, men det är inte det enda sättet.  "
"Funktioner som :func:`importlib.import_module` och den inbyggda :func:"
"`__import__` kan också användas för att anropa importmaskineriet."

msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
"Satsen :keyword:`import` kombinerar två operationer; den söker efter den "
"namngivna modulen och binder sedan resultatet av denna sökning till ett namn "
"i det lokala omfånget.  Sökoperationen i :keyword:`!import`-satsen "
"definieras som ett anrop till funktionen :func:`__import__`, med lämpliga "
"argument. Returvärdet för :func:`__import__` används för att utföra "
"namnbindningsoperationen i :keyword:`!import`-satsen.  Se :keyword:`!import`-"
"satsen för exakta detaljer om denna namnbindningsoperation."

msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
"Ett direkt anrop till :func:`__import__` utför endast modulsökningen och, om "
"den hittas, skapandet av modulen.  Även om vissa sidoeffekter kan uppstå, t."
"ex. import av överordnade paket och uppdatering av olika cacheminnen "
"(inklusive :data:`sys.modules`), är det bara :keyword:`import` som utför en "
"namnbindningsoperation."

msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
"När en :keyword:`import`-sats exekveras anropas den inbyggda "
"standardfunktionen :func:`__import__`. Andra mekanismer för att anropa "
"importsystemet (t.ex. :func:`importlib.import_module`) kan välja att "
"kringgå :func:`__import__` och använda sina egna lösningar för att "
"implementera importsemantik."

msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"När en modul importeras första gången söker Python efter modulen och om den "
"hittas skapar den ett modulobjekt [#fnmo]_ och initialiserar det.  Om den "
"namngivna modulen inte kan hittas genereras ett :exc:`ModuleNotFoundError`.  "
"Python implementerar olika strategier för att söka efter den namngivna "
"modulen när importmaskinen anropas.  Dessa strategier kan modifieras och "
"utökas genom att använda olika krokar som beskrivs i avsnitten nedan."

msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"Importsystemet har uppdaterats för att fullt ut implementera den andra fasen "
"av :pep:`302`. Det finns inte längre något implicit importmaskineri - hela "
"importsystemet är exponerat genom :data:`sys.meta_path`. Dessutom har stöd "
"för inbyggda namnrymdspaket implementerats (se :pep:`420`)."

msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
"Modulen :mod:`importlib` tillhandahåller ett omfattande API för att "
"interagera med importsystemet.  Till exempel ger :func:`importlib."
"import_module` ett rekommenderat, enklare API än inbyggda :func:`__import__` "
"för att anropa importmaskineriet.  Se dokumentationen för biblioteket :mod:"
"`importlib` för mer information."

msgid "Packages"
msgstr "Paket"

msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"Python har bara en typ av modulobjekt, och alla moduler är av denna typ, "
"oavsett om modulen är implementerad i Python, C eller något annat.  För att "
"hjälpa till att organisera moduler och tillhandahålla en "
"namngivningshierarki har Python ett koncept av :term:`packages <package>`."

msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"Du kan tänka på paket som kataloger i ett filsystem och moduler som filer i "
"kataloger, men ta inte den här analogin alltför bokstavligt eftersom paket "
"och moduler inte behöver komma från filsystemet.  I den här dokumentationen "
"använder vi den praktiska analogin med kataloger och filer.  Precis som "
"kataloger i filsystemet är paket organiserade hierarkiskt, och paket kan i "
"sig innehålla underpaket, liksom vanliga moduler."

msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"Det är viktigt att komma ihåg att alla paket är moduler, men inte alla "
"moduler är paket.  Eller uttryckt på ett annat sätt, paket är bara en "
"speciell typ av modul.  Specifikt betraktas alla moduler som innehåller ett "
"``__path__``-attribut som ett paket."

msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by a dot, akin to Python's standard attribute access syntax.  "
"Thus you might have a package called :mod:`email`, which in turn has a "
"subpackage called :mod:`email.mime` and a module within that subpackage "
"called :mod:`email.mime.text`."
msgstr ""
"Alla moduler har ett namn.  Namn på underpaket separeras från namnet på det "
"överordnade paketet med en punkt, på samma sätt som Pythons standardsyntax "
"för attributåtkomst.  Således kan du ha ett paket som heter :mod:`email`, "
"som i sin tur har ett underpaket som heter :mod:`email.mime` och en modul "
"inom det underpaketet som heter :mod:`email.mime.text`."

msgid "Regular packages"
msgstr "Vanliga paket"

msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"Python definierar två typer av paket, :term:`regular packages <regular "
"package>` och :term:`namespace packages <namespace package>`.  Vanliga paket "
"är traditionella paket som de fanns i Python 3.2 och tidigare. Ett vanligt "
"paket implementeras vanligtvis som en katalog som innehåller en fil med "
"namnet ``__init__.py``.  När ett reguljärt paket importeras körs filen "
"``__init__.py`` implicit, och de objekt som definieras i den binds till namn "
"i paketets namnrymd.  Filen ``__init__.py`` kan innehålla samma Python-kod "
"som vilken annan modul som helst, och Python kommer att lägga till några "
"ytterligare attribut till modulen när den importeras."

msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""
"Följande filsystemlayout definierar t.ex. ett \"föräldrapaket\" på högsta "
"nivån med tre underpaket::"

msgid ""
"parent/\n"
"    __init__.py\n"
"    one/\n"
"        __init__.py\n"
"    two/\n"
"        __init__.py\n"
"    three/\n"
"        __init__.py"
msgstr ""
"förälder/\n"
"    __init__.py\n"
"    en/\n"
"        __init__.py\n"
"    två/\n"
"        __init__.py\n"
"    tre/\n"
"        __init__.py"

msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"Import av ``parent.one`` kommer implicit att exekvera ``parent/__init__.py`` "
"och ``parent/one/__init__.py``.  Efterföljande import av ``parent.two`` "
"eller ``parent.three`` kommer att exekvera ``parent/two/__init__.py`` "
"respektive ``parent/three/__init__.py``."

msgid "Namespace packages"
msgstr "Paket för namnrymden"

msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"Ett namnrymdspaket är en sammansättning av olika :term:`portioner "
"<portion>`, där varje portion bidrar med ett underpaket till moderpaketet.  "
"Delar kan finnas på olika platser i filsystemet.  Delar kan också finnas i "
"zip-filer, på nätverket eller någon annanstans som Python söker efter under "
"import.  Namnrymdspaket kanske inte direkt motsvarar objekt i filsystemet; "
"de kan vara virtuella moduler som inte har någon konkret representation."

msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"Namnområdespaket använder inte en vanlig lista för sitt attribut "
"``__path__``. De använder istället en anpassad iterabel typ som automatiskt "
"utför en ny sökning efter paketdelar vid nästa importförsök inom det paketet "
"om sökvägen till deras överordnade paket (eller :data:`sys.path` för ett "
"paket på högsta nivån) ändras."

msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"Med namespace-paket finns det ingen fil med namnet ``parent/__init__.py``.  "
"I själva verket kan det finnas flera ``parent``-kataloger som hittas under "
"importsökningen, där var och en tillhandahålls av en annan del.  Således "
"kanske ``parent/one`` inte är fysiskt placerad bredvid ``parent/two``.  I "
"det här fallet kommer Python att skapa ett namnrymdspaket för "
"toppnivåpaketet ``parent`` när det eller ett av dess underpaket importeras."

msgid "See also :pep:`420` for the namespace package specification."
msgstr "Se även :pep:`420` för specifikation av namnrymdspaket."

msgid "Searching"
msgstr "Söker"

msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"För att påbörja sökningen behöver Python :term:`fullständigt kvalificerat "
"<qualified name>` namn på modulen (eller paketet, men för denna diskussions "
"syfte är skillnaden oväsentlig) som importeras.  Detta namn kan komma från "
"olika argument till :keyword:`import`-satsen, eller från parametrarna till "
"funktionerna :func:`importlib.import_module` eller :func:`__import__`."

msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"Detta namn kommer att användas i olika faser av importsökningen, och det kan "
"vara den prickade sökvägen till en undermodul, t.ex. ``foo.bar.baz``.  I det "
"här fallet försöker Python först importera ``foo``, sedan ``foo.bar`` och "
"slutligen ``foo.bar.baz``. Om någon av de mellanliggande importerna "
"misslyckas genereras ett :exc:`ModuleNotFoundError`."

msgid "The module cache"
msgstr "Modulens cache"

msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"Den första platsen som kontrolleras under importsökningen är :data:`sys."
"modules`.  Denna mappning fungerar som en cache för alla moduler som "
"tidigare har importerats, inklusive mellanliggande sökvägar.  Så om ``foo."
"bar.baz`` tidigare har importerats, kommer :data:`sys.modules` att innehålla "
"poster för ``foo``, ``foo.bar`` och ``foo.bar.baz``.  Varje nyckel kommer "
"att ha motsvarande modulobjekt som sitt värde."

msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"Under importen söks modulnamnet upp i :data:`sys.modules` och om det finns "
"där är det associerade värdet den modul som uppfyller importkraven och "
"processen avslutas.  Men om värdet är ``None``, så uppstår ett :exc:"
"`ModuleNotFoundError`.  Om modulnamnet saknas kommer Python att fortsätta "
"att söka efter modulen."

msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` är skrivbar.  Att radera en nyckel kanske inte förstör "
"den associerade modulen (eftersom andra moduler kan innehålla referenser "
"till den), men det kommer att ogiltigförklara cacheposten för den namngivna "
"modulen, vilket gör att Python måste söka på nytt efter den namngivna "
"modulen vid nästa import. Nyckeln kan också tilldelas ``None``, vilket "
"tvingar nästa import av modulen att resultera i ett :exc:"
"`ModuleNotFoundError`."

msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"Se dock upp, för om du behåller en referens till modulobjektet, "
"ogiltigförklarar dess cache-post i :data:`sys.modules` och sedan "
"återimporterar den namngivna modulen, kommer de två modulobjekten *inte* att "
"vara desamma. Däremot kommer :func:`importlib.reload` att återanvända "
"*samma* modulobjekt och helt enkelt återinitialisera modulens innehåll genom "
"att köra om modulens kod."

msgid "Finders and loaders"
msgstr "Sökare och lastare"

msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
"Om den namngivna modulen inte finns i :data:`sys.modules`, används Pythons "
"importprotokoll för att hitta och ladda modulen.  Detta protokoll består av "
"två konceptuella objekt, :term:`finders <finder>` och :term:`loaders "
"<loader>`. En sökares uppgift är att avgöra om den kan hitta den namngivna "
"modulen med hjälp av någon strategi som den känner till. Objekt som "
"implementerar båda dessa gränssnitt kallas :term:`importers <importer>` - de "
"returnerar sig själva när de upptäcker att de kan ladda den begärda modulen."

msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python innehåller ett antal standardsökare och importörer.  Den första vet "
"hur man hittar inbyggda moduler, och den andra vet hur man hittar frysta "
"moduler.  En tredje standardsökare söker efter moduler i en :term:`import "
"path`.  :term:`import path` är en lista med platser som kan vara sökvägar "
"till filsystem eller zip-filer.  Den kan också utökas till att söka efter "
"alla lokaliserbara resurser, till exempel de som identifieras av "
"webbadresser."

msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""
"Importmaskineriet är utbyggbart, så nya sökare kan läggas till för att utöka "
"modulens sökmöjligheter."

msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"Sökare laddar faktiskt inte moduler.  Om de kan hitta den namngivna modulen "
"returnerar de en :dfn:`module spec`, en inkapsling av modulens "
"importrelaterade information, som importmaskineriet sedan använder när "
"modulen laddas."

msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"I följande avsnitt beskrivs protokollet för sökare och laddare mer i detalj, "
"inklusive hur du kan skapa och registrera nya för att utöka "
"importmaskineriet."

msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"I tidigare versioner av Python returnerade sökare :term:`laddare <loader>` "
"direkt, medan de nu returnerar modulspecifikationer som *innehåller* "
"laddare. Laddare används fortfarande under import men har färre "
"ansvarsområden."

msgid "Import hooks"
msgstr "Importera krokar"

msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"Importmaskineriet är utformat för att vara utbyggbart; den primära "
"mekanismen för detta är *importkrokarna*.  Det finns två typer av "
"importkrokar: *metakrokar* och *importvägskrokar*."

msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"Metakrokar anropas i början av importbearbetningen, innan någon annan "
"importbearbetning har ägt rum, förutom :data:`sys.modules` cache look up. "
"Detta gör att metakrokar kan åsidosätta :data:`sys.path`-behandling, frysta "
"moduler eller till och med inbyggda moduler.  Metakrokar registreras genom "
"att nya sökobjekt läggs till i :data:`sys.meta_path`, enligt beskrivningen "
"nedan."

msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"Import sökvägskrokar anropas som en del av :data:`sys.path` (eller ``package."
"__path__``) bearbetning, vid den punkt där deras associerade sökvägsobjekt "
"påträffas.  Importsökvägskrokar registreras genom att lägga till nya "
"anropbara filer i :data:`sys.path_hooks` enligt beskrivningen nedan."

msgid "The meta path"
msgstr "Metasökvägen"

msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec` which takes three arguments: "
"a name, an import path, and (optionally) a target module.  The meta path "
"finder can use any strategy it wants to determine whether it can handle the "
"named module or not."
msgstr ""
"När den namngivna modulen inte hittas i :data:`sys.modules` söker Python "
"vidare i :data:`sys.meta_path`, som innehåller en lista över "
"metasökvägssökarobjekt.  Dessa sökare tillfrågas för att se om de vet hur de "
"ska hantera den namngivna modulen.  Metasökvägssökare måste implementera en "
"metod som heter :meth:`~importlib.abc.MetaPathFinder.find_spec` som tar tre "
"argument: ett namn, en importsökväg och (eventuellt) en målmodul.  "
"Metasökvägssökaren kan använda vilken strategi den vill för att avgöra om "
"den kan hantera den namngivna modulen eller inte."

msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"Om metasökvägssökaren vet hur den ska hantera den namngivna modulen "
"returneras ett spec-objekt.  Om den inte kan hantera den namngivna modulen "
"returneras ``None``.  Om :data:`sys.meta_path`-behandlingen når slutet av "
"sin lista utan att returnera en specifikation, uppstår ett :exc:"
"`ModuleNotFoundError`.  Alla andra undantag som uppstår sprids helt enkelt "
"uppåt och avbryter importprocessen."

msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"Metoden :meth:`~importlib.abc.MetaPathFinder.find_spec` för "
"metasökvägssökare anropas med två eller tre argument.  Det första är det "
"fullständigt kvalificerade namnet på den modul som importeras, t.ex. ``foo."
"bar.baz``. Det andra argumentet är de sökvägsposter som ska användas för "
"sökningen efter modulen.  För moduler på högsta nivån är det andra "
"argumentet ``None``, men för undermoduler eller underpaket är det andra "
"argumentet värdet på det överordnade paketets attribut ``__path__``. Om det "
"inte går att komma åt rätt ``__path__``-attribut, uppstår ett :exc:"
"`ModuleNotFoundError`.  Det tredje argumentet är ett befintligt modulobjekt "
"som kommer att laddas senare. Importsystemet skickar in en målmodul endast "
"under omladdning."

msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"Metasökvägen kan genomkorsas flera gånger för en enda importbegäran. Till "
"exempel, förutsatt att ingen av de inblandade modulerna redan har cachats, "
"kommer import av ``foo.bar.baz`` först att utföra en toppnivåimport, anropa "
"``mpf.find_spec(\"foo\", None, None)`` på varje metasökvägssökare (``mpf``). "
"När ``foo`` har importerats importeras ``foo.bar`` genom att metasökvägen "
"genomkorsas en andra gång och ``mpf.find_spec(\"foo.bar\", foo.__path__, "
"None)`` anropas. När ``foo.bar`` har importerats kommer den sista "
"traverseringen att anropa ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, "
"None)``."

msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"Vissa metasökvägssökare stöder endast import på toppnivå. Dessa importörer "
"returnerar alltid ``None`` när något annat än ``None`` anges som det andra "
"argumentet."

msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"Pythons standard :data:`sys.meta_path` har tre metasökvägssökare, en som vet "
"hur man importerar inbyggda moduler, en som vet hur man importerar frysta "
"moduler och en som vet hur man importerar moduler från en :term:`importväg` "
"(dvs. den :term:`vägbaserade sökaren`)."

msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`!find_module`, which is now deprecated.  While it "
"will continue to work without change, the import machinery will try it only "
"if the finder does not implement :meth:`~importlib.abc.MetaPathFinder."
"find_spec`."
msgstr ""
"Metoden :meth:`~importlib.abc.MetaPathFinder.find_spec` för "
"metasökvägssökare ersatte :meth:`!find_module`, som nu är föråldrad.  Även "
"om den kommer att fortsätta att fungera utan förändring, kommer "
"importmaskineriet bara att prova den om sökaren inte implementerar :meth:"
"`~importlib.abc.MetaPathFinder.find_spec`."

msgid ""
"Use of :meth:`!find_module` by the import system now raises :exc:"
"`ImportWarning`."
msgstr ""
"Importsystemets användning av :meth:`!find_module` ger nu upphov till :exc:"
"`ImportWarning`."

msgid ""
":meth:`!find_module` has been removed. Use :meth:`~importlib.abc."
"MetaPathFinder.find_spec` instead."
msgstr ""
":meth:`!find_module` har tagits bort. Använd :meth:`~importlib.abc."
"MetaPathFinder.find_spec` istället."

msgid "Loading"
msgstr "Laddar"

msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"Om och när en modulspecifikation hittas kommer importmaskineriet att använda "
"den (och den laddare som den innehåller) när modulen laddas.  Här är en "
"ungefärlig beskrivning av vad som händer under laddningsdelen av import::"

msgid ""
"module = None\n"
"if spec.loader is not None and hasattr(spec.loader, 'create_module'):\n"
"    # It is assumed 'exec_module' will also be defined on the loader.\n"
"    module = spec.loader.create_module(spec)\n"
"if module is None:\n"
"    module = ModuleType(spec.name)\n"
"# The import-related module attributes get set here:\n"
"_init_module_attrs(spec, module)\n"
"\n"
"if spec.loader is None:\n"
"    # unsupported\n"
"    raise ImportError\n"
"if spec.origin is None and spec.submodule_search_locations is not None:\n"
"    # namespace package\n"
"    sys.modules[spec.name] = module\n"
"elif not hasattr(spec.loader, 'exec_module'):\n"
"    module = spec.loader.load_module(spec.name)\n"
"else:\n"
"    sys.modules[spec.name] = module\n"
"    try:\n"
"        spec.loader.exec_module(module)\n"
"    except BaseException:\n"
"        try:\n"
"            del sys.modules[spec.name]\n"
"        except KeyError:\n"
"            pass\n"
"        raise\n"
"return sys.modules[spec.name]"
msgstr ""
"modul = Ingen\n"
"if spec.loader is not None and hasattr(spec.loader, 'create_module'):\n"
"    # Det antas att 'exec_module' också kommer att definieras i laddaren.\n"
"    modul = spec.loader.create_module(spec)\n"
"om modulen är None:\n"
"    module = ModuleType(spec.name)\n"
"# De importrelaterade modulattributen ställs in här:\n"
"_init_module_attrs(spec, modul)\n"
"\n"
"om spec.loader är None:\n"
"    # stöds inte\n"
"    höja ImportError\n"
"om spec.origin är None och spec.submodule_search_locations inte är None:\n"
"    # namnrymdspaket\n"
"    sys.modules[spec.name] = modul\n"
"elif not hasattr(spec.loader, 'exec_module'):\n"
"    modul = spec.loader.load_module(spec.name)\n"
"else:\n"
"    sys.modules[spec.name] = modul\n"
"    försök:\n"
"        spec.loader.exec_module(modul)\n"
"    utom BaseException:\n"
"        try:\n"
"            del sys.moduler[spec.namn]\n"
"        except KeyError:\n"
"            pass\n"
"        höja\n"
"returnera sys.moduler[spec.namn]"

msgid "Note the following details:"
msgstr "Notera följande detaljer:"

msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""
"Om det finns ett befintligt modulobjekt med det angivna namnet i :data:`sys."
"modules`, kommer import redan att ha returnerat det."

msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"Modulen kommer att finnas i :data:`sys.modules` innan laddaren exekverar "
"modulkoden.  Detta är viktigt eftersom modulkoden kan (direkt eller "
"indirekt) importera sig själv; genom att lägga till den i :data:`sys."
"modules` i förväg förhindras obegränsad rekursion i värsta fall och multipel "
"laddning i bästa fall."

msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"Om laddningen misslyckas tas den misslyckade modulen - och endast den "
"misslyckade modulen - bort från :data:`sys.modules`.  Alla moduler som redan "
"finns i :data:`sys.modules` cache, och alla moduler som laddades "
"framgångsrikt som en bieffekt, måste finnas kvar i cachen.  Detta står i "
"kontrast till omlastning där även den misslyckade modulen finns kvar i :data:"
"`sys.modules`."

msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
"Efter att modulen har skapats men innan den körs ställer importmaskineriet "
"in de importrelaterade modulattributen (\"_init_module_attrs\" i "
"pseudokodeexemplet ovan), som sammanfattas i en :ref:`längre avsnitt <import-"
"mod-attrs>`."

msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"Modulens exekvering är det viktiga ögonblicket i laddningen då modulens "
"namnrymd fylls på.  Exekveringen är helt delegerad till laddaren, som får "
"bestämma vad som ska fyllas i och hur."

msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""
"Den modul som skapas under laddningen och skickas till exec_module() kanske "
"inte är den som returneras i slutet av import [#fnlo]_."

msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""
"Importsystemet har tagit över laddningsfunktionernas ansvar för "
"boilerplate.  Dessa utfördes tidigare av metoden :meth:`importlib.abc.Loader."
"load_module`."

msgid "Loaders"
msgstr "Lastare"

msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"Modulladdare tillhandahåller den kritiska funktionen för laddning: "
"modulkörning. Importmaskineriet anropar metoden :meth:`importlib.abc.Loader."
"exec_module` med ett enda argument, det modulobjekt som ska köras.  Alla "
"värden som returneras från :meth:`~importlib.abc.Loader.exec_module` "
"ignoreras."

msgid "Loaders must satisfy the following requirements:"
msgstr "Lastmaskinerna måste uppfylla följande krav:"

msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"Om modulen är en Python-modul (i motsats till en inbyggd modul eller ett "
"dynamiskt laddat tillägg), ska laddaren exekvera modulens kod i modulens "
"globala namnrymd (``module.__dict__``)."

msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
"Om laddaren inte kan exekvera modulen bör den ge upphov till ett :exc:"
"`ImportError`, även om alla andra undantag som ges upphov till under :meth:"
"`~importlib.abc.Loader.exec_module` kommer att spridas."

msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"I många fall kan sökaren och laddaren vara samma objekt; i sådana fall "
"skulle metoden :meth:`~importlib.abc.MetaPathFinder.find_spec` bara "
"returnera en spec med laddaren inställd på ``self``."

msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"Modulladdare kan välja att skapa modulobjektet under laddningen genom att "
"implementera en :meth:`~importlib.abc.Loader.create_module`-metod. Den tar "
"ett argument, modulspecifikationen, och returnerar det nya modulobjektet som "
"ska användas under laddningen.  ``create_module()`` behöver inte ställa in "
"några attribut på modulobjektet.  Om metoden returnerar ``None`` kommer "
"importmaskineriet att skapa den nya modulen själv."

msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "Metoden :meth:`~importlib.abc.Loader.create_module` för laddare."

msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
"Metoden :meth:`~importlib.abc.Loader.load_module` ersattes av :meth:"
"`~importlib.abc.Loader.exec_module` och importmaskineriet tog på sig allt "
"ansvar för laddningen."

msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"För kompatibilitet med befintliga laddare kommer importmaskineriet att "
"använda laddarnas ``load_module()``-metod om den finns och laddaren inte "
"också implementerar ``exec_module()``.  Dock har ``load_module()`` utgått "
"och laddare bör implementera ``exec_module()`` istället."

msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"Metoden ``load_module()`` måste implementera alla de standardfunktioner för "
"laddning som beskrivs ovan, förutom att exekvera modulen.  Alla samma "
"begränsningar gäller, med några ytterligare förtydliganden:"

msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
"Om det finns ett befintligt modulobjekt med det angivna namnet i :data:`sys."
"modules`, måste laddaren använda den befintliga modulen. (Annars kommer :"
"func:`importlib.reload` inte att fungera korrekt.) Om den namngivna modulen "
"inte finns i :data:`sys.modules`, måste laddaren skapa ett nytt modulobjekt "
"och lägga till det i :data:`sys.modules`."

msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"Modulen *måste* finnas i :data:`sys.modules` innan laddaren kör modulkoden, "
"för att förhindra obegränsad rekursion eller multipel laddning."

msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"Om laddningen misslyckas måste laddaren ta bort alla moduler som den har "
"infogat i :data:`sys.modules`, men den måste **endast** ta bort den eller de "
"moduler som misslyckas, och endast om laddaren själv har laddat modulerna "
"explicit."

msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"En :exc:`DeprecationWarning` tas upp när ``exec_module()`` är definierad men "
"``create_module()`` inte är det."

msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Ett :exc:`ImportError` uppstår när ``exec_module()`` är definierad men "
"``create_module()`` inte är det."

msgid "Use of ``load_module()`` will raise :exc:`ImportWarning`."
msgstr ""
"Användning av ``load_module()`` kommer att ge upphov till :exc:"
"`ImportWarning`."

msgid "Submodules"
msgstr "Undermoduler"

msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"När en undermodul laddas med hjälp av någon mekanism (t.ex. API:erna "
"``importlib``, ``import`` eller ``import-from``-satserna, eller inbyggda "
"``__import__()``) placeras en bindning i modermodulens namnrymd till "
"undermodulens objekt. Till exempel, om paketet ``spam`` har en undermodul "
"``foo``, efter import av ``spam.foo``, kommer ``spam`` att ha ett attribut "
"``foo`` som är bundet till undermodulen.  Låt oss säga att du har följande "
"katalogstruktur::"

msgid ""
"spam/\n"
"    __init__.py\n"
"    foo.py"
msgstr ""
"spam/\n"
"    __init__.py\n"
"    foo.py"

msgid "and ``spam/__init__.py`` has the following line in it::"
msgstr "och ``spam/__init__.py`` har följande rad i sig::"

msgid "from .foo import Foo"
msgstr "from .foo import Foo"

msgid ""
"then executing the following puts name bindings for ``foo`` and ``Foo`` in "
"the ``spam`` module::"
msgstr ""
"sedan körs följande sätter namnbindningar för ``foo`` och ``Foo`` i ``spam``-"
"modulen::"

msgid ""
">>> import spam\n"
">>> spam.foo\n"
"<module 'spam.foo' from '/tmp/imports/spam/foo.py'>\n"
">>> spam.Foo\n"
"<class 'spam.foo.Foo'>"
msgstr ""
">>> import spam\n"
">>> spam.foo\n"
"<module 'spam.foo' from '/tmp/imports/spam/foo.py'>\n"
">>> spam.Foo\n"
"<class 'spam.foo.Foo'>"

msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"Med tanke på Pythons välkända namnbindningsregler kan detta verka "
"förvånande, men det är faktiskt en grundläggande funktion i importsystemet.  "
"Den oföränderliga hållningen är att om du har ``sys.modules['spam']`` och "
"``sys.modules['spam.foo']`` (som du skulle göra efter ovanstående import), "
"måste den senare visas som ``foo``-attributet för den förra."

msgid "Module specs"
msgstr "Specifikationer för modul"

msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"Importmaskineriet använder en mängd information om varje modul under "
"importen, särskilt före inläsningen.  Det mesta av informationen är gemensam "
"för alla moduler.  Syftet med en moduls spec är att kapsla in denna "
"importrelaterade information för varje enskild modul."

msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"Genom att använda en specifikation under importen kan information överföras "
"mellan komponenterna i importsystemet, t.ex. mellan den sökare som skapar "
"modulspecifikationen och den laddare som utför den.  Viktigast av allt är "
"att det gör det möjligt för importmaskineriet att utföra de standardiserade "
"laddningsoperationerna, medan det utan en modulspecifikation var laddaren "
"som hade det ansvaret."

msgid ""
"The module's spec is exposed as :attr:`module.__spec__`. Setting :attr:`!"
"__spec__` appropriately applies equally to :ref:`modules initialized during "
"interpreter startup <programs>`. The one exception is ``__main__``, where :"
"attr:`!__spec__` is :ref:`set to None in some cases <main_spec>`."
msgstr ""
"Modulens specifikation visas som :attr:`module.__spec__`. Att ställa in :"
"attr:`!__spec__` på rätt sätt gäller lika för :ref:`moduler som initieras "
"under tolkens start <programs>`. Det enda undantaget är ``__main__``, där :"
"attr:`!__spec__` är :ref:`satt till None i vissa fall <main_spec>`."

msgid ""
"See :class:`~importlib.machinery.ModuleSpec` for details on the contents of "
"the module spec."
msgstr ""
"Se :class:`~importlib.machinery.ModuleSpec` för detaljer om innehållet i "
"modulspecifikationen."

msgid "__path__ attributes on modules"
msgstr "__path__-attribut för moduler"

msgid ""
"The :attr:`~module.__path__` attribute should be a (possibly empty) :term:"
"`sequence` of strings enumerating the locations where the package's "
"submodules will be found. By definition, if a module has a :attr:`!__path__` "
"attribute, it is a :term:`package`."
msgstr ""
"Attributet :attr:`~module.__path__` bör vara en (eventuellt tom) :term:"
"`sekvens` av strängar som räknar upp de platser där paketets undermoduler "
"kommer att hittas. Om en modul har attributet :attr:`!__path__` är den per "
"definition en :term:`package`."

msgid ""
"A package's :attr:`~module.__path__` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, :attr:`!__path__` is typically much more constrained "
"than :data:`!sys.path`."
msgstr ""
"Ett pakets attribut :attr:`~module.__path__` används vid import av dess "
"underpaket. Inom importmaskineriet fungerar det ungefär på samma sätt som :"
"data:`sys.path`, dvs. tillhandahåller en lista över platser att söka efter "
"moduler under import. Men :attr:`!__path__` är vanligtvis mycket mer "
"begränsad än :data:`!sys.path`."

msgid ""
"The same rules used for :data:`sys.path` also apply to a package's :attr:`!"
"__path__`. :data:`sys.path_hooks` (described below) are consulted when "
"traversing a package's :attr:`!__path__`."
msgstr ""
"Samma regler som används för :data:`sys.path` gäller också för ett pakets :"
"attr:`!__path__`. :data:`sys.path_hooks` (beskrivs nedan) används när ett "
"pakets :attr:`!__path__` genomkorsas."

msgid ""
"A package's ``__init__.py`` file may set or alter the package's :attr:"
"`~module.__path__` attribute, and this was typically the way namespace "
"packages were implemented prior to :pep:`420`.  With the adoption of :pep:"
"`420`, namespace packages no longer need to supply ``__init__.py`` files "
"containing only :attr:`!__path__` manipulation code; the import machinery "
"automatically sets :attr:`!__path__` correctly for the namespace package."
msgstr ""
"Ett pakets fil ``__init__.py`` kan ställa in eller ändra paketets attribut :"
"attr:`~module.__path__`, och detta var typiskt det sätt som namespace-paket "
"implementerades på före :pep:`420`.  Med införandet av :pep:`420` behöver "
"namnrymdspaket inte längre tillhandahålla ``__init__.py``-filer som endast "
"innehåller manipuleringskod för :attr:`!__path__`; importmaskineriet ställer "
"automatiskt in :attr:`!__path__` korrekt för namnrymdspaketet."

msgid "Module reprs"
msgstr "Modul reprs"

msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"Som standard har alla moduler en användbar repr, men beroende på de attribut "
"som anges ovan och i modulens specifikation kan du mer explicit styra repr "
"för modulobjekt."

msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"Om modulen har en specifikation (``__spec__``) kommer importsystemet att "
"försöka generera en repr från den.  Om det misslyckas eller om det inte "
"finns någon specifikation kommer importsystemet att skapa ett "
"standardreferat med hjälp av den information som finns tillgänglig om "
"modulen.  Det kommer att försöka använda ``modul.__name__``, ``modul."
"__file__`` och ``modul.__loader__`` som indata till repr, med standardvärden "
"för all information som saknas."

msgid "Here are the exact rules used:"
msgstr "Här är de exakta reglerna som används:"

msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"Om modulen har attributet ``__spec__`` används informationen i "
"specifikationen för att generera repr.  Attributen \"name\", \"loader\", "
"\"origin\" och \"has_location\" konsulteras."

msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""
"Om modulen har ett ``__file__``-attribut används detta som en del av "
"modulens repr."

msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"Om modulen inte har någon ``__file__`` men har en ``__loader__`` som inte är "
"``None``, så används laddarens repr som en del av modulens repr."

msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "Annars använder du bara modulens ``__name__`` i repr."

msgid ""
"Use of :meth:`!module_repr`, having been deprecated since Python 3.4, was "
"removed in Python 3.12 and is no longer called during the resolution of a "
"module's repr."
msgstr ""
"Användning av :meth:`!module_repr`, som har varit föråldrad sedan Python "
"3.4, togs bort i Python 3.12 och anropas inte längre under upplösningen av "
"en moduls repr."

msgid "Cached bytecode invalidation"
msgstr "Inaktivering av cachad bytekod"

msgid ""
"Before Python loads cached bytecode from a ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""
"Innan Python läser in cachad bytekod från en ``.pyc``-fil, kontrollerar den "
"om cacheminnet är uppdaterat med källfilen ``.py``. Som standard gör Python "
"detta genom att lagra källans senast ändrade tidsstämpel och storlek i "
"cachefilen när den skrivs. Vid körning validerar importsystemet sedan "
"cachefilen genom att kontrollera de lagrade metadata i cachefilen mot "
"källans metadata."

msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""
"Python stöder också \"hash-baserade\" cachefiler, som lagrar en hash av "
"källfilens innehåll snarare än dess metadata. Det finns två varianter av "
"hash-baserade ``.pyc``-filer: kontrollerade och okontrollerade. För "
"kontrollerade hash-baserade ``.pyc``-filer validerar Python cachefilen genom "
"att hasha källfilen och jämföra den resulterande hashen med hashen i "
"cachefilen. Om en kontrollerad hashbaserad cachefil visar sig vara ogiltig, "
"regenererar Python den och skriver en ny kontrollerad hashbaserad cachefil. "
"För okontrollerade hash-baserade ``.pyc``-filer antar Python helt enkelt att "
"cache-filen är giltig om den finns. Valideringsbeteendet för hashbaserade ``."
"pyc``-filer kan åsidosättas med flaggan :option:`--check-hash-based-pycs`."

msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr ""
"Lagt till hash-baserade ``.pyc``-filer. Tidigare stödde Python endast "
"tidsstämpelbaserad ogiltigförklaring av bytecode-cacher."

msgid "The Path Based Finder"
msgstr "Den sökvägsbaserade sökaren"

msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"Som tidigare nämnts kommer Python med flera standard metasökvägssökare. En "
"av dessa, som kallas :term:`path based finder` (:class:`~importlib.machinery."
"PathFinder`), söker i en :term:`import path`, som innehåller en lista med :"
"term:`path entries <path entry>`.  Varje sökvägspost namnger en plats att "
"söka efter moduler på."

msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"Den sökvägsbaserade sökfunktionen vet inte själv hur den ska importera "
"någonting. Istället går den igenom de enskilda sökvägsposterna och "
"associerar var och en av dem med en sökvägspostsökare som vet hur den ska "
"hantera just den typen av sökväg."

msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"Standarduppsättningen av sökvägssökare implementerar all semantik för att "
"hitta moduler i filsystemet och hanterar speciella filtyper som Python-"
"källkod (``.py``-filer), Python-bytekod (``.pyc``-filer) och delade "
"bibliotek (t.ex. ``.so``-filer). När modulen :mod:`zipimport` i "
"standardbiblioteket stöder detta, kan standardsökvägarna också hantera "
"inläsning av alla dessa filtyper (utom delade bibliotek) från zip-filer."

msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"Sökvägsposter behöver inte vara begränsade till filsystemets platser.  De "
"kan hänvisa till webbadresser, databasfrågor eller andra platser som kan "
"anges som en sträng."

msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"Den sökvägsbaserade sökfunktionen tillhandahåller ytterligare krokar och "
"protokoll så att du kan utöka och anpassa typerna av sökbara sökvägsposter.  "
"Om du t.ex. vill stödja sökvägsposter som nätverks-URL:er kan du skriva en "
"krok som implementerar HTTP-semantik för att hitta moduler på webben.  Denna "
"krok (en anropsbar) skulle returnera en :term:`path entry finder` som stöder "
"det protokoll som beskrivs nedan, som sedan används för att hämta en laddare "
"för modulen från webben."

msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"Ett varningens ord: både i det här avsnittet och i det föregående används "
"termen *sökare*, och man skiljer mellan dem genom att använda termerna :term:"
"`meta path finder` och :term:`path entry finder`.  Dessa två typer av sökare "
"är mycket lika, stöder liknande protokoll och fungerar på liknande sätt "
"under importprocessen, men det är viktigt att komma ihåg att de är subtilt "
"olika. I synnerhet fungerar metasökvägssökare i början av importprocessen, "
"vilket framgår av :data:`sys.meta_path`-traversieringen."

msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"Däremot är sökvägssökare på sätt och vis en implementeringsdetalj av den "
"sökvägsbaserade sökaren, och om den sökvägsbaserade sökaren skulle tas bort "
"från :data:`sys.meta_path` skulle faktiskt ingen av sökvägssökarens semantik "
"åberopas."

msgid "Path entry finders"
msgstr "Sökare för banans ingång"

msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
":term:`path based finder` ansvarar för att hitta och ladda Python-moduler "
"och -paket vars plats anges med en sträng :term:`path entry`.  De flesta "
"sökvägsposter namnger platser i filsystemet, men de behöver inte vara "
"begränsade till detta."

msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"Som en metasökvägssökare implementerar :term:`path based finder` "
"protokollet :meth:`~importlib.abc.MetaPathFinder.find_spec` som beskrivits "
"tidigare, men den exponerar ytterligare krokar som kan användas för att "
"anpassa hur moduler hittas och laddas från :term:`import path`."

msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
"Tre variabler används av :term:`path based finder`, :data:`sys.path`, :data:"
"`sys.path_hooks` och :data:`sys.path_importer_cache`.  Attributen "
"``__path__`` på paketobjekt används också.  Dessa ger ytterligare sätt att "
"anpassa importmaskineriet."

msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :envvar:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings should be present on :data:`sys.path`; all "
"other data types are ignored."
msgstr ""
":data:`sys.path` innehåller en lista med strängar som anger sökplatser för "
"moduler och paket.  Den initieras från miljövariabeln :envvar:`PYTHONPATH` "
"och olika andra installations- och implementationsspecifika standardvärden.  "
"Posterna i :data:`sys.path` kan namnge kataloger i filsystemet, zip-filer "
"och eventuellt andra \"platser\" (se modulen :mod:`site`) som ska sökas "
"efter moduler, till exempel webbadresser eller databasfrågor.  Endast "
"strängar bör finnas i :data:`sys.path`; alla andra datatyper ignoreras."

msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
":term:`path based finder` är en :term:`meta path finder`, så "
"importmaskineriet börjar sökningen efter :term:`import path` genom att "
"anropa den sökvägsbaserade sökarens :meth:`~importlib.machinery.PathFinder."
"find_spec`-metod enligt beskrivningen ovan.  När argumentet ``path`` till :"
"meth:`~importlib.machinery.PathFinder.find_spec` ges, kommer det att vara en "
"lista med strängsökvägar att korsa - vanligtvis ett pakets ``__path__``-"
"attribut för en import inom det paketet.  Om argumentet ``path`` är "
"``None``, indikerar detta en import på toppnivå och :data:`sys.path` används."

msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be ``stat()`` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again."
msgstr ""
"Den sökvägsbaserade sökaren itererar över varje post i sökvägen och letar "
"för var och en av dessa efter en lämplig :term:`sökvägspostsökare` (:class:"
"`~importlib.abc.PathEntryFinder`) för sökvägsposten.  Eftersom detta kan "
"vara en dyr operation (t.ex. kan det finnas ``stat()``-anropskostnader för "
"denna sökning), upprätthåller den sökvägsbaserade sökaren en cache som "
"mappar sökvägsposter till sökvägspostsökare.  Den här cachen finns i :data:"
"`sys.path_importer_cache` (trots namnet lagrar den här cachen faktiskt "
"sökobjekt i stället för att vara begränsad till :term:`importer`-objekt). På "
"detta sätt behöver den dyra sökningen efter en viss :term:`path entry`-"
"plats :term:`path entry finder` bara göras en gång.  Det står användarkoden "
"fritt att ta bort cacheposter från :data:`sys.path_importer_cache`, vilket "
"tvingar den sökvägsbaserade sökaren att utföra sökningen efter sökvägsposter "
"igen."

msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"Om sökvägsposten inte finns i cacheminnet itererar den sökvägsbaserade "
"sökaren över alla anropbara filer i :data:`sys.path_hooks`.  Var och en av :"
"term:``path entry hooks <path entry hook>`` i denna lista anropas med ett "
"enda argument, sökvägsposten som ska sökas.  Denna anropsbarhet kan antingen "
"returnera en :term:`path entry finder` som kan hantera sökvägsposten, eller "
"så kan den ge upphov till :exc:`ImportError`.  En :exc:`ImportError` används "
"av den sökvägsbaserade sökaren för att signalera att kroken inte kan hitta "
"en :term:`path entry finder` för den :term:`path entry`.  Undantaget "
"ignoreras och :term:`import path` iterationen fortsätter.  Kroken bör "
"förvänta sig antingen en sträng eller ett bytesobjekt; kodningen av "
"bytesobjekt är upp till kroken (t.ex. kan det vara en filsystemkodning, "
"UTF-8 eller något annat), och om kroken inte kan avkoda argumentet bör den "
"höja :exc:`ImportError`."

msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
"Om :data:`sys.path_hooks` iteration slutar med att ingen :term:`path entry "
"finder` returneras, kommer den sökvägsbaserade sökarens :meth:`~importlib."
"machinery.PathFinder.find_spec` metod att lagra ``None`` i :data:`sys."
"path_importer_cache` (för att ange att det inte finns någon sökare för denna "
"sökvägspost) och returnera ``None``, vilket anger att denna :term:`meta path "
"finder` inte kunde hitta modulen."

msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
"Om en :term:`path entry finder` *returneras* av en av :term:`path entry "
"hook`-anropsobjekten på :data:`sys.path_hooks`, används följande protokoll "
"för att be sökaren om en modulspecifikation, som sedan används när modulen "
"laddas."

msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory cannot be determined or is found not to exist, no "
"value is stored in :data:`sys.path_importer_cache`. Second, the value for "
"the current working directory is looked up fresh for each module lookup. "
"Third, the path used for :data:`sys.path_importer_cache` and returned by :"
"meth:`importlib.machinery.PathFinder.find_spec` will be the actual current "
"working directory and not the empty string."
msgstr ""
"Den aktuella arbetskatalogen - som anges med en tom sträng - hanteras på ett "
"något annorlunda sätt än andra poster i :data:`sys.path`. För det första, om "
"den aktuella arbetskatalogen inte kan bestämmas eller inte existerar, lagras "
"inget värde i :data:`sys.path_importer_cache`. För det andra söks värdet för "
"den aktuella arbetskatalogen upp på nytt för varje moduluppslagning. För det "
"tredje kommer den sökväg som används för :data:`sys.path_importer_cache` och "
"som returneras av :meth:`importlib.machinery.PathFinder.find_spec` att vara "
"den aktuella arbetskatalogen och inte den tomma strängen."

msgid "Path entry finder protocol"
msgstr "Protokoll för sökning av sökväg"

msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"För att stödja import av moduler och initialiserade paket och även för att "
"bidra med delar till namnrymdspaket måste sökvägssökare implementera "
"metoden :meth:`~importlib.abc.PathEntryFinder.find_spec`."

msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` tar två argument: det "
"fullständigt kvalificerade namnet på den modul som importeras och (valfritt) "
"målmodulen.  ``find_spec()`` returnerar en fullständigt ifylld specifikation "
"för modulen. Denna specifikation kommer alltid att ha \"loader\" inställd "
"(med ett undantag)."

msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`, the path entry finder sets ``submodule_search_locations`` to "
"a list containing the portion."
msgstr ""
"För att ange för importmaskinen att specifikationen representerar en "
"namnrymd :term:`portion`, sätter sökvägssökaren "
"``submodule_search_locations`` till en lista som innehåller portionen."

msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`!"
"find_loader` and :meth:`!find_module`, both of which are now deprecated, but "
"will be used if ``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` ersatte :meth:`!"
"find_loader` och :meth:`!find_module`, som båda nu är föråldrade, men som "
"kommer att användas om ``find_spec()`` inte är definierad."

msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"Äldre sökare för sökvägsposter kan implementera en av dessa två föråldrade "
"metoder istället för ``find_spec()``.  Metoderna respekteras fortfarande för "
"bakåtkompatibilitetens skull.  Men om ``find_spec()`` implementeras på "
"sökvägssökaren ignoreras de äldre metoderna."

msgid ""
":meth:`!find_loader` takes one argument, the fully qualified name of the "
"module being imported.  ``find_loader()`` returns a 2-tuple where the first "
"item is the loader and the second item is a namespace :term:`portion`."
msgstr ""
":meth:`!find_loader` tar ett argument, det fullständigt kvalificerade namnet "
"på den modul som importeras.  ``find_loader()`` returnerar en 2-tupel där "
"det första objektet är laddaren och det andra objektet är en namnrymd :term:"
"`portion`."

msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"För bakåtkompatibilitet med andra implementationer av importprotokollet "
"stöder många sökvägssökare också samma traditionella ``find_module()``-metod "
"som metasökvägssökare stöder. Metoderna ``find_module()`` för sökvägssökare "
"anropas dock aldrig med ett ``path``-argument (de förväntas registrera "
"lämplig sökvägsinformation från det första anropet till sökvägskroken)."

msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"Metoden ``find_module()`` på sökvägssökare är avskriven, eftersom den inte "
"tillåter sökvägssökaren att bidra med delar till namnrymdspaket.  Om både "
"``find_loader()`` och ``find_module()`` finns på en sökvägssökare, kommer "
"importsystemet alltid att anropa ``find_loader()`` i stället för "
"``find_module()``."

msgid ""
"Calls to :meth:`!find_module` and :meth:`!find_loader` by the import system "
"will raise :exc:`ImportWarning`."
msgstr ""
"Anrop till :meth:`!find_module` och :meth:`!find_loader` av importsystemet "
"kommer att ge upphov till :exc:`ImportWarning`."

msgid "``find_module()`` and ``find_loader()`` have been removed."
msgstr "``find_module()`` och ``find_loader()`` har tagits bort."

msgid "Replacing the standard import system"
msgstr "Ersättande av standardimportsystemet"

msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"Den mest tillförlitliga mekanismen för att ersätta hela importsystemet är "
"att ta bort standardinnehållet i :data:`sys.meta_path` och ersätta det helt "
"med en anpassad metasökvägskrok."

msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"Om det är acceptabelt att bara ändra beteendet hos importmeddelanden utan "
"att påverka andra API:er som använder importsystemet, kan det räcka med att "
"ersätta den inbyggda funktionen :func:`__import__`. Denna teknik kan också "
"användas på modulnivå för att endast ändra beteendet hos importmeddelanden "
"inom den modulen."

msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""
"För att selektivt förhindra import av vissa moduler från en krok tidigt i "
"metasökvägen (i stället för att helt inaktivera standardimportsystemet) "
"räcker det att skapa :exc:`ModuleNotFoundError` direkt från :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` i stället för att returnera "
"``None``. Det senare anger att metasökvägssökningen ska fortsätta, medan ett "
"undantag avslutar den omedelbart."

msgid "Package Relative Imports"
msgstr "Paket Relativ import"

msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""
"Relativ import använder ledande prickar. En enda ledande punkt anger en "
"relativ import, med början i det aktuella paketet. Två eller fler ledande "
"punkter anger en relativ import till det aktuella paketets överordnade, en "
"nivå per punkt efter den första. Till exempel, med följande paketlayout::"

msgid ""
"package/\n"
"    __init__.py\n"
"    subpackage1/\n"
"        __init__.py\n"
"        moduleX.py\n"
"        moduleY.py\n"
"    subpackage2/\n"
"        __init__.py\n"
"        moduleZ.py\n"
"    moduleA.py"
msgstr ""
"paket/\n"
"    __init__.py\n"
"    underpaket1/\n"
"        __init__.py\n"
"        modulX.py\n"
"        modulY.py\n"
"    underpaket2/\n"
"        __init__.py\n"
"        modulZ.py\n"
"    modulA.py"

msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""
"I antingen ``subpackage1/moduleX.py`` eller ``subpackage1/__init__.py`` är "
"följande giltig relativ import::"

msgid ""
"from .moduleY import spam\n"
"from .moduleY import spam as ham\n"
"from . import moduleY\n"
"from ..subpackage1 import moduleY\n"
"from ..subpackage2.moduleZ import eggs\n"
"from ..moduleA import foo"
msgstr ""
"from .moduleY import spam\n"
"from .moduleY import spam as ham\n"
"from . import moduleY\n"
"from ..subpackage1 import moduleY\n"
"from ..subpackage2.moduleZ import eggs\n"
"from ..moduleA import foo"

msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr ""
"Absolut import kan använda antingen syntaxen ``import <>`` eller ``from <> "
"import <>``, men relativ import kan bara använda den andra formen; "
"anledningen till detta är att::"

msgid "import XXX.YYY.ZZZ"
msgstr "import XXX.YYY.ZZZ"

msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr ""
"bör exponera ``XXX.YYY.ZZZ`` som ett användbart uttryck, men .moduleY är "
"inte ett giltigt uttryck."

msgid "Special considerations for __main__"
msgstr "Särskilda överväganden för __main__"

msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
"Modulen :mod:`__main__` är ett specialfall i förhållande till Pythons "
"importsystem.  Som nämnts :ref:``annanstans <programs>``, initialiseras "
"``__main__``-modulen direkt vid tolkens start, ungefär som :mod:`sys` och :"
"mod:`builtins`.  Men till skillnad från dessa två kvalificerar den sig inte "
"riktigt som en inbyggd modul.  Detta beror på att det sätt på vilket "
"``__main__`` initialiseras beror på de flaggor och andra alternativ som "
"tolken anropas med."

msgid "__main__.__spec__"
msgstr "__main__.__spec__"

msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
"Beroende på hur :mod:`__main__` initieras kommer ``__main__.__spec__`` att "
"ställas in på lämpligt sätt eller till ``None``."

msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"När Python startas med :option:`-m`-alternativet, sätts ``__spec__`` till "
"modulspecifikationen för motsvarande modul eller paket. ``__spec__`` fylls "
"också i när modulen ``__main__`` laddas som en del av exekveringen av en "
"katalog, zipfil eller annan :data:`sys.path`-post."

msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
"I :ref:`de återstående fallen <using-on-interface-options>```__main__."
"__spec__`` sätts till ``None``, eftersom den kod som används för att fylla "
"i :mod:`__main__` inte direkt motsvarar en importerbar modul:"

msgid "interactive prompt"
msgstr "interaktiv prompt"

msgid ":option:`-c` option"
msgstr ":option:`-c` option"

msgid "running from stdin"
msgstr "körs från stdin"

msgid "running directly from a source or bytecode file"
msgstr "körs direkt från en käll- eller bytecode-fil"

msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"Observera att ``__main__.__spec__`` alltid är ``None`` i det sista fallet, "
"*även om* filen tekniskt sett skulle kunna importeras direkt som en modul "
"istället. Använd :option:`-m` om giltiga metadata för moduler önskas i :mod:"
"`__main__`."

msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"Observera också att även när ``__main__`` motsvarar en importerbar modul och "
"``__main__.__spec__`` är inställd i enlighet med detta, betraktas de "
"fortfarande som *skilda* moduler. Detta beror på att block som skyddas av "
"``if __name__ == \"__main__\":`` kontroller endast exekveras när modulen "
"används för att fylla på ``main__`` namnrymden, och inte under normal import."

msgid "References"
msgstr "Referenser"

msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"Importmaskineriet har utvecklats avsevärt sedan Pythons tidiga dagar.  Den "
"ursprungliga `specifikationen för paket <https://www.python.org/doc/essays/"
"packages/>`_ är fortfarande tillgänglig att läsa, även om vissa detaljer har "
"ändrats sedan det dokumentet skrevs."

msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"Den ursprungliga specifikationen för :data:`sys.meta_path` var :pep:`302`, "
"med senare tillägg i :pep:`420`."

msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`!find_loader` protocol as "
"an alternative to :meth:`!find_module`."
msgstr ""
":pep:`420` introducerade :term:`namespace packages <namespace package>` för "
"Python 3.3. :pep:`420` introducerade även protokollet :meth:`!find_loader` "
"som ett alternativ till :meth:`!find_module`."

msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` beskriver tillägget av attributet ``__package__`` för explicit "
"relativ import i huvudmoduler."

msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` införde absolut och explicit relativ import och föreslog "
"ursprungligen ``__name__`` för semantiken som :pep:`366` så småningom skulle "
"specificera för ``__package__``."

msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` definierar exekverande moduler som skript."

msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` lägger till inkapsling av importstatus per modul i spec-objekt.  "
"Det avlastar också de flesta av de standardiserade ansvarsområdena för "
"laddare tillbaka till importmaskineriet.  Dessa ändringar gör det möjligt "
"att avskaffa flera API:er i importsystemet och även lägga till nya metoder "
"för sökare och laddare."

msgid "Footnotes"
msgstr "Fotnoter"

msgid "See :class:`types.ModuleType`."
msgstr "Se :class:`types.ModuleType`."

msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"Importlib-implementeringen undviker att använda returvärdet direkt. I "
"stället hämtas modulobjektet genom att modulnamnet söks upp i :data:`sys."
"modules`.  Den indirekta effekten av detta är att en importerad modul kan "
"ersätta sig själv i :data:`sys.modules`.  Detta är ett "
"implementationsspecifikt beteende som inte garanteras fungera i andra Python-"
"implementationer."

msgid "import machinery"
msgstr "importera maskiner"

msgid "package"
msgstr "paket"

msgid "regular"
msgstr "regular"

msgid "namespace"
msgstr "namnrymd"

msgid "portion"
msgstr "del"

msgid "sys.modules"
msgstr "sys.modules"

msgid "finder"
msgstr "sökare"

msgid "loader"
msgstr "lastare"

msgid "module spec"
msgstr "modulspecifikation"

msgid "import hooks"
msgstr "import hooks"

msgid "meta hooks"
msgstr "meta hooks"

msgid "path hooks"
msgstr "path hooks"

msgid "hooks"
msgstr "hooks"

msgid "import"
msgstr "importera"

msgid "meta"
msgstr "meta"

msgid "path"
msgstr "väg"

msgid "sys.meta_path"
msgstr "sys.meta_ sökväg"

msgid "find_spec"
msgstr "find_spec"

msgid "path based finder"
msgstr "sökvägsbaserad sökare"

msgid "sys.path"
msgstr "sys.path"

msgid "sys.path_hooks"
msgstr "sys.path_hooks"

msgid "sys.path_importer_cache"
msgstr "sys.path_importer_cache"

msgid "PYTHONPATH"
msgstr "PYTHONPATH"
