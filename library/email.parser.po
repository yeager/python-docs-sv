# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!email.parser`: Parsing email messages"
msgstr ":mod:`!email.parser`: Parsning av e-postmeddelanden"

msgid "**Source code:** :source:`Lib/email/parser.py`"
msgstr "**Källkod:** :source:`Lib/email/parser.py`"

msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by creating an :class:`~email.message.EmailMessage` "
"object, adding headers using the dictionary interface, and adding payload(s) "
"using :meth:`~email.message.EmailMessage.set_content` and related methods, "
"or they can be created by parsing a serialized representation of the email "
"message."
msgstr ""
"Objektstrukturer för meddelanden kan skapas på två sätt: de kan skapas helt "
"från början genom att skapa ett :class:`~email.message.EmailMessage`-objekt, "
"lägga till rubriker med hjälp av dictionary-gränssnittet och lägga till "
"nyttolast(er) med hjälp av :meth:`~email.message.EmailMessage.set_content` "
"och relaterade metoder, eller så kan de skapas genom att parsa en "
"serialiserad representation av e-postmeddelandet."

msgid ""
"The :mod:`email` package provides a standard parser that understands most "
"email document structures, including MIME documents.  You can pass the "
"parser a bytes, string or file object, and the parser will return to you the "
"root :class:`~email.message.EmailMessage` instance of the object structure.  "
"For simple, non-MIME messages the payload of this root object will likely be "
"a string containing the text of the message.  For MIME messages, the root "
"object will return ``True`` from its :meth:`~email.message.EmailMessage."
"is_multipart` method, and the subparts can be accessed via the payload "
"manipulation methods, such as :meth:`~email.message.EmailMessage.get_body`, :"
"meth:`~email.message.EmailMessage.iter_parts`, and :meth:`~email.message."
"EmailMessage.walk`."
msgstr ""
"Paketet :mod:`email` tillhandahåller en standardparser som förstår de flesta "
"e-postdokumentstrukturer, inklusive MIME-dokument.  Du kan skicka ett "
"bytes-, sträng- eller filobjekt till parsern, som returnerar rotobjektet :"
"class:`~email.message.EmailMessage` i objektstrukturen.  För enkla icke-MIME-"
"meddelanden kommer nyttolasten för detta rotobjekt sannolikt att vara en "
"sträng som innehåller texten i meddelandet.  För MIME-meddelanden returnerar "
"rotobjektet ``True`` från sin metod :meth:`~email.message.EmailMessage."
"is_multipart`, och underdelarna kan nås via metoderna för manipulering av "
"nyttolasten, t.ex. :meth:`~email.message.EmailMessage.get_body`, :meth:"
"`~email.message.EmailMessage.iter_parts` och :meth:`~email.message."
"EmailMessage.walk`."

msgid ""
"There are actually two parser interfaces available for use, the :class:"
"`Parser` API and the incremental :class:`FeedParser` API.  The :class:"
"`Parser` API is most useful if you have the entire text of the message in "
"memory, or if the entire message lives in a file on the file system.  :class:"
"`FeedParser` is more appropriate when you are reading the message from a "
"stream which might block waiting for more input (such as reading an email "
"message from a socket).  The :class:`FeedParser` can consume and parse the "
"message incrementally, and only returns the root object when you close the "
"parser."
msgstr ""
"Det finns faktiskt två parsergränssnitt tillgängliga för användning, :class:"
"`Parser` API och det inkrementella :class:`FeedParser` API.  API:et :class:"
"`Parser` är mest användbart om du har hela texten i meddelandet i minnet, "
"eller om hela meddelandet finns i en fil i filsystemet. API:et :class:"
"`FeedParser` är mer lämpligt när du läser meddelandet från en ström som kan "
"blockeras i väntan på mer indata (t.ex. när du läser ett e-postmeddelande "
"från en socket).  :class:`FeedParser` kan konsumera och analysera "
"meddelandet stegvis och returnerar rotobjektet först när du stänger parsern."

msgid ""
"Note that the parser can be extended in limited ways, and of course you can "
"implement your own parser completely from scratch.  All of the logic that "
"connects the :mod:`email` package's bundled parser and the :class:`~email."
"message.EmailMessage` class is embodied in the :class:`~email.policy.Policy` "
"class, so a custom parser can create message object trees any way it finds "
"necessary by implementing custom versions of the appropriate :class:`!"
"Policy` methods."
msgstr ""
"Observera att parsern kan utökas på begränsade sätt, och naturligtvis kan du "
"implementera din egen parser helt från grunden.  All logik som kopplar "
"samman :mod:`email`-paketets medföljande parser och :class:`~email.message."
"EmailMessage`-klassen finns i :class:`~email.policy.Policy`-klassen, så en "
"anpassad parser kan skapa träd av meddelandeobjekt på det sätt som den "
"finner nödvändigt genom att implementera anpassade versioner av lämpliga :"
"class:`!Policy`-metoder."

msgid "FeedParser API"
msgstr "FeedParser API"

msgid ""
"The :class:`BytesFeedParser`, imported from the :mod:`email.feedparser` "
"module, provides an API that is conducive to incremental parsing of email "
"messages, such as would be necessary when reading the text of an email "
"message from a source that can block (such as a socket).  The :class:"
"`BytesFeedParser` can of course be used to parse an email message fully "
"contained in a :term:`bytes-like object`, string, or file, but the :class:"
"`BytesParser` API may be more convenient for such use cases.  The semantics "
"and results of the two parser APIs are identical."
msgstr ""
":class:`BytesFeedParser`, som importeras från modulen :mod:`email."
"feedparser`, tillhandahåller ett API som är lämpligt för stegvis analys av e-"
"postmeddelanden, t.ex. när man läser texten i ett e-postmeddelande från en "
"källa som kan blockeras (t.ex. en socket).  API:t :class:`BytesFeedParser` "
"kan naturligtvis användas för att analysera ett e-postmeddelande som helt "
"och hållet finns i ett :term:`bytesliknande objekt`, en sträng eller en fil, "
"men API:t :class:`BytesParser` kan vara mer praktiskt för sådana "
"användningsfall.  Semantiken och resultaten för de två parser-API:erna är "
"identiska."

msgid ""
"The :class:`BytesFeedParser`'s API is simple; you create an instance, feed "
"it a bunch of bytes until there's no more to feed it, then close the parser "
"to retrieve the root message object.  The :class:`BytesFeedParser` is "
"extremely accurate when parsing standards-compliant messages, and it does a "
"very good job of parsing non-compliant messages, providing information about "
"how a message was deemed broken.  It will populate a message object's :attr:"
"`~email.message.EmailMessage.defects` attribute with a list of any problems "
"it found in a message.  See the :mod:`email.errors` module for the list of "
"defects that it can find."
msgstr ""
"API:et för :class:`BytesFeedParser` är enkelt; du skapar en instans, matar "
"den med en massa bytes tills det inte finns mer att mata den med och stänger "
"sedan parsern för att hämta rotmeddelandeobjektet.  :class:`BytesFeedParser` "
"är extremt exakt när den analyserar meddelanden som följer standarder, och "
"den gör ett mycket bra jobb med att analysera meddelanden som inte följer "
"standarder, och ger information om hur ett meddelande ansågs vara trasigt.  "
"Den kommer att fylla ett meddelandeobjekts :attr:`~email.message."
"EmailMessage.defects`-attribut med en lista över alla problem som den "
"hittade i ett meddelande.  Se modulen :mod:`email.errors` för en lista över "
"defekter som den kan hitta."

msgid "Here is the API for the :class:`BytesFeedParser`:"
msgstr "Här är API:et för :class:`BytesFeedParser`:"

msgid ""
"Create a :class:`BytesFeedParser` instance.  Optional *_factory* is a no-"
"argument callable; if not specified use the :attr:`~email.policy.Policy."
"message_factory` from the *policy*.  Call *_factory* whenever a new message "
"object is needed."
msgstr ""
"Skapa en instans av :class:`BytesFeedParser`.  Valfri *_factory* är en "
"anropsbar utan argument; om den inte anges används :attr:`~email.policy."
"Policy.message_factory` från *policy*.  Anropa *_factory* när ett nytt "
"meddelandeobjekt behövs."

msgid ""
"If *policy* is specified use the rules it specifies to update the "
"representation of the message.  If *policy* is not set, use the :class:"
"`compat32 <email.policy.Compat32>` policy, which maintains backward "
"compatibility with the Python 3.2 version of the email package and provides :"
"class:`~email.message.Message` as the default factory.  All other policies "
"provide :class:`~email.message.EmailMessage` as the default *_factory*. For "
"more information on what else *policy* controls, see the :mod:`~email."
"policy` documentation."
msgstr ""
"Om *policy* anges används de regler som anges för att uppdatera "
"representationen av meddelandet.  Om *policy* inte anges, använd policyn :"
"class:`compat32 <email.policy.Compat32>`, som upprätthåller "
"bakåtkompatibilitet med Python 3.2-versionen av e-postpaketet och "
"tillhandahåller :class:`~email.message.Message` som standardfabrik.  Alla "
"andra policyer tillhandahåller :class:`~email.message.EmailMessage` som "
"standard *_factory*. Mer information om vad mer *policy* kontrollerar finns "
"i dokumentationen för :mod:`~email.policy`."

msgid ""
"Note: **The policy keyword should always be specified**; The default will "
"change to :data:`email.policy.default` in a future version of Python."
msgstr ""
"Obs: ** Nyckelordet policy ska alltid anges**; Standardvärdet kommer att "
"ändras till :data:`email.policy.default` i en framtida version av Python."

msgid "Added the *policy* keyword."
msgstr "Nyckelordet *policy* har lagts till."

msgid "*_factory* defaults to the policy ``message_factory``."
msgstr "*_factory* Standardvärdet är policyn ``message_factory``."

msgid ""
"Feed the parser some more data.  *data* should be a :term:`bytes-like "
"object` containing one or more lines.  The lines can be partial and the "
"parser will stitch such partial lines together properly.  The lines can have "
"any of the three common line endings: carriage return, newline, or carriage "
"return and newline (they can even be mixed)."
msgstr ""
"Mata parsern med mer data.  *data* bör vara ett :term:`bytesliknande objekt` "
"som innehåller en eller flera rader.  Raderna kan vara partiella och parsern "
"kommer att sy ihop sådana partiella rader på rätt sätt.  Raderna kan ha "
"någon av de tre vanliga radavslutningarna: vagnsretur, ny rad eller "
"vagnsretur och ny rad (de kan även blandas)."

msgid ""
"Complete the parsing of all previously fed data and return the root message "
"object.  It is undefined what happens if :meth:`~feed` is called after this "
"method has been called."
msgstr ""
"Slutför parsningen av all tidigare matad data och returnerar "
"rotmeddelandeobjektet.  Det är odefinierat vad som händer om :meth:`~feed` "
"anropas efter att denna metod har anropats."

msgid ""
"Works like :class:`BytesFeedParser` except that the input to the :meth:"
"`~BytesFeedParser.feed` method must be a string.  This is of limited "
"utility, since the only way for such a message to be valid is for it to "
"contain only ASCII text or, if :attr:`~email.policy.EmailPolicy.utf8` is "
"``True``, no binary attachments."
msgstr ""
"Fungerar som :class:`BytesFeedParser` förutom att indata till :meth:"
"`~BytesFeedParser.feed`-metoden måste vara en sträng.  Detta är av begränsad "
"nytta, eftersom det enda sättet för ett sådant meddelande att vara giltigt "
"är att det endast innehåller ASCII-text eller, om :attr:`~email.policy."
"EmailPolicy.utf8` är ``True``, inga binära bilagor."

msgid "Parser API"
msgstr "Parser API"

msgid ""
"The :class:`BytesParser` class, imported from the :mod:`email.parser` "
"module, provides an API that can be used to parse a message when the "
"complete contents of the message are available in a :term:`bytes-like "
"object` or file.  The :mod:`email.parser` module also provides :class:"
"`Parser` for parsing strings, and header-only parsers, :class:"
"`BytesHeaderParser` and :class:`HeaderParser`, which can be used if you're "
"only interested in the headers of the message.  :class:`BytesHeaderParser` "
"and :class:`HeaderParser` can be much faster in these situations, since they "
"do not attempt to parse the message body, instead setting the payload to the "
"raw body."
msgstr ""
"Klassen :class:`BytesParser`, importerad från modulen :mod:`email.parser`, "
"tillhandahåller ett API som kan användas för att analysera ett meddelande "
"när det fullständiga innehållet i meddelandet finns tillgängligt i ett :term:"
"`bytesliknande objekt` eller en fil.  Modulen :mod:`email.parser` "
"tillhandahåller även :class:`Parser` för att analysera strängar och "
"analysatorer för enbart rubriker, :class:`BytesHeaderParser` och :class:"
"`HeaderParser`, som kan användas om du bara är intresserad av meddelandets "
"rubriker.  :class:`BytesHeaderParser` och :class:`HeaderParser` kan vara "
"mycket snabbare i dessa situationer, eftersom de inte försöker analysera "
"meddelandetexten, utan istället sätter nyttolasten till den råa texten."

msgid ""
"Create a :class:`BytesParser` instance.  The *_class* and *policy* arguments "
"have the same meaning and semantics as the *_factory* and *policy* arguments "
"of :class:`BytesFeedParser`."
msgstr ""
"Skapa en instans av :class:`BytesParser`.  Argumenten *_class* och *policy* "
"har samma betydelse och semantik som argumenten *_factory* och *policy* i :"
"class:`BytesFeedParser`."

msgid ""
"Removed the *strict* argument that was deprecated in 2.4.  Added the "
"*policy* keyword."
msgstr ""
"Tog bort argumentet *strict* som inte längre användes i 2.4.  Nyckelordet "
"*policy* har lagts till."

msgid "*_class* defaults to the policy ``message_factory``."
msgstr "*_class* Standardvärdet är policyn ``message_factory``."

msgid ""
"Read all the data from the binary file-like object *fp*, parse the resulting "
"bytes, and return the message object.  *fp* must support both the :meth:`~io."
"IOBase.readline` and the :meth:`~io.IOBase.read` methods."
msgstr ""
"Läser alla data från det binära filliknande objektet *fp*, analyserar de "
"resulterande byte och returnerar meddelandeobjektet.  *fp* måste stödja både "
"metoderna :meth:`~io.IOBase.readline` och :meth:`~io.IOBase.read`."

msgid ""
"The bytes contained in *fp* must be formatted as a block of :rfc:`5322` (or, "
"if :attr:`~email.policy.EmailPolicy.utf8` is ``True``, :rfc:`6532`) style "
"headers and header continuation lines, optionally preceded by an envelope "
"header.  The header block is terminated either by the end of the data or by "
"a blank line.  Following the header block is the body of the message (which "
"may contain MIME-encoded subparts, including subparts with a :mailheader:"
"`Content-Transfer-Encoding` of ``8bit``)."
msgstr ""
"Bytesen i *fp* måste formateras som ett block med rubriker och "
"fortsättningsrader av typen :rfc:`5322` (eller, om :attr:`~email.policy."
"EmailPolicy.utf8` är ``True``, :rfc:`6532`), eventuellt föregånget av ett "
"kuverthuvud.  Huvudblocket avslutas antingen med slutet av datan eller med "
"en blank rad.  Efter huvudblocket följer meddelandetexten (som kan innehålla "
"MIME-kodade underdelar, inklusive underdelar med en :mailheader:`Content-"
"Transfer-Encoding` på ``8bit``)."

msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after "
"reading the headers or not.  The default is ``False``, meaning it parses the "
"entire contents of the file."
msgstr ""
"Valfritt *headersonly* är en flagga som anger om parsningen ska avbrytas "
"efter att rubrikerna har lästs eller inte.  Standardvärdet är ``False``, "
"vilket innebär att hela filens innehåll analyseras."

msgid ""
"Similar to the :meth:`parse` method, except it takes a :term:`bytes-like "
"object` instead of a file-like object.  Calling this method on a :term:"
"`bytes-like object` is equivalent to wrapping *bytes* in a :class:`~io."
"BytesIO` instance first and calling :meth:`parse`."
msgstr ""
"Liknar metoden :meth:`parse`, förutom att den tar ett :term:`bytesliknande "
"objekt` istället för ett filliknande objekt.  Att anropa denna metod på ett :"
"term:`bytesliknande objekt` är likvärdigt med att först packa in *bytes* i "
"en :class:`~io.BytesIO`-instans och sedan anropa :meth:`parse`."

msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr "Valfritt *headersonly* är som med metoden :meth:`parse`."

msgid ""
"Exactly like :class:`BytesParser`, except that *headersonly* defaults to "
"``True``."
msgstr ""
"Exakt som :class:`BytesParser`, förutom att *headersonly* som standard är "
"``True``."

msgid ""
"This class is parallel to :class:`BytesParser`, but handles string input."
msgstr ""
"Denna klass är parallell med :class:`BytesParser`, men hanterar "
"stränginmatning."

msgid "Removed the *strict* argument.  Added the *policy* keyword."
msgstr ""
"Argumentet *strict* har tagits bort.  Nyckelordet *policy* har lagts till."

msgid ""
"Read all the data from the text-mode file-like object *fp*, parse the "
"resulting text, and return the root message object.  *fp* must support both "
"the :meth:`~io.TextIOBase.readline` and the :meth:`~io.TextIOBase.read` "
"methods on file-like objects."
msgstr ""
"Läser alla data från det filliknande objektet *fp* i textläge, tolkar den "
"resulterande texten och returnerar rotmeddelandeobjektet.  *fp* måste stödja "
"både metoderna :meth:`~io.TextIOBase.readline` och :meth:`~io.TextIOBase."
"read` för filliknande objekt."

msgid ""
"Other than the text mode requirement, this method operates like :meth:"
"`BytesParser.parse`."
msgstr ""
"Bortsett från kravet på textläge fungerar den här metoden som :meth:"
"`BytesParser.parse`."

msgid ""
"Similar to the :meth:`parse` method, except it takes a string object instead "
"of a file-like object.  Calling this method on a string is equivalent to "
"wrapping *text* in a :class:`~io.StringIO` instance first and calling :meth:"
"`parse`."
msgstr ""
"Liknar metoden :meth:`parse`, förutom att den tar ett strängobjekt istället "
"för ett filliknande objekt.  Att anropa denna metod på en sträng motsvarar "
"att först packa in *text* i en :class:`~io.StringIO`-instans och sedan "
"anropa :meth:`parse`."

msgid ""
"Exactly like :class:`Parser`, except that *headersonly* defaults to ``True``."
msgstr ""
"Exakt som :class:`Parser`, förutom att *headersonly* har standardvärdet "
"``True``."

msgid ""
"Since creating a message object structure from a string or a file object is "
"such a common task, four functions are provided as a convenience.  They are "
"available in the top-level :mod:`email` package namespace."
msgstr ""
"Eftersom det är en vanlig uppgift att skapa en meddelandeobjektstruktur från "
"en sträng eller ett filobjekt, finns det fyra funktioner som en "
"bekvämlighet.  De är tillgängliga i toppnivån :mod:`email` package namespace."

msgid ""
"Return a message object structure from a :term:`bytes-like object`.  This is "
"equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Returnerar en meddelandeobjektstruktur från ett :term:`bytesliknande "
"objekt`.  Detta är likvärdigt med ``BytesParser().parsebytes(s)``.  Valfria "
"*_class* och *policy* tolkas som med :class:`~email.parser.BytesParser` "
"klasskonstruktören."

msgid ""
"Return a message object structure tree from an open binary :term:`file "
"object`.  This is equivalent to ``BytesParser().parse(fp)``.  *_class* and "
"*policy* are interpreted as with the :class:`~email.parser.BytesParser` "
"class constructor."
msgstr ""
"Returnerar ett strukturträd för meddelandeobjekt från ett öppet binärt :term:"
"`filobjekt`.  Detta är likvärdigt med ``BytesParser().parse(fp)``.  *_class* "
"och *policy* tolkas som med :class:`~email.parser.BytesParser` "
"klasskonstruktören."

msgid ""
"Return a message object structure from a string.  This is equivalent to "
"``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as with "
"the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Returnerar en meddelandeobjektstruktur från en sträng.  Detta är likvärdigt "
"med ``Parser().parsestr(s)``.  *_class* och *policy* tolkas som med :class:"
"`~email.parser.Parser`-klassens konstruktör."

msgid ""
"Return a message object structure tree from an open :term:`file object`. "
"This is equivalent to ``Parser().parse(fp)``.  *_class* and *policy* are "
"interpreted as with the :class:`~email.parser.Parser` class constructor."
msgstr ""
"Returnerar ett strukturträd för meddelandeobjekt från ett öppet :term:"
"`filobjekt`. Detta är likvärdigt med ``Parser().parse(fp)``.  *_class* och "
"*policy* tolkas som med :class:`~email.parser.Parser` klasskonstruktören."

msgid ""
"Here's an example of how you might use :func:`message_from_bytes` at an "
"interactive Python prompt::"
msgstr ""
"Här är ett exempel på hur du kan använda :func:`message_from_bytes` i en "
"interaktiv Python-prompt::"

msgid ""
">>> import email\n"
">>> msg = email.message_from_bytes(myBytes)"
msgstr ""
">>> import e-post\n"
">>> msg = email.message_from_bytes(myBytes)"

msgid "Additional notes"
msgstr "Ytterligare anmärkningar"

msgid "Here are some notes on the parsing semantics:"
msgstr "Här följer några kommentarer om semantiken i parsningen:"

msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return ``False`` "
"for :meth:`~email.message.EmailMessage.is_multipart`, and :meth:`~email."
"message.EmailMessage.iter_parts` will yield an empty list."
msgstr ""
"De flesta meddelanden av typen :mimetype:`multipart` som inte är av typen :"
"mimetype:`multipart` analyseras som ett enda meddelandeobjekt med en sträng "
"som nyttolast.  Dessa objekt kommer att returnera ``False`` för :meth:"
"`~email.message.EmailMessage.is_multipart`, och :meth:`~email.message."
"EmailMessage.iter_parts` kommer att ge en tom lista."

msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The "
"outer container message will return ``True`` for :meth:`~email.message."
"EmailMessage.is_multipart`, and :meth:`~email.message.EmailMessage."
"iter_parts` will yield a list of subparts."
msgstr ""
"Alla meddelanden av typen :mimetype:`multipart` tolkas som ett "
"containermeddelandeobjekt med en lista över undermeddelandeobjekt för "
"nyttolasten.  Det yttre containermeddelandet returnerar ``True`` för :meth:"
"`~email.message.EmailMessage.is_multipart`, och :meth:`~email.message."
"EmailMessage.iter_parts` ger en lista med underdelar."

msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (such as :"
"mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will also "
"be parsed as container object containing a list payload of length 1.  Their :"
"meth:`~email.message.EmailMessage.is_multipart` method will return ``True``. "
"The single element yielded by :meth:`~email.message.EmailMessage.iter_parts` "
"will be a sub-message object."
msgstr ""
"De flesta meddelanden med innehållstypen :mimetype:`message/\\*` (t.ex. :"
"mimetype:`message/delivery-status` och :mimetype:`message/rfc822`) kommer "
"också att analyseras som containerobjekt som innehåller en list payload av "
"längd 1. Deras metod :meth:`~email.message.EmailMessage.is_multipart` kommer "
"att returnera ``True``. Det enskilda element som erhålls genom :meth:`~email."
"message.EmailMessage.iter_parts` kommer att vara ett undermeddelandeobjekt."

msgid ""
"Some non-standards-compliant messages may not be internally consistent about "
"their :mimetype:`multipart`\\ -edness.  Such messages may have a :mailheader:"
"`Content-Type` header of type :mimetype:`multipart`, but their :meth:`~email."
"message.EmailMessage.is_multipart` method may return ``False``. If such "
"messages were parsed with the :class:`~email.parser.FeedParser`, they will "
"have an instance of the :class:`~email.errors."
"MultipartInvariantViolationDefect` class in their *defects* attribute list.  "
"See :mod:`email.errors` for details."
msgstr ""
"Vissa meddelanden som inte följer standarderna kanske inte är internt "
"konsekventa när det gäller deras :mimetype:`multipart`-edness.  Sådana "
"meddelanden kan ha en :mailheader:`Content-Type` header av typen :mimetype:"
"`multipart`, men deras :meth:`~email.message.EmailMessage.is_multipart` "
"metod kan returnera ``False``. Om sådana meddelanden analyserades med :class:"
"`~email.parser.FeedParser`, kommer de att ha en instans av :class:`~email."
"errors.MultipartInvariantViolationDefect`-klassen i sin *defects*-"
"attributlista.  Se :mod:`email.errors` för detaljer."
