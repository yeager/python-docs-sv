# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!math` --- Mathematical functions"
msgstr ":mod:`!math` --- Matematiska funktioner"

msgid ""
"This module provides access to common mathematical functions and constants, "
"including those defined by the C standard."
msgstr ""
"Denna modul ger tillgång till vanliga matematiska funktioner och konstanter, "
"inklusive de som definieras av C-standarden."

msgid ""
"These functions cannot be used with complex numbers; use the functions of "
"the same name from the :mod:`cmath` module if you require support for "
"complex numbers.  The distinction between functions which support complex "
"numbers and those which don't is made since most users do not want to learn "
"quite as much mathematics as required to understand complex numbers.  "
"Receiving an exception instead of a complex result allows earlier detection "
"of the unexpected complex number used as a parameter, so that the programmer "
"can determine how and why it was generated in the first place."
msgstr ""
"Dessa funktioner kan inte användas med komplexa tal; använd funktionerna med "
"samma namn från modulen :mod:`cmath` om du behöver stöd för komplexa tal.  "
"Distinktionen mellan funktioner som stöder komplexa tal och de som inte gör "
"det görs eftersom de flesta användare inte vill lära sig så mycket matematik "
"som krävs för att förstå komplexa tal.  Om man får ett undantag i stället "
"för ett komplext resultat kan man tidigare upptäcka det oväntade komplexa "
"talet som används som parameter, så att programmeraren kan avgöra hur och "
"varför det genererades från första början."

msgid ""
"The following functions are provided by this module.  Except when explicitly "
"noted otherwise, all return values are floats."
msgstr ""
"Följande funktioner tillhandahålls av denna modul.  Om inte annat "
"uttryckligen anges är alla returvärden flyttal."

msgid "**Number-theoretic functions**"
msgstr "**Numerteoretiska funktioner**"

msgid ":func:`comb(n, k) <comb>`"
msgstr ":func:`comb(n, k) <comb>`"

msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"without order"
msgstr ""
"Antal sätt att välja *k* artiklar från *n* artiklar utan upprepning och utan "
"ordning"

msgid ":func:`factorial(n) <factorial>`"
msgstr ":func:`factorial(n) <factorial>`"

msgid "*n* factorial"
msgstr "*n* faktoriell"

msgid ":func:`gcd(*integers) <gcd>`"
msgstr ":func:`gcd(*integers) <gcd>`"

msgid "Greatest common divisor of the integer arguments"
msgstr "Största gemensamma divisor av heltalsargumenten"

msgid ":func:`isqrt(n) <isqrt>`"
msgstr ":func:`isqrt(n) <isqrt>`"

msgid "Integer square root of a nonnegative integer *n*"
msgstr "Integer kvadratrot av ett icke-negativt heltal *n*"

msgid ":func:`lcm(*integers) <lcm>`"
msgstr ":func:`lcm(*integers) <lcm>`"

msgid "Least common multiple of the integer arguments"
msgstr "Minsta gemensamma multipel av heltalsargumenten"

msgid ":func:`perm(n, k) <perm>`"
msgstr ":func:`perm(n, k) <perm>`"

msgid ""
"Number of ways to choose *k* items from *n* items without repetition and "
"with order"
msgstr ""
"Antal sätt att välja *k* artiklar från *n* artiklar utan upprepning och med "
"ordning"

msgid "**Floating point arithmetic**"
msgstr "**Aritmetik med flyttal**"

msgid ":func:`ceil(x) <ceil>`"
msgstr ":func:`ceil(x) <ceil>`"

msgid "Ceiling of *x*, the smallest integer greater than or equal to *x*"
msgstr "Tak för *x*, det minsta heltal som är större än eller lika med *x*"

msgid ":func:`fabs(x) <fabs>`"
msgstr ":func:`fabs(x) <fabs>`"

msgid "Absolute value of *x*"
msgstr "Absolut värde av *x*"

msgid ":func:`floor(x)  <floor>`"
msgstr ":func:`floor(x) <floor>`"

msgid "Floor of *x*, the largest integer less than or equal to *x*"
msgstr "Golv av *x*, det största heltalet mindre än eller lika med *x*"

msgid ":func:`fma(x, y, z) <fma>`"
msgstr ":func:`fma(x, y, z) <fma>`"

msgid "Fused multiply-add operation: ``(x * y) + z``"
msgstr "Kombinerad multiplicera-add-operation: ``(x * y) + z``"

msgid ":func:`fmod(x, y) <fmod>`"
msgstr ":func:`fmod(x, y) <fmod>`"

msgid "Remainder of division ``x / y``"
msgstr "Resterande del av divisionen ``x / y``"

msgid ":func:`modf(x) <modf>`"
msgstr ":func:`modf(x) <modf>`"

msgid "Fractional and integer parts of *x*"
msgstr "Bråkdelar och heltalsdelar av *x*"

msgid ":func:`remainder(x, y) <remainder>`"
msgstr ":func:`remainder(x, y) <remainder>`"

msgid "Remainder of *x* with respect to *y*"
msgstr "Resterande del av *x* i förhållande till *y*"

msgid ":func:`trunc(x) <trunc>`"
msgstr ":func:`trunc(x) <trunc>`"

msgid "Integer part of *x*"
msgstr "Heltalsdel av *x*"

msgid "**Floating point manipulation functions**"
msgstr "**Funktioner för manipulation av flyttal**"

msgid ":func:`copysign(x, y) <copysign>`"
msgstr ":func:`copysign(x, y) <copysign>`"

msgid "Magnitude (absolute value) of *x* with the sign of *y*"
msgstr "Magnituden (absolutvärdet) av *x* med tecknet för *y*"

msgid ":func:`frexp(x) <frexp>`"
msgstr ":func:`frexp(x) <frexp>`"

msgid "Mantissa and exponent of *x*"
msgstr "Mantissa och exponent för *x*"

msgid ":func:`isclose(a, b, rel_tol, abs_tol) <isclose>`"
msgstr ":func:`isclose(a, b, rel_tol, abs_tol) <isclose>`"

msgid "Check if the values *a* and *b* are close to each other"
msgstr "Kontrollera om värdena *a* och *b* ligger nära varandra"

msgid ":func:`isfinite(x) <isfinite>`"
msgstr ":func:`isfinite(x) <isfinite>`"

msgid "Check if *x* is neither an infinity nor a NaN"
msgstr "Kontrollera om *x* varken är oändligt eller NaN"

msgid ":func:`isinf(x) <isinf>`"
msgstr ":func:`isinf(x) <isinf>`"

msgid "Check if *x* is a positive or negative infinity"
msgstr "Kontrollera om *x* är en positiv eller negativ oändlighet"

msgid ":func:`isnan(x) <isnan>`"
msgstr ":func:`isnan(x) <isnan>`"

msgid "Check if *x* is a NaN  (not a number)"
msgstr "Kontrollera om *x* är ett NaN (inte ett tal)"

msgid ":func:`ldexp(x, i) <ldexp>`"
msgstr ":func:`ldexp(x, i) <ldexp>`"

msgid "``x * (2**i)``, inverse of function :func:`frexp`"
msgstr "``x * (2**i)``, invers av funktionen :func:`frexp`"

msgid ":func:`nextafter(x, y, steps) <nextafter>`"
msgstr ":func:`nextafter(x, y, steps) <nextafter>`"

msgid "Floating-point value *steps* steps after *x* towards *y*"
msgstr "Flyttalsvärde *steps* stegar efter *x* mot *y*"

msgid ":func:`ulp(x) <ulp>`"
msgstr ":func:`ulp(x) <ulp>`"

msgid "Value of the least significant bit of *x*"
msgstr "Värdet av den minst signifikanta biten i *x*"

msgid "**Power, exponential and logarithmic functions**"
msgstr "**Potens-, exponential- och logaritmfunktioner**"

msgid ":func:`cbrt(x) <cbrt>`"
msgstr ":func:`cbrt(x) <cbrt>`"

msgid "Cube root of *x*"
msgstr "Kubrot av *x*"

msgid ":func:`exp(x) <exp>`"
msgstr ":func:`exp(x) <exp>`"

msgid "*e* raised to the power *x*"
msgstr "*e* upphöjd till makten *x*"

msgid ":func:`exp2(x) <exp2>`"
msgstr ":func:`exp2(x) <exp2>`"

msgid "*2* raised to the power *x*"
msgstr "*2* upphöjd till kraft *x*"

msgid ":func:`expm1(x) <expm1>`"
msgstr ":func:`expm1(x) <expm1>`"

msgid "*e* raised to the power *x*, minus 1"
msgstr "*e* upphöjt till potensen *x*, minus 1"

msgid ":func:`log(x, base) <log>`"
msgstr ":func:`log(x, base) <log>`"

msgid "Logarithm of *x* to the given base (*e* by default)"
msgstr "Logaritmen av *x* till den angivna basen (*e* som standard)"

msgid ":func:`log1p(x) <log1p>`"
msgstr ":func:`log1p(x) <log1p>`"

msgid "Natural logarithm of *1+x* (base *e*)"
msgstr "Naturlig logaritm av *1+x* (bas *e*)"

msgid ":func:`log2(x) <log2>`"
msgstr ":func:`log2(x) <log2>`"

msgid "Base-2 logarithm of *x*"
msgstr "Bas-2 logaritm av *x*"

msgid ":func:`log10(x) <log10>`"
msgstr ":func:`log10(x) <log10>`"

msgid "Base-10 logarithm of *x*"
msgstr "Bas-10 logaritmen av *x*"

msgid ":func:`pow(x, y) <math.pow>`"
msgstr ":func:`pow(x, y) <math.pow>`"

msgid "*x* raised to the power *y*"
msgstr "*x* upphöjd till makten *y*"

msgid ":func:`sqrt(x) <sqrt>`"
msgstr ":func:`sqrt(x) <sqrt>`"

msgid "Square root of *x*"
msgstr "Kvadratrot av *x*"

msgid "**Summation and product functions**"
msgstr "**Summa och produktfunktioner**"

msgid ":func:`dist(p, q) <dist>`"
msgstr ":func:`dist(p, q) <dist>`"

msgid ""
"Euclidean distance between two points *p* and *q* given as an iterable of "
"coordinates"
msgstr ""
"Euklidiskt avstånd mellan två punkter *p* och *q* givet som en iterabel av "
"koordinater"

msgid ":func:`fsum(iterable) <fsum>`"
msgstr ":func:`fsum(iterable) <fsum>`"

msgid "Sum of values in the input *iterable*"
msgstr "Summan av värdena i indata *iterable*"

msgid ":func:`hypot(*coordinates) <hypot>`"
msgstr ":func:`hypot(*coordinates) <hypot>`"

msgid "Euclidean norm of an iterable of coordinates"
msgstr "Euklidisk norm för en iterabel med koordinater"

msgid ":func:`prod(iterable, start) <prod>`"
msgstr ":func:`prod(iterable, start) <prod>`"

msgid "Product of elements in the input *iterable* with a *start* value"
msgstr "Produkt av element i indata *iterable* med ett *start* värde"

msgid ":func:`sumprod(p, q) <sumprod>`"
msgstr ":func:`sumprod(p, q) <sumprod>`"

msgid "Sum of products from two iterables *p* and *q*"
msgstr "Summan av produkterna från två iterabler *p* och *q*"

msgid "**Angular conversion**"
msgstr "**Vinkelomvandling**"

msgid ":func:`degrees(x) <degrees>`"
msgstr ":func:`degrees(x) <degrees>`"

msgid "Convert angle *x* from radians to degrees"
msgstr "Konvertera vinkel *x* från radianer till grader"

msgid ":func:`radians(x) <radians>`"
msgstr ":func:`radianer(x) <radians>`"

msgid "Convert angle *x* from degrees to radians"
msgstr "Konvertera vinkel *x* från grader till radianer"

msgid "**Trigonometric functions**"
msgstr "**Trigonometriska funktioner**"

msgid ":func:`acos(x) <acos>`"
msgstr ":func:`acos(x) <acos>`"

msgid "Arc cosine of *x*"
msgstr "Arc cosinus av *x*"

msgid ":func:`asin(x) <asin>`"
msgstr ":func:`asin(x) <asin>`"

msgid "Arc sine of *x*"
msgstr "Arc sinus av *x*"

msgid ":func:`atan(x) <atan>`"
msgstr ":func:`atan(x) <atan>`"

msgid "Arc tangent of *x*"
msgstr "Arc tangent av *x*"

msgid ":func:`atan2(y, x) <atan2>`"
msgstr ":func:`atan2(y, x) <atan2>`"

msgid "``atan(y / x)``"
msgstr "``atan(y / x)``"

msgid ":func:`cos(x) <cos>`"
msgstr ":func:`cos(x) <cos>`"

msgid "Cosine of *x*"
msgstr "Cosinus av *x*"

msgid ":func:`sin(x) <sin>`"
msgstr ":func:`sin(x) <sin>`"

msgid "Sine of *x*"
msgstr "Sinus av *x*"

msgid ":func:`tan(x) <tan>`"
msgstr ":func:`tan(x) <tan>`"

msgid "Tangent of *x*"
msgstr "Tangent av *x*"

msgid "**Hyperbolic functions**"
msgstr "**Hyperboliska funktioner**"

msgid ":func:`acosh(x) <acosh>`"
msgstr ":func:`acosh(x) <acosh>`"

msgid "Inverse hyperbolic cosine of *x*"
msgstr "Invers hyperbolisk cosinus av *x*"

msgid ":func:`asinh(x) <asinh>`"
msgstr ":func:`asinh(x) <asinh>`"

msgid "Inverse hyperbolic sine of *x*"
msgstr "Omvänd hyperbolisk sinus av *x*"

msgid ":func:`atanh(x) <atanh>`"
msgstr ":func:`atanh(x) <atanh>`"

msgid "Inverse hyperbolic tangent of *x*"
msgstr "Omvänd hyperbolisk tangent till *x*"

msgid ":func:`cosh(x) <cosh>`"
msgstr ":func:`cosh(x) <cosh>`"

msgid "Hyperbolic cosine of *x*"
msgstr "Hyperbolisk cosinus av *x*"

msgid ":func:`sinh(x) <sinh>`"
msgstr ":func:`sinh(x) <sinh>`"

msgid "Hyperbolic sine of *x*"
msgstr "Hyperbolisk sinus av *x*"

msgid ":func:`tanh(x) <tanh>`"
msgstr ":func:`tanh(x) <tanh>`"

msgid "Hyperbolic tangent of *x*"
msgstr "Hyperbolisk tangent till *x*"

msgid "**Special functions**"
msgstr "**Särskilda funktioner**"

msgid ":func:`erf(x) <erf>`"
msgstr ":func:`erf(x) <erf>`"

msgid "`Error function <https://en.wikipedia.org/wiki/Error_function>`_ at *x*"
msgstr "`Felfunktion <https://en.wikipedia.org/wiki/Error_function>`_ vid *x*"

msgid ":func:`erfc(x) <erfc>`"
msgstr ":func:`erfc(x) <erfc>`"

msgid ""
"`Complementary error function <https://en.wikipedia.org/wiki/"
"Error_function>`_ at *x*"
msgstr ""
"`Kompletterande felfunktion <https://en.wikipedia.org/wiki/Error_function>`_ "
"vid *x*"

msgid ":func:`gamma(x) <gamma>`"
msgstr ":func:`gamma(x) <gamma>`"

msgid "`Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr ""
"`Gammafunktion <https://en.wikipedia.org/wiki/Gamma_function>`_ vid *x*"

msgid ":func:`lgamma(x) <lgamma>`"
msgstr ":func:`lgamma(x) <lgamma>`"

msgid ""
"Natural logarithm of the absolute value of the `Gamma function <https://en."
"wikipedia.org/wiki/Gamma_function>`_ at *x*"
msgstr ""
"Naturlig logaritm av absolutvärdet av `Gamma-funktionen <https://en."
"wikipedia.org/wiki/Gamma_function>`_ vid *x*"

msgid "**Constants**"
msgstr "**Konstanter**"

msgid ":data:`pi`"
msgstr ":data:`pi`"

msgid "*π* = 3.141592..."
msgstr "*π* = 3.141592..."

msgid ":data:`e`"
msgstr ":data:`e`"

msgid "*e* = 2.718281..."
msgstr "*e* = 2.718281..."

msgid ":data:`tau`"
msgstr ":data:`tau`"

msgid "*τ* = 2\\ *π* = 6.283185..."
msgstr "*τ* = 2\\ *π* = 6,283185..."

msgid ":data:`inf`"
msgstr ":data:`inf`"

msgid "Positive infinity"
msgstr "Positiv oändlighet"

msgid ":data:`nan`"
msgstr ":data:`nan`"

msgid "\"Not a number\" (NaN)"
msgstr "\"Inte ett tal\" (NaN)"

msgid "Number-theoretic functions"
msgstr "Nummerteoretiska funktioner"

msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and without order."
msgstr ""
"Returnera antalet sätt att välja *k* objekt från *n* objekt utan upprepning "
"och utan ordning."

msgid ""
"Evaluates to ``n! / (k! * (n - k)!)`` when ``k <= n`` and evaluates to zero "
"when ``k > n``."
msgstr ""
"Utvärderas till ``n! / (k! * (n - k)!)`` när ``k <= n`` och utvärderas till "
"noll när ``k > n``."

msgid ""
"Also called the binomial coefficient because it is equivalent to the "
"coefficient of k-th term in polynomial expansion of ``(1 + x)ⁿ``."
msgstr ""
"Kallas även binomialkoefficienten eftersom den motsvarar koefficienten för "
"den k:e termen i polynomutvecklingen av ``(1 + x)ⁿ``."

msgid ""
"Raises :exc:`TypeError` if either of the arguments are not integers. Raises :"
"exc:`ValueError` if either of the arguments are negative."
msgstr ""
"Utlöser :exc:`TypeError` om något av argumenten inte är heltal. Utlöser :exc:"
"`ValueError` om något av argumenten är negativa."

msgid "Return factorial of the nonnegative integer *n*."
msgstr "Returnerar faktoriellt av det icke-negativa heltalet *n*."

msgid "Floats with integral values (like ``5.0``) are no longer accepted."
msgstr "Floater med heltalsvärden (som ``5.0``) accepteras inte längre."

msgid ""
"Return the greatest common divisor of the specified integer arguments. If "
"any of the arguments is nonzero, then the returned value is the largest "
"positive integer that is a divisor of all arguments.  If all arguments are "
"zero, then the returned value is ``0``.  ``gcd()`` without arguments returns "
"``0``."
msgstr ""
"Returnerar den största gemensamma divisorn av de angivna heltalsargumenten. "
"Om något av argumenten inte är noll, är det returnerade värdet det största "
"positiva heltal som är divisor till alla argument.  Om alla argument är "
"noll, är det returnerade värdet ``0``.  ``gcd()`` utan argument returnerar "
"``0``."

msgid ""
"Added support for an arbitrary number of arguments. Formerly, only two "
"arguments were supported."
msgstr ""
"Stöd för ett godtyckligt antal argument har lagts till. Tidigare stöddes "
"endast två argument."

msgid ""
"Return the integer square root of the nonnegative integer *n*. This is the "
"floor of the exact square root of *n*, or equivalently the greatest integer "
"*a* such that *a*\\ ² |nbsp| ≤ |nbsp| *n*."
msgstr ""
"Returnerar heltalets kvadratrot av det icke-negativa heltalet *n*. Detta är "
"golvet i den exakta kvadratroten av *n*, eller motsvarande det största "
"heltalet *a* som är sådant att *a*\\ ² |nbsp| ≤ |nbsp| *n*."

msgid ""
"For some applications, it may be more convenient to have the least integer "
"*a* such that *n* |nbsp| ≤ |nbsp| *a*\\ ², or in other words the ceiling of "
"the exact square root of *n*. For positive *n*, this can be computed using "
"``a = 1 + isqrt(n - 1)``."
msgstr ""
"För vissa tillämpningar kan det vara mer praktiskt att ha det minsta "
"heltalet *a* så att *n* |nbsp| ≤ |nbsp| *a*\\ ², eller med andra ord taket "
"för den exakta kvadratroten av *n*. För positiva *n* kan detta beräknas med "
"hjälp av ``a = 1 + isqrt(n - 1)``."

msgid ""
"Return the least common multiple of the specified integer arguments. If all "
"arguments are nonzero, then the returned value is the smallest positive "
"integer that is a multiple of all arguments.  If any of the arguments is "
"zero, then the returned value is ``0``.  ``lcm()`` without arguments returns "
"``1``."
msgstr ""
"Returnerar den minsta gemensamma multipeln av de angivna heltalsargumenten. "
"Om alla argument är olika noll är det returnerade värdet det minsta positiva "
"heltalet som är en multipel av alla argument.  Om något av argumenten är "
"noll, är det returnerade värdet ``0``.  ``lcm()`` utan argument returnerar "
"``1``."

msgid ""
"Return the number of ways to choose *k* items from *n* items without "
"repetition and with order."
msgstr ""
"Returnera antalet sätt att välja *k* objekt från *n* objekt utan upprepning "
"och med ordning."

msgid ""
"Evaluates to ``n! / (n - k)!`` when ``k <= n`` and evaluates to zero when "
"``k > n``."
msgstr ""
"Utvärderas till ``n! / (n - k)!`` när ``k <= n`` och utvärderas till noll "
"när ``k > n``."

msgid ""
"If *k* is not specified or is ``None``, then *k* defaults to *n* and the "
"function returns ``n!``."
msgstr ""
"Om *k* inte anges eller är ``None``, är *k* standardvärdet för *n* och "
"funktionen returnerar ``n!``."

msgid "Floating point arithmetic"
msgstr "Aritmetik med flyttal"

msgid ""
"Return the ceiling of *x*, the smallest integer greater than or equal to "
"*x*. If *x* is not a float, delegates to :meth:`x.__ceil__ <object."
"__ceil__>`, which should return an :class:`~numbers.Integral` value."
msgstr ""
"Returnerar taket för *x*, det minsta heltalet som är större än eller lika "
"med *x*. Om *x* inte är en float, delegeras till :meth:`x.__ceil__ <object."
"__ceil__>`, som bör returnera ett :class:`~numbers.Integral`-värde."

msgid "Return the absolute value of *x*."
msgstr "Returnerar det absoluta värdet av *x*."

msgid ""
"Return the floor of *x*, the largest integer less than or equal to *x*.  If "
"*x* is not a float, delegates to :meth:`x.__floor__ <object.__floor__>`, "
"which should return an :class:`~numbers.Integral` value."
msgstr ""
"Returnerar golvet av *x*, det största heltalet mindre än eller lika med "
"*x*.  Om *x* inte är en float, delegeras till :meth:`x.__floor__ <object."
"__floor__>`, som bör returnera ett :class:`~numbers.Integral`-värde."

msgid ""
"Fused multiply-add operation. Return ``(x * y) + z``, computed as though "
"with infinite precision and range followed by a single round to the "
"``float`` format. This operation often provides better accuracy than the "
"direct expression ``(x * y) + z``."
msgstr ""
"Fusionerad multiplicera-add-operation. Returnerar ``(x * y) + z``, beräknat "
"som om det vore med oändlig precision och intervall följt av en enda "
"avrundning till ``float``-formatet. Denna operation ger ofta bättre "
"noggrannhet än det direkta uttrycket ``(x * y) + z``."

msgid ""
"This function follows the specification of the fusedMultiplyAdd operation "
"described in the IEEE 754 standard. The standard leaves one case "
"implementation-defined, namely the result of ``fma(0, inf, nan)`` and "
"``fma(inf, 0, nan)``. In these cases, ``math.fma`` returns a NaN, and does "
"not raise any exception."
msgstr ""
"Denna funktion följer specifikationen för fusedMultiplyAdd-operationen som "
"beskrivs i IEEE 754-standarden. Standarden lämnar ett fall "
"implementationsdefinierat, nämligen resultatet av ``fma(0, inf, nan)`` och "
"``fma(inf, 0, nan)``. I dessa fall returnerar ``math.fma`` ett NaN och ger "
"inte upphov till något undantag."

msgid ""
"Return the floating-point remainder of ``x / y``, as defined by the platform "
"C library function ``fmod(x, y)``. Note that the Python expression ``x % y`` "
"may not return the same result.  The intent of the C standard is that "
"``fmod(x, y)`` be exactly (mathematically; to infinite precision) equal to "
"``x - n*y`` for some integer *n* such that the result has the same sign as "
"*x* and magnitude less than ``abs(y)``.  Python's ``x % y`` returns a result "
"with the sign of *y* instead, and may not be exactly computable for float "
"arguments. For example, ``fmod(-1e-100, 1e100)`` is ``-1e-100``, but the "
"result of Python's ``-1e-100 % 1e100`` is ``1e100-1e-100``, which cannot be "
"represented exactly as a float, and rounds to the surprising ``1e100``.  For "
"this reason, function :func:`fmod` is generally preferred when working with "
"floats, while Python's ``x % y`` is preferred when working with integers."
msgstr ""
"Returnerar restvärdet i flyttal av ``x / y``, enligt definitionen av "
"plattformens C-biblioteksfunktion ``fmod(x, y)``. Observera att Python-"
"uttrycket ``x % y`` kanske inte returnerar samma resultat.  Avsikten med C-"
"standarden är att ``fmod(x, y)`` ska vara exakt (matematiskt; till oändlig "
"precision) lika med ``x - n*y`` för något heltal *n* så att resultatet har "
"samma tecken som *x* och storlek mindre än ``abs(y)``.  Pythons ``x % y`` "
"returnerar ett resultat med tecknet *y* istället, och kanske inte är exakt "
"beräkningsbart för float-argument. Till exempel är ``fmod(-1e-100, 1e100)`` "
"``-1e-100``, men resultatet av Pythons ``-1e-100 % 1e100`` är "
"``1e100-1e-100``, som inte kan representeras exakt som en float, och "
"avrundas till den överraskande ``1e100``.  Av denna anledning är funktionen :"
"func:`fmod` i allmänhet att föredra när man arbetar med flyttal, medan "
"Pythons ``x % y`` är att föredra när man arbetar med heltal."

msgid ""
"Return the fractional and integer parts of *x*.  Both results carry the sign "
"of *x* and are floats."
msgstr ""
"Returnerar bråktals- och heltalsdelarna av *x*.  Båda resultaten har tecknet "
"för *x* och är flyttal."

msgid ""
"Note that :func:`modf` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, rather "
"than returning its second return value through an 'output parameter' (there "
"is no such thing in Python)."
msgstr ""
"Observera att :func:`modf` har ett annat anrops-/returmönster än sina "
"motsvarigheter i C: den tar ett enda argument och returnerar ett par värden, "
"i stället för att returnera sitt andra returvärde via en "
"\"utgångsparameter\" (det finns inget sådant i Python)."

msgid ""
"Return the IEEE 754-style remainder of *x* with respect to *y*.  For finite "
"*x* and finite nonzero *y*, this is the difference ``x - n*y``, where ``n`` "
"is the closest integer to the exact value of the quotient ``x / y``.  If "
"``x / y`` is exactly halfway between two consecutive integers, the nearest "
"*even* integer is used for ``n``.  The remainder ``r = remainder(x, y)`` "
"thus always satisfies ``abs(r) <= 0.5 * abs(y)``."
msgstr ""
"Returnerar restvärdet i IEEE 754-stil av *x* med avseende på *y*.  För "
"ändliga *x* och ändliga *y* som inte är noll är detta skillnaden ``x - "
"n*y``, där ``n`` är det närmaste heltalet till det exakta värdet av kvoten "
"``x / y``.  Om ``x / y`` ligger exakt mitt emellan två på varandra följande "
"heltal, används det närmaste *jämna* heltalet för ``n``.  Resten ``r = "
"rest(x, y)`` uppfyller således alltid ``abs(r) <= 0,5 * abs(y)``."

msgid ""
"Special cases follow IEEE 754: in particular, ``remainder(x, math.inf)`` is "
"*x* for any finite *x*, and ``remainder(x, 0)`` and ``remainder(math.inf, "
"x)`` raise :exc:`ValueError` for any non-NaN *x*. If the result of the "
"remainder operation is zero, that zero will have the same sign as *x*."
msgstr ""
"Specialfall följer IEEE 754: i synnerhet är ``remainder(x, math.inf)`` *x* "
"för alla ändliga *x*, och ``remainder(x, 0)`` och ``remainder(math.inf, x)`` "
"ger upphov till :exc:`ValueError` för alla icke-NaN *x*. Om resultatet av "
"remainder-operationen är noll, kommer nollan att ha samma tecken som *x*."

msgid ""
"On platforms using IEEE 754 binary floating point, the result of this "
"operation is always exactly representable: no rounding error is introduced."
msgstr ""
"På plattformar som använder IEEE 754 binär flyttal är resultatet av denna "
"operation alltid exakt representativt: inget avrundningsfel införs."

msgid ""
"Return *x* with the fractional part removed, leaving the integer part.  This "
"rounds toward 0: ``trunc()`` is equivalent to :func:`floor` for positive "
"*x*, and equivalent to :func:`ceil` for negative *x*. If *x* is not a float, "
"delegates to :meth:`x.__trunc__ <object.__trunc__>`, which should return an :"
"class:`~numbers.Integral` value."
msgstr ""
"Returnerar *x* med bråkdelen borttagen, så att heltalsdelen återstår.  Detta "
"avrundas mot 0: ``trunc()`` är likvärdigt med :func:`floor` för positiva "
"*x*, och likvärdigt med :func:`ceil` för negativa *x*. Om *x* inte är en "
"float, delegeras till :meth:`x.__trunc__ <object.__trunc__>`, som bör "
"returnera ett :class:`~numbers.Integral`-värde."

msgid ""
"For the :func:`ceil`, :func:`floor`, and :func:`modf` functions, note that "
"*all* floating-point numbers of sufficiently large magnitude are exact "
"integers. Python floats typically carry no more than 53 bits of precision "
"(the same as the platform C double type), in which case any float *x* with "
"``abs(x) >= 2**52`` necessarily has no fractional bits."
msgstr ""
"För funktionerna :func:`ceil`, :func:`floor`, och :func:`modf`, notera att "
"*alla* flyttal av tillräckligt stor storlek är exakta heltal. Pythons "
"flyttal har vanligtvis inte mer än 53 bitars precision (samma som plattform "
"C:s dubbeltyp), i vilket fall alla flyttal *x* med ``abs(x) >= 2**52`` "
"nödvändigtvis inte har några bråkdelar."

msgid "Floating point manipulation functions"
msgstr "Funktioner för manipulation av flyttal"

msgid ""
"Return a float with the magnitude (absolute value) of *x* but the sign of "
"*y*.  On platforms that support signed zeros, ``copysign(1.0, -0.0)`` "
"returns *-1.0*."
msgstr ""
"Returnerar en float med magnituden (absolutvärdet) *x* men tecknet *y*.  På "
"plattformar som stöder signerade nollor returnerar ``copysign(1,0, -0,0)`` "
"*-1,0*."

msgid ""
"Return the mantissa and exponent of *x* as the pair ``(m, e)``.  *m* is a "
"float and *e* is an integer such that ``x == m * 2**e`` exactly. If *x* is "
"zero, returns ``(0.0, 0)``, otherwise ``0.5 <= abs(m) < 1``.  This is used "
"to \"pick apart\" the internal representation of a float in a portable way."
msgstr ""
"Returnerar mantissa och exponent för *x* som paret ``(m, e)``.  *m* är ett "
"flyttal och *e* är ett heltal så att ``x == m * 2**e`` exakt. Om *x* är noll "
"returneras ``(0,0, 0)``, annars ``0,5 <= abs(m) < 1``.  Detta används för "
"att \"plocka isär\" den interna representationen av en float på ett "
"portabelt sätt."

msgid ""
"Note that :func:`frexp` has a different call/return pattern than its C "
"equivalents: it takes a single argument and return a pair of values, rather "
"than returning its second return value through an 'output parameter' (there "
"is no such thing in Python)."
msgstr ""
"Observera att :func:`frexp` har ett annat anrops-/returmönster än sina "
"motsvarigheter i C: den tar ett enda argument och returnerar ett par värden, "
"i stället för att returnera sitt andra returvärde via en "
"\"utgångsparameter\" (det finns inget sådant i Python)."

msgid ""
"Return ``True`` if the values *a* and *b* are close to each other and "
"``False`` otherwise."
msgstr ""
"Returnerar ``True`` om värdena *a* och *b* ligger nära varandra och "
"``False`` i annat fall."

msgid ""
"Whether or not two values are considered close is determined according to "
"given absolute and relative tolerances.  If no errors occur, the result will "
"be: ``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."
msgstr ""
"Huruvida två värden anses ligga nära varandra eller inte avgörs enligt givna "
"absoluta och relativa toleranser.  Om inga fel inträffar blir resultatet: "
"``abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)``."

msgid ""
"*rel_tol* is the relative tolerance -- it is the maximum allowed difference "
"between *a* and *b*, relative to the larger absolute value of *a* or *b*. "
"For example, to set a tolerance of 5%, pass ``rel_tol=0.05``.  The default "
"tolerance is ``1e-09``, which assures that the two values are the same "
"within about 9 decimal digits.  *rel_tol* must be nonnegative and less than "
"``1.0``."
msgstr ""
"*rel_tol* är den relativa toleransen - det är den maximalt tillåtna "
"skillnaden mellan *a* och *b*, i förhållande till det större absoluta värdet "
"av *a* eller *b*. Om du t.ex. vill ange en tolerans på 5 % anger du "
"``rel_tol=0,05``.  Standardtoleransen är ``1e-09``, vilket garanterar att de "
"två värdena är lika inom cirka 9 decimaler.  *rel_tol* måste vara icke-"
"negativt och mindre än ``1,0``."

msgid ""
"*abs_tol* is the absolute tolerance; it defaults to ``0.0`` and it must be "
"nonnegative.  When comparing ``x`` to ``0.0``, ``isclose(x, 0)`` is computed "
"as ``abs(x) <= rel_tol  * abs(x)``, which is ``False`` for any nonzero ``x`` "
"and *rel_tol* less than ``1.0``.  So add an appropriate positive *abs_tol* "
"argument to the call."
msgstr ""
"*abs_tol* är den absoluta toleransen; standardvärdet är ``0,0`` och det "
"måste vara icke-negativt.  Vid jämförelse av ``x`` med ``0,0`` beräknas "
"``isclose(x, 0)`` som ``abs(x) <= rel_tol * abs(x)``, vilket är ``falskt`` "
"för alla ``x`` som inte är noll och *rel_tol* mindre än ``1,0``.  Lägg "
"därför till ett lämpligt positivt *abs_tol*-argument i anropet."

msgid ""
"The IEEE 754 special values of ``NaN``, ``inf``, and ``-inf`` will be "
"handled according to IEEE rules.  Specifically, ``NaN`` is not considered "
"close to any other value, including ``NaN``.  ``inf`` and ``-inf`` are only "
"considered close to themselves."
msgstr ""
"IEEE 754 specialvärdena ``NaN``, ``inf`` och ``-inf`` kommer att hanteras "
"enligt IEEE:s regler.  Specifikt anses inte ``NaN`` ligga nära något annat "
"värde, inklusive ``NaN``.  ``inf`` och ``-inf`` betraktas endast som nära "
"sig själva."

msgid ":pep:`485` -- A function for testing approximate equality"
msgstr ":pep:`485` -- En funktion för att testa ungefärlig likhet"

msgid ""
"Return ``True`` if *x* is neither an infinity nor a NaN, and ``False`` "
"otherwise.  (Note that ``0.0`` *is* considered finite.)"
msgstr ""
"Returnerar ``True`` om *x* varken är en oändlighet eller en NaN, och "
"``False`` annars.  (Observera att ``0.0`` *anses* som ändligt.)"

msgid ""
"Return ``True`` if *x* is a positive or negative infinity, and ``False`` "
"otherwise."
msgstr ""
"Returnerar ``True`` om *x* är en positiv eller negativ oändlighet, och "
"``False`` annars."

msgid ""
"Return ``True`` if *x* is a NaN (not a number), and ``False`` otherwise."
msgstr ""
"Returnerar ``True`` om *x* är en NaN (inte ett tal), och ``False`` annars."

msgid ""
"Return ``x * (2**i)``.  This is essentially the inverse of function :func:"
"`frexp`."
msgstr ""
"Returnerar ``x * (2**i)``.  Detta är i princip inversen av funktionen :func:"
"`frexp`."

msgid "Return the floating-point value *steps* steps after *x* towards *y*."
msgstr "Returnerar flyttalsvärdet *steps* steg efter *x* mot *y*."

msgid "If *x* is equal to *y*, return *y*, unless *steps* is zero."
msgstr "Om *x* är lika med *y* returneras *y*, såvida inte *steps* är noll."

msgid "Examples:"
msgstr "Exempel:"

msgid "``math.nextafter(x, math.inf)`` goes up: towards positive infinity."
msgstr "``math.nextafter(x, math.inf)`` går upp: mot positiv oändlighet."

msgid "``math.nextafter(x, -math.inf)`` goes down: towards minus infinity."
msgstr "``math.nextafter(x, -math.inf)`` går ner: mot minus oändligheten."

msgid "``math.nextafter(x, 0.0)`` goes towards zero."
msgstr "``math.nextafter(x, 0.0)`` går mot noll."

msgid "``math.nextafter(x, math.copysign(math.inf, x))`` goes away from zero."
msgstr "``math.nextafter(x, math.copysign(math.inf, x))`` går bort från noll."

msgid "See also :func:`math.ulp`."
msgstr "Se även :func:`math.ulp`."

msgid "Added the *steps* argument."
msgstr "Lagt till argumentet *steps*."

msgid "Return the value of the least significant bit of the float *x*:"
msgstr "Returnera värdet på den minst signifikanta biten i floaten *x*:"

msgid "If *x* is a NaN (not a number), return *x*."
msgstr "Om *x* är ett NaN (inte ett tal), returneras *x*."

msgid "If *x* is negative, return ``ulp(-x)``."
msgstr "Om *x* är negativ, returneras ``ulp(-x)``."

msgid "If *x* is a positive infinity, return *x*."
msgstr "Om *x* är en positiv oändlighet, returneras *x*."

msgid ""
"If *x* is equal to zero, return the smallest positive *denormalized* "
"representable float (smaller than the minimum positive *normalized* float, :"
"data:`sys.float_info.min <sys.float_info>`)."
msgstr ""
"Om *x* är lika med noll, returneras den minsta positiva *denormaliserade* "
"representativa floaten (mindre än den minsta positiva *normaliserade* "
"floaten, :data:`sys.float_info.min <sys.float_info>`)."

msgid ""
"If *x* is equal to the largest positive representable float, return the "
"value of the least significant bit of *x*, such that the first float smaller "
"than *x* is ``x - ulp(x)``."
msgstr ""
"Om *x* är lika med den största positiva representativa floaten, returneras "
"värdet av den minst signifikanta biten i *x*, så att den första floaten som "
"är mindre än *x* är ``x - ulp(x)``."

msgid ""
"Otherwise (*x* is a positive finite number), return the value of the least "
"significant bit of *x*, such that the first float bigger than *x* is ``x + "
"ulp(x)``."
msgstr ""
"Annars (*x* är ett positivt ändligt tal), returnera värdet på den minst "
"signifikanta biten i *x*, så att det första flyttalet som är större än *x* "
"är ``x + ulp(x)``."

msgid "ULP stands for \"Unit in the Last Place\"."
msgstr "ULP står för \"Unit in the Last Place\"."

msgid ""
"See also :func:`math.nextafter` and :data:`sys.float_info.epsilon <sys."
"float_info>`."
msgstr ""
"Se även :func:`math.nextafter` och :data:`sys.float_info.epsilon <sys."
"float_info>`."

msgid "Power, exponential and logarithmic functions"
msgstr "Potens-, exponential- och logaritmfunktioner"

msgid "Return the cube root of *x*."
msgstr "Returnerar kubikroten av *x*."

msgid ""
"Return *e* raised to the power *x*, where *e* = 2.718281... is the base of "
"natural logarithms.  This is usually more accurate than ``math.e ** x`` or "
"``pow(math.e, x)``."
msgstr ""
"Returnerar *e* upphöjt till potensen *x*, där *e* = 2,718281... är basen för "
"naturliga logaritmer.  Detta är vanligtvis mer exakt än ``math.e ** x`` "
"eller ``pow(math.e, x)``."

msgid "Return *2* raised to the power *x*."
msgstr "Returnera *2* upphöjt till potensen *x*."

msgid ""
"Return *e* raised to the power *x*, minus 1.  Here *e* is the base of "
"natural logarithms.  For small floats *x*, the subtraction in ``exp(x) - 1`` "
"can result in a `significant loss of precision <https://en.wikipedia.org/"
"wiki/Loss_of_significance>`_\\; the :func:`expm1` function provides a way to "
"compute this quantity to full precision:"
msgstr ""
"Returnerar *e* upphöjt till potensen *x*, minus 1.  Här är *e* basen för "
"naturliga logaritmer.  För små flyttal *x* kan subtraktionen i ``exp(x) - "
"1`` resultera i en `betydande förlust av precision <https://en.wikipedia.org/"
"wiki/Loss_of_significance>`_\\; funktionen :func:`expm1` ger ett sätt att "
"beräkna denna kvantitet med full precision:"

msgid "With one argument, return the natural logarithm of *x* (to base *e*)."
msgstr ""
"Med ett argument, returnerar den naturliga logaritmen av *x* (till basen "
"*e*)."

msgid ""
"With two arguments, return the logarithm of *x* to the given *base*, "
"calculated as ``log(x)/log(base)``."
msgstr ""
"Med två argument, returnerar logaritmen för *x* till den angivna *basen*, "
"beräknad som ``log(x)/log(bas)``."

msgid ""
"Return the natural logarithm of *1+x* (base *e*). The result is calculated "
"in a way which is accurate for *x* near zero."
msgstr ""
"Returnerar den naturliga logaritmen av *1+x* (bas *e*). Resultatet beräknas "
"på ett sätt som är korrekt för *x* nära noll."

msgid ""
"Return the base-2 logarithm of *x*. This is usually more accurate than "
"``log(x, 2)``."
msgstr ""
"Returnerar bas-2 logaritmen av *x*. Detta är vanligtvis mer exakt än "
"``log(x, 2)``."

msgid ""
":meth:`int.bit_length` returns the number of bits necessary to represent an "
"integer in binary, excluding the sign and leading zeros."
msgstr ""
":meth:`int.bit_length` returnerar det antal bitar som krävs för att "
"representera ett heltal i binär form, exklusive tecken och inledande nollor."

msgid ""
"Return the base-10 logarithm of *x*.  This is usually more accurate than "
"``log(x, 10)``."
msgstr ""
"Returnerar bas-10 logaritmen av *x*.  Detta är vanligtvis mer exakt än "
"``log(x, 10)``."

msgid ""
"Return *x* raised to the power *y*.  Exceptional cases follow the IEEE 754 "
"standard as far as possible.  In particular, ``pow(1.0, x)`` and ``pow(x, "
"0.0)`` always return ``1.0``, even when *x* is a zero or a NaN.  If both *x* "
"and *y* are finite, *x* is negative, and *y* is not an integer then ``pow(x, "
"y)`` is undefined, and raises :exc:`ValueError`."
msgstr ""
"Returnera *x* upphöjt till potensen *y*.  Undantagsfall följer IEEE 754-"
"standarden så långt som möjligt.  I synnerhet returnerar ``pow(1.0, x)`` och "
"``pow(x, 0.0)`` alltid ``1.0``, även när *x* är en nolla eller ett NaN.  Om "
"både *x* och *y* är ändliga, *x* är negativ och *y* inte är ett heltal är "
"``pow(x, y)`` odefinierad och ger upphov till :exc:`ValueError`."

msgid ""
"Unlike the built-in ``**`` operator, :func:`math.pow` converts both its "
"arguments to type :class:`float`.  Use ``**`` or the built-in :func:`pow` "
"function for computing exact integer powers."
msgstr ""
"Till skillnad från den inbyggda operatorn ``**`` konverterar :func:`math."
"pow`` båda sina argument till typen :class:`float`.  Använd ``**`` eller den "
"inbyggda funktionen :func:`pow` för att beräkna exakta heltalspotenser."

msgid ""
"The special cases ``pow(0.0, -inf)`` and ``pow(-0.0, -inf)`` were changed to "
"return ``inf`` instead of raising :exc:`ValueError`, for consistency with "
"IEEE 754."
msgstr ""
"Specialfallen ``pow(0.0, -inf)`` och ``pow(-0.0, -inf)`` ändrades till att "
"returnera ``inf`` istället för att ge :exc:`ValueError`, för att "
"överensstämma med IEEE 754."

msgid "Return the square root of *x*."
msgstr "Returnerar kvadratroten av *x*."

msgid "Summation and product functions"
msgstr "Summations- och produktfunktioner"

msgid ""
"Return the Euclidean distance between two points *p* and *q*, each given as "
"a sequence (or iterable) of coordinates.  The two points must have the same "
"dimension."
msgstr ""
"Returnerar det euklidiska avståndet mellan två punkter *p* och *q*, var och "
"en angiven som en sekvens (eller iterabel) av koordinater.  De två punkterna "
"måste ha samma dimension."

msgid "Roughly equivalent to::"
msgstr "Ungefär motsvarande::"

msgid "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))"
msgstr "sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))"

msgid ""
"Return an accurate floating-point sum of values in the iterable.  Avoids "
"loss of precision by tracking multiple intermediate partial sums."
msgstr ""
"Returnerar en exakt summa i flyttal av värdena i iterabeln.  Undviker "
"förlust av precision genom att spåra flera mellanliggande partiella summor."

msgid ""
"The algorithm's accuracy depends on IEEE-754 arithmetic guarantees and the "
"typical case where the rounding mode is half-even.  On some non-Windows "
"builds, the underlying C library uses extended precision addition and may "
"occasionally double-round an intermediate sum causing it to be off in its "
"least significant bit."
msgstr ""
"Algoritmens noggrannhet beror på aritmetiska garantier enligt IEEE-754 och "
"det typiska fallet där avrundningsläget är halvjämnt.  På vissa icke-Windows-"
"versioner använder det underliggande C-biblioteket addition med utökad "
"precision och kan ibland dubbelrunda en mellansumma, vilket gör att den "
"minst signifikanta biten inte stämmer."

msgid ""
"For further discussion and two alternative approaches, see the `ASPN "
"cookbook recipes for accurate floating-point summation <https://code."
"activestate.com/recipes/393090-binary-floating-point-summation-accurate-to-"
"full-p/>`_\\."
msgstr ""
"För ytterligare diskussion och två alternativa metoder, se \"ASPN cookbook "
"recipes for accurate floating-point summation\" <https://code.activestate."
"com/recipes/393090-binary-floating-point-summation-accurate-to-full-p/>`_\\."

msgid ""
"Return the Euclidean norm, ``sqrt(sum(x**2 for x in coordinates))``. This is "
"the length of the vector from the origin to the point given by the "
"coordinates."
msgstr ""
"Returnerar den euklidiska normen, ``sqrt(sum(x**2 for x in coordinates))``. "
"Detta är längden på vektorn från origo till den punkt som anges av "
"koordinaterna."

msgid ""
"For a two dimensional point ``(x, y)``, this is equivalent to computing the "
"hypotenuse of a right triangle using the Pythagorean theorem, ``sqrt(x*x + "
"y*y)``."
msgstr ""
"För en tvådimensionell punkt ``(x, y)`` är detta likvärdigt med att beräkna "
"hypotenusan i en rätvinklig triangel med hjälp av Pythagoras sats, "
"``sqrt(x*x + y*y)``."

msgid ""
"Added support for n-dimensional points. Formerly, only the two dimensional "
"case was supported."
msgstr ""
"Stöd för n-dimensionella punkter har lagts till. Tidigare stöddes endast det "
"tvådimensionella fallet."

msgid ""
"Improved the algorithm's accuracy so that the maximum error is under 1 ulp "
"(unit in the last place).  More typically, the result is almost always "
"correctly rounded to within 1/2 ulp."
msgstr ""
"Förbättrat algoritmens noggrannhet så att det maximala felet är under 1 ulp "
"(enhet på sista plats).  Mer typiskt är att resultatet nästan alltid är "
"korrekt avrundat till inom 1/2 ulp."

msgid ""
"Calculate the product of all the elements in the input *iterable*. The "
"default *start* value for the product is ``1``."
msgstr ""
"Beräkna produkten av alla element i indata *iterable*. Standardvärdet "
"*start* för produkten är ``1``."

msgid ""
"When the iterable is empty, return the start value.  This function is "
"intended specifically for use with numeric values and may reject non-numeric "
"types."
msgstr ""
"När iterabeln är tom returneras startvärdet.  Denna funktion är särskilt "
"avsedd för användning med numeriska värden och kan avvisa icke-numeriska "
"typer."

msgid "Return the sum of products of values from two iterables *p* and *q*."
msgstr ""
"Returnerar summan av produkter av värden från två iterabler *p* och *q*."

msgid "Raises :exc:`ValueError` if the inputs do not have the same length."
msgstr "Utlöser :exc:`ValueError` om inmatningarna inte har samma längd."

msgid "sum(map(operator.mul, p, q, strict=True))"
msgstr "sum(map(operator.mul, p, q, strict=True))"

msgid ""
"For float and mixed int/float inputs, the intermediate products and sums are "
"computed with extended precision."
msgstr ""
"För float- och mixed int/float-ingångar beräknas mellanprodukter och summor "
"med utökad precision."

msgid "Angular conversion"
msgstr "Angulär konvertering"

msgid "Convert angle *x* from radians to degrees."
msgstr "Konvertera vinkel *x* från radianer till grader."

msgid "Convert angle *x* from degrees to radians."
msgstr "Konvertera vinkel *x* från grader till radianer."

msgid "Trigonometric functions"
msgstr "Trigonometriska funktioner"

msgid ""
"Return the arc cosine of *x*, in radians. The result is between ``0`` and "
"``pi``."
msgstr ""
"Returnerar bågkosinus för *x*, i radianer. Resultatet ligger mellan ``0`` "
"och ``pi``."

msgid ""
"Return the arc sine of *x*, in radians. The result is between ``-pi/2`` and "
"``pi/2``."
msgstr ""
"Returnerar bågsinus för *x*, i radianer. Resultatet ligger mellan ``-pi/2`` "
"och ``pi/2``."

msgid ""
"Return the arc tangent of *x*, in radians. The result is between ``-pi/2`` "
"and ``pi/2``."
msgstr ""
"Returnerar bågtangenten för *x*, i radianer. Resultatet ligger mellan ``-"
"pi/2`` och ``pi/2``."

msgid ""
"Return ``atan(y / x)``, in radians. The result is between ``-pi`` and "
"``pi``. The vector in the plane from the origin to point ``(x, y)`` makes "
"this angle with the positive X axis. The point of :func:`atan2` is that the "
"signs of both inputs are known to it, so it can compute the correct quadrant "
"for the angle. For example, ``atan(1)`` and ``atan2(1, 1)`` are both "
"``pi/4``, but ``atan2(-1, -1)`` is ``-3*pi/4``."
msgstr ""
"Returnerar ``atan(y / x)``, i radianer. Resultatet ligger mellan ``-pi`` och "
"``pi``. Vektorn i planet från origo till punkten ``(x, y)`` bildar denna "
"vinkel med den positiva X-axeln. Poängen med :func:`atan2` är att tecknen på "
"båda indata är kända för den, så att den kan beräkna rätt kvadrant för "
"vinkeln. Till exempel är ``atan(1)`` och ``atan2(1, 1)`` båda ``pi/4``, men "
"``atan2(-1, -1)`` är ``-3*pi/4``."

msgid "Return the cosine of *x* radians."
msgstr "Returnerar cosinus av *x* radianer."

msgid "Return the sine of *x* radians."
msgstr "Returnerar sinus av *x* radianer."

msgid "Return the tangent of *x* radians."
msgstr "Returnerar tangenten av *x* radianer."

msgid "Hyperbolic functions"
msgstr "Hyperboliska funktioner"

msgid ""
"`Hyperbolic functions <https://en.wikipedia.org/wiki/Hyperbolic_functions>`_ "
"are analogs of trigonometric functions that are based on hyperbolas instead "
"of circles."
msgstr ""
"hyperboliska funktioner <https://en.wikipedia.org/wiki/"
"Hyperbolic_functions>`_ är motsvarigheter till trigonometriska funktioner "
"som baseras på hyperbler i stället för cirklar."

msgid "Return the inverse hyperbolic cosine of *x*."
msgstr "Returnerar den inversa hyperboliska cosinus av *x*."

msgid "Return the inverse hyperbolic sine of *x*."
msgstr "Returnerar den inverterade hyperboliska sinus av *x*."

msgid "Return the inverse hyperbolic tangent of *x*."
msgstr "Returnerar den omvända hyperboliska tangenten för *x*."

msgid "Return the hyperbolic cosine of *x*."
msgstr "Returnerar hyperbolisk cosinus av *x*."

msgid "Return the hyperbolic sine of *x*."
msgstr "Returnerar den hyperboliska sinusformen av *x*."

msgid "Return the hyperbolic tangent of *x*."
msgstr "Returnerar den hyperboliska tangenten för *x*."

msgid "Special functions"
msgstr "Särskilda funktioner"

msgid ""
"Return the `error function <https://en.wikipedia.org/wiki/Error_function>`_ "
"at *x*."
msgstr ""
"Returnera `felsfunktionen <https://en.wikipedia.org/wiki/Error_function>`_ "
"vid *x*."

msgid ""
"The :func:`erf` function can be used to compute traditional statistical "
"functions such as the `cumulative standard normal distribution <https://en."
"wikipedia.org/wiki/Cumulative_distribution_function>`_::"
msgstr ""
"Funktionen :func:`erf` kan användas för att beräkna traditionella "
"statistiska funktioner som t.ex. den kumulativa standardnormalfördelningen "
"<https://en.wikipedia.org/wiki/Cumulative_distribution_function>`_::"

msgid ""
"def phi(x):\n"
"    'Cumulative distribution function for the standard normal distribution'\n"
"    return (1.0 + erf(x / sqrt(2.0))) / 2.0"
msgstr ""
"def phi(x):\n"
"    \"Kumulativ fördelningsfunktion för standardnormalfördelningen\n"
"    returnera (1,0 + erf(x / sqrt(2,0)))) / 2.0"

msgid ""
"Return the complementary error function at *x*.  The `complementary error "
"function <https://en.wikipedia.org/wiki/Error_function>`_ is defined as "
"``1.0 - erf(x)``.  It is used for large values of *x* where a subtraction "
"from one would cause a `loss of significance <https://en.wikipedia.org/wiki/"
"Loss_of_significance>`_\\."
msgstr ""
"Returnerar den komplementära felfunktionen vid *x*.  Den komplementära "
"felfunktionen <https://en.wikipedia.org/wiki/Error_function>`_ definieras "
"som ``1,0 - erf(x)``.  Den används för stora värden på *x* där en "
"subtraktion från ett skulle orsaka en \"förlust av signifikans\" <https://en."
"wikipedia.org/wiki/Loss_of_significance>`_\\."

msgid ""
"Return the `Gamma function <https://en.wikipedia.org/wiki/Gamma_function>`_ "
"at *x*."
msgstr ""
"Returnera `Gamma-funktionen <https://en.wikipedia.org/wiki/Gamma_function>`_ "
"vid *x*."

msgid ""
"Return the natural logarithm of the absolute value of the Gamma function at "
"*x*."
msgstr ""
"Returnerar den naturliga logaritmen av absolutvärdet av Gamma-funktionen vid "
"*x*."

msgid "Constants"
msgstr "Konstanter"

msgid "The mathematical constant *π* = 3.141592..., to available precision."
msgstr ""
"Den matematiska konstanten *π* = 3,141592..., med tillgänglig precision."

msgid "The mathematical constant *e* = 2.718281..., to available precision."
msgstr ""
"Den matematiska konstanten *e* = 2,718281..., med tillgänglig precision."

msgid ""
"The mathematical constant *τ* = 6.283185..., to available precision. Tau is "
"a circle constant equal to 2\\ *π*, the ratio of a circle's circumference to "
"its radius. To learn more about Tau, check out Vi Hart's video `Pi is "
"(still) Wrong <https://vimeo.com/147792667>`_, and start celebrating `Tau "
"day <https://tauday.com/>`_ by eating twice as much pie!"
msgstr ""
"Den matematiska konstanten *τ* = 6,283185..., med tillgänglig precision. Tau "
"är en cirkelkonstant som är lika med 2\\ *π*, förhållandet mellan en cirkels "
"omkrets och dess radie. För att lära dig mer om Tau, kolla in Vi Harts video "
"`Pi is (still) Wrong <https://vimeo.com/147792667>`_, och börja fira `Tau "
"day <https://tauday.com/>`_ genom att äta dubbelt så mycket paj!"

msgid ""
"A floating-point positive infinity.  (For negative infinity, use ``-math."
"inf``.)  Equivalent to the output of ``float('inf')``."
msgstr ""
"En positiv oändlighet med flyttal.  (För negativ oändlighet, använd ``-math."
"inf``.) Motsvarar resultatet av ``float('inf')``."

msgid ""
"A floating-point \"not a number\" (NaN) value. Equivalent to the output of "
"``float('nan')``. Due to the requirements of the `IEEE-754 standard <https://"
"en.wikipedia.org/wiki/IEEE_754>`_, ``math.nan`` and ``float('nan')`` are not "
"considered to equal to any other numeric value, including themselves. To "
"check whether a number is a NaN, use the :func:`isnan` function to test for "
"NaNs instead of ``is`` or ``==``. Example:"
msgstr ""
"Ett flyttalsvärde som \"inte är ett tal\" (NaN). Motsvarar utmatningen från "
"``float('nan')``. På grund av kraven i standarden `IEEE-754 <https://en."
"wikipedia.org/wiki/IEEE_754>`_ anses ``math.nan`` och ``float('nan')`` inte "
"vara lika med något annat numeriskt värde, inklusive sig själva. För att "
"kontrollera om ett tal är ett NaN, använd funktionen :func:`isnan` för att "
"testa för NaN istället för ``is`` eller ``==``. Ett exempel:"

msgid "It is now always available."
msgstr "Den är nu alltid tillgänglig."

msgid ""
"The :mod:`math` module consists mostly of thin wrappers around the platform "
"C math library functions.  Behavior in exceptional cases follows Annex F of "
"the C99 standard where appropriate.  The current implementation will raise :"
"exc:`ValueError` for invalid operations like ``sqrt(-1.0)`` or ``log(0.0)`` "
"(where C99 Annex F recommends signaling invalid operation or divide-by-"
"zero), and :exc:`OverflowError` for results that overflow (for example, "
"``exp(1000.0)``).  A NaN will not be returned from any of the functions "
"above unless one or more of the input arguments was a NaN; in that case, "
"most functions will return a NaN, but (again following C99 Annex F) there "
"are some exceptions to this rule, for example ``pow(float('nan'), 0.0)`` or "
"``hypot(float('nan'), float('inf'))``."
msgstr ""
"Modulen :mod:`math` består mestadels av tunna omslag runt plattformens C-"
"matematiska biblioteksfunktioner.  Beteendet i undantagsfall följer Annex F "
"i C99-standarden där så är lämpligt.  Den nuvarande implementationen kommer "
"att ge :exc:`ValueError` för ogiltiga operationer som ``sqrt(-1,0)`` eller "
"``log(0,0)`` (där C99 Annex F rekommenderar att man signalerar ogiltig "
"operation eller dividerar med noll), och :exc:`OverflowError` för resultat "
"som överflödar (till exempel ``exp(1000,0)``).  Ett NaN kommer inte att "
"returneras från någon av funktionerna ovan om inte ett eller flera av "
"inmatningsargumenten var ett NaN; i så fall kommer de flesta funktioner att "
"returnera ett NaN, men (återigen enligt C99 Annex F) finns det några "
"undantag från denna regel, till exempel ``pow(float('nan'), 0.0)`` eller "
"``hypot(float('nan'), float('inf'))``."

msgid ""
"Note that Python makes no effort to distinguish signaling NaNs from quiet "
"NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior "
"is to treat all NaNs as though they were quiet."
msgstr ""
"Observera att Python inte gör något försök att skilja signalerande NaNs från "
"tysta NaNs, och beteendet för signalerande NaNs förblir ospecificerat. "
"Typiskt beteende är att behandla alla NaN som om de vore tysta."

msgid "Module :mod:`cmath`"
msgstr "Modul :mod:`cmath`"

msgid "Complex number versions of many of these functions."
msgstr "Komplexa talversioner av många av dessa funktioner."
