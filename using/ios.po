# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Using Python on iOS"
msgstr "Använda Python på iOS"

msgid "Authors"
msgstr "Författare"

msgid "Russell Keith-Magee (2024-03)"
msgstr "Russell Keith-Magee (2024-03)"

msgid ""
"Python on iOS is unlike Python on desktop platforms. On a desktop platform, "
"Python is generally installed as a system resource that can be used by any "
"user of that computer. Users then interact with Python by running a :program:"
"`python` executable and entering commands at an interactive prompt, or by "
"running a Python script."
msgstr ""
"Python på iOS är olikt Python på stationära plattformar. På en stationär "
"plattform installeras Python vanligtvis som en systemresurs som kan användas "
"av alla användare av den datorn. Användare interagerar sedan med Python "
"genom att köra en körbar :program:`python` och ange kommandon i en "
"interaktiv prompt, eller genom att köra ett Python-skript."

msgid ""
"On iOS, there is no concept of installing as a system resource. The only "
"unit of software distribution is an \"app\". There is also no console where "
"you could run a :program:`python` executable, or interact with a Python REPL."
msgstr ""
"På iOS finns det inget koncept för installation som en systemresurs. Den "
"enda enheten för distribution av programvara är en \"app\". Det finns inte "
"heller någon konsol där du kan köra en :program:`python`-körbar fil eller "
"interagera med en Python REPL."

msgid ""
"As a result, the only way you can use Python on iOS is in embedded mode - "
"that is, by writing a native iOS application, and embedding a Python "
"interpreter using ``libPython``, and invoking Python code using the :ref:"
"`Python embedding API <embedding>`. The full Python interpreter, the "
"standard library, and all your Python code is then packaged as a standalone "
"bundle that can be distributed via the iOS App Store."
msgstr ""
"Som ett resultat är det enda sättet du kan använda Python på iOS i inbäddat "
"läge - det vill säga genom att skriva en inbyggd iOS-applikation och bädda "
"in en Python-tolk med hjälp av ``libPython`` och anropa Python-kod med hjälp "
"av :ref:``Python embedding API <embedding>``. Den fullständiga Python-"
"tolken, standardbiblioteket och all din Python-kod paketeras sedan som ett "
"fristående paket som kan distribueras via iOS App Store."

msgid ""
"If you're looking to experiment for the first time with writing an iOS app "
"in Python, projects such as `BeeWare <https://beeware.org>`__ and `Kivy "
"<https://kivy.org>`__ will provide a much more approachable user experience. "
"These projects manage the complexities associated with getting an iOS "
"project running, so you only need to deal with the Python code itself."
msgstr ""
"Om du vill experimentera för första gången med att skriva en iOS-app i "
"Python, kommer projekt som `BeeWare <https://beeware.org>`__ och `Kivy "
"<https://kivy.org>`__ att ge en mycket mer lättillgänglig "
"användarupplevelse. Dessa projekt hanterar de komplexiteter som är "
"förknippade med att få ett iOS-projekt att köra, så att du bara behöver "
"hantera själva Python-koden."

msgid "Python at runtime on iOS"
msgstr "Python i körtid på iOS"

msgid "iOS version compatibility"
msgstr "kompatibilitet med iOS-versioner"

msgid ""
"The minimum supported iOS version is specified at compile time, using the :"
"option:`--host` option to ``configure``. By default, when compiled for iOS, "
"Python will be compiled with a minimum supported iOS version of 13.0. To use "
"a different minimum iOS version, provide the version number as part of the :"
"option:`!--host` argument - for example, ``--host=arm64-apple-ios15.4-"
"simulator`` would compile an ARM64 simulator build with a deployment target "
"of 15.4."
msgstr ""
"Den minsta iOS-versionen som stöds anges vid kompileringstillfället med "
"hjälp av alternativet :option:`--host` till ``configure``. När Python "
"kompileras för iOS kommer det som standard att kompileras med en minsta iOS-"
"version som stöds på 13.0. För att använda en annan minsta iOS-version, ange "
"versionsnumret som en del av :option:`!--host`-argumentet - till exempel, "
"``--host=arm64-apple-ios15.4-simulator`` skulle kompilera en ARM64-"
"simulatorbyggnad med ett implementeringsmål på 15.4."

msgid "Platform identification"
msgstr "Identifiering av plattform"

msgid ""
"When executing on iOS, ``sys.platform`` will report as ``ios``. This value "
"will be returned on an iPhone or iPad, regardless of whether the app is "
"running on the simulator or a physical device."
msgstr ""
"Vid exekvering på iOS kommer ``sys.platform`` att rapportera som ``ios``. "
"Detta värde kommer att returneras på en iPhone eller iPad, oavsett om appen "
"körs på simulatorn eller en fysisk enhet."

msgid ""
"Information about the specific runtime environment, including the iOS "
"version, device model, and whether the device is a simulator, can be "
"obtained using :func:`platform.ios_ver`. :func:`platform.system` will report "
"``iOS`` or ``iPadOS``, depending on the device."
msgstr ""
"Information om den specifika körtidsmiljön, inklusive iOS-versionen, "
"enhetsmodellen och om enheten är en simulator, kan erhållas med :func:"
"`platform.ios_ver`. :func:`platform.system` rapporterar ``iOS`` eller "
"``iPadOS``, beroende på enheten."

msgid ""
":func:`os.uname` reports kernel-level details; it will report a name of "
"``Darwin``."
msgstr ""
":func:`os.uname` rapporterar detaljer på kärnnivå; den kommer att rapportera "
"ett namn på ``Darwin``."

msgid "Standard library availability"
msgstr "Tillgänglighet för standardbibliotek"

msgid ""
"The Python standard library has some notable omissions and restrictions on "
"iOS. See the :ref:`API availability guide for iOS <mobile-availability>` for "
"details."
msgstr ""
"Pythons standardbibliotek har några anmärkningsvärda utelämnanden och "
"begränsningar på iOS. Se :ref:`API availability guide for iOS <mobile-"
"availability>` för mer information."

msgid "Binary extension modules"
msgstr "Binära tilläggsmoduler"

msgid ""
"One notable difference about iOS as a platform is that App Store "
"distribution imposes hard requirements on the packaging of an application. "
"One of these requirements governs how binary extension modules are "
"distributed."
msgstr ""
"En märkbar skillnad med iOS som plattform är att distributionen via App "
"Store ställer hårda krav på paketeringen av en applikation. Ett av dessa "
"krav reglerar hur binära tilläggsmoduler distribueras."

msgid ""
"The iOS App Store requires that *all* binary modules in an iOS app must be "
"dynamic libraries, contained in a framework with appropriate metadata, "
"stored in the ``Frameworks`` folder of the packaged app. There can be only a "
"single binary per framework, and there can be no executable binary material "
"outside the ``Frameworks`` folder."
msgstr ""
"IOS App Store kräver att *alla* binära moduler i en iOS-app måste vara "
"dynamiska bibliotek, som ingår i ett ramverk med lämpliga metadata, som "
"lagras i mappen ``Frameworks`` i den paketerade appen. Det får bara finnas "
"en enda binär modul per ramverk och det får inte finnas något körbart binärt "
"material utanför mappen \"Frameworks\"."

msgid ""
"This conflicts with the usual Python approach for distributing binaries, "
"which allows a binary extension module to be loaded from any location on "
"``sys.path``. To ensure compliance with App Store policies, an iOS project "
"must post-process any Python packages, converting ``.so`` binary modules "
"into individual standalone frameworks with appropriate metadata and signing. "
"For details on how to perform this post-processing, see the guide for :ref:"
"`adding Python to your project <adding-ios>`."
msgstr ""
"Detta strider mot den vanliga Python-metoden för distribution av binära "
"filer, som gör det möjligt att ladda en binär tilläggsmodul från valfri "
"plats på ``sys.path``. För att säkerställa efterlevnad av App Store-policyer "
"måste ett iOS-projekt efterbehandla alla Python-paket och konvertera binära "
"moduler av typen ``.so`` till enskilda fristående ramverk med lämpliga "
"metadata och signering. Mer information om hur du utför denna "
"efterbearbetning finns i guiden för :ref:``addding Python to your project "
"<adding-ios>``."

msgid ""
"To help Python discover binaries in their new location, the original ``.so`` "
"file on ``sys.path`` is replaced with a ``.fwork`` file. This file is a text "
"file containing the location of the framework binary, relative to the app "
"bundle. To allow the framework to resolve back to the original location, the "
"framework must contain a ``.origin`` file that contains the location of the "
"``.fwork`` file, relative to the app bundle."
msgstr ""
"För att hjälpa Python att upptäcka binärfiler på deras nya plats ersätts den "
"ursprungliga filen ``.so`` på ``sys.path`` med en fil ``.fwork``. Den här "
"filen är en textfil som innehåller platsen för ramverkets binärfil i "
"förhållande till appbunten. För att ramverket ska kunna återgå till den "
"ursprungliga platsen måste ramverket innehålla en fil med namnet ``.origin`` "
"som innehåller platsen för filen ``.fwork`` i förhållande till appbunten."

msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"Tänk till exempel på fallet med en import ``from foo.bar import _whiz``, där "
"``_whiz`` implementeras med den binära modulen ``sources/foo/bar/_whiz.abi3."
"so``, där ``sources`` är den plats som registrerats på ``sys.path``, "
"relativt programpaketet. Den här modulen *måste* distribueras som "
"``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (ramverkets namn skapas "
"från modulens fullständiga importsökväg), med en ``Info.plist``-fil i "
"katalogen ``.framework`` som identifierar binärfilen som ett ramverk. "
"Modulen ``foo.bar._whiz`` skulle representeras på den ursprungliga platsen "
"med en ``källor/foo/bar/_whiz.abi3.fwork`` markörfil, som innehåller "
"sökvägen ``Frameworks/foo.bar._whiz/foo.bar._whiz``. Ramverket skulle också "
"innehålla ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin``, som "
"innehåller sökvägen till filen ``.fwork``."

msgid ""
"When running on iOS, the Python interpreter will install an :class:"
"`~importlib.machinery.AppleFrameworkLoader` that is able to read and import "
"``.fwork`` files. Once imported, the ``__file__`` attribute of the binary "
"module will report as the location of the ``.fwork`` file. However, the :"
"class:`~importlib.machinery.ModuleSpec` for the loaded module will report "
"the ``origin`` as the location of the binary in the framework folder."
msgstr ""
"När du kör på iOS kommer Python-tolken att installera en :class:`~importlib."
"machinery.AppleFrameworkLoader` som kan läsa och importera ``.fwork``-filer. "
"När den har importerats kommer attributet ``__file__`` i den binära modulen "
"att rapportera platsen för filen ``.fwork``. Men :class:`~importlib."
"machinery.ModuleSpec` för den inlästa modulen kommer att rapportera "
"``origin`` som platsen för den binära filen i ramverksmappen."

msgid "Compiler stub binaries"
msgstr "Kompilatorns stubbinaries"

msgid ""
"Xcode doesn't expose explicit compilers for iOS; instead, it uses an "
"``xcrun`` script that resolves to a full compiler path (e.g., ``xcrun --sdk "
"iphoneos clang`` to get the ``clang`` for an iPhone device). However, using "
"this script poses two problems:"
msgstr ""
"Xcode exponerar inte explicita kompilatorer för iOS; istället använder det "
"ett ``xcrun``-skript som löser till en fullständig kompilatorsökväg (t.ex. "
"``xcrun --sdk iphoneos clang`` för att få ``clang`` för en iPhone-enhet). "
"Att använda detta skript innebär dock två problem:"

msgid ""
"The output of ``xcrun`` includes paths that are machine specific, resulting "
"in a sysconfig module that cannot be shared between users; and"
msgstr ""
"Utdata från ``xcrun`` innehåller sökvägar som är maskinspecifika, vilket "
"resulterar i en sysconfig-modul som inte kan delas mellan användare; och"

msgid ""
"It results in ``CC``/``CPP``/``LD``/``AR`` definitions that include spaces. "
"There is a lot of C ecosystem tooling that assumes that you can split a "
"command line at the first space to get the path to the compiler executable; "
"this isn't the case when using ``xcrun``."
msgstr ""
"Det resulterar i ``CC``/``CPP``/``LD``/``AR``-definitioner som innehåller "
"mellanslag. Det finns många verktyg för C-ekosystem som förutsätter att du "
"kan dela en kommandorad vid det första mellanslaget för att få sökvägen till "
"kompilatorns körbara fil; detta är inte fallet när du använder ``xcrun``."

msgid ""
"To avoid these problems, Python provided stubs for these tools. These stubs "
"are shell script wrappers around the underingly ``xcrun`` tools, distributed "
"in a ``bin`` folder distributed alongside the compiled iOS framework. These "
"scripts are relocatable, and will always resolve to the appropriate local "
"system paths. By including these scripts in the bin folder that accompanies "
"a framework, the contents of the ``sysconfig`` module becomes useful for end-"
"users to compile their own modules. When compiling third-party Python "
"modules for iOS, you should ensure these stub binaries are on your path."
msgstr ""
"För att undvika dessa problem tillhandahöll Python stubbar för dessa "
"verktyg. Dessa stubbar är skalskriptomslag runt de underliggande ``xcrun``-"
"verktygen, som distribueras i en ``bin``-mapp som distribueras tillsammans "
"med det kompilerade iOS-ramverket. Dessa skript är flyttbara och kommer "
"alltid att lösa upp till lämpliga lokala systemsökvägar. Genom att inkludera "
"dessa skript i bin-mappen som följer med ett ramverk blir innehållet i "
"modulen ``sysconfig`` användbart för slutanvändare som vill kompilera sina "
"egna moduler. När du kompilerar Python-moduler från tredje part för iOS bör "
"du se till att dessa stubbinaries finns på din sökväg."

msgid "Installing Python on iOS"
msgstr "Installera Python på iOS"

msgid "Tools for building iOS apps"
msgstr "Verktyg för att bygga iOS-appar"

msgid ""
"Building for iOS requires the use of Apple's Xcode tooling. It is strongly "
"recommended that you use the most recent stable release of Xcode. This will "
"require the use of the most (or second-most) recently released macOS "
"version, as Apple does not maintain Xcode for older macOS versions. The "
"Xcode Command Line Tools are not sufficient for iOS development; you need a "
"*full* Xcode install."
msgstr ""
"För att bygga för iOS krävs att du använder Apples Xcode-verktyg. Vi "
"rekommenderar starkt att du använder den senaste stabila versionen av Xcode. "
"Detta kräver att du använder den senaste (eller näst senaste) macOS-"
"versionen, eftersom Apple inte underhåller Xcode för äldre macOS-versioner. "
"Xcode Command Line Tools är inte tillräckligt för iOS-utveckling; du behöver "
"en *fullständig* Xcode-installation."

msgid ""
"If you want to run your code on the iOS simulator, you'll also need to "
"install an iOS Simulator Platform. You should be prompted to select an iOS "
"Simulator Platform when you first run Xcode. Alternatively, you can add an "
"iOS Simulator Platform by selecting from the Platforms tab of the Xcode "
"Settings panel."
msgstr ""
"Om du vill köra din kod på iOS-simulatorn måste du också installera en iOS "
"Simulator Platform. Du bör uppmanas att välja en iOS Simulator Platform när "
"du först kör Xcode. Alternativt kan du lägga till en iOS-simulatorplattform "
"genom att välja på fliken Plattformar i panelen Inställningar i Xcode."

msgid "Adding Python to an iOS project"
msgstr "Lägga till Python i ett iOS-projekt"

msgid ""
"Python can be added to any iOS project, using either Swift or Objective C. "
"The following examples will use Objective C; if you are using Swift, you may "
"find a library like `PythonKit <https://github.com/pvieito/PythonKit>`__ to "
"be helpful."
msgstr ""
"Python kan läggas till i alla iOS-projekt med hjälp av antingen Swift eller "
"Objective C. I följande exempel används Objective C; om du använder Swift "
"kan du ha nytta av ett bibliotek som `PythonKit <https://github.com/pvieito/"
"PythonKit>`__."

msgid "To add Python to an iOS Xcode project:"
msgstr "Så här lägger du till Python i ett iOS Xcode-projekt:"

msgid ""
"Build or obtain a Python ``XCFramework``. See the instructions in :source:"
"`iOS/README.rst` (in the CPython source distribution) for details on how to "
"build a Python ``XCFramework``. At a minimum, you will need a build that "
"supports ``arm64-apple-ios``, plus one of either ``arm64-apple-ios-"
"simulator`` or ``x86_64-apple-ios-simulator``."
msgstr ""
"Bygg eller hämta ett Python ``XCFramework``. Se instruktionerna i :source:"
"`iOS/README.rst` (i källdistributionen för CPython) för detaljer om hur man "
"bygger ett Python ``XCFramework``. Du behöver åtminstone ett bygge som "
"stöder ``arm64-apple-ios``, plus en av antingen ``arm64-apple-ios-"
"simulator`` eller ``x86_64-apple-ios-simulator``."

msgid ""
"Drag the ``XCframework`` into your iOS project. In the following "
"instructions, we'll assume you've dropped the ``XCframework`` into the root "
"of your project; however, you can use any other location that you want by "
"adjusting paths as needed."
msgstr ""
"Dra ``XCframework`` in i ditt iOS-projekt. I följande instruktioner antar vi "
"att du har släppt ``XCframework`` i roten till ditt projekt; du kan dock "
"använda vilken annan plats du vill genom att justera sökvägar efter behov."

msgid ""
"Drag the ``iOS/Resources/dylib-Info-template.plist`` file into your project, "
"and ensure it is associated with the app target."
msgstr ""
"Dra filen ``iOS/Resources/dylib-Info-template.plist`` till ditt projekt och "
"se till att den är associerad med appmålet."

msgid ""
"Add your application code as a folder in your Xcode project. In the "
"following instructions, we'll assume that your user code is in a folder "
"named ``app`` in the root of your project; you can use any other location by "
"adjusting paths as needed. Ensure that this folder is associated with your "
"app target."
msgstr ""
"Lägg till din applikationskod som en mapp i ditt Xcode-projekt. I följande "
"instruktioner antar vi att din användarkod finns i en mapp med namnet "
"``app`` i roten av ditt projekt; du kan använda någon annan plats genom att "
"justera sökvägar efter behov. Se till att den här mappen är kopplad till "
"ditt appmål."

msgid ""
"Select the app target by selecting the root node of your Xcode project, then "
"the target name in the sidebar that appears."
msgstr ""
"Välj appens mål genom att välja rotnoden i ditt Xcode-projekt och sedan "
"målnamnet i sidofältet som visas."

msgid ""
"In the \"General\" settings, under \"Frameworks, Libraries and Embedded "
"Content\", add ``Python.xcframework``, with \"Embed & Sign\" selected."
msgstr ""
"I inställningarna \"General\", under \"Frameworks, Libraries and Embedded "
"Content\", lägg till ``Python.xcframework``, med \"Embed & Sign\" markerat."

msgid "In the \"Build Settings\" tab, modify the following:"
msgstr "På fliken \"Build Settings\" ändrar du följande:"

msgid "Build Options"
msgstr "Byggalternativ"

msgid "User Script Sandboxing: No"
msgstr "Sandbox för användarskript: Nej"

msgid "Enable Testability: Yes"
msgstr "Aktivera testbarhet: Ja"

msgid "Search Paths"
msgstr "Sökvägar"

msgid "Framework Search Paths: ``$(PROJECT_DIR)``"
msgstr "Sökvägar för ramverk: ``$(PROJECT_DIR)``"

msgid ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"
msgstr ""
"Sökvägar för rubriker: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"

msgid "Apple Clang - Warnings - All languages"
msgstr "Apple Clang - Varningar - Alla språk"

msgid "Quoted Include In Framework Header: No"
msgstr "Quoted inkluderas i ramverkets huvud: Nej"

msgid ""
"Add a build step that copies the Python standard library into your app. In "
"the \"Build Phases\" tab, add a new \"Run Script\" build step *before* the "
"\"Embed Frameworks\" step, but *after* the \"Copy Bundle Resources\" step. "
"Name the step \"Install Target Specific Python Standard Library\", disable "
"the \"Based on dependency analysis\" checkbox, and set the script content to:"
msgstr ""
"Lägg till ett byggsteg som kopierar Pythons standardbibliotek till din app. "
"På fliken \"Build Phases\" lägger du till ett nytt byggsteg \"Run Script\" "
"*före* steget \"Embed Frameworks\", men *efter* steget \"Copy Bundle "
"Resources\". Döp steget till \"Install Target Specific Python Standard "
"Library\", avmarkera kryssrutan \"Based on dependency analysis\" och ställ "
"in skriptinnehållet till:"

msgid ""
"set -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Installing Python modules for iOS Simulator\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-"
"simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"else\n"
"    echo \"Installing Python modules for iOS Device\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" "
"\"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"
msgstr ""
"ställa in -e\n"
"\n"
"mkdir -p \"$CODESIGNING_FOLDER_PATH/python/lib\"\n"
"if [ \"$EFFECTIVE_PLATFORM_NAME\" = \"-iphonesimulator\" ]; then\n"
"    echo \"Installerar Python-moduler för iOS-simulatorn\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64_x86_64-"
"simulator/lib/\" \"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"annat\n"
"    echo \"Installerar Python-moduler för iOS-enhet\"\n"
"    rsync -au --delete \"$PROJECT_DIR/Python.xcframework/ios-arm64/lib/\" "
"\"$CODESIGNING_FOLDER_PATH/python/lib/\"\n"
"fi"

msgid ""
"Note that the name of the simulator \"slice\" in the XCframework may be "
"different, depending the CPU architectures your ``XCFramework`` supports."
msgstr ""
"Observera att namnet på simulatorns \"slice\" i XCframework kan vara "
"annorlunda beroende på vilka CPU-arkitekturer som stöds av ditt "
"``XCFramework``."

msgid ""
"Add a second build step that processes the binary extension modules in the "
"standard library into \"Framework\" format. Add a \"Run Script\" build step "
"*directly after* the one you added in step 8, named \"Prepare Python Binary "
"Modules\". It should also have \"Based on dependency analysis\" unchecked, "
"with the following script content:"
msgstr ""
"Lägg till ett andra byggsteg som bearbetar de binära tilläggsmodulerna i "
"standardbiblioteket till \"Framework\"-format. Lägg till ett byggsteg för "
"\"Run Script\" *direkt efter* det som du lade till i steg 8, med namnet "
"\"Prepare Python Binary Modules\". Det ska också ha \"Based on dependency "
"analysis\" avmarkerat, med följande skriptinnehåll:"

msgid ""
"set -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # The name of the extension file\n"
"    EXT=$(basename \"$FULL_EXT\")\n"
"    # The location of the extension file, relative to the bundle\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # The path to the extension file, relative to the install base\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # The full dotted name of the extension module, constructed from the "
"file path.\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \"."
"\");\n"
"    # A bundle identifier; not actually used, but required by Xcode "
"framework packaging\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME "
"| tr \"_\" \"-\")\n"
"    # The name of the framework folder.\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # If the framework folder doesn't exist, create it.\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Creating framework for $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Installing binary for $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/"
"$FULL_MODULE_NAME\"\n"
"    # Create a placeholder .fwork file where the .so was\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # Create a back reference to the .so file location in the framework\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/"
"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
" }\n"
"\n"
" PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
" echo \"Install Python $PYTHON_VER standard library extension modules...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name "
"\"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
" done\n"
"\n"
" # Clean up dylib template\n"
" rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
" echo \"Signing frameworks as $EXPANDED_CODE_SIGN_IDENTITY_NAME "
"($EXPANDED_CODE_SIGN_IDENTITY)...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /"
"usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" "
"${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-"
"metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"
msgstr ""
"ställa in -e\n"
"\n"
"install_dylib () {\n"
"    INSTALL_BASE=$1\n"
"    FULL_EXT=$2\n"
"\n"
"    # Namnet på tilläggsfilen\n"
"    EXT=$(basnamn \"$FULL_EXT\")\n"
"    # Platsen för tilläggsfilen, i förhållande till paketet\n"
"    RELATIVE_EXT=${FULL_EXT#$CODESIGNING_FOLDER_PATH/}\n"
"    # Sökvägen till tilläggsfilen, i förhållande till installationsbasen\n"
"    PYTHON_EXT=${RELATIVE_EXT/$INSTALL_BASE/}\n"
"    # Det fullständiga prickade namnet på tilläggsmodulen, konstruerat från "
"filsökvägen.\n"
"    FULL_MODULE_NAME=$(echo $PYTHON_EXT | cut -d \".\" -f 1 | tr \"/\" \"."
"\");\n"
"    # En paketidentifierare; används egentligen inte, men krävs för "
"paketering av Xcode-ramverket\n"
"    FRAMEWORK_BUNDLE_ID=$(echo $PRODUCT_BUNDLE_IDENTIFIER.$FULL_MODULE_NAME "
"| tr \"_\" \"-\")\n"
"    # Namnet på ramverksmappen.\n"
"    FRAMEWORK_FOLDER=\"Frameworks/$FULL_MODULE_NAME.framework\"\n"
"\n"
"    # Om ramverksmappen inte finns, skapa den.\n"
"    if [ ! -d \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\" ]; then\n"
"        echo \"Skapar ramverk för $RELATIVE_EXT\"\n"
"        mkdir -p \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER\"\n"
"        cp \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleExecutable -string \"$FULL_MODULE_NAME\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"        plutil -replace CFBundleIdentifier -string \"$FRAMEWORK_BUNDLE_ID\" "
"\"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/Info.plist\"\n"
"    fi\n"
"\n"
"    echo \"Installerar binärfil för $FRAMEWORK_FOLDER/$FULL_MODULE_NAME\"\n"
"    mv \"$FULL_EXT\" \"$CODESIGNING_FOLDER_PATH/$FRAMEWORK_FOLDER/"
"$FULL_MODULE_NAME\"\n"
"    # Skapa en platshållare för .fwork-filen där .so fanns\n"
"    echo \"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME\" > ${FULL_EXT%.so}.fwork\n"
"    # Skapa en bakre referens till .so-filens plats i ramverket\n"
"    echo \"${RELATIVE_EXT%.so}.fwork\" > \"$CODESIGNING_FOLDER_PATH/"
"$FRAMEWORK_FOLDER/$FULL_MODULE_NAME.origin\"\n"
" }\n"
"\n"
" PYTHON_VER=$(ls -1 \"$CODESIGNING_FOLDER_PATH/python/lib\")\n"
" echo \"Installera Python $PYTHON_VER standardbibliotekets "
"tilläggsmoduler ...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/python/lib/$PYTHON_VER/lib-dynload\" -name "
"\"*.so\" | while read FULL_EXT; do\n"
"    install_dylib python/lib/$PYTHON_VER/lib-dynload/ \"$FULL_EXT\"\n"
" done\n"
"\n"
" # Rensa upp dylib-mallen\n"
" rm -f \"$CODESIGNING_FOLDER_PATH/dylib-Info-template.plist\"\n"
"\n"
" echo \"Signerar ramverk som $EXPANDED_CODE_SIGN_IDENTITY_NAME "
"($EXPANDED_CODE_SIGN_IDENTITY) ...\"\n"
" find \"$CODESIGNING_FOLDER_PATH/Frameworks\" -name \"*.framework\" -exec /"
"usr/bin/codesign --force --sign \"$EXPANDED_CODE_SIGN_IDENTITY\" "
"${OTHER_CODE_SIGN_FLAGS:-} -o runtime --timestamp=none --preserve-"
"metadata=identifier,entitlements,flags --generate-entitlement-der \"{}\" \\;"

msgid ""
"Add Objective C code to initialize and use a Python interpreter in embedded "
"mode. You should ensure that:"
msgstr ""
"Lägg till Objective C-kod för att initiera och använda en Python-tolk i "
"inbäddat läge. Du bör se till att:"

msgid "UTF-8 mode (:c:member:`PyPreConfig.utf8_mode`) is *enabled*;"
msgstr "UTF-8-läget (:c:member:`PyPreConfig.utf8_mode`) är *aktiverat*;"

msgid "Buffered stdio (:c:member:`PyConfig.buffered_stdio`) is *disabled*;"
msgstr "Buffered stdio (:c:member:`PyConfig.buffered_stdio`) är *inaktiverad*;"

msgid "Writing bytecode (:c:member:`PyConfig.write_bytecode`) is *disabled*;"
msgstr ""
"Skrivning av bytecode (:c:member:`PyConfig.write_bytecode`) är *inaktiverad*;"

msgid ""
"Signal handlers (:c:member:`PyConfig.install_signal_handlers`) are *enabled*;"
msgstr ""
"Signalhanterare (:c:member:`PyConfig.install_signal_handlers`) är "
"*aktiverade*;"

msgid ""
"System logging (:c:member:`PyConfig.use_system_logger`) is *enabled* "
"(optional, but strongly recommended; this is enabled by default);"
msgstr ""
"Systemloggning (:c:member:`PyConfig.use_system_logger`) är *aktiverad* "
"(valfritt, men rekommenderas starkt; detta är aktiverat som standard);"

msgid ""
":envvar:`PYTHONHOME` for the interpreter is configured to point at the "
"``python`` subfolder of your app's bundle; and"
msgstr ""
":envvar:`PYTHONHOME` för tolken är konfigurerad att peka på undermappen "
"``python`` i din apps paket; och"

msgid "The :envvar:`PYTHONPATH` for the interpreter includes:"
msgstr ":envvar:`PYTHONPATH` för tolken inkluderar:"

msgid "the ``python/lib/python3.X`` subfolder of your app's bundle,"
msgstr "undermappen ``python/lib/python3.X`` i din apps paket,"

msgid ""
"the ``python/lib/python3.X/lib-dynload`` subfolder of your app's bundle, and"
msgstr "undermappen ``python/lib/python3.X/lib-dynload`` i din apps paket, och"

msgid "the ``app`` subfolder of your app's bundle"
msgstr "undermappen ``app`` i din apps paket"

msgid ""
"Your app's bundle location can be determined using ``[[NSBundle mainBundle] "
"resourcePath]``."
msgstr ""
"Appens bundle-plats kan bestämmas med hjälp av ``[[NSBundle mainBundle] "
"resourcePath]``."

msgid ""
"Steps 8, 9 and 10 of these instructions assume that you have a single folder "
"of pure Python application code, named ``app``. If you have third-party "
"binary modules in your app, some additional steps will be required:"
msgstr ""
"Steg 8, 9 och 10 i dessa instruktioner förutsätter att du har en enda mapp "
"med ren Python-applikationskod, som heter ``app``. Om du har binära moduler "
"från tredje part i din app krävs ytterligare några steg:"

msgid ""
"You need to ensure that any folders containing third-party binaries are "
"either associated with the app target, or copied in as part of step 8. Step "
"8 should also purge any binaries that are not appropriate for the platform a "
"specific build is targeting (i.e., delete any device binaries if you're "
"building an app targeting the simulator)."
msgstr ""
"Du måste se till att alla mappar som innehåller binärfiler från tredje part "
"antingen är associerade med appens mål eller kopieras in som en del av steg "
"8. I steg 8 bör du också rensa bort alla binärfiler som inte är lämpliga för "
"den plattform som en specifik build är inriktad på (dvs. ta bort alla "
"enhetsbinärfiler om du bygger en app som är inriktad på simulatorn)."

msgid ""
"Any folders that contain third-party binaries must be processed into "
"framework form by step 9. The invocation of ``install_dylib`` that processes "
"the ``lib-dynload`` folder can be copied and adapted for this purpose."
msgstr ""
"Alla mappar som innehåller binärfiler från tredje part måste bearbetas till "
"ramverksform i steg 9. Anropet av ``install_dylib`` som bearbetar mappen "
"``lib-dynload`` kan kopieras och anpassas för detta ändamål."

msgid ""
"If you're using a separate folder for third-party packages, ensure that "
"folder is included as part of the :envvar:`PYTHONPATH` configuration in step "
"10."
msgstr ""
"Om du använder en separat mapp för tredjepartspaket ska du se till att den "
"mappen ingår som en del av :envvar:`PYTHONPATH`-konfigurationen i steg 10."

msgid ""
"If any of the folders that contain third-party packages will contain ``."
"pth`` files, you should add that folder as a *site directory* (using :meth:"
"`site.addsitedir`), rather than adding to :envvar:`PYTHONPATH` or :attr:`sys."
"path` directly."
msgstr ""
"Om någon av mapparna som innehåller tredjepartspaket kommer att innehålla ``."
"pth``-filer bör du lägga till den mappen som en *site-katalog* (med :meth:"
"`site.addsitedir`), i stället för att lägga till den direkt i :envvar:"
"`PYTHONPATH` eller :attr:`sys.path`."

msgid "Testing a Python package"
msgstr "Testa ett Python-paket"

msgid ""
"The CPython source tree contains :source:`a testbed project <iOS/testbed>` "
"that is used to run the CPython test suite on the iOS simulator. This "
"testbed can also be used as a testbed project for running your Python "
"library's test suite on iOS."
msgstr ""
"CPythons källträd innehåller :source:`ett testbäddsprojekt <iOS/testbed>` "
"som används för att köra CPythons testsvit på iOS-simulatorn. Denna testbädd "
"kan också användas som ett testbäddsprojekt för att köra ditt Python-"
"biblioteks testsvit på iOS."

msgid ""
"After building or obtaining an iOS XCFramework (See :source:`iOS/README.rst` "
"for details), create a clone of the Python iOS testbed project by running:"
msgstr ""
"När du har byggt eller hämtat ett iOS XCFramework (se :source:`iOS/README."
"rst` för detaljer) skapar du en klon av Python iOS-testbäddsprojektet genom "
"att köra:"

msgid ""
"$ python iOS/testbed clone --framework <path/to/Python.xcframework> --app "
"<path/to/module1> --app <path/to/module2> app-testbed"
msgstr ""
"$ python iOS/testbed clone --framework <path/to/Python.xcframework> --app "
"<path/to/module1> --app <path/to/module2> app-testbed"

msgid ""
"You will need to modify the ``iOS/testbed`` reference to point to that "
"directory in the CPython source tree; any folders specified with the ``--"
"app`` flag will be copied into the cloned testbed project. The resulting "
"testbed will be created in the ``app-testbed`` folder. In this example, the "
"``module1`` and ``module2`` would be importable modules at runtime. If your "
"project has additional dependencies, they can be installed into the ``app-"
"testbed/iOSTestbed/app_packages`` folder (using ``pip install --target app-"
"testbed/iOSTestbed/app_packages`` or similar)."
msgstr ""
"Du måste ändra ``iOS/testbed``-referensen så att den pekar på den katalogen "
"i CPythons källträd; alla mappar som anges med flaggan ``--app`` kommer att "
"kopieras till det klonade testbäddsprojektet. Den resulterande testbädden "
"kommer att skapas i mappen ``app-testbed``. I det här exemplet skulle "
"``modul1`` och ``modul2`` vara importerbara moduler vid körning. Om ditt "
"projekt har ytterligare beroenden kan de installeras i mappen ``app-testbed/"
"iOSTestbed/app_packages`` (med hjälp av ``pip install --target app-testbed/"
"iOSTestbed/app_packages`` eller liknande)."

msgid ""
"You can then use the ``app-testbed`` folder to run the test suite for your "
"app, For example, if ``module1.tests`` was the entry point to your test "
"suite, you could run:"
msgstr ""
"Du kan sedan använda mappen ``app-testbed`` för att köra testsviten för din "
"app, Till exempel, om ``module1.tests`` var ingångspunkten till din "
"testsvit, kan du köra:"

msgid "$ python app-testbed run -- module1.tests"
msgstr "$ python app-testbed run -- module1.tests"

msgid ""
"This is the equivalent of running ``python -m module1.tests`` on a desktop "
"Python build. Any arguments after the ``--`` will be passed to the testbed "
"as if they were arguments to ``python -m`` on a desktop machine."
msgstr ""
"Detta motsvarar att köra ``python -m module1.tests`` på en Python-byggd på "
"skrivbordet. Alla argument efter ``--`` kommer att skickas till testbädden "
"som om de vore argument till ``python -m`` på en skrivbordsmaskin."

msgid "You can also open the testbed project in Xcode by running:"
msgstr "Du kan också öppna testbäddsprojektet i Xcode genom att köra:"

msgid "$ open app-testbed/iOSTestbed.xcodeproj"
msgstr "$ öppna app-testbed/iOSTestbed.xcodeproj"

msgid "This will allow you to use the full Xcode suite of tools for debugging."
msgstr ""
"Detta gör att du kan använda hela Xcode-sviten med verktyg för felsökning."

msgid "App Store Compliance"
msgstr "App Store-överensstämmelse"

msgid ""
"The only mechanism for distributing apps to third-party iOS devices is to "
"submit the app to the iOS App Store; apps submitted for distribution must "
"pass Apple's app review process. This process includes a set of automated "
"validation rules that inspect the submitted application bundle for "
"problematic code."
msgstr ""
"Den enda mekanismen för att distribuera appar till iOS-enheter från tredje "
"part är att skicka in appen till iOS App Store; appar som skickas in för "
"distribution måste passera Apples appgranskningsprocess. Denna process "
"innehåller en uppsättning automatiserade valideringsregler som inspekterar "
"det inlämnade applikationspaketet för problematisk kod."

msgid ""
"The Python standard library contains some code that is known to violate "
"these automated rules. While these violations appear to be false positives, "
"Apple's review rules cannot be challenged; so, it is necessary to modify the "
"Python standard library for an app to pass App Store review."
msgstr ""
"Pythons standardbibliotek innehåller viss kod som är känd för att bryta mot "
"dessa automatiserade regler. Även om dessa överträdelser verkar vara falskt "
"positiva kan Apples granskningsregler inte ifrågasättas, så det är "
"nödvändigt att modifiera Python-standardbiblioteket för att en app ska klara "
"App Store-granskningen."

msgid ""
"The Python source tree contains :source:`a patch file <Mac/Resources/app-"
"store-compliance.patch>` that will remove all code that is known to cause "
"issues with the App Store review process. This patch is applied "
"automatically when building for iOS."
msgstr ""
"Pythons källkodsträd innehåller :source:`en patchfil <Mac/Resources/app-"
"store-compliance.patch>` som tar bort all kod som är känd för att orsaka "
"problem med App Stores granskningsprocess. Denna patch tillämpas automatiskt "
"när du bygger för iOS."
