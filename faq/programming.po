# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Programming FAQ"
msgstr "Vanliga frågor om programmering"

msgid "Contents"
msgstr "Innehåll"

msgid "General Questions"
msgstr "Allmänna frågor"

msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr ""
"Finns det en debugger på källkodsnivå med brytpunkter, single-stepping, etc"

msgid "Yes."
msgstr "Ja."

msgid ""
"Several debuggers for Python are described below, and the built-in function :"
"func:`breakpoint` allows you to drop into any of them."
msgstr ""
"Flera debuggers för Python beskrivs nedan, och den inbyggda funktionen :func:"
"`breakpoint` gör att du kan hoppa in i vilken som helst av dem."

msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It "
"is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"Modulen pdb är en enkel men adekvat felsökare i konsolläge för Python. Den "
"är en del av Pythons standardbibliotek och :mod:`dokumenteras i Library "
"Reference Manual <pdb>`. Du kan också skriva din egen avlusare genom att "
"använda koden för pdb som ett exempel."

msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as `Tools/scripts/idle3 <https://"
"github.com/python/cpython/blob/main/Tools/scripts/idle3>`_), includes a "
"graphical debugger."
msgstr ""
"Den interaktiva utvecklingsmiljön IDLE, som ingår i standarddistributionen "
"av Python (normalt tillgänglig som `Tools/scripts/idle3 <https://github.com/"
"python/cpython/blob/main/Tools/scripts/idle3>`_), innehåller en grafisk "
"felsökare."

msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such "
"as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"PythonWin är en Python IDE som innehåller en GUI-felsökare baserad på pdb.  "
"PythonWin-felsökaren färgar brytpunkter och har en hel del coola funktioner, "
"till exempel felsökning av icke-PythonWin-program.  PythonWin är "
"tillgängligt som en del av `pywin32 <https://github.com/mhammond/pywin32>`_-"
"projektet och som en del av `ActivePython <https://www.activestate.com/"
"products/python/>`_-distributionen."

msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <https://eric-ide.python-projects.org/>`_ är en IDE som bygger på PyQt "
"och redigeringskomponenten Scintilla."

msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ är en gdb-liknande "
"felsökare."

msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"visual Studio Code <https://code.visualstudio.com/>`_ är en IDE med "
"felsökningsverktyg som kan integreras med programvara för versionshantering."

msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr ""
"Det finns ett antal kommersiella Python IDE:er som innehåller grafiska "
"debuggers. De inkluderar:"

msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`Wing IDE <https://wingware.com/>`_"

msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"

msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

msgid "Are there tools to help find bugs or perform static analysis?"
msgstr ""
"Finns det verktyg som hjälper till att hitta buggar eller utföra statisk "
"analys?"

msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help you "
"catch bugs sooner."
msgstr ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ och `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ gör grundläggande kontroller som "
"hjälper dig att hitta buggar snabbare."

msgid ""
"Static type checkers such as `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, and `Pytype <https://github.com/google/"
"pytype>`_ can check type hints in Python source code."
msgstr ""
"Statiska typkontrollprogram som `Mypy <https://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_ och `Pytype <https://github.com/google/pytype>`_ "
"kan kontrollera typtips i Pythons källkod."

msgid "How can I create a stand-alone binary from a Python script?"
msgstr "Hur kan jag skapa en fristående binär från ett Python-skript?"

msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"Du behöver inte kunna kompilera Python till C-kod om du bara vill ha ett "
"fristående program som användarna kan ladda ner och köra utan att först "
"behöva installera Python-distributionen.  Det finns ett antal verktyg som "
"fastställer den uppsättning moduler som krävs av ett program och binder "
"samman dessa moduler med en Python-binärfil för att producera en enda körbar "
"fil."

msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as `Tools/freeze <https://github.com/python/cpython/tree/main/Tools/"
"freeze>`_. It converts Python byte code to C arrays; with a C compiler you "
"can embed all your modules into a new program, which is then linked with the "
"standard Python modules."
msgstr ""
"Ett sätt är att använda verktyget freeze, som ingår i Pythons källträd som "
"`Tools/freeze <https://github.com/python/cpython/tree/main/Tools/freeze>`_. "
"Det konverterar Pythons bytekod till C-arrayer; med en C-kompilator kan du "
"bädda in alla dina moduler i ett nytt program, som sedan länkas med Pythons "
"standardmoduler."

msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in "
"the source directory (for built-in modules).  It then turns the bytecode for "
"modules written in Python into C code (array initializers that can be turned "
"into code objects using the marshal module) and creates a custom-made config "
"file that only contains those built-in modules which are actually used in "
"the program.  It then compiles the generated C code and links it with the "
"rest of the Python interpreter to form a self-contained binary which acts "
"exactly like your script."
msgstr ""
"Det fungerar genom att skanna din källkod rekursivt efter importmeddelanden "
"(i båda formerna) och leta efter modulerna i Pythons standardsökväg samt i "
"källkatalogen (för inbyggda moduler).  Därefter omvandlas bytekoden för "
"moduler skrivna i Python till C-kod (array-initialiserare som kan omvandlas "
"till kodobjekt med hjälp av marshal-modulen) och en skräddarsydd "
"konfigurationsfil skapas som endast innehåller de inbyggda moduler som "
"faktiskt används i programmet.  Därefter kompileras den genererade C-koden "
"och länkas med resten av Python-tolken för att bilda en fristående binär fil "
"som fungerar precis som ditt skript."

msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""
"Följande paket kan hjälpa till att skapa körbara konsol- och GUI-program:"

msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ (plattformsoberoende)"

msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <https://pyinstaller.org/>`_ (plattformsoberoende)"

msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-platform)"
msgstr ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ "
"(plattformsoberoende)"

msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ "
"(plattformsoberoende)"

msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr "`py2app <https://github.com/ronaldoussoren/py2app>`_ (endast macOS)"

msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <https://www.py2exe.org/>`_ (endast Windows)"

msgid "Are there coding standards or a style guide for Python programs?"
msgstr "Finns det kodningsstandarder eller en stilguide för Python-program?"

msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr ""
"Ja. Den kodningsstil som krävs för standardbiblioteksmoduler är dokumenterad "
"som :pep:`8`."

msgid "Core Language"
msgstr "Kärnspråk"

msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr "Varför får jag ett UnboundLocalError när variabeln har ett värde?"

msgid ""
"It can be a surprise to get the :exc:`UnboundLocalError` in previously "
"working code when it is modified by adding an assignment statement somewhere "
"in the body of a function."
msgstr ""
"Det kan vara en överraskning att få :exc:`UnboundLocalError` i tidigare "
"fungerande kod när den ändras genom att lägga till en assignment-sats "
"någonstans i en funktions kropp."

msgid "This code:"
msgstr "Den här koden:"

msgid "works, but this code:"
msgstr "fungerar, men den här koden:"

msgid "results in an :exc:`!UnboundLocalError`:"
msgstr "resulterar i en :exc:`!UnboundLocalError`:"

msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"Det beror på att när du gör en tilldelning till en variabel i ett scope, "
"blir variabeln lokal i detta scope och skuggar alla variabler med liknande "
"namn i det yttre scopet.  Eftersom den sista satsen i foo tilldelar ett nytt "
"värde till ``x``, känner kompilatorn igen den som en lokal variabel.  "
"Följaktligen när den tidigare ``print(x)`` försöker skriva ut den "
"oinitialiserade lokala variabeln och ett fel uppstår."

msgid ""
"In the example above you can access the outer scope variable by declaring it "
"global:"
msgstr ""
"I exemplet ovan kan du komma åt den yttre scopevariabeln genom att deklarera "
"den som global:"

msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you "
"are actually modifying the value of the variable in the outer scope:"
msgstr ""
"Denna uttryckliga deklaration krävs för att påminna dig om att du faktiskt "
"ändrar variabelns värde i det yttre omfånget (till skillnad från den ytligt "
"sett analoga situationen med klass- och instansvariabler):"

msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr ""
"Du kan göra något liknande i ett nästlat scope med hjälp av nyckelordet :"
"keyword:`nonlocal`:"

msgid "What are the rules for local and global variables in Python?"
msgstr "Vilka är reglerna för lokala och globala variabler i Python?"

msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"I Python är variabler som endast refereras till inom en funktion implicit "
"globala.  Om en variabel tilldelas ett värde någonstans inom funktionens "
"kropp antas den vara lokal om den inte uttryckligen deklareras som global."

msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time.  "
"You'd have to declare as global every reference to a built-in function or to "
"a component of an imported module.  This clutter would defeat the usefulness "
"of the ``global`` declaration for identifying side-effects."
msgstr ""
"Även om det är lite förvånande i början, förklarar en stunds övervägande "
"detta.  Å ena sidan ger kravet på :keyword:`global` för tilldelade variabler "
"en spärr mot oavsiktliga bieffekter.  Å andra sidan, om ``global`` krävdes "
"för alla globala referenser, skulle du använda ``global`` hela tiden.  Man "
"skulle vara tvungen att deklarera varje referens till en inbyggd funktion "
"eller till en komponent i en importerad modul som global.  Denna röra skulle "
"omintetgöra nyttan av ``global``-deklarationen för att identifiera "
"bieffekter."

msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr ""
"Varför returnerar lambdas som definieras i en loop med olika värden alla "
"samma resultat?"

msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr ""
"Antag att du använder en for-slinga för att definiera några olika lambdas "
"(eller till och med vanliga funktioner), t.ex.::"

msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda: x**2)"
msgstr ""
">>> rutor = []\n"
">>> för x i intervall(5):\n"
"... squares.append(lambda: x**2)"

msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"Detta ger dig en lista som innehåller 5 lambdas som beräknar ``x**2``.  Du "
"kan förvänta dig att när de anropas skulle de returnera ``0``, ``1``, ``4``, "
"``9`` och ``16``.  Men när du faktiskt försöker kommer du att se att de alla "
"returnerar ``16``::"

msgid ""
">>> squares[2]()\n"
"16\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> kvadrater[2]()\n"
"16\n"
">>> kvadrater[4]()\n"
"16"

msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by "
"changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"Detta beror på att ``x`` inte är lokalt för lambdan utan definieras i det "
"yttre scope, och den nås när lambdan anropas --- inte när den definieras.  I "
"slutet av slingan är värdet på ``x`` ``4``, så alla funktioner returnerar nu "
"``4**2``, dvs ``16``.  Du kan också verifiera detta genom att ändra värdet "
"på ``x`` och se hur resultaten av lambdas ändras::"

msgid ""
">>> x = 8\n"
">>> squares[2]()\n"
"64"
msgstr ""
">>> x = 8\n"
">>> kvadrater[2]()\n"
"64"

msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr ""
"För att undvika detta måste du spara värdena i variabler som är lokala för "
"lambdan, så att de inte är beroende av värdet på den globala ``x``::"

msgid ""
">>> squares = []\n"
">>> for x in range(5):\n"
"...     squares.append(lambda n=x: n**2)"
msgstr ""
">>> rutor = []\n"
">>> för x i intervall(5):\n"
"... squares.append(lambda n=x: n**2)"

msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in "
"the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"Här skapar ``n=x`` en ny variabel ``n`` som är lokal för lambdan och som "
"beräknas när lambdan definieras så att den har samma värde som ``x`` hade "
"vid den tidpunkten i loopen.  Detta innebär att värdet på ``n`` kommer att "
"vara ``0`` i den första lambdan, ``1`` i den andra, ``2`` i den tredje och "
"så vidare. Därför kommer varje lambda nu att returnera rätt resultat::"

msgid ""
">>> squares[2]()\n"
"4\n"
">>> squares[4]()\n"
"16"
msgstr ""
">>> kvadrater[2]()\n"
"4\n"
">>> kvadrater[4]()\n"
"16"

msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr ""
"Observera att detta beteende inte är unikt för lambdas, utan även gäller för "
"vanliga funktioner."

msgid "How do I share global variables across modules?"
msgstr "Hur delar jag globala variabler mellan moduler?"

msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then "
"becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected "
"everywhere.  For example:"
msgstr ""
"Det vanligaste sättet att dela information mellan moduler inom ett och samma "
"program är att skapa en speciell modul (ofta kallad config eller cfg).  "
"Importera bara config-modulen i alla moduler i ditt program; modulen blir då "
"tillgänglig som ett globalt namn.  Eftersom det bara finns en instans av "
"varje modul kommer alla ändringar som görs i modulobjektet att återspeglas "
"överallt.  Ett exempel:"

msgid "config.py::"
msgstr "config.py::"

msgid "x = 0   # Default value of the 'x' configuration setting"
msgstr "x = 0 # Standardvärde för konfigurationsinställningen \"x"

msgid "mod.py::"
msgstr "mod.py::"

msgid ""
"import config\n"
"config.x = 1"
msgstr ""
"import config\n"
"config.x = 1"

msgid "main.py::"
msgstr "main.py::"

msgid ""
"import config\n"
"import mod\n"
"print(config.x)"
msgstr ""
"import config\n"
"import mod\n"
"print(config.x)"

msgid ""
"Note that using a module is also the basis for implementing the singleton "
"design pattern, for the same reason."
msgstr ""
"Observera att användning av en modul också är grunden för att implementera "
"designmönstret singleton, av samma anledning."

msgid "What are the \"best practices\" for using import in a module?"
msgstr "Vilka är de \"bästa metoderna\" för att använda import i en modul?"

msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"I allmänhet ska du inte använda ``from modulename import *``.  Om du gör det "
"blir importörens namnrymd rörig och det blir mycket svårare för linters att "
"upptäcka odefinierade namn."

msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"Importera moduler längst upp i en fil.  På så sätt blir det tydligt vilka "
"andra moduler din kod kräver och du undviker frågor om modulnamnet är inom "
"räckvidden. Om du använder en import per rad är det enkelt att lägga till "
"och ta bort modulimporter, men om du använder flera importer per rad tar det "
"mindre plats på skärmen."

msgid "It's good practice if you import modules in the following order:"
msgstr "Det är bra om du importerar moduler i följande ordning:"

msgid ""
"standard library modules -- e.g. :mod:`sys`, :mod:`os`, :mod:`argparse`, :"
"mod:`re`"
msgstr ""
"standardbiblioteksmoduler -- t.ex. :mod:`sys`, :mod:`os`, :mod:`argparse`, :"
"mod:`re`"

msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL.Image`"
msgstr ""
"biblioteksmoduler från tredje part (allt som installeras i Pythons site-"
"packages-katalog) -- t.ex. :mod:`!dateutil`, :mod:`!requests`, :mod:`!PIL."
"Image`"

msgid "locally developed modules"
msgstr "lokalt utvecklade moduler"

msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr ""
"Det är ibland nödvändigt att flytta import till en funktion eller klass för "
"att undvika problem med cirkulär import.  Gordon McMillan säger:"

msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level.  "
"That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"Cirkulär import fungerar bra när båda modulerna använder importformen "
"\"import <module>\".  De misslyckas när den andra modulen vill hämta ett "
"namn från den första (\"from module import name\") och importen sker på "
"högsta nivån.  Det beror på att namnen i den första modulen ännu inte är "
"tillgängliga, eftersom den första modulen är upptagen med att importera den "
"andra."

msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"I det här fallet, om den andra modulen bara används i en funktion, kan "
"importen enkelt flyttas till den funktionen.  När importen anropas kommer "
"den första modulen att ha initialiserats färdigt och den andra modulen kan "
"göra sin import."

msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be "
"possible to import all of the modules at the top of the file.  In this case, "
"importing the correct modules in the corresponding platform-specific code is "
"a good option."
msgstr ""
"Det kan också vara nödvändigt att flytta importen från den översta kodnivån "
"om några av modulerna är plattformsspecifika.  I så fall kanske det inte ens "
"är möjligt att importera alla moduler högst upp i filen.  I så fall är det "
"ett bra alternativ att importera rätt moduler i motsvarande "
"plattformsspecifika kod."

msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is "
"especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module "
"the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"Flytta bara import till ett lokalt scope, t.ex. inuti en "
"funktionsdefinition, om det är nödvändigt för att lösa ett problem, t.ex. "
"för att undvika cirkulär import eller för att minska initialiseringstiden "
"för en modul.  Den här tekniken är särskilt användbar om många av importerna "
"är onödiga beroende på hur programmet exekveras.  Du kanske också vill "
"flytta importen till en funktion om modulerna bara används i den "
"funktionen.  Observera att det kan vara dyrt att ladda en modul första "
"gången eftersom modulen initialiseras en gång, men att ladda en modul flera "
"gånger är praktiskt taget gratis och kostar bara ett par "
"ordboksuppslagningar.  Även om modulnamnet har försvunnit finns modulen "
"förmodligen tillgänglig i :data:`sys.modules`."

msgid "Why are default values shared between objects?"
msgstr "Varför delas standardvärden mellan objekt?"

msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr ""
"Denna typ av bugg drabbar ofta nybörjare inom programmering.  Tänk på den "
"här funktionen::"

msgid ""
"def foo(mydict={}):  # Danger: shared reference to one dict for all calls\n"
"    ... compute something ...\n"
"    mydict[key] = value\n"
"    return mydict"
msgstr ""
"def foo(mydict={}):  # Fara: delad referens till en dict för alla anrop\n"
"    ... beräkna något ...\n"
"    mydict[nyckel] = värde\n"
"    returnera mydict"

msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins "
"executing, ``mydict`` starts out with an item already in it."
msgstr ""
"Första gången du anropar den här funktionen innehåller ``mydict`` ett enda "
"objekt.  Andra gången innehåller ``mydict`` två objekt eftersom när "
"``foo()`` börjar exekveras, börjar ``mydict`` med ett objekt redan i den."

msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"Man förväntar sig ofta att ett funktionsanrop skapar nya objekt för "
"standardvärden. Detta är inte vad som händer. Standardvärden skapas exakt en "
"gång, när funktionen definieras.  Om det objektet ändras, som ordboken i det "
"här exemplet, kommer efterföljande anrop av funktionen att hänvisa till det "
"ändrade objektet."

msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"Per definition är oföränderliga objekt som tal, strängar, tupler och "
"``None`` säkra från ändringar. Ändringar av föränderliga objekt som "
"ordböcker, listor och klassinstanser kan leda till förvirring."

msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"På grund av denna funktion är det god programmeringspraxis att inte använda "
"föränderliga objekt som standardvärden.  Använd istället ``None`` som "
"standardvärde och kontrollera i funktionen om parametern är ``None`` och "
"skapa en ny lista/dictionary/whatever om den är det.  Skriv till exempel "
"inte::"

msgid ""
"def foo(mydict={}):\n"
"    ..."
msgstr ""
"def foo(mydict={}):\n"
"    ..."

msgid "but::"
msgstr "men::"

msgid ""
"def foo(mydict=None):\n"
"    if mydict is None:\n"
"        mydict = {}  # create a new dict for local namespace"
msgstr ""
"def foo(mydict=None):\n"
"    om mydict är None:\n"
"        mydict = {} # skapa en ny dict för lokal namnrymd"

msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"Den här funktionen kan vara användbar.  När du har en funktion som är "
"tidskrävande att beräkna är en vanlig teknik att cachelagra parametrarna och "
"det resulterande värdet för varje anrop till funktionen och returnera det "
"cachelagrade värdet om samma värde begärs igen.  Detta kallas \"memoizing\" "
"och kan implementeras så här::"

msgid ""
"# Callers can only provide two parameters and optionally pass _cache by "
"keyword\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) in _cache:\n"
"        return _cache[(arg1, arg2)]\n"
"\n"
"    # Calculate the value\n"
"    result = ... expensive computation ...\n"
"    _cache[(arg1, arg2)] = result           # Store result in the cache\n"
"    return result"
msgstr ""
"# Anroparen kan bara ange två parametrar och eventuellt skicka _cache med "
"nyckelord\n"
"def expensive(arg1, arg2, *, _cache={}):\n"
"    if (arg1, arg2) i _cache:\n"
"        returnera _cache[(arg1, arg2)]\n"
"\n"
"    # Beräkna värdet\n"
"    resultat = ... dyr beräkning ...\n"
"    _cache[(arg1, arg2)] = result # Lagra resultatet i cacheminnet\n"
"    returnera resultat"

msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr ""
"Du kan använda en global variabel som innehåller en ordbok i stället för "
"standardvärdet; det är en smaksak."

msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr ""
"Hur kan jag skicka valfria parametrar eller nyckelordsparametrar från en "
"funktion till en annan?"

msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"Samla argumenten med hjälp av specifikatorerna ``*`` och ``**`` i "
"funktionens parameterlista, så att du får de positionella argumenten som en "
"tupel och nyckelordsargumenten som en ordbok.  Du kan sedan skicka dessa "
"argument när du anropar en annan funktion genom att använda ``*`` och "
"``**``::"

msgid ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['width'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"
msgstr ""
"def f(x, *args, **kwargs):\n"
"    ...\n"
"    kwargs['bredd'] = '14.3c'\n"
"    ...\n"
"    g(x, *args, **kwargs)"

msgid "What is the difference between arguments and parameters?"
msgstr "Vad är skillnaden mellan argument och parametrar?"

msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what :term:"
"`kind of arguments <parameter>` a function can accept.  For example, given "
"the function definition::"
msgstr ""
":term:`Parametrar <parameter>` definieras av de namn som förekommer i en "
"funktionsdefinition, medan :term:`argument <argument>` är de värden som "
"faktiskt skickas till en funktion när den anropas.  Parametrar definierar "
"vilken :term:`typ av argument <parameter>` som en funktion kan acceptera.  "
"Till exempel, givet funktionsdefinitionen::"

msgid ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"
msgstr ""
"def func(foo, bar=None, **kwargs):\n"
"    pass"

msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling "
"``func``, for example::"
msgstr ""
"*foo*, *bar* och *kwargs* är parametrar för ``func``.  Men när man anropar "
"``func``, till exempel::"

msgid "func(42, bar=314, extra=somevar)"
msgstr "func(42, bar=314, extra=somevar)"

msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "värdena ``42``, ``314`` och ``somevar`` är argument."

msgid "Why did changing list 'y' also change list 'x'?"
msgstr "Varför ändrades listan \"y\" samtidigt som listan \"x\" ändrades?"

msgid "If you wrote code like::"
msgstr "Om du skrev kod som::"

msgid ""
">>> x = []\n"
">>> y = x\n"
">>> y.append(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"
msgstr ""
">>> x = []\n"
">>> y = x\n"
">>> y.lägg till(10)\n"
">>> y\n"
"[10]\n"
">>> x\n"
"[10]"

msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr ""
"kanske du undrar varför ett tillägg av ett element till ``y`` ändrade ``x`` "
"också."

msgid "There are two factors that produce this result:"
msgstr "Det finns två faktorer som ger detta resultat:"

msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"Variabler är helt enkelt namn som refererar till objekt.  Om du gör ``y = "
"x`` skapas inte en kopia av listan - det skapas en ny variabel ``y`` som "
"refererar till samma objekt som ``x`` refererar till.  Det betyder att det "
"bara finns ett objekt (listan) och att både ``x`` och ``y`` refererar till "
"det."

msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr ""
"Listor är :term:`mutabla`, vilket innebär att du kan ändra deras innehåll."

msgid ""
"After the call to :meth:`!append`, the content of the mutable object has "
"changed from ``[]`` to ``[10]``.  Since both the variables refer to the same "
"object, using either name accesses the modified value ``[10]``."
msgstr ""
"Efter anropet till :meth:`!append` har innehållet i det föränderliga "
"objektet ändrats från ``[]`` till ``[10]``.  Eftersom båda variablerna "
"refererar till samma objekt får man tillgång till det modifierade värdet "
"``[10]`` om man använder något av namnen."

msgid "If we instead assign an immutable object to ``x``::"
msgstr "Om vi istället tilldelar ett oföränderligt objekt till ``x``::"

msgid ""
">>> x = 5  # ints are immutable\n"
">>> y = x\n"
">>> x = x + 1  # 5 can't be mutated, we are creating a new object here\n"
">>> x\n"
"6\n"
">>> y\n"
"5"
msgstr ""
">>> x = 5 # ints är oföränderliga\n"
">>> y = x\n"
">>> x = x + 1 # 5 kan inte muteras, vi skapar ett nytt objekt här\n"
">>> x\n"
"6\n"
">>> y\n"
"5"

msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is "
"because integers are :term:`immutable`, and when we do ``x = x + 1`` we are "
"not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"kan vi se att i detta fall är ``x`` och ``y`` inte lika längre.  Detta beror "
"på att heltal är :term:`immutable`, och när vi gör ``x = x + 1`` muterar vi "
"inte int ``5`` genom att öka dess värde; istället skapar vi ett nytt objekt "
"(int ``6``) och tilldelar det till ``x`` (det vill säga ändrar vilket objekt "
"``x`` refererar till).  Efter denna tilldelning har vi två objekt (int ``6`` "
"och ``5``) och två variabler som hänvisar till dem (``x`` hänvisar nu till "
"``6`` men ``y`` hänvisar fortfarande till ``5``)."

msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and :func:`sorted(y) <sorted>`) create a new object.  In general in "
"Python (and in all cases in the standard library) a method that mutates an "
"object will return ``None`` to help avoid getting the two types of "
"operations confused.  So if you mistakenly write ``y.sort()`` thinking it "
"will give you a sorted copy of ``y``, you'll instead end up with ``None``, "
"which will likely cause your program to generate an easily diagnosed error."
msgstr ""
"Vissa operationer (till exempel ``y.append(10)`` och ``y.sort()``) muterar "
"objektet, medan ytligt sett liknande operationer (till exempel ``y = y + "
"[10]`` och :func:`sorted(y) <sorted>`) skapar ett nytt objekt.  I allmänhet "
"i Python (och i alla fall i standardbiblioteket) kommer en metod som muterar "
"ett objekt att returnera ``None`` för att undvika att de två typerna av "
"operationer förväxlas.  Så om du felaktigt skriver ``y.sort()`` och tror att "
"det kommer att ge dig en sorterad kopia av ``y``, kommer du istället att "
"sluta med ``None``, vilket sannolikt kommer att leda till att ditt program "
"genererar ett lättdiagnostiserat fel."

msgid ""
"However, there is one class of operations where the same operation sometimes "
"has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"Det finns dock en klass av operationer där samma operation ibland har olika "
"beteenden med olika typer: de utökade tilldelningsoperatorerna.  Till "
"exempel muterar ``+=`` listor men inte tupler eller ints (``a_list += [1, 2, "
"3]`` motsvarar ``a_list.extend([1, 2, 3])`` och muterar ``a_list``, medan "
"``some_tuple += (1, 2, 3)`` och ``some_int += 1`` skapar nya objekt)."

msgid "In other words:"
msgstr "Med andra ord..:"

msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"Om vi har ett muterbart objekt (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), kan vi använda vissa specifika operationer för att mutera det och "
"alla variabler som hänvisar till det kommer att se förändringen."

msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"Om vi har ett oföränderligt objekt (:class:`str`, :class:`int`, :class:"
"`tuple`, etc.) kommer alla variabler som refererar till det alltid att ha "
"samma värde, men operationer som omvandlar det värdet till ett nytt värde "
"returnerar alltid ett nytt objekt."

msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"Om du vill veta om två variabler refererar till samma objekt eller inte, kan "
"du använda operatorn :keyword:`is` eller den inbyggda funktionen :func:`id`."

msgid "How do I write a function with output parameters (call by reference)?"
msgstr "Hur skriver jag en funktion med utparametrar (call by reference)?"

msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se.  "
"You can achieve the desired effect in a number of ways."
msgstr ""
"Kom ihåg att argument skickas via assignment i Python.  Eftersom tilldelning "
"bara skapar referenser till objekt finns det inget alias mellan ett "
"argumentnamn i den som anropar och den som tar emot anropet, och därmed "
"inget anrop genom referens i sig.  Du kan uppnå önskad effekt på ett antal "
"olika sätt."

msgid "By returning a tuple of the results::"
msgstr "Genom att returnera en tupel av resultaten::"

msgid ""
">>> def func1(a, b):\n"
"...     a = 'new-value'        # a and b are local names\n"
"...     b = b + 1              # assigned to new objects\n"
"...     return a, b            # return new values\n"
"...\n"
">>> x, y = 'old-value', 99\n"
">>> func1(x, y)\n"
"('new-value', 100)"
msgstr ""
">>> def func1(a, b):\n"
"... a = 'nytt värde' # a och b är lokala namn\n"
"... b = b + 1 # tilldelas nya objekt\n"
"... return a, b # returnerar nya värden\n"
"...\n"
">>> x, y = 'gammalt värde', 99\n"
">>> func1(x, y)\n"
"('nytt värde', 100)"

msgid "This is almost always the clearest solution."
msgstr "Detta är nästan alltid den tydligaste lösningen."

msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr ""
"Genom att använda globala variabler.  Detta är inte trådsäkert och "
"rekommenderas inte."

msgid "By passing a mutable (changeable in-place) object::"
msgstr "Genom att skicka ett muterbart (förändringsbart på plats) objekt::"

msgid ""
">>> def func2(a):\n"
"...     a[0] = 'new-value'     # 'a' references a mutable list\n"
"...     a[1] = a[1] + 1        # changes a shared object\n"
"...\n"
">>> args = ['old-value', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['new-value', 100]"
msgstr ""
">>> def func2(a):\n"
"... a[0] = 'nytt-värde' # 'a' refererar till en föränderlig lista\n"
"... a[1] = a[1] + 1 # ändrar ett delat objekt\n"
"...\n"
">>> args = ['gammalt-värde', 99]\n"
">>> func2(args)\n"
">>> args\n"
"['nytt värde', 100]"

msgid "By passing in a dictionary that gets mutated::"
msgstr "Genom att skicka in en ordbok som muteras::"

msgid ""
">>> def func3(args):\n"
"...     args['a'] = 'new-value'     # args is a mutable dictionary\n"
"...     args['b'] = args['b'] + 1   # change it in-place\n"
"...\n"
">>> args = {'a': 'old-value', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> def func3(args):\n"
"... args['a'] = 'nytt värde' # args är en föränderlig ordbok\n"
"... args['b'] = args['b'] + 1 # ändra det på plats\n"
"...\n"
">>> args = {'a': 'gammalt värde', 'b': 99}\n"
">>> func3(args)\n"
">>> args\n"
"{'a': 'nytt värde', 'b': 100}"

msgid "Or bundle up values in a class instance::"
msgstr "Eller samla ihop värden i en klassinstans::"

msgid ""
">>> class Namespace:\n"
"...     def __init__(self, /, **args):\n"
"...         for key, value in args.items():\n"
"...             setattr(self, key, value)\n"
"...\n"
">>> def func4(args):\n"
"...     args.a = 'new-value'        # args is a mutable Namespace\n"
"...     args.b = args.b + 1         # change object in-place\n"
"...\n"
">>> args = Namespace(a='old-value', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'new-value', 'b': 100}"
msgstr ""
">>> klass Namnrymd:\n"
"... def __init__(self, /, **args):\n"
"... for key, value in args.items():\n"
"... setattr(self, nyckel, värde)\n"
"...\n"
">>> def func4(args):\n"
"... args.a = 'nytt-värde' # args är ett föränderligt Namespace\n"
"... args.b = args.b + 1 # ändra objekt på plats\n"
"...\n"
">>> args = Namespace(a='gammalt-värde', b=99)\n"
">>> func4(args)\n"
">>> vars(args)\n"
"{'a': 'nytt värde', 'b': 100}"

msgid "There's almost never a good reason to get this complicated."
msgstr ""
"Det finns nästan aldrig någon bra anledning att göra det så här komplicerat."

msgid "Your best choice is to return a tuple containing the multiple results."
msgstr ""
"Det bästa alternativet är att returnera en tupel som innehåller flera "
"resultat."

msgid "How do you make a higher order function in Python?"
msgstr "Hur gör man en funktion av högre ordning i Python?"

msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested "
"scopes::"
msgstr ""
"Du har två val: du kan använda nästlade scopes eller så kan du använda "
"anropsbara objekt. Anta till exempel att du vill definiera ``linear(a,b)`` "
"som returnerar en funktion ``f(x)`` som beräknar värdet ``a*x+b``.  Använda "
"nästlade scopes::"

msgid ""
"def linear(a, b):\n"
"    def result(x):\n"
"        return a * x + b\n"
"    return result"
msgstr ""
"def linear(a, b):\n"
"    def resultat(x):\n"
"        returnerar a * x + b\n"
"    returnera resultat"

msgid "Or using a callable object::"
msgstr "Eller använda ett anropsbart objekt::"

msgid ""
"class linear:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"
msgstr ""
"klass linjär:\n"
"\n"
"    def __init__(self, a, b):\n"
"        self.a, self.b = a, b\n"
"\n"
"    def __call__(self, x):\n"
"        return self.a * x + self.b"

msgid "In both cases, ::"
msgstr "I båda fallen gäller::"

msgid "taxes = linear(0.3, 2)"
msgstr "skatter = linjär(0,3, 2)"

msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "ger ett anropbart objekt där ``taxes(10e6) == 0,3 * 10e6 + 2``."

msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr ""
"Metoden med anropsbara objekt har nackdelen att den är lite långsammare och "
"resulterar i något längre kod.  Observera dock att en samling callables kan "
"dela sin signatur via arv::"

msgid ""
"class exponential(linear):\n"
"    # __init__ inherited\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"
msgstr ""
"klass exponentiell(linjär):\n"
"    # __init__ nedärvd\n"
"    def __call__(self, x):\n"
"        return self.a * (x ** self.b)"

msgid "Object can encapsulate state for several methods::"
msgstr "Objekt kan kapsla in tillstånd för flera metoder::"

msgid ""
"class counter:\n"
"\n"
"    value = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = counter()\n"
"inc, dec, reset = count.up, count.down, count.set"
msgstr ""
"klassräknare:\n"
"\n"
"    värde = 0\n"
"\n"
"    def set(self, x):\n"
"        self.value = x\n"
"\n"
"    def up(self):\n"
"        self.value = self.value + 1\n"
"\n"
"    def down(self):\n"
"        self.value = self.value - 1\n"
"\n"
"count = räknare()\n"
"inc, dec, reset = count.up, count.down, count.set"

msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the "
"same counting variable."
msgstr ""
"Här fungerar ``inc()``, ``dec()`` och ``reset()`` som funktioner som delar "
"samma räknevariabel."

msgid "How do I copy an object in Python?"
msgstr "Hur kopierar jag ett objekt i Python?"

msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"I allmänhet kan du prova :func:`copy.copy` eller :func:`copy.deepcopy` för "
"det allmänna fallet. Alla objekt kan inte kopieras, men de flesta kan det."

msgid ""
"Some objects can be copied more easily.  Dictionaries have a :meth:`~dict."
"copy` method::"
msgstr ""
"Vissa objekt kan kopieras lättare.  Dictionaries har en :meth:`~dict.copy` "
"metod::"

msgid "newdict = olddict.copy()"
msgstr "newdict = olddict.copy()"

msgid "Sequences can be copied by slicing::"
msgstr "Sekvenser kan kopieras genom att skära::"

msgid "new_l = l[:]"
msgstr "ny_l = l[:]"

msgid "How can I find the methods or attributes of an object?"
msgstr "Hur hittar jag metoder eller attribut för ett objekt?"

msgid ""
"For an instance ``x`` of a user-defined class, :func:`dir(x) <dir>` returns "
"an alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"För en instans ``x`` av en användardefinierad klass returnerar :func:`dir(x) "
"<dir>` en alfabetiserad lista över de namn som innehåller de "
"instansattribut, metoder och attribut som definieras av klassen."

msgid "How can my code discover the name of an object?"
msgstr "Hur kan min kod ta reda på namnet på ett objekt?"

msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"Generellt sett kan det inte det, eftersom objekt egentligen inte har några "
"namn. I princip binder assignment alltid ett namn till ett värde; samma sak "
"gäller för ``def`` och ``class`` statements, men i det fallet är värdet en "
"callable. Tänk på följande kod::"

msgid ""
">>> class A:\n"
"...     pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A object at 0x16D07CC>\n"
">>> print(a)\n"
"<__main__.A object at 0x16D07CC>"
msgstr ""
">>> klass A:\n"
"... pass\n"
"...\n"
">>> B = A\n"
">>> a = B()\n"
">>> b = a\n"
">>> print(b)\n"
"<__main__.A objekt på 0x16D07CC>\n"
">>> Skriv ut(a)\n"
"<__main__.A object at 0x16D07CC> >>> print(a)"

msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name ``B`` the created instance is still reported as an "
"instance of class ``A``.  However, it is impossible to say whether the "
"instance's name is ``a`` or ``b``, since both names are bound to the same "
"value."
msgstr ""
"Man kan hävda att klassen har ett namn: även om den är bunden till två namn "
"och anropas via namnet ``B`` rapporteras den skapade instansen fortfarande "
"som en instans av klassen ``A``.  Det är dock omöjligt att säga om "
"instansens namn är ``a`` eller ``b``, eftersom båda namnen är bundna till "
"samma värde."

msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"Generellt sett bör det inte vara nödvändigt för din kod att \"känna till "
"namnen\" på vissa värden. Om du inte avsiktligt skriver introspektiva "
"program är detta vanligtvis en indikation på att det kan vara bra att ändra "
"tillvägagångssätt."

msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr ""
"I comp.lang.python gav Fredrik Lundh en gång en utmärkt liknelse som svar på "
"denna fråga:"

msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"På samma sätt som du får reda på namnet på katten du hittade på din veranda: "
"katten (objektet) själv kan inte berätta vad den heter, och den bryr sig "
"egentligen inte - så det enda sättet att få reda på vad den heter är att "
"fråga alla dina grannar (namnrymder) om det är deras katt (objekt)..."

msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr ""
".... och bli inte förvånad om du upptäcker att den är känd under många namn, "
"eller inget namn alls!"

msgid "What's up with the comma operator's precedence?"
msgstr "Vad är det med kommatecknets företräde?"

msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "Komma är inte en operator i Python.  Tänk på denna session::"

msgid ""
">>> \"a\" in \"b\", \"a\"\n"
"(False, 'a')"
msgstr ""
">>> \"a\" i \"b\", \"a\"\n"
"(Falskt, \"a\")"

msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr ""
"Eftersom kommatecknet inte är en operator, utan en separator mellan uttryck, "
"utvärderas ovanstående som om du hade skrivit::"

msgid "(\"a\" in \"b\"), \"a\""
msgstr "(\"a\" i \"b\"), \"a\""

msgid "not::"
msgstr "inte::"

msgid "\"a\" in (\"b\", \"a\")"
msgstr "\"a\" i (\"b\", \"a\")"

msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr ""
"Detsamma gäller för de olika tilldelningsoperatorerna (``=``, ``+=`` etc).  "
"De är egentligen inte operatorer utan syntaktiska avgränsare i assignment-"
"satser."

msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "Finns det en motsvarighet till C:s \"?:\" ternära operator?"

msgid "Yes, there is. The syntax is as follows::"
msgstr "Ja, det finns det. Syntaxen är som följer::"

msgid ""
"[on_true] if [expression] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x if x < y else y"
msgstr ""
"[on_true] if [expression] else [on_false]\n"
"\n"
"x, y = 50, 25\n"
"small = x om x < y annars y"

msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr ""
"Innan denna syntax introducerades i Python 2.5 var ett vanligt idiom att "
"använda logiska operatorer::"

msgid "[expression] and [on_true] or [on_false]"
msgstr "[uttryck] och [on_true] eller [on_false]"

msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"Detta idiom är dock osäkert, eftersom det kan ge fel resultat när *on_true* "
"har ett falskt booleskt värde.  Därför är det alltid bättre att använda "
"formen ``... if ... else ...``."

msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr "Är det möjligt att skriva obfuskerade one-liners i Python?"

msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within :keyword:`!"
"lambda`.  See the following three examples, slightly adapted from Ulf "
"Bartelt::"
msgstr ""
"Ja, det gör jag.  Vanligtvis görs detta genom att nesta :keyword:`lambda` "
"inom :keyword:`!lambda`.  Se följande tre exempel, något anpassade från Ulf "
"Bartelt::"

msgid ""
"from functools import reduce\n"
"\n"
"# Primes < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# First 10 Fibonacci numbers\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), range(10))))\n"
"\n"
"# Mandelbrot set\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda "
"y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y\n"
">=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"#    \\___ ___/  \\___ ___/  |   |   |__ lines on screen\n"
"#        V          V      |   |______ columns on screen\n"
"#        |          |      |__________ maximum of \"iterations\"\n"
"#        |          |_________________ range on y axis\n"
"#        |____________________________ range on x axis"
msgstr ""
"från functools import reduce\n"
"\n"
"# Primtal < 1000\n"
"print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,\n"
"map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))\n"
"\n"
"# De första 10 Fibonacci-numren\n"
"print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:\n"
"f(x,f), intervall(10))))\n"
"\n"
"# Mandelbrotuppsättningen\n"
"print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\\n'+y,map(lambda "
"y,\n"
"Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,\n"
"Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,\n"
"i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)eller (x*x+y*y\n"
">=4.0) eller 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(\n"
"64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy\n"
"))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))\n"
"# \\___ ___/ \\___ ___/ | | |__ rader på skärmen\n"
"# V V | |______ kolumner på skärmen\n"
"# | | |__________ maximalt antal \"iterationer\"\n"
"# | |_________________ intervall på y-axeln\n"
"# |____________________________ intervall på x-axeln"

msgid "Don't try this at home, kids!"
msgstr "Prova inte det här hemma, barn!"

msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr "Vad betyder snedstrecket(/) i parameterlistan för en funktion?"

msgid ""
"A slash in the argument list of a function denotes that the parameters prior "
"to it are positional-only.  Positional-only parameters are the ones without "
"an externally usable name.  Upon calling a function that accepts positional-"
"only parameters, arguments are mapped to parameters based solely on their "
"position. For example, :func:`divmod` is a function that accepts positional-"
"only parameters. Its documentation looks like this::"
msgstr ""
"Ett snedstreck i argumentlistan för en funktion anger att parametrarna före "
"det är enbart positionella.  Endast positionella parametrar är de som saknar "
"ett externt användbart namn.  När du anropar en funktion som accepterar "
"enbart positionella parametrar mappas argumenten till parametrar enbart "
"baserat på deras position. Exempelvis är :func:`divmod` en funktion som "
"accepterar enbart positionella parametrar. Dess dokumentation ser ut så här::"

msgid ""
">>> help(divmod)\n"
"Help on built-in function divmod in module builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."
msgstr ""
">>> hjälp(divmod)\n"
"Hjälp om den inbyggda funktionen divmod i modulen builtins:\n"
"\n"
"divmod(x, y, /)\n"
"    Returnerar tupeln (x//y, x%y).  Invariant: div*y + mod == x."

msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr ""
"Snedstrecket i slutet av parameterlistan betyder att båda parametrarna "
"endast är positionella. Således skulle ett anrop av :func:`divmod` med "
"nyckelordsargument leda till ett fel::"

msgid ""
">>> divmod(x=3, y=4)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: divmod() takes no keyword arguments"
msgstr ""
"&gt;&gt;&gt; divmod(x=3, y=4)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: divmod() tar inga nyckelordsargument"

msgid "Numbers and strings"
msgstr "Siffror och strängar"

msgid "How do I specify hexadecimal and octal integers?"
msgstr "Hur anger jag hexadecimala och oktala heltal?"

msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"För att ange en oktalsiffra föregår du oktalvärdet med en nolla och sedan "
"ett litet eller stort \"o\".  Om du till exempel vill ställa in variabeln "
"\"a\" till oktalvärdet \"10\" (8 i decimal) skriver du::"

msgid ""
">>> a = 0o10\n"
">>> a\n"
"8"
msgstr ""
">>> a = 0o10\n"
">>> a\n"
"8"

msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"Hexadecimalt är lika enkelt.  Det hexadecimala talet föregås helt enkelt av "
"en nolla och sedan ett \"x\" med liten eller stor bokstav.  Hexadecimala "
"siffror kan anges med små eller stora bokstäver.  Till exempel i Python-"
"tolken::"

msgid ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"
msgstr ""
">>> a = 0xa5\n"
">>> a\n"
"165\n"
">>> b = 0XB2\n"
">>> b\n"
"178"

msgid "Why does -22 // 10 return -3?"
msgstr "Varför returnerar -22 // 10 -3?"

msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"Den drivs främst av önskemålet att ``i % j`` ska ha samma tecken som ``j``. "
"Om du vill ha det, och också vill ha::"

msgid "i == (i // j) * j + (i % j)"
msgstr "i == (i // j) * j + (i % j)"

msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"så måste heltalsdivision ge golvet.  C kräver också att identiteten ska "
"gälla, och då måste kompilatorer som trunkerar ``i // j`` se till att ``i % "
"j`` har samma tecken som ``i``."

msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"Det finns få verkliga användningsfall för ``i % j`` när ``j`` är negativ.  "
"När ``j`` är positiv finns det många, och i praktiskt taget alla är det mer "
"användbart för ``i % j`` att vara ``>= 0``.  Om klockan visar 10 nu, vad "
"visade den då för 200 timmar sedan?  ``-190 % 12 == 2`` är användbart; "
"``-190 % 12 == -10`` är en bugg som väntar på att bita."

msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "Hur får jag int literal-attribut istället för SyntaxError?"

msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a :"
"exc:`SyntaxError` because the period is seen as a decimal point::"
msgstr ""
"Att försöka slå upp ett ``int`` bokstavligt attribut på normalt sätt ger "
"ett :exc:`SyntaxError` eftersom punkten ses som ett decimaltecken::"

msgid ""
">>> 1.__class__\n"
"  File \"<stdin>\", line 1\n"
"  1.__class__\n"
"   ^\n"
"SyntaxError: invalid decimal literal"
msgstr ""
"&gt;&gt;&gt; 1.__class__\n"
"  Fil \"<stdin>\", rad 1\n"
"  1.__klass\n"
"   ^\n"
"SyntaxError: ogiltig decimal bokstav"

msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr ""
"Lösningen är att skilja bokstav från punkt med antingen ett mellanslag eller "
"en parentes."

msgid "How do I convert a string to a number?"
msgstr "Hur konverterar jag en sträng till ett tal?"

msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to a floating-"
"point number, e.g. ``float('144') == 144.0``."
msgstr ""
"För heltal används den inbyggda typkonstruktören :func:`int`, t.ex. "
"``int('144') == 144``.  På samma sätt konverterar :func:`float` till ett "
"flyttal, t.ex. ``float('144') == 144.0``."

msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"Som standard tolkar dessa talet som decimaltal, så att ``int('0144') == "
"144`` är sant och ``int('0x144')`` ger upphov till :exc:`ValueError`. "
"``int(string, base)`` tar basen att konvertera från som ett andra valfritt "
"argument, så ``int( '0x144', 16) == 324``.  Om basen anges som 0 tolkas "
"talet enligt Pythons regler: ett inledande '0o' indikerar oktal och '0x' "
"indikerar ett hextal."

msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"Använd inte den inbyggda funktionen :func:`eval` om allt du behöver är att "
"konvertera strängar till tal. :func:`eval` blir betydligt långsammare och "
"det innebär en säkerhetsrisk: någon kan skicka ett Python-uttryck till dig "
"som kan ha oönskade bieffekter.  Till exempel skulle någon kunna skicka "
"```__import__('os').system(\"rm -rf $HOME\")`` vilket skulle radera din "
"hemkatalog."

msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python "
"does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` har också effekten att siffror tolkas som Python-uttryck, så "
"att t.ex. ``eval('09')`` ger ett syntaxfel eftersom Python inte tillåter "
"inledande '0' i ett decimaltal (utom '0')."

msgid "How do I convert a number to a string?"
msgstr "Hur konverterar jag ett tal till en sträng?"

msgid ""
"To convert, e.g., the number ``144`` to the string ``'144'``, use the built-"
"in type constructor :func:`str`.  If you want a hexadecimal or octal "
"representation, use the built-in functions :func:`hex` or :func:`oct`.  For "
"fancy formatting, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections, e.g. ``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\"."
"format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"För att konvertera t.ex. talet ``144`` till strängen ``'144'``, använd den "
"inbyggda typkonstruktören :func:`str`.  Om du vill ha en hexadecimal eller "
"oktal representation, använd de inbyggda funktionerna :func:`hex` eller :"
"func:`oct`.  För tjusig formatering, se avsnitten :ref:`f-strings` och :ref:"
"`formatstrings`, t.ex. ``\"{:04d}\".format(144)`` ger ``'0144'`` och "
"``\"{:.3f}\".format(1.0/3.0)`` ger ``'0.333'``."

msgid "How do I modify a string in place?"
msgstr "Hur ändrar jag en sträng på plats?"

msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it "
"from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"Det kan du inte, eftersom strängar är oföränderliga.  I de flesta "
"situationer bör du helt enkelt konstruera en ny sträng från de olika delar "
"som du vill sätta ihop den av.  Men om du behöver ett objekt med möjlighet "
"att modifiera unicode-data på plats kan du försöka använda ett :class:`io."
"StringIO`-objekt eller :mod:`array`-modulen::"

msgid ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('w', s)\n"
">>> print(a)\n"
"array('w', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('w', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"
msgstr ""
">>> import io\n"
">>> s = \"Hello, world\"\n"
">>> sio = io.StringIO(s)\n"
">>> sio.getvalue()\n"
"'Hello, world'\n"
">>> sio.seek(7)\n"
"7\n"
">>> sio.write(\"there!\")\n"
"6\n"
">>> sio.getvalue()\n"
"'Hello, there!'\n"
"\n"
">>> import array\n"
">>> a = array.array('w', s)\n"
">>> print(a)\n"
"array('w', 'Hello, world')\n"
">>> a[0] = 'y'\n"
">>> print(a)\n"
"array('w', 'yello, world')\n"
">>> a.tounicode()\n"
"'yello, world'"

msgid "How do I use strings to call functions/methods?"
msgstr "Hur använder jag strängar för att anropa funktioner/metoder?"

msgid "There are various techniques."
msgstr "Det finns olika tekniker."

msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary "
"advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr ""
"Det bästa är att använda en ordbok som mappar strängar till funktioner.  Den "
"främsta fördelen med den här tekniken är att strängarna inte behöver matcha "
"namnen på funktionerna.  Detta är också den primära teknik som används för "
"att emulera en fallkonstruktion::"

msgid ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs\n"
"\n"
"dispatch[get_input()]()  # Note trailing parens to call function"
msgstr ""
"def a():\n"
"    pass\n"
"\n"
"def b():\n"
"    pass\n"
"\n"
"dispatch = {'go': a, 'stop': b} # Observera avsaknad av parenteser för "
"funcs\n"
"\n"
"dispatch[get_input()]() # Notera efterföljande parenteser för att anropa "
"funktion"

msgid "Use the built-in function :func:`getattr`::"
msgstr "Använd den inbyggda funktionen :func:`getattr`::"

msgid ""
"import foo\n"
"getattr(foo, 'bar')()"
msgstr ""
"import foo\n"
"getattr(foo, 'bar')()"

msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ""
"Observera att :func:`getattr` fungerar på alla objekt, inklusive klasser, "
"klassinstanser, moduler och så vidare."

msgid "This is used in several places in the standard library, like this::"
msgstr ""
"Detta används på flera ställen i standardbiblioteket, till exempel så här::"

msgid ""
"class Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"
msgstr ""
"klass Foo:\n"
"    def do_foo(self):\n"
"        ...\n"
"\n"
"    def do_bar(self):\n"
"        ...\n"
"\n"
"f = getattr(foo_instance, 'do_' + opname)\n"
"f()"

msgid "Use :func:`locals` to resolve the function name::"
msgstr "Använd :func:`locals` för att lösa upp funktionsnamnet::"

msgid ""
"def myFunc():\n"
"    print(\"hello\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fname]\n"
"f()"
msgstr ""
"def myFunc():\n"
"    print(\"hallå\")\n"
"\n"
"fname = \"myFunc\"\n"
"\n"
"f = locals()[fnamn]\n"
"f()"

msgid ""
"Is there an equivalent to Perl's ``chomp()`` for removing trailing newlines "
"from strings?"
msgstr ""
"Finns det en motsvarighet till Perls ``chomp()`` för att ta bort "
"efterföljande nya rader från strängar?"

msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several "
"empty lines at the end, the line terminators for all the blank lines will be "
"removed::"
msgstr ""
"Du kan använda ``S.rstrip(\"\\r\\n\")`` för att ta bort alla förekomster av "
"en radavslutare från slutet av strängen ``S`` utan att ta bort andra "
"efterföljande blanksteg.  Om strängen ``S`` representerar mer än en rad, med "
"flera tomma rader i slutet, kommer radavslutarna för alla de tomma raderna "
"att tas bort::"

msgid ""
">>> lines = (\"line 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> lines.rstrip(\"\\n\\r\")\n"
"'line 1 '"
msgstr ""
">>> rader = (\"rad 1 \\r\\n\"\n"
"...          \"\\r\\n\"\n"
"...          \"\\r\\n\")\n"
">>> linjer.rstrip(\"\\n\\r\")\n"
"'rad 1 '"

msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr ""
"Eftersom detta vanligtvis bara är önskvärt när man läser text en rad i "
"taget, fungerar det bra att använda ``S.rstrip()`` på detta sätt."

msgid "Is there a ``scanf()`` or ``sscanf()`` equivalent?"
msgstr "Finns det en motsvarighet till ``scanf()`` eller ``sscanf()``?"

msgid "Not as such."
msgstr "Inte som sådan."

msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using :"
"func:`int` or :func:`float`.  :meth:`!split` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""
"För enkel parsning av indata är det enklast att dela upp raden i ord som är "
"avgränsade med blanksteg med hjälp av metoden :meth:`~str.split` för "
"strängobjekt och sedan konvertera decimalsträngar till numeriska värden med "
"hjälp av :func:`int` eller :func:`float`. :meth:`!split` stöder en valfri "
"parameter \"sep\" som är användbar om raden använder något annat än "
"blanksteg som avgränsare."

msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's ``sscanf`` and better suited for the task."
msgstr ""
"För mer komplicerad parsning av indata är reguljära uttryck kraftfullare än "
"C:s ``sscanf`` och bättre lämpade för uppgiften."

msgid "What does ``UnicodeDecodeError`` or ``UnicodeEncodeError`` error mean?"
msgstr "Vad betyder ``UnicodeDecodeError`` eller ``UnicodeEncodeError`` fel?"

msgid "See the :ref:`unicode-howto`."
msgstr "Se :ref:`unicode-howto`."

msgid "Can I end a raw string with an odd number of backslashes?"
msgstr "Kan jag avsluta en rå sträng med ett udda antal backslash?"

msgid ""
"A raw string ending with an odd number of backslashes will escape the "
"string's quote::"
msgstr ""
"En rå sträng som slutar med ett udda antal backslashes kommer att undkomma "
"strängens quote::"

msgid ""
">>> r'C:\\this\\will\\not\\work\\'\n"
"  File \"<stdin>\", line 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: unterminated string literal (detected at line 1)"
msgstr ""
"&gt;&gt;&gt; r'C:\\this\\will\\not\\work\\'\n"
"  Fil \"<stdin>\", rad 1\n"
"    r'C:\\this\\will\\not\\work\\'\n"
"    ^\n"
"SyntaxError: oavslutad sträng bokstav (upptäckt på rad 1)"

msgid ""
"There are several workarounds for this. One is to use regular strings and "
"double the backslashes::"
msgstr ""
"Det finns flera lösningar på detta. En är att använda vanliga strängar och "
"dubbla de bakre bindestrecken::"

msgid ""
">>> 'C:\\\\this\\\\will\\\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> 'C:\\\\this\\\\will\\work\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

msgid ""
"Another is to concatenate a regular string containing an escaped backslash "
"to the raw string::"
msgstr ""
"Ett annat sätt är att konkatenera en reguljär sträng som innehåller en "
"undangömd backslash till råsträngen::"

msgid ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> r'C:\\this\\will\\work' '\\\\'\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

msgid ""
"It is also possible to use :func:`os.path.join` to append a backslash on "
"Windows::"
msgstr ""
"Det är också möjligt att använda :func:`os.path.join` för att lägga till ett "
"backslash i Windows::"

msgid ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"
msgstr ""
">>> os.path.join(r'C:\\this\\will\\work', '')\n"
"'C:\\\\this\\\\will\\\\work\\\\'"

msgid ""
"Note that while a backslash will \"escape\" a quote for the purposes of "
"determining where the raw string ends, no escaping occurs when interpreting "
"the value of the raw string. That is, the backslash remains present in the "
"value of the raw string::"
msgstr ""
"Observera att även om en backslash \"escapar\" ett citattecken för att "
"avgöra var råsträngen slutar, sker ingen escaping när råsträngens värde "
"tolkas. Det vill säga, det bakre snedstrecket finns kvar i värdet av den råa "
"strängen::"

msgid ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""
msgstr ""
">>> r'backslash\\'preserved'\n"
"\"backslash\\\\'preserved\""

msgid "Also see the specification in the :ref:`language reference <strings>`."
msgstr "Se även specifikationen i :ref:``language reference <strings>``."

msgid "Performance"
msgstr "Prestanda"

msgid "My program is too slow. How do I speed it up?"
msgstr "Mitt program är för långsamt. Hur snabbar jag upp det?"

msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr ""
"Det är en svår fråga, generellt sett.  Här är en lista på saker att komma "
"ihåg innan du dyker vidare:"

msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr ""
"Prestandaegenskaperna varierar mellan olika Python-implementationer.  Denna "
"FAQ fokuserar på :term:`CPython`."

msgid ""
"Behaviour can vary across operating systems, especially when talking about I/"
"O or multi-threading."
msgstr ""
"Beteendet kan variera mellan olika operativsystem, särskilt när det gäller I/"
"O eller multi-threading."

msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr ""
"Du bör alltid hitta de hetaste punkterna i ditt program *innan* du försöker "
"optimera någon kod (se modulen :mod:`profile`)."

msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr ""
"Genom att skriva benchmark-skript kan du snabbt iterera när du söker efter "
"förbättringar (se modulen :mod:`timeit`)."

msgid ""
"It is highly recommended to have good code coverage (through unit testing or "
"any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr ""
"Det är starkt rekommenderat att ha god kodtäckning (genom enhetstestning "
"eller någon annan teknik) innan man eventuellt introducerar regressioner som "
"döljs i sofistikerade optimeringar."

msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"Med detta sagt finns det många knep för att snabba upp Python-kod.  Här är "
"några allmänna principer som räcker långt för att nå acceptabla "
"prestandanivåer:"

msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr ""
"Att göra dina algoritmer snabbare (eller byta till snabbare algoritmer) kan "
"ge mycket större fördelar än att försöka strö mikrooptimeringsknep över hela "
"koden."

msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"Använd rätt datastrukturer.  Studera dokumentationen för modulen :ref:`bltin-"
"types` och :mod:`collections`."

msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the :"
"meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"När standardbiblioteket tillhandahåller en primitiv metod för att göra något "
"är det troligt (men inte garanterat) att den är snabbare än något alternativ "
"som du kan komma på.  Detta gäller i ännu högre grad för primitiver som är "
"skrivna i C, t.ex. inbyggda program och vissa tilläggstyper.  Se till "
"exempel till att använda antingen den inbyggda metoden :meth:`list.sort` "
"eller den relaterade funktionen :func:`sorted` för att göra sortering (och "
"se :ref:`sortinghowto` för exempel på måttligt avancerad användning)."

msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done, "
"your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often "
"detrimental to readability)."
msgstr ""
"Abstraktioner tenderar att skapa indirektioner och tvinga tolken att arbeta "
"mer.  Om nivåerna av indirekta åtgärder uppväger mängden användbart arbete "
"som utförs, blir ditt program långsammare.  Du bör undvika överdriven "
"abstraktion, särskilt i form av små funktioner eller metoder (som också ofta "
"är skadliga för läsbarheten)."

msgid ""
"If you have reached the limit of what pure Python can allow, there are tools "
"to take you further away.  For example, `Cython <https://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"Om du har nått gränsen för vad ren Python kan tillåta, finns det verktyg som "
"tar dig längre bort.  Till exempel kan `Cython &lt;https://cython.org&gt;`_ "
"kompilera en något modifierad version av Python-kod till ett C-tillägg och "
"kan användas på många olika plattformar.  Cython kan dra nytta av "
"kompilering (och valfria typannoteringar) för att göra din kod betydligt "
"snabbare än när den tolkas.  Om du är säker på dina färdigheter i C-"
"programmering kan du också :ref:`skriva en C-tilläggsmodul <extending-"
"index>` själv."

msgid ""
"The wiki page devoted to `performance tips <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."
msgstr ""
"Wikisidan som ägnas åt \"prestandatips\" <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."

msgid "What is the most efficient way to concatenate many strings together?"
msgstr ""
"Vad är det mest effektiva sättet att konkatenera många strängar tillsammans?"

msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
"objekten :class:`str` och :class:`bytes` är oföränderliga, och därför är det "
"ineffektivt att sammanfoga många strängar eftersom varje sammanfogning "
"skapar ett nytt objekt.  I det allmänna fallet är den totala "
"körtidskostnaden kvadratisk i den totala stränglängden."

msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr ""
"För att samla många :class:`str`-objekt är det rekommenderade idiomet att "
"placera dem i en lista och anropa :meth:`str.join` i slutet::"

msgid ""
"chunks = []\n"
"for s in my_strings:\n"
"    chunks.append(s)\n"
"result = ''.join(chunks)"
msgstr ""
"chunks = []\n"
"för s i my_strings:\n"
"    chunks.append(s)\n"
"resultat = ''.join(chunks)"

msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr ""
"(ett annat rimligt effektivt idiom är att använda :class:`io.StringIO`)"

msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"För att ackumulera många :class:`bytes`-objekt är det rekommenderade idiomet "
"att utöka ett :class:`bytearray`-objekt med hjälp av konkatenering på plats "
"(operatorn ``+=``)::"

msgid ""
"result = bytearray()\n"
"for b in my_bytes_objects:\n"
"    result += b"
msgstr ""
"resultat = bytearray()\n"
"för b i my_bytes_objects:\n"
"    resultat += b"

msgid "Sequences (Tuples/Lists)"
msgstr "Sekvenser (Tupler/Listor)"

msgid "How do I convert between tuples and lists?"
msgstr "Hur konverterar jag mellan tupler och listor?"

msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"Typkonstruktören ``tuple(seq)`` konverterar vilken sekvens som helst "
"(egentligen vilken iterabel som helst) till en tuple med samma objekt i "
"samma ordning."

msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"Till exempel ger ``tuple([1, 2, 3])`` ``(1, 2, 3)`` och ``tuple('abc')`` ger "
"``('a', 'b', 'c')``.  Om argumentet är en tupel görs ingen kopia utan samma "
"objekt returneras, så det är billigt att anropa :func:`tuple` när du inte är "
"säker på att ett objekt redan är en tupel."

msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"Typkonstruktören ``list(seq)`` konverterar en sekvens eller iterabel till en "
"lista med samma objekt i samma ordning.  Till exempel ger ``list((1, 2, "
"3))`` ``[1, 2, 3]`` och ``list('abc')`` ger ``['a', 'b', 'c']``.  Om "
"argumentet är en lista gör den en kopia precis som ``seq[:]`` skulle göra."

msgid "What's a negative index?"
msgstr "Vad är ett negativt index?"

msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Pythonsekvenser är indexerade med positiva och negativa tal.  För positiva "
"tal är 0 det första indexet 1 är det andra indexet och så vidare.  För "
"negativa index är -1 det sista indexet och -2 är det näst sista indexet och "
"så vidare.  Tänk på ``seq[-n]`` som samma sak som ``seq[len(seq)-n]``."

msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"Att använda negativa index kan vara mycket praktiskt.  Till exempel är "
"``S[:-1]`` hela strängen utom det sista tecknet, vilket är användbart när "
"man vill ta bort den efterföljande nya raden från en sträng."

msgid "How do I iterate over a sequence in reverse order?"
msgstr "Hur itererar jag över en sekvens i omvänd ordning?"

msgid "Use the :func:`reversed` built-in function::"
msgstr "Använd den inbyggda funktionen :func:`reversed`::"

msgid ""
"for x in reversed(sequence):\n"
"    ...  # do something with x ..."
msgstr ""
"för x i omvänd(sekvens):\n"
"    ...  # gör något med x ..."

msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr ""
"Detta påverkar inte din ursprungliga sekvens, men skapar en ny kopia med "
"omvänd ordning som du kan iterera över."

msgid "How do you remove duplicates from a list?"
msgstr "Hur tar man bort dubbletter från en lista?"

msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr ""
"Se Python Cookbook för en lång diskussion om många sätt att göra detta:"

msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of "
"the list, deleting duplicates as you go::"
msgstr ""
"Om du inte har något emot att ändra ordning på listan kan du sortera den och "
"sedan skanna från slutet av listan och ta bort dubbletter efter hand:"

msgid ""
"if mylist:\n"
"    mylist.sort()\n"
"    last = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        else:\n"
"            last = mylist[i]"
msgstr ""
"if mylist:\n"
"    mylist.sort()\n"
"    sista = mylist[-1]\n"
"    for i in range(len(mylist)-2, -1, -1):\n"
"        if last == mylist[i]:\n"
"            del mylist[i]\n"
"        annars:\n"
"            last = mylist[i]"

msgid ""
"If all elements of the list may be used as set keys (i.e. they are all :term:"
"`hashable`) this is often faster ::"
msgstr ""
"Om alla element i listan kan användas som set-nycklar (dvs. de är alla :term:"
"`hashable`) är detta ofta snabbare ::"

msgid "mylist = list(set(mylist))"
msgstr "mylist = list(set(mylist))"

msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr ""
"Detta omvandlar listan till en uppsättning, varvid dubbletter tas bort, och "
"sedan tillbaka till en lista."

msgid "How do you remove multiple items from a list"
msgstr "Hur tar du bort flera objekt från en lista"

msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice "
"replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"Precis som vid borttagning av dubbletter är det en möjlighet att explicit "
"iterera baklänges med ett delete-villkor.  Det är dock enklare och snabbare "
"att använda slice replacement med en implicit eller explicit iteration "
"framåt. Här är tre varianter:::"

msgid ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x for x in mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition]"
msgstr ""
"mylist[:] = filter(keep_function, mylist)\n"
"mylist[:] = (x för x i mylist if keep_condition)\n"
"mylist[:] = [x for x in mylist if keep_condition] (x för x i mylist if "
"keep_condition)"

msgid "The list comprehension may be fastest."
msgstr "Förståelsen av listan kan vara snabbast."

msgid "How do you make an array in Python?"
msgstr "Hur gör du en matris i Python?"

msgid "Use a list::"
msgstr "Använd en lista::"

msgid "[\"this\", 1, \"is\", \"an\", \"array\"]"
msgstr "[\"detta\", 1, \"är\", \"en\", \"array\"]"

msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"Listor motsvarar matriser i C eller Pascal när det gäller tidskomplexitet; "
"den främsta skillnaden är att en Python-lista kan innehålla objekt av många "
"olika typer."

msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than "
"lists.  Also note that `NumPy <https://numpy.org/>`_ and other third party "
"packages define array-like structures with various characteristics as well."
msgstr ""
"Modulen ``array`` tillhandahåller också metoder för att skapa matriser av "
"fasta typer med kompakta representationer, men de är långsammare att "
"indexera än listor.  Observera också att `NumPy <https://numpy.org/>`_ och "
"andra tredjepartspaket också definierar array-liknande strukturer med olika "
"egenskaper."

msgid ""
"To get Lisp-style linked lists, you can emulate *cons cells* using tuples::"
msgstr ""
"För att få länkade listor i Lisp-stil kan du emulera *cons cells* med hjälp "
"av tuples::"

msgid "lisp_list = (\"like\",  (\"this\",  (\"example\", None) ) )"
msgstr "lisp_list = (\"som\", (\"detta\", (\"exempel\", None) ) )"

msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of a Lisp *car* is ``lisp_list[0]`` and the analogue of *cdr* is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"Om man vill ha mutabilitet kan man använda listor i stället för tupler.  Här "
"är motsvarigheten till en Lisp *car* ``lisp_list[0]`` och motsvarigheten "
"till *cdr* är ``lisp_list[1]``.  Gör bara detta om du är säker på att du "
"verkligen behöver det, eftersom det vanligtvis är mycket långsammare än att "
"använda Python-listor."

msgid "How do I create a multidimensional list?"
msgstr "Hur skapar jag en flerdimensionell lista?"

msgid "You probably tried to make a multidimensional array like this::"
msgstr "Du har säkert försökt skapa en flerdimensionell matris så här::"

msgid ">>> A = [[None] * 2] * 3"
msgstr ">>> A = [[Ingen] * 2] * 3"

msgid "This looks correct if you print it:"
msgstr "Detta ser korrekt ut om du skriver ut det:"

msgid ""
">>> A\n"
"[[None, None], [None, None], [None, None]]"
msgstr ""
">>> A\n"
"[[Ingen, Ingen], [Ingen, Ingen], [Ingen, Ingen]]"

msgid "But when you assign a value, it shows up in multiple places:"
msgstr "Men när du tilldelar ett värde dyker det upp på flera ställen:"

msgid ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, None], [5, None], [5, None]]"
msgstr ""
">>> A[0][0] = 5\n"
">>> A\n"
"[[5, Ingen], [5, Ingen], [5, Ingen]]"

msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"Anledningen är att replikering av en lista med ``*`` inte skapar kopior, det "
"skapar bara referenser till de befintliga objekten.  Med ``*3`` skapas en "
"lista som innehåller 3 referenser till samma lista med längden två.  "
"Ändringar i en rad kommer att visas i alla rader, vilket nästan säkert inte "
"är vad du vill."

msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr ""
"Det föreslagna tillvägagångssättet är att först skapa en lista med önskad "
"längd och sedan fylla i varje element med en nyskapad lista::"

msgid ""
"A = [None] * 3\n"
"for i in range(3):\n"
"    A[i] = [None] * 2"
msgstr ""
"A = [Ingen] * 3\n"
"för i i intervall(3):\n"
"    A[i] = [Ingen] * 2"

msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr ""
"Detta genererar en lista som innehåller 3 olika listor med längden två.  Du "
"kan också använda en listkomprehension::"

msgid ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"
msgstr ""
"w, h = 2, 3\n"
"A = [[None] * w for i in range(h)]"

msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr ""
"Eller så kan du använda ett tillägg som tillhandahåller en matrisdatatyp; "
"`NumPy <https://numpy.org/>`_ är den mest kända."

msgid "How do I apply a method or function to a sequence of objects?"
msgstr "Hur tillämpar jag en metod eller funktion på en sekvens av objekt?"

msgid ""
"To call a method or function and accumulate the return values is a list, a :"
"term:`list comprehension` is an elegant solution::"
msgstr ""
"Att anropa en metod eller funktion och ackumulera returvärdena är en lista, "
"en :term:``list comprehension`` är en elegant lösning::"

msgid ""
"result = [obj.method() for obj in mylist]\n"
"\n"
"result = [function(obj) for obj in mylist]"
msgstr ""
"resultat = [obj.method() för obj i mylist]\n"
"\n"
"resultat = [funktion(obj) för obj i mylist]"

msgid ""
"To just run the method or function without saving the return values, a "
"plain :keyword:`for` loop will suffice::"
msgstr ""
"Om du bara vill köra metoden eller funktionen utan att spara returvärdena "
"räcker det med en vanlig :keyword:`for`-loop::"

msgid ""
"for obj in mylist:\n"
"    obj.method()\n"
"\n"
"for obj in mylist:\n"
"    function(obj)"
msgstr ""
"för obj i mylist:\n"
"    obj.metod()\n"
"\n"
"för obj i mylist:\n"
"    funktion(obj)"

msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr ""
"Varför ger a_tuple[i] += ['item'] upphov till ett undantag när tillägget "
"fungerar?"

msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and "
"immutable objects in Python."
msgstr ""
"Detta beror på en kombination av det faktum att utökade "
"tilldelningsoperatorer är *tilldelningsoperatorer* och skillnaden mellan "
"muterbara och oföränderliga objekt i Python."

msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr ""
"Den här diskussionen gäller i allmänhet när utökade tilldelningsoperatorer "
"tillämpas på element i en tupel som pekar på föränderliga objekt, men vi "
"använder en ``lista`` och ``+=`` som vårt exempel."

msgid "If you wrote::"
msgstr "Om du skrev::"

msgid ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (most recent call last):\n"
"   ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tuple = (1, 2)\n"
">>> a_tuple[0] += 1\n"
"Traceback (senaste anropet senast):\n"
"   ...\n"
"TypeError: Objektet 'tuple' stöder inte tilldelning av objekt"

msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"Anledningen till undantaget bör vara omedelbart klar: ``1`` läggs till "
"objektet ``a_tuple[0]`` pekar på (``1``), vilket ger resultatobjektet ``2``, "
"men när vi försöker tilldela resultatet av beräkningen, ``2``, till "
"elementet ``0`` i tupeln, får vi ett fel eftersom vi inte kan ändra vad ett "
"element i en tuple pekar på."

msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr ""
"Under täckmanteln gör den här utökade uppdragsbeskrivningen ungefär så här::"

msgid ""
">>> result = a_tuple[0] + 1\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> resultat = a_tuple[0] + 1\n"
">>> a_tuple[0] = resultat\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: Objektet 'tuple' stöder inte tilldelning av objekt"

msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr ""
"Det är tilldelningsdelen av operationen som ger upphov till felet, eftersom "
"en tuple är oföränderlig."

msgid "When you write something like::"
msgstr "När du skriver något i stil med::"

msgid ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> a_tuple = (['foo'], 'bar')\n"
">>> a_tuple[0] += ['item']\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: Objektet 'tuple' stöder inte tilldelning av objekt"

msgid ""
"The exception is a bit more surprising, and even more surprising is the fact "
"that even though there was an error, the append worked::"
msgstr ""
"Undantaget är lite mer överraskande, och ännu mer överraskande är det faktum "
"att även om det fanns ett fel, fungerade tillägget::"

msgid ""
">>> a_tuple[0]\n"
"['foo', 'item']"
msgstr ""
">>> a_tuple[0]\n"
"['foo', 'item']"

msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an :meth:`~object.__iadd__` magic method, it gets called when the ``+=`` "
"augmented assignment is executed, and its return value is what gets used in "
"the assignment statement; and (b) for lists, :meth:`!__iadd__` is equivalent "
"to calling :meth:`!extend` on the list and returning the list.  That's why "
"we say that for lists, ``+=`` is a \"shorthand\" for :meth:`!list.extend`::"
msgstr ""
"För att förstå varför detta händer måste du veta att (a) om ett objekt "
"implementerar en magisk metod :meth:`~object.__iadd__`, anropas den när den "
"utökade tilldelningen ``+=`` utförs, och dess returvärde är det som används "
"i tilldelningsuttalandet; och (b) för listor är :meth:`!__iadd__` likvärdigt "
"med att anropa :meth:`!extend` på listan och returnera listan.  Det är "
"därför vi säger att för listor är ``+=`` en \"kortform\" för :meth:`!list."
"extend`::"

msgid ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"
msgstr ""
">>> a_list = []\n"
">>> a_list += [1]\n"
">>> a_list\n"
"[1]"

msgid "This is equivalent to::"
msgstr "Detta är likvärdigt med::"

msgid ""
">>> result = a_list.__iadd__([1])\n"
">>> a_list = result"
msgstr ""
">>> resultat = a_list.__iadd__([1])\n"
">>> a_list = resultat"

msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"Det objekt som a_list pekar på har muterats och pekaren till det muterade "
"objektet tilldelas tillbaka till ``a_list``.  Slutresultatet av "
"tilldelningen är en no-op, eftersom det är en pekare till samma objekt som "
"``a_list`` tidigare pekade på, men tilldelningen sker ändå."

msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr "I vårt tuplexempel är det som händer alltså likvärdigt med::"

msgid ""
">>> result = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = result\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'tuple' object does not support item assignment"
msgstr ""
">>> resultat = a_tuple[0].__iadd__(['item'])\n"
">>> a_tuple[0] = resultat\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: 'tuple'-objektet stöder inte tilldelning av objekt"

msgid ""
"The :meth:`!__iadd__` succeeds, and thus the list is extended, but even "
"though ``result`` points to the same object that ``a_tuple[0]`` already "
"points to, that final assignment still results in an error, because tuples "
"are immutable."
msgstr ""
":meth:`!__iadd__` lyckas och därmed utökas listan, men även om ``result`` "
"pekar på samma objekt som ``a_tuple[0]`` redan pekar på, resulterar den "
"slutliga tilldelningen fortfarande i ett fel, eftersom tuples är "
"oföränderliga."

msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr ""
"Jag vill göra en komplicerad sortering: kan du göra en Schwartzian-transform "
"i Python?"

msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"Tekniken, som tillskrivs Randal Schwartz från Perl-communityn, sorterar "
"elementen i en lista med en metrisk som mappar varje element till dess "
"\"sorteringsvärde\". I Python använder du argumentet ``key`` för metoden :"
"meth:`list.sort`::"

msgid ""
"Isorted = L[:]\n"
"Isorted.sort(key=lambda s: int(s[10:15]))"
msgstr ""
"Isorted = L[:]\n"
"Isorted.sort(nyckel=lambda s: int(s[10:15]))"

msgid "How can I sort one list by values from another list?"
msgstr "Hur kan jag sortera en lista efter värden från en annan lista?"

msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr ""
"Slå samman dem till en iterator av tupler, sortera den resulterande listan "
"och välj sedan ut det element du vill ha:"

msgid ""
">>> list1 = [\"what\", \"I'm\", \"sorting\", \"by\"]\n"
">>> list2 = [\"something\", \"else\", \"to\", \"sort\"]\n"
">>> pairs = zip(list1, list2)\n"
">>> pairs = sorted(pairs)\n"
">>> pairs\n"
"[(\"I'm\", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', "
"'something')]\n"
">>> result = [x[1] for x in pairs]\n"
">>> result\n"
"['else', 'sort', 'to', 'something']"
msgstr ""
">>> list1 = [\"vad\", \"jag\", \"sortera\", \"efter\"] >>> list2 = "
"[\"något\", \"annat\", \"till\", \"sortera\n"
">>> list2 = [\"något\", \"annat\", \"till\", \"sortera\"]\n"
">>> par = zip(list1, list2)\n"
">>> par = sorterad(par)\n"
">>> par\n"
"[(\"jag är\", \"annat\"), (\"av\", \"sortera\"), (\"sortera\", \"till\"), "
"(\"vad\", \"något\")]\n"
">>> resultat = [x[1] för x i par] >>> resultat = [x[1] för x i par\n"
">>> resultat\n"
"['annat', 'sortera', 'till', 'något']"

msgid "Objects"
msgstr "Objekt"

msgid "What is a class?"
msgstr "Vad är en klass?"

msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"En klass är den särskilda objekttyp som skapas genom att en class-sats körs. "
"Klassobjekt används som mallar för att skapa instansobjekt, som innehåller "
"både data (attribut) och kod (metoder) som är specifika för en datatyp."

msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"En klass kan baseras på en eller flera andra klasser, som kallas dess "
"basklass(er). Den ärver då attribut och metoder från sina basklasser. Detta "
"gör att en objektmodell successivt kan förfinas genom arv.  Du kanske har en "
"generisk klass ``Mailbox`` som tillhandahåller grundläggande åtkomstmetoder "
"för en brevlåda, och underklasser som ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` som hanterar olika specifika brevlådeformat."

msgid "What is a method?"
msgstr "Vad är en metod?"

msgid ""
"A method is a function on some object ``x`` that you normally call as ``x."
"name(arguments...)``.  Methods are defined as functions inside the class "
"definition::"
msgstr ""
"En metod är en funktion på något objekt ``x`` som du normalt anropar som ``x."
"name(arguments...)``.  Metoder definieras som funktioner inuti "
"klassdefinitionen::"

msgid ""
"class C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"
msgstr ""
"klass C:\n"
"    def meth(self, arg):\n"
"        return arg * 2 + self.attribute"

msgid "What is self?"
msgstr "Vad är jaget?"

msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, "
"c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self är bara ett konventionellt namn för det första argumentet i en metod.  "
"En metod som definieras som ``meth(self, a, b, c)`` bör anropas som ``x."
"meth(a, b, c)`` för någon instans ``x`` av den klass där definitionen "
"förekommer; den anropade metoden kommer att tro att den anropas som "
"``meth(x, a, b, c)``."

msgid "See also :ref:`why-self`."
msgstr "Se även :ref:`varför-själv`."

msgid ""
"How do I check if an object is an instance of a given class or of a subclass "
"of it?"
msgstr ""
"Hur kontrollerar jag om ett objekt är en instans av en viss klass eller av "
"en underklass av den?"

msgid ""
"Use the built-in function :func:`isinstance(obj, cls) <isinstance>`.  You "
"can check if an object is an instance of any of a number of classes by "
"providing a tuple instead of a single class, e.g. ``isinstance(obj, (class1, "
"class2, ...))``, and can also check whether an object is one of Python's "
"built-in types, e.g. ``isinstance(obj, str)`` or ``isinstance(obj, (int, "
"float, complex))``."
msgstr ""
"Använd den inbyggda funktionen :func:`isinstance(obj, cls) <isinstance>`.  "
"Du kan kontrollera om ett objekt är en instans av någon av ett antal klasser "
"genom att ange en tupel istället för en enda klass, t.ex. ``isinstance(obj, "
"(class1, class2, ...))``, och du kan också kontrollera om ett objekt är en "
"av Pythons inbyggda typer, t.ex. ``isinstance(obj, str)`` eller "
"``isinstance(obj, (int, float, complex))``."

msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an :"
"term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"Observera att :func:`isinstance` även kontrollerar för virtuellt arv från "
"en :term:`abstrakt basklass`.  Så testet kommer att returnera ``True`` för "
"en registrerad klass även om den inte direkt eller indirekt har ärvt från "
"den.  För att testa för \"true inheritance\", skanna klassens :term:`MRO`:"

msgid ""
"from collections.abc import Mapping\n"
"\n"
"class P:\n"
"     pass\n"
"\n"
"class C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"
msgstr ""
"från collections.abc import Mapping\n"
"\n"
"klass P:\n"
"     pass\n"
"\n"
"klass C(P):\n"
"    pass\n"
"\n"
"Mapping.register(P)"

msgid ""
">>> c = C()\n"
">>> isinstance(c, C)        # direct\n"
"True\n"
">>> isinstance(c, P)        # indirect\n"
"True\n"
">>> isinstance(c, Mapping)  # virtual\n"
"True\n"
"\n"
"# Actual inheritance chain\n"
">>> type(c).__mro__\n"
"(<class 'C'>, <class 'P'>, <class 'object'>)\n"
"\n"
"# Test for \"true inheritance\"\n"
">>> Mapping in type(c).__mro__\n"
"False"
msgstr ""
">>> c = C()\n"
">>> isinstance(c, C) # direkt\n"
"Sant\n"
">>> isinstance(c, P) # indirekt\n"
"True\n"
">>> isinstans(c, Mapping) # virtuell\n"
"Sant\n"
"\n"
"# Faktisk arvskedja\n"
">>> typ(c).__mro__\n"
"(<klass 'C'>, <klass 'P'>, <klass 'objekt'>)\n"
"\n"
"# Test för \"sant arv\"\n"
">>> Mappning i typ(c).__mro__\n"
"Falsk"

msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"Observera att de flesta program inte använder :func:`isinstance` på "
"användardefinierade klasser särskilt ofta.  Om du utvecklar klasserna själv "
"är en mer korrekt objektorienterad stil att definiera metoder på klasserna "
"som kapslar in ett visst beteende, istället för att kontrollera objektets "
"klass och göra en annan sak baserat på vilken klass det är.  Om man t.ex. "
"har en funktion som gör något::"

msgid ""
"def search(obj):\n"
"    if isinstance(obj, Mailbox):\n"
"        ...  # code to search a mailbox\n"
"    elif isinstance(obj, Document):\n"
"        ...  # code to search a document\n"
"    elif ..."
msgstr ""
"def search(obj):\n"
"    if isinstance(obj, Brevlåda):\n"
"        ...  # kod för att söka i en brevlåda\n"
"    elif isinstance(obj, Dokument):\n"
"        ...  # kod för att söka i ett dokument\n"
"    elif ..."

msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr ""
"Ett bättre tillvägagångssätt är att definiera en ``search()``-metod för alla "
"klasser och bara anropa den::"

msgid ""
"class Mailbox:\n"
"    def search(self):\n"
"        ...  # code to search a mailbox\n"
"\n"
"class Document:\n"
"    def search(self):\n"
"        ...  # code to search a document\n"
"\n"
"obj.search()"
msgstr ""
"klass Brevlåda:\n"
"    def search(self):\n"
"        ...  # kod för att söka i en brevlåda\n"
"\n"
"klass Dokument:\n"
"    def search(self):\n"
"        ...  # kod för att söka i ett dokument\n"
"\n"
"obj.search()"

msgid "What is delegation?"
msgstr "Vad är delegering?"

msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all "
"other methods to the corresponding method of ``x``."
msgstr ""
"Delegering är en objektorienterad teknik (även kallad designmönster). Låt "
"oss säga att du har ett objekt ``x`` och vill ändra beteendet hos bara en av "
"dess metoder.  Du kan skapa en ny klass som tillhandahåller en ny "
"implementering av den metod du är intresserad av att ändra och delegerar "
"alla andra metoder till motsvarande metod i ``x``."

msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all "
"written data to uppercase::"
msgstr ""
"Python-programmerare kan enkelt implementera delegering.  Till exempel, "
"följande klass implementerar en klass som beter sig som en fil men "
"konverterar all skriven data till versaler::"

msgid ""
"class UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = outfile\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, name):\n"
"        return getattr(self._outfile, name)"
msgstr ""
"klass UpperOut:\n"
"\n"
"    def __init__(self, outfile):\n"
"        self._outfile = utfil\n"
"\n"
"    def write(self, s):\n"
"        self._outfile.write(s.upper())\n"
"\n"
"    def __getattr__(self, namn):\n"
"        return getattr(self._outfile, namn)"

msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying ``self._outfile."
"write()`` method.  All other methods are delegated to the underlying ``self."
"_outfile`` object.  The delegation is accomplished via the :meth:`~object."
"__getattr__` method; consult :ref:`the language reference <attribute-"
"access>` for more information about controlling attribute access."
msgstr ""
"Här omdefinierar klassen ``UpperOut`` metoden ``write()`` så att "
"argumentsträngen konverteras till versaler innan den underliggande metoden "
"``self._outfile.write()`` anropas.  Alla andra metoder delegeras till det "
"underliggande objektet ``self._outfile``.  Delegeringen sker via metoden :"
"meth:`~object.__getattr__`; se :ref:``språkreferensen <attribute-access>` "
"för mer information om hur man kontrollerar attributåtkomst."

msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a :meth:"
"`~object.__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`!__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"Observera att för mer allmänna fall kan delegering bli knepigare. När "
"attribut måste ställas in såväl som hämtas måste klassen definiera en :meth:"
"`~object.__setattr__`-metod också, och den måste göra det noggrant.  Den "
"grundläggande implementationen av :meth:`!__setattr__` är ungefär likvärdig "
"med följande::"

msgid ""
"class X:\n"
"    ...\n"
"    def __setattr__(self, name, value):\n"
"        self.__dict__[name] = value\n"
"    ..."
msgstr ""
"klass X:\n"
"    ...\n"
"    def __setattr__(self, namn, värde):\n"
"        self.__dict__[name] = värde\n"
"    ..."

msgid ""
"Many :meth:`~object.__setattr__` implementations call :meth:`!object."
"__setattr__` to set an attribute on self without causing infinite recursion::"
msgstr ""
"Många :meth:`~object.__setattr__`-implementationer anropar :meth:`!object."
"__setattr__` för att sätta ett attribut på self utan att orsaka oändlig "
"rekursion::"

msgid ""
"class X:\n"
"    def __setattr__(self, name, value):\n"
"        # Custom logic here...\n"
"        object.__setattr__(self, name, value)"
msgstr ""
"klass X:\n"
"    def __setattr__(self, namn, värde):\n"
"        # Egen logik här...\n"
"        object.__setattr__(self, namn, värde)"

msgid ""
"Alternatively, it is possible to set attributes by inserting entries into :"
"attr:`self.__dict__ <object.__dict__>` directly."
msgstr ""
"Alternativt är det möjligt att ställa in attribut genom att infoga poster i :"
"attr:`self.__dict__ <object.__dict__>` direkt."

msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr ""
"Hur anropar jag en metod som är definierad i en basklass från en härledd "
"klass som utökar den?"

msgid "Use the built-in :func:`super` function::"
msgstr "Använd den inbyggda funktionen :func:`super`::"

msgid ""
"class Derived(Base):\n"
"    def meth(self):\n"
"        super().meth()  # calls Base.meth"
msgstr ""
"klass Avledda(Bas):\n"
"    def meth(self):\n"
"        super().meth() # anropar Base.meth"

msgid ""
"In the example, :func:`super` will automatically determine the instance from "
"which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"I exemplet kommer :func:`super` automatiskt att bestämma från vilken instans "
"den anropades (värdet ``self``), leta upp :term:`method resolution order` "
"(MRO) med ``type(self).__mro__`` och returnera nästa i raden efter "
"``Derived`` i MRO: ``Base``."

msgid "How can I organize my code to make it easier to change the base class?"
msgstr ""
"Hur kan jag organisera min kod för att göra det lättare att ändra basklassen?"

msgid ""
"You could assign the base class to an alias and derive from the alias.  Then "
"all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"Du kan tilldela basklassen till ett alias och härleda från aliaset.  Då "
"behöver man bara ändra det värde som tilldelats aliaset.  För övrigt är "
"detta trick också praktiskt om du vill bestämma dynamiskt (t.ex. beroende på "
"tillgängliga resurser) vilken basklass som ska användas.  Exempel::"

msgid ""
"class Base:\n"
"    ...\n"
"\n"
"BaseAlias = Base\n"
"\n"
"class Derived(BaseAlias):\n"
"    ..."
msgstr ""
"klass Bas:\n"
"    ...\n"
"\n"
"BaseAlias = Bas\n"
"\n"
"klass Avledda(BaseAlias):\n"
"    ..."

msgid "How do I create static class data and static class methods?"
msgstr "Hur skapar jag statiska klassdata och statiska klassmetoder?"

msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr ""
"Både statiska data och statiska metoder (i den mening som avses i C++ eller "
"Java) stöds i Python."

msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr ""
"För statiska data definierar du helt enkelt ett klassattribut.  För att "
"tilldela ett nytt värde till attributet måste du uttryckligen använda "
"klassnamnet i tilldelningen::"

msgid ""
"class C:\n"
"    count = 0   # number of times C.__init__ called\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count  # or return self.count"
msgstr ""
"klass C:\n"
"    count = 0 # antal gånger C.__init__ anropas\n"
"\n"
"    def __init__(self):\n"
"        C.count = C.count + 1\n"
"\n"
"    def getcount(self):\n"
"        return C.count # eller return self.count"

msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c.count`` refererar också till ``C.count`` för varje ``c`` så att "
"``isinstance(c, C)`` gäller, såvida det inte åsidosätts av ``c`` själv eller "
"av någon klass på basklasssökvägen från ``c.__class__`` tillbaka till ``C``."

msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own "
"dict.  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"Varning: Inom en metod i C skapar en tilldelning som ``self.count = 42`` en "
"ny och orelaterad instans med namnet \"count\" i ``self`` egen dict.  "
"Ombindning av ett klass-statiskt datanamn måste alltid specificera klassen "
"oavsett om det är inom en metod eller inte::"

msgid "C.count = 314"
msgstr "C.count = 314"

msgid "Static methods are possible::"
msgstr "Statiska metoder är möjliga::"

msgid ""
"class C:\n"
"    @staticmethod\n"
"    def static(arg1, arg2, arg3):\n"
"        # No 'self' parameter!\n"
"        ..."
msgstr ""
"klass C:\n"
"    @statiskmetod\n"
"    def static(arg1, arg2, arg3):\n"
"        # Ingen parameter 'self'!\n"
"        ..."

msgid ""
"However, a far more straightforward way to get the effect of a static method "
"is via a simple module-level function::"
msgstr ""
"Ett mycket enklare sätt att få effekten av en statisk metod är dock via en "
"enkel funktion på modulnivå::"

msgid ""
"def getcount():\n"
"    return C.count"
msgstr ""
"def getcount():\n"
"    returnera C.count"

msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"Om din kod är strukturerad så att du definierar en klass (eller en nära "
"relaterad klasshierarki) per modul, ger detta den önskade inkapslingen."

msgid "How can I overload constructors (or methods) in Python?"
msgstr "Hur kan jag överbelasta konstruktörer (eller metoder) i Python?"

msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr ""
"Det här svaret gäller egentligen alla metoder, men frågan dyker oftast upp "
"först i samband med konstruktörer."

msgid "In C++ you'd write"
msgstr "I C++ skulle du skriva"

msgid ""
"class C {\n"
"    C() { cout << \"No arguments\\n\"; }\n"
"    C(int i) { cout << \"Argument is \" << i << \"\\n\"; }\n"
"}"
msgstr ""
"klass C {\n"
"    C() { cout << \"Inga argument\\n\"; }\n"
"    C(int i) { cout << \"Argumentet är \" << i << \"\\n\"; }\n"
"}"

msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr ""
"I Python måste man skriva en enda konstruktor som fångar upp alla fall med "
"hjälp av standardargument.  Till exempel::"

msgid ""
"class C:\n"
"    def __init__(self, i=None):\n"
"        if i is None:\n"
"            print(\"No arguments\")\n"
"        else:\n"
"            print(\"Argument is\", i)"
msgstr ""
"klass C:\n"
"    def __init__(self, i=None):\n"
"        om i är None:\n"
"            print(\"Inga argument\")\n"
"        else:\n"
"            print(\"Argumentet är\", i)"

msgid "This is not entirely equivalent, but close enough in practice."
msgstr "Detta är inte helt likvärdigt, men tillräckligt nära i praktiken."

msgid "You could also try a variable-length argument list, e.g. ::"
msgstr "Du kan också prova en argumentlista med variabel längd, t.ex. ::"

msgid ""
"def __init__(self, *args):\n"
"    ..."
msgstr ""
"def __init__(self, *args):\n"
"    ..."

msgid "The same approach works for all method definitions."
msgstr "Samma tillvägagångssätt fungerar för alla metoddefinitioner."

msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr ""
"Jag försöker använda __spam och jag får ett fel om _SomeClassName__spam."

msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"Variabelnamn med dubbla inledande understreck \"manglas\" för att ge ett "
"enkelt men effektivt sätt att definiera privata klassvariabler.  Alla "
"identifierare av formen ``__spam`` (minst två inledande understrykningar, "
"högst en efterföljande understrykning) ersätts textuellt med "
"``_klassnamn__spam``, där ``klassnamn`` är det aktuella klassnamnet med "
"eventuella inledande understrykningar borttagna."

msgid ""
"The identifier can be used unchanged within the class, but to access it "
"outside the class, the mangled name must be used:"
msgstr ""
"Identifieraren kan användas oförändrad inom klassen, men för att komma åt "
"den utanför klassen måste det manglade namnet användas:"

msgid ""
"class A:\n"
"    def __one(self):\n"
"        return 1\n"
"    def two(self):\n"
"        return 2 * self.__one()\n"
"\n"
"class B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"
msgstr ""
"klass A:\n"
"    def __one(self):\n"
"        returnera 1\n"
"    def två(self):\n"
"        return 2 * self.__one()\n"
"\n"
"klass B(A):\n"
"    def three(self):\n"
"        return 3 * self._A__one()\n"
"\n"
"four = 4 * A()._A__one()"

msgid ""
"In particular, this does not guarantee privacy since an outside user can "
"still deliberately access the private attribute; many Python programmers "
"never bother to use private variable names at all."
msgstr ""
"I synnerhet garanterar detta inte sekretess eftersom en utomstående "
"användare fortfarande avsiktligt kan komma åt det privata attributet; många "
"Python-programmerare bryr sig aldrig om att använda privata variabelnamn "
"alls."

msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
"Specifikationerna för :ref:`privat namnmangling <private-name-mangling>` för "
"detaljer och specialfall."

msgid "My class defines __del__ but it is not called when I delete the object."
msgstr ""
"Min klass definierar __del__ men den anropas inte när jag tar bort objektet."

msgid "There are several possible reasons for this."
msgstr "Det finns flera möjliga orsaker till detta."

msgid ""
"The :keyword:`del` statement does not necessarily call :meth:`~object."
"__del__` -- it simply decrements the object's reference count, and if this "
"reaches zero :meth:`!__del__` is called."
msgstr ""
"Satsen :keyword:`del` anropar inte nödvändigtvis :meth:`~object.__del__` -- "
"den minskar helt enkelt objektets referensantal, och om det når noll "
"anropas :meth:`!__del__`."

msgid ""
"If your data structures contain circular links (e.g. a tree where each child "
"has a parent reference and each parent has a list of children) the reference "
"counts will never go back to zero.  Once in a while Python runs an algorithm "
"to detect such cycles, but the garbage collector might run some time after "
"the last reference to your data structure vanishes, so your :meth:`!__del__` "
"method may be called at an inconvenient and random time. This is "
"inconvenient if you're trying to reproduce a problem. Worse, the order in "
"which object's :meth:`!__del__` methods are executed is arbitrary.  You can "
"run :func:`gc.collect` to force a collection, but there *are* pathological "
"cases where objects will never be collected."
msgstr ""
"Om dina datastrukturer innehåller cirkulära länkar (t.ex. ett träd där varje "
"barn har en föräldrareferens och varje förälder har en lista med barn) "
"kommer referensantalet aldrig att gå tillbaka till noll.  Då och då kör "
"Python en algoritm för att upptäcka sådana cykler, men skräpsamlaren kan "
"köras en tid efter att den sista referensen till din datastruktur "
"försvinner, så din :meth:`!__del__`-metod kan anropas vid en obekväm och "
"slumpmässig tidpunkt. Detta är obekvämt om du försöker återskapa ett "
"problem. Ännu värre är att ordningen i vilken objektets :meth:`!__del__`-"
"metoder utförs är godtycklig.  Du kan köra :func:`gc.collect` för att tvinga "
"fram en insamling, men det *finns* patologiska fall där objekt aldrig kommer "
"att samlas in."

msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects.  "
"Don't call :meth:`!__del__` directly -- :meth:`!__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than "
"once for the same object."
msgstr ""
"Trots cycle collector är det ändå en bra idé att definiera en explicit "
"``close()``-metod på objekt som anropas när du är klar med dem.  Metoden "
"``close()`` kan sedan ta bort attribut som refererar till underobjekt.  "
"Anropa inte :meth:`!__del__` direkt -- :meth:`!__del__` bör anropa "
"``close()`` och ``close()`` bör se till att den kan anropas mer än en gång "
"för samma objekt."

msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"Ett annat sätt att undvika cykliska referenser är att använda modulen :mod:"
"`weakref`, som gör att du kan peka på objekt utan att öka deras "
"referensantal. Träddatastrukturer, till exempel, bör använda svaga "
"referenser för sina föräldra- och syskonreferenser (om de behöver dem!)."

msgid ""
"Finally, if your :meth:`!__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"Slutligen, om din :meth:`!__del__`-metod ger upphov till ett undantag, "
"skrivs ett varningsmeddelande ut till :data:`sys.stderr`."

msgid "How do I get a list of all instances of a given class?"
msgstr "Hur får jag en lista över alla instanser av en viss klass?"

msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"Python håller inte reda på alla instanser av en klass (eller av en inbyggd "
"typ). Du kan programmera klassens konstruktor att hålla reda på alla "
"instanser genom att hålla en lista med svaga referenser till varje instans."

msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "Varför verkar resultatet av ``id()`` inte vara unikt?"

msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in "
"memory.  This is illustrated by this example:"
msgstr ""
"Inbyggda :func:`id` returnerar ett heltal som garanterat är unikt under "
"objektets livstid.  Eftersom detta i CPython är objektets minnesadress "
"händer det ofta att efter att ett objekt har raderats från minnet, allokeras "
"nästa nyskapade objekt på samma position i minnet.  Detta illustreras av "
"detta exempel:"

msgid ""
"The two ids belong to different integer objects that are created before, and "
"deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"De två id:na tillhör olika heltalsobjekt som skapas före och raderas "
"omedelbart efter att anropet ``id()`` har utförts.  För att vara säker på "
"att objekt vars id du vill undersöka fortfarande är vid liv, skapar du en "
"annan referens till objektet:"

msgid "When can I rely on identity tests with the *is* operator?"
msgstr "När kan jag förlita mig på identitetstester med operatorn *is*?"

msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr ""
"Operatorn ``is`` testar objektets identitet.  Testet ``a är b`` är "
"likvärdigt med ``id(a) == id(b)``."

msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are "
"usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"Den viktigaste egenskapen hos ett identitetstest är att ett objekt alltid är "
"identiskt med sig självt, ``a är a`` returnerar alltid ``True``.  "
"Identitetstester är vanligtvis snabbare än likhetstester.  Och till skillnad "
"från likhetstester är identitetstester garanterade att returnera en boolean "
"``True`` eller ``False``."

msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr ""
"Identitetstester kan dock *endast* ersättas med likhetstester när objektets "
"identitet är säkerställd.  I allmänhet finns det tre omständigheter där "
"identiteten är garanterad:"

msgid ""
"Assignments create new names but do not change object identity.  After the "
"assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"Tilldelningar skapar nya namn men ändrar inte objektets identitet.  Efter "
"tilldelningen ``nytt = gammalt`` är det garanterat att ``nytt är gammalt``."

msgid ""
"Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"Att placera ett objekt i en behållare som lagrar objektreferenser ändrar "
"inte objektets identitet.  Efter listtilldelningen ``s[0] = x`` är det "
"garanterat att ``s[0] är x``."

msgid ""
"If an object is a singleton, it means that only one instance of that object "
"can exist.  After the assignments ``a = None`` and ``b = None``, it is "
"guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"Om ett objekt är en singleton betyder det att det bara kan finnas en instans "
"av objektet.  Efter tilldelningarna ``a = None`` och ``b = None`` är det "
"garanterat att ``a är b`` eftersom ``None`` är en singleton."

msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"Under de flesta andra omständigheter är identitetstester inte tillrådliga "
"och likhetstester är att föredra.  I synnerhet bör identitetstester inte "
"användas för att kontrollera konstanter som :class:`int` och :class:`str` "
"som inte garanterat är singletoner::"

msgid ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a is c\n"
"False\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a is c\n"
"False"
msgstr ""
">>> a = 1000\n"
">>> b = 500\n"
">>> c = b + 500\n"
">>> a är c\n"
"Falsk\n"
"\n"
">>> a = 'Python'\n"
">>> b = 'Py'\n"
">>> c = b + 'thon'\n"
">>> a är c\n"
"Falsk"

msgid "Likewise, new instances of mutable containers are never identical::"
msgstr "På samma sätt är nya instanser av mutabla behållare aldrig identiska:"

msgid ""
">>> a = []\n"
">>> b = []\n"
">>> a is b\n"
"False"
msgstr ""
">>> a = []\n"
">>> b = []\n"
">>> a är b\n"
"Falsk"

msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr ""
"I standardbibliotekskoden ser du flera vanliga mönster för korrekt "
"användning av identitetstester:"

msgid ""
"As recommended by :pep:`8`, an identity test is the preferred way to check "
"for ``None``.  This reads like plain English in code and avoids confusion "
"with other objects that may have boolean values that evaluate to false."
msgstr ""
"Som rekommenderas av :pep:`8`, är ett identitetstest det föredragna sättet "
"att kontrollera för ``None``.  Detta låter som vanlig engelska i koden och "
"undviker förvirring med andra objekt som kan ha booleska värden som "
"utvärderas till false."

msgid ""
"Detecting optional arguments can be tricky when ``None`` is a valid input "
"value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`:"
msgstr ""
"Det kan vara svårt att upptäcka valfria argument när ``None`` är ett giltigt "
"inmatningsvärde.  I sådana situationer kan du skapa ett singleton sentinel-"
"objekt som garanterat skiljer sig från andra objekt.  Så här kan du till "
"exempel implementera en metod som beter sig som :meth:`dict.pop`:"

msgid ""
"_sentinel = object()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if key in self:\n"
"        value = self[key]\n"
"        del self[key]\n"
"        return value\n"
"    if default is _sentinel:\n"
"        raise KeyError(key)\n"
"    return default"
msgstr ""
"_sentinel = objekt()\n"
"\n"
"def pop(self, key, default=_sentinel):\n"
"    if nyckel i self:\n"
"        värde = self[nyckel]\n"
"        del self[nyckel]\n"
"        returnera värde\n"
"    om standard är _sentinel:\n"
"        raise KeyError(nyckel)\n"
"    returnera standard"

msgid ""
"Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"Containerimplementationer behöver ibland komplettera likhetstester med "
"identitetstester.  Detta förhindrar att koden blir förvirrad av objekt som "
"``float('NaN')`` som inte är lika med sig själva."

msgid ""
"For example, here is the implementation of :meth:`!collections.abc.Sequence."
"__contains__`::"
msgstr ""
"Här är till exempel implementeringen av :meth:`!collections.abc.Sequence."
"__contains__`::"

msgid ""
"def __contains__(self, value):\n"
"    for v in self:\n"
"        if v is value or v == value:\n"
"            return True\n"
"    return False"
msgstr ""
"def __contains__(self, värde):\n"
"    for v in self:\n"
"        om v är värde eller v == värde:\n"
"            return True\n"
"    returnera Falskt"

msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr ""
"Hur kan en underklass styra vilka data som lagras i en oföränderlig instans?"

msgid ""
"When subclassing an immutable type, override the :meth:`~object.__new__` "
"method instead of the :meth:`~object.__init__` method.  The latter only runs "
"*after* an instance is created, which is too late to alter data in an "
"immutable instance."
msgstr ""
"När du subklassar en oföränderlig typ ska du åsidosätta metoden :meth:"
"`~object.__new__` i stället för metoden :meth:`~object.__init__`.  Den "
"senare körs bara *efter* att en instans har skapats, vilket är för sent för "
"att ändra data i en oföränderlig instans."

msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr ""
"Alla dessa oföränderliga klasser har en annan signatur än sin överordnade "
"klass:"

msgid ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Always choose the first day of the month\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Allow text names for some numbers\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Convert str to name suitable for a URL path\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"
msgstr ""
"from datetime import date\n"
"\n"
"class FirstOfMonthDate(date):\n"
"    \"Always choose the first day of the month\"\n"
"    def __new__(cls, year, month, day):\n"
"        return super().__new__(cls, year, month, 1)\n"
"\n"
"class NamedInt(int):\n"
"    \"Allow text names for some numbers\"\n"
"    xlat = {'zero': 0, 'one': 1, 'ten': 10}\n"
"    def __new__(cls, value):\n"
"        value = cls.xlat.get(value, value)\n"
"        return super().__new__(cls, value)\n"
"\n"
"class TitleStr(str):\n"
"    \"Convert str to name suitable for a URL path\"\n"
"    def __new__(cls, s):\n"
"        s = s.lower().replace(' ', '-')\n"
"        s = ''.join([c for c in s if c.isalnum() or c == '-'])\n"
"        return super().__new__(cls, s)"

msgid "The classes can be used like this:"
msgstr "Klasserna kan användas på följande sätt:"

msgid ""
">>> FirstOfMonthDate(2012, 2, 14)\n"
"FirstOfMonthDate(2012, 2, 1)\n"
">>> NamedInt('ten')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blog: Why Python Rocks')\n"
"'blog-why-python-rocks'"
msgstr ""
">>> Första-månad-datum(2012, 2, 14)\n"
"Första-månad-datum(2012, 2, 1)\n"
">>> NamedInt('tio')\n"
"10\n"
">>> NamedInt(20)\n"
"20\n"
">>> TitleStr('Blogg: Varför Python rockar')\n"
"'blogg-varför-python-rockar'"

msgid "How do I cache method calls?"
msgstr "Hur cachar jag metodanrop?"

msgid ""
"The two principal tools for caching methods are :func:`functools."
"cached_property` and :func:`functools.lru_cache`.  The former stores results "
"at the instance level and the latter at the class level."
msgstr ""
"De två viktigaste verktygen för att cachelagra metoder är :func:`functools."
"cached_property` och :func:`functools.lru_cache`.  Det förstnämnda lagrar "
"resultat på instansnivå och det sistnämnda på klassnivå."

msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"Metoden *cached_property* fungerar bara med metoder som inte tar några "
"argument.  Den skapar inte någon referens till instansen.  Det cachade "
"metodresultatet sparas bara så länge som instansen är vid liv."

msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr ""
"Fördelen är att när en instans inte längre används kommer det cachade "
"metodresultatet att släppas direkt.  Nackdelen är att om instanser "
"ackumuleras, så kommer även de ackumulerade metodresultaten att göra det.  "
"De kan växa utan gräns."

msgid ""
"The *lru_cache* approach works with methods that have :term:`hashable` "
"arguments.  It creates a reference to the instance unless special efforts "
"are made to pass in weak references."
msgstr ""
"Metoden *lru_cache* fungerar med metoder som har :term:`hashable`-argument.  "
"Den skapar en referens till instansen om inte särskilda ansträngningar görs "
"för att skicka in svaga referenser."

msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr ""
"Fördelen med den senast använda algoritmen är att cacheminnet begränsas av "
"den angivna *maxstorleken*.  Nackdelen är att instanser hålls vid liv tills "
"de åldras ur cacheminnet eller tills cacheminnet rensas."

msgid "This example shows the various techniques::"
msgstr "Detta exempel visar de olika teknikerna::"

msgid ""
"class Weather:\n"
"    \"Lookup weather information on a government website\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # The _station_id is private and immutable\n"
"\n"
"    def current_temperature(self):\n"
"        \"Latest hourly observation\"\n"
"        # Do not cache this because old results\n"
"        # can be out of date.\n"
"\n"
"    @cached_property\n"
"    def location(self):\n"
"        \"Return the longitude/latitude coordinates of the station\"\n"
"        # Result only depends on the station_id\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Rainfall on a given date\"\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"klass Väder:\n"
"    \"Leta upp väderinformation på en statlig webbplats\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self._station_id = station_id\n"
"        # _station_id är privat och oföränderligt\n"
"\n"
"    def current_temperature(self):\n"
"        \"Senaste timobservationen\"\n"
"        # Cacha inte detta eftersom gamla resultat\n"
"        # kan vara föråldrade.\n"
"\n"
"    @cachad_egenskap\n"
"    def plats(själv):\n"
"        \"Returnera stationens longitud/latitudkoordinater\"\n"
"        # Resultatet beror bara på station_id\n"
"\n"
"    @lru_cache(maxstorlek=20)\n"
"    def historic_rainfall(self, date, units='mm'):\n"
"        \"Nederbörd på ett givet datum\"\n"
"        # Beror på station_id, datum och enheter."

msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"I exemplet ovan antas att *station_id* aldrig ändras.  Om de relevanta "
"instansattributen är föränderliga kan *cached_property*-metoden inte fungera "
"eftersom den inte kan upptäcka ändringar av attributen."

msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, the "
"class needs to define the :meth:`~object.__eq__` and :meth:`~object."
"__hash__` methods so that the cache can detect relevant attribute updates::"
msgstr ""
"För att *lru_cache*-strategin ska fungera när *station_id* är föränderligt "
"måste klassen definiera metoderna :meth:`~object.__eq__` och :meth:`~object."
"__hash__` så att cachen kan upptäcka relevanta attributuppdateringar::"

msgid ""
"class Weather:\n"
"    \"Example with a mutable station identifier\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxsize=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        'Rainfall on a given date'\n"
"        # Depends on the station_id, date, and units."
msgstr ""
"klass Väder:\n"
"    \"Exempel med en föränderlig stationsidentifierare\"\n"
"\n"
"    def __init__(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def change_station(self, station_id):\n"
"        self.station_id = station_id\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.station_id == other.station_id\n"
"\n"
"    def __hash__(self):\n"
"        return hash(self.station_id)\n"
"\n"
"    @lru_cache(maxstorlek=20)\n"
"    def historic_rainfall(self, date, units='cm'):\n"
"        \"Nederbörd på ett givet datum\n"
"        # Beror på station_id, datum och enheter."

msgid "Modules"
msgstr "Moduler"

msgid "How do I create a .pyc file?"
msgstr "Hur skapar jag en .pyc-fil?"

msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for details.)"
msgstr ""
"När en modul importeras för första gången (eller när källfilen har ändrats "
"sedan den aktuella kompilerade filen skapades) ska en fil med namnet ``."
"pyc`` som innehåller den kompilerade koden skapas i en underkatalog med "
"namnet ``__pycache__`` i katalogen som innehåller filen ``.py``. Filen ``."
"pyc`` har ett filnamn som börjar med samma namn som filen ``.py`` och slutar "
"med ``.pyc``, med en mittdel som beror på den specifika ``python``-binärfil "
"som skapade den. (Se :pep:`3147` för mer information.)"

msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"En anledning till att en ``.pyc``-fil inte kan skapas är ett "
"behörighetsproblem i den katalog som innehåller källfilen, vilket innebär "
"att underkatalogen ``__pycache__`` inte kan skapas. Detta kan t.ex. hända om "
"du utvecklar som en användare men kör som en annan, t.ex. om du testar med "
"en webbserver."

msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python "
"has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"Om inte miljövariabeln :envvar:`PYTHONDONTWRITEBYTECODE` är inställd, skapas "
"en .pyc-fil automatiskt om du importerar en modul och Python har möjlighet "
"(behörigheter, ledigt utrymme, etc...) att skapa en ``__pycache__`` "
"underkatalog och skriva den kompilerade modulen till den underkatalogen."

msgid ""
"Running Python on a top level script is not considered an import and no ``."
"pyc`` will be created.  For example, if you have a top-level module ``foo."
"py`` that imports another module ``xyz.py``, when you run ``foo`` (by typing "
"``python foo.py`` as a shell command), a ``.pyc`` will be created for "
"``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"Att köra Python på ett toppnivåskript betraktas inte som en import och ingen "
"``.pyc`` kommer att skapas.  Om du till exempel har en toppnivåmodul ``foo."
"py`` som importerar en annan modul ``xyz.py``, när du kör ``foo`` (genom att "
"skriva ``python foo.py`` som ett skalkommando), kommer en ``.pyc`` att "
"skapas för ``xyz`` eftersom ``xyz`` importeras, men ingen ``.pyc``-fil "
"kommer att skapas för ``foo`` eftersom ``foo.py`` inte importeras."

msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a ``."
"pyc`` file for a module that is not imported -- you can, using the :mod:"
"`py_compile` and :mod:`compileall` modules."
msgstr ""
"Om du behöver skapa en ``.pyc``-fil för ``foo`` - det vill säga skapa en ``."
"pyc``-fil för en modul som inte importeras - kan du göra det med hjälp av "
"modulerna :mod:`py_compile` och :mod:`compileall`."

msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to "
"use the ``compile()`` function in that module interactively::"
msgstr ""
"Modulen :mod:`py_compile` kan manuellt kompilera valfri modul.  Ett sätt är "
"att använda ``compile()``-funktionen i den modulen interaktivt::"

msgid ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"
msgstr ""
">>> import py_compile\n"
">>> py_compile.compile('foo.py')"

msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter "
"``cfile``)."
msgstr ""
"Detta kommer att skriva ``.pyc`` till en ``__pycache__`` underkatalog på "
"samma plats som ``foo.py`` (eller så kan du åsidosätta det med den valfria "
"parametern ``cfile``)."

msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"Du kan också automatiskt kompilera alla filer i en katalog eller flera "
"kataloger med modulen :mod:`compileall`.  Du kan göra det från skalprompten "
"genom att köra ``compileall.py`` och ange sökvägen till en katalog som "
"innehåller Python-filer som ska kompileras::"

msgid "python -m compileall ."
msgstr "python -m compileall ."

msgid "How do I find the current module name?"
msgstr "Hur hittar jag det aktuella modulnamnet?"

msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"En modul kan ta reda på sitt eget modulnamn genom att titta på den "
"fördefinierade globala variabeln ``__name__``.  Om denna har värdet "
"``'__main__'`` körs programmet som ett skript.  Många moduler som vanligtvis "
"används genom att importera dem tillhandahåller också ett "
"kommandoradsgränssnitt eller ett självtest, och kör endast denna kod efter "
"att ha kontrollerat ``__name__``::"

msgid ""
"def main():\n"
"    print('Running test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"def main():\n"
"    print('Kör test...')\n"
"    ...\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

msgid "How can I have modules that mutually import each other?"
msgstr "Hur kan jag ha moduler som ömsesidigt importerar varandra?"

msgid "Suppose you have the following modules:"
msgstr "Anta att du har följande moduler:"

msgid ":file:`foo.py`::"
msgstr ":fil:`foo.py`::"

msgid ""
"from bar import bar_var\n"
"foo_var = 1"
msgstr ""
"från bar import bar_var\n"
"foo_var = 1"

msgid ":file:`bar.py`::"
msgstr ":fil:`bar.py`::"

msgid ""
"from foo import foo_var\n"
"bar_var = 2"
msgstr ""
"från foo import foo_var\n"
"bar_var = 2"

msgid "The problem is that the interpreter will perform the following steps:"
msgstr "Problemet är att tolken kommer att utföra följande steg:"

msgid "main imports ``foo``"
msgstr "huvudimport ``foo``"

msgid "Empty globals for ``foo`` are created"
msgstr "Tomma globaler för ``foo`` skapas"

msgid "``foo`` is compiled and starts executing"
msgstr "``foo`` kompileras och börjar exekveras"

msgid "``foo`` imports ``bar``"
msgstr "``foo`` imports ``bar``"

msgid "Empty globals for ``bar`` are created"
msgstr "Tomma globaler för ``bar`` skapas"

msgid "``bar`` is compiled and starts executing"
msgstr "``bar`` kompileras och börjar exekveras"

msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr ""
"``bar`` imports ``foo`` (vilket är en no-op eftersom det redan finns en "
"modul som heter ``foo``)"

msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr ""
"Importmekanismen försöker läsa ``foo_var`` från ``foo`` globaler, för att "
"ställa in ``bar.foo_var = foo.foo_var``"

msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet "
"and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"Det sista steget misslyckas, eftersom Python inte är klar med tolkningen av "
"``foo`` ännu och den globala symbolordboken för ``foo`` fortfarande är tom."

msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr ""
"Samma sak händer när man använder ``import foo`` och sedan försöker komma åt "
"``foo.foo_var`` i global kod."

msgid "There are (at least) three possible workarounds for this problem."
msgstr "Det finns (minst) tre möjliga lösningar på det här problemet."

msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import ..."
"``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Guido van Rossum rekommenderar att man undviker all användning av ``from "
"<module> import ...`` och att all kod placeras i funktioner.  "
"Initialiseringar av globala variabler och klassvariabler bör endast använda "
"konstanter eller inbyggda funktioner.  Detta innebär att allt från en "
"importerad modul refereras som ``<module>.<name>``."

msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr ""
"Jim Roskind föreslår att du utför stegen i följande ordning i varje modul:"

msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr ""
"export (globaler, funktioner och klasser som inte behöver importerade "
"basklasser)"

msgid "``import`` statements"
msgstr "``import`` statements"

msgid ""
"active code (including globals that are initialized from imported values)."
msgstr "aktiv kod (inklusive globaler som initieras från importerade värden)."

msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr ""
"Van Rossum tycker inte så mycket om den här metoden eftersom importen hamnar "
"på ett konstigt ställe, men den fungerar."

msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr ""
"Matthias Urlichs rekommenderar att du omstrukturerar din kod så att den "
"rekursiva importen inte är nödvändig i första hand."

msgid "These solutions are not mutually exclusive."
msgstr "Dessa lösningar utesluter inte varandra."

msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') returnerar <modul 'x'>; hur får jag z?"

msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
"Överväg att använda bekvämlighetsfunktionen :func:`~importlib.import_module` "
"från :mod:`importlib` istället::"

msgid "z = importlib.import_module('x.y.z')"
msgstr "z = importlib.import_module('x.y.z')"

msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr ""
"När jag redigerar en importerad modul och importerar den på nytt visas inte "
"ändringarna.  Varför händer detta?"

msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force "
"re-reading of a changed module, do this::"
msgstr ""
"Av både effektivitets- och konsekvensskäl läser Python bara modulfilen "
"första gången en modul importeras.  Om den inte gjorde det, i ett program "
"som består av många moduler där var och en importerar samma grundmodul, "
"skulle grundmodulen analyseras och omanalyseras många gånger.  Gör så här "
"för att tvinga fram omläsning av en ändrad modul::"

msgid ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"
msgstr ""
"import importlib\n"
"import modname\n"
"importlib.reload(modname)"

msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr ""
"Varning: denna teknik är inte 100% fool-säker.  I synnerhet moduler som "
"innehåller uttalanden som ::"

msgid "from modname import some_objects"
msgstr "from modname import some_objects"

msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr ""
"kommer att fortsätta att fungera med den gamla versionen av de importerade "
"objekten.  Om modulen innehåller klassdefinitioner kommer befintliga "
"klassinstanser *inte* att uppdateras för att använda den nya "
"klassdefinitionen.  Detta kan resultera i följande paradoxala beteende::"

msgid ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Create an instance of C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance is false?!?\n"
"False"
msgstr ""
">>> import importlib\n"
">>> import cls\n"
">>> c = cls.C()                # Create an instance of C\n"
">>> importlib.reload(cls)\n"
"<module 'cls' from 'cls.py'>\n"
">>> isinstance(c, cls.C)       # isinstance is false?!?\n"
"False"

msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of "
"the class objects::"
msgstr ""
"Problemets natur klargörs om man skriver ut klassobjektens \"identitet\"::"

msgid ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"
msgstr ""
">>> hex(id(c.__class__))\n"
"'0x7352a0'\n"
">>> hex(id(cls.C))\n"
"'0x4198d0'"

msgid "argument"
msgstr "argument"

msgid "difference from parameter"
msgstr "skillnad från parameter"

msgid "parameter"
msgstr "parameter"

msgid "difference from argument"
msgstr "skillnad från argument"
