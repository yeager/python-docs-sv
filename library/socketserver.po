# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!socketserver` --- A framework for network servers"
msgstr ":mod:`!socketserver` --- Ett ramverk för nätverksservrar"

msgid "**Source code:** :source:`Lib/socketserver.py`"
msgstr "**Källkod:** :source:`Lib/socketserver.py`"

msgid ""
"The :mod:`socketserver` module simplifies the task of writing network "
"servers."
msgstr ""
"Modulen :mod:`socketserver` förenklar arbetet med att skriva nätverksservrar."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid "There are four basic concrete server classes:"
msgstr "Det finns fyra grundläggande konkreta serverklasser:"

msgid ""
"This uses the internet TCP protocol, which provides for continuous streams "
"of data between the client and server. If *bind_and_activate* is true, the "
"constructor automatically attempts to invoke :meth:`~BaseServer.server_bind` "
"and :meth:`~BaseServer.server_activate`.  The other parameters are passed to "
"the :class:`BaseServer` base class."
msgstr ""
"Detta använder TCP-protokollet för internet, vilket möjliggör kontinuerliga "
"dataströmmar mellan klienten och servern. Om *bind_and_activate* är true "
"försöker konstruktören automatiskt att anropa :meth:`~BaseServer."
"server_bind` och :meth:`~BaseServer.server_activate`.  De andra parametrarna "
"skickas till basklassen :class:`BaseServer`."

msgid ""
"This uses datagrams, which are discrete packets of information that may "
"arrive out of order or be lost while in transit.  The parameters are the "
"same as for :class:`TCPServer`."
msgstr ""
"Detta använder datagram, som är diskreta paket med information som kan "
"anlända i fel ordning eller förloras under transporten.  Parametrarna är "
"desamma som för :class:`TCPServer`."

msgid ""
"These more infrequently used classes are similar to the TCP and UDP classes, "
"but use Unix domain sockets; they're not available on non-Unix platforms.  "
"The parameters are the same as for :class:`TCPServer`."
msgstr ""
"Dessa mer sällan använda klasser liknar TCP- och UDP-klasserna, men använder "
"Unix-domänuttag; de är inte tillgängliga på plattformar som inte är Unix.  "
"Parametrarna är desamma som för :class:`TCPServer`."

msgid ""
"These four classes process requests :dfn:`synchronously`; each request must "
"be completed before the next request can be started.  This isn't suitable if "
"each request takes a long time to complete, because it requires a lot of "
"computation, or because it returns a lot of data which the client is slow to "
"process.  The solution is to create a separate process or thread to handle "
"each request; the :class:`ForkingMixIn` and :class:`ThreadingMixIn` mix-in "
"classes can be used to support asynchronous behaviour."
msgstr ""
"Dessa fyra klasser behandlar förfrågningar :dfn:`synkront`; varje förfrågan "
"måste slutföras innan nästa förfrågan kan startas.  Detta är inte lämpligt "
"om varje begäran tar lång tid att slutföra, eftersom den kräver mycket "
"beräkningar eller eftersom den returnerar mycket data som klienten är "
"långsam att bearbeta.  Lösningen är att skapa en separat process eller tråd "
"för att hantera varje begäran; mix-in-klasserna :class:`ForkingMixIn` och :"
"class:`ThreadingMixIn` kan användas för att stödja asynkront beteende."

msgid ""
"Creating a server requires several steps.  First, you must create a request "
"handler class by subclassing the :class:`BaseRequestHandler` class and "
"overriding its :meth:`~BaseRequestHandler.handle` method; this method will "
"process incoming requests.  Second, you must instantiate one of the server "
"classes, passing it the server's address and the request handler class. It "
"is recommended to use the server in a :keyword:`with` statement. Then call "
"the :meth:`~BaseServer.handle_request` or :meth:`~BaseServer.serve_forever` "
"method of the server object to process one or many requests.  Finally, call :"
"meth:`~BaseServer.server_close` to close the socket (unless you used a :"
"keyword:`!with` statement)."
msgstr ""
"Att skapa en server kräver flera steg.  Först måste du skapa en klass för "
"hantering av begäranden genom att subklassa klassen :class:"
"`BaseRequestHandler` och åsidosätta dess metod :meth:`~BaseRequestHandler."
"handle`; denna metod kommer att behandla inkommande begäranden.  För det "
"andra måste du instansiera en av serverklasserna och skicka serverns adress "
"och request handler-klassen till den. Det rekommenderas att använda servern "
"i en :keyword:`with`-sats. Anropa sedan metoden :meth:`~BaseServer."
"handle_request` eller :meth:`~BaseServer.serve_forever` i serverobjektet för "
"att behandla en eller flera förfrågningar.  Slutligen anropa :meth:"
"`~BaseServer.server_close` för att stänga socket (om du inte använde en :"
"keyword:`!with`-sats)."

msgid ""
"When inheriting from :class:`ThreadingMixIn` for threaded connection "
"behavior, you should explicitly declare how you want your threads to behave "
"on an abrupt shutdown.  The :class:`ThreadingMixIn` class defines an "
"attribute *daemon_threads*, which indicates whether or not the server should "
"wait for thread termination.  You should set the flag explicitly if you "
"would like threads to behave autonomously; the default is :const:`False`, "
"meaning that Python will not exit until all threads created by :class:"
"`ThreadingMixIn` have exited."
msgstr ""
"När du ärver från :class:`ThreadingMixIn` för trådat anslutningsbeteende bör "
"du uttryckligen deklarera hur du vill att dina trådar ska bete sig vid en "
"plötslig avstängning.  Klassen :class:`ThreadingMixIn` definierar ett "
"attribut *daemon_threads*, som anger om servern ska vänta på att tråden "
"avslutas eller inte.  Du bör sätta flaggan explicit om du vill att trådarna "
"ska bete sig självständigt; standardvärdet är :const:`False`, vilket innebär "
"att Python inte kommer att avslutas förrän alla trådar som skapats av :class:"
"`ThreadingMixIn` har avslutats."

msgid ""
"Server classes have the same external methods and attributes, no matter what "
"network protocol they use."
msgstr ""
"Serverklasser har samma externa metoder och attribut, oavsett vilket "
"nätverksprotokoll de använder."

msgid "Server Creation Notes"
msgstr "Anteckningar om skapande av server"

msgid ""
"There are five classes in an inheritance diagram, four of which represent "
"synchronous servers of four types::"
msgstr ""
"Det finns fem klasser i ett arvsdiagram, varav fyra representerar synkrona "
"servrar av fyra typer::"

msgid ""
"+------------+\n"
"| BaseServer |\n"
"+------------+\n"
"      |\n"
"      v\n"
"+-----------+        +------------------+\n"
"| TCPServer |------->| UnixStreamServer |\n"
"+-----------+        +------------------+\n"
"      |\n"
"      v\n"
"+-----------+        +--------------------+\n"
"| UDPServer |------->| UnixDatagramServer |\n"
"+-----------+        +--------------------+"
msgstr ""
"+------------+\n"
"| BaseServer |\n"
"+------------+\n"
"      |\n"
"      v\n"
"+-----------+        +------------------+\n"
"| TCPServer |------->| UnixStreamServer |\n"
"+-----------+        +------------------+\n"
"      |\n"
"      v\n"
"+-----------+        +--------------------+\n"
"| UDPServer |------->| UnixDatagramServer |\n"
"+-----------+        +--------------------+"

msgid ""
"Note that :class:`UnixDatagramServer` derives from :class:`UDPServer`, not "
"from :class:`UnixStreamServer` --- the only difference between an IP and a "
"Unix server is the address family."
msgstr ""
"Observera att :class:`UnixDatagramServer` härstammar från :class:"
"`UDPServer`, inte från :class:`UnixStreamServer` --- den enda skillnaden "
"mellan en IP- och en Unix-server är adressfamiljen."

msgid ""
"Forking and threading versions of each type of server can be created using "
"these mix-in classes.  For instance, :class:`ThreadingUDPServer` is created "
"as follows::"
msgstr ""
"Forking- och threading-versioner av varje typ av server kan skapas med hjälp "
"av dessa mix-in-klasser.  Till exempel skapas :class:`ThreadingUDPServer` på "
"följande sätt::"

msgid ""
"class ThreadingUDPServer(ThreadingMixIn, UDPServer):\n"
"    pass"
msgstr ""
"klass ThreadingUDPServer(ThreadingMixIn, UDPServer):\n"
"    pass"

msgid ""
"The mix-in class comes first, since it overrides a method defined in :class:"
"`UDPServer`.  Setting the various attributes also changes the behavior of "
"the underlying server mechanism."
msgstr ""
"Mix-in-klassen kommer först, eftersom den åsidosätter en metod som "
"definieras i :class:`UDPServer`.  Genom att ställa in de olika attributen "
"ändras också beteendet hos den underliggande servermekanismen."

msgid ""
":class:`ForkingMixIn` and the Forking classes mentioned below are only "
"available on POSIX platforms that support :func:`~os.fork`."
msgstr ""
":class:`ForkingMixIn` och de Forking-klasser som nämns nedan är endast "
"tillgängliga på POSIX-plattformar som stöder :func:`~os.fork`."

msgid ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` waits until all "
"child processes complete, except if :attr:`block_on_close` attribute is "
"``False``."
msgstr ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` väntar tills "
"alla underordnade processer har slutförts, förutom om attributet :attr:"
"`block_on_close` är ``False``."

msgid ""
":meth:`ThreadingMixIn.server_close <BaseServer.server_close>` waits until "
"all non-daemon threads complete, except if :attr:`block_on_close` attribute "
"is ``False``."
msgstr ""
":meth:`ThreadingMixIn.server_close <BaseServer.server_close>` väntar tills "
"alla icke-daemon-trådar har avslutats, förutom om attributet :attr:"
"`block_on_close` är ``False``."

msgid ""
"Specify how many child processes will exist to handle requests at a time "
"for :class:`ForkingMixIn`.  If the limit is reached, new requests will wait "
"until one child process has finished."
msgstr ""
"Ange hur många underordnade processer som ska finnas för att hantera "
"begäranden åt gången för :class:`ForkingMixIn`.  Om gränsen nås kommer nya "
"förfrågningar att vänta tills en underordnad process har avslutats."

msgid ""
"For :class:`ThreadingMixIn` use daemonic threads by setting :data:"
"`ThreadingMixIn.daemon_threads <daemon_threads>` to ``True`` to not wait "
"until threads complete."
msgstr ""
"För :class:`ThreadingMixIn` använd daemoniska trådar genom att ställa in :"
"data:`ThreadingMixIn.daemon_threads <daemon_threads>` till ``True`` för att "
"inte vänta tills trådarna är klara."

msgid ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` and :meth:"
"`ThreadingMixIn.server_close <BaseServer.server_close>` now waits until all "
"child processes and non-daemonic threads complete. Add a new :attr:"
"`ForkingMixIn.block_on_close <block_on_close>` class attribute to opt-in for "
"the pre-3.7 behaviour."
msgstr ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` och :meth:"
"`ThreadingMixIn.server_close <BaseServer.server_close>` väntar nu tills alla "
"underordnade processer och icke-daemoniska trådar har slutförts. Lägg till "
"ett nytt klassattribut :attr:`ForkingMixIn.block_on_close <block_on_close>` "
"för att välja beteendet från före 3.7."

msgid "These classes are pre-defined using the mix-in classes."
msgstr "Dessa klasser är fördefinierade med hjälp av mix-in-klasserna."

msgid ""
"The ``ForkingUnixStreamServer`` and ``ForkingUnixDatagramServer`` classes "
"were added."
msgstr ""
"Klasserna ``ForkingUnixStreamServer`` och ``ForkingUnixDatagramServer`` "
"lades till."

msgid ""
"To implement a service, you must derive a class from :class:"
"`BaseRequestHandler` and redefine its :meth:`~BaseRequestHandler.handle` "
"method. You can then run various versions of the service by combining one of "
"the server classes with your request handler class.  The request handler "
"class must be different for datagram or stream services.  This can be hidden "
"by using the handler subclasses :class:`StreamRequestHandler` or :class:"
"`DatagramRequestHandler`."
msgstr ""
"För att implementera en tjänst måste du härleda en klass från :class:"
"`BaseRequestHandler` och omdefiniera dess :meth:`~BaseRequestHandler.handle`-"
"metod. Du kan sedan köra olika versioner av tjänsten genom att kombinera en "
"av serverklasserna med din request handler-klass.  Klassen för hantering av "
"begäran måste vara olika för datagram- och strömtjänster.  Detta kan döljas "
"genom att använda hanterarsubklasserna :class:`StreamRequestHandler` eller :"
"class:`DatagramRequestHandler`."

msgid ""
"Of course, you still have to use your head!  For instance, it makes no sense "
"to use a forking server if the service contains state in memory that can be "
"modified by different requests, since the modifications in the child process "
"would never reach the initial state kept in the parent process and passed to "
"each child.  In this case, you can use a threading server, but you will "
"probably have to use locks to protect the integrity of the shared data."
msgstr ""
"Naturligtvis måste du fortfarande använda ditt huvud!  Det är till exempel "
"inte meningsfullt att använda en forking-server om tjänsten innehåller "
"tillstånd i minnet som kan ändras av olika förfrågningar, eftersom "
"ändringarna i barnprocessen aldrig skulle nå det ursprungliga tillståndet "
"som förvaras i moderprocessen och skickas till varje barn.  I det här fallet "
"kan du använda en threading-server, men du måste förmodligen använda lås för "
"att skydda integriteten hos de delade data."

msgid ""
"On the other hand, if you are building an HTTP server where all data is "
"stored externally (for instance, in the file system), a synchronous class "
"will essentially render the service \"deaf\" while one request is being "
"handled -- which may be for a very long time if a client is slow to receive "
"all the data it has requested.  Here a threading or forking server is "
"appropriate."
msgstr ""
"Om du å andra sidan bygger en HTTP-server där all data lagras externt (t.ex. "
"i filsystemet), kommer en synkron klass i princip att göra tjänsten \"döv\" "
"medan en förfrågan hanteras - vilket kan ta mycket lång tid om en klient är "
"långsam med att få all data som den har begärt.  Här är en threading- eller "
"forking-server lämplig."

msgid ""
"In some cases, it may be appropriate to process part of a request "
"synchronously, but to finish processing in a forked child depending on the "
"request data.  This can be implemented by using a synchronous server and "
"doing an explicit fork in the request handler class :meth:"
"`~BaseRequestHandler.handle` method."
msgstr ""
"I vissa fall kan det vara lämpligt att behandla en del av en begäran "
"synkront, men att avsluta behandlingen i en förgrenad underordnad del "
"beroende på begärandedata.  Detta kan implementeras genom att använda en "
"synkron server och göra en explicit förgrening i klassen för hantering av "
"begäran :meth:`~BaseRequestHandler.handle` method."

msgid ""
"Another approach to handling multiple simultaneous requests in an "
"environment that supports neither threads nor :func:`~os.fork` (or where "
"these are too expensive or inappropriate for the service) is to maintain an "
"explicit table of partially finished requests and to use :mod:`selectors` to "
"decide which request to work on next (or whether to handle a new incoming "
"request).  This is particularly important for stream services where each "
"client can potentially be connected for a long time (if threads or "
"subprocesses cannot be used)."
msgstr ""
"En annan metod för att hantera flera samtidiga förfrågningar i en miljö som "
"varken stöder trådar eller :func:`~os.fork` (eller där dessa är för dyra "
"eller olämpliga för tjänsten) är att upprätthålla en explicit tabell över "
"delvis avslutade förfrågningar och att använda :mod:`selectors` för att "
"bestämma vilken förfrågan som ska bearbetas härnäst (eller om en ny "
"inkommande förfrågan ska hanteras).  Detta är särskilt viktigt för "
"strömtjänster där varje klient potentiellt kan vara ansluten under lång tid "
"(om trådar eller underprocesser inte kan användas)."

msgid "Server Objects"
msgstr "Serverobjekt"

msgid ""
"This is the superclass of all Server objects in the module.  It defines the "
"interface, given below, but does not implement most of the methods, which is "
"done in subclasses.  The two parameters are stored in the respective :attr:"
"`server_address` and :attr:`RequestHandlerClass` attributes."
msgstr ""
"Detta är superklassen för alla Server-objekt i modulen.  Den definierar det "
"gränssnitt som anges nedan, men implementerar inte de flesta metoderna, "
"vilket görs i underklasser.  De två parametrarna lagras i respektive "
"attribut :attr:`server_address` och :attr:`RequestHandlerClass`."

msgid ""
"Return an integer file descriptor for the socket on which the server is "
"listening.  This function is most commonly passed to :mod:`selectors`, to "
"allow monitoring multiple servers in the same process."
msgstr ""
"Returnerar en heltalsfilbeskrivning för det uttag som servern lyssnar på.  "
"Denna funktion skickas oftast till :mod:`selectors`, för att möjliggöra "
"övervakning av flera servrar i samma process."

msgid ""
"Process a single request.  This function calls the following methods in "
"order: :meth:`get_request`, :meth:`verify_request`, and :meth:"
"`process_request`.  If the user-provided :meth:`~BaseRequestHandler.handle` "
"method of the handler class raises an exception, the server's :meth:"
"`handle_error` method will be called.  If no request is received within :"
"attr:`timeout` seconds, :meth:`handle_timeout` will be called and :meth:"
"`handle_request` will return."
msgstr ""
"Behandla en enskild begäran.  Denna funktion anropar följande metoder i "
"ordning: :meth:`get_request`, :meth:`verify_request`, och :meth:"
"`process_request`.  Om den användartillhandahållna metoden :meth:"
"`~BaseRequestHandler.handle` i klassen handler ger upphov till ett undantag, "
"anropas serverns metod :meth:`handle_error`.  Om ingen begäran tas emot "
"inom :attr:`timeout` sekunder, anropas :meth:`handle_timeout` och :meth:"
"`handle_request` returneras."

msgid ""
"Handle requests until an explicit :meth:`shutdown` request.  Poll for "
"shutdown every *poll_interval* seconds. Ignores the :attr:`timeout` "
"attribute.  It also calls :meth:`service_actions`, which may be used by a "
"subclass or mixin to provide actions specific to a given service.  For "
"example, the :class:`ForkingMixIn` class uses :meth:`service_actions` to "
"clean up zombie child processes."
msgstr ""
"Hantera förfrågningar fram till en explicit :meth:`shutdown`-förfrågan.  "
"Pollar för avstängning varje *poll_interval* sekund. Ignorerar attributet :"
"attr:`timeout`.  Den anropar också :meth:`service_actions`, som kan användas "
"av en subklass eller mixin för att tillhandahålla åtgärder som är specifika "
"för en viss tjänst.  Till exempel använder klassen :class:`ForkingMixIn` :"
"meth:`service_actions` för att rensa upp zombiebarnprocesser."

msgid "Added ``service_actions`` call to the ``serve_forever`` method."
msgstr "Lagt till anropet ``service_actions`` till metoden ``serve_forever``."

msgid ""
"This is called in the :meth:`serve_forever` loop. This method can be "
"overridden by subclasses or mixin classes to perform actions specific to a "
"given service, such as cleanup actions."
msgstr ""
"Detta anropas i :meth:`serve_forever'-loopen. Denna metod kan åsidosättas av "
"subklasser eller mixin-klasser för att utföra åtgärder som är specifika för "
"en viss tjänst, t.ex. rensningsåtgärder."

msgid ""
"Tell the :meth:`serve_forever` loop to stop and wait until it does. :meth:"
"`shutdown` must be called while :meth:`serve_forever` is running in a "
"different thread otherwise it will deadlock."
msgstr ""
"Be :meth:`serve_forever`-loopen att sluta och vänta tills den gör det. :meth:"
"`shutdown` måste anropas medan :meth:`serve_forever` körs i en annan tråd "
"annars kommer den att låsa sig."

msgid "Clean up the server. May be overridden."
msgstr "Städa upp på servern. Kan åsidosättas."

msgid ""
"The family of protocols to which the server's socket belongs.  Common "
"examples are :const:`socket.AF_INET`, :const:`socket.AF_INET6`, and :const:"
"`socket.AF_UNIX`.  Subclass the TCP or UDP server classes in this module "
"with class attribute ``address_family = AF_INET6`` set if you want IPv6 "
"server classes."
msgstr ""
"Den familj av protokoll som serverns socket tillhör.  Vanliga exempel är :"
"const:`socket.AF_INET`, :const:`socket.AF_INET6` och :const:`socket."
"AF_UNIX`.  Underordna TCP- eller UDP-serverklasserna i den här modulen med "
"klassattributet ``address_family = AF_INET6`` inställt om du vill ha IPv6-"
"serverklasser."

msgid ""
"The user-provided request handler class; an instance of this class is "
"created for each request."
msgstr ""
"Den användartillhandahållna klassen för hantering av begäran; en instans av "
"denna klass skapas för varje begäran."

msgid ""
"The address on which the server is listening.  The format of addresses "
"varies depending on the protocol family; see the documentation for the :mod:"
"`socket` module for details.  For internet protocols, this is a tuple "
"containing a string giving the address, and an integer port number: "
"``('127.0.0.1', 80)``, for example."
msgstr ""
"Den adress som servern lyssnar på.  Adressernas format varierar beroende på "
"protokollfamilj; se dokumentationen för modulen :mod:`socket` för mer "
"information.  För internetprotokoll är detta en tupel som innehåller en "
"sträng som anger adressen och ett heltals portnummer: ``('127.0.0.1', 80)``, "
"till exempel."

msgid ""
"The socket object on which the server will listen for incoming requests."
msgstr ""
"Det socket-objekt som servern ska lyssna på för inkommande förfrågningar."

msgid "The server classes support the following class variables:"
msgstr "Serverklasserna har stöd för följande klassvariabler:"

msgid ""
"Whether the server will allow the reuse of an address.  This defaults to :"
"const:`False`, and can be set in subclasses to change the policy."
msgstr ""
"Om servern tillåter återanvändning av en adress.  Standardvärdet är :const:"
"`False`, och kan ställas in i underklasser för att ändra policyn."

msgid ""
"The size of the request queue.  If it takes a long time to process a single "
"request, any requests that arrive while the server is busy are placed into a "
"queue, up to :attr:`request_queue_size` requests.  Once the queue is full, "
"further requests from clients will get a \"Connection denied\" error.  The "
"default value is usually 5, but this can be overridden by subclasses."
msgstr ""
"Storleken på förfrågningskön.  Om det tar lång tid att behandla en enskild "
"begäran placeras alla begäranden som kommer in medan servern är upptagen i "
"en kö, upp till :attr:`request_queue_size` begäranden.  När kön är full "
"kommer ytterligare förfrågningar från klienter att få felmeddelandet "
"\"Connection denied\".  Standardvärdet är vanligtvis 5, men detta kan "
"åsidosättas av underklasser."

msgid ""
"The type of socket used by the server; :const:`socket.SOCK_STREAM` and :"
"const:`socket.SOCK_DGRAM` are two common values."
msgstr ""
"Den typ av socket som används av servern; :const:`socket.SOCK_STREAM` och :"
"const:`socket.SOCK_DGRAM` är två vanliga värden."

msgid ""
"Timeout duration, measured in seconds, or :const:`None` if no timeout is "
"desired.  If :meth:`handle_request` receives no incoming requests within the "
"timeout period, the :meth:`handle_timeout` method is called."
msgstr ""
"Timeout-tid, mätt i sekunder, eller :const:`None` om ingen timeout önskas.  "
"Om :meth:`handle_request` inte får några inkommande förfrågningar inom "
"timeout-perioden anropas metoden :meth:`handle_timeout`."

msgid ""
"There are various server methods that can be overridden by subclasses of "
"base server classes like :class:`TCPServer`; these methods aren't useful to "
"external users of the server object."
msgstr ""
"Det finns olika servermetoder som kan åsidosättas av underklasser av "
"basserverklasser som :class:`TCPServer`; dessa metoder är inte användbara "
"för externa användare av serverobjektet."

msgid ""
"Actually processes the request by instantiating :attr:`RequestHandlerClass` "
"and calling its :meth:`~BaseRequestHandler.handle` method."
msgstr ""
"Behandlar faktiskt begäran genom att instansiera :attr:`RequestHandlerClass` "
"och anropa dess :meth:`~BaseRequestHandler.handle`-metod."

msgid ""
"Must accept a request from the socket, and return a 2-tuple containing the "
"*new* socket object to be used to communicate with the client, and the "
"client's address."
msgstr ""
"Måste acceptera en begäran från sockeln och returnera en 2-tupel som "
"innehåller det *nya* socketobjektet som ska användas för att kommunicera med "
"klienten och klientens adress."

msgid ""
"This function is called if the :meth:`~BaseRequestHandler.handle` method of "
"a :attr:`RequestHandlerClass` instance raises an exception.  The default "
"action is to print the traceback to standard error and continue handling "
"further requests."
msgstr ""
"Denna funktion anropas om metoden :meth:`~BaseRequestHandler.handle` i en "
"instans av :attr:`RequestHandlerClass` ger upphov till ett undantag.  "
"Standardåtgärden är att skriva ut spårningen till standardfelet och "
"fortsätta att hantera ytterligare förfrågningar."

msgid "Now only called for exceptions derived from the :exc:`Exception` class."
msgstr ""
"Anropas nu endast för undantag som härrör från klassen :exc:`Exception`."

msgid ""
"This function is called when the :attr:`timeout` attribute has been set to a "
"value other than :const:`None` and the timeout period has passed with no "
"requests being received.  The default action for forking servers is to "
"collect the status of any child processes that have exited, while in "
"threading servers this method does nothing."
msgstr ""
"Denna funktion anropas när attributet :attr:`timeout` har angetts till ett "
"annat värde än :const:`None` och timeout-perioden har löpt ut utan att några "
"begäranden har tagits emot.  Standardåtgärden för forking-servrar är att "
"samla in status för alla underordnade processer som har avslutats, medan den "
"här metoden inte gör någonting i threading-servrar."

msgid ""
"Calls :meth:`finish_request` to create an instance of the :attr:"
"`RequestHandlerClass`.  If desired, this function can create a new process "
"or thread to handle the request; the :class:`ForkingMixIn` and :class:"
"`ThreadingMixIn` classes do this."
msgstr ""
"Anropar :meth:`finish_request` för att skapa en instans av :attr:"
"`RequestHandlerClass`.  Om så önskas kan denna funktion skapa en ny process "
"eller tråd för att hantera begäran; klasserna :class:`ForkingMixIn` och :"
"class:`ThreadingMixIn` gör detta."

msgid ""
"Called by the server's constructor to activate the server.  The default "
"behavior for a TCP server just invokes :meth:`~socket.socket.listen` on the "
"server's socket.  May be overridden."
msgstr ""
"Anropas av serverkonstruktören för att aktivera servern.  Standardbeteendet "
"för en TCP-server anropar bara :meth:`~socket.socket.listen` på serverns "
"socket.  Kan åsidosättas."

msgid ""
"Called by the server's constructor to bind the socket to the desired "
"address. May be overridden."
msgstr ""
"Anropas av serverkonstruktören för att binda sockeln till önskad adress. Kan "
"åsidosättas."

msgid ""
"Must return a Boolean value; if the value is :const:`True`, the request will "
"be processed, and if it's :const:`False`, the request will be denied.  This "
"function can be overridden to implement access controls for a server. The "
"default implementation always returns :const:`True`."
msgstr ""
"Måste returnera ett booleskt värde; om värdet är :const:`True` kommer "
"begäran att behandlas, och om det är :const:`False` kommer begäran att "
"nekas.  Denna funktion kan åsidosättas för att implementera "
"åtkomstkontroller för en server. Standardimplementeringen returnerar alltid :"
"const:`True`."

msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`server_close`."
msgstr ""
"Stöd för protokollet :term:`context manager` har lagts till.  Att avsluta "
"kontexthanteraren är likvärdigt med att anropa :meth:`server_close`."

msgid "Request Handler Objects"
msgstr "Objekt för hantering av begäran"

msgid ""
"This is the superclass of all request handler objects.  It defines the "
"interface, given below.  A concrete request handler subclass must define a "
"new :meth:`handle` method, and can override any of the other methods.  A new "
"instance of the subclass is created for each request."
msgstr ""
"Detta är superklassen för alla request handler-objekt.  Den definierar det "
"gränssnitt som anges nedan.  En konkret subklass av request handler måste "
"definiera en ny :meth:`handle`-metod och kan åsidosätta alla andra metoder.  "
"En ny instans av subklassen skapas för varje begäran."

msgid ""
"Called before the :meth:`handle` method to perform any initialization "
"actions required.  The default implementation does nothing."
msgstr ""
"Anropas före :meth:`handle`-metoden för att utföra eventuella "
"initialiseringsåtgärder som krävs.  Standardimplementationen gör ingenting."

msgid ""
"This function must do all the work required to service a request.  The "
"default implementation does nothing.  Several instance attributes are "
"available to it; the request is available as :attr:`request`; the client "
"address as :attr:`client_address`; and the server instance as :attr:"
"`server`, in case it needs access to per-server information."
msgstr ""
"Denna funktion måste göra allt arbete som krävs för att hantera en begäran.  "
"Standardimplementationen gör ingenting.  Flera instansattribut är "
"tillgängliga för den; begäran är tillgänglig som :attr:`request`; "
"klientadressen som :attr:`client_address`; och serverinstansen som :attr:"
"`server`, om den behöver tillgång till information per server."

msgid ""
"The type of :attr:`request` is different for datagram or stream services.  "
"For stream services, :attr:`request` is a socket object; for datagram "
"services, :attr:`request` is a pair of string and socket."
msgstr ""
"Typen av :attr:`request` är olika för datagram- och strömtjänster.  För "
"strömtjänster är :attr:`request` ett socket-objekt; för datagramtjänster är :"
"attr:`request` ett par av string och socket."

msgid ""
"Called after the :meth:`handle` method to perform any clean-up actions "
"required.  The default implementation does nothing.  If :meth:`setup` raises "
"an exception, this function will not be called."
msgstr ""
"Anropas efter :meth:`handle`-metoden för att utföra eventuella "
"rengöringsåtgärder som krävs.  Standardimplementationen gör ingenting.  Om :"
"meth:`setup` ger upphov till ett undantag, kommer denna funktion inte att "
"anropas."

msgid ""
"The *new* :class:`socket.socket` object to be used to communicate with the "
"client."
msgstr ""
"Det *nya* :class:`socket.socket`-objektet som ska användas för att "
"kommunicera med klienten."

msgid "Client address returned by :meth:`BaseServer.get_request`."
msgstr "Klientadress som returneras av :meth:`BaseServer.get_request`."

msgid ":class:`BaseServer` object used for handling the request."
msgstr ":class:`BaseServer`-objekt som används för att hantera begäran."

msgid ""
"These :class:`BaseRequestHandler` subclasses override the :meth:"
"`~BaseRequestHandler.setup` and :meth:`~BaseRequestHandler.finish` methods, "
"and provide :attr:`rfile` and :attr:`wfile` attributes."
msgstr ""
"Dessa :class:`BaseRequestHandler` subklasser åsidosätter metoderna :meth:"
"`~BaseRequestHandler.setup` och :meth:`~BaseRequestHandler.finish`, och "
"tillhandahåller attributen :attr:`rfile` och :attr:`wfile`."

msgid ""
"A file object from which receives the request is read. Support the :class:"
"`io.BufferedIOBase` readable interface."
msgstr ""
"Ett filobjekt som tar emot begäran läses från. Stöder det läsbara "
"gränssnittet :class:`io.BufferedIOBase`."

msgid ""
"A file object to which the reply is written. Support the :class:`io."
"BufferedIOBase` writable interface"
msgstr ""
"Ett filobjekt som svaret skrivs till. Stöder det skrivbara gränssnittet :"
"class:`io.BufferedIOBase`"

msgid ""
":attr:`wfile` also supports the :class:`io.BufferedIOBase` writable "
"interface."
msgstr ""
":attr:`wfile` stöder också det skrivbara gränssnittet :class:`io."
"BufferedIOBase`."

msgid "Examples"
msgstr "Exempel"

msgid ":class:`socketserver.TCPServer` Example"
msgstr ":class:`socketserver.TCPServer` Exempel"

msgid "This is the server side::"
msgstr "Detta är serversidan::"

msgid ""
"import socketserver\n"
"\n"
"class MyTCPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    The request handler class for our server.\n"
"\n"
"    It is instantiated once per connection to the server, and must\n"
"    override the handle() method to implement communication to the\n"
"    client.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        # self.request is the TCP socket connected to the client\n"
"        pieces = [b'']\n"
"        total = 0\n"
"        while b'\\n' not in pieces[-1] and total < 10_000:\n"
"            pieces.append(self.request.recv(2000))\n"
"            total += len(pieces[-1])\n"
"        self.data = b''.join(pieces)\n"
"        print(f\"Received from {self.client_address[0]}:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # just send back the same data, but upper-cased\n"
"        self.request.sendall(self.data.upper())\n"
"        # after we return, the socket will be closed.\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"\n"
"    # Create the server, binding to localhost on port 9999\n"
"    with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:\n"
"        # Activate the server; this will keep running until you\n"
"        # interrupt the program with Ctrl-C\n"
"        server.serve_forever()"
msgstr ""
"import socketserver\n"
"\n"
"class MyTCPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    The request handler class for our server.\n"
"\n"
"    It is instantiated once per connection to the server, and must\n"
"    override the handle() method to implement communication to the\n"
"    client.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        # self.request is the TCP socket connected to the client\n"
"        pieces = [b'']\n"
"        total = 0\n"
"        while b'\\n' not in pieces[-1] and total < 10_000:\n"
"            pieces.append(self.request.recv(2000))\n"
"            total += len(pieces[-1])\n"
"        self.data = b''.join(pieces)\n"
"        print(f\"Received from {self.client_address[0]}:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # just send back the same data, but upper-cased\n"
"        self.request.sendall(self.data.upper())\n"
"        # after we return, the socket will be closed.\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"\n"
"    # Create the server, binding to localhost on port 9999\n"
"    with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:\n"
"        # Activate the server; this will keep running until you\n"
"        # interrupt the program with Ctrl-C\n"
"        server.serve_forever()"

msgid ""
"An alternative request handler class that makes use of streams (file-like "
"objects that simplify communication by providing the standard file "
"interface)::"
msgstr ""
"En alternativ klass för hantering av förfrågningar som använder sig av "
"strömmar (filliknande objekt som förenklar kommunikation genom att "
"tillhandahålla standardgränssnittet för filer)::"

msgid ""
"class MyTCPHandler(socketserver.StreamRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        # self.rfile is a file-like object created by the handler.\n"
"        # We can now use e.g. readline() instead of raw recv() calls.\n"
"        # We limit ourselves to 10000 bytes to avoid abuse by the sender.\n"
"        self.data = self.rfile.readline(10000).rstrip()\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # Likewise, self.wfile is a file-like object used to write back\n"
"        # to the client\n"
"        self.wfile.write(self.data.upper())"
msgstr ""
"class MyTCPHandler(socketserver.StreamRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        # self.rfile is a file-like object created by the handler.\n"
"        # We can now use e.g. readline() instead of raw recv() calls.\n"
"        # We limit ourselves to 10000 bytes to avoid abuse by the sender.\n"
"        self.data = self.rfile.readline(10000).rstrip()\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # Likewise, self.wfile is a file-like object used to write back\n"
"        # to the client\n"
"        self.wfile.write(self.data.upper())"

msgid ""
"The difference is that the ``readline()`` call in the second handler will "
"call ``recv()`` multiple times until it encounters a newline character, "
"while the first handler had to use a ``recv()`` loop to accumulate data "
"until a newline itself.  If it had just used a single ``recv()`` without the "
"loop it would just have returned what has been received so far from the "
"client. TCP is stream based: data arrives in the order it was sent, but "
"there no correlation between client ``send()`` or ``sendall()`` calls and "
"the number of ``recv()`` calls on the server required to receive it."
msgstr ""
"Skillnaden är att ``readline()``-anropet i den andra hanteraren kommer att "
"anropa ``recv()`` flera gånger tills den stöter på ett tecken för ny rad, "
"medan den första hanteraren måste använda en ``recv()``-loop för att "
"ackumulera data tills den själv stöter på en ny rad.  Om den bara hade "
"använt en enda ``recv()`` utan slingan skulle den bara ha returnerat det som "
"hittills har tagits emot från klienten. TCP är strömbaserat: data anländer i "
"den ordning de skickades, men det finns ingen korrelation mellan klientens "
"```end()`` eller ```endall()``-anrop och antalet ``recv()``-anrop på servern "
"som krävs för att ta emot dem."

msgid "This is the client side::"
msgstr "Detta är klientsidan::"

msgid ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# Create a socket (SOCK_STREAM means a TCP socket)\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"    # Connect to server and send data\n"
"    sock.connect((HOST, PORT))\n"
"    sock.sendall(bytes(data, \"utf-8\"))\n"
"    sock.sendall(b\"\\n\")\n"
"\n"
"    # Receive data from the server and shut down\n"
"    received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"
msgstr ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# Create a socket (SOCK_STREAM means a TCP socket)\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"    # Connect to server and send data\n"
"    sock.connect((HOST, PORT))\n"
"    sock.sendall(bytes(data, \"utf-8\"))\n"
"    sock.sendall(b\"\\n\")\n"
"\n"
"    # Receive data from the server and shut down\n"
"    received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"

msgid "The output of the example should look something like this:"
msgstr "Utdata från exemplet bör se ut ungefär så här:"

msgid "Server:"
msgstr "Server:"

msgid ""
"$ python TCPServer.py\n"
"127.0.0.1 wrote:\n"
"b'hello world with TCP'\n"
"127.0.0.1 wrote:\n"
"b'python is nice'"
msgstr ""
"$ python TCPServer.py\n"
"127.0.0.1 wrote:\n"
"b'hello world with TCP'\n"
"127.0.0.1 wrote:\n"
"b'python is nice'"

msgid "Client:"
msgstr "Klient:"

msgid ""
"$ python TCPClient.py hello world with TCP\n"
"Sent:     hello world with TCP\n"
"Received: HELLO WORLD WITH TCP\n"
"$ python TCPClient.py python is nice\n"
"Sent:     python is nice\n"
"Received: PYTHON IS NICE"
msgstr ""
"$ python TCPClient.py hello world with TCP\n"
"Sent:     hello world with TCP\n"
"Received: HELLO WORLD WITH TCP\n"
"$ python TCPClient.py python is nice\n"
"Sent:     python is nice\n"
"Received: PYTHON IS NICE"

msgid ":class:`socketserver.UDPServer` Example"
msgstr ":class:`socketserver.UDPServer` Exempel"

msgid ""
"import socketserver\n"
"\n"
"class MyUDPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    This class works similar to the TCP handler class, except that\n"
"    self.request consists of a pair of data and client socket, and since\n"
"    there is no connection the client address must be given explicitly\n"
"    when sending data back via sendto().\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        data = self.request[0].strip()\n"
"        socket = self.request[1]\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(data)\n"
"        socket.sendto(data.upper(), self.client_address)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"    with socketserver.UDPServer((HOST, PORT), MyUDPHandler) as server:\n"
"        server.serve_forever()"
msgstr ""
"import socketserver\n"
"\n"
"class MyUDPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    This class works similar to the TCP handler class, except that\n"
"    self.request consists of a pair of data and client socket, and since\n"
"    there is no connection the client address must be given explicitly\n"
"    when sending data back via sendto().\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        data = self.request[0].strip()\n"
"        socket = self.request[1]\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(data)\n"
"        socket.sendto(data.upper(), self.client_address)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"    with socketserver.UDPServer((HOST, PORT), MyUDPHandler) as server:\n"
"        server.serve_forever()"

msgid ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# SOCK_DGRAM is the socket type to use for UDP sockets\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n"
"\n"
"# As you can see, there is no connect() call; UDP has no connections.\n"
"# Instead, data is directly sent to the recipient via sendto().\n"
"sock.sendto(bytes(data + \"\\n\", \"utf-8\"), (HOST, PORT))\n"
"received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"
msgstr ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# SOCK_DGRAM is the socket type to use for UDP sockets\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n"
"\n"
"# As you can see, there is no connect() call; UDP has no connections.\n"
"# Instead, data is directly sent to the recipient via sendto().\n"
"sock.sendto(bytes(data + \"\\n\", \"utf-8\"), (HOST, PORT))\n"
"received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"

msgid ""
"The output of the example should look exactly like for the TCP server "
"example."
msgstr "Utdata från exemplet ska se ut precis som i exemplet med TCP-servern."

msgid "Asynchronous Mixins"
msgstr "Asynkrona mixins"

msgid ""
"To build asynchronous handlers, use the :class:`ThreadingMixIn` and :class:"
"`ForkingMixIn` classes."
msgstr ""
"Om du vill bygga asynkrona hanterare använder du klasserna :class:"
"`ThreadingMixIn` och :class:`ForkingMixIn`."

msgid "An example for the :class:`ThreadingMixIn` class::"
msgstr "Ett exempel för klassen :class:`ThreadingMixIn`::"

msgid ""
"import socket\n"
"import threading\n"
"import socketserver\n"
"\n"
"class ThreadedTCPRequestHandler(socketserver.BaseRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        data = str(self.request.recv(1024), 'ascii')\n"
"        cur_thread = threading.current_thread()\n"
"        response = bytes(\"{}: {}\".format(cur_thread.name, data), 'ascii')\n"
"        self.request.sendall(response)\n"
"\n"
"class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver."
"TCPServer):\n"
"    pass\n"
"\n"
"def client(ip, port, message):\n"
"    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"        sock.connect((ip, port))\n"
"        sock.sendall(bytes(message, 'ascii'))\n"
"        response = str(sock.recv(1024), 'ascii')\n"
"        print(\"Received: {}\".format(response))\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # Port 0 means to select an arbitrary unused port\n"
"    HOST, PORT = \"localhost\", 0\n"
"\n"
"    server = ThreadedTCPServer((HOST, PORT), ThreadedTCPRequestHandler)\n"
"    with server:\n"
"        ip, port = server.server_address\n"
"\n"
"        # Start a thread with the server -- that thread will then start one\n"
"        # more thread for each request\n"
"        server_thread = threading.Thread(target=server.serve_forever)\n"
"        # Exit the server thread when the main thread terminates\n"
"        server_thread.daemon = True\n"
"        server_thread.start()\n"
"        print(\"Server loop running in thread:\", server_thread.name)\n"
"\n"
"        client(ip, port, \"Hello World 1\")\n"
"        client(ip, port, \"Hello World 2\")\n"
"        client(ip, port, \"Hello World 3\")\n"
"\n"
"        server.shutdown()"
msgstr ""
"import socket\n"
"import threading\n"
"import socketserver\n"
"\n"
"class ThreadedTCPRequestHandler(socketserver.BaseRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        data = str(self.request.recv(1024), 'ascii')\n"
"        cur_thread = threading.current_thread()\n"
"        response = bytes(\"{}: {}\".format(cur_thread.name, data), 'ascii')\n"
"        self.request.sendall(response)\n"
"\n"
"class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver."
"TCPServer):\n"
"    pass\n"
"\n"
"def client(ip, port, message):\n"
"    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"        sock.connect((ip, port))\n"
"        sock.sendall(bytes(message, 'ascii'))\n"
"        response = str(sock.recv(1024), 'ascii')\n"
"        print(\"Received: {}\".format(response))\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # Port 0 means to select an arbitrary unused port\n"
"    HOST, PORT = \"localhost\", 0\n"
"\n"
"    server = ThreadedTCPServer((HOST, PORT), ThreadedTCPRequestHandler)\n"
"    with server:\n"
"        ip, port = server.server_address\n"
"\n"
"        # Start a thread with the server -- that thread will then start one\n"
"        # more thread for each request\n"
"        server_thread = threading.Thread(target=server.serve_forever)\n"
"        # Exit the server thread when the main thread terminates\n"
"        server_thread.daemon = True\n"
"        server_thread.start()\n"
"        print(\"Server loop running in thread:\", server_thread.name)\n"
"\n"
"        client(ip, port, \"Hello World 1\")\n"
"        client(ip, port, \"Hello World 2\")\n"
"        client(ip, port, \"Hello World 3\")\n"
"\n"
"        server.shutdown()"

msgid ""
"$ python ThreadedTCPServer.py\n"
"Server loop running in thread: Thread-1\n"
"Received: Thread-2: Hello World 1\n"
"Received: Thread-3: Hello World 2\n"
"Received: Thread-4: Hello World 3"
msgstr ""
"$ python ThreadedTCPServer.py\n"
"Server loop running in thread: Thread-1\n"
"Received: Thread-2: Hello World 1\n"
"Received: Thread-3: Hello World 2\n"
"Received: Thread-4: Hello World 3"

msgid ""
"The :class:`ForkingMixIn` class is used in the same way, except that the "
"server will spawn a new process for each request. Available only on POSIX "
"platforms that support :func:`~os.fork`."
msgstr ""
"Klassen :class:`ForkingMixIn` används på samma sätt, med skillnaden att "
"servern skapar en ny process för varje förfrågan. Endast tillgänglig på "
"POSIX-plattformar som stöder :func:`~os.fork`."
