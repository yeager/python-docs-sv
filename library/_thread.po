# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!_thread` --- Low-level threading API"
msgstr ":mod:`!_thread` --- API för trådning på låg nivå"

msgid ""
"This module provides low-level primitives for working with multiple threads "
"(also called :dfn:`light-weight processes` or :dfn:`tasks`) --- multiple "
"threads of control sharing their global data space.  For synchronization, "
"simple locks (also called :dfn:`mutexes` or :dfn:`binary semaphores`) are "
"provided. The :mod:`threading` module provides an easier to use and higher-"
"level threading API built on top of this module."
msgstr ""
"Denna modul tillhandahåller primitiver på låg nivå för att arbeta med flera "
"trådar (även kallade :dfn:`light-weight processes` eller :dfn:`tasks`) --- "
"flera kontrolltrådar som delar sitt globala datautrymme.  För synkronisering "
"tillhandahålls enkla lås (även kallade :dfn:`mutexes` eller :dfn:`binary "
"semaphores`). Modulen :mod:`threading` tillhandahåller ett mer lättanvänt "
"API för trådning på högre nivå som bygger på denna modul."

msgid "This module used to be optional, it is now always available."
msgstr "Denna modul var tidigare valfri, men är nu alltid tillgänglig."

msgid "This module defines the following constants and functions:"
msgstr "Denna modul definierar följande konstanter och funktioner:"

msgid "Raised on thread-specific errors."
msgstr "Utlöses vid trådspecifika fel."

msgid "This is now a synonym of the built-in :exc:`RuntimeError`."
msgstr "Detta är nu en synonym till den inbyggda :exc:`RuntimeError`."

msgid "This is the type of lock objects."
msgstr "Detta är den typ av låsobjekt."

msgid ""
"Start a new thread and return its identifier.  The thread executes the "
"function *function* with the argument list *args* (which must be a tuple). "
"The optional *kwargs* argument specifies a dictionary of keyword arguments."
msgstr ""
"Starta en ny tråd och returnera dess identifierare.  Tråden exekverar "
"funktionen *function* med argumentlistan *args* (som måste vara en tupel). "
"Det valfria argumentet *kwargs* anger en ordlista med nyckelordsargument."

msgid "When the function returns, the thread silently exits."
msgstr "När funktionen återkommer avslutas tråden tyst."

msgid ""
"When the function terminates with an unhandled exception, :func:`sys."
"unraisablehook` is called to handle the exception. The *object* attribute of "
"the hook argument is *function*. By default, a stack trace is printed and "
"then the thread exits (but other threads continue to run)."
msgstr ""
"När funktionen avslutas med ett ohanterat undantag anropas :func:`sys."
"unraisablehook` för att hantera undantaget. Attributet *object* för hook-"
"argumentet är *function*. Som standard skrivs ett stackspår ut och sedan "
"avslutas tråden (men andra trådar fortsätter att köras)."

msgid ""
"When the function raises a :exc:`SystemExit` exception, it is silently "
"ignored."
msgstr ""
"Om funktionen ger upphov till ett :exc:`SystemExit`-undantag ignoreras det i "
"tysthet."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``_thread.start_new_thread`` with "
"arguments ``function``, ``args``, ``kwargs``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``_thread.start_new_thread`` med "
"argumenten ``function``, ``args``, ``kwargs``."

msgid ":func:`sys.unraisablehook` is now used to handle unhandled exceptions."
msgstr ""
":func:`sys.unraisablehook` används nu för att hantera obehandlade undantag."

msgid ""
"Simulate the effect of a signal arriving in the main thread. A thread can "
"use this function to interrupt the main thread, though there is no guarantee "
"that the interruption will happen immediately."
msgstr ""
"Simulerar effekten av en signal som anländer till huvudtråden. En tråd kan "
"använda denna funktion för att avbryta huvudtråden, men det finns ingen "
"garanti för att avbrottet sker omedelbart."

msgid ""
"If given, *signum* is the number of the signal to simulate. If *signum* is "
"not given, :const:`signal.SIGINT` is simulated."
msgstr ""
"Om *signum* anges är det numret på den signal som ska simuleras. Om *signum* "
"inte anges, simuleras :const:`signal.SIGINT`."

msgid ""
"If the given signal isn't handled by Python (it was set to :const:`signal."
"SIG_DFL` or :const:`signal.SIG_IGN`), this function does nothing."
msgstr ""
"Om den angivna signalen inte hanteras av Python (den sattes till :const:"
"`signal.SIG_DFL` eller :const:`signal.SIG_IGN`), gör denna funktion "
"ingenting."

msgid "The *signum* argument is added to customize the signal number."
msgstr "Argumentet *signum* läggs till för att anpassa signalnumret."

msgid ""
"This does not emit the corresponding signal but schedules a call to the "
"associated handler (if it exists). If you want to truly emit the signal, "
"use :func:`signal.raise_signal`."
msgstr ""
"Detta sänder inte ut motsvarande signal utan schemalägger ett anrop till den "
"associerade hanteraren (om den finns). Om du verkligen vill sända ut "
"signalen, använd :func:`signal.raise_signal`."

msgid ""
"Raise the :exc:`SystemExit` exception.  When not caught, this will cause the "
"thread to exit silently."
msgstr ""
"Utlöser undantaget :exc:`SystemExit`.  Om det inte fångas upp kommer det att "
"leda till att tråden avslutas i tysthet."

msgid ""
"Return a new lock object.  Methods of locks are described below.  The lock "
"is initially unlocked."
msgstr ""
"Returnerar ett nytt låsobjekt.  Metoder för lås beskrivs nedan.  Låset är "
"initialt olåst."

msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Returnerar \"trådidentifieraren\" för den aktuella tråden.  Detta är ett "
"heltal som inte är noll.  Dess värde har ingen direkt betydelse; det är "
"avsett som en magisk cookie som kan användas t.ex. för att indexera en "
"ordbok med trådspecifika data.  Trådidentifierare kan återanvändas när en "
"tråd avslutas och en ny tråd skapas."

msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Returnerar det inbyggda integrerade tråd-ID:t för den aktuella tråden som "
"tilldelats av kärnan. Detta är ett icke-negativt heltal. Dess värde kan "
"användas för att unikt identifiera just denna tråd i hela systemet (tills "
"tråden avslutas, varefter värdet kan återanvändas av operativsystemet)."

msgid "Availability"
msgstr "Tillgänglighet"

msgid "Added support for GNU/kFreeBSD."
msgstr "Lagt till stöd för GNU/kFreeBSD."

msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Returnerar den trådstackstorlek som används när nya trådar skapas.  Det "
"valfria argumentet *size* anger den stackstorlek som ska användas för senare "
"skapade trådar och måste vara 0 (använd plattformens eller konfigurerade "
"standard) eller ett positivt heltalsvärde på minst 32 768 (32 KiB). Om "
"*size* inte anges används 0.  Om ändring av trådstackens storlek inte stöds, "
"uppstår ett :exc:`RuntimeError`.  Om den angivna stackstorleken är ogiltig, "
"uppstår ett :exc:`ValueError` och stackstorleken ändras inte.  32 KiB är för "
"närvarande det minsta stödda stackstorleksvärdet för att garantera "
"tillräckligt med stackutrymme för själva tolken.  Observera att vissa "
"plattformar kan ha särskilda restriktioner för värden på stackstorleken, t."
"ex. att den minsta stackstorleken måste vara > 32 KiB eller att allokering "
"måste ske i multiplar av sidstorleken i systemminnet - "
"plattformsdokumentationen bör läsas för mer information (4 KiB-sidor är "
"vanliga; att använda multiplar av 4096 för stackstorleken är det föreslagna "
"tillvägagångssättet i avsaknad av mer specifik information)."

msgid "Unix platforms with POSIX threads support."
msgstr "Unix-plattformar med stöd för POSIX-trådar."

msgid ""
"The maximum value allowed for the *timeout* parameter of :meth:`Lock.acquire "
"<threading.Lock.acquire>`. Specifying a timeout greater than this value will "
"raise an :exc:`OverflowError`."
msgstr ""
"Det högsta tillåtna värdet för parametern *timeout* i :meth:`Lock.acquire "
"<threading.Lock.acquire>`. Om du anger en timeout som är större än detta "
"värde kommer ett :exc:`OverflowError` att uppstå."

msgid "Lock objects have the following methods:"
msgstr "Låsobjekt har följande metoder:"

msgid ""
"Without any optional argument, this method acquires the lock "
"unconditionally, if necessary waiting until it is released by another thread "
"(only one thread at a time can acquire a lock --- that's their reason for "
"existence)."
msgstr ""
"Utan något valfritt argument förvärvar denna metod låset villkorslöst och "
"väntar vid behov tills det släpps av en annan tråd (endast en tråd i taget "
"kan förvärva ett lås --- det är deras existensberättigande)."

msgid ""
"If the *blocking* argument is present, the action depends on its value: if "
"it is false, the lock is only acquired if it can be acquired immediately "
"without waiting, while if it is true, the lock is acquired unconditionally "
"as above."
msgstr ""
"Om argumentet *blocking* finns med beror åtgärden på dess värde: om det är "
"falskt förvärvas låset endast om det kan förvärvas omedelbart utan att "
"vänta, medan om det är sant förvärvas låset villkorslöst enligt ovan."

msgid ""
"If the floating-point *timeout* argument is present and positive, it "
"specifies the maximum wait time in seconds before returning.  A negative "
"*timeout* argument specifies an unbounded wait.  You cannot specify a "
"*timeout* if *blocking* is false."
msgstr ""
"Om argumentet *timeout* med flyttal är närvarande och positivt, anger det "
"den maximala väntetiden i sekunder innan återgång.  Ett negativt *timeout*-"
"argument anger en obegränsad väntetid.  Du kan inte ange en *timeout* om "
"*blocking* är false."

msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not."
msgstr ""
"Returvärdet är ``True`` om låset har förvärvats framgångsrikt, ``False`` om "
"så inte är fallet."

msgid "The *timeout* parameter is new."
msgstr "Parametern *timeout* är ny."

msgid "Lock acquires can now be interrupted by signals on POSIX."
msgstr "Lock acquires kan nu avbrytas av signaler på POSIX."

msgid "Lock acquires can now be interrupted by signals on Windows."
msgstr "Lock acquires kan nu avbrytas av signaler i Windows."

msgid ""
"Releases the lock.  The lock must have been acquired earlier, but not "
"necessarily by the same thread."
msgstr ""
"Frigör låset.  Låset måste ha förvärvats tidigare, men inte nödvändigtvis av "
"samma tråd."

msgid ""
"Return the status of the lock: ``True`` if it has been acquired by some "
"thread, ``False`` if not."
msgstr ""
"Returnerar status för låset: ``True`` om det har förvärvats av någon tråd, "
"``False`` om inte."

msgid ""
"In addition to these methods, lock objects can also be used via the :keyword:"
"`with` statement, e.g.::"
msgstr ""
"Utöver dessa metoder kan låsobjekt också användas via :keyword:`with`-"
"satsen, t.ex.::"

msgid ""
"import _thread\n"
"\n"
"a_lock = _thread.allocate_lock()\n"
"\n"
"with a_lock:\n"
"    print(\"a_lock is locked while this executes\")"
msgstr ""
"import _tråd\n"
"\n"
"a_lock = _thread.allocate_lock()\n"
"\n"
"med a_lock:\n"
"    print(\"a_lock är låst medan detta körs\")"

msgid "**Caveats:**"
msgstr "**Fallgropar:**"

msgid ""
"Interrupts always go to the main thread (the :exc:`KeyboardInterrupt` "
"exception will be received by that thread.)"
msgstr ""
"Avbrott går alltid till huvudtråden (undantaget :exc:`KeyboardInterrupt` "
"kommer att tas emot av den tråden)"

msgid ""
"Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is "
"equivalent to calling :func:`_thread.exit`."
msgstr ""
"Att anropa :func:`sys.exit` eller utlösa undantaget :exc:`SystemExit` är "
"likvärdigt med att anropa :func:`_thread.exit`."

msgid ""
"When the main thread exits, it is system defined whether the other threads "
"survive.  On most systems, they are killed without executing :keyword:"
"`try` ... :keyword:`finally` clauses or executing object destructors."
msgstr ""
"När huvudtråden avslutas är det systemspecifikt om de andra trådarna "
"överlever.  På de flesta system dödas de utan att utföra :keyword:`try` ... :"
"keyword:`finally`-klausuler eller exekvera objektdestruktorer."

msgid "light-weight processes"
msgstr "lättviktiga processer"

msgid "processes, light-weight"
msgstr "processer, lättviktig"

msgid "binary semaphores"
msgstr "binära semaforer"

msgid "semaphores, binary"
msgstr "semaforer, binära"

msgid "pthreads"
msgstr "pthreads"

msgid "threads"
msgstr "trådar"

msgid "POSIX"
msgstr "POSIX"

msgid "module"
msgstr "modul"

msgid "signal"
msgstr "signal"
