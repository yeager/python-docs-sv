# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!html.parser` --- Simple HTML and XHTML parser"
msgstr ":mod:`!html.parser` --- Enkel HTML- och XHTML-parser"

msgid "**Source code:** :source:`Lib/html/parser.py`"
msgstr "**Källkod:** :source:`Lib/html/parser.py`"

msgid ""
"This module defines a class :class:`HTMLParser` which serves as the basis "
"for parsing text files formatted in HTML (HyperText Mark-up Language) and "
"XHTML."
msgstr ""
"Den här modulen definierar en klass :class:`HTMLParser` som fungerar som bas "
"för parsning av textfiler formaterade i HTML (HyperText Mark-up Language) "
"och XHTML."

msgid "Create a parser instance able to parse invalid markup."
msgstr "Skapa en parserinstans som kan parsa ogiltig markup."

msgid ""
"If *convert_charrefs* is ``True`` (the default), all character references "
"(except the ones in ``script``/``style`` elements) are automatically "
"converted to the corresponding Unicode characters."
msgstr ""
"Om *convert_charrefs* är ``True`` (standard) konverteras alla "
"teckenreferenser (utom de i ``cript``/``style``-element) automatiskt till "
"motsvarande Unicode-tecken."

msgid ""
"An :class:`.HTMLParser` instance is fed HTML data and calls handler methods "
"when start tags, end tags, text, comments, and other markup elements are "
"encountered.  The user should subclass :class:`.HTMLParser` and override its "
"methods to implement the desired behavior."
msgstr ""
"En instans av :class:`.HTMLParser` matas med HTML-data och anropar "
"hanteringsmetoder när starttaggar, sluttaggar, text, kommentarer och andra "
"markeringselement påträffas.  Användaren bör subklassa :class:`.HTMLParser` "
"och åsidosätta dess metoder för att implementera önskat beteende."

msgid ""
"This parser does not check that end tags match start tags or call the end-"
"tag handler for elements which are closed implicitly by closing an outer "
"element."
msgstr ""
"Denna parser kontrollerar inte att sluttaggar matchar starttaggar eller "
"anropar sluttagghanteraren för element som stängs implicit genom att stänga "
"ett yttre element."

msgid "*convert_charrefs* keyword argument added."
msgstr "*convert_charrefs* nyckelordsargument tillagt."

msgid "The default value for argument *convert_charrefs* is now ``True``."
msgstr "Standardvärdet för argumentet *convert_charrefs* är nu ``True``."

msgid "Example HTML Parser Application"
msgstr "Exempel på HTML Parser-applikation"

msgid ""
"As a basic example, below is a simple HTML parser that uses the :class:"
"`HTMLParser` class to print out start tags, end tags, and data as they are "
"encountered:"
msgstr ""
"Som ett grundläggande exempel visas nedan en enkel HTML-parser som använder "
"klassen :class:`HTMLParser` för att skriva ut starttaggar, sluttaggar och "
"data när de påträffas:"

msgid ""
"from html.parser import HTMLParser\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Encountered a start tag:\", tag)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"Encountered an end tag :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Encountered some data  :\", data)\n"
"\n"
"parser = MyHTMLParser()\n"
"parser.feed('<html><head><title>Test</title></head>'\n"
"            '<body><h1>Parse me!</h1></body></html>')"
msgstr ""
"from html.parser import HTMLParser\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Encountered a start tag:\", tag)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"Encountered an end tag :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Encountered some data  :\", data)\n"
"\n"
"parser = MyHTMLParser()\n"
"parser.feed('<html><head><title>Test</title></head>'\n"
"            '<body><h1>Parse me!</h1></body></html>')"

msgid "The output will then be:"
msgstr "Utgången kommer då att vara:"

msgid ""
"Encountered a start tag: html\n"
"Encountered a start tag: head\n"
"Encountered a start tag: title\n"
"Encountered some data  : Test\n"
"Encountered an end tag : title\n"
"Encountered an end tag : head\n"
"Encountered a start tag: body\n"
"Encountered a start tag: h1\n"
"Encountered some data  : Parse me!\n"
"Encountered an end tag : h1\n"
"Encountered an end tag : body\n"
"Encountered an end tag : html"
msgstr ""
"Encountered a start tag: html\n"
"Encountered a start tag: head\n"
"Encountered a start tag: title\n"
"Encountered some data  : Test\n"
"Encountered an end tag : title\n"
"Encountered an end tag : head\n"
"Encountered a start tag: body\n"
"Encountered a start tag: h1\n"
"Encountered some data  : Parse me!\n"
"Encountered an end tag : h1\n"
"Encountered an end tag : body\n"
"Encountered an end tag : html"

msgid ":class:`.HTMLParser` Methods"
msgstr ":class:`.HTMLParser` Metoder"

msgid ":class:`HTMLParser` instances have the following methods:"
msgstr ":class:`HTMLParser`-instanser har följande metoder:"

msgid ""
"Feed some text to the parser.  It is processed insofar as it consists of "
"complete elements; incomplete data is buffered until more data is fed or :"
"meth:`close` is called.  *data* must be :class:`str`."
msgstr ""
"Mata in text till parsern.  Den bearbetas i den mån den består av "
"fullständiga element; ofullständiga data buffras tills mer data matas in "
"eller :meth:`close` anropas.  *data* måste vara :class:`str`."

msgid ""
"Force processing of all buffered data as if it were followed by an end-of-"
"file mark.  This method may be redefined by a derived class to define "
"additional processing at the end of the input, but the redefined version "
"should always call the :class:`HTMLParser` base class method :meth:`close`."
msgstr ""
"Tvingar fram bearbetning av alla buffrade data som om de följdes av en "
"markering för slutet av filen.  Denna metod kan omdefinieras av en härledd "
"klass för att definiera ytterligare bearbetning i slutet av inmatningen, men "
"den omdefinierade versionen bör alltid anropa basklassmetoden :meth:`close` "
"i :class:`HTMLParser`."

msgid ""
"Reset the instance.  Loses all unprocessed data.  This is called implicitly "
"at instantiation time."
msgstr ""
"Återställer instansen.  Förlorar alla obearbetade data.  Detta anropas "
"implicit vid instantieringstillfället."

msgid "Return current line number and offset."
msgstr "Returnerar aktuellt radnummer och offset."

msgid ""
"Return the text of the most recently opened start tag.  This should not "
"normally be needed for structured processing, but may be useful in dealing "
"with HTML \"as deployed\" or for re-generating input with minimal changes "
"(whitespace between attributes can be preserved, etc.)."
msgstr ""
"Returnerar texten i den senast öppnade starttaggen.  Detta bör normalt inte "
"behövas för strukturerad bearbetning, men kan vara användbart för att "
"hantera HTML \"som den är distribuerad\" eller för att återskapa indata med "
"minimala ändringar (blanksteg mellan attribut kan bevaras etc.)."

msgid ""
"The following methods are called when data or markup elements are "
"encountered and they are meant to be overridden in a subclass.  The base "
"class implementations do nothing (except for :meth:`~HTMLParser."
"handle_startendtag`):"
msgstr ""
"Följande metoder anropas när data- eller markeringselement påträffas och de "
"är avsedda att åsidosättas i en underklass.  Basklassens implementationer "
"gör ingenting (förutom :meth:`~HTMLParser.handle_startendtag`):"

msgid ""
"This method is called to handle the start tag of an element (e.g. ``<div "
"id=\"main\">``)."
msgstr ""
"Denna metod anropas för att hantera starttaggen för ett element (t.ex. "
"``<div id=\"main\">``)."

msgid ""
"The *tag* argument is the name of the tag converted to lower case. The "
"*attrs* argument is a list of ``(name, value)`` pairs containing the "
"attributes found inside the tag's ``<>`` brackets.  The *name* will be "
"translated to lower case, and quotes in the *value* have been removed, and "
"character and entity references have been replaced."
msgstr ""
"Argumentet *tag* är namnet på taggen konverterat till gemener. Argumentet "
"*attrs* är en lista med paren ``(namn, värde)`` som innehåller de attribut "
"som finns inom taggens ``<>``-parenteser.  *name* översätts till gemener och "
"citattecken i *value* har tagits bort, och tecken- och entitetsreferenser "
"har ersatts."

msgid ""
"For instance, for the tag ``<A HREF=\"https://www.cwi.nl/\">``, this method "
"would be called as ``handle_starttag('a', [('href', 'https://www.cwi."
"nl/')])``."
msgstr ""
"För taggen ``<A HREF=\"https://www.cwi.nl/\">`` skulle den här metoden till "
"exempel anropas som ``handle_starttag('a', [('href', 'https://www.cwi."
"nl/')])``."

msgid ""
"All entity references from :mod:`html.entities` are replaced in the "
"attribute values."
msgstr ""
"Alla entitetsreferenser från :mod:`html.entities` ersätts i attributvärdena."

msgid ""
"This method is called to handle the end tag of an element (e.g. ``</div>``)."
msgstr ""
"Denna metod anropas för att hantera sluttaggen för ett element (t.ex. ``</"
"div>``)."

msgid "The *tag* argument is the name of the tag converted to lower case."
msgstr "Argumentet *tag* är namnet på taggen konverterat till gemener."

msgid ""
"Similar to :meth:`handle_starttag`, but called when the parser encounters an "
"XHTML-style empty tag (``<img ... />``).  This method may be overridden by "
"subclasses which require this particular lexical information; the default "
"implementation simply calls :meth:`handle_starttag` and :meth:"
"`handle_endtag`."
msgstr ""
"Liknar :meth:`handle_starttag`, men anropas när parsern stöter på en tom "
"tagg i XHTML-stil (``<img ... />``).  Denna metod kan åsidosättas av "
"underklasser som kräver denna speciella lexikala information; "
"standardimplementationen anropar helt enkelt :meth:`handle_starttag` och :"
"meth:`handle_endtag`."

msgid ""
"This method is called to process arbitrary data (e.g. text nodes and the "
"content of ``<script>...</script>`` and ``<style>...</style>``)."
msgstr ""
"Denna metod anropas för att bearbeta godtyckliga data (t.ex. textnoder och "
"innehållet i ``.<script>.</script>.`` och ``.<style>.</style>.``)."

msgid ""
"This method is called to process a named character reference of the form "
"``&name;`` (e.g. ``&gt;``), where *name* is a general entity reference (e.g. "
"``'gt'``).  This method is never called if *convert_charrefs* is ``True``."
msgstr ""
"Denna metod anropas för att behandla en namngiven teckenreferens av formen "
"``&name;`` (t.ex. ``&gt;``), där *name* är en allmän entitetsreferens (t.ex. "
"``'gt'``).  Denna metod anropas aldrig om *convert_charrefs* är ``True``."

msgid ""
"This method is called to process decimal and hexadecimal numeric character "
"references of the form :samp:`&#{NNN};` and :samp:`&#x{NNN};`.  For example, "
"the decimal equivalent for ``&gt;`` is ``&#62;``, whereas the hexadecimal is "
"``&#x3E;``; in this case the method will receive ``'62'`` or ``'x3E'``.  "
"This method is never called if *convert_charrefs* is ``True``."
msgstr ""
"Denna metod anropas för att bearbeta decimala och hexadecimala numeriska "
"teckenreferenser av formen :samp:`&#{NNN};` och :samp:`&#x{NNN};`.  "
"Exempelvis är den decimala motsvarigheten till ``&gt;`` ``>``, medan den "
"hexadecimala är ``>``; i detta fall kommer metoden att ta emot ``'62'`` "
"eller ``'x3E'``.  Denna metod anropas aldrig om *convert_charrefs* är "
"``True``."

msgid ""
"This method is called when a comment is encountered (e.g. ``<!--comment--"
">``)."
msgstr ""
"Denna metod anropas när en kommentar påträffas (t.ex. ``<!--comment-->``)."

msgid ""
"For example, the comment ``<!-- comment -->`` will cause this method to be "
"called with the argument ``' comment '``."
msgstr ""
"Exempelvis kommer kommentaren ``<!-- comment -->`` att leda till att denna "
"metod anropas med argumentet ``' comment '``."

msgid ""
"The content of Internet Explorer conditional comments (condcoms) will also "
"be sent to this method, so, for ``<!--[if IE 9]>IE9-specific content<!"
"[endif]-->``, this method will receive ``'[if IE 9]>IE9-specific content<!"
"[endif]'``."
msgstr ""
"Innehållet i Internet Explorer villkorliga kommentarer (condcoms) kommer "
"också att skickas till denna metod, så för ``<!--[om IE 9]>IE9-specifikt "
"innehåll<![endif]-->`` kommer denna metod att få ``'[om IE 9]>IE9-specifikt "
"innehåll<![endif]'``."

msgid ""
"This method is called to handle an HTML doctype declaration (e.g. ``<!"
"DOCTYPE html>``)."
msgstr ""
"Denna metod anropas för att hantera en HTML-doktypdeklaration (t.ex. ``<!"
"DOCTYPE html>``)."

msgid ""
"The *decl* parameter will be the entire contents of the declaration inside "
"the ``<!...>`` markup (e.g. ``'DOCTYPE html'``)."
msgstr ""
"Parametern *decl* kommer att vara hela innehållet i deklarationen inuti "
"``<!...>``-markeringen (t.ex. ``'DOCTYPE html'``)."

msgid ""
"Method called when a processing instruction is encountered.  The *data* "
"parameter will contain the entire processing instruction. For example, for "
"the processing instruction ``<?proc color='red'>``, this method would be "
"called as ``handle_pi(\"proc color='red'\")``.  It is intended to be "
"overridden by a derived class; the base class implementation does nothing."
msgstr ""
"Metod som anropas när en bearbetningsinstruktion påträffas.  Parametern "
"*data* kommer att innehålla hela bearbetningsinstruktionen. Till exempel, "
"för bearbetningsinstruktionen ``<?proc color='red'>``, skulle denna metod "
"anropas som ``handle_pi(\"proc color='red'\")``.  Den är avsedd att "
"åsidosättas av en härledd klass; basklassens implementering gör ingenting."

msgid ""
"The :class:`HTMLParser` class uses the SGML syntactic rules for processing "
"instructions.  An XHTML processing instruction using the trailing ``'?'`` "
"will cause the ``'?'`` to be included in *data*."
msgstr ""
"Klassen :class:`HTMLParser` använder SGML:s syntaktiska regler för "
"bearbetningsinstruktioner.  En XHTML-bearbetningsinstruktion som använder "
"den efterföljande ``'?'`` kommer att leda till att ``'?'`` inkluderas i "
"*data*."

msgid ""
"This method is called when an unrecognized declaration is read by the parser."
msgstr "Denna metod anropas när en oigenkänd deklaration läses av parsern."

msgid ""
"The *data* parameter will be the entire contents of the declaration inside "
"the ``<![...]>`` markup.  It is sometimes useful to be overridden by a "
"derived class.  The base class implementation does nothing."
msgstr ""
"Parametern *data* kommer att vara hela innehållet i deklarationen inuti ``<!"
"[...]>``-markeringen.  Det är ibland användbart att åsidosättas av en "
"härledd klass.  Basklassens implementation gör ingenting."

msgid "Examples"
msgstr "Exempel"

msgid ""
"The following class implements a parser that will be used to illustrate more "
"examples:"
msgstr ""
"Följande klass implementerar en parser som kommer att användas för att "
"illustrera fler exempel:"

msgid ""
"from html.parser import HTMLParser\n"
"from html.entities import name2codepoint\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Start tag:\", tag)\n"
"        for attr in attrs:\n"
"            print(\"     attr:\", attr)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"End tag  :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Data     :\", data)\n"
"\n"
"    def handle_comment(self, data):\n"
"        print(\"Comment  :\", data)\n"
"\n"
"    def handle_entityref(self, name):\n"
"        c = chr(name2codepoint[name])\n"
"        print(\"Named ent:\", c)\n"
"\n"
"    def handle_charref(self, name):\n"
"        if name.startswith('x'):\n"
"            c = chr(int(name[1:], 16))\n"
"        else:\n"
"            c = chr(int(name))\n"
"        print(\"Num ent  :\", c)\n"
"\n"
"    def handle_decl(self, data):\n"
"        print(\"Decl     :\", data)\n"
"\n"
"parser = MyHTMLParser()"
msgstr ""
"from html.parser import HTMLParser\n"
"from html.entities import name2codepoint\n"
"\n"
"class MyHTMLParser(HTMLParser):\n"
"    def handle_starttag(self, tag, attrs):\n"
"        print(\"Start tag:\", tag)\n"
"        for attr in attrs:\n"
"            print(\"     attr:\", attr)\n"
"\n"
"    def handle_endtag(self, tag):\n"
"        print(\"End tag  :\", tag)\n"
"\n"
"    def handle_data(self, data):\n"
"        print(\"Data     :\", data)\n"
"\n"
"    def handle_comment(self, data):\n"
"        print(\"Comment  :\", data)\n"
"\n"
"    def handle_entityref(self, name):\n"
"        c = chr(name2codepoint[name])\n"
"        print(\"Named ent:\", c)\n"
"\n"
"    def handle_charref(self, name):\n"
"        if name.startswith('x'):\n"
"            c = chr(int(name[1:], 16))\n"
"        else:\n"
"            c = chr(int(name))\n"
"        print(\"Num ent  :\", c)\n"
"\n"
"    def handle_decl(self, data):\n"
"        print(\"Decl     :\", data)\n"
"\n"
"parser = MyHTMLParser()"

msgid "Parsing a doctype:"
msgstr "Parsning av en doctype:"

msgid ""
">>> parser.feed('<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" '\n"
"...             '\"http://www.w3.org/TR/html4/strict.dtd\">')\n"
"Decl     : DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3."
"org/TR/html4/strict.dtd\""
msgstr ""
">>> parser.feed('<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" '\n"
"...             '\"http://www.w3.org/TR/html4/strict.dtd\">')\n"
"Decl     : DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3."
"org/TR/html4/strict.dtd\""

msgid "Parsing an element with a few attributes and a title:"
msgstr "Parsning av ett element med några attribut och en titel:"

msgid ""
">>> parser.feed('<img src=\"python-logo.png\" alt=\"The Python logo\">')\n"
"Start tag: img\n"
"     attr: ('src', 'python-logo.png')\n"
"     attr: ('alt', 'The Python logo')\n"
">>>\n"
">>> parser.feed('<h1>Python</h1>')\n"
"Start tag: h1\n"
"Data     : Python\n"
"End tag  : h1"
msgstr ""
">>> parser.feed('<img src=\"python-logo.png\" alt=\"The Python logo\">')\n"
"Start tag: img\n"
"     attr: ('src', 'python-logo.png')\n"
"     attr: ('alt', 'The Python logo')\n"
">>>\n"
">>> parser.feed('<h1>Python</h1>')\n"
"Start tag: h1\n"
"Data     : Python\n"
"End tag  : h1"

msgid ""
"The content of ``script`` and ``style`` elements is returned as is, without "
"further parsing:"
msgstr ""
"Innehållet i elementen ``cript`` och ``style`` returneras som det är, utan "
"ytterligare parsning:"

msgid ""
">>> parser.feed('<style type=\"text/css\">#python { color: green }</"
"style>')\n"
"Start tag: style\n"
"     attr: ('type', 'text/css')\n"
"Data     : #python { color: green }\n"
"End tag  : style\n"
"\n"
">>> parser.feed('<script type=\"text/javascript\">'\n"
"...             'alert(\"<strong>hello!</strong>\");</script>')\n"
"Start tag: script\n"
"     attr: ('type', 'text/javascript')\n"
"Data     : alert(\"<strong>hello!</strong>\");\n"
"End tag  : script"
msgstr ""
">>> parser.feed('<style type=\"text/css\">#python { color: green }</"
"style>')\n"
"Start tag: style\n"
"     attr: ('type', 'text/css')\n"
"Data     : #python { color: green }\n"
"End tag  : style\n"
"\n"
">>> parser.feed('<script type=\"text/javascript\">'\n"
"...             'alert(\"<strong>hello!</strong>\");</script>')\n"
"Start tag: script\n"
"     attr: ('type', 'text/javascript')\n"
"Data     : alert(\"<strong>hello!</strong>\");\n"
"End tag  : script"

msgid "Parsing comments:"
msgstr "Analyserar kommentarer:"

msgid ""
">>> parser.feed('<!--a comment-->'\n"
"...             '<!--[if IE 9]>IE-specific content<![endif]-->')\n"
"Comment  : a comment\n"
"Comment  : [if IE 9]>IE-specific content<![endif]"
msgstr ""
">>> parser.feed('<!--a comment-->'\n"
"...             '<!--[if IE 9]>IE-specific content<![endif]-->')\n"
"Comment  : a comment\n"
"Comment  : [if IE 9]>IE-specific content<![endif]"

msgid ""
"Parsing named and numeric character references and converting them to the "
"correct char (note: these 3 references are all equivalent to ``'>'``):"
msgstr ""
"Parsning av namngivna och numeriska teckenreferenser och konvertering av dem "
"till rätt tecken (notera: dessa 3 referenser är alla likvärdiga med ``'>'``):"

msgid ""
">>> parser = MyHTMLParser()\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Data     : >>>\n"
"\n"
">>> parser = MyHTMLParser(convert_charrefs=False)\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Named ent: >\n"
"Num ent  : >\n"
"Num ent  : >"
msgstr ""
">>> parser = MyHTMLParser()\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Data     : >>>\n"
"\n"
">>> parser = MyHTMLParser(convert_charrefs=False)\n"
">>> parser.feed('&gt;&#62;&#x3E;')\n"
"Named ent: >\n"
"Num ent  : >\n"
"Num ent  : >"

msgid ""
"Feeding incomplete chunks to :meth:`~HTMLParser.feed` works, but :meth:"
"`~HTMLParser.handle_data` might be called more than once (unless "
"*convert_charrefs* is set to ``True``):"
msgstr ""
"Att mata ofullständiga bitar till :meth:`~HTMLParser.feed` fungerar, men :"
"meth:`~HTMLParser.handle_data` kan anropas mer än en gång (om inte "
"*convert_charrefs* är satt till ``True``):"

msgid ""
">>> for chunk in ['<sp', 'an>buff', 'ered', ' text</s', 'pan>']:\n"
"...     parser.feed(chunk)\n"
"...\n"
"Start tag: span\n"
"Data     : buff\n"
"Data     : ered\n"
"Data     :  text\n"
"End tag  : span"
msgstr ""
">>> for chunk in ['<sp', 'an>buff', 'ered', ' text</s', 'pan>']:\n"
"...     parser.feed(chunk)\n"
"...\n"
"Start tag: span\n"
"Data     : buff\n"
"Data     : ered\n"
"Data     :  text\n"
"End tag  : span"

msgid "Parsing invalid HTML (e.g. unquoted attributes) also works:"
msgstr ""
"Parsning av ogiltig HTML (t.ex. attribut som inte citeras) fungerar också:"

msgid ""
">>> parser.feed('<p><a class=link href=#main>tag soup</p ></a>')\n"
"Start tag: p\n"
"Start tag: a\n"
"     attr: ('class', 'link')\n"
"     attr: ('href', '#main')\n"
"Data     : tag soup\n"
"End tag  : p\n"
"End tag  : a"
msgstr ""
">>> parser.feed('<p><a class=link href=#main>tag soup</p ></a>')\n"
"Start tag: p\n"
"Start tag: a\n"
"     attr: ('class', 'link')\n"
"     attr: ('href', '#main')\n"
"Data     : tag soup\n"
"End tag  : p\n"
"End tag  : a"

msgid "HTML"
msgstr "HTML"

msgid "XHTML"
msgstr "XHTML"
