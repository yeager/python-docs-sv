# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Supporting Cyclic Garbage Collection"
msgstr "Stöd för cyklisk skräpinsamling"

msgid ""
"Python's support for detecting and collecting garbage which involves "
"circular references requires support from object types which are "
"\"containers\" for other objects which may also be containers.  Types which "
"do not store references to other objects, or which only store references to "
"atomic types (such as numbers or strings), do not need to provide any "
"explicit support for garbage collection."
msgstr ""
"Pythons stöd för att upptäcka och samla in skräp som involverar cirkulära "
"referenser kräver stöd från objekttyper som är \"behållare\" för andra "
"objekt som också kan vara behållare.  Typer som inte lagrar referenser till "
"andra objekt, eller som bara lagrar referenser till atomära typer (t.ex. tal "
"eller strängar), behöver inte tillhandahålla något explicit stöd för "
"skräpinsamling."

msgid ""
"To create a container type, the :c:member:`~PyTypeObject.tp_flags` field of "
"the type object must include the :c:macro:`Py_TPFLAGS_HAVE_GC` and provide "
"an implementation of the :c:member:`~PyTypeObject.tp_traverse` handler.  If "
"instances of the type are mutable, a :c:member:`~PyTypeObject.tp_clear` "
"implementation must also be provided."
msgstr ""
"För att skapa en containertyp måste fältet :c:member:`~PyTypeObject."
"tp_flags` i typobjektet innehålla :c:macro:`Py_TPFLAGS_HAVE_GC` och "
"tillhandahålla en implementation av hanteraren :c:member:`~PyTypeObject."
"tp_traverse`.  Om instanser av typen är mutabla måste också en "
"implementation av :c:member:`~PyTypeObject.tp_clear` tillhandahållas."

msgid ":c:macro:`Py_TPFLAGS_HAVE_GC`"
msgstr ":c:makro:`Py_TPFLAGS_HAVE_GC`"

msgid ""
"Objects with a type with this flag set must conform with the rules "
"documented here.  For convenience these objects will be referred to as "
"container objects."
msgstr ""
"Objekt med en typ med denna flagga måste följa de regler som dokumenteras "
"här.  För enkelhetens skull kommer dessa objekt att kallas containerobjekt."

msgid "Constructors for container types must conform to two rules:"
msgstr "Konstruktörer för containertyper måste följa två regler:"

msgid ""
"The memory for the object must be allocated using :c:macro:`PyObject_GC_New` "
"or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
"Minnet för objektet måste allokeras med hjälp av :c:macro:`PyObject_GC_New` "
"eller :c:macro:`PyObject_GC_NewVar`."

msgid ""
"Once all the fields which may contain references to other containers are "
"initialized, it must call :c:func:`PyObject_GC_Track`."
msgstr ""
"När alla fält, som kan innehålla referenser till andra containrar, har "
"initialiserats måste den anropa :c:func:`PyObject_GC_Track`."

msgid ""
"Similarly, the deallocator for the object must conform to a similar pair of "
"rules:"
msgstr ""
"På samma sätt måste deallokatorn för objektet följa ett liknande par regler:"

msgid ""
"Before fields which refer to other containers are invalidated, :c:func:"
"`PyObject_GC_UnTrack` must be called."
msgstr ""
"Innan fält som hänvisar till andra behållare ogiltigförklaras måste :c:func:"
"`PyObject_GC_UnTrack` anropas."

msgid ""
"The object's memory must be deallocated using :c:func:`PyObject_GC_Del`."
msgstr ""
"Objektets minne måste avallokeras med hjälp av :c:func:`PyObject_GC_Del`."

msgid ""
"If a type adds the Py_TPFLAGS_HAVE_GC, then it *must* implement at least a :"
"c:member:`~PyTypeObject.tp_traverse` handler or explicitly use one from its "
"subclass or subclasses."
msgstr ""
"Om en typ lägger till Py_TPFLAGS_HAVE_GC, så *måste* den implementera minst "
"en :c:member:`~PyTypeObject.tp_traverse`-hanterare eller uttryckligen "
"använda en från sin underklass eller underklasser."

msgid ""
"When calling :c:func:`PyType_Ready` or some of the APIs that indirectly call "
"it like :c:func:`PyType_FromSpecWithBases` or :c:func:`PyType_FromSpec` the "
"interpreter will automatically populate the :c:member:`~PyTypeObject."
"tp_flags`, :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields if the type inherits from a class that "
"implements the garbage collector protocol and the child class does *not* "
"include the :c:macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"När man anropar :c:func:`PyType_Ready` eller några av de API:er som indirekt "
"anropar det som :c:func:`PyType_FromSpecWithBases` eller :c:func:"
"`PyType_FromSpec` kommer tolken automatiskt att fylla i fälten :c:member:"
"`~PyTypeObject.tp_flags`, :c:member:`~PyTypeObject.tp_traverse` och :c:"
"member:`~PyTypeObject.tp_clear` om typen ärver från en klass som "
"implementerar garbage collector-protokollet och den underordnade klassen "
"*inte* innehåller flaggan :c:macro:`Py_TPFLAGS_HAVE_GC`."

msgid ""
"Analogous to :c:macro:`PyObject_New` but for container objects with the :c:"
"macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Analogt med :c:macro:`PyObject_New` men för containerobjekt med flaggan :c:"
"macro:`Py_TPFLAGS_HAVE_GC` inställd."

msgid ""
"Do not call this directly to allocate memory for an object; call the type's :"
"c:member:`~PyTypeObject.tp_alloc` slot instead."
msgstr ""
"Anropa inte detta direkt för att allokera minne för ett objekt; anropa "
"istället typens :c:member:`~PyTypeObject.tp_alloc` slot."

msgid ""
"When populating a type's :c:member:`~PyTypeObject.tp_alloc` slot, :c:func:"
"`PyType_GenericAlloc` is preferred over a custom function that simply calls "
"this macro."
msgstr ""
"När en typs :c:member:`~PyTypeObject.tp_alloc`-plats fylls i är :c:func:"
"`PyType_GenericAlloc` att föredra framför en anpassad funktion som helt "
"enkelt anropar detta makro."

msgid ""
"Memory allocated by this macro must be freed with :c:func:`PyObject_GC_Del` "
"(usually called via the object's :c:member:`~PyTypeObject.tp_free` slot)."
msgstr ""
"Minne som allokerats av detta makro måste frigöras med :c:func:"
"`PyObject_GC_Del` (anropas vanligtvis via objektets :c:member:`~PyTypeObject."
"tp_free` slot)."

msgid ":c:func:`PyObject_GC_Del`"
msgstr ":c:func:`PyObject_GC_Del`"

msgid ":c:macro:`PyObject_New`"
msgstr ":c:makro:`PyObject_New`"

msgid ":c:func:`PyType_GenericAlloc`"
msgstr ":c:func:`PyType_GenericAlloc`"

msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:medlem:`~PyTypeObject.tp_alloc`"

msgid ""
"Analogous to :c:macro:`PyObject_NewVar` but for container objects with the :"
"c:macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Analogt med :c:macro:`PyObject_NewVar` men för containerobjekt med flaggan :"
"c:macro:`Py_TPFLAGS_HAVE_GC` inställd."

msgid ":c:macro:`PyObject_NewVar`"
msgstr ":c:makro:`PyObject_NewVar`"

msgid ""
"Analogous to :c:macro:`PyObject_GC_New` but allocates *extra_size* bytes at "
"the end of the object (at offset :c:member:`~PyTypeObject.tp_basicsize`). "
"The allocated memory is initialized to zeros, except for the :c:type:`Python "
"object header <PyObject>`."
msgstr ""
"Analogt med :c:macro:`PyObject_GC_New` men allokerar *extra_size* bytes i "
"slutet av objektet (vid offset :c:member:`~PyTypeObject.tp_basicsize`). Det "
"allokerade minnet initialiseras till noll, förutom :c:type:`Python object "
"header <PyObject>`."

msgid ""
"The extra data will be deallocated with the object, but otherwise it is not "
"managed by Python."
msgstr ""
"Den extra datan kommer att avallokeras med objektet, men i övrigt hanteras "
"den inte av Python."

msgid ""
"Memory allocated by this function must be freed with :c:func:"
"`PyObject_GC_Del` (usually called via the object's :c:member:`~PyTypeObject."
"tp_free` slot)."
msgstr ""
"Minne som allokerats av denna funktion måste frigöras med :c:func:"
"`PyObject_GC_Del` (anropas vanligtvis via objektets :c:member:`~PyTypeObject."
"tp_free` slot)."

msgid ""
"The function is marked as unstable because the final mechanism for reserving "
"extra data after an instance is not yet decided. For allocating a variable "
"number of fields, prefer using :c:type:`PyVarObject` and :c:member:"
"`~PyTypeObject.tp_itemsize` instead."
msgstr ""
"Funktionen är markerad som instabil eftersom den slutliga mekanismen för att "
"reservera extra data efter en instans ännu inte är bestämd. För att allokera "
"ett varierande antal fält, använd hellre :c:type:`PyVarObject` och :c:member:"
"`~PyTypeObject.tp_itemsize` istället."

msgid ""
"Resize an object allocated by :c:macro:`PyObject_NewVar`. Returns the "
"resized object of type ``TYPE*`` (refers to any C type) or ``NULL`` on "
"failure."
msgstr ""
"Ändrar storlek på ett objekt som allokerats av :c:macro:`PyObject_NewVar`. "
"Returnerar det storleksändrade objektet av typen ``TYPE*`` (refererar till "
"valfri C-typ) eller ``NULL`` om det misslyckas."

msgid ""
"*op* must be of type :c:expr:`PyVarObject *` and must not be tracked by the "
"collector yet. *newsize* must be of type :c:type:`Py_ssize_t`."
msgstr ""
"*op* måste vara av typen :c:expr:`PyVarObject *` och får inte spåras av "
"samlaren ännu. *newsize* måste vara av typen :c:type:`Py_ssize_t`."

msgid ""
"Adds the object *op* to the set of container objects tracked by the "
"collector.  The collector can run at unexpected times so objects must be "
"valid while being tracked.  This should be called once all the fields "
"followed by the :c:member:`~PyTypeObject.tp_traverse` handler become valid, "
"usually near the end of the constructor."
msgstr ""
"Lägger till objektet *op* till uppsättningen containerobjekt som spåras av "
"samlaren.  Uppsamlaren kan köras vid oväntade tidpunkter så objekten måste "
"vara giltiga när de spåras.  Detta bör anropas när alla fält som följs av "
"handlaren :c:member:`~PyTypeObject.tp_traverse` blir giltiga, vanligtvis i "
"slutet av konstruktorn."

msgid ""
"Returns non-zero if the object implements the garbage collector protocol, "
"otherwise returns 0."
msgstr ""
"Returnerar icke-noll om objektet implementerar garbage collector-"
"protokollet, annars returneras 0."

msgid ""
"The object cannot be tracked by the garbage collector if this function "
"returns 0."
msgstr ""
"Objektet kan inte spåras av skräpsamlaren om denna funktion returnerar 0."

msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* is "
"being currently tracked by the garbage collector and 0 otherwise."
msgstr ""
"Returnerar 1 om objekttypen för *op* implementerar GC-protokollet och *op* "
"för närvarande spåras av skräpsamlaren och 0 i annat fall."

msgid "This is analogous to the Python function :func:`gc.is_tracked`."
msgstr "Detta är analogt med Python-funktionen :func:`gc.is_tracked`."

msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* has "
"been already finalized by the garbage collector and 0 otherwise."
msgstr ""
"Returnerar 1 om objekttypen för *op* implementerar GC-protokollet och *op* "
"redan har slutförts av skräpsamlaren och 0 i annat fall."

msgid "This is analogous to the Python function :func:`gc.is_finalized`."
msgstr "Detta är analogt med Python-funktionen :func:`gc.is_finalized`."

msgid ""
"Releases memory allocated to an object using :c:macro:`PyObject_GC_New` or :"
"c:macro:`PyObject_GC_NewVar`."
msgstr ""
"Frigör minne som allokerats till ett objekt med :c:macro:`PyObject_GC_New` "
"eller :c:macro:`PyObject_GC_NewVar`."

msgid ""
"Do not call this directly to free an object's memory; call the type's :c:"
"member:`~PyTypeObject.tp_free` slot instead."
msgstr ""
"Anropa inte detta direkt för att frigöra ett objekts minne; anropa istället "
"typens :c:member:`~PyTypeObject.tp_free` slot."

msgid ""
"Do not use this for memory allocated by :c:macro:`PyObject_New`, :c:macro:"
"`PyObject_NewVar`, or related allocation functions; use :c:func:"
"`PyObject_Free` instead."
msgstr ""
"Använd inte detta för minne som allokerats av :c:macro:`PyObject_New`, :c:"
"macro:`PyObject_NewVar` eller relaterade allokeringsfunktioner; använd "
"istället :c:func:`PyObject_Free`."

msgid ":c:func:`PyObject_Free` is the non-GC equivalent of this function."
msgstr ""
":c:func:`PyObject_Free` är den icke-GC-motsvarighet till denna funktion."

msgid ":c:macro:`PyObject_GC_New`"
msgstr ":c:makro:`PyObject_GC_New`"

msgid ":c:macro:`PyObject_GC_NewVar`"
msgstr ":c:makro:`PyObject_GC_NewVar`"

msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

msgid ""
"Remove the object *op* from the set of container objects tracked by the "
"collector.  Note that :c:func:`PyObject_GC_Track` can be called again on "
"this object to add it back to the set of tracked objects.  The deallocator (:"
"c:member:`~PyTypeObject.tp_dealloc` handler) should call this for the object "
"before any of the fields used by the :c:member:`~PyTypeObject.tp_traverse` "
"handler become invalid."
msgstr ""
"Ta bort objektet *op* från uppsättningen containerobjekt som spåras av "
"samlaren.  Observera att :c:func:`PyObject_GC_Track` kan anropas igen på "
"detta objekt för att lägga till det igen i uppsättningen av spårade objekt.  "
"Deallocatorn (:c:member:`~PyTypeObject.tp_dealloc` handler) bör anropa detta "
"för objektet innan något av de fält som används av :c:member:`~PyTypeObject."
"tp_traverse` handler blir ogiltigt."

msgid ""
"The :c:func:`!_PyObject_GC_TRACK` and :c:func:`!_PyObject_GC_UNTRACK` macros "
"have been removed from the public C API."
msgstr ""
"Makron :c:func:`!_PyObject_GC_TRACK` och :c:func:`!_PyObject_GC_UNTRACK` har "
"tagits bort från det publika C API:et."

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler accepts a function "
"parameter of this type:"
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_traverse` accepterar en "
"funktionsparameter av denna typ:"

msgid ""
"Type of the visitor function passed to the :c:member:`~PyTypeObject."
"tp_traverse` handler. The function should be called with an object to "
"traverse as *object* and the third parameter to the :c:member:`~PyTypeObject."
"tp_traverse` handler as *arg*.  The Python core uses several visitor "
"functions to implement cyclic garbage detection; it's not expected that "
"users will need to write their own visitor functions."
msgstr ""
"Typ av besöksfunktion som skickas till :c:member:`~PyTypeObject.tp_traverse` "
"handler. Funktionen bör anropas med ett objekt att traversera som *object* "
"och den tredje parametern till handläggaren :c:member:`~PyTypeObject."
"tp_traverse` som *arg*.  Python-kärnan använder flera besökarfunktioner för "
"att implementera cyklisk skräpdetektering; det förväntas inte att användare "
"behöver skriva sina egna besökarfunktioner."

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler must have the following "
"type:"
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_traverse` måste ha följande typ:"

msgid ""
"Traversal function for a container object.  Implementations must call the "
"*visit* function for each object directly contained by *self*, with the "
"parameters to *visit* being the contained object and the *arg* value passed "
"to the handler.  The *visit* function must not be called with a ``NULL`` "
"object argument.  If *visit* returns a non-zero value that value should be "
"returned immediately."
msgstr ""
"Traversalfunktion för ett containerobjekt.  Implementeringar måste anropa "
"funktionen *visit* för varje objekt som direkt ingår i *self*, där "
"parametrarna till *visit* är det ingående objektet och värdet för *arg* som "
"skickas till hanteraren.  Funktionen *visit* får inte anropas med ett "
"``NULL`` objektargument.  Om *visit* returnerar ett värde som inte är noll "
"ska detta värde returneras omedelbart."

msgid ""
"To simplify writing :c:member:`~PyTypeObject.tp_traverse` handlers, a :c:"
"func:`Py_VISIT` macro is provided.  In order to use this macro, the :c:"
"member:`~PyTypeObject.tp_traverse` implementation must name its arguments "
"exactly *visit* and *arg*:"
msgstr ""
"För att förenkla skrivandet av :c:member:`~PyTypeObject.tp_traverse`-"
"hanterare tillhandahålls ett :c:func:`Py_VISIT`-makro.  För att kunna "
"använda detta makro måste :c:member:`~PyTypeObject.tp_traverse` "
"implementationen namnge sina argument exakt *visit* och *arg*:"

msgid ""
"If the :c:expr:`PyObject *` *o* is not ``NULL``, call the *visit* callback, "
"with arguments *o* and *arg*.  If *visit* returns a non-zero value, then "
"return it. Using this macro, :c:member:`~PyTypeObject.tp_traverse` handlers "
"look like::"
msgstr ""
"Om :c:expr:`PyObject *` *o* inte är ``NULL``, anropa *visit* callback, med "
"argumenten *o* och *arg*.  Om *visit* returnerar ett värde som inte är noll, "
"returnera det. Med hjälp av detta makro ser :c:member:`~PyTypeObject."
"tp_traverse` handlers ut som::"

msgid ""
"static int\n"
"my_traverse(Noddy *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->foo);\n"
"    Py_VISIT(self->bar);\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"my_traverse(Noddy *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(själv>foo);\n"
"    Py_VISIT(self->bar);\n"
"    return 0;\n"
"}"

msgid ""
"The :c:member:`~PyTypeObject.tp_clear` handler must be of the :c:type:"
"`inquiry` type, or ``NULL`` if the object is immutable."
msgstr ""
"Hanteraren :c:member:`~PyTypeObject.tp_clear` måste vara av typen :c:type:"
"`inquiry`, eller ``NULL`` om objektet är oföränderligt."

msgid ""
"Drop references that may have created reference cycles.  Immutable objects "
"do not have to define this method since they can never directly create "
"reference cycles.  Note that the object must still be valid after calling "
"this method (don't just call :c:func:`Py_DECREF` on a reference).  The "
"collector will call this method if it detects that this object is involved "
"in a reference cycle."
msgstr ""
"Släpper referenser som kan ha skapat referenscykler.  Oföränderliga objekt "
"behöver inte definiera denna metod eftersom de aldrig direkt kan skapa "
"referenscykler.  Observera att objektet fortfarande måste vara giltigt efter "
"anropet av denna metod (anropa inte bara :c:func:`Py_DECREF` på en "
"referens).  Uppsamlaren anropar denna metod om den upptäcker att detta "
"objekt är involverat i en referenscykel."

msgid "Controlling the Garbage Collector State"
msgstr "Styrning av skräpsamlarens tillstånd"

msgid ""
"The C-API provides the following functions for controlling garbage "
"collection runs."
msgstr ""
"C-API tillhandahåller följande funktioner för att styra körningar av "
"skräpplockning."

msgid ""
"Perform a full garbage collection, if the garbage collector is enabled. "
"(Note that :func:`gc.collect` runs it unconditionally.)"
msgstr ""
"Utför en fullständig skräpinsamling, om skräpinsamlaren är aktiverad. "
"(Observera att :func:`gc.collect` kör den villkorslöst)"

msgid ""
"Returns the number of collected + unreachable objects which cannot be "
"collected. If the garbage collector is disabled or already collecting, "
"returns ``0`` immediately. Errors during garbage collection are passed to :"
"data:`sys.unraisablehook`. This function does not raise exceptions."
msgstr ""
"Returnerar antalet insamlade + oåtkomliga objekt som inte kan samlas in. Om "
"skräpsamlaren är inaktiverad eller redan samlar in objekt, returneras ``0`` "
"omedelbart. Fel under skräpinsamlingen skickas till :data:`sys."
"unraisablehook`. Denna funktion ger inte upphov till undantag."

msgid ""
"Enable the garbage collector: similar to :func:`gc.enable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Aktivera skräpsamlaren: liknar :func:`gc.enable`. Returnerar det tidigare "
"tillståndet, 0 för inaktiverad och 1 för aktiverad."

msgid ""
"Disable the garbage collector: similar to :func:`gc.disable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Inaktivera skräpsamlaren: liknar :func:`gc.disable`. Returnerar det tidigare "
"tillståndet, 0 för inaktiverad och 1 för aktiverad."

msgid ""
"Query the state of the garbage collector: similar to :func:`gc.isenabled`. "
"Returns the current state, 0 for disabled and 1 for enabled."
msgstr ""
"Frågar efter skräpsamlarens tillstånd: liknar :func:`gc.isenabled`. "
"Returnerar det aktuella tillståndet, 0 för inaktiverad och 1 för aktiverad."

msgid "Querying Garbage Collector State"
msgstr "Förfrågan om status för skräpsamlare"

msgid ""
"The C-API provides the following interface for querying information about "
"the garbage collector."
msgstr ""
"C-API tillhandahåller följande gränssnitt för att fråga efter information om "
"skräpsamlaren."

msgid ""
"Run supplied *callback* on all live GC-capable objects. *arg* is passed "
"through to all invocations of *callback*."
msgstr ""
"Kör medföljande *callback* på alla levande GC-kompatibla objekt. *arg* "
"skickas vidare till alla anrop av *callback*."

msgid ""
"If new objects are (de)allocated by the callback it is undefined if they "
"will be visited."
msgstr ""
"Om nya objekt (de)allokeras av callbacken är det inte fastställt om de "
"kommer att besökas."

msgid ""
"Garbage collection is disabled during operation. Explicitly running a "
"collection in the callback may lead to undefined behaviour e.g. visiting the "
"same objects multiple times or not at all."
msgstr ""
"Garbage collection är inaktiverad under drift. Att explicit köra en "
"insamling i återuppringningen kan leda till odefinierat beteende, t.ex. att "
"samma objekt besöks flera gånger eller inte alls."

msgid ""
"Type of the visitor function to be passed to :c:func:"
"`PyUnstable_GC_VisitObjects`. *arg* is the same as the *arg* passed to "
"``PyUnstable_GC_VisitObjects``. Return ``1`` to continue iteration, return "
"``0`` to stop iteration. Other return values are reserved for now so "
"behavior on returning anything else is undefined."
msgstr ""
"Typ av besöksfunktion som ska skickas till :c:func:"
"`PyUnstable_GC_VisitObjects`. *arg* är samma som *arg* som skickas till "
"``PyUnstable_GC_VisitObjects``. Returnera ``1`` för att fortsätta "
"iterationen, returnera ``0`` för att stoppa iterationen. Andra returvärden "
"är reserverade för tillfället så beteendet vid retur av något annat är "
"odefinierat."
