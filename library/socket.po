# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!socket` --- Low-level networking interface"
msgstr ":mod:`!socket` --- Gränssnitt för nätverk på låg nivå"

msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**Källkod:** :source:`Lib/socket.py`"

msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"Denna modul ger tillgång till BSD *socket*-gränssnittet. Den är tillgänglig "
"på alla moderna Unix-system, Windows, MacOS och förmodligen ytterligare "
"plattformar."

msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr ""
"Vissa beteenden kan vara plattformsberoende, eftersom anrop görs till "
"operativsystemets socket-API:er."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`~socket.socket` function returns a :dfn:`socket object` whose "
"methods implement the various socket system calls.  Parameter types are "
"somewhat higher-level than in the C interface: as with :meth:`read` and :"
"meth:`write` operations on Python files, buffer allocation on receive "
"operations is automatic, and buffer length is implicit on send operations."
msgstr ""
"Python-gränssnittet är en enkel translitterering av Unix systemanrop och "
"biblioteksgränssnitt för sockets till Pythons objektorienterade stil: "
"funktionen :func:`~socket.socket` returnerar ett :dfn:`socket-objekt` vars "
"metoder implementerar de olika systemanropen för sockets.  Parametertyperna "
"är på en något högre nivå än i C-gränssnittet: precis som med :meth:`read` "
"och :meth:`write` operationer på Python-filer är buffertallokeringen vid "
"mottagning automatisk och buffertlängden är implicit vid sändning."

msgid "Module :mod:`socketserver`"
msgstr "Modul :mod:`socketserver`"

msgid "Classes that simplify writing network servers."
msgstr "Klasser som förenklar skrivandet av nätverksservrar."

msgid "Module :mod:`ssl`"
msgstr "Modul :mod:`ssl`"

msgid "A TLS/SSL wrapper for socket objects."
msgstr "En TLS/SSL-wrapper för socket-objekt."

msgid "Socket families"
msgstr "Uttagsfamiljer"

msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr ""
"Beroende på system och byggalternativ stöds olika sockelfamiljer av denna "
"modul."

msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"Det adressformat som krävs av ett visst socket-objekt väljs automatiskt "
"utifrån den adressfamilj som angavs när socket-objektet skapades.  "
"Socketadresser representeras på följande sätt:"

msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"Adressen till en :const:`AF_UNIX`-socket som är bunden till en filsystemnod "
"representeras som en sträng med hjälp av filsystemets kodning och "
"felhanteraren ``'surrogateescape'`` (se :pep:`383`).  En adress i Linux "
"abstrakta namnrymd returneras som ett :term:`bytesliknande objekt` med en "
"inledande nollbyte; notera att uttag i denna namnrymd kan kommunicera med "
"vanliga filsystemuttag, så program som är avsedda att köras på Linux kan "
"behöva hantera båda typerna av adresser.  En sträng eller ett bytesliknande "
"objekt kan användas för båda typerna av adresser när det skickas som ett "
"argument."

msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr ""
"Tidigare antogs :const:`AF_UNIX` socket-sökvägar använda UTF-8-kodning."

msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Skrivbar :term:`bytesliknande objekt` är nu accepterad."

msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"Ett par ``(host, port)`` används för adressfamiljen :const:`AF_INET`, där "
"*host* är en sträng som representerar antingen ett värdnamn i "
"internetdomännotation som ``'daring.cwi.nl'`` eller en IPv4-adress som "
"``'100.50.200.5'``, och *port* är ett heltal."

msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""
"För IPv4-adresser accepteras två specialformer i stället för en värdadress: "
"``''`` representerar :const:`INADDR_ANY`, som används för att binda till "
"alla gränssnitt, och strängen ``'<broadcast>'`` representerar :const:"
"`INADDR_BROADCAST`.  Detta beteende är inte kompatibelt med IPv6, därför bör "
"du undvika dessa om du avser att stödja IPv6 med dina Python-program."

msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"För adressfamiljen :const:`AF_INET6` används en fyrdubbling ``(host, port, "
"flowinfo, scope_id)``, där *flowinfo* och *scope_id* representerar "
"medlemmarna ``sin6_flowinfo`` och ``sin6_scope_id`` i :const:`struct "
"sockaddr_in6` i C. För modulmetoderna :mod:`socket` kan *flowinfo* och "
"*scope_id* utelämnas bara för bakåtkompatibilitet.  Observera dock att "
"utelämnande av *scope_id* kan orsaka problem vid manipulering av scoped IPv6-"
"adresser."

msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""
"För multicast-adresser (med *scope_id* meningsfullt) får *address* inte "
"innehålla delen ``%scope_id`` (eller ``zone id``). Denna information är "
"överflödig och kan med fördel utelämnas (rekommenderas)."

msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` sockets representeras som par ``(pid, groups)``."

msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"Stöd för TIPC endast för Linux finns tillgängligt med hjälp av "
"adressfamiljen :const:`AF_TIPC`.  TIPC är ett öppet, icke-IP-baserat "
"nätverksprotokoll som är utformat för användning i klustrade datormiljöer.  "
"Adresser representeras av en tupel och fälten beror på adresstypen. Den "
"allmänna tupelformen är ``(addr_type, v1, v2, v3 [, scope])``, där:"

msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* är en av :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"eller :const:`TIPC_ADDR_ID`."

msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* är en av :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, och :"
"const:`TIPC_NODE_SCOPE`."

msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"Om *addr_type* är :const:`TIPC_ADDR_NAME`, så är *v1* servertypen, *v2* "
"portidentifieraren och *v3* bör vara 0."

msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"Om *addr_type* är :const:`TIPC_ADDR_NAMESEQ`, så är *v1* servertypen, *v2* "
"det lägre portnumret och *v3* det övre portnumret."

msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"Om *addr_type* är :const:`TIPC_ADDR_ID`, så är *v1* noden, *v2* referensen "
"och *v3* ska sättas till 0."

msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
"En tupel ``(interface, )`` används för adressfamiljen :const:`AF_CAN`, där "
"*interface* är en sträng som representerar ett nätverksgränssnittsnamn som "
"``'can0'``. Nätverksgränssnittsnamnet ``''`` kan användas för att ta emot "
"paket från alla nätverksgränssnitt i denna familj."

msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
":const:`CAN_ISOTP`-protokollet kräver en tupel ``(interface, rx_addr, "
"tx_addr)`` där båda tilläggsparametrarna är osignerade långa heltal som "
"representerar en CAN-identifierare (standard eller utökad)."

msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
":const:`CAN_J1939`-protokollet kräver en tupel ``(interface, name, pgn, "
"addr)`` där ytterligare parametrar är ett 64-bitars osignerat heltal som "
"representerar ECU-namnet, ett 32-bitars osignerat heltal som representerar "
"parametergruppnumret (PGN) och ett 8-bitars heltal som representerar "
"adressen."

msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""
"En sträng eller en tupel ``(id, unit)`` används för protokollet :const:"
"`SYSPROTO_CONTROL` i familjen :const:`PF_SYSTEM`. Strängen är namnet på en "
"kärnkontroll som använder ett dynamiskt tilldelat ID. Tupeln kan användas om "
"ID och enhetsnummer för kärnkontrollen är kända eller om ett registrerat ID "
"används."

msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ":const:`AF_BLUETOOTH` stöder följande protokoll och adressformat:"

msgid ""
":const:`BTPROTO_L2CAP` accepts a tuple ``(bdaddr, psm[, cid[, "
"bdaddr_type]])`` where:"
msgstr ""
":const:`BTPROTO_L2CAP` accepterar en tupel ``(bdaddr, psm[, cid[, "
"bdaddr_type]])`` där:"

msgid "``bdaddr`` is a string specifying the Bluetooth address."
msgstr "``bdaddr`` är en sträng som anger Bluetooth-adressen."

msgid "``psm`` is an integer specifying the Protocol/Service Multiplexer."
msgstr "``psm`` är ett heltal som anger Protocol/Service Multiplexer."

msgid ""
"``cid`` is an optional integer specifying the Channel Identifier. If not "
"given, defaults to zero."
msgstr ""
"``cid`` är ett valfritt heltal som anger kanalidentifieraren. Om den inte "
"anges är standardvärdet noll."

msgid ""
"``bdaddr_type`` is an optional integer specifying the address type; one of :"
"const:`BDADDR_BREDR` (default), :const:`BDADDR_LE_PUBLIC`, :const:"
"`BDADDR_LE_RANDOM`."
msgstr ""
"``bdaddr_type`` är ett valfritt heltal som anger adresstypen; en av :const:"
"`BDADDR_BREDR` (standard), :const:`BDADDR_LE_PUBLIC`, :const:"
"`BDADDR_LE_RANDOM`."

msgid "Added ``cid`` and ``bdaddr_type`` fields."
msgstr "Fälten ``cid`` och ``bdaddr_type`` tillagda."

msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` accepterar ``(bdaddr, channel)`` där ``bdaddr`` är "
"Bluetooth-adressen som en sträng och ``channel`` är ett heltal."

msgid ":const:`BTPROTO_HCI` accepts a format that depends on your OS."
msgstr ""
":const:`BTPROTO_HCI` accepterar ett format som beror på ditt operativsystem."

msgid ""
"On Linux it accepts an integer ``device_id`` or a tuple ``(device_id, "
"[channel])`` where ``device_id`` specifies the number of the Bluetooth "
"device, and ``channel`` is an optional integer specifying the HCI channel (:"
"const:`HCI_CHANNEL_RAW` by default)."
msgstr ""
"På Linux accepterar den ett heltal ``device_id`` eller en tupel "
"``(device_id, [channel])`` där ``device_id`` anger numret på Bluetooth-"
"enheten och ``channel`` är ett valfritt heltal som anger HCI-kanalen (:const:"
"`HCI_CHANNEL_RAW`` som standard)."

msgid ""
"On FreeBSD, NetBSD and DragonFly BSD it accepts ``bdaddr`` where ``bdaddr`` "
"is the Bluetooth address as a string."
msgstr ""
"På FreeBSD, NetBSD och DragonFly BSD accepterar den ``bdaddr`` där "
"``bdaddr`` är Bluetooth-adressen som en sträng."

msgid "NetBSD and DragonFlyBSD support added."
msgstr "Stöd för NetBSD och DragonFlyBSD har lagts till."

msgid "FreeBSD support added."
msgstr "Stöd för FreeBSD har lagts till."

msgid ""
"Added ``channel`` field. ``device_id`` not packed in a tuple is now accepted."
msgstr ""
"Lagt till fältet ``channel``. ``device_id`` som inte är packat i en tupel "
"accepteras nu."

msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is the Bluetooth "
"address as a string or a :class:`bytes` object. (ex. ``'12:23:34:45:56:67'`` "
"or ``b'12:23:34:45:56:67'``)"
msgstr ""
":const:`BTPROTO_SCO` accepterar ``bdaddr`` där ``bdaddr`` är Bluetooth-"
"adressen som en sträng eller ett :class:`bytes`-objekt. (t.ex. "
"``'12:23:34:45:56:67'`` eller ``b'12:23:34:45:56:67'``)"

msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` är ett socketbaserat gränssnitt för kärnkryptografi som "
"endast används i Linux. En algoritmsockel konfigureras med en tuple av två "
"till fyra element ``(typ, namn [, feat [, mask]])``, där:"

msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* är algoritmtypen som en sträng, t.ex. ``aead``, ``hash``, "
"``skcipher`` eller ``rng``."

msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* är algoritmens namn och driftläge som en sträng, t.ex. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` eller ``drbg_nopr_ctr_aes256``."

msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* och *mask* är osignerade 32-bitars heltal."

msgid "Some algorithm types require more recent Kernels."
msgstr "Vissa algoritmtyper kräver nyare kärnor."

msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` tillåter kommunikation mellan virtuella maskiner och deras "
"värdar. Socklarna representeras som en ``(CID, port)``-tupel där kontext-ID "
"eller CID och port är heltal."

msgid "See :manpage:`vsock(7)`"
msgstr "Se :manpage:`vsock(7)`"

msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"addresses are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` är ett lågnivågränssnitt direkt till nätverksenheter. "
"Adresserna representeras av tupeln ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` där:"

msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - Sträng som anger enhetens namn."

msgid ""
"*proto* - The Ethernet protocol number. May be :data:`ETH_P_ALL` to capture "
"all protocols, one of the :ref:`ETHERTYPE_* constants <socket-ethernet-"
"types>` or any other Ethernet protocol number."
msgstr ""
"*proto* - Ethernetprotokollets nummer. Kan vara :data:`ETH_P_ALL` för att "
"fånga alla protokoll, en av :ref:`ETHERTYPE_*-konstanterna <socket-ethernet-"
"types>` eller något annat Ethernet-protokollnummer."

msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - Valfritt heltal som anger pakettyp:"

msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr ""
"``PACKET_HOST`` (standard) - Paketet adresseras till den lokala värden."

msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - Broadcast-paket i det fysiska lagret."

msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr ""
"``PACKET_MULTICAST`` - Paket som skickas till en multicastadress i det "
"fysiska lagret."

msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""
"``PACKET_OTHERHOST`` - Paket till en annan värd som har fångats upp av en "
"enhetsdrivrutin i promiscuous-läge."

msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr ""
"``PACKET_OUTGOING`` - Paket från den lokala värden som loopas tillbaka till "
"ett paketuttag."

msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr "*hatype* - Valfritt heltal som anger typen av ARP-hårdvaruadress."

msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr ""
"*addr* - Valfritt bytesliknande objekt som anger den fysiska "
"hårdvaruadressen, vars tolkning beror på enheten."

msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` är ett socketbaserat gränssnitt för Linux för "
"kommunikation med tjänster som körs på samprocessorer i Qualcomm-"
"plattformar. Adressfamiljen representeras som en ``(nod, port)``-tupel där "
"*nod* och *port* är icke-negativa heltal."

msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` är en variant av UDP som låter dig ange vilken del "
"av ett paket som täcks av kontrollsumman. Den lägger till två socket-"
"alternativ som du kan ändra. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` ändrar hur stor del av utgående paket som "
"täcks av kontrollsumman och ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` filtrerar bort paket som täcker för lite av "
"sina data. I båda fallen bör ``length`` ligga i ``range(8, 2**16, 8)``."

msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"En sådan socket bör konstrueras med ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` för IPv4 eller ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` för IPv6."

msgid ""
":const:`AF_HYPERV` is a Windows-only socket based interface for "
"communicating with Hyper-V hosts and guests. The address family is "
"represented as a ``(vm_id, service_id)`` tuple where the ``vm_id`` and "
"``service_id`` are UUID strings."
msgstr ""
":const:`AF_HYPERV` är ett socketbaserat gränssnitt för Windows för "
"kommunikation med Hyper-V-värdar och -gäster. Adressfamiljen representeras "
"som en ``(vm_id, service_id)``-tupel där ``vm_id`` och ``service_id`` är "
"UUID-strängar."

msgid ""
"The ``vm_id`` is the virtual machine identifier or a set of known VMID "
"values if the target is not a specific virtual machine. Known VMID constants "
"defined on ``socket`` are:"
msgstr ""
"``vm_id`` är den virtuella maskinens identifierare eller en uppsättning "
"kända VMID-värden om målet inte är en specifik virtuell maskin. Kända VMID-"
"konstanter som definieras på ``socket`` är:"

msgid "``HV_GUID_ZERO``"
msgstr "``HV_GUID_ZERO``"

msgid "``HV_GUID_BROADCAST``"
msgstr "``HV_GUID_BROADCAST``"

msgid ""
"``HV_GUID_WILDCARD`` - Used to bind on itself and accept connections from "
"all partitions."
msgstr ""
"``HV_GUID_WILDCARD`` - Används för att binda på sig själv och acceptera "
"anslutningar från alla partitioner."

msgid ""
"``HV_GUID_CHILDREN`` - Used to bind on itself and accept connection from "
"child partitions."
msgstr ""
"``HV_GUID_CHILDREN`` - Används för att binda på sig själv och acceptera "
"anslutning från underordnade partitioner."

msgid "``HV_GUID_LOOPBACK`` - Used as a target to itself."
msgstr "``HV_GUID_LOOPBACK`` - Används som mål för sig själv."

msgid ""
"``HV_GUID_PARENT`` - When used as a bind accepts connection from the parent "
"partition. When used as an address target it will connect to the parent "
"partition."
msgstr ""
"``HV_GUID_PARENT`` - När den används som bindning accepteras anslutning från "
"den överordnade partitionen. När den används som adressmål kommer den att "
"ansluta till den överordnade partitionen."

msgid "The ``service_id`` is the service identifier of the registered service."
msgstr "``service_id`` är tjänsteidentifieraren för den registrerade tjänsten."

msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"Om du använder ett värdnamn i *host*-delen av IPv4/v6-socketadressen kan "
"programmet uppvisa ett icke-bestämbart beteende, eftersom Python använder "
"den första adressen som returneras från DNS-upplösningen.  Socketadressen "
"kommer att lösas upp på olika sätt till en faktisk IPv4/v6-adress, beroende "
"på resultaten från DNS-upplösningen och/eller värdkonfigurationen.  För "
"deterministiskt beteende använd en numerisk adress i *host*-delen."

msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""
"Alla fel ger upphov till undantag.  De normala undantagen för ogiltiga "
"argumenttyper och när minnet är slut kan användas. Fel relaterade till "
"socket- eller adresssemantik ger upphov till :exc:`OSError` eller en av dess "
"underklasser."

msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
"Icke-blockerande läge stöds genom :meth:`~socket.setblocking`.  En "
"generalisering av detta baserat på timeouts stöds genom :meth:`~socket."
"settimeout`."

msgid "Module contents"
msgstr "Modulens innehåll"

msgid "The module :mod:`socket` exports the following elements."
msgstr "Modulen :mod:`socket` exporterar följande element."

msgid "Exceptions"
msgstr "Undantag"

msgid "A deprecated alias of :exc:`OSError`."
msgstr "Ett föråldrat alias för :exc:`OSError`."

msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ""
"Efter :pep:`3151` gjordes denna klass till ett alias för :exc:`OSError`."

msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
"Detta undantag är en underklass till :exc:`OSError` och uppstår vid "
"adressrelaterade fel, dvs. för funktioner som använder *h_errno* i POSIX C "
"API, inklusive :func:`gethostbyname_ex` och :func:`gethostbyaddr`. Det "
"medföljande värdet är ett par ``(h_errno, string)`` som representerar ett "
"fel som returneras av ett biblioteksanrop.  *h_errno* är ett numeriskt "
"värde, medan *sträng* representerar beskrivningen av *h_errno*, som "
"returneras av C-funktionen :c:func:`hstrerror`."

msgid "This class was made a subclass of :exc:`OSError`."
msgstr "Denna klass gjordes till en underklass av :exc:`OSError`."

msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`!EAI_\\*` constants defined in this module."
msgstr ""
"Detta undantag, som är en underklass till :exc:`OSError`, uppstår vid "
"adressrelaterade fel som orsakas av :func:`getaddrinfo` och :func:"
"`getnameinfo`. Det medföljande värdet är ett par ``(error, string)`` som "
"representerar ett fel som returneras av ett biblioteksanrop.  *string* "
"representerar beskrivningen av *error*, som returneras av C-funktionen :c:"
"func:`gai_strerror`.  Det numeriska *error*-värdet kommer att matcha en av :"
"const:`!EAI_\\*`-konstanterna som definieras i den här modulen."

msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr "Ett föråldrat alias för :exc:`TimeoutError`."

msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
"Detta undantag är en underklass till :exc:`OSError` och uppstår när en "
"timeout inträffar på ett uttag som har timeouts aktiverade via ett tidigare "
"anrop till :meth:`~socket.settimeout` (eller implicit via :func:`~socket."
"setdefaulttimeout`).  Det medföljande värdet är en sträng vars värde för "
"närvarande alltid är \"timed out\"."

msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "Denna klass gjordes till ett alias för :exc:`TimeoutError`."

msgid "Constants"
msgstr "Konstanter"

msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"Konstanterna AF_* och SOCK_* är nu :class:`AddressFamily` och :class:"
"`SocketKind` :class:`.IntEnum` samlingar."

msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`~socket.socket`.  If the :const:`AF_UNIX` constant "
"is not defined then this protocol is unsupported.  More constants may be "
"available depending on the system."
msgstr ""
"Dessa konstanter representerar de adress- (och protokoll-) familjer som "
"används för det första argumentet till :func:`~socket.socket`.  Om "
"konstanten :const:`AF_UNIX` inte är definierad stöds inte det här "
"protokollet.  Fler konstanter kan vara tillgängliga beroende på systemet."

msgid ""
":const:`AF_UNSPEC` means that :func:`getaddrinfo` should return socket "
"addresses for any address family (either IPv4, IPv6, or any other) that can "
"be used."
msgstr ""
":const:`AF_UNSPEC` betyder att :func:`getaddrinfo` ska returnera "
"socketadresser för alla adressfamiljer (antingen IPv4, IPv6 eller någon "
"annan) som kan användas."

msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`~socket.socket`.  More constants may be available depending on the "
"system. (Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be "
"generally useful.)"
msgstr ""
"Dessa konstanter representerar de socket-typer som används för det andra "
"argumentet till :func:`~socket.socket`.  Fler konstanter kan vara "
"tillgängliga beroende på systemet. (Endast :const:`SOCK_STREAM` och :const:"
"`SOCK_DGRAM` verkar vara allmänt användbara)"

msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"Dessa två konstanter, om de definieras, kan kombineras med socket-typerna "
"och gör att du kan ställa in vissa flaggor atomiskt (och därmed undvika "
"eventuella tävlingsförhållanden och behovet av separata anrop)."

msgid ""
"`Secure File Descriptor Handling <https://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""
"säker hantering av File Descriptor <https://udrepper.livejournal.com/20407."
"html>`_ för en mer ingående förklaring."

msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`~socket.setsockopt` and :meth:"
"`~socket.getsockopt` methods of socket objects.  In most cases, only those "
"symbols that are defined in the Unix header files are defined; for a few "
"symbols, default values are provided."
msgstr ""
"Många konstanter av dessa former, som finns dokumenterade i Unix-"
"dokumentationen om sockets och/eller IP-protokollet, är också definierade i "
"socket-modulen. De används i allmänhet som argument till metoderna :meth:"
"`~socket.setsockopt` och :meth:`~socket.getsockopt` för socket-objekt.  I de "
"flesta fall definieras endast de symboler som finns definierade i Unix "
"header-filer; för några få symboler anges standardvärden."

msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` lades till."

msgid ""
"Added support for ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` on Windows platforms "
"when available."
msgstr ""
"Lagt till stöd för ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` på Windows-plattformar "
"när det finns tillgängligt."

msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT`` lades till."

msgid ""
"Added support for ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` on Windows platforms "
"when available."
msgstr ""
"Lagt till stöd för ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` på Windows-"
"plattformar när det finns tillgängligt."

msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""
"``IP_RECVTOS`` lades till.  ``TCP_KEEPALIVE`` lades till. På MacOS kan denna "
"konstant användas på samma sätt som ``TCP_KEEPIDLE`` används på Linux."

msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""
"Lagt till ``TCP_CONNECTION_INFO``. På MacOS kan denna konstant användas på "
"samma sätt som ``TCP_INFO`` används på Linux och BSD."

msgid ""
"Added ``SO_RTABLE`` and ``SO_USER_COOKIE``. On OpenBSD and FreeBSD "
"respectively those constants can be used in the same way that ``SO_MARK`` is "
"used on Linux. Also added missing TCP socket options from Linux: "
"``TCP_MD5SIG``, ``TCP_THIN_LINEAR_TIMEOUTS``, ``TCP_THIN_DUPACK``, "
"``TCP_REPAIR``, ``TCP_REPAIR_QUEUE``, ``TCP_QUEUE_SEQ``, "
"``TCP_REPAIR_OPTIONS``, ``TCP_TIMESTAMP``, ``TCP_CC_INFO``, "
"``TCP_SAVE_SYN``, ``TCP_SAVED_SYN``, ``TCP_REPAIR_WINDOW``, "
"``TCP_FASTOPEN_CONNECT``, ``TCP_ULP``, ``TCP_MD5SIG_EXT``, "
"``TCP_FASTOPEN_KEY``, ``TCP_FASTOPEN_NO_COOKIE``, ``TCP_ZEROCOPY_RECEIVE``, "
"``TCP_INQ``, ``TCP_TX_DELAY``. Added ``IP_PKTINFO``, ``IP_UNBLOCK_SOURCE``, "
"``IP_BLOCK_SOURCE``, ``IP_ADD_SOURCE_MEMBERSHIP``, "
"``IP_DROP_SOURCE_MEMBERSHIP``."
msgstr ""
"Lagt till ``SO_RTABLE`` och ``SO_USER_COOKIE``. På OpenBSD respektive "
"FreeBSD kan dessa konstanter användas på samma sätt som ``SO_MARK`` används "
"på Linux. Har även lagt till saknade TCP-socketalternativ från Linux: "
"``TCP_MD5SIG``, ``TCP_THIN_LINEAR_TIMEOUTS``, ``TCP_THIN_DUPACK``, "
"``TCP_REPAIR``, ``TCP_REPAIR_QUEUE``, ``TCP_QUEUE_SEQ``, "
"``TCP_REPAIR_OPTIONS``, ``TCP_TIMESTAMP``, ``TCP_CC_INFO``, "
"``TCP_SAVE_SYN``, ``TCP_SAVED_SYN``, ``TCP_REPAIR_WINDOW``, "
"``TCP_FASTOPEN_CONNECT``, ``TCP_ULP``, ``TCP_MD5SIG_EXT``, "
"``TCP_FASTOPEN_KEY``, ``TCP_FASTOPEN_NO_COOKIE``, ``TCP_ZEROCOPY_RECEIVE``, "
"``TCP_INQ``, ``TCP_TX_DELAY``. Lagt till ``IP_PKTINFO``, "
"``IP_UNBLOCK_SOURCE``, ``IP_BLOCK_SOURCE``, ``IP_ADD_SOURCE_MEMBERSHIP``, "
"``IP_DROP_SOURCE_MEMBERSHIP``."

msgid ""
"Added ``SO_BINDTOIFINDEX``. On Linux this constant can be used in the same "
"way that ``SO_BINDTODEVICE`` is used, but with the index of a network "
"interface instead of its name."
msgstr ""
"Lagt till ``SO_BINDTOIFINDEX``. På Linux kan denna konstant användas på "
"samma sätt som ``SO_BINDTODEVICE``, men med indexet för ett "
"nätverksgränssnitt i stället för dess namn."

msgid ""
"Added missing ``IP_FREEBIND``, ``IP_RECVERR``, ``IPV6_RECVERR``, "
"``IP_RECVTTL``, and ``IP_RECVORIGDSTADDR`` on Linux."
msgstr ""
"Lagt till saknade ``IP_FREEBIND``, ``IP_RECVERR``, ``IPV6_RECVERR``, "
"``IP_RECVTTL`` och ``IP_RECVORIGDSTADDR`` på Linux."

msgid "Added support for ``TCP_QUICKACK`` on Windows platforms when available."
msgstr ""
"Lagt till stöd för ``TCP_QUICKACK`` på Windows-plattformar när det finns "
"tillgängligt."

msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr ""
"Många konstanter av dessa former, som finns dokumenterade i Linux-"
"dokumentationen, definieras också i socket-modulen."

msgid "NetBSD support was added."
msgstr "Stöd för NetBSD har lagts till."

msgid "Restored missing ``CAN_RAW_ERR_FILTER`` on Linux."
msgstr "Återställde saknade ``CAN_RAW_ERR_FILTER`` på Linux."

msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN_BCM, i CAN-protokollfamiljen, är broadcast manager (BCM)-protokollet. "
"Broadcast Manager-konstanter, som finns dokumenterade i Linux-"
"dokumentationen, definieras också i socket-modulen."

msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr ""
"Flaggan :data:`CAN_BCM_CAN_FD_FRAME` är endast tillgänglig på Linux >= 4.8."

msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"Aktiverar stöd för CAN FD i ett CAN_RAW-uttag. Detta är avaktiverat som "
"standard. Detta gör att din applikation kan skicka både CAN- och CAN FD-"
"ramar, men du måste acceptera både CAN- och CAN FD-ramar när du läser från "
"sockeln."

msgid "This constant is documented in the Linux documentation."
msgstr "Denna konstant finns dokumenterad i Linux-dokumentationen."

msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""
"Sammanfogar de tillämpade CAN-filtren så att endast CAN-ramar som matchar "
"alla givna CAN-filter skickas till användarutrymmet."

msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN_ISOTP, i CAN-protokollfamiljen, är ISO-TP-protokollet (ISO 15765-2). ISO-"
"TP-konstanter, dokumenterade i Linux-dokumentationen."

msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""
"CAN_J1939, i CAN-protokollfamiljen, är SAE J1939-protokollet. J1939-"
"konstanter, dokumenterade i Linux-dokumentationen."

msgid ""
"These two constants, documented in the FreeBSD divert(4) manual page, are "
"also defined in the socket module."
msgstr ""
"Dessa två konstanter, som finns dokumenterade i FreeBSD divert(4)-"
"manualsidan, definieras också i socket-modulen."

msgid ""
":data:`!ETH_P_ALL` can be used in the :class:`~socket.socket` constructor as "
"*proto* for the :const:`AF_PACKET` family in order to capture every packet, "
"regardless of protocol."
msgstr ""
":data:`!ETH_P_ALL` kan användas i :class:`~socket.socket`-konstruktören som "
"*proto* för :const:`AF_PACKET`-familjen för att fånga alla paket, oavsett "
"protokoll."

msgid "For more information, see the :manpage:`packet(7)` manpage."
msgstr "För mer information, se :manpage:`packet(7)` manpage."

msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Konstanter för Windows WSAIoctl(). Konstanterna används som argument till :"
"meth:`~socket.socket.ioctl`-metoden för socket-objekt."

msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH`` lades till."

msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"TIPC-relaterade konstanter, som matchar de som exporteras av C socket API. "
"Se TIPC-dokumentationen för mer information."

msgid "Constants for Linux Kernel cryptography."
msgstr "Konstanter för Linux Kernel-kryptografi."

msgid "Constants for Linux host/guest communication."
msgstr "Konstanter för Linux host/guest-kommunikation."

msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr ""
"Denna konstant innehåller ett booleskt värde som anger om IPv6 stöds på "
"denna plattform."

msgid "Integer constants for use with Bluetooth addresses."
msgstr "Heltalskonstanter för användning med Bluetooth-adresser."

msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"Dessa är strängkonstanter som innehåller Bluetooth-adresser med speciella "
"betydelser. Till exempel kan :const:`BDADDR_ANY` användas för att ange "
"vilken adress som helst när du anger bindningsuttaget med :const:"
"`BTPROTO_RFCOMM`."

msgid ""
"These constants describe the Bluetooth address type when binding or "
"connecting a :const:`BTPROTO_L2CAP` socket."
msgstr ""
"Dessa konstanter beskriver Bluetooth-adresstypen när du binder eller "
"ansluter ett :const:`BTPROTO_L2CAP`-uttag."

msgid ""
"Used in the level argument to the :meth:`~socket.setsockopt` and :meth:"
"`~socket.getsockopt` methods of Bluetooth socket objects."
msgstr ""
"Används i level-argumentet till metoderna :meth:`~socket.setsockopt` och :"
"meth:`~socket.getsockopt` för Bluetooth-socketobjekt."

msgid ""
":const:`SOL_BLUETOOTH` is only available on Linux. Other constants are "
"available if the corresponding protocol is supported."
msgstr ""
":const:`SOL_BLUETOOTH` är endast tillgängligt på Linux. Andra konstanter är "
"tillgängliga om det finns stöd för motsvarande protokoll."

msgid ""
"Used in the option name and value argument to the :meth:`~socket.setsockopt` "
"and :meth:`~socket.getsockopt` methods of Bluetooth socket objects."
msgstr ""
"Används som argument för alternativnamn och värde i metoderna :meth:`~socket."
"setsockopt` och :meth:`~socket.getsockopt` för Bluetooth-socketobjekt."

msgid ""
":const:`!BT_*` and :const:`L2CAP_LM` are only available on Linux. :const:`!"
"SO_BTH_*` are only available on Windows. Other constants may be available on "
"Linux and various BSD platforms."
msgstr ""
":const:`!BT_*` och :const:`L2CAP_LM` är endast tillgängliga på Linux. :const:"
"`!SO_BTH_*` är endast tillgängliga på Windows. Andra konstanter kan finnas "
"tillgängliga på Linux och olika BSD-plattformar."

msgid ""
"Option names for use with :const:`BTPROTO_HCI`. Availability and format of "
"the option values depend on platform."
msgstr ""
"Alternativnamn för användning med :const:`BTPROTO_HCI`. Tillgänglighet och "
"format för alternativvärdena beror på plattform."

msgid ""
"Added :const:`!SO_HCI_EVT_FILTER` and :const:`!SO_HCI_PKT_FILTER` on NetBSD "
"and DragonFly BSD. Added :const:`!HCI_DATA_DIR` on FreeBSD, NetBSD and "
"DragonFly BSD."
msgstr ""
"Lagt till :const:`!SO_HCI_EVT_FILTER` och :const:`!SO_HCI_PKT_FILTER` på "
"NetBSD och DragonFly BSD. Lagt till :const:`!HCI_DATA_DIR` på FreeBSD, "
"NetBSD och DragonFly BSD."

msgid ""
"The ``device_id`` value used to create an HCI socket that isn't specific to "
"a single Bluetooth adapter."
msgstr ""
"Värdet ``device_id`` som används för att skapa ett HCI-uttag som inte är "
"specifikt för en enda Bluetooth-adapter."

msgid ""
"Possible values for ``channel`` field in the :const:`BTPROTO_HCI` address."
msgstr "Möjliga värden för fältet ``channel`` i adressen :const:`BTPROTO_HCI`."

msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr ""
"Konstant för Qualcomms IPC-routerprotokoll, som används för att kommunicera "
"med fjärrprocessorer som tillhandahåller tjänster."

msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""
"LOCAL_CREDS och LOCAL_CREDS_PERSISTENT kan användas med SOCK_DGRAM, "
"SOCK_STREAM uttag, motsvarande Linux/DragonFlyBSD SO_PASSCRED, medan "
"LOCAL_CREDS skickar inloggningsuppgifterna vid första läsningen, "
"LOCAL_CREDS_PERSISTENT skickar för varje läsning, SCM_CREDS2 måste då "
"användas för den senare för meddelandetypen."

msgid ""
"Constant to optimize CPU locality, to be used in conjunction with :data:"
"`SO_REUSEPORT`."
msgstr ""
"Konstant för att optimera CPU-lokalisering, ska användas tillsammans med :"
"data:`SO_REUSEPORT`."

msgid ""
"Constant to enable duplicate address and port bindings with load balancing."
msgstr ""
"Konstant för att aktivera duplicerade adress- och portbindningar med "
"lastbalansering."

msgid "Constants for Windows Hyper-V sockets for host/guest communications."
msgstr "Konstanter för Windows Hyper-V-sockets för värd/gäst-kommunikation."

msgid ""
"`IEEE 802.3 protocol number <https://www.iana.org/assignments/ieee-802-"
"numbers/ieee-802-numbers.txt>`_. constants."
msgstr ""
"`IEEE 802.3 protokollnummer <https://www.iana.org/assignments/ieee-802-"
"numbers/ieee-802-numbers.txt>`_. konstanter."

msgid ""
"These constants are used by the :meth:`~socket.socket.shutdown` method of "
"socket objects."
msgstr ""
"Dessa konstanter används av :meth:`~socket.socket.shutdown`-metoden för "
"socket-objekt."

msgid "Functions"
msgstr "Funktioner"

msgid "Creating sockets"
msgstr "Skapa uttag"

msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "Följande funktioner skapar alla :ref:`socket-objekt <socket-objects>`."

msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"Skapa en ny socket med hjälp av den angivna adressfamiljen, socket-typen och "
"protokollnumret.  Adressfamiljen bör vara :const:`AF_INET` (standard), :"
"const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET` "
"eller :const:`AF_RDS`. Socket-typen bör vara :const:`SOCK_STREAM` "
"(standard), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` eller kanske någon av de "
"andra ``SOCK_``-konstanterna. Protokollnumret är vanligtvis noll och kan "
"utelämnas eller i det fall adressfamiljen är :const:`AF_CAN` bör protokollet "
"vara ett av :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` eller :"
"const:`CAN_J1939`."

msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close`."
msgstr ""
"Om *fileno* anges, hämtas värdena för *family*, *type* och *proto* "
"automatiskt från den angivna filbeskrivaren.  Automatisk detektering kan "
"åsidosättas genom att anropa funktionen med uttryckliga *family*-, *type*- "
"eller *proto*-argument.  Detta påverkar endast hur Python representerar t."
"ex. returvärdet av :meth:`socket.getpeername` men inte den faktiska OS-"
"resursen.  Till skillnad från :func:`socket.fromfd` kommer *fileno* att "
"returnera samma socket och inte en dubblett. Detta kan hjälpa till att "
"stänga ett fristående uttag med hjälp av :meth:`socket.close`."

msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "Det nyskapade uttaget är :ref:`non-inherititable <fd_inheritance>`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.__new__`` med "
"argumenten ``self``, ``family``, ``type``, ``protocol``."

msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "Familjen AF_CAN lades till. Familjen AF_RDS lades till."

msgid "The CAN_BCM protocol was added."
msgstr "Protokollet CAN_BCM har lagts till."

msgid "The returned socket is now non-inheritable."
msgstr "Den returnerade sockeln är nu inte ärftlig."

msgid "The CAN_ISOTP protocol was added."
msgstr "Protokollet CAN_ISOTP har lagts till."

msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  Therefore,"
msgstr ""
"När bitflaggorna :const:`SOCK_NONBLOCK` eller :const:`SOCK_CLOEXEC` "
"tillämpas på *type* rensas de och :attr:`socket.type` kommer inte att "
"återspegla dem.  De skickas fortfarande till det underliggande systemets "
"``socket()``-anrop.  Därför är"

msgid ""
"sock = socket.socket(\n"
"    socket.AF_INET,\n"
"    socket.SOCK_STREAM | socket.SOCK_NONBLOCK)"
msgstr ""
"sock = socket.socket(\n"
"    socket.AF_INET,\n"
"    socket.SOCK_STREAM | socket.SOCK_NONBLOCK)"

msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"kommer fortfarande att skapa ett icke-blockerande uttag på operativsystem "
"som stöder ``SOCK_NONBLOCK``, men ``sock.type`` kommer att sättas till "
"``socket.SOCK_STREAM``."

msgid "The CAN_J1939 protocol was added."
msgstr "Protokollet CAN_J1939 har lagts till."

msgid "The IPPROTO_MPTCP protocol was added."
msgstr "Protokollet IPPROTO_MPTCP har lagts till."

msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`~socket.socket` function above. The default "
"family is :const:`AF_UNIX` if defined on the platform; otherwise, the "
"default is :const:`AF_INET`."
msgstr ""
"Bygger ett par anslutna socket-objekt med hjälp av den angivna "
"adressfamiljen, socket-typen och protokollnumret.  Adressfamilj, sockeltyp "
"och protokollnummer är som för funktionen :func:`~socket.socket` ovan. "
"Standardfamiljen är :const:`AF_UNIX` om den definieras på plattformen; "
"annars är standard :const:`AF_INET`."

msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "De nyskapade uttagen är :ref:`icke-ärftliga <fd_inheritance>`."

msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr ""
"De returnerade socket-objekten stöder nu hela socket-API:et, snarare än en "
"delmängd."

msgid "The returned sockets are now non-inheritable."
msgstr "De återlämnade uttagen är nu icke-ärftliga."

msgid "Windows support added."
msgstr "Stöd för Windows har lagts till."

msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"Anslut till en TCP-tjänst som lyssnar på internetadressen *address* (en 2-"
"tupel ``(host, port)``) och returnera socket-objektet.  Detta är en funktion "
"på högre nivå än :meth:`socket.connect`: om *host* är ett icke-numeriskt "
"värdnamn kommer den att försöka lösa det för både :data:`AF_INET` och :data:"
"`AF_INET6`, och sedan försöka ansluta till alla möjliga adresser i tur och "
"ordning tills en anslutning lyckas.  Detta gör det enkelt att skriva "
"klienter som är kompatibla med både IPv4 och IPv6."

msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"Om den valfria parametern *timeout* anges kommer timeouten att ställas in på "
"socket-instansen innan anslutningsförsök görs.  Om ingen *timeout* anges "
"används den globala standardinställningen för timeout som returneras av :"
"func:`getdefaulttimeout`."

msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"Om *source_address* anges måste det vara en 2-tupel ``(host, port)`` som "
"sockeln ska binda till som sin källadress innan den ansluter.  Om host eller "
"port är '' respektive 0 kommer OS standardbeteende att användas."

msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""
"Om det inte går att skapa en anslutning uppstår ett undantag. Som standard "
"är det undantaget från den sista adressen i listan. Om *all_errors* är "
"``True``, är det en :exc:`ExceptionGroup` som innehåller felen i alla försök."

msgid "*source_address* was added."
msgstr "*source_address* har lagts till."

msgid "*all_errors* was added."
msgstr "*all_errors* har lagts till."

msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and returns the socket object."
msgstr ""
"Bekvämlighetsfunktion som skapar ett TCP-socket bundet till *adress* (en 2-"
"tupel ``(host, port)``) och returnerar socket-objektet."

msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; if not specified , a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""
"*family* bör vara antingen :data:`AF_INET` eller :data:`AF_INET6`. *backlog* "
"är den köstorlek som skickas till :meth:`socket.listen`; om inget anges "
"väljs ett rimligt standardvärde. *reuse_port* avgör om socket-alternativet :"
"data:`SO_REUSEPORT` ska ställas in."

msgid ""
"If *dualstack_ipv6* is true, *family* is :data:`AF_INET6` and the platform "
"supports it the socket will be able to accept both IPv4 and IPv6 "
"connections, else it will raise :exc:`ValueError`. Most POSIX platforms and "
"Windows are supposed to support this functionality. When this functionality "
"is enabled the address returned by :meth:`socket.getpeername` when an IPv4 "
"connection occurs will be an IPv6 address represented as an IPv4-mapped IPv6 "
"address. If *dualstack_ipv6* is false it will explicitly disable this "
"functionality on platforms that enable it by default (e.g. Linux). This "
"parameter can be used in conjunction with :func:`has_dualstack_ipv6`:"
msgstr ""
"Om *dualstack_ipv6* är true, *family* är :data:`AF_INET6` och plattformen "
"stöder det kommer uttaget att kunna acceptera både IPv4- och IPv6-"
"anslutningar, annars kommer det att ge upphov till :exc:`ValueError`. De "
"flesta POSIX-plattformar och Windows ska ha stöd för denna funktionalitet. "
"När den här funktionen är aktiverad kommer den adress som returneras av :"
"meth:`socket.getpeername` när en IPv4-anslutning sker att vara en IPv6-"
"adress som representeras av en IPv4-mappad IPv6-adress. Om *dualstack_ipv6* "
"är false kommer denna funktionalitet att uttryckligen inaktiveras på "
"plattformar som aktiverar den som standard (t.ex. Linux). Denna parameter "
"kan användas tillsammans med :func:`has_dualstack_ipv6`:"

msgid ""
"import socket\n"
"\n"
"addr = (\"\", 8080)  # all interfaces, port 8080\n"
"if socket.has_dualstack_ipv6():\n"
"    s = socket.create_server(addr, family=socket.AF_INET6, "
"dualstack_ipv6=True)\n"
"else:\n"
"    s = socket.create_server(addr)"
msgstr ""
"import socket\n"
"\n"
"addr = (\"\", 8080)  # all interfaces, port 8080\n"
"if socket.has_dualstack_ipv6():\n"
"    s = socket.create_server(addr, family=socket.AF_INET6, "
"dualstack_ipv6=True)\n"
"else:\n"
"    s = socket.create_server(addr)"

msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"På POSIX-plattformar är socket-alternativet :data:`SO_REUSEADDR` inställt "
"för att omedelbart återanvända tidigare sockets som var bundna till samma "
"*adress* och förblev i TIME_WAIT-tillstånd."

msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""
"Returnerar ``True`` om plattformen stöder skapandet av ett TCP-uttag som kan "
"hantera både IPv4- och IPv6-anslutningar."

msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`~io.IOBase.fileno` method) and build a socket object from "
"the result.  Address family, socket type and protocol number are as for the :"
"func:`~socket.socket` function above. The file descriptor should refer to a "
"socket, but this is not checked --- subsequent operations on the object may "
"fail if the file descriptor is invalid. This function is rarely needed, but "
"can be used to get or set socket options on a socket passed to a program as "
"standard input or output (such as a server started by the Unix inet "
"daemon).  The socket is assumed to be in blocking mode."
msgstr ""
"Duplicera filbeskrivaren *fd* (ett heltal som returneras av ett filobjekts :"
"meth:`~io.IOBase.fileno`-metod) och bygg ett socket-objekt från resultatet.  "
"Adressfamilj, socket-typ och protokollnummer är samma som för funktionen :"
"func:`~socket.socket` ovan. Filens deskriptor bör referera till en socket, "
"men detta kontrolleras inte --- efterföljande operationer på objektet kan "
"misslyckas om filens deskriptor är ogiltig. Denna funktion behövs sällan, "
"men kan användas för att hämta eller ställa in socket-alternativ på en "
"socket som skickas till ett program som standardinmatning eller -utmatning "
"(t.ex. en server som startas av Unix inet daemon).  Sockeln antas vara i "
"blockeringsläge."

msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
"Instansiera ett uttag från data som erhållits från metoden :meth:`socket."
"share`.  Uttaget antas vara i blockeringsläge."

msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"Detta är ett Python-typobjekt som representerar objekttypen socket. Det är "
"samma sak som ``type(socket(...))``."

msgid "Other functions"
msgstr "Övriga funktioner"

msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ""
"Modulen :mod:`socket` erbjuder också olika nätverksrelaterade tjänster:"

msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"Stäng en filbeskrivare för en socket. Detta är som :func:`os.close`, men för "
"sockets. På vissa plattformar (mest märkbart Windows) fungerar inte :func:"
"`os.close` för socket-filbeskrivare."

msgid ""
"This function wraps the C function ``getaddrinfo`` of the underlying system."
msgstr ""
"Denna funktion omsluter C-funktionen ``getaddrinfo`` i det underliggande "
"systemet."

msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"Översätter *host*/*port*-argumentet till en sekvens av 5-tuples som "
"innehåller alla nödvändiga argument för att skapa en socket som är ansluten "
"till den tjänsten. *host* är ett domännamn, en strängrepresentation av en "
"IPv4/v6-adress eller ``None``. *port* är ett strängnamn för en tjänst, t.ex. "
"``'http'``, ett numeriskt portnummer eller ``None``.  Genom att ange "
"``None`` som värde för *host* och *port* kan du ange ``NULL`` till det "
"underliggande C API:et."

msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to provide options and limit the list of addresses returned. Pass "
"their default values (:data:`AF_UNSPEC`, 0, and 0, respectively) to not "
"limit the results. See the note below for details."
msgstr ""
"Argumenten *family*, *type* och *proto* kan anges som tillval för att ge "
"alternativ och begränsa listan med adresser som returneras. Använd deras "
"standardvärden (:data:`AF_UNSPEC`, 0 respektive 0) för att inte begränsa "
"resultaten. Se anmärkningen nedan för mer information."

msgid ""
"The *flags* argument can be one or several of the ``AI_*`` constants, and "
"will influence how results are computed and returned. For example, :const:"
"`AI_NUMERICHOST` will disable domain name resolution and will raise an error "
"if *host* is a domain name."
msgstr ""
"Argumentet *flags* kan vara en eller flera av ``AI_*``-konstanterna och "
"påverkar hur resultaten beräknas och returneras. Exempelvis kommer :const:"
"`AI_NUMERICHOST` att inaktivera domännamnsupplösning och ge upphov till ett "
"fel om *host* är ett domännamn."

msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "Funktionen returnerar en lista med 5-tuples med följande struktur:"

msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`~socket.socket` function.  *canonname* will be a "
"string representing the canonical name of the *host* if :const:"
"`AI_CANONNAME` is part of the *flags* argument; else *canonname* will be "
"empty.  *sockaddr* is a tuple describing a socket address, whose format "
"depends on the returned *family* (a ``(address, port)`` 2-tuple for :const:"
"`AF_INET`, a ``(address, port, flowinfo, scope_id)`` 4-tuple for :const:"
"`AF_INET6`), and is meant to be passed to the :meth:`socket.connect` method."
msgstr ""
"I dessa tupler är *family*, *type*, *proto* alla heltal och är avsedda att "
"skickas till funktionen :func:`~socket.socket`.  *canonname* kommer att vara "
"en sträng som representerar det kanoniska namnet på *host* om :const:"
"`AI_CANONNAME` är en del av *flags*-argumentet; annars kommer *canonname* "
"att vara tomt.  *sockaddr* är en tupel som beskriver en socketadress, vars "
"format beror på den returnerade *familjen* (en ``(adress, port)`` 2-tupel "
"för :const:`AF_INET`, en ``(adress, port, flowinfo, scope_id)`` 4-tupel för :"
"const:`AF_INET6`), och är avsedd att skickas till metoden :meth:`socket."
"connect`."

msgid ""
"If you intend to use results from :func:`!getaddrinfo` to create a socket "
"(rather than, for example, retrieve *canonname*), consider limiting the "
"results by *type* (e.g. :data:`SOCK_STREAM` or :data:`SOCK_DGRAM`) and/or "
"*proto* (e.g. :data:`IPPROTO_TCP` or :data:`IPPROTO_UDP`) that your "
"application can handle."
msgstr ""
"Om du tänker använda resultaten från :func:`!getaddrinfo` för att skapa ett "
"uttag (i stället för att t.ex. hämta *canonname*) bör du överväga att "
"begränsa resultaten efter *typ* (t.ex. :data:`SOCK_STREAM` eller :data:"
"`SOCK_DGRAM`) och/eller *proto* (t.ex. :data:`IPPROTO_TCP` eller :data:"
"`IPPROTO_UDP`) som ditt program kan hantera."

msgid ""
"The behavior with default values of *family*, *type*, *proto* and *flags* is "
"system-specific."
msgstr ""
"Beteendet med standardvärden för *family*, *type*, *proto* och *flags* är "
"systemspecifikt."

msgid ""
"Many systems (for example, most Linux configurations) will return a sorted "
"list of all matching addresses. These addresses should generally be tried in "
"order until a connection succeeds (possibly tried in parallel, for example, "
"using a `Happy Eyeballs`_ algorithm). In these cases, limiting the *type* "
"and/or *proto* can help eliminate unsuccessful or unusable connection "
"attempts."
msgstr ""
"Många system (t.ex. de flesta Linux-konfigurationer) returnerar en sorterad "
"lista över alla matchande adresser. Dessa adresser bör i allmänhet provas i "
"tur och ordning tills en anslutning lyckas (eventuellt parallellt, t.ex. med "
"hjälp av en `Happy Eyeballs`_-algoritm). I dessa fall kan en begränsning av "
"*typ* och/eller *proto* bidra till att eliminera misslyckade eller "
"oanvändbara anslutningsförsök."

msgid ""
"Some systems will, however, only return a single address. (For example, this "
"was reported on Solaris and AIX configurations.) On these systems, limiting "
"the *type* and/or *proto* helps ensure that this address is usable."
msgstr ""
"Vissa system returnerar dock bara en enda adress. (Detta har t.ex. "
"rapporterats för Solaris- och AIX-konfigurationer.) På dessa system kan man "
"genom att begränsa *type* och/eller *proto* säkerställa att adressen är "
"användbar."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.getaddrinfo`` med "
"argumenten ``host``, ``port``, ``family``, ``type``, ``protocol``."

msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"Följande exempel hämtar adressinformation för en hypotetisk TCP-anslutning "
"till ``example.org`` på port 80 (resultaten kan skilja sig åt i ditt system "
"om IPv6 inte är aktiverat)::"

msgid ""
">>> socket.getaddrinfo(\"example.org\", 80, proto=socket.IPPROTO_TCP)\n"
"[(socket.AF_INET6, socket.SOCK_STREAM,\n"
" 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),\n"
" (socket.AF_INET, socket.SOCK_STREAM,\n"
" 6, '', ('93.184.216.34', 80))]"
msgstr ""
">>> socket.getaddrinfo(\"example.org\", 80, proto=socket.IPPROTO_TCP)\n"
"[(socket.AF_INET6, socket.SOCK_STREAM,\n"
" 6, '', ('2606:2800:220:1:248:1893:25c8:1946', 80, 0, 0)),\n"
" (socket.AF_INET, socket.SOCK_STREAM,\n"
" 6, '', ('93.184.216.34', 80))]"

msgid "parameters can now be passed using keyword arguments."
msgstr "parametrar kan nu skickas med hjälp av nyckelordsargument."

msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr ""
"för IPv6 multicast-adresser kommer strängen som representerar en adress inte "
"att innehålla delen ``%scope_id``."

msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"Returnerar ett fullständigt kvalificerat domännamn för *namn*. Om *name* "
"utelämnas eller är tomt tolkas det som den lokala värden.  För att hitta det "
"fullständigt kvalificerade namnet kontrolleras det värdnamn som returneras "
"av :func:`gethostbyaddr`, följt av alias för värden, om sådana finns.  Det "
"första namnet som innehåller en punkt väljs.  Om inget fullständigt "
"kvalificerat domännamn finns tillgängligt och *name* angavs returneras det "
"oförändrat.  Om *name* var tomt eller lika med ``'0.0.0.0'`` returneras "
"värdnamnet från :func:`gethostname`."

msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Översätter ett värdnamn till IPv4-adressformat.  IPv4-adressen returneras "
"som en sträng, t.ex. ``'100.50.200.5'``.  Om värdnamnet i sig är en IPv4-"
"adress returneras den oförändrad.  Se :func:`gethostbyname_ex` för ett mer "
"komplett gränssnitt. :func:`gethostbyname` stöder inte IPv6-namnupplösning, "
"och :func:`getaddrinfo` bör användas istället för IPv4/v6 dual stack-stöd."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.gethostbyname`` med "
"argumentet ``hostname``."

msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a 3-"
"tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Översätter ett värdnamn till IPv4-adressformat, utökat gränssnitt. "
"Returnerar en 3-tupel ``(hostname, aliaslist, ipaddrlist)`` där *hostname* "
"är värdens primära värdnamn, *aliaslist* är en (eventuellt tom) lista med "
"alternativa värdnamn för samma adress och *ipaddrlist* är en lista med IPv4-"
"adresser för samma gränssnitt på samma värd (ofta men inte alltid en enda "
"adress). :func:`gethostbyname_ex` har inte stöd för IPv6-namnupplösning och :"
"func:`getaddrinfo` bör användas istället för IPv4/v6 dual stack-stöd."

msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr ""
"Returnerar en sträng som innehåller värdnamnet på den maskin där Python-"
"tolken körs för närvarande."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.gethostname`` utan "
"argument."

msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"Observera: :func:`gethostname` returnerar inte alltid det fullständigt "
"kvalificerade domännamnet; använd :func:`getfqdn` för det."

msgid ""
"Return a 3-tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"Returnerar en 3-tupel ``(hostname, aliaslist, ipaddrlist)`` där *hostname* "
"är det primära värdnamnet som svarar på den angivna *ip_address*, "
"*aliaslist* är en (eventuellt tom) lista över alternativa värdnamn för samma "
"adress och *ipaddrlist* är en lista över IPv4/v6-adresser för samma "
"gränssnitt på samma värd (innehåller troligen bara en enda adress). För att "
"hitta det fullständigt kvalificerade domännamnet, använd funktionen :func:"
"`getfqdn`. :func:`gethostbyaddr` stöder både IPv4 och IPv6."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` med "
"argumentet ``ip_address``."

msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""
"Översätter en socketadress *sockaddr* till en 2-tupel ``(host, port)``. "
"Beroende på inställningarna i *flags* kan resultatet innehålla ett "
"fullständigt kvalificerat domännamn eller en numerisk adressrepresentation i "
"*host*.  På samma sätt kan *port* innehålla en sträng med ett portnamn eller "
"ett numeriskt portnummer."

msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""
"För IPv6-adresser läggs ``%scope_id`` till värddelen om *sockaddr* "
"innehåller meningsfulla *scope_id*. Vanligtvis händer detta för multicast-"
"adresser."

msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr "För mer information om *flags* kan du läsa :manpage:`getnameinfo(3)`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.getnameinfo`` med "
"argumentet ``sockaddr``."

msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`~socket."
"socket` function.  This is usually only needed for sockets opened in \"raw\" "
"mode (:const:`SOCK_RAW`); for the normal socket modes, the correct protocol "
"is chosen automatically if the protocol is omitted or zero."
msgstr ""
"Översätt ett internetprotokollnamn (t.ex. ``'icmp'``) till en konstant som "
"kan användas som det (valfria) tredje argumentet till funktionen :func:"
"`~socket.socket`.  Detta behövs vanligtvis bara för socklar som öppnas i "
"\"raw\"-läge (:const:`SOCK_RAW`); för de normala socketlägena väljs rätt "
"protokoll automatiskt om protokollet utelämnas eller är noll."

msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Översätter ett namn på en internettjänst och ett protokollnamn till ett "
"portnummer för den tjänsten.  Det valfria protokollnamnet, om det anges, bör "
"vara ``'tcp'`` eller ``'udp'``, annars kommer alla protokoll att matcha."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.getservbyname`` med "
"argumenten ``servicename``, ``protocolname``."

msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Översätter ett internetportnummer och ett protokollnamn till ett servicenamn "
"för den tjänsten.  Det valfria protokollnamnet, om det anges, bör vara "
"``'tcp'`` eller ``'udp'``, annars kommer alla protokoll att matcha."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.getservbyport`` med "
"argumenten ``port``, ``protocolname``."

msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Konverterar 32-bitars positiva heltal från nätverkets till värddatorns "
"byteordning.  På maskiner där värdbyteordningen är densamma som "
"nätverksbyteordningen är detta ett no-op; annars utförs en swapoperation på "
"4 byte."

msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Konvertera 16-bitars positiva heltal från nätverkets byteordning till "
"värddatorns byteordning.  På maskiner där värdbyteordningen är densamma som "
"nätverksbyteordningen är detta ett no-op; annars utförs en 2 byte swap-"
"operation."

msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned integer."
msgstr ""
"Utlöser :exc:`OverflowError` om *x* inte ryms i ett 16-bitars osignerat "
"heltal."

msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Konverterar 32-bitars positiva heltal från värd- till nätverksbyteordning.  "
"På maskiner där värdbyteordningen är densamma som nätverksbyteordningen är "
"detta en no-op; annars utförs en swapoperation på 4 byte."

msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Konverterar 16-bitars positiva heltal från värd- till nätverksbyteordning.  "
"På maskiner där värdbyteordningen är densamma som nätverksbyteordningen är "
"detta en no-op; annars utförs en 2 byte swap-operation."

msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""
"Konverterar en IPv4-adress från strängformat med prickade kvadrater (t.ex. "
"'123.45.67.89') till 32-bitars packat binärt format, som ett bytesobjekt med "
"fyra tecken i längd.  Detta är användbart när du pratar med ett program som "
"använder standard C-biblioteket och behöver objekt av typen :c:struct:"
"`in_addr`, vilket är C-typen för det 32-bitars packade binära format som "
"denna funktion returnerar."

msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton` accepterar även strängar med mindre än tre punkter; se "
"Unix manualsida :manpage:`inet(3)` för detaljer."

msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"Om IPv4-adresssträngen som skickas till denna funktion är ogiltig, kommer :"
"exc:`OSError` att uppstå. Observera att exakt vad som är giltigt beror på "
"den underliggande C-implementeringen av :c:func:`inet_aton`."

msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` har inte stöd för IPv6 och :func:`inet_pton` bör användas "
"istället för stöd för IPv4/v6 dual stack."

msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""
"Konverterar en 32-bitars packad IPv4-adress (ett fyra byte långt :term:"
"`bytes-liknande objekt`) till dess standardrepresentation i form av en "
"sträng med prickade kvadrater (t.ex. '123.45.67.89').  Detta är användbart "
"när du pratar med ett program som använder standard C-biblioteket och "
"behöver objekt av typen :c:struct:`in_addr`, vilket är C-typen för 32-bitars "
"packade binära data som den här funktionen tar som argument."

msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"Om byte-sekvensen som skickas till den här funktionen inte är exakt 4 byte "
"lång, kommer :exc:`OSError` att visas. :func:`inet_ntoa` stöder inte IPv6, "
"och :func:`inet_ntop` bör användas istället för IPv4/v6 dual stack-stöd."

msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to :func:"
"`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""
"Konvertera en IP-adress från dess familjespecifika strängformat till ett "
"packat, binärt format. :func:`inet_pton` är användbart när ett bibliotek "
"eller nätverksprotokoll kräver ett objekt av typen :c:struct:`in_addr` "
"(liknande :func:`inet_aton`) eller :c:struct:`in6_addr`."

msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"Värden som stöds för *address_family* är för närvarande :const:`AF_INET` "
"och :const:`AF_INET6`. Om IP-adresssträngen *ip_string* är ogiltig kommer :"
"exc:`OSError` att visas. Observera att exakt vad som är giltigt beror på "
"både värdet på *address_family* och den underliggande implementationen av :c:"
"func:`inet_pton`."

msgid "Windows support added"
msgstr "Windows-stöd har lagts till"

msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""
"Konverterar en packad IP-adress (ett :term:`bytesliknande objekt` med ett "
"visst antal byte) till dess standardiserade, familjespecifika "
"strängrepresentation (t.ex. ``'7.10.0.5'`` eller ``'5aef:2b::8'``). :func:"
"`inet_ntop` är användbart när ett bibliotek eller nätverksprotokoll "
"returnerar ett objekt av typen :c:struct:`in_addr` (liknande :func:"
"`inet_ntoa`) eller :c:struct:`in6_addr`."

msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"Värden som stöds för *address_family* är för närvarande :const:`AF_INET` "
"och :const:`AF_INET6`. Om bytesobjektet *packed_ip* inte har rätt längd för "
"den angivna adressfamiljen, kommer :exc:`ValueError` att uppstå. :exc:"
"`OSError` uppstår för fel från anropet till :func:`inet_ntop`."

msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"Returnerar den totala längden, utan efterföljande utfyllnad, av ett "
"tilläggsdataobjekt med tillhörande data av den angivna *längden*.  Detta "
"värde kan ofta användas som buffertstorlek för :meth:`~socket.recvmsg` för "
"att ta emot ett enda objekt med tillhörande data, men :rfc:`3542` kräver att "
"portabla applikationer använder :func:`CMSG_SPACE` och därmed inkluderar "
"utrymme för utfyllnad, även när objektet kommer att vara det sista i "
"bufferten.  Utlöser :exc:`OverflowError` om *length* ligger utanför det "
"tillåtna värdeintervallet."

msgid "Most Unix platforms."
msgstr "De flesta Unix-plattformar."

msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"Returnerar den buffertstorlek som behövs för att :meth:`~socket.recvmsg` ska "
"kunna ta emot ett tilläggsdataobjekt med tillhörande data av den angivna "
"*längden*, tillsammans med eventuell efterföljande utfyllnad.  Det "
"buffertutrymme som behövs för att ta emot flera objekt är summan av :func:"
"`CMSG_SPACE`-värdena för deras associerade datalängder.  Utlöser :exc:"
"`OverflowError` om *length* ligger utanför det tillåtna värdeintervallet."

msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"Observera att vissa system kan stödja tilläggsdata utan att tillhandahålla "
"denna funktion.  Observera också att en inställning av buffertstorleken med "
"hjälp av resultaten från denna funktion kanske inte exakt begränsar den "
"mängd tilläggsdata som kan tas emot, eftersom ytterligare data kan rymmas i "
"utfyllnadsområdet."

msgid "most Unix platforms."
msgstr "de flesta Unix-plattformar."

msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"Returnerar standardtimeout i sekunder (float) för nya socket-objekt. Ett "
"värde på ``None`` anger att nya socket-objekt inte har någon timeout. När "
"socket-modulen importeras första gången är standardvärdet ``None``."

msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"Ställ in standardtimeout i sekunder (float) för nya socket-objekt.  När "
"socket-modulen importeras första gången är standardvärdet ``None``.  Se :"
"meth:`~socket.settimeout` för möjliga värden och deras respektive betydelser."

msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"Ställ in maskinens värdnamn till *namn*.  Detta kommer att ge upphov till "
"ett :exc:`OSError` om du inte har tillräckliga rättigheter."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.sethostname`` med "
"argumentet ``name``."

msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"Returnerar en lista med information om nätverksgränssnitt (index int, "
"namnsträng). :exc:`OSError` om systemanropet misslyckas."

msgid "Windows support was added."
msgstr "Stöd för Windows har lagts till."

msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""
"I Windows har nätverksgränssnitten olika namn i olika sammanhang (alla namn "
"är exempel):"

msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

msgid "name: ``ethernet_32770``"
msgstr "name: ``ethernet_32770``"

msgid "friendly name: ``vEthernet (nat)``"
msgstr "friendly name: ``vEthernet (nat)``"

msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "description: ``Hyper-V Virtual Ethernet Adapter``"

msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr ""
"Denna funktion returnerar namn av den andra formen från listan, "
"``ethernet_32770`` i detta exempel."

msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"Returnerar ett indexnummer för ett nätverksgränssnitt som motsvarar ett "
"gränssnittsnamn. :exc:`OSError` om det inte finns något gränssnitt med det "
"angivna namnet."

msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr ""
"\"Interface name\" är ett namn som dokumenterats i :func:`if_nameindex`."

msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"Returnerar ett nätverksgränssnittsnamn som motsvarar ett "
"gränssnittsindexnummer. :exc:`OSError` om det inte finns något gränssnitt "
"med angivet index."

msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`~socket.sendmsg` for the documentation of these parameters."
msgstr ""
"Skicka listan med filbeskrivare *fds* över ett :const:`AF_UNIX`-socket "
"*sock*. Parametern *fds* är en sekvens av filbeskrivare. Se :meth:`~socket."
"sendmsg` för dokumentation av dessa parametrar."

msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr ""
"Unix-plattformar som stöder :meth:`~socket.sendmsg` och :const:`SCM_RIGHTS` "
"mekanism."

msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`~socket."
"recvmsg` for the documentation of these parameters."
msgstr ""
"Tar emot upp till *maxfds* filbeskrivare från en :const:`AF_UNIX` socket "
"*sock*. Returnerar ``(msg, list(fds), flags, addr)``. Se :meth:`~socket."
"recvmsg` för dokumentation av dessa parametrar."

msgid ""
"Unix platforms supporting :meth:`~socket.recvmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr ""
"Unix-plattformar som stöder :meth:`~socket.recvmsg` och :const:`SCM_RIGHTS` "
"mekanism."

msgid "Any truncated integers at the end of the list of file descriptors."
msgstr "Eventuella avkortade heltal i slutet av listan över filbeskrivare."

msgid "Socket Objects"
msgstr "Socket-objekt"

msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
"Socket-objekt har följande metoder.  Med undantag för :meth:`~socket."
"makefile` motsvarar dessa Unix systemanrop som är tillämpliga på sockets."

msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"Stöd för protokollet :term:`context manager` har lagts till.  Att avsluta "
"kontexthanteraren är likvärdigt med att anropa :meth:`~socket.close`."

msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"Acceptera en anslutning. Sockeln måste vara bunden till en adress och lyssna "
"efter anslutningar. Returvärdet är ett par ``(conn, address)`` där *conn* är "
"ett *nytt* socketobjekt som kan användas för att skicka och ta emot data på "
"anslutningen, och *address* är adressen som är bunden till sockeln i andra "
"änden av anslutningen."

msgid "The socket is now non-inheritable."
msgstr "Uttaget är nu icke-ärftligt."

msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Om systemanropet avbryts och signalhanteraren inte ger upphov till ett "
"undantag, försöker metoden nu göra om systemanropet istället för att ge "
"upphov till ett :exc:`InterruptedError`-undantag (se :pep:`475` för "
"förklaringen)."

msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Binda uttaget till *adress*.  Uttaget får inte redan vara bundet. (Formatet "
"på *adress* beror på adressfamiljen --- se ovan)"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.bind`` med argumenten "
"``self``, ``address``."

msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"Markera uttaget som stängt.  Den underliggande systemresursen (t.ex. en "
"filbeskrivare) stängs också när alla filobjekt från :meth:`makefile` "
"stängs.  När det händer kommer alla framtida operationer på socket-objektet "
"att misslyckas. Fjärränden kommer inte att ta emot några fler data (efter "
"att köade data har spolats)."

msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"Socklar stängs automatiskt när de samlas in, men det rekommenderas att :meth:"
"`close` dem explicit, eller att använda ett :keyword:`with`-slutord runt dem."

msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
":exc:`OSError` tas nu upp om ett fel uppstår när det underliggande :c:func:"
"`close`-anropet görs."

msgid ""
":meth:`close` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown` before :meth:`close`."
msgstr ""
":meth:`close` frigör den resurs som är kopplad till en anslutning men "
"stänger inte nödvändigtvis anslutningen omedelbart.  Om du vill stänga "
"anslutningen i rätt tid, anropa :meth:`shutdown` före :meth:`close`."

msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"Anslut till en fjärransluten socket på *adress*. (Formatet på *adress* beror "
"på adressfamiljen --- se ovan)"

msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""
"Om anslutningen avbryts av en signal väntar metoden tills anslutningen är "
"klar, eller ger upphov till ett :exc:`TimeoutError` vid timeout, om "
"signalhanteraren inte ger upphov till ett undantag och uttaget är "
"blockerande eller har en timeout. För icke-blockerande uttag ger metoden "
"upphov till ett :exc:`InterruptedError`-undantag om anslutningen avbryts av "
"en signal (eller det undantag som signalhanteraren ger upphov till)."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.connect`` med "
"argumenten ``self``, ``address``."

msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"Metoden väntar nu tills anslutningen är klar istället för att skapa ett :exc:"
"`InterruptedError`-undantag om anslutningen avbryts av en signal, "
"signalhanteraren inte skapar ett undantag och uttaget blockeras eller har en "
"timeout (se :pep:`475` för motivering)."

msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"Som ``connect(address)``, men returnerar en felindikator istället för att "
"skapa ett undantag för fel som returneras av anropet :c:func:`connect` på C-"
"nivå (andra problem, t.ex. \"host not found\", kan fortfarande skapa "
"undantag).  Felindikatorn är ``0`` om operationen lyckades, annars värdet på "
"variabeln :c:data:`errno`.  Detta är användbart för att stödja t.ex. "
"asynkrona anslutningar."

msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"Sätter socket-objektet i stängt tillstånd utan att faktiskt stänga den "
"underliggande filbeskrivaren.  Fildeskriptorn returneras och kan "
"återanvändas för andra ändamål."

msgid "Duplicate the socket."
msgstr "Duplicera uttaget."

msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"Returnerar socketens filbeskrivare (ett litet heltal), eller -1 om den "
"misslyckas. Detta är användbart med :func:`select.select`."

msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"Under Windows kan det lilla heltal som returneras av denna metod inte "
"användas där en filbeskrivare kan användas (t.ex. :func:`os.fdopen`).  Unix "
"har inte denna begränsning."

msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"Hämta :ref:`inheritable flag <fd_inheritance>` för socketens filbeskrivare "
"eller socketens handtag: ``True`` om sockeln kan ärvas i underordnade "
"processer, ``False`` om den inte kan det."

msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"Returnerar den fjärradress som uttaget är anslutet till.  Detta är till "
"exempel användbart för att ta reda på portnumret för en fjärransluten IPv4/"
"v6-socket. (Formatet på den adress som returneras beror på adressfamiljen "
"--- se ovan)  På vissa system stöds inte denna funktion."

msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"Returnerar socketens egen adress.  Detta är till exempel användbart för att "
"ta reda på portnumret för ett IPv4/v6-uttag. (Formatet på den adress som "
"returneras beror på adressfamiljen --- se ovan)"

msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:ref:`SO_\\* etc. <socket-"
"unix-constants>`) are defined in this module.  If *buflen* is absent, an "
"integer option is assumed and its integer value is returned by the "
"function.  If *buflen* is present, it specifies the maximum length of the "
"buffer used to receive the option in, and this buffer is returned as a bytes "
"object.  It is up to the caller to decode the contents of the buffer (see "
"the optional built-in module :mod:`struct` for a way to decode C structures "
"encoded as byte strings)."
msgstr ""
"Returnerar värdet för det angivna socket-alternativet (se Unix man-sida :"
"manpage:`getsockopt(2)`).  De symboliska konstanter som behövs (:ref:`SO_\\* "
"etc. <socket-unix-constants>`) definieras i den här modulen.  Om *buflen* "
"saknas antas ett heltalsalternativ och dess heltalsvärde returneras av "
"funktionen.  Om *buflen* finns anger den den maximala längden på den buffert "
"som används för att ta emot alternativet, och denna buffert returneras som "
"ett bytesobjekt.  Det är upp till den som anropar att avkoda innehållet i "
"bufferten (se den valfria inbyggda modulen :mod:`struct` för ett sätt att "
"avkoda C-strukturer som kodats som bytesträngar)."

msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""
"Returnerar ``True`` om uttaget är i blockeringsläge, ``False`` om det är i "
"icke-blockeringsläge."

msgid "This is equivalent to checking ``socket.gettimeout() != 0``."
msgstr "Detta är likvärdigt med att kontrollera ``socket.gettimeout() != 0``."

msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"Returnerar timeout i sekunder (float) associerad med socket-operationer, "
"eller ``None`` om ingen timeout är inställd.  Detta återspeglar det senaste "
"anropet till :meth:`setblocking` eller :meth:`settimeout`."

msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
"Metoden :meth:`ioctl` är ett begränsat gränssnitt till systemgränssnittet "
"WSAIoctl.  Mer information finns i `Win32-dokumentationen <https://msdn."
"microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_."

msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"På andra plattformar kan de generiska funktionerna :func:`fcntl.fcntl` och :"
"func:`fcntl.ioctl` användas; de accepterar ett socket-objekt som sitt första "
"argument."

msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"För närvarande stöds endast följande kontrollkoder: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS`` och ``SIO_LOOPBACK_FAST_PATH``."

msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"Gör det möjligt för en server att acceptera anslutningar.  Om *backlog* "
"anges måste det vara minst 0 (om det är lägre sätts det till 0); det anger "
"antalet oaccepterade anslutningar som systemet tillåter innan nya "
"anslutningar nekas. Om det inte specificeras väljs ett rimligt standardvärde."

msgid "The *backlog* parameter is now optional."
msgstr "Parametern *backlog* är nu valfri."

msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'``, "
"``'b'``, or a combination of those."
msgstr ""
"Returnerar ett :term:`filobjekt` associerat med uttaget.  Den exakta typen "
"som returneras beror på de argument som ges till :meth:`makefile`.  Dessa "
"argument tolkas på samma sätt som av den inbyggda funktionen :func:`open`, "
"förutom att de enda *mode*-värden som stöds är ``'r'`` (standard), ``'w'``, "
"``'b'`` eller en kombination av dessa."

msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"Sockeln måste vara i blockeringsläge; den kan ha en timeout, men "
"filobjektets interna buffert kan hamna i ett inkonsekvent tillstånd om en "
"timeout inträffar."

msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
"Om du stänger filobjektet som returneras av :meth:`makefile` stängs inte den "
"ursprungliga sockeln om inte alla andra filobjekt har stängts och :meth:"
"`socket.close` har anropats på socketobjektet."

msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"I Windows kan det filliknande objekt som skapas av :meth:`makefile` inte "
"användas där ett filobjekt med en filbeskrivare förväntas, t.ex. "
"strömargumenten i :meth:`subprocess.Popen`."

msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*. A returned empty bytes object indicates "
"that the client has disconnected. See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"Ta emot data från uttaget.  Returvärdet är ett bytes-objekt som "
"representerar den mottagna datan.  Den maximala mängden data som kan tas "
"emot på en gång anges av *bufsize*. Ett returnerat tomt bytes-objekt "
"indikerar att klienten har kopplat från. Se Unix-manualsidan :manpage:"
"`recv(2)` för betydelsen av det valfria argumentet *flags*; det är noll som "
"standard."

msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Tar emot data från uttaget.  Returvärdet är ett par ``(bytes, address)`` där "
"*bytes* är ett bytesobjekt som representerar de mottagna data och *address* "
"är adressen till det uttag som skickar data.  Se Unix-manualsidan :manpage:"
"`recv(2)` för betydelsen av det valfria argumentet *flags*; det är noll som "
"standard. (Formatet på *address* beror på adressfamiljen --- se ovan)"

msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""
"För IPv6-adresser för multicast innehåller den första posten i *address* "
"inte längre delen ``%scope_id``. För att få en fullständig IPv6-adress, "
"använd :func:`getnameinfo`."

msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"Tar emot normal data (upp till *bufsize* bytes) och tilläggsdata från "
"sockeln.  Argumentet *ancbufsize* anger storleken i byte på den interna "
"buffert som används för att ta emot tilläggsdata; standardvärdet är 0, "
"vilket innebär att inga tilläggsdata tas emot.  Lämpliga buffertstorlekar "
"för tilläggsdata kan beräknas med hjälp av :func:`CMSG_SPACE` eller :func:"
"`CMSG_LEN`, och objekt som inte ryms i bufferten kan avkortas eller "
"kasseras.  Argumentet *flags* är 0 som standard och har samma betydelse som "
"för :meth:`recv`."

msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"Returvärdet är en 4-tupel: ``(data, ancdata, msg_flags, address)``.  "
"Objektet *data* är ett :class:`bytes`-objekt som innehåller de icke-"
"ancillära data som mottagits.  Objektet *ancdata* är en lista med noll eller "
"flera tupler ``(cmsg_level, cmsg_type, cmsg_data)`` som representerar de "
"mottagna tilläggsdata (kontrollmeddelanden): *cmsg_level* och *cmsg_type* är "
"heltal som anger protokollnivån respektive den protokollspecifika typen, och "
"*cmsg_data* är ett :class:`bytes`-objekt som innehåller tillhörande data.  "
"Objektet *msg_flags* är det bitvisa ELLER av olika flaggor som anger villkor "
"för det mottagna meddelandet; se systemdokumentationen för mer information. "
"Om det mottagande uttaget inte är anslutet är *address* adressen till det "
"sändande uttaget, om sådan finns; annars är dess värde ospecificerat."

msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""
"På vissa system kan :meth:`sendmsg` och :meth:`recvmsg` användas för att "
"skicka filbeskrivare mellan processer över en :const:`AF_UNIX`-socket.  När "
"denna funktion används (den är ofta begränsad till :const:`SOCK_STREAM`-"
"socklar), kommer :meth:`recvmsg` att returnera, i sina tilläggsdata, objekt "
"av formen ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, där *fds* är ett :"
"class:`bytes`-objekt som representerar de nya filbeskrivarna som en binär "
"array av den ursprungliga C-typen :c:expr:`int`.  Om :meth:`recvmsg` ger "
"upphov till ett undantag efter att systemanropet har returnerats, kommer det "
"först att försöka stänga alla filbeskrivare som har tagits emot via denna "
"mekanism."

msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"Vissa system anger inte den avkortade längden på tilläggsdata som bara "
"delvis har tagits emot.  Om ett objekt verkar sträcka sig längre än slutet "
"av bufferten, kommer :meth:`recvmsg` att utfärda en :exc:`RuntimeWarning`, "
"och kommer att returnera den del av det som finns i bufferten förutsatt att "
"det inte har avkortats före början av dess tillhörande data."

msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
"På system som stöder :const:`SCM_RIGHTS`-mekanismen tar följande funktion "
"emot upp till *maxfds* filbeskrivare och returnerar meddelandedata och en "
"lista som innehåller beskrivarna (samtidigt som oväntade förhållanden "
"ignoreras, t.ex. att orelaterade kontrollmeddelanden tas emot).  Se även :"
"meth:`sendmsg`. ::"

msgid ""
"import socket, array\n"
"\n"
"def recv_fds(sock, msglen, maxfds):\n"
"    fds = array.array(\"i\")   # Array of ints\n"
"    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds "
"* fds.itemsize))\n"
"    for cmsg_level, cmsg_type, cmsg_data in ancdata:\n"
"        if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket."
"SCM_RIGHTS:\n"
"            # Append data, ignoring any truncated integers at the end.\n"
"            fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds."
"itemsize)])\n"
"    return msg, list(fds)"
msgstr ""
"import socket, array\n"
"\n"
"def recv_fds(sock, msglen, maxfds):\n"
"    fds = array.array(\"i\")   # Array of ints\n"
"    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds "
"* fds.itemsize))\n"
"    for cmsg_level, cmsg_type, cmsg_data in ancdata:\n"
"        if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket."
"SCM_RIGHTS:\n"
"            # Append data, ignoring any truncated integers at the end.\n"
"            fds.frombytes(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds."
"itemsize)])\n"
"    return msg, list(fds)"

msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"Tar emot normala data och tilläggsdata från sockeln och beter sig som :meth:"
"`recvmsg` skulle göra, men sprider ut de data som inte tillhörancillary i en "
"serie buffertar istället för att returnera ett nytt bytes-objekt.  "
"Argumentet *buffers* måste vara en iterabel av objekt som exporterar "
"skrivbara buffertar (t.ex. :class:`bytearray`-objekt); dessa kommer att "
"fyllas med successiva bitar av de icke-ancillära data tills allt har "
"skrivits eller det inte finns några fler buffertar.  Operativsystemet kan "
"sätta en gräns (:func:`~os.sysconf` värde ``SC_IOV_MAX``) på antalet "
"buffertar som kan användas.  Argumenten *ancbufsize* och *flags* har samma "
"betydelse som för :meth:`recvmsg`."

msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"Returvärdet är en 4-tupel: ``(nbytes, ancdata, msg_flags, address)``, där "
"*nbytes* är det totala antalet byte av icke-ancillär data som skrivs in i "
"buffertarna, och *ancdata*, *msg_flags* och *address* är desamma som för :"
"meth:`recvmsg`."

msgid "Example::"
msgstr "Exempel::"

msgid ""
">>> import socket\n"
">>> s1, s2 = socket.socketpair()\n"
">>> b1 = bytearray(b'----')\n"
">>> b2 = bytearray(b'0123456789')\n"
">>> b3 = bytearray(b'--------------')\n"
">>> s1.send(b'Mary had a little lamb')\n"
"22\n"
">>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])\n"
"(22, [], 0, None)\n"
">>> [b1, b2, b3]\n"
"[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]"
msgstr ""
">>> import socket\n"
">>> s1, s2 = socket.socketpair()\n"
">>> b1 = bytearray(b'----')\n"
">>> b2 = bytearray(b'0123456789')\n"
">>> b3 = bytearray(b'--------------')\n"
">>> s1.send(b'Mary had a little lamb')\n"
"22\n"
">>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])\n"
"(22, [], 0, None)\n"
">>> [b1, b2, b3]\n"
"[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]"

msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Tar emot data från sockeln och skriver in dem i *buffer* istället för att "
"skapa en ny bytestring.  Returvärdet är ett par ``(nbytes, address)`` där "
"*nbytes* är antalet mottagna byte och *address* är adressen till den socket "
"som skickar data.  Se Unix-manualsidan :manpage:`recv(2)` för betydelsen av "
"det valfria argumentet *flags*; det är noll som standard.  (Formatet på "
"*address* beror på adressfamiljen --- se ovan)"

msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"Tar emot upp till *nbytes* byte från sockeln och lagrar data i en buffert i "
"stället för att skapa en ny bytestring.  Om *nbytes* inte anges (eller 0), "
"tas upp till den storlek som finns tillgänglig i den angivna bufferten.  "
"Returnerar antalet mottagna byte.  Se Unix-manualsidan :manpage:`recv(2)` "
"för betydelsen av det valfria argumentet *flags*; det är noll som standard."

msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"Skicka data till uttaget.  Uttaget måste vara anslutet till ett fjärruttag.  "
"Det valfria argumentet *flags* har samma betydelse som för :meth:`recv` "
"ovan. Returnerar antalet bytes som skickats. Applikationer är ansvariga för "
"att kontrollera att alla data har skickats; om endast en del av data har "
"skickats måste applikationen försöka leverera resterande data. För "
"ytterligare information om detta ämne, se :ref:`socket-howto`."

msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"Skicka data till uttaget.  Uttaget måste vara anslutet till ett fjärruttag.  "
"Det valfria argumentet *flags* har samma betydelse som för :meth:`recv` "
"ovan. Till skillnad från :meth:`send` fortsätter den här metoden att skicka "
"data från *bytes* tills antingen all data har skickats eller ett fel "
"inträffar.  ``None`` returneras vid framgång.  Vid fel uppstår ett undantag "
"och det finns inget sätt att avgöra hur mycket data, om någon, som skickades "
"framgångsrikt."

msgid ""
"The socket timeout is no longer reset each time data is sent successfully. "
"The socket timeout is now the maximum total duration to send all data."
msgstr ""
"Socket timeout återställs inte längre varje gång data har skickats "
"framgångsrikt. Socket timeout är nu den maximala totala tiden det tar att "
"skicka all data."

msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Skicka data till uttaget.  Sockeln ska inte vara ansluten till en "
"fjärrsocket, eftersom destinationssockeln anges av *address*.  Det valfria "
"argumentet *flags* har samma betydelse som för :meth:`recv` ovan.  "
"Returnerar antalet bytes som skickats. (Formatet på *address* beror på "
"adressfamiljen --- se ovan)"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.sendto`` med argumenten "
"``self``, ``address``."

msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"Skicka normala data och tilläggsdata till sockeln genom att samla in icke-"
"anknutna data från en serie buffertar och sammanfoga dem till ett enda "
"meddelande.  Argumentet *buffers* anger de icke-anknutna data som en "
"iterabel av :term:`bytesliknande objekt <bytes-like object>` (t.ex. :class:"
"`bytes`-objekt); operativsystemet kan sätta en gräns (:func:`~os.sysconf`-"
"värdet ``SC_IOV_MAX``) för antalet buffertar som kan användas.  Argumentet "
"*ancdata* anger tilläggsdata (kontrollmeddelanden) som en iterabel med noll "
"eller flera tupler ``(cmsg_level, cmsg_type, cmsg_data)``, där *cmsg_level* "
"och *cmsg_type* är heltal som anger protokollnivån respektive den "
"protokollspecifika typen, och *cmsg_data* är ett bytesliknande objekt som "
"innehåller tillhörande data.  Observera att vissa system (i synnerhet system "
"utan :func:`CMSG_SPACE`) kan stödja sändning av endast ett "
"kontrollmeddelande per anrop.  Argumentet *flags* är 0 som standard och har "
"samma betydelse som för :meth:`send`.  Om *address* anges och inte ``None``, "
"anges en destinationsadress för meddelandet.  Returvärdet är antalet bytes "
"av icke-ancillär data som skickats."

msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"Följande funktion skickar listan över filbeskrivare *fds* över en :const:"
"`AF_UNIX`-socket, på system som stöder :const:`SCM_RIGHTS`-mekanismen.  Se "
"även :meth:`recvmsg`. ::"

msgid ""
"import socket, array\n"
"\n"
"def send_fds(sock, msg, fds):\n"
"    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array."
"array(\"i\", fds))])"
msgstr ""
"import socket, array\n"
"\n"
"def send_fds(sock, msg, fds):\n"
"    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array."
"array(\"i\", fds))])"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``socket.sendmsg`` med "
"argumenten ``self``, ``address``."

msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
"Specialiserad version av :meth:`~socket.sendmsg` för :const:`AF_ALG` socket. "
"Ställ in läge, IV, AEAD-associerad datalängd och flaggor för :const:`AF_ALG`-"
"uttag."

msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"Skicka en fil tills EOF nås med hjälp av högpresterande :mod:`os.sendfile` "
"och returnera det totala antalet bytes som skickades. *file* måste vara ett "
"vanligt filobjekt som öppnas i binärt läge. Om :mod:`os.sendfile` inte är "
"tillgänglig (t.ex. Windows) eller om *fil* inte är en vanlig fil används "
"istället :meth:`send`. *offset* anger varifrån filen ska börja läsas. Om det "
"anges är *count* det totala antalet byte som ska överföras i stället för att "
"skicka filen tills EOF nås. Filens position uppdateras vid retur eller också "
"vid fel, i vilket fall :meth:`file.tell() <io.IOBase.tell>` kan användas för "
"att räkna ut antalet bytes som skickades. Uttaget måste vara av typen :const:"
"`SOCK_STREAM`. Icke-blockerande socklar stöds inte."

msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"Ställ in :ref:`ärvbarhetsflaggan <fd_inheritance>` för socketens "
"filbeskrivare eller socketens handtag."

msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"Ställ in blockerande eller icke-blockerande läge för uttaget: om *flag* är "
"false ställs uttaget in på icke-blockerande, annars på blockerande läge."

msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr "Denna metod är en kortform för vissa :meth:`~socket.settimeout`-anrop:"

msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr ""
"```sock.setblocking(True)`` är likvärdigt med ```sock.settimeout(None)``"

msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr ""
"```sock.setblocking(False)`` är likvärdigt med ```sock.settimeout(0.0)``"

msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Metoden tillämpar inte längre :const:`SOCK_NONBLOCK`-flaggan på :attr:"
"`socket.type`."

msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating-point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"Ställer in en timeout för blockering av socket-operationer.  Argumentet "
"*value* kan vara ett icke-negativt flyttal som uttrycker sekunder, eller "
"``None``. Om ett värde som inte är noll anges kommer efterföljande socket-"
"operationer att ge upphov till ett :exc:`timeout`-undantag om timeout-"
"perioden *value* har löpt ut innan operationen har slutförts.  Om noll anges "
"sätts uttaget i icke-blockerande läge. Om ``None`` anges sätts uttaget i "
"blockeringsläge."

msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr ""
"För mer information, se :ref:`notes on socket timeouts <socket-timeouts>`."

msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Metoden växlar inte längre :const:`SOCK_NONBLOCK`-flaggan på :attr:`socket."
"type`."

msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in this module "
"(:ref:`!SO_\\* etc. <socket-unix-constants>`).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"Ställ in värdet för det angivna socket-alternativet (se Unix-manualsidan :"
"manpage:`setsockopt(2)`).  De symboliska konstanter som behövs definieras i "
"den här modulen (:ref:`!SO_\\* etc. <socket-unix-constants>`).  Värdet kan "
"vara ett heltal, ``None`` eller ett :term:`bytesliknande objekt` som "
"representerar en buffert. I det senare fallet är det upp till den som "
"anropar att se till att bytestringen innehåller rätt bitar (se den valfria "
"inbyggda modulen :mod:`struct` för ett sätt att koda C-strukturer som "
"bytestringar). När *value* är satt till ``None`` krävs argumentet *optlen*. "
"Det är likvärdigt med att anropa C-funktionen :c:func:`setsockopt` med "
"``optval=NULL`` och ``optlen=optlen``."

msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr ""
"setsockopt(level, optname, None, optlen: int) formuläret har lagts till."

msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"Stänger av en eller båda halvorna av anslutningen.  Om *how* är :const:"
"`SHUT_RD`, tillåts inte ytterligare mottagningar.  Om *how* är :const:"
"`SHUT_WR`, är ytterligare sändningar inte tillåtna.  Om *how* är :const:"
"`SHUT_RDWR`, är ytterligare sändningar och mottagningar inte tillåtna."

msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"Duplicera ett uttag och förbered det för delning med en målprocess.  "
"Målprocessen måste förses med *process_id*.  Det resulterande bytesobjektet "
"kan sedan skickas till målprocessen med hjälp av någon form av "
"interprocesskommunikation och sockeln kan återskapas där med :func:"
"`fromshare`. När den här metoden har anropats är det säkert att stänga "
"sockeln eftersom operativsystemet redan har duplicerat den för målprocessen."

msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
"Observera att det inte finns några metoder :meth:`read` eller :meth:`write`; "
"använd istället :meth:`~socket.recv` och :meth:`~socket.send` utan *flags*-"
"argument."

msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
"Socket-objekt har också dessa (skrivskyddade) attribut som motsvarar de "
"värden som ges till :class:`~socket.socket`-konstruktören."

msgid "The socket family."
msgstr "Socket-familjen."

msgid "The socket type."
msgstr "Typ av socket."

msgid "The socket protocol."
msgstr "Socketprotokollet."

msgid "Notes on socket timeouts"
msgstr "Anmärkningar om timeout för socket"

msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"Ett socket-objekt kan vara i ett av tre lägen: blockerande, icke-blockerande "
"eller timeout.  Sockets skapas som standard alltid i blockeringsläge, men "
"detta kan ändras genom att anropa :func:`setdefaulttimeout`."

msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr ""
"I *blockeringsläge* blockeras operationer tills de är slutförda eller tills "
"systemet returnerar ett fel (t.ex. att anslutningen har tidsavgränsats)."

msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` module can be used to know when and whether a socket is "
"available for reading or writing."
msgstr ""
"I *non-blocking mode* misslyckas operationer (med ett fel som tyvärr är "
"systemberoende) om de inte kan slutföras omedelbart: funktioner från "
"modulen :mod:`select` kan användas för att veta när och om en socket är "
"tillgänglig för läsning eller skrivning."

msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"I *timeout-läge* misslyckas operationer om de inte kan slutföras inom den "
"timeout som anges för uttaget (de ger upphov till ett :exc:`timeout`-"
"undantag) eller om systemet returnerar ett fel."

msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno` of a socket."
msgstr ""
"På operativsystemsnivå är sockets i *timeout-läge* internt inställda på icke-"
"blockerande läge.  Dessutom delas blockerings- och timeout-lägena mellan "
"filbeskrivare och socket-objekt som refererar till samma nätverksändpunkt. "
"Denna implementationsdetalj kan få synliga konsekvenser om du t.ex. "
"bestämmer dig för att använda :meth:`~socket.fileno` för ett uttag."

msgid "Timeouts and the ``connect`` method"
msgstr "Timeout och metoden \"Connect"

msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
"Operationen :meth:`~socket.connect` är också föremål för timeout-"
"inställningen, och i allmänhet rekommenderas att anropa :meth:`~socket."
"settimeout` innan anrop av :meth:`~socket.connect` eller skicka en timeout-"
"parameter till :meth:`create_connection`.  Systemets nätverksstack kan dock "
"också returnera ett eget timeout-fel för anslutningen oavsett Python-"
"socketens timeout-inställning."

msgid "Timeouts and the ``accept`` method"
msgstr "Tidsgränser och ``accept``-metoden"

msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
"Om :func:`getdefaulttimeout` inte är :const:`None`, ärver de uttag som "
"returneras av metoden :meth:`~socket.accept` denna timeout.  Annars beror "
"beteendet på inställningarna för det lyssnande uttaget:"

msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"om det lyssnande uttaget är i *blockeringsläge* eller i *timeout-läge*, är "
"uttaget som returneras av :meth:`~socket.accept` i *blockeringsläge*;"

msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"om det lyssnande uttaget är i *icke-blockerande läge*, om det uttag som "
"returneras av :meth:`~socket.accept` är i blockerande eller icke-blockerande "
"läge är beroende av operativsystemet.  Om du vill säkerställa ett "
"plattformsoberoende beteende rekommenderas att du manuellt åsidosätter den "
"här inställningen."

msgid "Example"
msgstr "Exempel"

msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:"
"`~socket.socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:"
"`~socket.accept` (possibly repeating the :meth:`~socket.accept` to service "
"more than one client), while a client only needs the sequence :func:`~socket."
"socket`, :meth:`~socket.connect`.  Also note that the server does not :meth:"
"`~socket.sendall`/:meth:`~socket.recv` on the socket it is listening on but "
"on the new socket returned by :meth:`~socket.accept`."
msgstr ""
"Här följer fyra minimala exempel på program som använder TCP/IP-protokollet: "
"en server som ekar alla data som den får tillbaka (och som bara betjänar en "
"klient) och en klient som använder det.  Observera att en server måste "
"utföra sekvensen :func:`~socket.socket`, :meth:`~socket.bind`, :meth:"
"`~socket.listen`, :meth:`~socket.accept` (eventuellt upprepa :meth:`~socket."
"accept` för att betjäna mer än en klient), medan en klient bara behöver "
"sekvensen :func:`~socket.socket`, :meth:`~socket.connect`.  Observera också "
"att servern inte gör :meth:`~socket.sendall`/:meth:`~socket.recv` på den "
"socket den lyssnar på utan på den nya socket som returneras av :meth:"
"`~socket.accept`."

msgid "The first two examples support IPv4 only. ::"
msgstr "De två första exemplen stöder endast IPv4. ::"

msgid ""
"# Echo server program\n"
"import socket\n"
"\n"
"HOST = ''                 # Symbolic name meaning all available interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.bind((HOST, PORT))\n"
"    s.listen(1)\n"
"    conn, addr = s.accept()\n"
"    with conn:\n"
"        print('Connected by', addr)\n"
"        while True:\n"
"            data = conn.recv(1024)\n"
"            if not data: break\n"
"            conn.sendall(data)"
msgstr ""
"# Echo server program\n"
"import socket\n"
"\n"
"HOST = ''                 # Symbolic name meaning all available interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.bind((HOST, PORT))\n"
"    s.listen(1)\n"
"    conn, addr = s.accept()\n"
"    with conn:\n"
"        print('Connected by', addr)\n"
"        while True:\n"
"            data = conn.recv(1024)\n"
"            if not data: break\n"
"            conn.sendall(data)"

msgid ""
"# Echo client program\n"
"import socket\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.connect((HOST, PORT))\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"
msgstr ""
"# Echo client program\n"
"import socket\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n"
"    s.connect((HOST, PORT))\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"

msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to all the addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"De två följande exemplen är identiska med de två föregående, men stöder både "
"IPv4 och IPv6. Serversidan lyssnar på den första tillgängliga adressfamiljen "
"(den borde lyssna på båda i stället). På de flesta IPv6-klara system kommer "
"IPv6 att ha företräde och servern kanske inte accepterar IPv4-trafik. "
"Klientsidan försöker ansluta till alla de adresser som returneras som ett "
"resultat av namnupplösningen och skickar trafik till den första som ansluts "
"framgångsrikt:"

msgid ""
"# Echo server program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = None               # Symbolic name meaning all available interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,\n"
"                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.bind(sa)\n"
"        s.listen(1)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"conn, addr = s.accept()\n"
"with conn:\n"
"    print('Connected by', addr)\n"
"    while True:\n"
"        data = conn.recv(1024)\n"
"        if not data: break\n"
"        conn.send(data)"
msgstr ""
"# Echo server program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = None               # Symbolic name meaning all available interfaces\n"
"PORT = 50007              # Arbitrary non-privileged port\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,\n"
"                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.bind(sa)\n"
"        s.listen(1)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"conn, addr = s.accept()\n"
"with conn:\n"
"    print('Connected by', addr)\n"
"    while True:\n"
"        data = conn.recv(1024)\n"
"        if not data: break\n"
"        conn.send(data)"

msgid ""
"# Echo client program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket."
"SOCK_STREAM):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.connect(sa)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"with s:\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"
msgstr ""
"# Echo client program\n"
"import socket\n"
"import sys\n"
"\n"
"HOST = 'daring.cwi.nl'    # The remote host\n"
"PORT = 50007              # The same port as used by the server\n"
"s = None\n"
"for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket."
"SOCK_STREAM):\n"
"    af, socktype, proto, canonname, sa = res\n"
"    try:\n"
"        s = socket.socket(af, socktype, proto)\n"
"    except OSError as msg:\n"
"        s = None\n"
"        continue\n"
"    try:\n"
"        s.connect(sa)\n"
"    except OSError as msg:\n"
"        s.close()\n"
"        s = None\n"
"        continue\n"
"    break\n"
"if s is None:\n"
"    print('could not open socket')\n"
"    sys.exit(1)\n"
"with s:\n"
"    s.sendall(b'Hello, world')\n"
"    data = s.recv(1024)\n"
"print('Received', repr(data))"

msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"Nästa exempel visar hur man skriver en mycket enkel nätverkssniffer med raw "
"sockets i Windows. Exemplet kräver administratörsbehörighet för att ändra "
"gränssnittet::"

msgid ""
"import socket\n"
"\n"
"# the public network interface\n"
"HOST = socket.gethostbyname(socket.gethostname())\n"
"\n"
"# create a raw socket and bind it to the public interface\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)\n"
"s.bind((HOST, 0))\n"
"\n"
"# Include IP headers\n"
"s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n"
"\n"
"# receive all packets\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)\n"
"\n"
"# receive a packet\n"
"print(s.recvfrom(65565))\n"
"\n"
"# disabled promiscuous mode\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)"
msgstr ""
"import socket\n"
"\n"
"# the public network interface\n"
"HOST = socket.gethostbyname(socket.gethostname())\n"
"\n"
"# create a raw socket and bind it to the public interface\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)\n"
"s.bind((HOST, 0))\n"
"\n"
"# Include IP headers\n"
"s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n"
"\n"
"# receive all packets\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)\n"
"\n"
"# receive a packet\n"
"print(s.recvfrom(65565))\n"
"\n"
"# disabled promiscuous mode\n"
"s.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)"

msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"I nästa exempel visas hur du använder socket-gränssnittet för att "
"kommunicera med ett CAN-nätverk med hjälp av raw socket-protokollet. Om du "
"istället vill använda CAN med broadcast manager-protokollet öppnar du en "
"socket med::"

msgid "socket.socket(socket.AF_CAN, socket.SOCK_DGRAM, socket.CAN_BCM)"
msgstr "socket.socket(socket.AF_CAN, socket.SOCK_DGRAM, socket.CAN_BCM)"

msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send` and :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"När du har bundit (:const:`CAN_RAW`) eller anslutit (:const:`CAN_BCM`) "
"sockeln kan du använda operationerna :meth:`socket.send` och :meth:`socket."
"recv` (och deras motsvarigheter) på socketobjektet som vanligt."

msgid "This last example might require special privileges::"
msgstr "Detta sista exempel kan kräva särskilda privilegier::"

msgid ""
"import socket\n"
"import struct\n"
"\n"
"\n"
"# CAN frame packing/unpacking (see 'struct can_frame' in <linux/can.h>)\n"
"\n"
"can_frame_fmt = \"=IB3x8s\"\n"
"can_frame_size = struct.calcsize(can_frame_fmt)\n"
"\n"
"def build_can_frame(can_id, data):\n"
"    can_dlc = len(data)\n"
"    data = data.ljust(8, b'\\x00')\n"
"    return struct.pack(can_frame_fmt, can_id, can_dlc, data)\n"
"\n"
"def dissect_can_frame(frame):\n"
"    can_id, can_dlc, data = struct.unpack(can_frame_fmt, frame)\n"
"    return (can_id, can_dlc, data[:can_dlc])\n"
"\n"
"\n"
"# create a raw socket and bind it to the 'vcan0' interface\n"
"s = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\n"
"s.bind(('vcan0',))\n"
"\n"
"while True:\n"
"    cf, addr = s.recvfrom(can_frame_size)\n"
"\n"
"    print('Received: can_id=%x, can_dlc=%x, data=%s' % "
"dissect_can_frame(cf))\n"
"\n"
"    try:\n"
"        s.send(cf)\n"
"    except OSError:\n"
"        print('Error sending CAN frame')\n"
"\n"
"    try:\n"
"        s.send(build_can_frame(0x01, b'\\x01\\x02\\x03'))\n"
"    except OSError:\n"
"        print('Error sending CAN frame')"
msgstr ""
"import socket\n"
"import struct\n"
"\n"
"\n"
"# CAN frame packing/unpacking (see 'struct can_frame' in <linux/can.h>)\n"
"\n"
"can_frame_fmt = \"=IB3x8s\"\n"
"can_frame_size = struct.calcsize(can_frame_fmt)\n"
"\n"
"def build_can_frame(can_id, data):\n"
"    can_dlc = len(data)\n"
"    data = data.ljust(8, b'\\x00')\n"
"    return struct.pack(can_frame_fmt, can_id, can_dlc, data)\n"
"\n"
"def dissect_can_frame(frame):\n"
"    can_id, can_dlc, data = struct.unpack(can_frame_fmt, frame)\n"
"    return (can_id, can_dlc, data[:can_dlc])\n"
"\n"
"\n"
"# create a raw socket and bind it to the 'vcan0' interface\n"
"s = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\n"
"s.bind(('vcan0',))\n"
"\n"
"while True:\n"
"    cf, addr = s.recvfrom(can_frame_size)\n"
"\n"
"    print('Received: can_id=%x, can_dlc=%x, data=%s' % "
"dissect_can_frame(cf))\n"
"\n"
"    try:\n"
"        s.send(cf)\n"
"    except OSError:\n"
"        print('Error sending CAN frame')\n"
"\n"
"    try:\n"
"        s.send(build_can_frame(0x01, b'\\x01\\x02\\x03'))\n"
"    except OSError:\n"
"        print('Error sending CAN frame')"

msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr ""
"Om du kör ett exempel flera gånger med för kort fördröjning mellan "
"körningarna kan det leda till följande fel::"

msgid "OSError: [Errno 98] Address already in use"
msgstr "OSError: [Errno 98] Adressen är redan i bruk"

msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr ""
"Detta beror på att den tidigare exekveringen har lämnat uttaget i ett "
"``TIME_WAIT``-tillstånd och inte kan återanvändas omedelbart."

msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :const:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"Det finns en :mod:`socket` flagga att ställa in, för att förhindra detta, :"
"const:`socket.SO_REUSEADDR`::"

msgid ""
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n"
"s.bind((HOST, PORT))"
msgstr ""
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n"
"s.bind((HOST, PORT))"

msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
"flaggan :data:`SO_REUSEADDR` talar om för kärnan att återanvända en lokal "
"socket i ``TIME_WAIT``-tillstånd, utan att vänta på att dess naturliga "
"timeout ska löpa ut."

msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr ""
"För en introduktion till socketprogrammering (i C), se följande artiklar:"

msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*En inledande handledning i 4.3BSD Interprocess Communication*, av Stuart "
"Sechrest"

msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, av Samuel J. "
"Leffler et al,"

msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"både i UNIX Programmer's Manual, Supplementary Documents 1 (avsnitt PS1:7 "
"och PS1:8).  Det plattformsspecifika referensmaterialet för de olika socket-"
"relaterade systemanropen är också en värdefull källa till information om "
"detaljerna i socket-semantik.  För Unix hänvisas till manualsidorna; för "
"Windows hänvisas till WinSock (eller Winsock 2) specifikationen.  För IPv6-"
"klara API:er kan läsare vilja hänvisa till :rfc:`3493` med titeln Basic "
"Socket Interface Extensions for IPv6."

msgid "object"
msgstr "object"

msgid "socket"
msgstr "socket"

msgid "I/O control"
msgstr "I/O-kontroll"

msgid "buffering"
msgstr "buffring"

msgid "module"
msgstr "modul"

msgid "struct"
msgstr "struktur"
