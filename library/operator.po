# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!operator` --- Standard operators as functions"
msgstr ":mod:`!operator` --- Standardoperatorer som funktioner"

msgid "**Source code:** :source:`Lib/operator.py`"
msgstr "**Källkod:** :source:`Lib/operator.py`"

msgid ""
"The :mod:`operator` module exports a set of efficient functions "
"corresponding to the intrinsic operators of Python.  For example, ``operator."
"add(x, y)`` is equivalent to the expression ``x+y``. Many function names are "
"those used for special methods, without the double underscores.  For "
"backward compatibility, many of these have a variant with the double "
"underscores kept. The variants without the double underscores are preferred "
"for clarity."
msgstr ""
"Modulen :mod:`operator` exporterar en uppsättning effektiva funktioner som "
"motsvarar de inbyggda operatorerna i Python.  Till exempel är ``operator."
"add(x, y)`` likvärdig med uttrycket ``x+y``. Många funktionsnamn är de som "
"används för specialmetoder, utan de dubbla understrykningarna.  För "
"bakåtkompatibilitet har många av dessa en variant med de dubbla "
"understrykningarna. Varianterna utan de dubbla understrykningarna föredras "
"för tydlighetens skull."

msgid ""
"The functions fall into categories that perform object comparisons, logical "
"operations, mathematical operations and sequence operations."
msgstr ""
"Funktionerna är indelade i kategorier som utför objektjämförelser, logiska "
"operationer, matematiska operationer och sekvensoperationer."

msgid ""
"The object comparison functions are useful for all objects, and are named "
"after the rich comparison operators they support:"
msgstr ""
"Funktionerna för objektjämförelse är användbara för alla objekt och har fått "
"sina namn efter de jämförelseoperatorer som de stöder:"

msgid ""
"Perform \"rich comparisons\" between *a* and *b*. Specifically, ``lt(a, b)`` "
"is equivalent to ``a < b``, ``le(a, b)`` is equivalent to ``a <= b``, "
"``eq(a, b)`` is equivalent to ``a == b``, ``ne(a, b)`` is equivalent to ``a !"
"= b``, ``gt(a, b)`` is equivalent to ``a > b`` and ``ge(a, b)`` is "
"equivalent to ``a >= b``.  Note that these functions can return any value, "
"which may or may not be interpretable as a Boolean value.  See :ref:"
"`comparisons` for more information about rich comparisons."
msgstr ""
"Utför \"rika jämförelser\" mellan *a* och *b*. Specifikt är ``lt(a, b)`` "
"likvärdigt med ``a < b``, ``le(a, b)`` likvärdigt med ``a <= b``, ``eq(a, "
"b)`` likvärdigt med ``a == b``, ``ne(a, b)`` likvärdigt med ``a != b``, "
"``gt(a, b)`` likvärdigt med ``a > b`` och ``ge(a, b)`` likvärdigt med ``a >= "
"b``.  Observera att dessa funktioner kan returnera vilket värde som helst, "
"som kan eller inte kan tolkas som ett booleskt värde.  Se :ref:`comparisons` "
"för mer information om rika jämförelser."

msgid ""
"The logical operations are also generally applicable to all objects, and "
"support truth tests, identity tests, and boolean operations:"
msgstr ""
"De logiska operationerna är också allmänt tillämpliga på alla objekt och "
"stöder sanningstest, identitetstest och booleska operationer:"

msgid ""
"Return the outcome of :keyword:`not` *obj*.  (Note that there is no :meth:`!"
"__not__` method for object instances; only the interpreter core defines this "
"operation.  The result is affected by the :meth:`~object.__bool__` and :meth:"
"`~object.__len__` methods.)"
msgstr ""
"Returnerar resultatet av :keyword:`not` *obj*.  (Observera att det inte "
"finns någon :meth:`!__not__`-metod för objektinstanser; endast tolkens kärna "
"definierar denna operation.  Resultatet påverkas av metoderna :meth:`~object."
"__bool__` och :meth:`~object.__len__`)"

msgid ""
"Return :const:`True` if *obj* is true, and :const:`False` otherwise.  This "
"is equivalent to using the :class:`bool` constructor."
msgstr ""
"Returnerar :const:`True` om *obj* är sann, och :const:`False` annars.  Detta "
"är likvärdigt med att använda :class:`bool`-konstruktören."

msgid "Return ``a is b``.  Tests object identity."
msgstr "Returnerar ``a är b``.  Testar objektets identitet."

msgid "Return ``a is not b``.  Tests object identity."
msgstr "Returnerar ``a är inte b``.  Testar objektets identitet."

msgid "Return ``a is None``.  Tests object identity."
msgstr "Returnerar ``a är ingen``.  Testar objektets identitet."

msgid "Return ``a is not None``.  Tests object identity."
msgstr "Returnerar ``a är inte None``.  Testar objektets identitet."

msgid "The mathematical and bitwise operations are the most numerous:"
msgstr "De matematiska och bitvisa operationerna är de mest omfattande:"

msgid "Return the absolute value of *obj*."
msgstr "Returnerar det absoluta värdet av *obj*."

msgid "Return ``a + b``, for *a* and *b* numbers."
msgstr "Returnerar ``a + b``, för *a* och *b* tal."

msgid "Return the bitwise and of *a* and *b*."
msgstr "Returnerar det bitvisa och av *a* och *b*."

msgid "Return ``a // b``."
msgstr "Returnera ``a // b``."

msgid "Return *a* converted to an integer.  Equivalent to ``a.__index__()``."
msgstr ""
"Returnerar *a* omvandlad till ett heltal.  Motsvarar ``a.__index__()``."

msgid ""
"The result always has exact type :class:`int`.  Previously, the result could "
"have been an instance of a subclass of ``int``."
msgstr ""
"Resultatet har alltid den exakta typen :class:`int`.  Tidigare kunde "
"resultatet ha varit en instans av en underklass av ``int``."

msgid ""
"Return the bitwise inverse of the number *obj*.  This is equivalent to "
"``~obj``."
msgstr ""
"Returnerar den bitvisa inversen av talet *obj*.  Detta är likvärdigt med "
"``~obj``."

msgid "Return *a* shifted left by *b*."
msgstr "Returnera *a* vänsterförskjutet med *b*."

msgid "Return ``a % b``."
msgstr "Returnera ``a % b``."

msgid "Return ``a * b``, for *a* and *b* numbers."
msgstr "Returnera ``a * b``, för *a* och *b* tal."

msgid "Return ``a @ b``."
msgstr "Returnera ``a @ b``."

msgid "Return *obj* negated (``-obj``)."
msgstr "Returnerar *obj* negerad (``-obj``)."

msgid "Return the bitwise or of *a* and *b*."
msgstr "Returnerar det bitvisa eller av *a* och *b*."

msgid "Return *obj* positive (``+obj``)."
msgstr "Returnera *obj* positiv (``+obj``)."

msgid "Return ``a ** b``, for *a* and *b* numbers."
msgstr "Returnera ``a ** b``, för *a* och *b* tal."

msgid "Return *a* shifted right by *b*."
msgstr "Returnera *a* högerförskjutet med *b*."

msgid "Return ``a - b``."
msgstr "Returnera ``a - b``."

msgid ""
"Return ``a / b`` where 2/3 is .66 rather than 0.  This is also known as "
"\"true\" division."
msgstr ""
"Returnera ``a / b`` där 2/3 är 0,66 i stället för 0. Detta kallas också "
"\"sann\" division."

msgid "Return the bitwise exclusive or of *a* and *b*."
msgstr "Returnerar bitvis exklusivt eller av *a* och *b*."

msgid ""
"Operations which work with sequences (some of them with mappings too) "
"include:"
msgstr ""
"Operationer som arbetar med sekvenser (vissa av dem även med mappningar) är "
"t.ex:"

msgid "Return ``a + b`` for *a* and *b* sequences."
msgstr "Returnerar ``a + b`` för *a*- och *b*-sekvenser."

msgid "Return the outcome of the test ``b in a``. Note the reversed operands."
msgstr ""
"Returnerar resultatet av testet ``b i a``. Notera de omvända operanderna."

msgid "Return the number of occurrences of *b* in *a*."
msgstr "Returnera antalet förekomster av *b* i *a*."

msgid "Remove the value of *a* at index *b*."
msgstr "Ta bort värdet av *a* på index *b*."

msgid "Return the value of *a* at index *b*."
msgstr "Returnera värdet av *a* vid index *b*."

msgid "Return the index of the first of occurrence of *b* in *a*."
msgstr "Returnera index för den första förekomsten av *b* i *a*."

msgid "Set the value of *a* at index *b* to *c*."
msgstr "Ställ in värdet av *a* på index *b* till *c*."

msgid ""
"Return an estimated length for the object *obj*. First try to return its "
"actual length, then an estimate using :meth:`object.__length_hint__`, and "
"finally return the default value."
msgstr ""
"Returnerar en uppskattad längd för objektet *obj*. Försök först att "
"returnera dess faktiska längd, sedan en uppskattning med hjälp av :meth:"
"`object.__length_hint__`, och slutligen returnera standardvärdet."

msgid "The following operation works with callables:"
msgstr "Följande operation arbetar med avropbara varor:"

msgid "Return ``obj(*args, **kwargs)``."
msgstr "Returnera ``obj(*args, **kwargs)``."

msgid ""
"The :mod:`operator` module also defines tools for generalized attribute and "
"item lookups.  These are useful for making fast field extractors as "
"arguments for :func:`map`, :func:`sorted`, :meth:`itertools.groupby`, or "
"other functions that expect a function argument."
msgstr ""
"Modulen :mod:`operator` definierar också verktyg för generaliserade "
"attribut- och objektuppslagningar.  Dessa är användbara för att skapa snabba "
"fältextraktorer som argument för :func:`map`, :func:`sorted`, :meth:"
"`itertools.groupby` eller andra funktioner som förväntar sig ett "
"funktionsargument."

msgid ""
"Return a callable object that fetches *attr* from its operand. If more than "
"one attribute is requested, returns a tuple of attributes. The attribute "
"names can also contain dots. For example:"
msgstr ""
"Returnerar ett anropsbart objekt som hämtar *attr* från sin operand. Om mer "
"än ett attribut begärs, returneras en tupel av attribut. Attributnamnen kan "
"också innehålla prickar. Till exempel: *attr*:"

msgid "After ``f = attrgetter('name')``, the call ``f(b)`` returns ``b.name``."
msgstr ""
"Efter ``f = attrgetter('name')`` returnerar anropet ``f(b)`` ``b.name``."

msgid ""
"After ``f = attrgetter('name', 'date')``, the call ``f(b)`` returns ``(b."
"name, b.date)``."
msgstr ""
"Efter ``f = attrgetter('name', 'date')`` returnerar anropet ``f(b)`` ``(b."
"name, b.date)``."

msgid ""
"After ``f = attrgetter('name.first', 'name.last')``, the call ``f(b)`` "
"returns ``(b.name.first, b.name.last)``."
msgstr ""
"Efter ``f = attrgetter('name.first', 'name.last')`` returnerar anropet "
"``f(b)`` ``(b.name.first, b.name.last)``."

msgid "Equivalent to::"
msgstr "Motsvarar::"

msgid ""
"def attrgetter(*items):\n"
"    if any(not isinstance(item, str) for item in items):\n"
"        raise TypeError('attribute name must be a string')\n"
"    if len(items) == 1:\n"
"        attr = items[0]\n"
"        def g(obj):\n"
"            return resolve_attr(obj, attr)\n"
"    else:\n"
"        def g(obj):\n"
"            return tuple(resolve_attr(obj, attr) for attr in items)\n"
"    return g\n"
"\n"
"def resolve_attr(obj, attr):\n"
"    for name in attr.split(\".\"):\n"
"        obj = getattr(obj, name)\n"
"    return obj"
msgstr ""
"def attrgetter(*objekt):\n"
"    if any(not isinstance(item, str) for item in items):\n"
"        raise TypeError('attributnamnet måste vara en sträng')\n"
"    if len(items) == 1:\n"
"        attr = objekt[0]\n"
"        def g(obj):\n"
"            return resolve_attr(obj, attr)\n"
"    annat:\n"
"        def g(obj):\n"
"            return tuple(resolve_attr(obj, attr) for attr in items)\n"
"    returnerar g\n"
"\n"
"def resolve_attr(obj, attr):\n"
"    för namn i attr.split(\".\"):\n"
"        obj = getattr(obj, namn)\n"
"    returnera obj"

msgid ""
"Return a callable object that fetches *item* from its operand using the "
"operand's :meth:`~object.__getitem__` method.  If multiple items are "
"specified, returns a tuple of lookup values.  For example:"
msgstr ""
"Returnerar ett anropbart objekt som hämtar *item* från sin operand med hjälp "
"av operandens :meth:`~object.__getitem__`-metod.  Om flera objekt anges "
"returneras en tupel av uppslagsvärden.  Exempelvis"

msgid "After ``f = itemgetter(2)``, the call ``f(r)`` returns ``r[2]``."
msgstr "Efter ``f = itemgetter(2)`` returnerar anropet ``f(r)`` ``r[2]``."

msgid ""
"After ``g = itemgetter(2, 5, 3)``, the call ``g(r)`` returns ``(r[2], r[5], "
"r[3])``."
msgstr ""
"Efter ``g = itemgetter(2, 5, 3)`` returnerar anropet ``g(r)`` ``(r[2], r[5], "
"r[3])``."

msgid ""
"def itemgetter(*items):\n"
"    if len(items) == 1:\n"
"        item = items[0]\n"
"        def g(obj):\n"
"            return obj[item]\n"
"    else:\n"
"        def g(obj):\n"
"            return tuple(obj[item] for item in items)\n"
"    return g"
msgstr ""
"def itemgetter(*items):\n"
"    if len(objekt) == 1:\n"
"        objekt = objekt[0]\n"
"        def g(obj):\n"
"            returnera obj[objekt]\n"
"    else:\n"
"        def g(obj):\n"
"            return tuple(obj[item] för item i items)\n"
"    returnera g"

msgid ""
"The items can be any type accepted by the operand's :meth:`~object."
"__getitem__` method.  Dictionaries accept any :term:`hashable` value.  "
"Lists, tuples, and strings accept an index or a slice:"
msgstr ""
"Objekten kan vara av vilken typ som helst som accepteras av operandens :meth:"
"`~object.__getitem__`-metod.  Ordböcker accepterar alla :term:`hashable`-"
"värden.  Listor, tupler och strängar accepterar ett index eller en slice:"

msgid ""
"Example of using :func:`itemgetter` to retrieve specific fields from a tuple "
"record:"
msgstr ""
"Exempel på användning av :func:`itemgetter` för att hämta specifika fält "
"från en tuple-post:"

msgid ""
"Return a callable object that calls the method *name* on its operand.  If "
"additional arguments and/or keyword arguments are given, they will be given "
"to the method as well.  For example:"
msgstr ""
"Returnerar ett anropsbart objekt som anropar metoden *namn* på sin operand.  "
"Om ytterligare argument och/eller nyckelordsargument anges kommer de också "
"att ges till metoden.  Till exempel"

msgid ""
"After ``f = methodcaller('name')``, the call ``f(b)`` returns ``b.name()``."
msgstr ""
"Efter ``f = methodcaller('name')`` returnerar anropet ``f(b)`` ``b.name()``."

msgid ""
"After ``f = methodcaller('name', 'foo', bar=1)``, the call ``f(b)`` returns "
"``b.name('foo', bar=1)``."
msgstr ""
"Efter ``f = methodcaller('name', 'foo', bar=1)`` returnerar anropet ``f(b)`` "
"``b.name('foo', bar=1)``."

msgid ""
"def methodcaller(name, /, *args, **kwargs):\n"
"    def caller(obj):\n"
"        return getattr(obj, name)(*args, **kwargs)\n"
"    return caller"
msgstr ""
"def methodcaller(namn, /, *args, **kwargs):\n"
"    def caller(obj):\n"
"        return getattr(obj, namn)(*args, **kwargs)\n"
"    returnerar anropare"

msgid "Mapping Operators to Functions"
msgstr "Mappning av operatorer till funktioner"

msgid ""
"This table shows how abstract operations correspond to operator symbols in "
"the Python syntax and the functions in the :mod:`operator` module."
msgstr ""
"Denna tabell visar hur abstrakta operationer motsvarar operatorssymboler i "
"Pythons syntax och funktionerna i modulen :mod:`operator`."

msgid "Operation"
msgstr "Operation"

msgid "Syntax"
msgstr "Syntax"

msgid "Function"
msgstr "Funktion"

msgid "Addition"
msgstr "Addition"

msgid "``a + b``"
msgstr "``a + b```"

msgid "``add(a, b)``"
msgstr "``add(a, b)``"

msgid "Concatenation"
msgstr "Sammanfogning"

msgid "``seq1 + seq2``"
msgstr "``seq1 + seq2``"

msgid "``concat(seq1, seq2)``"
msgstr "``concat(seq1, seq2)``"

msgid "Containment Test"
msgstr "Test av inneslutning"

msgid "``obj in seq``"
msgstr "``obj i seq``"

msgid "``contains(seq, obj)``"
msgstr "``innehåller(seq, obj)``"

msgid "Division"
msgstr "Division"

msgid "``a / b``"
msgstr "``a / b``"

msgid "``truediv(a, b)``"
msgstr "``truediv(a, b)``"

msgid "``a // b``"
msgstr "``a // b```"

msgid "``floordiv(a, b)``"
msgstr "``floordiv(a, b)``"

msgid "Bitwise And"
msgstr "Bitvis och"

msgid "``a & b``"
msgstr "``a & b``"

msgid "``and_(a, b)``"
msgstr "``och_(a, b)``"

msgid "Bitwise Exclusive Or"
msgstr "Bitvis exklusivt eller"

msgid "``a ^ b``"
msgstr "``a ^ b``"

msgid "``xor(a, b)``"
msgstr "``xor(a, b)```"

msgid "Bitwise Inversion"
msgstr "Bitvis invertering"

msgid "``~ a``"
msgstr "``~ a``"

msgid "``invert(a)``"
msgstr "``invert(a)``"

msgid "Bitwise Or"
msgstr "Bitvis eller"

msgid "``a | b``"
msgstr "``a | b```"

msgid "``or_(a, b)``"
msgstr "``eller_(a, b)``"

msgid "Exponentiation"
msgstr "Potens"

msgid "``a ** b``"
msgstr "``a ** b```"

msgid "``pow(a, b)``"
msgstr "``pow(a, b)``"

msgid "Identity"
msgstr "Identitet"

msgid "``a is b``"
msgstr "\"A är B"

msgid "``is_(a, b)``"
msgstr "``är_(a, b)``"

msgid "``a is not b``"
msgstr "\"a är inte b"

msgid "``is_not(a, b)``"
msgstr "``är_inte(a, b)``"

msgid "``a is None``"
msgstr "``a är ingen``"

msgid "``is_none(a)``"
msgstr "``is_none(a)``"

msgid "``a is not None``"
msgstr "``a är inte None``"

msgid "``is_not_none(a)``"
msgstr "``is_not_none(a)``"

msgid "Indexed Assignment"
msgstr "Indexerat uppdrag"

msgid "``obj[k] = v``"
msgstr "``obj[k] = v``"

msgid "``setitem(obj, k, v)``"
msgstr "``setitem(obj, k, v)``"

msgid "Indexed Deletion"
msgstr "Indexerad radering"

msgid "``del obj[k]``"
msgstr "``del obj[k]``"

msgid "``delitem(obj, k)``"
msgstr "``delitem(obj, k)``"

msgid "Indexing"
msgstr "Indexering"

msgid "``obj[k]``"
msgstr "``obj[k]```"

msgid "``getitem(obj, k)``"
msgstr "``getitem(obj, k)``"

msgid "Left Shift"
msgstr "Vänster skift"

msgid "``a << b``"
msgstr "``a << b```"

msgid "``lshift(a, b)``"
msgstr "``lshift(a, b)``"

msgid "Modulo"
msgstr "Modulo"

msgid "``a % b``"
msgstr "``a % b```"

msgid "``mod(a, b)``"
msgstr "``mod(a, b)``"

msgid "Multiplication"
msgstr "Multiplikation"

msgid "``a * b``"
msgstr "``a * b```"

msgid "``mul(a, b)``"
msgstr "``mul(a, b)``"

msgid "Matrix Multiplication"
msgstr "Multiplikation av matriser"

msgid "``a @ b``"
msgstr "``a @ b``"

msgid "``matmul(a, b)``"
msgstr "``matmul(a, b)``"

msgid "Negation (Arithmetic)"
msgstr "Negation (aritmetik)"

msgid "``- a``"
msgstr "``- a``"

msgid "``neg(a)``"
msgstr "``neg(a)```"

msgid "Negation (Logical)"
msgstr "Negation (logisk)"

msgid "``not a``"
msgstr "``inte en``"

msgid "``not_(a)``"
msgstr "``inte_(a)```"

msgid "Positive"
msgstr "Positiv"

msgid "``+ a``"
msgstr "``+ a``"

msgid "``pos(a)``"
msgstr "``pos(a)```"

msgid "Right Shift"
msgstr "Höger skift"

msgid "``a >> b``"
msgstr "``a >> b```"

msgid "``rshift(a, b)``"
msgstr "``rshift(a, b)``"

msgid "Slice Assignment"
msgstr "Uppgift om skiva"

msgid "``seq[i:j] = values``"
msgstr "``seq[i:j] = värden``"

msgid "``setitem(seq, slice(i, j), values)``"
msgstr "``setitem(seq, slice(i, j), värden)``"

msgid "Slice Deletion"
msgstr "Borttagning av skivor"

msgid "``del seq[i:j]``"
msgstr "``del seq[i:j]``"

msgid "``delitem(seq, slice(i, j))``"
msgstr "``delitem(seq, slice(i, j))``"

msgid "Slicing"
msgstr "Skivning"

msgid "``seq[i:j]``"
msgstr "``seq[i:j]``"

msgid "``getitem(seq, slice(i, j))``"
msgstr "``getitem(seq, slice(i, j))``"

msgid "String Formatting"
msgstr "Strängformatering"

msgid "``s % obj``"
msgstr "``s % obj``"

msgid "``mod(s, obj)``"
msgstr "``mod(s, obj)``"

msgid "Subtraction"
msgstr "Subtraktion"

msgid "``a - b``"
msgstr "``a - b``"

msgid "``sub(a, b)``"
msgstr "``sub(a, b)``"

msgid "Truth Test"
msgstr "Sanningstest"

msgid "``obj``"
msgstr "``obj``"

msgid "``truth(obj)``"
msgstr "``Sanning(obj)``"

msgid "Ordering"
msgstr "Ordning"

msgid "``a < b``"
msgstr "``a < b```"

msgid "``lt(a, b)``"
msgstr "``lt(a, b)``"

msgid "``a <= b``"
msgstr "``a <= b```"

msgid "``le(a, b)``"
msgstr "``le(a, b)``"

msgid "Equality"
msgstr "Jämlikhet"

msgid "``a == b``"
msgstr "``a == b```"

msgid "``eq(a, b)``"
msgstr "``eq(a, b)``"

msgid "Difference"
msgstr "Skillnad"

msgid "``a != b``"
msgstr "``a != b``"

msgid "``ne(a, b)``"
msgstr "``ne(a, b)``"

msgid "``a >= b``"
msgstr "``a >= b```"

msgid "``ge(a, b)``"
msgstr "``ge(a, b)```"

msgid "``a > b``"
msgstr "``a > b``"

msgid "``gt(a, b)``"
msgstr "``gt(a, b)``"

msgid "In-place Operators"
msgstr "Operatorer på plats"

msgid ""
"Many operations have an \"in-place\" version.  Listed below are functions "
"providing a more primitive access to in-place operators than the usual "
"syntax does; for example, the :term:`statement` ``x += y`` is equivalent to "
"``x = operator.iadd(x, y)``.  Another way to put it is to say that ``z = "
"operator.iadd(x, y)`` is equivalent to the compound statement ``z = x; z += "
"y``."
msgstr ""
"Många operationer har en \"in-place\"-version.  Nedan listas funktioner som "
"ger en mer primitiv tillgång till in-place-operatorer än vad den vanliga "
"syntaxen gör; till exempel är :term:`-satsen` ``x += y`` ekvivalent med ``x "
"= operator.iadd(x, y)``.  Ett annat sätt att uttrycka det är att säga att "
"``z = operator.iadd(x, y)`` är ekvivalent med det sammansatta påståendet ``z "
"= x; z += y``."

msgid ""
"In those examples, note that when an in-place method is called, the "
"computation and assignment are performed in two separate steps.  The in-"
"place functions listed below only do the first step, calling the in-place "
"method.  The second step, assignment, is not handled."
msgstr ""
"Observera i dessa exempel att när en in-place-metod anropas utförs "
"beräkningen och tilldelningen i två separata steg.  De in-place-funktioner "
"som listas nedan gör bara det första steget, anrop av in-place-metoden.  Det "
"andra steget, tilldelning, hanteras inte."

msgid ""
"For immutable targets such as strings, numbers, and tuples, the updated "
"value is computed, but not assigned back to the input variable:"
msgstr ""
"För oföränderliga mål som strängar, tal och tupler beräknas det uppdaterade "
"värdet, men tilldelas inte tillbaka till inmatningsvariabeln:"

msgid ""
"For mutable targets such as lists and dictionaries, the in-place method will "
"perform the update, so no subsequent assignment is necessary:"
msgstr ""
"För föränderliga mål som listor och lexikon kommer in-place-metoden att "
"utföra uppdateringen, så ingen efterföljande tilldelning är nödvändig:"

msgid "``a = iadd(a, b)`` is equivalent to ``a += b``."
msgstr "``a = iadd(a, b)`` är likvärdigt med ``a += b``."

msgid "``a = iand(a, b)`` is equivalent to ``a &= b``."
msgstr "``a = iand(a, b)`` är likvärdigt med ``a &= b``."

msgid ""
"``a = iconcat(a, b)`` is equivalent to ``a += b`` for *a* and *b* sequences."
msgstr ""
"``a = iconcat(a, b)`` är likvärdigt med ``a += b`` för *a* och *b* sekvenser."

msgid "``a = ifloordiv(a, b)`` is equivalent to ``a //= b``."
msgstr "``a = ifloordiv(a, b)`` är ekvivalent med ``a //= b``."

msgid "``a = ilshift(a, b)`` is equivalent to ``a <<= b``."
msgstr "``a = ilshift(a, b)`` är likvärdigt med ``a <<= b``."

msgid "``a = imod(a, b)`` is equivalent to ``a %= b``."
msgstr "``a = imod(a, b)`` är ekvivalent med ``a %= b``."

msgid "``a = imul(a, b)`` is equivalent to ``a *= b``."
msgstr "``a = imul(a, b)`` är likvärdigt med ``a *= b``."

msgid "``a = imatmul(a, b)`` is equivalent to ``a @= b``."
msgstr "``a = imatmul(a, b)`` är likvärdigt med ``a @= b``."

msgid "``a = ior(a, b)`` is equivalent to ``a |= b``."
msgstr "``a = ior(a, b)`` är likvärdigt med ``a |= b``."

msgid "``a = ipow(a, b)`` is equivalent to ``a **= b``."
msgstr "``a = ipow(a, b)`` är ekvivalent med ``a **= b``."

msgid "``a = irshift(a, b)`` is equivalent to ``a >>= b``."
msgstr "``a = irshift(a, b)`` är likvärdigt med ``a >>= b``."

msgid "``a = isub(a, b)`` is equivalent to ``a -= b``."
msgstr "``a = isub(a, b)`` är likvärdigt med ``a -= b``."

msgid "``a = itruediv(a, b)`` is equivalent to ``a /= b``."
msgstr "``a = itruediv(a, b)`` är ekvivalent med ``a /= b``."

msgid "``a = ixor(a, b)`` is equivalent to ``a ^= b``."
msgstr "``a = ixor(a, b)`` är ekvivalent med ``a ^= b``."
