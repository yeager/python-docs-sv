# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!tokenize` --- Tokenizer for Python source"
msgstr ":mod:`!tokenize` --- Tokenizer för Python-källor"

msgid "**Source code:** :source:`Lib/tokenize.py`"
msgstr "**Källkod:** :source:`Lib/tokenize.py`"

msgid ""
"The :mod:`tokenize` module provides a lexical scanner for Python source "
"code, implemented in Python.  The scanner in this module returns comments as "
"tokens as well, making it useful for implementing \"pretty-printers\", "
"including colorizers for on-screen displays."
msgstr ""
"Modulen :mod:`tokenize` tillhandahåller en lexikal skanner för Python-"
"källkod, implementerad i Python.  Skannern i den här modulen returnerar även "
"kommentarer som tokens, vilket gör den användbar för att implementera "
"\"pretty-printers\", inklusive färgläggare för skärmvisning."

msgid ""
"To simplify token stream handling, all :ref:`operator <operators>` and :ref:"
"`delimiter <delimiters>` tokens and :data:`Ellipsis` are returned using the "
"generic :data:`~token.OP` token type.  The exact type can be determined by "
"checking the ``exact_type`` property on the :term:`named tuple` returned "
"from :func:`tokenize.tokenize`."
msgstr ""
"För att förenkla hanteringen av tokenflöden, returneras alla :ref:`operator "
"<operators>` och :ref:`delimiter <delimiters>` tokens och :data:`Ellipsis` "
"med den generiska :data:`~token.OP` token-typen.  Den exakta typen kan "
"bestämmas genom att kontrollera egenskapen ``exact_type`` på :term:`named "
"tuple` som returneras från :func:`tokenize.tokenize`."

msgid ""
"Note that the functions in this module are only designed to parse "
"syntactically valid Python code (code that does not raise when parsed using :"
"func:`ast.parse`).  The behavior of the functions in this module is "
"**undefined** when providing invalid Python code and it can change at any "
"point."
msgstr ""
"Observera att funktionerna i den här modulen endast är utformade för att "
"analysera syntaktiskt giltig Python-kod (kod som inte ger utslag när den "
"analyseras med :func:`ast.parse`).  Beteendet hos funktionerna i den här "
"modulen är **odefinierat** när de tillhandahåller ogiltig Python-kod och det "
"kan ändras när som helst."

msgid "Tokenizing Input"
msgstr "Tokenisering av inmatning"

msgid "The primary entry point is a :term:`generator`:"
msgstr "Den primära ingångspunkten är en :term:`generator`:"

msgid ""
"The :func:`.tokenize` generator requires one argument, *readline*, which "
"must be a callable object which provides the same interface as the :meth:`io."
"IOBase.readline` method of file objects.  Each call to the function should "
"return one line of input as bytes."
msgstr ""
"Generatorn :func:`.tokenize` kräver ett argument, *readline*, som måste vara "
"ett anropbart objekt som ger samma gränssnitt som metoden :meth:`io.IOBase."
"readline` för filobjekt.  Varje anrop till funktionen bör returnera en rad "
"indata som bytes."

msgid ""
"The generator produces 5-tuples with these members: the token type; the "
"token string; a 2-tuple ``(srow, scol)`` of ints specifying the row and "
"column where the token begins in the source; a 2-tuple ``(erow, ecol)`` of "
"ints specifying the row and column where the token ends in the source; and "
"the line on which the token was found. The line passed (the last tuple item) "
"is the *physical* line.  The 5 tuple is returned as a :term:`named tuple` "
"with the field names: ``type string start end line``."
msgstr ""
"Generatorn producerar 5-tupler med dessa medlemmar: token-typen; token-"
"strängen; en 2-tupel ``(srow, scol)`` av ints som anger raden och kolumnen "
"där token börjar i källan; en 2-tupel ``(erow, ecol)`` av ints som anger "
"raden och kolumnen där token slutar i källan; och raden där token hittades. "
"Den rad som skickas (den sista tupeln) är den *fysiska* raden.  Tupeln 5 "
"returneras som en :term:`named tuple` med fältnamnen: ``type string start "
"end line``."

msgid ""
"The returned :term:`named tuple` has an additional property named "
"``exact_type`` that contains the exact operator type for :data:`~token.OP` "
"tokens.  For all other token types ``exact_type`` equals the named tuple "
"``type`` field."
msgstr ""
"Den returnerade :term:`named tuple` har en ytterligare egenskap med namnet "
"``exact_type`` som innehåller den exakta operatortypen för :data:`~token.OP`-"
"tokens.  För alla andra token-typer är ``exact_type`` lika med den namngivna "
"tupelns fält ``type``."

msgid "Added support for named tuples."
msgstr "Lagt till stöd för namngivna tupler."

msgid "Added support for ``exact_type``."
msgstr "Lagt till stöd för ``exact_type``."

msgid ""
":func:`.tokenize` determines the source encoding of the file by looking for "
"a UTF-8 BOM or encoding cookie, according to :pep:`263`."
msgstr ""
":func:`.tokenize` bestämmer källkodningen för filen genom att leta efter en "
"UTF-8 BOM eller kodningskaka, enligt :pep:`263`."

msgid "Tokenize a source reading unicode strings instead of bytes."
msgstr "Tokenisera en källa som läser unicode-strängar istället för bytes."

msgid ""
"Like :func:`.tokenize`, the *readline* argument is a callable returning a "
"single line of input. However, :func:`generate_tokens` expects *readline* to "
"return a str object rather than bytes."
msgstr ""
"Precis som :func:`.tokenize` är argumentet *readline* en callable som "
"returnerar en enda rad med indata. Men :func:`generate_tokens` förväntar sig "
"att *readline* returnerar ett str-objekt istället för bytes."

msgid ""
"The result is an iterator yielding named tuples, exactly like :func:`."
"tokenize`. It does not yield an :data:`~token.ENCODING` token."
msgstr ""
"Resultatet är en iterator som ger namngivna tupler, precis som :func:`."
"tokenize`. Det ger inte en :data:`~token.ENCODING`-token."

msgid ""
"All constants from the :mod:`token` module are also exported from :mod:"
"`tokenize`."
msgstr ""
"Alla konstanter från modulen :mod:`token` exporteras också från :mod:"
"`tokenize`."

msgid ""
"Another function is provided to reverse the tokenization process. This is "
"useful for creating tools that tokenize a script, modify the token stream, "
"and write back the modified script."
msgstr ""
"En annan funktion finns för att vända tokeniseringsprocessen. Detta är "
"användbart för att skapa verktyg som tokeniserar ett skript, modifierar "
"tokenflödet och skriver tillbaka det modifierade skriptet."

msgid ""
"Converts tokens back into Python source code.  The *iterable* must return "
"sequences with at least two elements, the token type and the token string. "
"Any additional sequence elements are ignored."
msgstr ""
"Konverterar tokens tillbaka till Python-källkod.  *iterable* måste returnera "
"sekvenser med minst två element, token-typen och token-strängen. Eventuella "
"ytterligare sekvenselement ignoreras."

msgid ""
"The result is guaranteed to tokenize back to match the input so that the "
"conversion is lossless and round-trips are assured.  The guarantee applies "
"only to the token type and token string as the spacing between tokens "
"(column positions) may change."
msgstr ""
"Resultatet garanteras att tokeniseras tillbaka för att matcha indata så att "
"konverteringen är förlustfri och rundresor garanteras.  Garantin gäller "
"endast för token-typen och token-strängen eftersom avståndet mellan tokens "
"(kolumnpositioner) kan ändras."

msgid ""
"It returns bytes, encoded using the :data:`~token.ENCODING` token, which is "
"the first token sequence output by :func:`.tokenize`. If there is no "
"encoding token in the input, it returns a str instead."
msgstr ""
"Den returnerar bytes, kodade med :data:`~token.ENCODING`-token, som är den "
"första tokensekvensen som matas ut av :func:`.tokenize`. Om det inte finns "
"någon kodningstoken i indata returneras en str istället."

msgid ""
":func:`.tokenize` needs to detect the encoding of source files it tokenizes. "
"The function it uses to do this is available:"
msgstr ""
":func:`.tokenize` behöver upptäcka kodningen av källfiler som den "
"tokeniserar. Funktionen som den använder för att göra detta är tillgänglig:"

msgid ""
"The :func:`detect_encoding` function is used to detect the encoding that "
"should be used to decode a Python source file. It requires one argument, "
"readline, in the same way as the :func:`.tokenize` generator."
msgstr ""
"Funktionen :func:`detect_encoding` används för att upptäcka den kodning som "
"ska användas för att avkoda en Python-källfil. Den kräver ett argument, "
"readline, på samma sätt som generatorn :func:`.tokenize`."

msgid ""
"It will call readline a maximum of twice, and return the encoding used (as a "
"string) and a list of any lines (not decoded from bytes) it has read in."
msgstr ""
"Den kommer att anropa readline högst två gånger och returnera den kodning "
"som använts (som en sträng) och en lista över alla rader (som inte avkodats "
"från bytes) som den har läst in."

msgid ""
"It detects the encoding from the presence of a UTF-8 BOM or an encoding "
"cookie as specified in :pep:`263`. If both a BOM and a cookie are present, "
"but disagree, a :exc:`SyntaxError` will be raised. Note that if the BOM is "
"found, ``'utf-8-sig'`` will be returned as an encoding."
msgstr ""
"Den detekterar kodningen från närvaron av en UTF-8 BOM eller en kodningskaka "
"enligt specifikationen i :pep:`263`. Om både en BOM och en cookie finns, men "
"är oense, kommer ett :exc:`SyntaxError` att uppstå. Observera att om BOM "
"hittas, kommer ``'utf-8-sig'`` att returneras som kodning."

msgid ""
"If no encoding is specified, then the default of ``'utf-8'`` will be "
"returned."
msgstr ""
"Om ingen kodning anges kommer standardvärdet ``'utf-8'`` att returneras."

msgid ""
"Use :func:`.open` to open Python source files: it uses :func:"
"`detect_encoding` to detect the file encoding."
msgstr ""
"Använd :func:`.open` för att öppna Python-källfiler: den använder :func:"
"`detect_encoding` för att upptäcka filkodningen."

msgid ""
"Open a file in read only mode using the encoding detected by :func:"
"`detect_encoding`."
msgstr ""
"Öppna en fil i skrivskyddat läge med hjälp av den kodning som upptäcktes av :"
"func:`detect_encoding`."

msgid ""
"Raised when either a docstring or expression that may be split over several "
"lines is not completed anywhere in the file, for example::"
msgstr ""
"Utlöses när antingen en dokumentsträng eller ett uttryck som kan vara "
"uppdelat på flera rader inte avslutas någonstans i filen, till exempel::"

msgid ""
"\"\"\"Beginning of\n"
"docstring"
msgstr ""
"\"\"\"Början av\n"
"dokumentsträng"

msgid "or::"
msgstr "eller::"

msgid ""
"[1,\n"
" 2,\n"
" 3"
msgstr ""
"[1,\n"
" 2,\n"
" 3"

msgid "Command-Line Usage"
msgstr "Användning av kommandoraden"

msgid ""
"The :mod:`tokenize` module can be executed as a script from the command "
"line. It is as simple as:"
msgstr ""
"Modulen :mod:`tokenize` kan köras som ett skript från kommandoraden. Det är "
"så enkelt som att:"

msgid "python -m tokenize [-e] [filename.py]"
msgstr "python -m tokenize [-e] [filnamn.py]"

msgid "The following options are accepted:"
msgstr "Följande alternativ accepteras:"

msgid "show this help message and exit"
msgstr "visa detta hjälpmeddelande och avsluta"

msgid "display token names using the exact type"
msgstr "visa tokennamn med exakt typ"

msgid ""
"If :file:`filename.py` is specified its contents are tokenized to stdout. "
"Otherwise, tokenization is performed on stdin."
msgstr ""
"Om :file:`filnamn.py` anges tokeniseras dess innehåll till stdout. I annat "
"fall utförs tokenisering på stdin."

msgid "Examples"
msgstr "Exempel"

msgid ""
"Example of a script rewriter that transforms float literals into Decimal "
"objects::"
msgstr ""
"Exempel på en script rewriter som omvandlar float-literaler till Decimal-"
"objekt::"

msgid ""
"from tokenize import tokenize, untokenize, NUMBER, STRING, NAME, OP\n"
"from io import BytesIO\n"
"\n"
"def decistmt(s):\n"
"    \"\"\"Substitute Decimals for floats in a string of statements.\n"
"\n"
"    >>> from decimal import Decimal\n"
"    >>> s = 'print(+21.3e-5*-.1234/81.7)'\n"
"    >>> decistmt(s)\n"
"    \"print (+Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7'))\"\n"
"\n"
"    The format of the exponent is inherited from the platform C library.\n"
"    Known cases are \"e-007\" (Windows) and \"e-07\" (not Windows).  Since\n"
"    we're only showing 12 digits, and the 13th isn't close to 5, the\n"
"    rest of the output should be platform-independent.\n"
"\n"
"    >>> exec(s)  #doctest: +ELLIPSIS\n"
"    -3.21716034272e-0...7\n"
"\n"
"    Output from calculations with Decimal should be identical across all\n"
"    platforms.\n"
"\n"
"    >>> exec(decistmt(s))\n"
"    -3.217160342717258261933904529E-7\n"
"    \"\"\"\n"
"    result = []\n"
"    g = tokenize(BytesIO(s.encode('utf-8')).readline)  # tokenize the "
"string\n"
"    for toknum, tokval, _, _, _ in g:\n"
"        if toknum == NUMBER and '.' in tokval:  # replace NUMBER tokens\n"
"            result.extend([\n"
"                (NAME, 'Decimal'),\n"
"                (OP, '('),\n"
"                (STRING, repr(tokval)),\n"
"                (OP, ')')\n"
"            ])\n"
"        else:\n"
"            result.append((toknum, tokval))\n"
"    return untokenize(result).decode('utf-8')"
msgstr ""
"from tokenize import tokenize, untokenize, NUMBER, STRING, NAME, OP\n"
"from io import BytesIO\n"
"\n"
"def decistmt(s):\n"
"    \"\"\"Substitute Decimals for floats in a string of statements.\n"
"\n"
"    >>> from decimal import Decimal\n"
"    >>> s = 'print(+21.3e-5*-.1234/81.7)'\n"
"    >>> decistmt(s)\n"
"    \"print (+Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7'))\"\n"
"\n"
"    The format of the exponent is inherited from the platform C library.\n"
"    Known cases are \"e-007\" (Windows) and \"e-07\" (not Windows).  Since\n"
"    we're only showing 12 digits, and the 13th isn't close to 5, the\n"
"    rest of the output should be platform-independent.\n"
"\n"
"    >>> exec(s)  #doctest: +ELLIPSIS\n"
"    -3.21716034272e-0...7\n"
"\n"
"    Output from calculations with Decimal should be identical across all\n"
"    platforms.\n"
"\n"
"    >>> exec(decistmt(s))\n"
"    -3.217160342717258261933904529E-7\n"
"    \"\"\"\n"
"    result = []\n"
"    g = tokenize(BytesIO(s.encode('utf-8')).readline)  # tokenize the "
"string\n"
"    for toknum, tokval, _, _, _ in g:\n"
"        if toknum == NUMBER and '.' in tokval:  # replace NUMBER tokens\n"
"            result.extend([\n"
"                (NAME, 'Decimal'),\n"
"                (OP, '('),\n"
"                (STRING, repr(tokval)),\n"
"                (OP, ')')\n"
"            ])\n"
"        else:\n"
"            result.append((toknum, tokval))\n"
"    return untokenize(result).decode('utf-8')"

msgid "Example of tokenizing from the command line.  The script::"
msgstr "Exempel på tokenisering från kommandoraden.  Skriptet::"

msgid ""
"def say_hello():\n"
"    print(\"Hello, World!\")\n"
"\n"
"say_hello()"
msgstr ""
"def say_hello():\n"
"    print(\"Hello, World!\")\n"
"\n"
"say_hello()"

msgid ""
"will be tokenized to the following output where the first column is the "
"range of the line/column coordinates where the token is found, the second "
"column is the name of the token, and the final column is the value of the "
"token (if any)"
msgstr ""
"kommer att tokeniseras till följande utdata där den första kolumnen är "
"intervallet för rad- / kolumnkoordinaterna där token hittas, den andra "
"kolumnen är namnet på token och den sista kolumnen är värdet på token (om "
"någon)"

msgid ""
"$ python -m tokenize hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          OP             '('\n"
"1,14-1,15:          OP             ')'\n"
"1,15-1,16:          OP             ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           OP             '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          OP             ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           OP             '('\n"
"4,10-4,11:          OP             ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"
msgstr ""
"$ python -m tokenize hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          OP             '('\n"
"1,14-1,15:          OP             ')'\n"
"1,15-1,16:          OP             ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           OP             '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          OP             ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           OP             '('\n"
"4,10-4,11:          OP             ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"

msgid ""
"The exact token type names can be displayed using the :option:`-e` option:"
msgstr ""
"De exakta namnen på token-typerna kan visas med hjälp av alternativet :"
"option:`-e`:"

msgid ""
"$ python -m tokenize -e hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          LPAR           '('\n"
"1,14-1,15:          RPAR           ')'\n"
"1,15-1,16:          COLON          ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           LPAR           '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          RPAR           ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           LPAR           '('\n"
"4,10-4,11:          RPAR           ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"
msgstr ""
"$ python -m tokenize -e hello.py\n"
"0,0-0,0:            ENCODING       'utf-8'\n"
"1,0-1,3:            NAME           'def'\n"
"1,4-1,13:           NAME           'say_hello'\n"
"1,13-1,14:          LPAR           '('\n"
"1,14-1,15:          RPAR           ')'\n"
"1,15-1,16:          COLON          ':'\n"
"1,16-1,17:          NEWLINE        '\\n'\n"
"2,0-2,4:            INDENT         '    '\n"
"2,4-2,9:            NAME           'print'\n"
"2,9-2,10:           LPAR           '('\n"
"2,10-2,25:          STRING         '\"Hello, World!\"'\n"
"2,25-2,26:          RPAR           ')'\n"
"2,26-2,27:          NEWLINE        '\\n'\n"
"3,0-3,1:            NL             '\\n'\n"
"4,0-4,0:            DEDENT         ''\n"
"4,0-4,9:            NAME           'say_hello'\n"
"4,9-4,10:           LPAR           '('\n"
"4,10-4,11:          RPAR           ')'\n"
"4,11-4,12:          NEWLINE        '\\n'\n"
"5,0-5,0:            ENDMARKER      ''"

msgid ""
"Example of tokenizing a file programmatically, reading unicode strings "
"instead of bytes with :func:`generate_tokens`::"
msgstr ""
"Exempel på tokenisering av en fil programmatiskt, läsning av unicode-"
"strängar istället för bytes med :func:`generate_tokens`::"

msgid ""
"import tokenize\n"
"\n"
"with tokenize.open('hello.py') as f:\n"
"    tokens = tokenize.generate_tokens(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
msgstr ""
"import tokenize\n"
"\n"
"with tokenize.open('hello.py') as f:\n"
"    tokens = tokenize.generate_tokens(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"

msgid "Or reading bytes directly with :func:`.tokenize`::"
msgstr "Eller läsa bytes direkt med :func:`.tokenize`::"

msgid ""
"import tokenize\n"
"\n"
"with open('hello.py', 'rb') as f:\n"
"    tokens = tokenize.tokenize(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
msgstr ""
"import tokenize\n"
"\n"
"with open('hello.py', 'rb') as f:\n"
"    tokens = tokenize.tokenize(f.readline)\n"
"    for token in tokens:\n"
"        print(token)"
