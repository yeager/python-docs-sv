# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Instrumenting CPython with DTrace and SystemTap"
msgstr "Instrumentering av CPython med DTrace och SystemTap"

msgid "author"
msgstr "författare"

msgid "David Malcolm"
msgstr "David Malcolm"

msgid "Łukasz Langa"
msgstr "Łukasz Langa"

msgid ""
"DTrace and SystemTap are monitoring tools, each providing a way to inspect "
"what the processes on a computer system are doing.  They both use domain-"
"specific languages allowing a user to write scripts which:"
msgstr ""
"DTrace och SystemTap är övervakningsverktyg som var och en ger möjlighet att "
"inspektera vad processerna i ett datorsystem gör.  De använder båda "
"domänspecifika språk som gör det möjligt för en användare att skriva skript "
"som:"

msgid "filter which processes are to be observed"
msgstr "filtrera vilka processer som ska följas"

msgid "gather data from the processes of interest"
msgstr "samla in data från de processer som är av intresse"

msgid "generate reports on the data"
msgstr "generera rapporter om data"

msgid ""
"As of Python 3.6, CPython can be built with embedded \"markers\", also known "
"as \"probes\", that can be observed by a DTrace or SystemTap script, making "
"it easier to monitor what the CPython processes on a system are doing."
msgstr ""
"Från och med Python 3.6 kan CPython byggas med inbäddade \"markörer\", även "
"kända som \"prober\", som kan observeras av ett DTrace- eller SystemTap-"
"skript, vilket gör det lättare att övervaka vad CPython-processerna på ett "
"system gör."

msgid ""
"DTrace markers are implementation details of the CPython interpreter. No "
"guarantees are made about probe compatibility between versions of CPython. "
"DTrace scripts can stop working or work incorrectly without warning when "
"changing CPython versions."
msgstr ""
"DTrace-markörer är implementeringsdetaljer i CPython-tolken. Inga garantier "
"ges om kompatibilitet mellan olika versioner av CPython. DTrace-skript kan "
"sluta fungera eller fungera felaktigt utan förvarning när CPython-versioner "
"ändras."

msgid "Enabling the static markers"
msgstr "Aktivering av statiska markörer"

msgid ""
"macOS comes with built-in support for DTrace.  On Linux, in order to build "
"CPython with the embedded markers for SystemTap, the SystemTap development "
"tools must be installed."
msgstr ""
"macOS kommer med inbyggt stöd för DTrace.  På Linux måste SystemTap-"
"utvecklingsverktygen installeras för att CPython ska kunna byggas med de "
"inbäddade markörerna för SystemTap."

msgid "On a Linux machine, this can be done via::"
msgstr "På en Linux-maskin kan detta göras via::"

msgid "$ yum install systemtap-sdt-devel"
msgstr "$ yum install systemtap-sdt-devel"

msgid "or::"
msgstr "eller::"

msgid "$ sudo apt-get install systemtap-sdt-dev"
msgstr "$ sudo apt-get install systemtap-sdt-dev"

msgid ""
"CPython must then be :option:`configured with the --with-dtrace option <--"
"with-dtrace>`:"
msgstr ""
"CPython måste då :option:`konfigureras med alternativet --with-dtrace <--"
"with-dtrace>`:"

msgid "checking for --with-dtrace... yes"
msgstr "checking for --with-dtrace... yes"

msgid ""
"On macOS, you can list available DTrace probes by running a Python process "
"in the background and listing all probes made available by the Python "
"provider::"
msgstr ""
"På macOS kan du lista tillgängliga DTrace-prober genom att köra en Python-"
"process i bakgrunden och lista alla prober som görs tillgängliga av Python-"
"providern::"

msgid ""
"$ python3.6 -q &\n"
"$ sudo dtrace -l -P python$!  # or: dtrace -l -m python3.6\n"
"\n"
"   ID   PROVIDER            MODULE                          FUNCTION NAME\n"
"29564 python18035        python3.6          _PyEval_EvalFrameDefault "
"function-entry\n"
"29565 python18035        python3.6             dtrace_function_entry "
"function-entry\n"
"29566 python18035        python3.6          _PyEval_EvalFrameDefault "
"function-return\n"
"29567 python18035        python3.6            dtrace_function_return "
"function-return\n"
"29568 python18035        python3.6                           collect gc-"
"done\n"
"29569 python18035        python3.6                           collect gc-"
"start\n"
"29570 python18035        python3.6          _PyEval_EvalFrameDefault line\n"
"29571 python18035        python3.6                 maybe_dtrace_line line"
msgstr ""
"$ python3.6 -q &\n"
"$ sudo dtrace -l -P python$!  # or: dtrace -l -m python3.6\n"
"\n"
"   ID   PROVIDER            MODULE                          FUNCTION NAME\n"
"29564 python18035        python3.6          _PyEval_EvalFrameDefault "
"function-entry\n"
"29565 python18035        python3.6             dtrace_function_entry "
"function-entry\n"
"29566 python18035        python3.6          _PyEval_EvalFrameDefault "
"function-return\n"
"29567 python18035        python3.6            dtrace_function_return "
"function-return\n"
"29568 python18035        python3.6                           collect gc-"
"done\n"
"29569 python18035        python3.6                           collect gc-"
"start\n"
"29570 python18035        python3.6          _PyEval_EvalFrameDefault line\n"
"29571 python18035        python3.6                 maybe_dtrace_line line"

msgid ""
"On Linux, you can verify if the SystemTap static markers are present in the "
"built binary by seeing if it contains a \".note.stapsdt\" section."
msgstr ""
"På Linux kan du kontrollera om de statiska SystemTap-markörerna finns i den "
"inbyggda binärfilen genom att se om den innehåller ett avsnitt \".note."
"stapsdt\"."

msgid ""
"$ readelf -S ./python | grep .note.stapsdt\n"
"[30] .note.stapsdt        NOTE         0000000000000000 00308d78"
msgstr ""
"$ readelf -S ./python | grep .note.stapsdt\n"
"[30] .note.stapsdt        NOTE         0000000000000000 00308d78"

msgid ""
"If you've built Python as a shared library (with the :option:`--enable-"
"shared` configure option), you need to look instead within the shared "
"library.  For example::"
msgstr ""
"Om du har byggt Python som ett delat bibliotek (med "
"konfigurationsalternativet :option:`--enable-shared`) måste du istället leta "
"inom det delade biblioteket.  Till exempel::"

msgid ""
"$ readelf -S libpython3.3dm.so.1.0 | grep .note.stapsdt\n"
"[29] .note.stapsdt        NOTE         0000000000000000 00365b68"
msgstr ""
"$ readelf -S libpython3.3dm.so.1.0 | grep .note.stapsdt\n"
"[29] .note.stapsdt        NOTE         0000000000000000 00365b68"

msgid "Sufficiently modern readelf can print the metadata::"
msgstr "Tillräckligt modern readelf kan skriva ut metadata::"

msgid ""
"$ readelf -n ./python\n"
"\n"
"Displaying notes found at file offset 0x00000254 with length 0x00000020:\n"
"    Owner                 Data size          Description\n"
"    GNU                  0x00000010          NT_GNU_ABI_TAG (ABI version "
"tag)\n"
"        OS: Linux, ABI: 2.6.32\n"
"\n"
"Displaying notes found at file offset 0x00000274 with length 0x00000024:\n"
"    Owner                 Data size          Description\n"
"    GNU                  0x00000014          NT_GNU_BUILD_ID (unique build "
"ID bitstring)\n"
"        Build ID: df924a2b08a7e89f6e11251d4602022977af2670\n"
"\n"
"Displaying notes found at file offset 0x002d6c30 with length 0x00000144:\n"
"    Owner                 Data size          Description\n"
"    stapsdt              0x00000031          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: gc__start\n"
"        Location: 0x00000000004371c3, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bf6\n"
"        Arguments: -4@%ebx\n"
"    stapsdt              0x00000030          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: gc__done\n"
"        Location: 0x00000000004374e1, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bf8\n"
"        Arguments: -8@%rax\n"
"    stapsdt              0x00000045          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: function__entry\n"
"        Location: 0x000000000053db6c, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6be8\n"
"        Arguments: 8@%rbp 8@%r12 -4@%eax\n"
"    stapsdt              0x00000046          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: function__return\n"
"        Location: 0x000000000053dba8, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bea\n"
"        Arguments: 8@%rbp 8@%r12 -4@%eax"
msgstr ""
"$ readelf -n ./python\n"
"\n"
"Displaying notes found at file offset 0x00000254 with length 0x00000020:\n"
"    Owner                 Data size          Description\n"
"    GNU                  0x00000010          NT_GNU_ABI_TAG (ABI version "
"tag)\n"
"        OS: Linux, ABI: 2.6.32\n"
"\n"
"Displaying notes found at file offset 0x00000274 with length 0x00000024:\n"
"    Owner                 Data size          Description\n"
"    GNU                  0x00000014          NT_GNU_BUILD_ID (unique build "
"ID bitstring)\n"
"        Build ID: df924a2b08a7e89f6e11251d4602022977af2670\n"
"\n"
"Displaying notes found at file offset 0x002d6c30 with length 0x00000144:\n"
"    Owner                 Data size          Description\n"
"    stapsdt              0x00000031          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: gc__start\n"
"        Location: 0x00000000004371c3, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bf6\n"
"        Arguments: -4@%ebx\n"
"    stapsdt              0x00000030          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: gc__done\n"
"        Location: 0x00000000004374e1, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bf8\n"
"        Arguments: -8@%rax\n"
"    stapsdt              0x00000045          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: function__entry\n"
"        Location: 0x000000000053db6c, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6be8\n"
"        Arguments: 8@%rbp 8@%r12 -4@%eax\n"
"    stapsdt              0x00000046          NT_STAPSDT (SystemTap probe "
"descriptors)\n"
"        Provider: python\n"
"        Name: function__return\n"
"        Location: 0x000000000053dba8, Base: 0x0000000000630ce2, Semaphore: "
"0x00000000008d6bea\n"
"        Arguments: 8@%rbp 8@%r12 -4@%eax"

msgid ""
"The above metadata contains information for SystemTap describing how it can "
"patch strategically placed machine code instructions to enable the tracing "
"hooks used by a SystemTap script."
msgstr ""
"Ovanstående metadata innehåller information för SystemTap som beskriver hur "
"det kan patcha strategiskt placerade maskinkodinstruktioner för att aktivera "
"de spårningskrokar som används av ett SystemTap-skript."

msgid "Static DTrace probes"
msgstr "Statiska DTrace-prober"

msgid ""
"The following example DTrace script can be used to show the call/return "
"hierarchy of a Python script, only tracing within the invocation of a "
"function called \"start\". In other words, import-time function invocations "
"are not going to be listed:"
msgstr ""
"Följande exempel på DTrace-skript kan användas för att visa anrops-/"
"returhierarkin i ett Python-skript, med spårning endast inom anropet av en "
"funktion som heter \"start\". Med andra ord kommer inte anrop av "
"importfunktioner att listas:"

msgid ""
"self int indent;\n"
"\n"
"python$target:::function-entry\n"
"/copyinstr(arg1) == \"start\"/\n"
"{\n"
"        self->trace = 1;\n"
"}\n"
"\n"
"python$target:::function-entry\n"
"/self->trace/\n"
"{\n"
"        printf(\"%d\\t%*s:\", timestamp, 15, probename);\n"
"        printf(\"%*s\", self->indent, \"\");\n"
"        printf(\"%s:%s:%d\\n\", basename(copyinstr(arg0)), copyinstr(arg1), "
"arg2);\n"
"        self->indent++;\n"
"}\n"
"\n"
"python$target:::function-return\n"
"/self->trace/\n"
"{\n"
"        self->indent--;\n"
"        printf(\"%d\\t%*s:\", timestamp, 15, probename);\n"
"        printf(\"%*s\", self->indent, \"\");\n"
"        printf(\"%s:%s:%d\\n\", basename(copyinstr(arg0)), copyinstr(arg1), "
"arg2);\n"
"}\n"
"\n"
"python$target:::function-return\n"
"/copyinstr(arg1) == \"start\"/\n"
"{\n"
"        self->trace = 0;\n"
"}"
msgstr ""
"self int indent;\n"
"\n"
"python$target:::function-entry\n"
"/copyinstr(arg1) == \"start\"/\n"
"{\n"
"        self->trace = 1;\n"
"}\n"
"\n"
"python$target:::function-entry\n"
"/self->trace/\n"
"{\n"
"        printf(\"%d\\t%*s:\", timestamp, 15, probename);\n"
"        printf(\"%*s\", self->indent, \"\");\n"
"        printf(\"%s:%s:%d\\n\", basename(copyinstr(arg0)), copyinstr(arg1), "
"arg2);\n"
"        self->indent++;\n"
"}\n"
"\n"
"python$target:::function-return\n"
"/self->trace/\n"
"{\n"
"        self->indent--;\n"
"        printf(\"%d\\t%*s:\", timestamp, 15, probename);\n"
"        printf(\"%*s\", self->indent, \"\");\n"
"        printf(\"%s:%s:%d\\n\", basename(copyinstr(arg0)), copyinstr(arg1), "
"arg2);\n"
"}\n"
"\n"
"python$target:::function-return\n"
"/copyinstr(arg1) == \"start\"/\n"
"{\n"
"        self->trace = 0;\n"
"}"

msgid "It can be invoked like this::"
msgstr "Den kan anropas på följande sätt::"

msgid "$ sudo dtrace -q -s call_stack.d -c \"python3.6 script.py\""
msgstr "$ sudo dtrace -q -s call_stack.d -c \"python3.6 script.py\""

msgid "The output looks like this:"
msgstr "Utmatningen ser ut så här:"

msgid ""
"156641360502280  function-entry:call_stack.py:start:23\n"
"156641360518804  function-entry: call_stack.py:function_1:1\n"
"156641360532797  function-entry:  call_stack.py:function_3:9\n"
"156641360546807 function-return:  call_stack.py:function_3:10\n"
"156641360563367 function-return: call_stack.py:function_1:2\n"
"156641360578365  function-entry: call_stack.py:function_2:5\n"
"156641360591757  function-entry:  call_stack.py:function_1:1\n"
"156641360605556  function-entry:   call_stack.py:function_3:9\n"
"156641360617482 function-return:   call_stack.py:function_3:10\n"
"156641360629814 function-return:  call_stack.py:function_1:2\n"
"156641360642285 function-return: call_stack.py:function_2:6\n"
"156641360656770  function-entry: call_stack.py:function_3:9\n"
"156641360669707 function-return: call_stack.py:function_3:10\n"
"156641360687853  function-entry: call_stack.py:function_4:13\n"
"156641360700719 function-return: call_stack.py:function_4:14\n"
"156641360719640  function-entry: call_stack.py:function_5:18\n"
"156641360732567 function-return: call_stack.py:function_5:21\n"
"156641360747370 function-return:call_stack.py:start:28"
msgstr ""
"156641360502280  function-entry:call_stack.py:start:23\n"
"156641360518804  function-entry: call_stack.py:function_1:1\n"
"156641360532797  function-entry:  call_stack.py:function_3:9\n"
"156641360546807 function-return:  call_stack.py:function_3:10\n"
"156641360563367 function-return: call_stack.py:function_1:2\n"
"156641360578365  function-entry: call_stack.py:function_2:5\n"
"156641360591757  function-entry:  call_stack.py:function_1:1\n"
"156641360605556  function-entry:   call_stack.py:function_3:9\n"
"156641360617482 function-return:   call_stack.py:function_3:10\n"
"156641360629814 function-return:  call_stack.py:function_1:2\n"
"156641360642285 function-return: call_stack.py:function_2:6\n"
"156641360656770  function-entry: call_stack.py:function_3:9\n"
"156641360669707 function-return: call_stack.py:function_3:10\n"
"156641360687853  function-entry: call_stack.py:function_4:13\n"
"156641360700719 function-return: call_stack.py:function_4:14\n"
"156641360719640  function-entry: call_stack.py:function_5:18\n"
"156641360732567 function-return: call_stack.py:function_5:21\n"
"156641360747370 function-return:call_stack.py:start:28"

msgid "Static SystemTap markers"
msgstr "Statiskt systemTap-markörer"

msgid ""
"The low-level way to use the SystemTap integration is to use the static "
"markers directly.  This requires you to explicitly state the binary file "
"containing them."
msgstr ""
"Lågnivåmetoden för att använda SystemTap-integrationen är att använda de "
"statiska markörerna direkt.  Detta kräver att du uttryckligen anger den "
"binära fil som innehåller dem."

msgid ""
"For example, this SystemTap script can be used to show the call/return "
"hierarchy of a Python script:"
msgstr ""
"Detta SystemTap-skript kan t.ex. användas för att visa Call/Return-hierarkin "
"i ett Python-skript:"

msgid ""
"probe process(\"python\").mark(\"function__entry\") {\n"
"     filename = user_string($arg1);\n"
"     funcname = user_string($arg2);\n"
"     lineno = $arg3;\n"
"\n"
"     printf(\"%s => %s in %s:%d\\\\n\",\n"
"            thread_indent(1), funcname, filename, lineno);\n"
"}\n"
"\n"
"probe process(\"python\").mark(\"function__return\") {\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"\n"
"    printf(\"%s <= %s in %s:%d\\\\n\",\n"
"           thread_indent(-1), funcname, filename, lineno);\n"
"}"
msgstr ""
"probe process(\"python\").mark(\"function__entry\") {\n"
"     filename = user_string($arg1);\n"
"     funcname = user_string($arg2);\n"
"     lineno = $arg3;\n"
"\n"
"     printf(\"%s => %s in %s:%d\\\\n\",\n"
"            thread_indent(1), funcname, filename, lineno);\n"
"}\n"
"\n"
"probe process(\"python\").mark(\"function__return\") {\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"\n"
"    printf(\"%s <= %s in %s:%d\\\\n\",\n"
"           thread_indent(-1), funcname, filename, lineno);\n"
"}"

msgid ""
"$ stap \\\n"
"  show-call-hierarchy.stp \\\n"
"  -c \"./python test.py\""
msgstr ""
"$ stap \\\n"
"  show-call-hierarchy.stp \\\n"
"  -c \"./python test.py\""

msgid ""
"11408 python(8274):        => __contains__ in Lib/_abcoll.py:362\n"
"11414 python(8274):         => __getitem__ in Lib/os.py:425\n"
"11418 python(8274):          => encode in Lib/os.py:490\n"
"11424 python(8274):          <= encode in Lib/os.py:493\n"
"11428 python(8274):         <= __getitem__ in Lib/os.py:426\n"
"11433 python(8274):        <= __contains__ in Lib/_abcoll.py:366"
msgstr ""
"11408 python(8274):        => __contains__ in Lib/_abcoll.py:362\n"
"11414 python(8274):         => __getitem__ in Lib/os.py:425\n"
"11418 python(8274):          => encode in Lib/os.py:490\n"
"11424 python(8274):          <= encode in Lib/os.py:493\n"
"11428 python(8274):         <= __getitem__ in Lib/os.py:426\n"
"11433 python(8274):        <= __contains__ in Lib/_abcoll.py:366"

msgid "where the columns are:"
msgstr "där kolumnerna är:"

msgid "time in microseconds since start of script"
msgstr "tid i mikrosekunder sedan skriptets start"

msgid "name of executable"
msgstr "namn på körbar fil"

msgid "PID of process"
msgstr "PID för process"

msgid ""
"and the remainder indicates the call/return hierarchy as the script executes."
msgstr "och resten visar hierarkin för anrop/retur när skriptet körs."

msgid ""
"For a :option:`--enable-shared` build of CPython, the markers are contained "
"within the libpython shared library, and the probe's dotted path needs to "
"reflect this. For example, this line from the above example:"
msgstr ""
"För en :option:`--enable-shared`-byggnad av CPython finns markörerna i det "
"delade biblioteket libpython, och probens prickade sökväg måste återspegla "
"detta. Till exempel den här raden från exemplet ovan:"

msgid "probe process(\"python\").mark(\"function__entry\") {"
msgstr "probe process(\"python\").mark(\"function__entry\") {"

msgid "should instead read:"
msgstr "bör istället lyda:"

msgid ""
"probe process(\"python\").library(\"libpython3.6dm.so.1.0\")."
"mark(\"function__entry\") {"
msgstr ""
"probe process(\"python\").library(\"libpython3.6dm.so.1.0\")."
"mark(\"function__entry\") {"

msgid "(assuming a :ref:`debug build <debug-build>` of CPython 3.6)"
msgstr "(antar en :ref:`debug build <debug-build>` av CPython 3.6)"

msgid "Available static markers"
msgstr "Tillgängliga statiska markörer"

msgid ""
"This marker indicates that execution of a Python function has begun. It is "
"only triggered for pure-Python (bytecode) functions."
msgstr ""
"Denna markör anger att exekveringen av en Python-funktion har påbörjats. Den "
"utlöses endast för rena Python-funktioner (bytecode)."

msgid ""
"The filename, function name, and line number are provided back to the "
"tracing script as positional arguments, which must be accessed using "
"``$arg1``, ``$arg2``, ``$arg3``:"
msgstr ""
"Filnamnet, funktionsnamnet och radnumret skickas tillbaka till "
"spårningsskriptet som positionella argument, som måste nås med hjälp av "
"``$arg1``, ``$arg2``, ``$arg3``:"

msgid ""
"``$arg1`` : ``(const char *)`` filename, accessible using "
"``user_string($arg1)``"
msgstr ""
"``$arg1`` : ``(const char *)`` filnamn, tillgängligt med "
"``user_string($arg1)``"

msgid ""
"``$arg2`` : ``(const char *)`` function name, accessible using "
"``user_string($arg2)``"
msgstr ""
"``$arg2`` : ``(const char *)`` funktionsnamn, tillgängligt med "
"``user_string($arg2)``"

msgid "``$arg3`` : ``int`` line number"
msgstr "``$arg3`` : ``int`` radnummer"

msgid ""
"This marker is the converse of :c:func:`!function__entry`, and indicates "
"that execution of a Python function has ended (either via ``return``, or via "
"an exception).  It is only triggered for pure-Python (bytecode) functions."
msgstr ""
"Denna markör är motsatsen till :c:func:`!function__entry` och anger att "
"exekveringen av en Python-funktion har avslutats (antingen via ``return`` "
"eller via ett undantag).  Den utlöses endast för rena Python-funktioner "
"(bytecode)."

msgid "The arguments are the same as for :c:func:`!function__entry`"
msgstr "Argumenten är desamma som för :c:func:`!function__entry`"

msgid ""
"This marker indicates a Python line is about to be executed.  It is the "
"equivalent of line-by-line tracing with a Python profiler.  It is not "
"triggered within C functions."
msgstr ""
"Denna markör indikerar att en Python-rad är på väg att exekveras.  Det "
"motsvarar spårning rad för rad med en Python-profilerare.  Den utlöses inte "
"inom C-funktioner."

msgid "The arguments are the same as for :c:func:`!function__entry`."
msgstr "Argumenten är desamma som för :c:func:`!function__entry`."

msgid ""
"Fires when the Python interpreter starts a garbage collection cycle. "
"``arg0`` is the generation to scan, like :func:`gc.collect`."
msgstr ""
"Utlöses när Python-tolken startar en skräpinsamlingscykel. ``arg0`` är den "
"generation som ska skannas, som :func:`gc.collect`."

msgid ""
"Fires when the Python interpreter finishes a garbage collection cycle. "
"``arg0`` is the number of collected objects."
msgstr ""
"Utlöses när Python-tolken avslutar en garbage collection-cykel. ``arg0`` är "
"antalet insamlade objekt."

msgid ""
"Fires before :mod:`importlib` attempts to find and load the module. ``arg0`` "
"is the module name."
msgstr ""
"Startas innan :mod:`importlib` försöker hitta och ladda modulen. ``arg0`` är "
"modulens namn."

msgid ""
"Fires after :mod:`importlib`'s find_and_load function is called. ``arg0`` is "
"the module name, ``arg1`` indicates if module was successfully loaded."
msgstr ""
"Startas efter att :mod:`importlib`'s find_and_load-funktion har anropats. "
"``arg0`` är modulnamnet, ``arg1`` indikerar om modulen laddades "
"framgångsrikt."

msgid ""
"Fires when :func:`sys.audit` or :c:func:`PySys_Audit` is called. ``arg0`` is "
"the event name as C string, ``arg1`` is a :c:type:`PyObject` pointer to a "
"tuple object."
msgstr ""
"Startar när :func:`sys.audit` eller :c:func:`PySys_Audit` anropas. ``arg0`` "
"är händelsens namn som C-sträng, ``arg1`` är en :c:type:`PyObject`-pekare "
"till ett tuple-objekt."

msgid "SystemTap Tapsets"
msgstr "SystemTap Kranar"

msgid ""
"The higher-level way to use the SystemTap integration is to use a "
"\"tapset\": SystemTap's equivalent of a library, which hides some of the "
"lower-level details of the static markers."
msgstr ""
"Det mer avancerade sättet att använda SystemTap-integrationen är att använda "
"ett \"tapset\": SystemTaps motsvarighet till ett bibliotek, som döljer några "
"av de statiska markörernas detaljer på lägre nivå."

msgid "Here is a tapset file, based on a non-shared build of CPython:"
msgstr "Här är en tapset-fil, baserad på en icke-delad version av CPython:"

msgid ""
"/*\n"
"   Provide a higher-level wrapping around the function__entry and\n"
"   function__return markers:\n"
" \\*/\n"
"probe python.function.entry = process(\"python\").mark(\"function__entry\")\n"
"{\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"    frameptr = $arg4\n"
"}\n"
"probe python.function.return = process(\"python\")."
"mark(\"function__return\")\n"
"{\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"    frameptr = $arg4\n"
"}"
msgstr ""
"/*\n"
"   Provide a higher-level wrapping around the function__entry and\n"
"   function__return markers:\n"
" \\*/\n"
"probe python.function.entry = process(\"python\").mark(\"function__entry\")\n"
"{\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"    frameptr = $arg4\n"
"}\n"
"probe python.function.return = process(\"python\")."
"mark(\"function__return\")\n"
"{\n"
"    filename = user_string($arg1);\n"
"    funcname = user_string($arg2);\n"
"    lineno = $arg3;\n"
"    frameptr = $arg4\n"
"}"

msgid ""
"If this file is installed in SystemTap's tapset directory (e.g. ``/usr/share/"
"systemtap/tapset``), then these additional probepoints become available:"
msgstr ""
"Om den här filen installeras i SystemTaps tapset-katalog (t.ex. ``/usr/share/"
"systemtap/tapset``) blir dessa ytterligare probepoints tillgängliga:"

msgid ""
"This probe point indicates that execution of a Python function has begun. It "
"is only triggered for pure-Python (bytecode) functions."
msgstr ""
"Denna probepunkt indikerar att exekveringen av en Python-funktion har "
"påbörjats. Den utlöses endast för rena Python-funktioner (bytecode)."

msgid ""
"This probe point is the converse of ``python.function.return``, and "
"indicates that execution of a Python function has ended (either via "
"``return``, or via an exception).  It is only triggered for pure-Python "
"(bytecode) functions."
msgstr ""
"Denna probepunkt är motsatsen till ``python.function.return`` och anger att "
"exekveringen av en Python-funktion har avslutats (antingen via ``return`` "
"eller via ett undantag).  Den utlöses endast för rena Python-funktioner "
"(bytecode)."

msgid "Examples"
msgstr "Exempel"

msgid ""
"This SystemTap script uses the tapset above to more cleanly implement the "
"example given above of tracing the Python function-call hierarchy, without "
"needing to directly name the static markers:"
msgstr ""
"Detta SystemTap-skript använder tapset ovan för att på ett renare sätt "
"implementera exemplet ovan med spårning av Pythons funktionsanropshierarki, "
"utan att direkt behöva namnge de statiska markörerna:"

msgid ""
"probe python.function.entry\n"
"{\n"
"  printf(\"%s => %s in %s:%d\\n\",\n"
"         thread_indent(1), funcname, filename, lineno);\n"
"}\n"
"\n"
"probe python.function.return\n"
"{\n"
"  printf(\"%s <= %s in %s:%d\\n\",\n"
"         thread_indent(-1), funcname, filename, lineno);\n"
"}"
msgstr ""
"probe python.function.entry\n"
"{\n"
"  printf(\"%s => %s in %s:%d\\n\",\n"
"         thread_indent(1), funcname, filename, lineno);\n"
"}\n"
"\n"
"probe python.function.return\n"
"{\n"
"  printf(\"%s <= %s in %s:%d\\n\",\n"
"         thread_indent(-1), funcname, filename, lineno);\n"
"}"

msgid ""
"The following script uses the tapset above to provide a top-like view of all "
"running CPython code, showing the top 20 most frequently entered bytecode "
"frames, each second, across the whole system:"
msgstr ""
"Följande skript använder tapset ovan för att ge en toppliknande vy över all "
"CPython-kod som körs och visar de 20 mest frekvent inmatade bytekodsramarna "
"varje sekund i hela systemet:"

msgid ""
"global fn_calls;\n"
"\n"
"probe python.function.entry\n"
"{\n"
"    fn_calls[pid(), filename, funcname, lineno] += 1;\n"
"}\n"
"\n"
"probe timer.ms(1000) {\n"
"    printf(\"\\033[2J\\033[1;1H\") /* clear screen \\*/\n"
"    printf(\"%6s %80s %6s %30s %6s\\n\",\n"
"           \"PID\", \"FILENAME\", \"LINE\", \"FUNCTION\", \"CALLS\")\n"
"    foreach ([pid, filename, funcname, lineno] in fn_calls- limit 20) {\n"
"        printf(\"%6d %80s %6d %30s %6d\\n\",\n"
"            pid, filename, lineno, funcname,\n"
"            fn_calls[pid, filename, funcname, lineno]);\n"
"    }\n"
"    delete fn_calls;\n"
"}"
msgstr ""
"global fn_calls;\n"
"\n"
"probe python.function.entry\n"
"{\n"
"    fn_calls[pid(), filename, funcname, lineno] += 1;\n"
"}\n"
"\n"
"probe timer.ms(1000) {\n"
"    printf(\"\\033[2J\\033[1;1H\") /* clear screen \\*/\n"
"    printf(\"%6s %80s %6s %30s %6s\\n\",\n"
"           \"PID\", \"FILENAME\", \"LINE\", \"FUNCTION\", \"CALLS\")\n"
"    foreach ([pid, filename, funcname, lineno] in fn_calls- limit 20) {\n"
"        printf(\"%6d %80s %6d %30s %6d\\n\",\n"
"            pid, filename, lineno, funcname,\n"
"            fn_calls[pid, filename, funcname, lineno]);\n"
"    }\n"
"    delete fn_calls;\n"
"}"
