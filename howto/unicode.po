# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Unicode HOWTO"
msgstr "Unicode HOWTO"

msgid "Release"
msgstr "Release"

msgid "1.12"
msgstr "1.12"

msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"Denna HOWTO diskuterar Pythons st√∂d f√∂r Unicode-specifikationen f√∂r att "
"representera textdata, och f√∂rklarar olika problem som m√§nniskor ofta st√∂ter "
"p√• n√§r de f√∂rs√∂ker arbeta med Unicode."

msgid "Introduction to Unicode"
msgstr "Introduktion till Unicode"

msgid "Definitions"
msgstr "Definitioner"

msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a "
"variety of user-selectable languages; the same program might need to output "
"an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for "
"representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"Dagens program m√•ste kunna hantera en stor m√§ngd olika tecken.  "
"Applikationer √§r ofta internationaliserade f√∂r att visa meddelanden och "
"utdata p√• en m√§ngd olika spr√•k som kan v√§ljas av anv√§ndaren; samma program "
"kan beh√∂va skriva ut ett felmeddelande p√• engelska, franska, japanska, "
"hebreiska eller ryska.  Webbinneh√•ll kan skrivas p√• vilket som helst av "
"dessa spr√•k och kan √§ven inneh√•lla en m√§ngd olika emoji-symboler. Pythons "
"str√§ngtyp anv√§nder Unicode-standarden f√∂r att representera tecken, vilket "
"g√∂r att Python-program kan arbeta med alla dessa olika m√∂jliga tecken."

msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated "
"to add new languages and symbols."
msgstr ""
"Unicode (https://www.unicode.org/) √§r en specifikation som syftar till att "
"lista alla tecken som anv√§nds av m√§nskliga spr√•k och ge varje tecken sin "
"egen unika kod.  Unicode-specifikationerna revideras och uppdateras "
"kontinuerligt f√∂r att l√§gga till nya spr√•k och symboler."

msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are '√à' and '√ç'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", '‚Ö†', that's separate "
"from the uppercase letter 'I'.  They'll usually look the same, but these are "
"two different characters that have different meanings."
msgstr ""
"Ett **tecken** √§r den minsta m√∂jliga best√•ndsdelen i en text.  \"A\", \"B\", "
"\"C\" osv. √§r alla olika tecken.  Det √§r √§ven \"√à\" och \"√ç\".  Tecknen "
"varierar beroende p√• vilket spr√•k eller sammanhang man talar om.  Det finns "
"till exempel ett tecken f√∂r \"romersk siffra ett\", \"‚Ö†\", som √§r skilt fr√•n "
"versalbokstaven \"I\".  De ser vanligtvis likadana ut, men det √§r tv√• olika "
"tecken som har olika betydelser."

msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned <https://www.unicode."
"org/versions/latest/#Summary>`_ is less than that). In the standard and in "
"this document, a code point is written using the notation ``U+265E`` to mean "
"the character with value ``0x265e`` (9,822 in decimal)."
msgstr ""
"Unicode-standarden beskriver hur tecken representeras av **kodpunkter**.  "
"Ett kodpunktsv√§rde √§r ett heltal i intervallet 0 till 0x10FFFF (ca 1,1 "
"miljoner v√§rden, det `verkliga antalet tilldelade <https://www.unicode.org/"
"versions/latest/#Summary>`_ √§r mindre √§n s√•). I standarden och i detta "
"dokument skrivs en kodpunkt med notationen ``U+265E`` f√∂r att beteckna "
"tecknet med v√§rdet ``0x265e`` (9.822 i decimal)."

msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr ""
"Unicode-standarden inneh√•ller en m√§ngd tabeller med tecken och deras "
"motsvarande kodpunkter:"

msgid ""
"0061    'a'; LATIN SMALL LETTER A\n"
"0062    'b'; LATIN SMALL LETTER B\n"
"0063    'c'; LATIN SMALL LETTER C\n"
"...\n"
"007B    '{'; LEFT CURLY BRACKET\n"
"...\n"
"2167    '‚Öß'; ROMAN NUMERAL EIGHT\n"
"2168    '‚Ö®'; ROMAN NUMERAL NINE\n"
"...\n"
"265E    '‚ôû'; BLACK CHESS KNIGHT\n"
"265F    '‚ôü'; BLACK CHESS PAWN\n"
"...\n"
"1F600   'üòÄ'; GRINNING FACE\n"
"1F609   'üòâ'; WINKING FACE\n"
"..."
msgstr ""
"0061 \"a\"; LATINSK SM√Ö BOKSTAV A\n"
"0062 \"b\"; LATINSKA SM√Ö BOKSTAVAR B\n"
"0063 \"c\"; LATINSKA SM√Ö BOKSTAVAR C\n"
"...\n"
"007B '{'; V√ÑNSTER SNIRKLIG HAKPARENTES\n"
"...\n"
"2167 '‚Öß'; ROMERSK SIFFRA √ÖTTA\n"
"2168 '‚Ö®'; ROMERSK SIFFRA NIO\n"
"...\n"
"265E '‚ôû'; SVART SCHACKSPRINGAR\n"
"265F '‚ôü'; SVART SCHACKBONDE\n"
"...\n"
"1F600 'üòÄ'; FLINANDE ANSIKTE\n"
"1F609 'üòâ'; BLINKANDE ANSIKTE\n"
"..."

msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS "
"KNIGHT', '‚ôû'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"Strikt taget inneb√§r dessa definitioner att det √§r meningsl√∂st att s√§ga "
"\"detta √§r tecknet ``U+265E``\".  ``U+265E`` √§r en kodpunkt som "
"representerar ett visst tecken; i detta fall representerar den tecknet "
"'BLACK CHESS KNIGHT', '‚ôû'.  I informella sammanhang gl√∂ms ibland denna "
"distinktion mellan kodpunkter och tecken bort."

msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"Ett tecken representeras p√• en sk√§rm eller p√• papper av en upps√§ttning "
"grafiska element som kallas f√∂r en **glyf**.  Glyfen f√∂r ett stort A, till "
"exempel, √§r tv√• diagonala streck och ett horisontellt streck, men de exakta "
"detaljerna beror p√• vilket typsnitt som anv√§nds.  Den mesta Python-koden "
"beh√∂ver inte oroa sig f√∂r glyfer; att r√§kna ut vilken glyf som ska visas √§r "
"i allm√§nhet ett jobb f√∂r en GUI-verktygsl√•da eller en terminals "
"typsnittsrendering."

msgid "Encodings"
msgstr "Kodningar"

msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a "
"**character encoding**, or just an **encoding**."
msgstr ""
"F√∂r att sammanfatta f√∂reg√•ende avsnitt: en Unicode-str√§ng √§r en sekvens av "
"kodpunkter, som √§r siffror fr√•n 0 till ``0x10FFFF`` (1.114.111 decimalt).  "
"Denna sekvens av kodpunkter m√•ste representeras i minnet som en upps√§ttning "
"**kodenheter**, och **kodenheter** mappas sedan till 8-bitars bytes.  "
"Reglerna f√∂r att √∂vers√§tta en Unicode-str√§ng till en sekvens av bytes kallas "
"en **teckenkodning**, eller bara en **kodning**."

msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"Den f√∂rsta kodningen du kan t√§nka dig √§r att anv√§nda 32-bitars heltal som "
"kodningsenhet och sedan anv√§nda CPU:ns representation av 32-bitars heltal. I "
"den h√§r representationen kan str√§ngen \"Python\" se ut s√• h√§r:"

msgid ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
msgstr ""
"   P y t t h o n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00 "
"00\n"
"   0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"

msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr ""
"Denna representation √§r okomplicerad, men det finns ett antal problem med "
"att anv√§nda den."

msgid "It's not portable; different processors order the bytes differently."
msgstr "Den √§r inte portabel; olika processorer ordnar bytena p√• olika s√§tt."

msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"Det √§r mycket sl√∂saktigt med utrymme.  I de flesta texter √§r majoriteten av "
"kodpunkterna mindre √§n 127 eller mindre √§n 255, s√• en hel del utrymme upptas "
"av ``0x00`` bytes.  Ovanst√•ende str√§ng tar 24 byte j√§mf√∂rt med de 6 byte som "
"beh√∂vs f√∂r en ASCII-representation.  √ñkad RAM-anv√§ndning spelar inte s√• stor "
"roll (station√§ra datorer har gigabyte RAM och str√§ngar √§r vanligtvis inte s√• "
"stora), men att ut√∂ka v√•r anv√§ndning av disk- och n√§tverksbandbredd med en "
"faktor 4 √§r oacceptabelt."

msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr ""
"Det √§r inte kompatibelt med befintliga C-funktioner som ``strlen()``, s√• en "
"ny familj av breda str√§ngfunktioner skulle beh√∂va anv√§ndas."

msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr ""
"D√§rf√∂r anv√§nds inte den h√§r kodningen s√§rskilt mycket, och folk v√§ljer "
"ist√§llet andra kodningar som √§r mer effektiva och praktiska, till exempel "
"UTF-8."

msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 √§r en av de vanligaste kodningarna och Python anv√§nder den ofta som "
"standard.  UTF st√•r f√∂r \"Unicode Transformation Format\", och \"8\" betyder "
"att 8-bitarsv√§rden anv√§nds i kodningen.  (Det finns √§ven UTF-16- och UTF-32-"
"kodningar, men de anv√§nds mer s√§llan √§n UTF-8.)  UTF-8 anv√§nder f√∂ljande "
"regler:"

msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr "Om kodpunkten √§r < 128 representeras den av motsvarande bytev√§rde."

msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"Om kodpunkten √§r >= 128 omvandlas den till en sekvens av tv√•, tre eller fyra "
"byte, d√§r varje byte i sekvensen √§r mellan 128 och 255."

msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 har flera praktiska egenskaper:"

msgid "It can handle any Unicode code point."
msgstr "Den kan hantera alla Unicode-kodpunkter."

msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means "
"that UTF-8 strings can be processed by C functions such as ``strcpy()`` and "
"sent through protocols that can't handle zero bytes for anything other than "
"end-of-string markers."
msgstr ""
"En Unicode-str√§ng omvandlas till en sekvens av bytes som inneh√•ller "
"inb√§ddade nollbytes endast d√§r de representerar nolltecknet (U+0000). Detta "
"inneb√§r att UTF-8-str√§ngar kan bearbetas av C-funktioner som ``strcpy()`` "
"och skickas via protokoll som inte kan hantera nollbytes f√∂r n√•got annat √§n "
"mark√∂rer f√∂r str√§ngens slut."

msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "En str√§ng med ASCII-text √§r ocks√• giltig UTF-8-text."

msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr ""
"UTF-8 √§r ganska kompakt; de flesta vanliga tecken kan representeras med en "
"eller tv√• byte."

msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"Om byte skadas eller f√∂rloras √§r det m√∂jligt att best√§mma b√∂rjan p√• n√§sta "
"UTF-8-kodade kodpunkt och synkronisera p√• nytt.  Det √§r ocks√• osannolikt att "
"slumpm√§ssiga 8-bitarsdata ser ut som giltig UTF-8."

msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 √§r en byteorienterad kodning. Kodningen anger att varje tecken "
"representeras av en specifik sekvens av en eller flera byte. P√• s√• s√§tt "
"undviks de problem med byte-ordning som kan uppst√• med heltals- och "
"ordorienterade kodningar, som UTF-16 och UTF-32, d√§r byte-sekvensen varierar "
"beroende p√• den maskinvara som str√§ngen kodades med."

msgid "References"
msgstr "Referenser"

msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <https://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"P√• Unicode Consortiums webbplats <https://www.unicode.org>`_ finns "
"teckenkartor, en ordlista och PDF-versioner av Unicode-specifikationen.  Var "
"beredd p√• en del sv√•r l√§sning.  en kronologi <https://www.unicode.org/"
"history/>`_ √∂ver Unicodes ursprung och utveckling finns ocks√• p√• webbplatsen."

msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutes 36 seconds)."
msgstr ""
"P√• Computerphiles Youtube-kanal diskuterar Tom Scott kortfattat historien om "
"Unicode och UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ (9 minuter "
"och 36 sekunder)."

msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"F√∂r att hj√§lpa till att f√∂rst√• standarden har Jukka Korpela skrivit en "
"\"introduktionsguide <https://jkorpela.fi/unicode/guide.html>`_ till l√§sning "
"av Unicodes teckentabeller\"."

msgid ""
"Another `good introductory article <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ was "
"written by Joel Spolsky. If this introduction didn't make things clear to "
"you, you should try reading this alternate article before continuing."
msgstr ""
"En annan \"bra introduktionsartikel\" <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ skrevs "
"av Joel Spolsky. Om den h√§r introduktionen inte klargjorde saker f√∂r dig, "
"b√∂r du f√∂rs√∂ka l√§sa den h√§r alternativa artikeln innan du forts√§tter."

msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"Wikipedia-poster √§r ofta till stor hj√§lp, se till exempel posterna f√∂r "
"\"teckenkodning <https://en.wikipedia.org/wiki/Character_encoding>`_\" och "
"\"UTF-8 <https://en.wikipedia.org/wiki/UTF-8>`_\"."

msgid "Python's Unicode Support"
msgstr "Pythons st√∂d f√∂r Unicode"

msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr ""
"Nu n√§r du har l√§rt dig grunderna i Unicode kan vi titta p√• Pythons Unicode-"
"funktioner."

msgid "The String Type"
msgstr "Typ av str√§ng"

msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"Sedan Python 3.0 inneh√•ller spr√•kets typ :class:`str` Unicode-tecken, vilket "
"inneb√§r att alla str√§ngar som skapas med hj√§lp av ``\"unicode rocks!\"``, "
"``'unicode rocks!\"`` eller str√§ngsyntaxen med tre citattecken lagras som "
"Unicode."

msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"Standardkodningen f√∂r Python-k√§llkod √§r UTF-8, s√• du kan helt enkelt "
"inkludera ett Unicode-tecken i en str√§nglitteral::"

msgid ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # 'File not found' error message.\n"
"    print(\"Fichier non trouv√©\")"
msgstr ""
"f√∂rs√∂k:\n"
"    med open('/tmp/input.txt', 'r') som f:\n"
"        ...\n"
"except OSError:\n"
"    # Felmeddelandet \"Filen hittades inte\".\n"
"    print(\"Fichier non trouv√©\")"

msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr "Python 3 st√∂der ocks√• anv√§ndning av Unicode-tecken i identifierare::"

msgid ""
"r√©pertoire = \"/tmp/records.log\"\n"
"with open(r√©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"
msgstr ""
"r√©pertoire = \"/tmp/records.log\"\n"
"med open(r√©pertoire, \"w\") som f:\n"
"    f.write(\"test\\n\")"

msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"Om du inte kan ange ett visst tecken i din editor eller om du av n√•gon "
"anledning vill beh√•lla k√§llkoden som ASCII-only, kan du ocks√• anv√§nda escape-"
"sekvenser i str√§nglitteraler. (Beroende p√• ditt system kan det h√§nda att du "
"ser den faktiska glyfen capital-delta i st√§llet f√∂r en \\u-escape) ::"

msgid ""
">>> \"\\N{GREEK CAPITAL LETTER DELTA}\"  # Using the character name\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Using a 16-bit hex value\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Using a 32-bit hex value\n"
"'\\u0394'"
msgstr ""
">>> \"\\N{GREKISK STOR BOKSTAV DELTA}\"  # Anv√§nda teckenets namn\n"
"'\\u0394'\n"
">>> \"\\u0394\" # Anv√§nder ett 16-bitars hexv√§rde\n"
"'\\u0394'\n"
">>> \"\\U00000394\" # Anv√§nder ett 32-bitars hex-v√§rde\n"
"'\\u0394'"

msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"Dessutom kan man skapa en str√§ng med hj√§lp av :func:`~bytes.decode`-metoden "
"i :class:`bytes`.  Denna metod tar ett *kodnings*argument, till exempel "
"``UTF-8``, och eventuellt ett *fel*argument."

msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"Argumentet *errors* anger svaret n√§r indatastr√§ngen inte kan konverteras "
"enligt kodningens regler.  Legala v√§rden f√∂r detta argument √§r ``'strict'`` "
"(ger ett :exc:`UnicodeDecodeError` undantag), ``'replace'`` (anv√§nder "
"``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` (l√§mnar bara tecknet "
"utanf√∂r Unicode-resultatet), eller ``'backslashreplace'`` (infogar en "
"``xNN`` escape-sekvens). F√∂ljande exempel visar skillnaderna::"

msgid ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\n"
"  invalid start byte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"
msgstr ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8'-kodeken kan inte avkoda byte 0x80 i position 0:\n"
"  ogiltig startbyte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignorera\")\n"
"'abc'"

msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference "
"at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"Kodningar anges som str√§ngar som inneh√•ller kodningens namn.  Python kommer "
"med ungef√§r 100 olika kodningar; se Python Library Reference p√• :ref:"
"`standard-encodings` f√∂r en lista.  Vissa kodningar har flera namn; till "
"exempel √§r ``'latin-1'``, ``'iso_8859_1'`` och ``'8859`` alla synonymer f√∂r "
"samma kodning."

msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"Unicode-str√§ngar med ett tecken kan ocks√• skapas med den inbyggda "
"funktionen :func:`chr`, som tar heltal och returnerar en Unicode-str√§ng med "
"l√§ngden 1 som inneh√•ller motsvarande kodpunkt.  Den omv√§nda operationen √§r "
"den inbyggda funktionen :func:`ord` som tar en Unicode-str√§ng med ett tecken "
"och returnerar kodpunktsv√§rdet::"

msgid ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"
msgstr ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"

msgid "Converting to Bytes"
msgstr "Konvertering till byte"

msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
"Den motsatta metoden till :meth:`bytes.decode` √§r :meth:`str.encode`, som "
"returnerar en :class:`bytes`-representation av Unicode-str√§ngen, kodad med "
"den beg√§rda *kodningen*."

msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"Parametern *errors* √§r densamma som parametern i metoden :meth:`~bytes."
"decode` men st√∂der n√•gra fler m√∂jliga hanteringar. F√∂rutom ``'strict'``, "
"``'ignore'`` och ``'replace'`` (som i det h√§r fallet infogar ett fr√•getecken "
"i st√§llet f√∂r det okodbara tecknet), finns det ocks√• ``'xmlcharrefreplace'`` "
"(infogar en XML-teckenreferens), ``backslashreplace`` (infogar en ``uNNNN`` "
"escapesequence) och ``namereplace`` (infogar en ``N{...}`` escapesequence)."

msgid "The following example shows the different results::"
msgstr "F√∂ljande exempel visar de olika resultaten::"

msgid ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\n"
"  position 0: ordinal not in range(128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"
msgstr ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.kodning('ascii')\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii'-kodeken kan inte koda tecknet '\\ua000' i\n"
"  position 0: ordinal inte inom intervall(128)\n"
">>> u.encode('ascii', 'ignorera')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'ÍÄÄabcdﬁ¥'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"

msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"L√•gniv√•rutinerna f√∂r registrering och √•tkomst av tillg√§ngliga kodningar "
"finns i modulen :mod:`codecs`.  F√∂r att implementera nya kodningar kr√§vs "
"ocks√• att man f√∂rst√•r modulen :mod:`codecs`. De kodnings- och "
"avkodningsfunktioner som returneras av denna modul √§r dock vanligtvis mer "
"l√•gniv√• √§n vad som √§r bekv√§mt, och att skriva nya kodningar √§r en "
"specialiserad uppgift, s√• modulen kommer inte att behandlas i denna HOWTO."

msgid "Unicode Literals in Python Source Code"
msgstr "Unicode-bokst√§ver i Python-k√§llkod"

msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"I Python-k√§llkod kan specifika Unicode-kodpunkter skrivas med hj√§lp av "
"escape-sekvensen ``u``, som f√∂ljs av fyra hexadecimaler som anger "
"kodpunkten.  Escapesequencen ``U`` √§r liknande, men f√∂rv√§ntar sig √•tta "
"hexadecimaler, inte fyra::"

msgid ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ two-digit hex escape\n"
"... #         ^^^^^^ four-digit Unicode escape\n"
"... #                     ^^^^^^^^^^ eight-digit Unicode escape\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"
msgstr ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... # ^^^^ tv√•siffrig hex escape\n"
"... # ^^^^^^ fyrsiffrig Unicode-escape\n"
"... # ^^^^^^^^^^ √•ttasiffrig Unicode-escape\n"
">>> [ord(c) f√∂r c i s]\n"
"[97, 172, 4660, 8364, 32768]"

msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"Att anv√§nda escape-sekvenser f√∂r kodpunkter st√∂rre √§n 127 √§r bra i sm√• "
"doser, men blir ett irritationsmoment om du anv√§nder m√•nga tecken med "
"accent, som i ett program med meddelanden p√• franska eller n√•got annat spr√•k "
"med accent.  Du kan ocks√• s√§tta ihop str√§ngar med hj√§lp av den inbyggda "
"funktionen :func:`chr`, men det √§r √§nnu mer omst√§ndligt."

msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"Helst skulle du vilja kunna skriva litteraler i ditt spr√•ks naturliga "
"kodning.  Du kan sedan redigera Python-k√§llkod med din favoritredigerare som "
"visar de accentuerade tecknen naturligt och har r√§tt tecken som anv√§nds vid "
"k√∂rning."

msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"Python st√∂der som standard skrivning av k√§llkod i UTF-8, men du kan anv√§nda "
"n√§stan vilken kodning som helst om du deklarerar den kodning som anv√§nds.  "
"Detta g√∂rs genom att inkludera en speciell kommentar som antingen den f√∂rsta "
"eller andra raden i k√§llfilen::"

msgid ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"
msgstr ""
"#!/usr/bin/env python\n"
"# -*- kodning: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"

msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"Syntaxen √§r inspirerad av Emacs notation f√∂r att ange variabler som √§r "
"lokala i en fil.  Emacs st√∂der m√•nga olika variabler, men Python st√∂der bara "
"'coding'.  Symbolerna ``-*-`` anger f√∂r Emacs att kommentaren √§r speciell; "
"de har ingen betydelse f√∂r Python utan √§r en konvention.  Python letar efter "
"``coding: name`` eller ``coding=name`` i kommentaren."

msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"Om du inte inkluderar en s√•dan kommentar kommer standardkodningen som "
"anv√§nds att vara UTF-8 som redan n√§mnts.  Se √§ven :pep:`263` f√∂r mer "
"information."

msgid "Unicode Properties"
msgstr "Unicode-egenskaper"

msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"Unicode-specifikationen inneh√•ller en databas med information om "
"kodpunkter.  F√∂r varje definierad kodpunkt inneh√•ller informationen tecknets "
"namn, dess kategori, det numeriska v√§rdet om till√§mpligt (f√∂r tecken som "
"representerar numeriska begrepp som romerska siffror, br√•k som en tredjedel "
"och fyra femtedelar etc.)  Det finns ocks√• visningsrelaterade egenskaper, t."
"ex. hur kodpunkten ska anv√§ndas i dubbelriktad text."

msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr ""
"F√∂ljande program visar lite information om flera tecken och skriver ut det "
"numeriska v√§rdet f√∂r ett visst tecken::"

msgid ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"
msgstr ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"

msgid "When run, this prints:"
msgstr "N√§r det k√∂rs skrivs det ut:"

msgid ""
"0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n"
"1 0bf2 No TAMIL NUMBER ONE THOUSAND\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"
msgstr ""
"0 00e9 Ll LATINSKA SM√Ö BOKST√ÑVER E MED ACUTE\n"
"1 0bf2 No TAMIL NUMBER ETT TUSEN\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"

msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"Kategorikoderna √§r f√∂rkortningar som beskriver karakt√§ren p√• tecknet. De "
"grupperas i kategorier som \"Letter\", \"Number\", \"Punctuation\" eller "
"\"Symbol\", som i sin tur delas upp i underkategorier.  F√∂r att ta koderna "
"fr√•n ovanst√•ende utdata betyder ``'Ll'`` \"Letter, lowercase\", ``'No'`` "
"betyder \"Number, other\", ``'Mn'`` √§r \"Mark, nonspacing\" och ``'So'`` √§r "
"\"Symbol, other\".  Se avsnittet \"General Category Values\" i "
"dokumentationen f√∂r Unicode Character Database <https://www.unicode.org/"
"reports/tr44/#General_Category_Values>`_ f√∂r en lista √∂ver kategorikoder."

msgid "Comparing Strings"
msgstr "J√§mf√∂relse av str√§ngar"

msgid ""
"Unicode adds some complication to comparing strings, because the same set of "
"characters can be represented by different sequences of code points.  For "
"example, a letter like '√™' can be represented as a single code point U+00EA, "
"or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output "
"when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"Unicode g√∂r det lite sv√•rare att j√§mf√∂ra str√§ngar eftersom samma upps√§ttning "
"tecken kan representeras av olika sekvenser av kodpunkter.  Till exempel kan "
"en bokstav som \"√™\" representeras som en enda kodpunkt U+00EA, eller som "
"U+0065 U+0302, vilket √§r kodpunkten f√∂r \"e\" f√∂ljt av en kodpunkt f√∂r "
"\"COMBINING CIRCUMFLEX ACCENT\".  Dessa ger samma resultat n√§r de skrivs ut, "
"men den ena √§r en str√§ng med l√§ngd 1 och den andra har l√§ngd 2."

msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an "
"algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter '√ü' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"Ett verktyg f√∂r en j√§mf√∂relse som inte tar h√§nsyn till versaler √§r "
"str√§ngmetoden :meth:`~str.casefold` som omvandlar en str√§ng till en form som "
"inte tar h√§nsyn till versaler enligt en algoritm som beskrivs i Unicode-"
"standarden.  Denna algoritm har s√§rskild hantering f√∂r tecken som den tyska "
"bokstaven \"√ü\" (kodpunkt U+00DF), som blir ett par gemena bokst√§ver \"ss\"."

msgid ""
">>> street = 'G√ºrzenichstra√üe'\n"
">>> street.casefold()\n"
"'g√ºrzenichstrasse'"
msgstr ""
">>> gata = 'G√ºrzenichstra√üe'\n"
">>> gata.casefold()\n"
"'g√ºrzenichstrasse'"

msgid ""
"A second tool is the :mod:`unicodedata` module's :func:`~unicodedata."
"normalize` function that converts strings to one of several normal forms, "
"where letters followed by a combining character are replaced with single "
"characters.  :func:`~unicodedata.normalize` can be used to perform string "
"comparisons that won't falsely report inequality if two strings use "
"combining characters differently:"
msgstr ""
"Ett annat verktyg √§r :mod:`unicodedata`-modulens funktion :func:"
"`~unicodedata.normalize` som omvandlar str√§ngar till en av flera "
"normalformer, d√§r bokst√§ver som f√∂ljs av ett kombinationstecken ers√§tts med "
"enstaka tecken. :func:`~unicodedata.normalize` kan anv√§ndas f√∂r att utf√∂ra "
"str√§ngj√§mf√∂relser som inte felaktigt rapporterar oj√§mlikhet om tv√• str√§ngar "
"anv√§nder kombinationstecken p√• olika s√§tt:"

msgid ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"
msgstr ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"

msgid "When run, this outputs:"
msgstr "N√§r den k√∂rs matas den ut:"

msgid ""
"$ python compare-strs.py\n"
"length of first string= 1\n"
"length of second string= 2\n"
"True"
msgstr ""
"$ python j√§mf√∂r-str√§ngar.py\n"
"l√§ngd p√• f√∂rsta str√§ngen= 1\n"
"l√§ngd p√• andra str√§ngen= 2\n"
"Sant"

msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
"Det f√∂rsta argumentet till funktionen :func:`~unicodedata.normalize` √§r en "
"str√§ng som anger den √∂nskade normaliseringsformen, som kan vara en av 'NFC', "
"'NFKC', 'NFD' och 'NFKD'."

msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr "Unicode-standarden anger ocks√• hur man g√∂r j√§mf√∂relser utan versaler::"

msgid ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"
msgstr ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"

msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See section "
"3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"Detta kommer att skriva ut ``True``.  (Varf√∂r anropas :func:`!NFD` tv√• "
"g√•nger?  F√∂r att det finns n√•gra tecken som g√∂r att :meth:`~str.casefold` "
"returnerar en icke-normaliserad str√§ng, s√• resultatet m√•ste normaliseras "
"igen. Se avsnitt 3.13 i Unicode-standarden f√∂r en diskussion och ett exempel)"

msgid "Unicode Regular Expressions"
msgstr "Regulj√§ra uttryck i Unicode"

msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
"De regulj√§ra uttryck som st√∂ds av modulen :mod:`re` kan anges antingen som "
"bytes eller str√§ngar.  Vissa av specialteckensekvenserna, t.ex. ``d`` och "
"``w``, har olika betydelse beroende p√• om m√∂nstret anges som bytes eller "
"str√§ngar.  Till exempel kommer ``d`` att matcha tecknen ``[0-9]`` i byte men "
"i str√§ngar kommer det att matcha alla tecken som √§r i kategorin ``'Nd'``."

msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr ""
"Str√§ngen i det h√§r exemplet har numret 57 skrivet med b√•de thail√§ndska och "
"arabiska siffror::"

msgid ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"
msgstr ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"

msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"N√§r ``\\d+`` exekveras kommer den att matcha de thail√§ndska siffrorna och "
"skriva ut dem.  Om du anger flaggan :const:`re.ASCII` till :func:`~re."
"compile`, kommer ``d+`` att matcha substr√§ngen \"57\" ist√§llet."

msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"P√• samma s√§tt matchar ``\\w`` ett stort antal Unicode-tecken men bara ``[a-"
"zA-Z0-9_]`` i byte eller om :const:`re.ASCII` anges, och ``s`` matchar "
"antingen Unicode-tecken f√∂r blanksteg eller ``[ \\t\\n\\r\\f\\v]``."

msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "N√•gra bra alternativa diskussioner om Pythons Unicode-st√∂d √§r:"

msgid ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, av Nick Coghlan."

msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, en PyCon "
"2012-presentation av Ned Batchelder."

msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ""
"Typen :class:`str` beskrivs i Python-bibliotekets referens p√• :ref:`textseq`."

msgid "The documentation for the :mod:`unicodedata` module."
msgstr "Dokumentationen f√∂r modulen :mod:`unicodedata`."

msgid "The documentation for the :mod:`codecs` module."
msgstr "Dokumentationen f√∂r modulen :mod:`codecs`."

msgid ""
"Marc-Andr√© Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-Andr√© Lemburg gav `en presentation med titeln \"Python and "
"Unicode\" (PDF slides) <https://downloads.egenix.com/python/Unicode-EPC2002-"
"Talk.pdf>`_ p√• EuroPython 2002.  Bilderna √§r en utm√§rkt √∂versikt √∂ver "
"utformningen av Python 2:s Unicode-funktioner (d√§r Unicode-str√§ngtypen "
"kallas ``unicode`` och literaler b√∂rjar med ``u``)."

msgid "Reading and Writing Unicode Data"
msgstr "L√§sa och skriva Unicode-data"

msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"N√§r du har skrivit kod som fungerar med Unicode-data √§r n√§sta problem input/"
"output.  Hur f√•r du in Unicode-str√§ngar i ditt program och hur konverterar "
"du Unicode till en form som √§r l√§mplig f√∂r lagring eller √∂verf√∂ring?"

msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"Det √§r m√∂jligt att du inte beh√∂ver g√∂ra n√•gonting beroende p√• dina "
"inmatningsk√§llor och utmatningsdestinationer; du b√∂r kontrollera om de "
"bibliotek som anv√§nds i din applikation st√∂der Unicode nativt.  XML-parsers "
"returnerar ofta Unicode-data, till exempel.  M√•nga relationsdatabaser st√∂der "
"ocks√• Unicode-v√§rderade kolumner och kan returnera Unicode-v√§rden fr√•n en "
"SQL-fr√•ga."

msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Unicode-data konverteras vanligtvis till en viss kodning innan de skrivs "
"till disk eller skickas √∂ver ett uttag.  Det √§r m√∂jligt att g√∂ra allt arbete "
"sj√§lv: √∂ppna en fil, l√§s ett 8-bitars bytesobjekt fr√•n den och konvertera "
"bytena med ``bytes.decode(encoding)``.  Det manuella tillv√§gag√•ngss√§ttet "
"rekommenderas dock inte."

msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"Ett problem √§r att kodningarna best√•r av flera byte; ett Unicode-tecken kan "
"representeras av flera byte.  Om du vill l√§sa filen i godtyckligt stora "
"bitar (t.ex. 1024 eller 4096 byte) m√•ste du skriva felhanteringskod f√∂r att "
"f√•nga upp det fall d√§r endast en del av de byte som kodar ett enda Unicode-"
"tecken l√§ses i slutet av en bit.  En l√∂sning skulle vara att l√§sa in hela "
"filen i minnet och sedan utf√∂ra avkodningen, men d√• kan man inte arbeta med "
"filer som √§r extremt stora; om man beh√∂ver l√§sa en fil p√• 2 GiB beh√∂ver man "
"2 GiB RAM. (Egentligen mer, eftersom du √•tminstone f√∂r ett √∂gonblick m√•ste "
"ha b√•de den kodade str√§ngen och dess Unicode-version i minnet)"

msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"L√∂sningen skulle vara att anv√§nda avkodningsgr√§nssnittet p√• l√•g niv√• f√∂r att "
"f√•nga upp fallet med partiella kodningssekvenser.  Arbetet med att "
"implementera detta har redan gjorts √•t dig: den inbyggda funktionen :func:"
"`open` kan returnera ett filliknande objekt som f√∂ruts√§tter att filens "
"inneh√•ll √§r i en angiven kodning och accepterar Unicode-parametrar f√∂r "
"metoder som :meth:`~io.TextIOBase.read` och :meth:`~io.TextIOBase.write`.  "
"Detta fungerar genom :func:`open` parametrar *encoding* och *errors* som "
"tolkas precis som de i :meth:`str.encode` och :meth:`bytes.decode`."

msgid "Reading Unicode from a file is therefore simple::"
msgstr "Att l√§sa Unicode fr√•n en fil √§r d√§rf√∂r enkelt::"

msgid ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"
msgstr ""
"med open('unicode.txt', encoding='utf-8') som f:\n"
"    f√∂r rad i f:\n"
"        print(repr(rad))"

msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr ""
"Det √§r ocks√• m√∂jligt att √∂ppna filer i uppdateringsl√§ge, vilket till√•ter "
"b√•de l√§sning och skrivning::"

msgid ""
"with open('test', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"
msgstr ""
"med open('test', encoding='utf-8', mode='w+') som f:\n"
"    f.write('\\u4500 blah blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1])))"

msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"Unicode-tecknet ``U+FEFF`` anv√§nds som en byte-order mark (BOM) och skrivs "
"ofta som det f√∂rsta tecknet i en fil f√∂r att hj√§lpa till med autodetektering "
"av filens byte-ordning.  Vissa kodningar, t.ex. UTF-16, f√∂rv√§ntar sig att en "
"BOM ska finnas i b√∂rjan av en fil; n√§r en s√•dan kodning anv√§nds skrivs BOM "
"automatiskt som f√∂rsta tecken och tappas tyst n√§r filen l√§ses.  Det finns "
"varianter av dessa kodningar, t.ex. \"utf-16-le\" och \"utf-16-be\" f√∂r "
"little-endian- och big-endian-kodningar, som anger en viss byteordning och "
"inte hoppar √∂ver BOM."

msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For "
"reading such files, use the 'utf-8-sig' codec to automatically skip the mark "
"if present."
msgstr ""
"Inom vissa omr√•den √§r det ocks√• vanligt att anv√§nda en \"BOM\" i b√∂rjan av "
"UTF-8-kodade filer; namnet √§r missvisande eftersom UTF-8 inte √§r "
"byteorderberoende. M√§rket meddelar helt enkelt att filen √§r kodad i UTF-8.  "
"F√∂r att l√§sa s√•dana filer, anv√§nd codec 'utf-8-sig' f√∂r att automatiskt "
"hoppa √∂ver markeringen om den finns."

msgid "Unicode filenames"
msgstr "Unicode-filnamn"

msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"De flesta operativsystem som anv√§nds idag har st√∂d f√∂r filnamn som "
"inneh√•ller godtyckliga Unicode-tecken.  Vanligtvis implementeras detta genom "
"att konvertera Unicode-str√§ngen till n√•gon kodning som varierar beroende p√• "
"systemet.  Idag konvergerar Python mot att anv√§nda UTF-8: Python p√• MacOS "
"har anv√§nt UTF-8 i flera versioner, och Python 3.6 bytte till att anv√§nda "
"UTF-8 √§ven p√• Windows.  P√• Unix-system kommer det bara att finnas en :term:"
"`filsystemkodning <filesystem encoding and error handler>`. om du har st√§llt "
"in milj√∂variablerna ``LANG`` eller ``LC_CTYPE``; om du inte har gjort det √§r "
"standardkodningen √•terigen UTF-8."

msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
"Funktionen :func:`sys.getfilesystemencoding` returnerar den kodning som ska "
"anv√§ndas p√• ditt nuvarande system, om du vill g√∂ra kodningen manuellt, men "
"det finns inte mycket anledning att bry sig om det.  N√§r du √∂ppnar en fil "
"f√∂r l√§sning eller skrivning kan du vanligtvis bara ange Unicode-str√§ngen som "
"filnamn, s√• konverteras den automatiskt till r√§tt kodning f√∂r dig::"

msgid ""
"filename = 'filename\\u4500abc'\n"
"with open(filename, 'w') as f:\n"
"    f.write('blah\\n')"
msgstr ""
"filnamn = 'filnamn\\u4500abc'\n"
"med open(filnamn, 'w') som f:\n"
"    f.write('blah\\n')"

msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ""
"Funktioner i modulen :mod:`os`, t.ex. :func:`os.stat`, accepterar ocks√• "
"Unicode-filnamn."

msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` can do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
"Funktionen :func:`os.listdir` returnerar filnamn, vilket v√§cker en fr√•ga: "
"ska den returnera Unicode-versionen av filnamnen, eller ska den returnera "
"byte som inneh√•ller de kodade versionerna? :func:`os.listdir` kan g√∂ra b√•da, "
"beroende p√• om du angav katalogs√∂kv√§gen som byte eller en Unicode-str√§ng.  "
"Om du anger en Unicode-str√§ng som s√∂kv√§g kommer filnamnen att avkodas med "
"filsystemets kodning och en lista med Unicode-str√§ngar kommer att "
"returneras, medan en byte-s√∂kv√§g returnerar filnamnen som bytes.  Om man t."
"ex. antar att standard :term:`filsystemkodning <filesystem encoding and "
"error handler>` √§r UTF-8, k√∂rs f√∂ljande program::"

msgid ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"
msgstr ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"

msgid "will produce the following output:"
msgstr "kommer att ge f√∂ljande resultat:"

msgid ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filename\\u4500abc', ...]"
msgstr ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filnamn\\u4500abc', ...]"

msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr ""
"Den f√∂rsta listan inneh√•ller UTF-8-kodade filnamn och den andra listan "
"inneh√•ller Unicode-versionerna."

msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"Observera att vid de flesta tillf√§llen b√∂r du bara h√•lla dig till att "
"anv√§nda Unicode med dessa API:er.  Bytes-API:erna b√∂r endast anv√§ndas p√• "
"system d√§r oavkodbara filnamn kan f√∂rekomma; det √§r i stort sett bara Unix-"
"system nu."

msgid "Tips for Writing Unicode-aware Programs"
msgstr "Tips f√∂r att skriva Unicode-anpassade program"

msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr ""
"I detta avsnitt ges n√•gra f√∂rslag p√• hur man skriver programvara som "
"hanterar Unicode."

msgid "The most important tip is:"
msgstr "Det viktigaste tipset √§r:"

msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"Programvaran ska bara arbeta med Unicode-str√§ngar internt, avkoda indata s√• "
"snart som m√∂jligt och koda utdata f√∂rst i slutet."

msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"Om du f√∂rs√∂ker skriva bearbetningsfunktioner som accepterar b√•de Unicode och "
"byte-str√§ngar, kommer du att uppt√§cka att ditt program √§r s√•rbart f√∂r buggar "
"varhelst du kombinerar de tv√• olika typerna av str√§ngar.  Det finns ingen "
"automatisk kodning eller avkodning: om du g√∂r t.ex. ``str + bytes``, kommer "
"ett :exc:`TypeError` att uppst√•."

msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"N√§r du anv√§nder data som kommer fr√•n en webbl√§sare eller n√•gon annan "
"op√•litlig k√§lla √§r det vanligt att du kontrollerar om det finns olagliga "
"tecken i en str√§ng innan du anv√§nder str√§ngen i en genererad kommandorad "
"eller lagrar den i en databas.  Om du g√∂r detta b√∂r du vara noga med att "
"kontrollera den avkodade str√§ngen, inte de kodade bytesdata; vissa kodningar "
"kan ha intressanta egenskaper, t.ex. att de inte √§r bijektiva eller inte √§r "
"helt ASCII-kompatibla.  Detta g√§ller s√§rskilt om indata ocks√• anger "
"kodningen, eftersom angriparen d√• kan v√§lja ett smart s√§tt att d√∂lja skadlig "
"text i den kodade bytestr√∂mmen."

msgid "Converting Between File Encodings"
msgstr "Konvertering mellan filkodningar"

msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
"Klassen :class:`~codecs.StreamRecoder` kan p√• ett transparent s√§tt "
"konvertera mellan kodningar genom att ta en str√∂m som returnerar data i "
"kodning #1 och bete sig som en str√∂m som returnerar data i kodning #2."

msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"Om du till exempel har en inmatningsfil *f* som √§r i Latin-1 kan du linda in "
"den med en :class:`~codecs.StreamRecoder` f√∂r att returnera byte som √§r "
"kodade i UTF-8::"

msgid ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: used by read() to encode its results and\n"
"    # by write() to decode its input.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # reader/writer: used to read and write to the stream.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"
msgstr ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: anv√§nds av read() f√∂r att koda dess resultat och\n"
"    # av write() f√∂r att avkoda dess indata.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # l√§sare/skrivare: anv√§nds f√∂r att l√§sa och skriva till str√∂mmen.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"

msgid "Files in an Unknown Encoding"
msgstr "Filer med ok√§nd kodning"

msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"Vad kan du g√∂ra om du beh√∂ver g√∂ra en √§ndring i en fil, men inte k√§nner till "
"filens kodning?  Om du vet att kodningen √§r ASCII-kompatibel och bara vill "
"unders√∂ka eller √§ndra ASCII-delarna, kan du √∂ppna filen med felhanteraren "
"``surrogateescape``::"

msgid ""
"with open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    data = f.read()\n"
"\n"
"# make changes to the string 'data'\n"
"\n"
"with open(fname + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(data)"
msgstr ""
"med open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") som f:\n"
"    data = f.read()\n"
"\n"
"# g√∂r √§ndringar i str√§ngen 'data'\n"
"\n"
"med open(fnamn + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") som f:\n"
"    f.write(data)"

msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"Felhanteraren ``surrogateescape`` avkodar alla icke-ASCII-bytes som "
"kodpunkter i ett speciellt intervall som str√§cker sig fr√•n U+DC80 till "
"U+DCFF.  Dessa kodpunkter f√∂rvandlas sedan tillbaka till samma byte n√§r "
"felhanteraren ``urrogateescape`` anv√§nds f√∂r att koda data och skriva ut den "
"igen."

msgid ""
"One section of `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"Ett avsnitt i `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, ett f√∂redrag av David "
"Beazley p√• PyCon 2010, handlar om textbehandling och bin√§r datahantering."

msgid ""
"The `PDF slides for Marc-Andr√© Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"PDF-slides f√∂r Marc-Andr√© Lemburgs presentation \"Writing Unicode-aware "
"Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ diskuterar fr√•gor om "
"teckenkodning samt hur man internationaliserar och lokaliserar en "
"applikation.  Dessa bilder t√§cker endast Python 2.x."

msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ √§r ett f√∂redrag p√• PyCon 2013 av Benjamin Peterson som "
"diskuterar den interna Unicode-representationen i Python 3.3."

msgid "Acknowledgements"
msgstr "Tack till"

msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"Det f√∂rsta utkastet till detta dokument skrevs av Andrew Kuchling. Det har "
"sedan reviderats ytterligare av Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling och Ezio Melotti."

msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: √âric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von L√∂wis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"Tack till f√∂ljande personer som har noterat felaktigheter eller l√§mnat "
"f√∂rslag p√• denna artikel: √âric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von L√∂wis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
