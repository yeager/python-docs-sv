# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`!ssl` --- TLS/SSL-omslag för socket-objekt"

msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Källkod:** :source:`Lib/ssl.py`"

msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"Den här modulen ger tillgång till Transport Layer Security (ofta kallat "
"\"Secure Sockets Layer\") kryptering och peer authentication för "
"nätverksuttag, både på klient- och serversidan.  Den här modulen använder "
"OpenSSL-biblioteket. Det är tillgängligt på alla moderna Unix-system, "
"Windows, macOS och förmodligen ytterligare plattformar, så länge OpenSSL är "
"installerat på den plattformen."

msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 comes with OpenSSL "
"version 1.1.1."
msgstr ""
"Vissa beteenden kan vara plattformsberoende, eftersom anrop görs till "
"operativsystemets socket-API:er.  Den installerade versionen av OpenSSL kan "
"också orsaka variationer i beteendet. TLSv1.3 levereras till exempel med "
"OpenSSL version 1.1.1."

msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"Använd inte den här modulen utan att läsa :ref:`ssl-security`.  Detta kan "
"leda till en falsk känsla av säkerhet, eftersom standardinställningarna för "
"ssl-modulen inte nödvändigtvis är lämpliga för din applikation."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"Detta avsnitt dokumenterar objekten och funktionerna i modulen ``ssl``; för "
"mer allmän information om TLS, SSL och certifikat hänvisas läsaren till "
"dokumenten i avsnittet \"Se även\" längst ned."

msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection or :meth:"
"`get_verified_chain`, :meth:`get_unverified_chain` which retrieves "
"certificate chain."
msgstr ""
"Den här modulen tillhandahåller en klass, :class:`ssl.SSLSocket`, som härrör "
"från typen :class:`socket.socket` och ger en socket-liknande omslag som "
"också krypterar och dekrypterar data som går över sockeln med SSL.  Den "
"stöder ytterligare metoder som :meth:`getpeercert`, som hämtar certifikatet "
"för den andra sidan av anslutningen, :meth:`cipher`, som hämtar det chiffer "
"som används för den säkra anslutningen eller :meth:`get_verified_chain`, :"
"meth:`get_unverified_chain` som hämtar certifikatkedjan."

msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"För mer sofistikerade applikationer hjälper klassen :class:`ssl.SSLContext` "
"till att hantera inställningar och certifikat, som sedan kan ärvas av SSL-"
"uttag som skapas genom metoden :meth:`SSLContext.wrap_socket`."

msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Uppdaterad för att stödja länkning med OpenSSL 1.1.0"

msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 och 1.0.1 är föråldrade och stöds inte längre. I "
"framtiden kommer ssl-modulen att kräva minst OpenSSL 1.0.2 eller 1.1.0."

msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ""
":pep:`644` har implementerats. Modulen ssl kräver OpenSSL 1.1.1 eller nyare."

msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr ""
"Användning av föråldrade konstanter och funktioner resulterar i varningar om "
"föråldring."

msgid "Functions, Constants, and Exceptions"
msgstr "Funktioner, konstanter och undantag"

msgid "Socket creation"
msgstr "Skapande av uttag"

msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method. The helper function :func:`create_default_context` "
"returns a new context with secure default settings."
msgstr ""
"Instanser av :class:`SSLSocket` måste skapas med hjälp av metoden :meth:"
"`SSLContext.wrap_socket`. Hjälpfunktionen :func:`create_default_context` "
"returnerar en ny kontext med säkra standardinställningar."

msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr "Exempel på klientuttag med standardkontext och IPv4/IPv6 dual stack::"

msgid ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"

msgid "Client socket example with custom context and IPv4::"
msgstr "Exempel på klientuttag med anpassad kontext och IPv4::"

msgid ""
"hostname = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT requires valid cert chain and hostname\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""
"värdnamn = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT kräver giltig certkedja och värdnamn\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"med socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) som sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"

msgid "Server socket example listening on localhost IPv4::"
msgstr "Serveruttag exempel lyssnar på localhost IPv4::"

msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.listen(5)\n"
"    with context.wrap_socket(sock, server_side=True) as ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')\n"
"\n"
"med socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) som sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.lyssna(5)\n"
"    med context.wrap_socket(sock, server_side=True) som ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."

msgid "Context creation"
msgstr "Skapande av kontext"

msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"En bekvämlighetsfunktion som hjälper till att skapa :class:`SSLContext`-"
"objekt för vanliga ändamål."

msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Returnerar ett nytt :class:`SSLContext`-objekt med standardinställningar för "
"det angivna *syftet*.  Inställningarna väljs av modulen :mod:`ssl` och "
"representerar vanligtvis en högre säkerhetsnivå än när man anropar "
"konstruktören :class:`SSLContext` direkt."

msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* representerar valfria CA-certifikat att lita på "
"för certifikatverifiering, som i :meth:`SSLContext.load_verify_locations`.  "
"Om alla tre är :const:`None` kan den här funktionen välja att lita på "
"systemets standardcertifikat från CA i stället."

msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` with "
"high encryption cipher suites without RC4 and without unauthenticated cipher "
"suites. Passing :const:`~Purpose.SERVER_AUTH` as *purpose* sets :data:"
"`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA "
"certificates (when at least one of *cafile*, *capath* or *cadata* is given) "
"or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""
"Inställningarna är: :data:`PROTOCOL_TLS_CLIENT` eller :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2` och :data:`OP_NO_SSLv3` med "
"chiffersviter med hög kryptering utan RC4 och utan oautentiserade "
"chiffersviter. Genom att ange :const:`~Purpose.SERVER_AUTH` som *purpose* "
"sätts :data:`~SSLContext.verify_mode` till :data:`CERT_REQUIRED` och "
"antingen laddas CA-certifikat (när minst en av *cafile*, *capath* eller "
"*cadata* anges) eller så används :meth:`SSLContext.load_default_certs` för "
"att ladda standard CA-certifikat."

msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"När :attr:`~SSLContext.keylog_filename` stöds och miljövariabeln :envvar:"
"`SSLKEYLOGFILE` är inställd, aktiverar :func:`create_default_context` "
"nyckelloggning."

msgid ""
"The default settings for this context include :data:"
"`VERIFY_X509_PARTIAL_CHAIN` and :data:`VERIFY_X509_STRICT`. These make the "
"underlying OpenSSL implementation behave more like a conforming "
"implementation of :rfc:`5280`, in exchange for a small amount of "
"incompatibility with older X.509 certificates."
msgstr ""
"Standardinställningarna för detta sammanhang inkluderar :data:"
"`VERIFY_X509_PARTIAL_CHAIN` och :data:`VERIFY_X509_STRICT`. Dessa gör att "
"den underliggande OpenSSL-implementeringen beter sig mer som en "
"överensstämmande implementering av :rfc:`5280`, i utbyte mot en liten mängd "
"inkompatibilitet med äldre X.509-certifikat."

msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"Protokoll, alternativ, chiffer och andra inställningar kan ändras till mer "
"restriktiva värden när som helst utan föregående avskrivning.  Värdena "
"representerar en rättvis balans mellan kompatibilitet och säkerhet."

msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"Om din applikation behöver specifika inställningar bör du skapa en :class:"
"`SSLContext` och tillämpa inställningarna själv."

msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"Om du upptäcker att när vissa äldre klienter eller servrar försöker ansluta "
"med en :class:`SSLContext` som skapats av den här funktionen får de "
"felmeddelandet \"Protocol or cipher suite mismatch\", kan det bero på att de "
"endast stöder SSL3.0 som den här funktionen utesluter med :data:"
"`OP_NO_SSLv3`. SSL3.0 anses allmänt vara \"helt trasigt\" <https://en."
"wikipedia.org/wiki/POODLE>`_. Om du fortfarande vill fortsätta att använda "
"den här funktionen men ändå tillåta SSL 3.0-anslutningar kan du återaktivera "
"dem med hjälp av::"

msgid ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"
msgstr ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"

msgid ""
"This context enables :data:`VERIFY_X509_STRICT` by default, which may reject "
"pre-:rfc:`5280` or malformed certificates that the underlying OpenSSL "
"implementation otherwise would accept. While disabling this is not "
"recommended, you can do so using::"
msgstr ""
"Detta sammanhang aktiverar :data:`VERIFY_X509_STRICT` som standard, vilket "
"kan avvisa pre-:rfc:`5280` eller missbildade certifikat som den "
"underliggande OpenSSL-implementationen annars skulle acceptera. Det är inte "
"rekommenderat att inaktivera detta, men du kan göra det med hjälp av::"

msgid ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"
msgstr ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"

msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 togs bort från standardchiffersträngen."

msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 har lagts till i standardchiffersträngen."

msgid "3DES was dropped from the default cipher string."
msgstr "3DES togs bort från standardchiffersträngen."

msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr "Stöd för nyckelloggning till :envvar:`SSLKEYLOGFILE` har lagts till."

msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol instead of generic :data:`PROTOCOL_TLS`."
msgstr ""
"Kontexten använder nu protokollet :data:`PROTOCOL_TLS_CLIENT` eller :data:"
"`PROTOCOL_TLS_SERVER` i stället för det generiska protokollet :data:"
"`PROTOCOL_TLS`."

msgid ""
"The context now uses :data:`VERIFY_X509_PARTIAL_CHAIN` and :data:"
"`VERIFY_X509_STRICT` in its default verify flags."
msgstr ""
"Kontexten använder nu :data:`VERIFY_X509_PARTIAL_CHAIN` och :data:"
"`VERIFY_X509_STRICT` i sina standardverifieringsflaggor."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Utlöses för att signalera ett fel från den underliggande SSL-"
"implementeringen (som för närvarande tillhandahålls av OpenSSL-"
"biblioteket).  Detta innebär något problem i krypterings- och "
"autentiseringslagret på högre nivå som läggs ovanpå den underliggande "
"nätverksanslutningen.  Det här felet är en subtyp av :exc:`OSError`.  "
"Felkoden och meddelandet för :exc:`SSLError`-instanser tillhandahålls av "
"OpenSSL-biblioteket."

msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` brukade vara en subtyp av :exc:`socket.error`."

msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"En sträng som betecknar den OpenSSL-submodul där felet inträffade, t.ex. "
"``SSL``, ``PEM`` eller ``X509``.  Mängden möjliga värden beror på OpenSSL-"
"versionen."

msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"En sträng som anger orsaken till att felet uppstod, till exempel "
"``CERTIFICATE_VERIFY_FAILED``.  Mängden möjliga värden beror på OpenSSL-"
"versionen."

msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"En underklass av :exc:`SSLError` som uppstår när man försöker läsa eller "
"skriva och SSL-anslutningen har stängts på ett korrekt sätt.  Observera att "
"detta inte betyder att den underliggande transporten (läs TCP) har stängts."

msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"En underklass till :exc:`SSLError` som orsakas av en :ref:`icke-blockerande "
"SSL-socket <ssl-nonblocking>` när den försöker läsa eller skriva data, men "
"mer data måste tas emot på den underliggande TCP-transporten innan begäran "
"kan uppfyllas."

msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"En underklass till :exc:`SSLError` som uppstår när ett :ref:`icke-"
"blockerande SSL-uttag <ssl-nonblocking>` försöker läsa eller skriva data, "
"men mer data måste skickas på den underliggande TCP-transporten innan "
"begäran kan uppfyllas."

msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"En underklass till :exc:`SSLError` som uppstår när ett systemfel uppstår när "
"man försöker utföra en åtgärd på ett SSL-uttag.  Tyvärr finns det inget "
"enkelt sätt att inspektera det ursprungliga errno-numret."

msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"En underklass till :exc:`SSLError` som uppstår när SSL-anslutningen har "
"avslutats abrupt.  Generellt sett bör du inte försöka återanvända den "
"underliggande transporten när detta fel uppstår."

msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"En underklass av :exc:`SSLError` som uppstår när certifikatvalideringen "
"misslyckats."

msgid "A numeric error number that denotes the verification error."
msgstr "Ett numeriskt felnummer som anger verifieringsfelet."

msgid "A human readable string of the verification error."
msgstr "En mänskligt läsbar sträng av verifieringsfelet."

msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Ett alias för :exc:`SSLCertVerificationError`."

msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "Undantaget är nu ett alias för :exc:`SSLCertVerificationError`."

msgid "Random generation"
msgstr "Slumpmässig generering"

msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"Returnerar *num* kryptografiskt starka pseudoslumpmässiga bytes. Utlöser "
"ett :class:`SSLError` om PRNG inte har laddats med tillräckligt med data "
"eller om operationen inte stöds av den aktuella RAND-metoden. :func:"
"`RAND_status` kan användas för att kontrollera statusen för PRNG och :func:"
"`RAND_add` kan användas för att ladda PRNG."

msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "För nästan alla tillämpningar är :func:`os.urandom` att föredra."

msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"Läs Wikipedia-artikeln \"Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_\" för att få "
"information om kraven på en kryptografiskt stark generator."

msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"Returnerar ``True`` om SSL:s pseudoslumptalsgenerator har försetts med "
"\"tillräckligt\" med slumpmässighet, och ``False`` annars.  Du kan använda :"
"func:`ssl.RAND_egd` och :func:`ssl.RAND_add` för att öka slumpmässigheten i "
"pseudoslumptalsgeneratorn."

msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use ``0.0``).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"Blanda de angivna *bytes* i SSL:s pseudoslumpmässiga nummergenerator.  "
"Parametern *entropy* (en float) är en nedre gräns för entropin i strängen "
"(så du kan alltid använda ``0.0``).  Se :rfc:`1750` för mer information om "
"källor till entropi."

msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Skrivbar :term:`bytesliknande objekt` är nu accepterad."

msgid "Certificate handling"
msgstr "Hantering av certifikat"

msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Returnerar tiden i sekunder sedan epoken, givet strängen ``cert_time`` som "
"representerar \"notBefore\"- eller \"notAfter\"-datumet från ett certifikat "
"i ``\"%b %d %H:%M:%S %Y %Z\"`` strptime-format (C-läge)."

msgid "Here's an example:"
msgstr "Här är ett exempel:"

msgid ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp\n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))\n"
"2018-01-05 09:34:43"
msgstr ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp\n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))\n"
"2018-01-05 09:34:43"

msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr ""
"\"notBefore\"- eller \"notAfter\"-datum måste använda GMT (:rfc:`5280`)."

msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Tolkar inmatningstiden som en tid i UTC enligt tidszonen \"GMT\" i "
"inmatningssträngen. Lokal tidszon användes tidigare. Returnera ett heltal "
"(inga bråkdelar av en sekund i inmatningsformatet)"

msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If *ca_certs* is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the *cafile* parameter in :meth:`SSLContext."
"load_verify_locations`.  The call will attempt to validate the server "
"certificate against that set of root certificates, and will fail if the "
"validation attempt fails.  A timeout can be specified with the ``timeout`` "
"parameter."
msgstr ""
"Givet adressen ``addr`` till en SSL-skyddad server, som ett (*hostname*, "
"*port-number*)-par, hämtar serverns certifikat och returnerar det som en PEM-"
"kodad sträng.  Om ``ssl_version`` anges, används den versionen av SSL-"
"protokollet för att försöka ansluta till servern.  Om *ca_certs* anges bör "
"det vara en fil som innehåller en lista över rotcertifikat, i samma format "
"som används för parametern *cafile* i :meth:`SSLContext."
"load_verify_locations`.  Anropet kommer att försöka validera "
"servercertifikatet mot denna uppsättning rotcertifikat, och misslyckas om "
"valideringsförsöket misslyckas.  En timeout kan anges med parametern "
"``timeout``."

msgid "This function is now IPv6-compatible."
msgstr "Denna funktion är nu IPv6-kompatibel."

msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"Standard *ssl_version* ändras från :data:`PROTOCOL_SSLv3` till :data:"
"`PROTOCOL_TLS` för maximal kompatibilitet med moderna servrar."

msgid "The *timeout* parameter was added."
msgstr "Parametern *timeout* har lagts till."

msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Om ett certifikat ges som en DER-kodad blob med bytes, returneras en PEM-"
"kodad strängversion av samma certifikat."

msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Om ett certifikat anges som en ASCII PEM-sträng returneras en DER-kodad "
"sekvens av bytes för samma certifikat."

msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Returnerar en namngiven tupel med sökvägar till OpenSSL:s standardcafile och "
"-capath. Sökvägarna är samma som används av :meth:`SSLContext."
"set_default_verify_paths`. Returvärdet är en :term:`named tuple` "
"``DefaultVerifyPaths``:"

msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - upplöst sökväg till cafile eller ``None`` om filen inte "
"finns,"

msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - upplöst sökväg till capath eller ``None`` om katalogen inte "
"finns,"

msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` - OpenSSL:s miljönyckel som pekar på en cafile,"

msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - hårdkodad sökväg till en cafile,"

msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` - OpenSSL:s miljönyckel som pekar på en capath,"

msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - hårdkodad sökväg till en capath-katalog"

msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Hämtar certifikat från Windows system cert store. *store_name* kan vara en "
"av ``CA``, ``ROOT`` eller ``MY``. Windows kan också tillhandahålla "
"ytterligare certifikatlager."

msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"Funktionen returnerar en lista med (cert_bytes, encoding_type, trust)-"
"tupler. Encoding_type anger kodningen av cert_bytes. Den är antingen :const:"
"`x509_asn` för X.509 ASN.1-data eller :const:`pkcs_7_asn` för PKCS#7 ASN.1-"
"data. Trust anger syftet med certifikatet som en uppsättning OIDS eller "
"exakt ``True`` om certifikatet är pålitligt för alla ändamål."

msgid "Example::"
msgstr "Exempel::"

msgid ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b'data...', 'x509_asn', True)]"
msgstr ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b\"data...\", \"x509_asn\", True)]"

msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Hämtar CRL:er från Windows systemets cert-arkiv. *store_name* kan vara en av "
"``CA``, ``ROOT`` eller ``MY``. Windows kan också tillhandahålla ytterligare "
"cert-arkiv."

msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"Funktionen returnerar en lista med (cert_bytes, encoding_type, trust)-"
"tupler. Encoding_type anger kodningen av cert_bytes. Den är antingen :const:"
"`x509_asn` för X.509 ASN.1-data eller :const:`pkcs_7_asn` för PKCS#7 ASN.1-"
"data."

msgid "Constants"
msgstr "Konstanter"

msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Alla konstanter är nu :class:`enum.IntEnum` eller :class:`enum.IntFlag` "
"samlingar."

msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. Except for :const:"
"`PROTOCOL_TLS_CLIENT`, it is the default mode.  With client-side sockets, "
"just about any cert is accepted.  Validation errors, such as untrusted or "
"expired cert, are ignored and do not abort the TLS/SSL handshake."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_mode`. Med undantag för :const:"
"`PROTOCOL_TLS_CLIENT` är detta standardläget.  Med sockets på klientsidan "
"accepteras i stort sett alla certifikat.  Valideringsfel, t.ex. icke "
"betrodda eller utgångna certifikat, ignoreras och avbryter inte TLS/SSL-"
"handskakningen."

msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"I serverläge begärs inget certifikat från klienten, så klienten skickar inte "
"något för autentisering med klientcertifikat."

msgid "See the discussion of :ref:`ssl-security` below."
msgstr "Se diskussionen om :ref:`ssl-security` nedan."

msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In client mode, :const:"
"`CERT_OPTIONAL` has the same meaning as :const:`CERT_REQUIRED`. It is "
"recommended to use :const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_mode`. I klientläge har :const:"
"`CERT_OPTIONAL` samma betydelse som :const:`CERT_REQUIRED`. Vi rekommenderar "
"att du använder :const:`CERT_REQUIRED` för sockets på klientsidan i stället."

msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"I serverläge skickas en begäran om klientcertifikat till klienten.  Klienten "
"kan antingen ignorera begäran eller skicka ett certifikat för att utföra TLS-"
"klientcertifikatsautentisering.  Om klienten väljer att skicka ett "
"certifikat verifieras det.  Om ett verifieringsfel uppstår avbryts TLS-"
"handskakningen omedelbart."

msgid ""
"Use of this setting requires a valid set of CA certificates to be passed to :"
"meth:`SSLContext.load_verify_locations`."
msgstr ""
"Om denna inställning används krävs att en giltig uppsättning CA-certifikat "
"skickas till :meth:`SSLContext.load_verify_locations`."

msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In this mode, "
"certificates are required from the other side of the socket connection; an :"
"class:`SSLError` will be raised if no certificate is provided, or if its "
"validation fails. This mode is **not** sufficient to verify a certificate in "
"client mode as it does not match hostnames.  :attr:`~SSLContext."
"check_hostname` must be enabled as well to verify the authenticity of a "
"cert. :const:`PROTOCOL_TLS_CLIENT` uses :const:`CERT_REQUIRED` and enables :"
"attr:`~SSLContext.check_hostname` by default."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_mode`. I detta läge krävs "
"certifikat från den andra sidan av socket-anslutningen; ett :class:"
"`SSLError` kommer att uppstå om inget certifikat tillhandahålls, eller om "
"dess validering misslyckas. Detta läge är **inte** tillräckligt för att "
"verifiera ett certifikat i klientläge eftersom det inte matchar värdnamn. :"
"attr:`~SSLContext.check_hostname` måste också aktiveras för att verifiera "
"äktheten hos ett certifikat. :const:`PROTOCOL_TLS_CLIENT` använder :const:"
"`CERT_REQUIRED` och aktiverar :attr:`~SSLContext.check_hostname` som "
"standard."

msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"Med serveruttag ger detta läge obligatorisk TLS-"
"klientcertifikatsautentisering.  En begäran om klientcertifikat skickas till "
"klienten och klienten måste tillhandahålla ett giltigt och betrott "
"certifikat."

msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr ":class:`enum.IntEnum` samling av CERT_*-konstanter."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. I det här läget "
"kontrolleras inte CRL:er (Certificate Revocation List). Som standard varken "
"kräver eller verifierar OpenSSL CRL:er."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. I det här läget "
"kontrolleras endast peer-certifikatet, men inga mellanliggande CA-"
"certifikat. Läget kräver en giltig CRL som är signerad av peer-certifikatets "
"utfärdare (dess direkta förfader CA). Om ingen korrekt CRL har laddats med :"
"attr:`SSLContext.load_verify_locations`, kommer valideringen att misslyckas."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. I det här läget "
"kontrolleras CRL för alla certifikat i peer-certifikatkedjan."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags` för att inaktivera "
"lösningar för trasiga X.509-certifikat."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags` för att aktivera "
"verifiering av proxycertifikat."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. Instruerar OpenSSL att "
"föredra betrodda certifikat när förtroendekedjan byggs upp för att validera "
"ett certifikat. Denna flagga är aktiverad som standard."

msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
"Möjligt värde för :attr:`SSLContext.verify_flags`. Instruerar OpenSSL att "
"acceptera att mellanliggande CA:er i trust store behandlas som trust-"
"anchors, på samma sätt som självsignerade root CA-certifikat. Detta gör det "
"möjligt att lita på certifikat som utfärdats av en mellanliggande CA utan "
"att behöva lita på dess förfader rot-CA."

msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr ":class:`enum.IntFlag` samling av VERIFY_*-konstanter."

msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Väljer den högsta protokollversionen som både klienten och servern stöder. "
"Trots namnet kan det här alternativet välja både \"SSL\"- och \"TLS\"-"
"protokoll."

msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of :"
"data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"TLS-klienter och -servrar kräver olika standardinställningar för säker "
"kommunikation. Den generiska TLS-protokollkonstanten är föråldrad till "
"förmån för :data:`PROTOCOL_TLS_CLIENT` och :data:`PROTOCOL_TLS_SERVER`."

msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Förhandla automatiskt om den högsta protokollversionen som både klienten och "
"servern stöder och konfigurera kontextanslutningarna på klientsidan. "
"Protokollet aktiverar :data:`CERT_REQUIRED` och :attr:`~SSLContext."
"check_hostname` som standard."

msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr ""
"Autoförhandla den högsta protokollversionen som både klienten och servern "
"stöder och konfigurera kontexten för anslutningar på serversidan."

msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Alias för :data:`PROTOCOL_TLS`."

msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Använd :data:`PROTOCOL_TLS` istället."

msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Väljer SSL version 3 som protokoll för kryptering av kanalen."

msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr ""
"Detta protokoll är inte tillgängligt om OpenSSL kompileras med alternativet "
"``no-ssl3``."

msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL version 3 är osäkert.  Dess användning är starkt avrådd."

msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with :"
"attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"OpenSSL har utgått från alla versionsspecifika protokoll. Använd "
"standardprotokollet :data:`PROTOCOL_TLS_SERVER` eller :data:"
"`PROTOCOL_TLS_CLIENT` med :attr:`SSLContext.minimum_version` och :attr:"
"`SSLContext.maximum_version` istället."

msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "Väljer TLS version 1.0 som krypteringsprotokoll för kanalen."

msgid "OpenSSL has deprecated all version specific protocols."
msgstr "OpenSSL har avskaffat alla versionsspecifika protokoll."

msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Väljer TLS version 1.1 som krypteringsprotokoll för kanalen. Endast "
"tillgängligt med openssl version 1.0.1+."

msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Väljer TLS version 1.2 som krypteringsprotokoll för kanalen. Endast "
"tillgängligt med openssl version 1.0.1+."

msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Möjliggör lösningar för olika buggar som finns i andra SSL-implementeringar. "
"Detta alternativ är inställt som standard.  Det sätter inte nödvändigtvis "
"samma flaggor som OpenSSL:s konstant ``SSL_OP_ALL``."

msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Förhindrar en SSLv2-anslutning.  Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`.  Det hindrar motparterna från att "
"välja SSLv2 som protokollversion."

msgid "SSLv2 is deprecated"
msgstr "SSLv2 är föråldrat"

msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Förhindrar en SSLv3-anslutning.  Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`.  Det hindrar motparterna från att "
"välja SSLv3 som protokollversion."

msgid "SSLv3 is deprecated"
msgstr "SSLv3 är föråldrad"

msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Förhindrar en TLSv1-anslutning.  Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`.  Det hindrar peers från att välja "
"TLSv1 som protokollversion."

msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"Alternativet är föråldrat sedan OpenSSL 1.1.0, använd de nya :attr:"
"`SSLContext.minimum_version` och :attr:`SSLContext.maximum_version` istället."

msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Förhindrar en TLSv1.1-anslutning. Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`. Det hindrar motparterna från att "
"välja TLSv1.1 som protokollversion. Endast tillgängligt med openssl version "
"1.0.1+."

msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "Alternativet är föråldrat sedan OpenSSL 1.1.0."

msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Förhindrar en TLSv1.2-anslutning. Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`. Det hindrar motparterna från att "
"välja TLSv1.2 som protokollversion. Endast tillgängligt med openssl version "
"1.0.1+."

msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Förhindrar en TLSv1.3-anslutning. Detta alternativ är endast tillämpligt i "
"kombination med :const:`PROTOCOL_TLS`. Det hindrar motparterna från att "
"välja TLSv1.3 som protokollversion. TLS 1.3 är tillgängligt med OpenSSL "
"1.1.1 eller senare. När Python har kompilerats mot en äldre version av "
"OpenSSL, är flaggan som standard *0*."

msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15 and "
"3.6.3 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"Alternativet är föråldrat sedan OpenSSL 1.1.0. Det lades till i 2.7.15 och "
"3.6.3 för bakåtkompatibilitet med OpenSSL 1.0.2."

msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Inaktivera all omförhandling i TLSv1.2 och tidigare. Skicka inte "
"HelloRequest-meddelanden och ignorera begäran om omförhandling via "
"ClientHello."

msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "Detta alternativ är endast tillgängligt med OpenSSL 1.1.0h och senare."

msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Använd serverns preferens för chifferordning i stället för klientens. Det "
"här alternativet har ingen effekt på klientsocklar och SSLv2-serversocklar."

msgid ""
"Prevents reuse of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""
"Förhindrar återanvändning av samma DH-nyckel för olika SSL-sessioner.  Detta "
"förbättrar forward secrecy men kräver mer beräkningsresurser. Det här "
"alternativet gäller endast för serveruttag."

msgid ""
"Prevents reuse of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"Förhindrar återanvändning av samma ECDH-nyckel för olika SSL-sessioner.  "
"Detta förbättrar forward secrecy men kräver mer beräkningsresurser. Det här "
"alternativet gäller endast för serveruttag."

msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Skicka falska CCS-meddelanden (Change Cipher Spec) i TLS 1.3-handskakningen "
"för att få en TLS 1.3-anslutning att mer likna en TLS 1.2-anslutning."

msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Detta alternativ är endast tillgängligt med OpenSSL 1.1.1 och senare."

msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Inaktivera komprimering på SSL-kanalen.  Detta är användbart om "
"applikationsprotokollet stöder sitt eget komprimeringsschema."

msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ":class:`enum.IntFlag` samling av OP_*-konstanter."

msgid "Prevent client side from requesting a session ticket."
msgstr "Förhindra klientsidan från att begära en sessionsbiljett."

msgid "Ignore unexpected shutdown of TLS connections."
msgstr "Ignorera oväntad avstängning av TLS-anslutningar."

msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "Detta alternativ är endast tillgängligt med OpenSSL 3.0.0 och senare."

msgid ""
"Enable the use of the kernel TLS. To benefit from the feature, OpenSSL must "
"have been compiled with support for it, and the negotiated cipher suites and "
"extensions must be supported by it (a list of supported ones may vary by "
"platform and kernel version)."
msgstr ""
"Aktivera användning av TLS i kärnan. För att dra nytta av funktionen måste "
"OpenSSL ha kompilerats med stöd för den, och de förhandlade chiffersviterna "
"och tilläggen måste stödjas av den (en lista över de som stöds kan variera "
"beroende på plattform och kärnversion)."

msgid ""
"Note that with enabled kernel TLS some cryptographic operations are "
"performed by the kernel directly and not via any available OpenSSL "
"Providers. This might be undesirable if, for example, the application "
"requires all cryptographic operations to be performed by the FIPS provider."
msgstr ""
"Observera att med aktiverad TLS i kärnan utförs vissa kryptografiska "
"operationer direkt av kärnan och inte via någon tillgänglig OpenSSL-"
"provider. Detta kan vara oönskat om t.ex. applikationen kräver att alla "
"kryptografiska operationer utförs av FIPS-providern."

msgid ""
"Allow legacy insecure renegotiation between OpenSSL and unpatched servers "
"only."
msgstr ""
"Tillåt endast äldre, osäkra omförhandlingar mellan OpenSSL och servrar som "
"inte är patchade."

msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för TLS-tillägget *Application-Layer "
"Protocol Negotiation* enligt beskrivningen i :rfc:`7301`."

msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för att inte kontrollera ämnets "
"gemensamma namn och :attr:`SSLContext.hostname_checks_common_name` är "
"skrivbart."

msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för Diffie-Hellman-nyckelutbyte "
"baserat på elliptiska kurvor.  Detta bör vara sant om inte funktionen "
"uttryckligen har inaktiverats av distributören."

msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för tillägget *Server Name "
"Indication* (enligt definitionen i :rfc:`6066`)."

msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"Om OpenSSL-biblioteket har inbyggt stöd för *Next Protocol Negotiation* "
"enligt beskrivningen i `Application Layer Protocol Negotiation <https://en."
"wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. När det är "
"sant kan du använda metoden :meth:`SSLContext.set_npn_protocols` för att "
"annonsera vilka protokoll du vill stödja."

msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för SSL 2.0-protokollet."

msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för SSL 3.0-protokollet."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.0-protokollet."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.1-protokollet."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.2-protokollet."

msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS 1.3-protokollet."

msgid "Whether the OpenSSL library has built-in support for TLS-PSK."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS-PSK."

msgid "Whether the OpenSSL library has built-in support for TLS-PHA."
msgstr "Om OpenSSL-biblioteket har inbyggt stöd för TLS-PHA."

msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Lista över TLS-kanalbindningstyper som stöds.  Strängar i den här listan kan "
"användas som argument för :meth:`SSLSocket.get_channel_binding`."

msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "Versionssträngen för OpenSSL-biblioteket som läses in av tolken::"

msgid ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 1.0.2k  26 Jan 2017'"
msgstr ""
">>> ssl.OPENSSL_VERSION\n"
"\"OpenSSL 1.0.2k 26 januari 2017"

msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"En tupel med fem heltal som representerar versionsinformation om OpenSSL-"
"biblioteket::"

msgid ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"
msgstr ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"

msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr "Det råa versionsnumret för OpenSSL-biblioteket, som ett enda heltal::"

msgid ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"
msgstr ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"

msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Varningsbeskrivningar från :rfc:`5246` och andra. Registret `IANA TLS Alert "
"Registry <https://www.iana.org/assignments/tls-parameters/tls-parameters."
"xml#tls-parameters-6>`_ innehåller denna lista och referenser till de RFC:er "
"där deras betydelse definieras."

msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
"Används som returvärde för callback-funktionen i :meth:`SSLContext."
"set_servername_callback`."

msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ":class:`enum.IntEnum` samling av ALERT_DESCRIPTION_*-konstanter."

msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
"Alternativ för :func:`create_default_context` och :meth:`SSLContext."
"load_default_certs`.  Detta värde anger att kontexten kan användas för att "
"autentisera webbservrar (därför kommer den att användas för att skapa "
"sockets på klientsidan)."

msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
"Alternativ för :func:`create_default_context` och :meth:`SSLContext."
"load_default_certs`.  Detta värde indikerar att kontexten kan användas för "
"att autentisera webbklienter (därför kommer den att användas för att skapa "
"sockets på serversidan)."

msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ":class:`enum.IntEnum` samling av SSL_ERROR_*-konstanter."

msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":class:`enum.IntEnum` samling av SSL- och TLS-versioner för :attr:"
"`SSLContext.maximum_version` och :attr:`SSLContext.minimum_version`."

msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""
"Den lägsta eller högsta SSL- eller TLS-versionen som stöds. Dessa är magiska "
"konstanter. Deras värden återspeglar inte de lägsta och högsta tillgängliga "
"TLS/SSL-versionerna."

msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 till TLS 1.3."

msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and :attr:"
"`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"Alla :class:`TLSVersion`-medlemmar utom :attr:`TLSVersion.TLSv1_2` och :attr:"
"`TLSVersion.TLSv1_3` är föråldrade."

msgid "SSL Sockets"
msgstr "SSL-uttag"

msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "SSL-uttag tillhandahåller följande metoder för :ref:`socket-objects`:"

msgid ":meth:`~socket.socket.accept`"
msgstr ":meth:`~socket.socket.accept`"

msgid ":meth:`~socket.socket.bind`"
msgstr ":meth:`~socket.socket.bind`"

msgid ":meth:`~socket.socket.close`"
msgstr ":meth:`~socket.socket.close`"

msgid ":meth:`~socket.socket.connect`"
msgstr ":meth:`~socket.socket.connect`"

msgid ":meth:`~socket.socket.detach`"
msgstr ":meth:`~socket.socket.detach`"

msgid ":meth:`~socket.socket.fileno`"
msgstr ":meth:`~socket.socket.fileno`"

msgid ":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"
msgstr ":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"

msgid ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"
msgstr ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"

msgid ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, :meth:"
"`~socket.socket.setblocking`"
msgstr ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, :meth:"
"`~socket.socket.setblocking`"

msgid ":meth:`~socket.socket.listen`"
msgstr ":meth:`~socket.socket.listen`"

msgid ":meth:`~socket.socket.makefile`"
msgstr ":meth:`~socket.socket.makefile`"

msgid ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (but passing a "
"non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (men att "
"skicka ett ``flags``-argument som inte är noll är inte tillåtet)"

msgid ""
":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (with the same "
"limitation)"
msgstr ""
":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (med samma "
"begränsning)"

msgid ""
":meth:`~socket.socket.sendfile` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile` (men :mod:`os.sendfile` kommer endast att "
"användas för uttag med vanlig text, annars kommer :meth:`~socket.socket."
"send` att användas)"

msgid ":meth:`~socket.socket.shutdown`"
msgstr ":meth:`~socket.socket.shutdown`"

msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"Men eftersom SSL- (och TLS-) protokollet har sin egen inramning ovanpå TCP, "
"kan abstraktionen för SSL-uttag i vissa avseenden avvika från "
"specifikationen för normala uttag på OS-nivå.  Se särskilt :ref:"
"`anmärkningar om icke-blockerande uttag <ssl-nonblocking>`."

msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
"Instanser av :class:`SSLSocket` måste skapas med hjälp av :meth:`SSLContext."
"wrap_socket`-metoden."

msgid "The :meth:`sendfile` method was added."
msgstr "Metoden :meth:`sendfile` lades till."

msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now the maximum total duration of "
"the shutdown."
msgstr ""
":meth:`shutdown` nollställer inte socket timeout varje gång bytes tas emot "
"eller skickas. Socket timeout är nu den maximala totala varaktigheten för "
"avstängningen."

msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Det är inte längre aktuellt att skapa en :class:`SSLSocket`-instans direkt, "
"använd :meth:`SSLContext.wrap_socket` för att omsluta en socket."

msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
":class:`SSLSocket`-instanser måste skapas med :meth:`~SSLContext."
"wrap_socket`. I tidigare versioner var det möjligt att skapa instanser "
"direkt. Detta var aldrig dokumenterat eller officiellt stöttat."

msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing zero-"
"length data no longer fails with a protocol violation error."
msgstr ""
"Python använder nu ``SSL_read_ex`` och ``SSL_write_ex`` internt. "
"Funktionerna stöder läsning och skrivning av data som är större än 2 GB. "
"Skrivning av noll-längdsdata misslyckas inte längre med ett "
"protokollöverträdelsefel."

msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "SSL-uttag har också följande ytterligare metoder och attribut:"

msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Läser upp till *len* byte data från SSL-socket och returnerar resultatet som "
"en ``bytes``-instans. Om *buffer* anges läses data in i bufferten i stället "
"och antalet lästa byte returneras."

msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Utlös :exc:`SSLWantReadError` eller :exc:`SSLWantWriteError` om uttaget är :"
"ref:`icke-blockerande <ssl-nonblocking>` och läsningen skulle blockera."

msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"Eftersom en omförhandling kan ske när som helst kan ett anrop till :meth:"
"`read` också orsaka skrivoperationer."

msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to read up to *len* "
"bytes."
msgstr ""
"Timeouten för uttaget återställs inte längre varje gång byte tas emot eller "
"skickas. Socket timeout är nu den maximala totala tiden det tar att läsa upp "
"till *len* bytes."

msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "Använd :meth:`~SSLSocket.recv` istället för :meth:`~SSLSocket.read`."

msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"Skriv *buf* till SSL-socket och returnera antalet byte som skrivits. "
"Argumentet *buf* måste vara ett objekt som stöder buffertgränssnittet."

msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Utlös :exc:`SSLWantReadError` eller :exc:`SSLWantWriteError` om uttaget är :"
"ref:`non-blocking <ssl-nonblocking>` och skrivningen skulle blockera."

msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Eftersom en omförhandling kan ske när som helst kan ett anrop till :meth:"
"`write` också orsaka läsoperationer."

msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to write *buf*."
msgstr ""
"Timeout för socket nollställs inte längre varje gång byte tas emot eller "
"skickas. Timeouten för uttaget är nu den maximala totala tiden det tar att "
"skriva *buf*."

msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "Använd :meth:`~SSLSocket.send` istället för :meth:`~SSLSocket.write`."

msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
"Metoderna :meth:`~SSLSocket.read` och :meth:`~SSLSocket.write` är "
"lågnivåmetoder som läser och skriver okrypterade data på applikationsnivå "
"och dekrypterar/krypterar dem till krypterade data på trådnivå. Dessa "
"metoder kräver en aktiv SSL-anslutning, dvs. handskakningen har slutförts "
"och :meth:`SSLSocket.unwrap` har inte anropats."

msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"Normalt bör du använda Socket API-metoder som :meth:`~socket.socket.recv` "
"och :meth:`~socket.socket.send` istället för dessa metoder."

msgid "Perform the SSL setup handshake."
msgstr "Utför handskakningen för SSL-installationen."

msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"Handskakningsmetoden utför också :func:`match_hostname` när attributet :attr:"
"`~SSLContext.check_hostname` i socketens :attr:`~SSLSocket.context` är true."

msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration of the handshake."
msgstr ""
"Timeout för socket återställs inte längre varje gång byte tas emot eller "
"skickas. Timeouten för uttaget är nu den maximala totala varaktigheten för "
"handskakningen."

msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"sent to the peer."
msgstr ""
"Värdnamn eller IP-adress matchas av OpenSSL under handskakning. Funktionen :"
"func:`match_hostname` används inte längre. Om OpenSSL vägrar ett värdnamn "
"eller en IP-adress avbryts handskakningen i förtid och ett TLS-"
"varningsmeddelande skickas till motparten."

msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"Om det inte finns något certifikat för motparten i den andra änden av "
"anslutningen returneras ``None``.  Om SSL-handskakningen inte har gjorts "
"ännu, returneras :exc:`ValueError`."

msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Om parametern ``binary_form`` är :const:`False`, och ett certifikat har "
"mottagits från motparten, returnerar denna metod en :class:`dict`-instans.  "
"Om certifikatet inte validerades är dict tomt.  Om certifikatet validerades "
"returneras en dict med flera nycklar, bland annat ``subject`` (den huvudman "
"för vilken certifikatet utfärdades) och ``issuer`` (den huvudman som "
"utfärdar certifikatet).  Om ett certifikat innehåller en instans av "
"tillägget *Subject Alternative Name* (se :rfc:`3280`), kommer det också att "
"finnas en nyckel ``subjectAltName`` i ordlistan."

msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Fälten ``subject`` och ``issuer`` är tupler som innehåller den sekvens av "
"RDN (relative distinguished names) som anges i certifikatets datastruktur "
"för respektive fält, och varje RDN är en sekvens av namn-värdepar.  Här är "
"ett exempel från den verkliga världen::"

msgid ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Secure Digital Certificate Signing'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, "
"Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"
msgstr ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Säker digital certifikatsignering'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'Kalifornien'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, "
"Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org')),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"

msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Om parametern ``binary_form`` är :const:`True`` och ett certifikat har "
"tillhandahållits, returnerar denna metod den DER-kodade formen av hela "
"certifikatet som en sekvens av bytes, eller :const:`None` om motparten inte "
"har tillhandahållit något certifikat.  Om motparten tillhandahåller ett "
"certifikat beror på SSL-uttagets roll:"

msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"för ett SSL-uttag från en klient kommer servern alltid att tillhandahålla "
"ett certifikat, oavsett om validering krävdes eller inte;"

msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"för ett SSL-uttag på en server kommer klienten endast att tillhandahålla ett "
"certifikat när servern begär det; därför kommer :meth:`getpeercert` att "
"returnera :const:`None` om du använde :const:`CERT_NONE` (i stället för :"
"const:`CERT_OPTIONAL` eller :const:`CERT_REQUIRED`)."

msgid "See also :attr:`SSLContext.check_hostname`."
msgstr "Se även :attr:`SSLContext.check_hostname`."

msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"Den returnerade ordlistan innehåller ytterligare objekt som ``issuer`` och "
"``notBefore``."

msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` utlöses när handskakningen inte är klar. Den returnerade "
"ordlistan innehåller ytterligare X509v3-tilläggsobjekt såsom "
"``crlDistributionPoints``, ``caIssuers`` och ``OCSP`` URI:er."

msgid "IPv6 address strings no longer have a trailing new line."
msgstr "IPv6-adresssträngar har inte längre någon efterföljande ny rad."

msgid ""
"Returns verified certificate chain provided by the other end of the SSL "
"channel as a list of DER-encoded bytes. If certificate verification was "
"disabled method acts the same as :meth:`~SSLSocket.get_unverified_chain`."
msgstr ""
"Returnerar verifierad certifikatkedja som tillhandahålls av den andra änden "
"av SSL-kanalen som en lista med DER-kodade byte. Om certifikatverifiering "
"var inaktiverad fungerar metoden på samma sätt som :meth:`~SSLSocket."
"get_unverified_chain`."

msgid ""
"Returns raw certificate chain provided by the other end of the SSL channel "
"as a list of DER-encoded bytes."
msgstr ""
"Returnerar den råa certifikatkedjan som tillhandahålls av den andra änden av "
"SSL-kanalen som en lista med DER-kodade byte."

msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Returnerar en tupel med tre värden som innehåller namnet på det chiffer som "
"används, den version av SSL-protokollet som definierar dess användning och "
"antalet hemliga bitar som används.  Om ingen anslutning har upprättats, "
"returneras ``None``."

msgid ""
"Return the list of ciphers available in both the client and server.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"Returnerar listan över chiffer som är tillgängliga i både klienten och "
"servern.  Varje post i den returnerade listan är en tupel med tre värden som "
"innehåller namnet på chiffret, den version av SSL-protokollet som definierar "
"dess användning och antalet hemliga bitar som chiffret använder. :meth:"
"`~SSLSocket.shared_ciphers` returnerar ``None`` om ingen anslutning har "
"upprättats eller om uttaget är ett klientuttag."

msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Returnerar den komprimeringsalgoritm som används som en sträng, eller "
"``None`` om anslutningen inte komprimeras."

msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Om protokollet på högre nivå stöder sin egen komprimeringsmekanism kan du "
"använda :data:`OP_NO_COMPRESSION` för att inaktivera komprimering på SSL-"
"nivå."

msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"Hämta kanalbindningsdata för aktuell anslutning, som ett bytesobjekt.  "
"Returnerar ``None`` om ingen anslutning finns eller om handskakningen inte "
"har slutförts."

msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"Parametern *cb_type* gör det möjligt att välja önskad kanalbindningstyp. "
"Giltiga kanalbindningstyper listas i listan :data:`CHANNEL_BINDING_TYPES`.  "
"För närvarande stöds endast kanalbindningen 'tls-unique', definierad av :rfc:"
"`5929`. :exc:`ValueError` kommer att uppstå om en kanalbindningstyp som inte "
"stöds begärs."

msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"Returnerar det protokoll som valdes under TLS-handskakningen.  Om :meth:"
"`SSLContext.set_alpn_protocols` inte anropades, om den andra parten inte "
"stöder ALPN, om detta uttag inte stöder något av klientens föreslagna "
"protokoll, eller om handskakningen inte har skett ännu, returneras ``None``."

msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"Returnerar det protokoll på högre nivå som valdes under TLS/SSL-"
"handskakningen. Om :meth:`SSLContext.set_npn_protocols` inte anropades, "
"eller om den andra parten inte stöder NPN, eller om handskakningen ännu inte "
"har skett, kommer detta att returnera ``None``."

msgid "NPN has been superseded by ALPN"
msgstr "NPN har ersatts av ALPN"

msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Utför SSL-avstängningshandskakningen, som tar bort TLS-lagret från det "
"underliggande uttaget, och returnerar det underliggande uttagsobjektet.  "
"Detta kan användas för att gå från krypterad drift över en anslutning till "
"okrypterad.  Det returnerade uttaget bör alltid användas för vidare "
"kommunikation med den andra sidan av anslutningen, snarare än det "
"ursprungliga uttaget."

msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"Begär PHA (post-handshake authentication) från en TLS 1.3-klient. PHA kan "
"endast initieras för en TLS 1.3-anslutning från ett server-sidesockel, efter "
"den inledande TLS-handskakningen och med PHA aktiverat på båda sidor, se :"
"attr:`SSLContext.post_handshake_auth`."

msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"Metoden utför inte ett cert-utbyte omedelbart. Serversidan skickar en "
"CertificateRequest vid nästa skrivhändelse och förväntar sig att klienten "
"svarar med ett certifikat vid nästa läshändelse."

msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""
"Om något förhandsvillkor inte uppfylls (t.ex. inte TLS 1.3, PHA inte "
"aktiverat), utlöses ett :exc:`SSLError`."

msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Endast tillgänglig med OpenSSL 1.1.1 och TLS 1.3 aktiverat. Utan stöd för "
"TLS 1.3 ger metoden upphov till :exc:`NotImplementedError`."

msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Returnerar den faktiska SSL-protokollversionen som förhandlats fram av "
"anslutningen som en sträng, eller ``None`` om ingen säker anslutning "
"upprättas. I skrivande stund inkluderar möjliga returvärden ``\"SSLv2\"``, "
"``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` och ``\"TLSv1.2\"``. Nyare "
"OpenSSL-versioner kan definiera fler returvärden."

msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"Returnerar antalet redan dekrypterade bytes som är tillgängliga för läsning, "
"i väntan på anslutningen."

msgid "The :class:`SSLContext` object this SSL socket is tied to."
msgstr "Det :class:`SSLContext`-objekt som detta SSL-uttag är knutet till."

msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"En boolean som är ``True`` för server-sidans uttag och ``False`` för klient-"
"sidans uttag."

msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Värdnamn för servern: :class:`str`-typ, eller ``None`` för server-side "
"socket eller om värdnamnet inte angavs i konstruktören."

msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"Attributet är nu alltid ASCII-text. När ``server_hostname`` är ett "
"internationaliserat domännamn (IDN) lagrar detta attribut nu A-"
"märkningsformen (``\"xn--pythn-mua.org\"``) i stället för U-märkningsformen "
"(``\"pythön.org\"``)."

msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
":class:`SSLSession` för denna SSL-anslutning. Sessionen är tillgänglig för "
"uttag på klient- och serversidan efter att TLS-handskakningen har utförts. "
"För klientuttag kan sessionen ställas in innan :meth:`~SSLSocket."
"do_handshake` har anropats för att återanvända en session."

msgid "SSL Contexts"
msgstr "SSL-kontexter"

msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"En SSL-kontext innehåller olika data som är mer långlivade än enskilda SSL-"
"anslutningar, t.ex. SSL-konfigurationsalternativ, certifikat och privata "
"nycklar. Den hanterar också en cache för SSL-sessioner för uttag på "
"serversidan, för att snabba upp upprepade anslutningar från samma klienter."

msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"Skapa en ny SSL-kontext.  Du kan skicka *protocol* som måste vara en av "
"``PROTOCOL_*``-konstanterna som definieras i den här modulen.  Parametern "
"anger vilken version av SSL-protokollet som ska användas.  Vanligtvis väljer "
"servern en viss protokollversion och klienten måste anpassa sig till "
"serverns val.  De flesta av versionerna är inte kompatibla med andra "
"versioner.  Om inget anges är standardvärdet :data:`PROTOCOL_TLS`; det ger "
"störst kompatibilitet med andra versioner."

msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Här är en tabell som visar vilka versioner i en klient (längst ned på sidan) "
"som kan ansluta till vilka versioner i en server (längst upp):"

msgid "*client* / **server**"
msgstr "*klient* / **server**"

msgid "**SSLv2**"
msgstr "**SSLv2**"

msgid "**SSLv3**"
msgstr "**SSLv3**"

msgid "**TLS** [3]_"
msgstr "**TLS** [3]_ _TLS"

msgid "**TLSv1**"
msgstr "**TLSv1**"

msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

msgid "*SSLv2*"
msgstr "*SSLv2"

msgid "yes"
msgstr "ja"

msgid "no"
msgstr "nej"

msgid "no [1]_"
msgstr "no [1]_"

msgid "*SSLv3*"
msgstr "*SSLv3*"

msgid "no [2]_"
msgstr "no [2]_"

msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

msgid "*TLSv1*"
msgstr "*TLSv1"

msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` inaktiverar SSLv2 med :data:`OP_NO_SSLv2` som standard."

msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` inaktiverar SSLv3 med :data:`OP_NO_SSLv3` som standard."

msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"TLS 1.3-protokollet kommer att vara tillgängligt med :data:`PROTOCOL_TLS` i "
"OpenSSL >= 1.1.1. Det finns ingen dedikerad PROTOCOL-konstant för just TLS "
"1.3."

msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` låter :mod:`ssl`-modulen välja "
"säkerhetsinställningar för ett visst syfte."

msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2`, and :"
"data:`OP_NO_SSLv3` (except for :data:`PROTOCOL_SSLv3`) are set by default. "
"The initial cipher suite list contains only ``HIGH`` ciphers, no ``NULL`` "
"ciphers and no ``MD5`` ciphers."
msgstr ""
"Kontexten skapas med säkra standardvärden. Alternativen :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` och :"
"data:`OP_NO_SSLv3` (utom för :data:`PROTOCOL_SSLv3`) anges som standard. Den "
"ursprungliga listan över chiffersviter innehåller endast chiffer av typen "
"``HIGH``, inga chiffer av typen ``NULL`` och inga chiffer av typen ``MD5``."

msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
":class:`SSLContext` utan protokollargument är föråldrad. Kontextklassen "
"kommer antingen att kräva :data:`PROTOCOL_TLS_CLIENT` eller :data:"
"`PROTOCOL_TLS_SERVER` protokoll i framtiden."

msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and :data:`PROTOCOL_TLS_SERVER` "
"use TLS 1.2 as minimum TLS version."
msgstr ""
"Standardchiffersviterna innehåller nu endast säkra AES- och ChaCha20-chiffer "
"med forward secrecy och säkerhetsnivå 2. RSA- och DH-nycklar med mindre än "
"2048 bitar och ECC-nycklar med mindre än 224 bitar är förbjudna. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, och :data:`PROTOCOL_TLS_SERVER` "
"använder TLS 1.2 som minsta TLS-version."

msgid ""
":class:`SSLContext` only supports limited mutation once it has been used by "
"a connection. Adding new certificates to the internal trust store is "
"allowed, but changing ciphers, verification settings, or mTLS certificates "
"may result in surprising behavior."
msgstr ""
":class:`SSLContext` stöder endast begränsad mutation när den har använts av "
"en anslutning. Det är tillåtet att lägga till nya certifikat i det interna "
"förtroendearkivet, men att ändra chiffer, verifieringsinställningar eller "
"mTLS-certifikat kan resultera i överraskande beteende."

msgid ""
":class:`SSLContext` is designed to be shared and used by multiple "
"connections. Thus, it is thread-safe as long as it is not reconfigured after "
"being used by a connection."
msgstr ""
":class:`SSLContext` är utformad för att delas och användas av flera "
"anslutningar. Den är alltså trådsäker så länge den inte konfigureras om "
"efter att ha använts av en anslutning."

msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ":class:`SSLContext`-objekt har följande metoder och attribut:"

msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""
"Hämta statistik över antal laddade X.509-certifikat, antal X.509-certifikat "
"som markerats som CA-certifikat och spärrlistor som ordlista."

msgid "Example for a context with one CA cert and one other cert::"
msgstr "Exempel för en kontext med ett CA-cert och ett annat cert::"

msgid ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"
msgstr ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"

msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"Läser in en privat nyckel och motsvarande certifikat.  Strängen *certfile* "
"måste vara sökvägen till en enda fil i PEM-format som innehåller "
"certifikatet samt valfritt antal CA-certifikat som behövs för att fastställa "
"certifikatets äkthet.  Strängen *keyfile* måste, om den finns, peka på en "
"fil som innehåller den privata nyckeln.  I annat fall hämtas den privata "
"nyckeln även från *certfile*.  Se diskussionen i :ref:`ssl-certificates` för "
"mer information om hur certifikatet lagras i *certfile*."

msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"Argumentet *password* kan vara en funktion som ska anropas för att få "
"lösenordet för dekryptering av den privata nyckeln.  Funktionen anropas "
"endast om den privata nyckeln är krypterad och ett lösenord är nödvändigt.  "
"Den anropas utan argument och ska returnera en sträng, bytes eller "
"bytearray.  Om returvärdet är en sträng kommer den att kodas som UTF-8 innan "
"den används för att dekryptera nyckeln. Alternativt kan ett värde i form av "
"en sträng, bytes eller bytearray anges direkt som argument för *password*.  "
"Det ignoreras om den privata nyckeln inte är krypterad och inget lösenord "
"behövs."

msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"Om argumentet *password* inte anges och ett lösenord krävs, kommer OpenSSL:s "
"inbyggda mekanism för lösenordsuppmaning att användas för att interaktivt "
"uppmana användaren att ange ett lösenord."

msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""
"Ett :class:`SSLError` uppstår om den privata nyckeln inte stämmer överens "
"med certifikatet."

msgid "New optional argument *password*."
msgstr "Nytt valfritt argument *password*."

msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"Ladda en uppsättning standardcertifikat för \"certifikatutfärdare\" (CA) "
"från standardplatser. I Windows laddas CA-certifikat från systemlagren "
"``CA`` och ``ROOT``. På alla system anropar den :meth:`SSLContext."
"set_default_verify_paths`. I framtiden kan metoden komma att ladda CA-"
"certifikat från andra platser också."

msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :const:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :const:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""
"Flaggan *purpose* anger vilken typ av CA-certifikat som läses in. "
"Standardinställningarna :const:`Purpose.SERVER_AUTH` laddar certifikat som "
"är flaggade och betrodda för TLS-autentisering av webbservern (sockets på "
"klientsidan). :const:`Purpose.CLIENT_AUTH` laddar CA-certifikat för "
"verifiering av klientcertifikat på serversidan."

msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"Läser in en uppsättning certifikat från \"Certification Authority\" (CA) som "
"används för att validera andra peers certifikat när :data:`verify_mode` är "
"något annat än :data:`CERT_NONE`.  Åtminstone en av *cafile* eller *capath* "
"måste anges."

msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"Den här metoden kan också läsa in CRL:er (Certification Revocation List) i "
"PEM- eller DER-format. För att kunna använda CRL:er måste :attr:`SSLContext."
"verify_flags` vara korrekt konfigurerad."

msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"Strängen *cafile*, om den finns, är sökvägen till en fil med sammanlänkade "
"certifikat från certifikatutfärdare i PEM-format. Se diskussionen om :ref:"
"`ssl-certificates` för mer information om hur du ordnar certifikaten i den "
"här filen."

msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/>`_."
msgstr ""
"Strängen *capath*, om den finns, är sökvägen till en katalog som innehåller "
"flera CA-certifikat i PEM-format, enligt en `OpenSSL-specifik layout "
"<https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/>`_."

msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"Objektet *cadata*, om det finns, är antingen en ASCII-sträng med ett eller "
"flera PEM-kodade certifikat eller ett :term:`bytesliknande objekt` med DER-"
"kodade certifikat. Precis som med *capath* ignoreras extra rader runt PEM-"
"kodade certifikat, men minst ett certifikat måste finnas med."

msgid "New optional argument *cadata*"
msgstr "Nytt valfritt argument *cadata*"

msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"Hämta en lista med laddade certifikat från certifikatutfärdare (CA). Om "
"parametern ``binary_form`` är :const:`False`` är varje post i listan en dikt "
"som utdata från :meth:`SSLSocket.getpeercert`. Annars returnerar metoden en "
"lista med DER-kodade certifikat. Den returnerade listan innehåller inte "
"certifikat från *capath* om inte ett certifikat begärdes och laddades av en "
"SSL-anslutning."

msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"Certifikat i en capath-katalog läses inte in om de inte har använts minst en "
"gång."

msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""
"Hämta en lista över aktiverade chiffer. Listan är i ordning efter "
"chifferprioritet. Se :meth:`SSLContext.set_ciphers`."

msgid ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"
msgstr ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH Au=RSA '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH Au=RSA '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"

msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"Ladda en uppsättning standardcertifikat från en certifikatutfärdare (CA) "
"från en filsystemssökväg som definieras när OpenSSL-biblioteket byggs.  "
"Tyvärr finns det inget enkelt sätt att veta om den här metoden lyckas: inget "
"fel returneras om inga certifikat hittas.  När OpenSSL-biblioteket "
"tillhandahålls som en del av operativsystemet är det dock troligt att det är "
"korrekt konfigurerat."

msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://docs.openssl.org/"
"master/man1/ciphers/>`_. If no cipher can be selected (because compile-time "
"options or other configuration forbids use of all the specified ciphers), "
"an :class:`SSLError` will be raised."
msgstr ""
"Ange tillgängliga chiffer för uttag som skapats med detta sammanhang. Det "
"bör vara en sträng i formatet `OpenSSL cipher list <https://docs.openssl.org/"
"master/man1/ciphers/>`_. Om inget chiffer kan väljas (eftersom "
"kompileringstidsalternativ eller annan konfiguration förbjuder användning av "
"alla angivna chiffer), kommer ett :class:`SSLError` att uppstå."

msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""
"när du är ansluten kommer :meth:`SSLSocket.cipher`-metoden för SSL-uttag att "
"ge det aktuella valda chiffret."

msgid ""
"TLS 1.3 cipher suites cannot be disabled with :meth:`~SSLContext."
"set_ciphers`."
msgstr ""
"TLS 1.3-chiffersviter kan inte inaktiveras med :meth:`~SSLContext."
"set_ciphers`."

msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"Ange vilka protokoll som uttaget ska annonsera under SSL/TLS-handskakningen. "
"Det bör vara en lista med ASCII-strängar, som ``['http/1.1', 'spdy/2']``, "
"ordnade efter preferens. Valet av protokoll kommer att ske under "
"handskakningen, och kommer att ske enligt :rfc:`7301`. Efter en lyckad "
"handskakning kommer metoden :meth:`SSLSocket.selected_alpn_protocol` att "
"returnera det överenskomna protokollet."

msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"Denna metod ger upphov till :exc:`NotImplementedError` om :data:`HAS_ALPN` "
"är ``False``."

msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"Ange vilka protokoll som uttaget ska annonsera under SSL/TLS-handskakningen. "
"Det bör vara en lista med strängar, till exempel ``['http/1.1', 'spdy/2']``, "
"ordnade efter preferens. Valet av protokoll kommer att ske under "
"handskakningen och kommer att ske i enlighet med `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. Efter en lyckad handskakning kommer metoden :"
"meth:`SSLSocket.selected_npn_protocol` att returnera det överenskomna "
"protokollet."

msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"Denna metod ger upphov till :exc:`NotImplementedError` om :data:`HAS_NPN` är "
"``False``."

msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"Registrera en återuppringningsfunktion som kommer att anropas efter att "
"handskakningsmeddelandet TLS Client Hello har mottagits av SSL/TLS-servern "
"när TLS-klienten anger en servernamnindikation. Mekanismen för indikering av "
"servernamn specificeras i :rfc:`6066` avsnitt 3 - Server Name Indication."

msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"Endast en återuppringning kan ställas in per ``SSLContext``.  Om "
"*sni_callback* är inställd på ``None`` inaktiveras återuppringningen. Anrop "
"av denna funktion en senare gång inaktiverar den tidigare registrerade "
"återuppringningen."

msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"Callback-funktionen anropas med tre argument; det första är :class:`ssl."
"SSLSocket`, det andra är en sträng som representerar det servernamn som "
"klienten avser att kommunicera med (eller :const:`None` om TLS Client Hello "
"inte innehåller något servernamn) och det tredje argumentet är det "
"ursprungliga :class:`SSLContext`. Argumentet för servernamnet är text. För "
"internationaliserade domännamn är servernamnet en IDN A-label (``\"xn--pythn-"
"mua.org\"``)."

msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"En typisk användning av denna callback är att ändra :class:`ssl.SSLSocket`:"
"attr:`SSLSocket.context`-attributet till ett nytt objekt av typen :class:"
"`SSLContext` som representerar en certifikatkedja som matchar servernamnet."

msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.get_verified_chain`, :meth:`SSLSocket."
"get_unverified_chain` :meth:`SSLSocket.cipher` and :meth:`SSLSocket."
"compression` methods require that the TLS connection has progressed beyond "
"the TLS Client Hello and therefore will not return meaningful values nor can "
"they be called safely."
msgstr ""
"På grund av den tidiga förhandlingsfasen i TLS-anslutningen är endast "
"begränsade metoder och attribut användbara, t.ex. :meth:`SSLSocket."
"selected_alpn_protocol` och :attr:`SSLSocket.context`. Metoderna :meth:"
"`SSLSocket.getpeercert`, :meth:`SSLSocket.get_verified_chain`, :meth:"
"`SSLSocket.get_unverified_chain` :meth:`SSLSocket.cipher` och :meth:"
"`SSLSocket.compression` kräver att TLS-anslutningen har kommit längre än TLS "
"Client Hello och returnerar därför inte meningsfulla värden och kan inte "
"anropas på ett säkert sätt."

msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"Funktionen *sni_callback* måste returnera ``None`` för att TLS-förhandlingen "
"ska kunna fortsätta.  Om ett TLS-fel krävs kan en konstant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` returneras.  Andra "
"returvärden kommer att resultera i ett TLS-fatal error med :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."

msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"Om ett undantag uppstår från funktionen *sni_callback* kommer TLS-"
"anslutningen att avslutas med ett TLS-varningsmeddelande :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."

msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"Denna metod kommer att ge upphov till :exc:`NotImplementedError` om OpenSSL-"
"biblioteket hade OPENSSL_NO_TLSEXT definierat när det byggdes."

msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"Detta är ett äldre API som behålls för bakåtkompatibilitet. När det är "
"möjligt bör du använda :attr:`sni_callback` istället. Den givna "
"*server_name_callback* liknar *sni_callback*, förutom att när serverns "
"värdnamn är ett IDN-kodat internationaliserat domännamn, får "
"*server_name_callback* en avkodad U-etikett (``\"pythön.org\"``)."

msgid ""
"If there is a decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""
"Om det finns ett avkodningsfel på servernamnet kommer TLS-anslutningen att "
"avslutas med ett :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatalt TLS-"
"varningsmeddelande till klienten."

msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"Ladda parametrarna för nyckelgenerering för Diffie-Hellman (DH)-"
"nyckelutbyte. Genom att använda DH-nyckelutbyte förbättras forward secrecy "
"på bekostnad av beräkningsresurser (både på servern och på klienten). "
"Parametern *dhfile* ska vara sökvägen till en fil som innehåller DH-"
"parametrar i PEM-format."

msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"Den här inställningen gäller inte för klientsocklar.  Du kan också använda "
"alternativet :data:`OP_SINGLE_DH_USE` för att ytterligare förbättra "
"säkerheten."

msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"Ange kurvans namn för ECDH-nyckelutbyte (Elliptic Curve-based Diffie-"
"Hellman).  ECDH är betydligt snabbare än vanlig DH, men förmodligen lika "
"säkert.  Parametern *curve_name* ska vara en sträng som beskriver en välkänd "
"elliptisk kurva, t.ex. ``prime256v1`` för en kurva med brett stöd."

msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"Den här inställningen gäller inte för klientsocklar.  Du kan också använda "
"alternativet :data:`OP_SINGLE_ECDH_USE` för att ytterligare förbättra "
"säkerheten."

msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "Denna metod är inte tillgänglig om :data:`HAS_ECDH` är ``False``."

msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.ch/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.ch/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"

msgid "Vincent Bernat."
msgstr "Vincent Bernat."

msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :const:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Omfattar en befintlig Python-socket *sock* och returnerar en instans av :"
"attr:`SSLContext.sslsocket_class` (standard :class:`SSLSocket`). Det "
"returnerade SSL-uttaget är knutet till kontexten, dess inställningar och "
"certifikat. *sock* måste vara ett :const:`~socket.SOCK_STREAM`-uttag; andra "
"uttagstyper stöds inte."

msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"Parametern ``server_side`` är en boolean som anger om det är server- eller "
"klientsidans beteende som önskas från detta uttag."

msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"För uttag på klientsidan är kontextkonstruktionen lat; om det underliggande "
"uttaget inte är anslutet ännu kommer kontextkonstruktionen att utföras efter "
"att :meth:`connect` anropas på uttaget.  För uttag på serversidan, om "
"uttaget inte har någon fjärrpeer, antas det vara ett lyssnande uttag, och "
"SSL-omslaget på serversidan utförs automatiskt på klientanslutningar som "
"accepteras via metoden :meth:`accept`. Metoden kan ge upphov till :exc:"
"`SSLError`."

msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"Vid klientanslutningar anger den valfria parametern *server_hostname* "
"värdnamnet på den tjänst som vi ansluter till.  Detta gör att en enda server "
"kan vara värd för flera SSL-baserade tjänster med olika certifikat, på "
"liknande sätt som virtuella HTTP-värdar. Om *server_hostname* anges kommer "
"ett :exc:`ValueError` att uppstå om *server_side* är true."

msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"Parametern ``do_handshake_on_connect`` anger om SSL-handskakningen ska göras "
"automatiskt efter en :meth:`socket.connect`, eller om applikationsprogrammet "
"ska göra det explicit genom att anropa metoden :meth:`SSLSocket."
"do_handshake`.  Genom att anropa :meth:`SSLSocket.do_handshake` explicit får "
"programmet kontroll över blockeringsbeteendet för socket I/O som är "
"involverat i handskakningen."

msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"Parametern ``suppress_ragged_eofs`` anger hur metoden :meth:`SSLSocket.recv` "
"ska signalera oväntade EOF från den andra änden av anslutningen.  Om den "
"anges som :const:`True` (standard) returnerar den en normal EOF (ett tomt "
"bytesobjekt) som svar på oväntade EOF-fel från den underliggande sockeln; om "
"den anges som :const:`False` returneras undantagen tillbaka till anroparen."

msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, se :attr:`~SSLSocket.session`."

msgid ""
"To wrap an :class:`SSLSocket` in another :class:`SSLSocket`, use :meth:"
"`SSLContext.wrap_bio`."
msgstr ""
"För att linda in en :class:`SSLSocket` i en annan :class:`SSLSocket`, "
"använd :meth:`SSLContext.wrap_bio`."

msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"Tillåt alltid att ett server_hostname skickas med, även om OpenSSL inte har "
"SNI."

msgid "*session* argument was added."
msgstr "*session*-argumentet har lagts till."

msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""
"Metoden returnerar en instans av :attr:`SSLContext.sslsocket_class` istället "
"för hårdkodad :class:`SSLSocket`."

msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""
"Returtyp för :meth:`SSLContext.wrap_socket`, standard är :class:`SSLSocket`. "
"Attributet kan åsidosättas på en instans av class för att returnera en "
"anpassad underklass av :class:`SSLSocket`."

msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"Packa in BIO-objekten *incoming* och *outgoing* och returnera en instans av :"
"attr:`SSLContext.sslobject_class` (standard :class:`SSLObject`). SSL-"
"rutinerna läser inmatningsdata från det inkommande BIO-objektet och skriver "
"data till det utgående BIO-objektet."

msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"Parametrarna *server_side*, *server_hostname* och *session* har samma "
"betydelse som i :meth:`SSLContext.wrap_socket`."

msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""
"Metoden returnerar en instans av :attr:`SSLContext.sslobject_class` istället "
"för hårdkodad :class:`SSLObject`."

msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""
"Returtyp för :meth:`SSLContext.wrap_bio`, standard är :class:`SSLObject`. "
"Attributet kan åsidosättas på en instans av class för att returnera en "
"anpassad underklass av :class:`SSLObject`."

msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/>`_ to their "
"numeric values.  For example, here is the total number of hits and misses in "
"the session cache since the context was created::"
msgstr ""
"Hämta statistik om de SSL-sessioner som skapats eller hanterats av detta "
"sammanhang. En ordbok returneras som mappar namnen på varje "
"\"informationsdel\" <https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/"
">`_ till deras numeriska värden.  Här visas t.ex. det totala antalet träffar "
"och missar i sessionscachen sedan kontexten skapades::"

msgid ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"
msgstr ""
">>> statistik = context.session_stats()\n"
">>> stats['träffar'], stats['missar']\n"
"(0, 0)"

msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""
"Huruvida peer-certifikatets värdnamn ska matchas i :meth:`SSLSocket."
"do_handshake`. Kontextens :attr:`~SSLContext.verify_mode` måste vara "
"inställd på :data:`CERT_OPTIONAL` eller :data:`CERT_REQUIRED`, och du måste "
"skicka *server_hostname* till :meth:`~SSLContext.wrap_socket` för att matcha "
"värdnamnet.  Om du aktiverar kontroll av värdnamn ställs :attr:`~SSLContext."
"verify_mode` automatiskt in från :data:`CERT_NONE` till :data:"
"`CERT_REQUIRED`.  Det kan inte sättas tillbaka till :data:`CERT_NONE` så "
"länge värdnamnskontrollen är aktiverad. Protokollet :data:"
"`PROTOCOL_TLS_CLIENT` aktiverar värdnamnskontroll som standard. Med andra "
"protokoll måste värdnamnskontroll aktiveras uttryckligen."

msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"
msgstr ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"

msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSLContext.verify_mode` ändras nu automatiskt till :data:"
"`CERT_REQUIRED` när kontroll av värdnamn är aktiverat och :attr:`~SSLContext."
"verify_mode` är :data:`CERT_NONE`. Tidigare skulle samma operation ha "
"misslyckats med ett :exc:`ValueError`."

msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"Skriv TLS-nycklar till en keylog-fil när nyckelmaterial genereras eller tas "
"emot. Keylog-filen är endast avsedd för felsökningsändamål. Filformatet "
"specificeras av NSS och används av många trafikanalysatorer, t.ex. "
"Wireshark. Loggfilen öppnas i append-only-läge. Skrivningar synkroniseras "
"mellan trådar, men inte mellan processer."

msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :const:`PROTOCOL_TLS`, :"
"const:`PROTOCOL_TLS_CLIENT`, and :const:`PROTOCOL_TLS_SERVER`."
msgstr ""
"En :class:`TLSVersion` enum-medlem som representerar den högsta TLS-"
"versionen som stöds. Standardvärdet är :attr:`TLSVersion.MAXIMUM_SUPPORTED`. "
"Attributet är skrivskyddat för andra protokoll än :const:`PROTOCOL_TLS`, :"
"const:`PROTOCOL_TLS_CLIENT` och :const:`PROTOCOL_TLS_SERVER`."

msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""
"Attributen :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` och :attr:`SSLContext.options` påverkar alla de SSL- och "
"TLS-versioner som stöds av kontexten. Implementationen förhindrar inte "
"ogiltiga kombinationer. Till exempel kommer en kontext med :attr:"
"`OP_NO_TLSv1_2` i :attr:`~SSLContext.options` och :attr:`~SSLContext."
"maximum_version` satt till :attr:`TLSVersion.TLSv1_2` inte att kunna "
"upprätta en TLS 1.2-anslutning."

msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"Som :attr:`SSLContext.maximum_version` förutom att det är den lägsta "
"versionen som stöds eller :attr:`TLSVersion.MINIMUM_SUPPORTED`."

msgid ""
"Control the number of TLS 1.3 session tickets of a :const:"
"`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""
"Styr antalet TLS 1.3-sessionsbiljetter för en :const:`PROTOCOL_TLS_SERVER`-"
"kontext. Inställningen har ingen inverkan på TLS 1.0 till 1.2-anslutningar."

msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"Ett heltal som representerar den uppsättning SSL-alternativ som är "
"aktiverade i detta sammanhang. Standardvärdet är :data:`OP_ALL`, men du kan "
"ange andra alternativ som t.ex. :data:`OP_NO_SSLv2` genom att sätta ihop dem "
"med OR."

msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` returnerar :class:`Options` flaggor:"

msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and :attr:`SSLContext."
"maximum_version` instead."
msgstr ""
"Alla ``OP_NO_SSL*`` och ``OP_NO_TLS*`` alternativ har blivit föråldrade "
"sedan Python 3.7. Använd :attr:`SSLContext.minimum_version` och :attr:"
"`SSLContext.maximum_version` istället."

msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"Aktivera TLS 1.3-klientautentisering efter handskakning. Autentisering efter "
"handskakning är inaktiverad som standard och en server kan bara begära ett "
"TLS-klientcertifikat under den inledande handskakningen. När den är "
"aktiverad kan en server begära ett TLS-klientcertifikat när som helst efter "
"handskakningen."

msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""
"När den är aktiverad på sockets på klientsidan signalerar klienten till "
"servern att den stöder autentisering efter handskakning."

msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""
"När det är aktiverat på server-sidans socklar måste :attr:`SSLContext."
"verify_mode` också vara inställt på :data:`CERT_OPTIONAL` eller :data:"
"`CERT_REQUIRED`. Det faktiska utbytet av klientcertifikat fördröjs tills :"
"meth:`SSLSocket.verify_client_post_handshake` anropas och vissa I/O utförs."

msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"Den protokollversion som valdes när kontexten konstruerades.  Detta attribut "
"är skrivskyddat."

msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"Om :attr:`~SSLContext.check_hostname` faller tillbaka för att verifiera "
"certets gemensamma ämnesnamn i avsaknad av ett alternativt ämnesnamnstillägg "
"(standard: true)."

msgid ""
"The flag had no effect with OpenSSL before version 1.1.1l. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""
"Flaggan hade ingen effekt med OpenSSL före version 1.1.1l. Python 3.8.9, "
"3.9.3 och 3.10 innehåller lösningar för tidigare versioner."

msgid ""
"An integer representing the `security level <https://docs.openssl.org/master/"
"man3/SSL_CTX_get_security_level/>`_ for the context. This attribute is read-"
"only."
msgstr ""
"Ett heltal som representerar `säkerhetsnivån <https://docs.openssl.org/"
"master/man3/SSL_CTX_get_security_level/>`_ för kontexten. Detta attribut är "
"skrivskyddat."

msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"Flaggorna för verifiering av certifikat. Du kan ange flaggor som :data:"
"`VERIFY_CRL_CHECK_LEAF` genom att sätta ihop dem med OR. Som standard varken "
"kräver eller verifierar OpenSSL återkallningslistor för certifikat (CRL)."

msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ""
":attr:`SSLContext.verify_flags` returnerar :class:`VerifyFlags` flaggor:"

msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"Om man ska försöka verifiera andra peers certifikat och hur man ska agera om "
"verifieringen misslyckas.  Detta attribut måste vara ett av :data:"
"`CERT_NONE`, :data:`CERT_OPTIONAL` eller :data:`CERT_REQUIRED`."

msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` returnerar :class:`VerifyMode` enum:"

msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a client-side connection."
msgstr ""
"Aktiverar TLS-PSK-autentisering (pre-shared key) på en anslutning på "
"klientsidan."

msgid ""
"In general, certificate based authentication should be preferred over this "
"method."
msgstr ""
"I allmänhet bör certifikatbaserad autentisering föredras framför denna metod."

msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(hint: str | None) -> tuple[str | None, bytes]``. The ``hint`` "
"parameter is an optional identity hint sent by the server. The return value "
"is a tuple in the form (client-identity, psk). Client-identity is an "
"optional string which may be used by the server to select a corresponding "
"PSK for the client. The string must be less than or equal to ``256`` octets "
"when UTF-8 encoded. PSK is a :term:`bytes-like object` representing the pre-"
"shared key. Return a zero length PSK to reject the connection."
msgstr ""
"Parametern ``callback`` är ett anropbart objekt med signaturen: ``def "
"callback(hint: str | None) -> tuple[str | None, bytes]``. Parametern "
"``hint`` är en valfri identitetshint som skickas av servern. Returvärdet är "
"en tupel i formen (client-identity, psk). Client-identity är en valfri "
"sträng som kan användas av servern för att välja en motsvarande PSK för "
"klienten. Strängen måste vara mindre än eller lika med ``256`` oktetter när "
"den är UTF-8-kodad. PSK är ett :term:`bytesliknande objekt` som "
"representerar den fördelade nyckeln. Returnera en PSK med längden noll för "
"att avvisa anslutningen."

msgid "Setting ``callback`` to :const:`None` removes any existing callback."
msgstr ""
"Om ``callback`` sätts till :const:`None` tas alla befintliga callbacks bort."

msgid "When using TLS 1.3:"
msgstr "När du använder TLS 1.3:"

msgid "the ``hint`` parameter is always :const:`None`."
msgstr "parametern ``hint`` är alltid :const:`None`."

msgid "client-identity must be a non-empty string."
msgstr "client-identity måste vara en icke-tom sträng."

msgid "Example usage::"
msgstr "Exempel på användning::"

msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# A table using the hint from the server:\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# En enkel lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# En tabell med hjälp av ledtråden från servern:\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('fasad')\n"
"}\n"
"def återuppringning(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"

msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_PSK` is "
"``False``."
msgstr ""
"Denna metod ger upphov till :exc:`NotImplementedError` om :data:`HAS_PSK` är "
"``False``."

msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a server-side connection."
msgstr ""
"Aktiverar TLS-PSK-autentisering (pre-shared key) för en anslutning på "
"serversidan."

msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(identity: str | None) -> bytes``. The ``identity`` parameter is an "
"optional identity sent by the client which can be used to select a "
"corresponding PSK. The return value is a :term:`bytes-like object` "
"representing the pre-shared key. Return a zero length PSK to reject the "
"connection."
msgstr ""
"Parametern ``callback`` är ett anropbart objekt med signaturen: ``def "
"callback(identity: str | None) -> bytes``. Parametern ``identity`` är en "
"valfri identitet som skickas av klienten och som kan användas för att välja "
"en motsvarande PSK. Returvärdet är ett :term:`bytesliknande objekt` som "
"representerar den fördelade nyckeln. Returnera en PSK med noll längd för att "
"avvisa anslutningen."

msgid ""
"The parameter ``identity_hint`` is an optional identity hint string sent to "
"the client. The string must be less than or equal to ``256`` octets when "
"UTF-8 encoded."
msgstr ""
"Parametern ``identity_hint`` är en valfri identitetshintsträng som skickas "
"till klienten. Strängen måste vara mindre än eller lika med ``256`` oktetter "
"när den är UTF-8-kodad."

msgid ""
"When using TLS 1.3 the ``identity_hint`` parameter is not sent to the client."
msgstr ""
"Vid användning av TLS 1.3 skickas inte parametern ``identity_hint`` till "
"klienten."

msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identity: psk)\n"
"\n"
"# A table using the identity of the client:\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identity):\n"
"    return psk_table.get(identity, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# En enkel lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identitet: psk)\n"
"\n"
"# En tabell som använder klientens identitet:\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identitet):\n"
"    return psk_table.get(identitet, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"

msgid "Certificates"
msgstr "Diplom"

msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"Certifikat är i allmänhet en del av ett system med offentliga nycklar och "
"privata nycklar.  I detta system tilldelas varje *principal* (som kan vara "
"en maskin, en person eller en organisation) en unik krypteringsnyckel i två "
"delar.  Den ena delen av nyckeln är offentlig och kallas *public key*; den "
"andra delen hålls hemlig och kallas *private key*.  De två delarna är "
"relaterade på så sätt att om man krypterar ett meddelande med den ena delen "
"kan man dekryptera det med den andra delen, och **endast** med den andra "
"delen."

msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"Ett certifikat innehåller information om två huvudmän.  Det innehåller "
"namnet på en *subjekt* och subjektets publika nyckel.  Det innehåller också "
"ett uttalande från en andra huvudman, *utfärdaren*, om att subjektet är den "
"hen utger sig för att vara och att detta verkligen är subjektets publika "
"nyckel.  Utfärdarens uttalande är signerat med utfärdarens privata nyckel, "
"som endast utfärdaren känner till.  Vem som helst kan dock verifiera "
"utfärdarens uttalande genom att hitta utfärdarens publika nyckel, dekryptera "
"uttalandet med den och jämföra det med den övriga informationen i "
"certifikatet. Certifikatet innehåller också information om den tidsperiod "
"under vilken det är giltigt.  Detta uttrycks som två fält, kallade "
"\"notBefore\" och \"notAfter\"."

msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"I Python-användningen av certifikat kan en klient eller server använda ett "
"certifikat för att bevisa vem de är.  Den andra sidan av en "
"nätverksanslutning kan också krävas på ett certifikat, och det certifikatet "
"kan valideras på ett sätt som tillfredsställer den klient eller server som "
"kräver sådan validering.  Anslutningsförsöket kan ställas in så att ett "
"undantag utlöses om valideringen misslyckas. Valideringen görs automatiskt "
"av det underliggande OpenSSL-ramverket och applikationen behöver inte "
"bekymra sig om hur det fungerar.  Men applikationen behöver vanligtvis "
"tillhandahålla uppsättningar av certifikat för att denna process ska kunna "
"äga rum."

msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python använder filer för att innehålla certifikat.  De bör formateras som "
"\"PEM\" (se :rfc:`1422`), vilket är en bas-64-kodad form omsluten av en "
"rubrikrad och en sidfot:"

msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN CERTIFIKAT-----\n"
"... (certifikat i base64 PEM-kodning) ...\n"
"-----SLUTA CERTIFIKAT-----"

msgid "Certificate chains"
msgstr "Certifikatkedjor"

msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"De Python-filer som innehåller certifikat kan innehålla en sekvens av "
"certifikat, ibland kallad en *certifikatkedja*.  Denna kedja bör börja med "
"det specifika certifikatet för den principal som \"är\" klienten eller "
"servern, och sedan certifikatet för utfärdaren av det certifikatet, och "
"sedan certifikatet för utfärdaren av *det* certifikatet, och så vidare upp i "
"kedjan tills man kommer till ett certifikat som är *självsignerat*, det vill "
"säga ett certifikat som har samma subject och utfärdare, ibland kallat ett "
"*rotcertifikat*.  Certifikaten ska bara sammankopplas i certifikatfilen.  "
"Anta till exempel att vi har en kedja med tre certifikat, från vårt "
"servercertifikat till certifikatet för den certifikatutfärdare som signerade "
"vårt servercertifikat, till rotcertifikatet för den myndighet som utfärdade "
"certifikatutfärdarens certifikat::"

msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate for your server)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the certificate for the CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the root certificate for the CA's issuer)...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BÖRJA CERTIFIKAT-----\n"
"... (certifikat för din server) ...\n"
"-----AVSLUTA CERTIFIKAT-----\n"
"-----BÖRJAR CERTIFIKAT-----\n"
"... (certifikatet för CA) ...\n"
"-----AVSLUTA CERTIFIKAT-----\n"
"-----BÖRJAR CERTIFIKAT-----\n"
"... (rotcertifikatet för CA:s utfärdare)...\n"
"-----AVSLUTA CERTIFIKAT-----"

msgid "CA certificates"
msgstr "CA-certifikat"

msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"Om du ska kräva validering av den andra sidan av anslutningens certifikat "
"måste du tillhandahålla en \"CA certs\"-fil, fylld med certifikatkedjorna "
"för varje utfärdare som du är villig att lita på.  Återigen innehåller den "
"här filen bara dessa kedjor sammankopplade tillsammans.  För validering "
"kommer Python att använda den första kedjan som den hittar i filen som "
"matchar.  Plattformens certifikatfil kan användas genom att anropa :meth:"
"`SSLContext.load_default_certs`, detta görs automatiskt med :func:`."
"create_default_context`."

msgid "Combined key and certificate"
msgstr "Kombinerad nyckel och certifikat"

msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"needs to be passed.  If the private key is stored with the certificate, it "
"should come before the first certificate in the certificate chain::"
msgstr ""
"Ofta lagras den privata nyckeln i samma fil som certifikatet; i detta fall "
"behöver endast parametern ``certfile`` till :meth:`SSLContext."
"load_cert_chain` skickas.  Om den privata nyckeln lagras med certifikatet "
"bör den komma före det första certifikatet i certifikatkedjan::"

msgid ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (private key in base64 encoding) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN RSA PRIVAT NYCKEL-----\n"
"... (privat nyckel i base64-kodning) ...\n"
"-----AVSLUTA RSA PRIVAT NYCKEL-----\n"
"-----BEGIN CERTIFIKAT-----\n"
"... (certifikat i base64 PEM-kodning) ...\n"
"-----AVSLUTA CERTIFIKAT-----"

msgid "Self-signed certificates"
msgstr "Självsignerade certifikat"

msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"Om du ska skapa en server som tillhandahåller SSL-krypterade "
"anslutningstjänster måste du skaffa ett certifikat för den tjänsten.  Det "
"finns många sätt att skaffa lämpliga certifikat, t.ex. genom att köpa ett "
"från en certifikatutfärdare.  Ett annat vanligt sätt är att skapa ett "
"självsignerat certifikat.  Det enklaste sättet att göra detta är med OpenSSL-"
"paketet, genom att använda något i stil med följande::"

msgid ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, "
"Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"
msgstr ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generera en 1024 bitars RSA privat nyckel\n"
".......++++++\n"
".............................++++++\n"
"skriver ny privat nyckel till 'cert.pem'\n"
"-----\n"
"Du kommer nu att bli ombedd att ange information som kommer att ingå\n"
"i din certifikatbegäran.\n"
"Det du ska ange är vad som kallas ett Distinguished Name eller en DN.\n"
"Det finns ganska många fält, men du kan lämna vissa tomma\n"
"För vissa fält finns det ett standardvärde,\n"
"Om du anger '.' lämnas fältet tomt.\n"
"-----\n"
"Landsnamn (2-bokstavskod) [AU]:US\n"
"Delstatens eller provinsens namn (fullständigt namn) [Some-State]:MyState\n"
"Namn på lokalitet (t.ex. stad) []:Some City\n"
"Organisationsnamn (t.ex. företag) [Internet Widgits Pty Ltd]:My "
"Organization, Inc.\n"
"Namn på organisatorisk enhet (t.ex. sektion) []:My Group\n"
"Gemensamt namn (t.ex. ditt namn) []:myserver.mygroup.myorganization.com\n"
"E-postadress []:ops@myserver.mygroup.myorganization.com\n"
"%"

msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"Nackdelen med ett självsignerat certifikat är att det är ett eget "
"rotcertifikat, och ingen annan kommer att ha det i sin cache av kända (och "
"betrodda) rotcertifikat."

msgid "Examples"
msgstr "Exempel"

msgid "Testing for SSL support"
msgstr "Testning för SSL-stöd"

msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"För att testa om det finns SSL-stöd i en Python-installation bör "
"användarkoden använda följande idiom::"

msgid ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # do something that requires SSL support"
msgstr ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # do something that requires SSL support"

msgid "Client-side operation"
msgstr "Operation på klientsidan"

msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"I detta exempel skapas en SSL-kontext med rekommenderade "
"säkerhetsinställningar för klientsocklar, inklusive automatisk "
"certifikatverifiering::"

msgid ">>> context = ssl.create_default_context()"
msgstr ">>> kontext = ssl.create_default_context()"

msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""
"Om du föredrar att göra säkerhetsinställningarna själv kan du skapa ett "
"sammanhang från början (men tänk på att du kanske inte får rätt "
"inställningar)::"

msgid ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"
msgstr ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"

msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(detta utdrag förutsätter att ditt operativsystem placerar ett paket med "
"alla CA-certifikat i ``/etc/ssl/certs/ca-bundle.crt``; om inte, får du ett "
"fel och måste justera platsen)"

msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
"Protokollet :data:`PROTOCOL_TLS_CLIENT` konfigurerar kontexten för "
"validering av certifikat och verifiering av värdnamn. :attr:`~SSLContext."
"verify_mode` är inställd på :data:`CERT_REQUIRED` och :attr:`~SSLContext."
"check_hostname` är inställd på ``True``. Alla andra protokoll skapar SSL-"
"kontexter med osäkra standardvärden."

msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"När du använder kontexten för att ansluta till en server validerar :const:"
"`CERT_REQUIRED` och :attr:`~SSLContext.check_hostname` servercertifikatet: "
"det säkerställer att servercertifikatet har signerats med ett av CA-"
"certifikaten, kontrollerar att signaturen är korrekt och verifierar andra "
"egenskaper som giltighet och identitet för värdnamnet::"

msgid ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"...                            server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"
msgstr ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"... server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"

msgid "You may then fetch the certificate::"
msgstr "Du kan då hämta ut certifikatet::"

msgid ">>> cert = conn.getpeercert()"
msgstr ">>> cert = conn.getpeercert()"

msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"En visuell kontroll visar att certifikatet identifierar den önskade tjänsten "
"(dvs. HTTPS-värden ``www.python.org``)::"

msgid ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': ('http://cacerts.digicert.com/"
"DigiCertSHA2ExtendedValidationServerCA.crt',),\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1."
"crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-server-g1."
"crl'),\n"
" 'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName', 'DigiCert SHA2 Extended Validation Server "
"CA'),)),\n"
" 'notAfter': 'Sep  9 12:00:00 2016 GMT',\n"
" 'notBefore': 'Sep  5 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Private Organization'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName', 'Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org'),)),\n"
" 'subjectAltName': (('DNS', 'www.python.org'),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"
msgstr ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': ('http://cacerts.digicert.com/"
"DigiCertSHA2ExtendedValidationServerCA.crt',),\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1."
"crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-server-g1."
"crl'),\n"
" \"issuer\": ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName','DigiCert SHA2 Extended Validation Server "
"CA'),)),\n"
" \"notAfter\": \"9 september 12:00:00 2016 GMT\",\n"
" 'notBefore': '5 september 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Privat organisation'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName','Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org')),)),\n"
" \"subjectAltName\": ((\"DNS\", \"www.python.org\"),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"

msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"Nu när SSL-kanalen har upprättats och certifikatet har verifierats kan du "
"fortsätta att prata med servern::"

msgid ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Date: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Age: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"
msgstr ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Datum: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Ålder: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"

msgid "Server-side operation"
msgstr "Drift på serversidan"

msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"För serverdrift behöver du vanligtvis ha ett servercertifikat och en privat "
"nyckel i varsin fil.  Du skapar först en kontext som innehåller nyckeln och "
"certifikatet, så att klienterna kan kontrollera din äkthet.  Sedan öppnar du "
"en socket, binder den till en port, anropar :meth:`listen` på den och börjar "
"vänta på att klienter ska ansluta::"

msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.example.com', 10023))\n"
"bindsocket.listen(5)"
msgstr ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.example.com', 10023))\n"
"bindsocket.listen(5)"

msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"När en klient ansluter anropar du :meth:`accept` på sockeln för att hämta "
"den nya sockeln från andra änden och använder kontextens :meth:`SSLContext."
"wrap_socket`-metod för att skapa en SSL-socket på serversidan för "
"anslutningen:"

msgid ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"
msgstr ""
"medan True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    försök:\n"
"        deal_with_client(connstream)\n"
"    slutligen: deal_with_client\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"

msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"Sedan läser du data från ``connstream`` och gör något med den tills du är "
"klar med klienten (eller klienten är klar med dig)::"

msgid ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # empty data means the client is finished with us\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # we'll assume do_something returns False\n"
"            # when we're finished with client\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # finished with client"
msgstr ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # tomma data betyder att klienten är klar med oss\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # vi antar att do_something returnerar False\n"
"            # när vi är färdiga med klienten\n"
"            paus\n"
"        data = connstream.recv(1024)\n"
"    # färdig med klienten"

msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"Och gå tillbaka till att lyssna efter nya klientanslutningar (naturligtvis "
"skulle en riktig server förmodligen hantera varje klientanslutning i en "
"separat tråd, eller sätta socklarna i :ref:`icke-blockerande läge <ssl-"
"nonblocking>` och använda en händelseslinga)."

msgid "Notes on non-blocking sockets"
msgstr "Anteckningar om icke-blockerande sockets"

msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"SSL-uttag beter sig något annorlunda än vanliga uttag i icke-blockerande "
"läge. När du arbetar med icke-blockerande sockets finns det därför flera "
"saker du måste vara medveten om:"

msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"De flesta :class:`SSLSocket`-metoder kommer att ge upphov till antingen :exc:"
"`SSLWantWriteError` eller :exc:`SSLWantReadError` istället för :exc:"
"`BlockingIOError` om en I/O-operation skulle blockeras. :exc:"
"`SSLWantReadError` kommer att ges upphov till om en läsoperation på den "
"underliggande sockeln är nödvändig, och :exc:`SSLWantWriteError` för en "
"skrivoperation på den underliggande sockeln. Observera att försök att "
"*skriva* till ett SSL-uttag kan kräva att man först *läser* från det "
"underliggande uttaget, och försök att *läsa* från SSL-uttaget kan kräva att "
"man först *skriver* till det underliggande uttaget."

msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"I tidigare Python-versioner returnerade metoden :meth:`!SSLSocket.send` noll "
"istället för att ge upphov till :exc:`SSLWantWriteError` eller :exc:"
"`SSLWantReadError`."

msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
"Om du anropar :func:`~select.select` får du veta att det går att läsa från "
"(eller skriva till) sockeln på OS-nivå, men det innebär inte att det finns "
"tillräckligt med data i det övre SSL-lagret.  Det kan t.ex. hända att bara "
"en del av en SSL-ram har kommit fram.  Därför måste du vara redo att hantera "
"misslyckanden med :meth:`SSLSocket.recv` och :meth:`SSLSocket.send`, och "
"försöka igen efter ett nytt anrop till :func:`~select.select`."

msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"Omvänt, eftersom SSL-lagret har sin egen inramning, kan ett SSL-uttag "
"fortfarande ha data tillgängliga för läsning utan att :func:`~select.select` "
"är medveten om det.  Därför bör du först anropa :meth:`SSLSocket.recv` för "
"att tömma alla potentiellt tillgängliga data, och sedan bara blockera på "
"ett :func:`~select.select`-anrop om det fortfarande är nödvändigt."

msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(Naturligtvis gäller liknande bestämmelser när du använder andra primitiver "
"som :func:`~select.poll`, eller de i :mod:`selectors`-modulen)"

msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"Själva SSL-handskakningen kommer att vara icke-blockerande: metoden :meth:"
"`SSLSocket.do_handshake` måste prövas igen tills den returneras "
"framgångsrikt.  Här är en sammanfattning som använder :func:`~select.select` "
"för att vänta på att uttaget är redo::"

msgid ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"
msgstr ""
"medan True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        bryt\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"

msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level :ref:`Streams API <asyncio-"
"streams>`. It polls for events using the :mod:`selectors` module and "
"handles :exc:`SSLWantWriteError`, :exc:`SSLWantReadError` and :exc:"
"`BlockingIOError` exceptions. It runs the SSL handshake asynchronously as "
"well."
msgstr ""
"Modulen :mod:`asyncio` stöder :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` och tillhandahåller en högre nivå :ref:`Streams API <asyncio-"
"streams>`. Den pollar efter händelser med hjälp av modulen :mod:`selectors` "
"och hanterar undantagen :exc:`SSLWantWriteError`, :exc:`SSLWantReadError` "
"och :exc:`BlockingIOError`. Den kör även SSL-handskakningen asynkront."

msgid "Memory BIO Support"
msgstr "Stöd för BIO-minne"

msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"Ända sedan SSL-modulen introducerades i Python 2.6 har :class:`SSLSocket`-"
"klassen tillhandahållit två relaterade men distinkta områden av "
"funktionalitet:"

msgid "SSL protocol handling"
msgstr "Hantering av SSL-protokoll"

msgid "Network IO"
msgstr "Nätverk IO"

msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"API:et för nätverks-IO är identiskt med det som tillhandahålls av :class:"
"`socket.socket`, som :class:`SSLSocket` också ärver från. Detta gör att en "
"SSL-socket kan användas som en drop-in-ersättning för en vanlig socket, "
"vilket gör det mycket enkelt att lägga till SSL-stöd i en befintlig "
"applikation."

msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"Att kombinera SSL-protokollhantering och nätverks-IO fungerar vanligtvis "
"bra, men det finns vissa fall där det inte gör det. Ett exempel är asynkrona "
"IO-ramverk som vill använda en annan IO-multiplexeringsmodell än \"select/"
"poll on a file descriptor\"-modellen (beredskapsbaserad) som antas av :class:"
"`socket.socket` och av de interna OpenSSL-socket IO-rutinerna. Detta är mest "
"relevant för plattformar som Windows där denna modell inte är effektiv. För "
"detta ändamål tillhandahålls en variant med reducerat scope av :class:"
"`SSLSocket` som kallas :class:`SSLObject`."

msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"En reducerad variant av :class:`SSLSocket` som representerar en SSL-"
"protokollinstans som inte innehåller några IO-metoder för nätverk. Den här "
"klassen används vanligtvis av ramverksförfattare som vill implementera "
"asynkron IO för SSL via minnesbuffertar."

msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"Den här klassen implementerar ett gränssnitt ovanpå ett SSL-objekt på låg "
"nivå som implementeras av OpenSSL. Detta objekt fångar upp tillståndet för "
"en SSL-anslutning men tillhandahåller inte någon egen nätverks-IO. IO måste "
"utföras genom separata \"BIO\"-objekt som är OpenSSL:s abstraktionslager för "
"IO."

msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"Denna klass har ingen offentlig konstruktör.  En instans av :class:"
"`SSLObject` måste skapas med hjälp av metoden :meth:`~SSLContext.wrap_bio`. "
"Denna metod skapar :class:`SSLObject`-instansen och binder den till ett par "
"BIO:er. Den *inkommande* BIO används för att skicka data från Python till "
"SSL-protokollinstansen, medan den *utgående* BIO används för att skicka data "
"åt andra hållet."

msgid "The following methods are available:"
msgstr "Följande metoder finns tillgängliga:"

msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

msgid ":meth:`~SSLSocket.get_verified_chain`"
msgstr ":meth:`~SSLSocket.get_verified_chain`"

msgid ":meth:`~SSLSocket.get_unverified_chain`"
msgstr ":meth:`~SSLSocket.get_unverified_chain`"

msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
"Jämfört med :class:`SSLSocket` saknar detta objekt följande egenskaper:"

msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""
"Alla former av nätverks-IO; ``recv()`` och ``send()`` läser och skriver "
"endast till de underliggande :class:`MemoryBIO`-buffertarna."

msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"Det finns ingen *do_handshake_on_connect*-mekanism. Du måste alltid manuellt "
"anropa :meth:`~SSLSocket.do_handshake` för att starta handskakningen."

msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""
"Det finns ingen hantering av *suppress_ragged_eofs*. Alla villkor för "
"filändar som bryter mot protokollet rapporteras via undantaget :exc:"
"`SSLEOFError`."

msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
"Anropet till metoden :meth:`~SSLSocket.unwrap` returnerar ingenting, till "
"skillnad från en SSL-socket där den underliggande sockeln returneras."

msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"Den *server_name_callback* callback som skickas till :meth:`SSLContext."
"set_servername_callback` kommer att få en :class:`SSLObject`-instans "
"istället för en :class:`SSLSocket`-instans som sin första parameter."

msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "Några anteckningar relaterade till användningen av :class:`SSLObject`:"

msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
"All IO på ett :class:`SSLObject` är :ref:``icke-blockerande <ssl-"
"nonblocking>`. Detta innebär att till exempel :meth:`~SSLSocket.read` kommer "
"att ge upphov till ett :exc:`SSLWantReadError` om det behöver mer data än "
"vad det inkommande IO:t har tillgängligt."

msgid ""
":class:`SSLObject` instances must be created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
":class:`SSLObject`-instanser måste skapas med :meth:`~SSLContext.wrap_bio`. "
"I tidigare versioner var det möjligt att skapa instanser direkt. Detta har "
"aldrig dokumenterats eller fått officiellt stöd."

msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"Ett SSLObject kommunicerar med omvärlden med hjälp av minnesbuffertar. "
"Klassen :class:`MemoryBIO` tillhandahåller en minnesbuffert som kan användas "
"för detta ändamål.  Den omsluter ett OpenSSL-minne BIO-objekt (Basic IO):"

msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"En minnesbuffert som kan användas för att skicka data mellan Python och en "
"SSL-protokollinstans."

msgid "Return the number of bytes currently in the memory buffer."
msgstr "Returnerar antalet bytes som för närvarande finns i minnesbufferten."

msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""
"En boolean som anger om minnet BIO är aktuellt vid filens slutposition."

msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"Läser upp till *n* bytes från minnesbufferten. Om *n* inte anges eller är "
"negativ returneras alla byte."

msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"Skriv bytena från *buf* till minnet BIO. Argumentet *buf* måste vara ett "
"objekt som stöder buffertprotokollet."

msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"Returvärdet är antalet byte som skrivits, vilket alltid är lika med längden "
"på *buf*."

msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"Skriver en EOF-markör till minnet BIO. Efter att denna metod har anropats är "
"det olagligt att anropa :meth:`~MemoryBIO.write`. Attributet :attr:`eof` "
"kommer att bli sant efter att all data som för närvarande finns i bufferten "
"har lästs."

msgid "SSL session"
msgstr "SSL-session"

msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Sessionsobjekt som används av :attr:`~SSLSocket.session`."

msgid "Security considerations"
msgstr "Överväganden om säkerhet"

msgid "Best defaults"
msgstr "Bästa standardvärden"

msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"För **klientanvändning**, om du inte har några särskilda krav på din "
"säkerhetspolicy, rekommenderas starkt att du använder funktionen :func:"
"`create_default_context` för att skapa din SSL-kontext. Den kommer att ladda "
"systemets betrodda CA-certifikat, aktivera certifikatvalidering och "
"värdnamnskontroll och försöka välja rimligt säkra protokoll- och "
"chifferinställningar."

msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Så här kan du till exempel använda klassen :class:`smtplib.SMTP` för att "
"skapa en betrodd, säker anslutning till en SMTP-server::"

msgid ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=context)\n"
"(220, b'2.0.0 Ready to start TLS')"
msgstr ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=kontext)\n"
"(220, b'2.0.0 Redo att starta TLS')"

msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"Om det behövs ett klientcertifikat för anslutningen kan det läggas till med :"
"meth:`SSLContext.load_cert_chain`."

msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"Om du däremot skapar SSL-kontexten genom att anropa :class:`SSLContext`-"
"konstruktören själv, kommer den inte att ha certifikatvalidering eller "
"kontroll av värdnamn aktiverat som standard.  Om du gör det bör du läsa "
"nedanstående stycken för att uppnå en bra säkerhetsnivå."

msgid "Manual settings"
msgstr "Manuella inställningar"

msgid "Verifying certificates"
msgstr "Verifiering av certifikat"

msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of the time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname. This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ""
"Vid direkt anrop av :class:`SSLContext`-konstruktören är :const:`CERT_NONE` "
"standard.  Eftersom den inte autentiserar den andra motparten kan det vara "
"osäkert, särskilt i klientläge där du för det mesta vill säkerställa att "
"servern du pratar med är äkta. I klientläge rekommenderas därför starkt att "
"använda :const:`CERT_REQUIRED`.  Det är dock inte tillräckligt i sig. Du "
"måste också kontrollera att servercertifikatet, som kan erhållas genom att "
"anropa :meth:`SSLSocket.getpeercert`, matchar den önskade tjänsten.  För "
"många protokoll och applikationer kan tjänsten identifieras med hjälp av "
"värdnamnet. Denna vanliga kontroll utförs automatiskt när :attr:`SSLContext."
"check_hostname` är aktiverad."

msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr ""
"Matchning av värdnamn utförs nu av OpenSSL. Python använder inte längre :"
"func:`match_hostname`."

msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"Om du i serverläget vill autentisera dina klienter med hjälp av SSL-lagret "
"(i stället för att använda en autentiseringsmekanism på högre nivå) måste du "
"också ange :const:`CERT_REQUIRED` och kontrollera klientcertifikatet på "
"samma sätt."

msgid "Protocol versions"
msgstr "Protokollversioner"

msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"SSL version 2 och 3 anses vara osäkra och är därför farliga att använda.  Om "
"du vill ha maximal kompatibilitet mellan klienter och servrar rekommenderas "
"det att du använder :const:`PROTOCOL_TLS_CLIENT` eller :const:"
"`PROTOCOL_TLS_SERVER` som protokollversion. SSLv2 och SSLv3 är inaktiverade "
"som standard."

msgid ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"
msgstr ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"

msgid ""
"The SSL context created above will only allow TLSv1.3 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""
"SSL-kontexten som skapades ovan tillåter endast TLSv1.3 och senare (om det "
"stöds av ditt system) anslutningar till en server. :const:"
"`PROTOCOL_TLS_CLIENT` innebär certifikatvalidering och värdnamnskontroller "
"som standard. Du måste ladda certifikat i kontexten."

msgid "Cipher selection"
msgstr "Val av chiffer"

msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-"
"list-format>`_. If you want to check which ciphers are enabled by a given "
"cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` "
"command on your system."
msgstr ""
"Om du har avancerade säkerhetskrav är det möjligt att finjustera de chiffer "
"som aktiveras när du förhandlar om en SSL-session genom metoden :meth:"
"`SSLContext.set_ciphers`.  Från och med Python 3.2.3 inaktiverar ssl-modulen "
"vissa svaga chiffer som standard, men du kanske vill begränsa valet av "
"chiffer ytterligare. Se till att läsa OpenSSL:s dokumentation om formatet "
"för `cipher list <https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-list-"
"format>`_. Om du vill kontrollera vilka chiffer som aktiveras av en viss "
"chifferlista, använd :meth:`SSLContext.get_ciphers` eller kommandot "
"``openssl ciphers`` på ditt system."

msgid "Multi-processing"
msgstr "Multiprocessing"

msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add` or :func:`~ssl.RAND_bytes` is "
"sufficient."
msgstr ""
"Om du använder den här modulen som en del av ett program med flera processer "
"(t.ex. med modulerna :mod:`multiprocessing` eller :mod:`concurrent."
"futures`), bör du vara medveten om att OpenSSL:s interna slumptalsgenerator "
"inte hanterar förgrenade processer på rätt sätt.  Program måste ändra PRNG-"
"tillståndet för den överordnade processen om de använder någon SSL-funktion "
"med :func:`os.fork`.  Varje lyckat anrop av :func:`~ssl.RAND_add` eller :"
"func:`~ssl.RAND_bytes` är tillräckligt."

msgid "TLS 1.3"
msgstr "TLS 1.3"

msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""
"Protokollet TLS 1.3 beter sig något annorlunda än tidigare versioner av TLS/"
"SSL. Vissa nya funktioner i TLS 1.3 är ännu inte tillgängliga."

msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 använder en disjunkt uppsättning chiffersviter. Alla AES-GCM- och "
"ChaCha20-chiffersviter är aktiverade som standard.  Metoden :meth:"
"`SSLContext.set_ciphers` kan inte aktivera eller inaktivera några TLS 1.3-"
"chiffer ännu, men :meth:`SSLContext.get_ciphers` returnerar dem."

msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Sessionsbiljetter skickas inte längre som en del av den inledande "
"handskakningen och hanteras annorlunda. :attr:`SSLSocket.session` och :class:"
"`SSLSession` är inte kompatibla med TLS 1.3."

msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Certifikat på klientsidan verifieras inte heller längre under den första "
"handskakningen.  En server kan begära ett certifikat när som helst.  "
"Klienter behandlar certifikatbegäran medan de skickar eller tar emot "
"programdata från servern."

msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"TLS 1.3-funktioner som tidig data, uppskjuten begäran om TLS-"
"klientcertifikat, konfiguration av signaturalgoritm och omkodning stöds inte "
"ännu."

msgid "Class :class:`socket.socket`"
msgstr "Klass :class:`socket.socket`"

msgid "Documentation of underlying :mod:`socket` class"
msgstr "Dokumentation av den underliggande :mod:`socket`-klassen"

msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS Stark Kryptering: En introduktion <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"

msgid "Intro from the Apache HTTP Server documentation"
msgstr "Intro från dokumentationen för Apache HTTP Server"

msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Förbättrad sekretess för elektronisk post på Internet: Part "
"II: Certificate-Based Key Management <1422>`"

msgid "Steve Kent"
msgstr "Steve Kent"

msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Slumpmässighetskrav för säkerhet <4086>`"

msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Profil för Internet X.509 Public Key Infrastructure-"
"certifikat och lista över återkallade certifikat (CRL) <5280>`"

msgid "D. Cooper"
msgstr "D. Cooper"

msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: TLS-protokollet (Transport Layer Security) version 1.2 "
"<5246>`"

msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: TLS-tillägg (Transport Layer Security) <6066>`"

msgid "D. Eastlake"
msgstr "D. Eastlake"

msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Parametrar för TLS (Transport Layer Security) <https://www.iana."
"org/assignments/tls-parameters/tls-parameters.xml>`_"

msgid "IANA"
msgstr "IANA"

msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:``RFC 7525: Rekommendationer för säker användning av TLS (Transport "
"Layer Security) och DTLS (Datagram Transport Layer Security) <7525>`"

msgid "IETF"
msgstr "IETF"

msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"mozillas TLS-rekommendationer för serversidan <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"

msgid "Mozilla"
msgstr "Mozilla"

msgid "OpenSSL"
msgstr "OpenSSL"

msgid "(use in module ssl)"
msgstr "(används i modul ssl)"

msgid "TLS"
msgstr "TLS"

msgid "SSL"
msgstr "SSL"

msgid "Transport Layer Security"
msgstr "Transport Layer Security"

msgid "Secure Sockets Layer"
msgstr "Secure Sockets Layer"

msgid "certificates"
msgstr "certifikat"

msgid "X509 certificate"
msgstr "X509-certifikat"
