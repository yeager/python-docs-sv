# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Event Loop"
msgstr "Händelseslinga"

msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**Källkod:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"

msgid "Preface"
msgstr "Förord"

msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"Händelseslingan är kärnan i varje asyncio-applikation. Händelseslingor kör "
"asynkrona uppgifter och återuppringningar, utför IO-operationer i nätverket "
"och kör underprocesser."

msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Programutvecklare bör vanligtvis använda asynciofunktionerna på hög nivå, "
"till exempel :func:`asyncio.run`, och bör sällan behöva referera till "
"loopobjektet eller anropa dess metoder.  Det här avsnittet är främst avsett "
"för författare av kod på lägre nivå, bibliotek och ramverk som behöver "
"finare kontroll över händelseslingans beteende."

msgid "Obtaining the Event Loop"
msgstr "Få fram händelseslingan"

msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"Följande lågnivåfunktioner kan användas för att hämta, ställa in eller skapa "
"en händelseslinga:"

msgid "Return the running event loop in the current OS thread."
msgstr "Returnerar den pågående händelseslingan i den aktuella OS-tråden."

msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr ""
"Skapa ett :exc:`RuntimeError` om det inte finns någon pågående "
"händelseslinga."

msgid "This function can only be called from a coroutine or a callback."
msgstr "Denna funktion kan endast anropas från en coroutine eller en callback."

msgid "Get the current event loop."
msgstr "Hämta den aktuella händelseslingan."

msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or "
"similar API), this function will always return the running event loop."
msgstr ""
"När den här funktionen anropas från en coroutine eller en callback (t.ex. "
"schemalagd med call_soon eller liknande API) returnerar den alltid den "
"pågående händelseslingan."

msgid ""
"If there is no running event loop set, the function will return the result "
"of the ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""
"Om det inte finns någon pågående händelseslinga inställd, returnerar "
"funktionen resultatet av anropet ``get_event_loop_policy()."
"get_event_loop()``."

msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Eftersom den här funktionen har ett ganska komplext beteende (särskilt när "
"anpassade policys för händelseslingor används) är det bättre att använda "
"funktionen :func:`get_running_loop` än :func:`get_event_loop` i coroutines "
"och callbacks."

msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr ""
"Som nämnts ovan bör du överväga att använda funktionen :func:`asyncio.run` "
"på högre nivå istället för att använda dessa funktioner på lägre nivå för "
"att manuellt skapa och stänga en händelseslinga."

msgid "Raises a :exc:`RuntimeError` if there is no current event loop."
msgstr ""
"Utlöser ett :exc:`RuntimeError` om det inte finns någon aktuell "
"händelseslinga."

msgid ""
"The :mod:`!asyncio` policy system is deprecated and will be removed in "
"Python 3.16; from there on, this function will return the current running "
"event loop if present else it will return the loop set by :func:"
"`set_event_loop`."
msgstr ""
"Policysystemet :mod:`!asyncio` är föråldrat och kommer att tas bort i Python "
"3.16; från och med då kommer denna funktion att returnera den aktuella "
"pågående händelseslingan om den finns annars kommer den att returnera den "
"slinga som ställts in av :func:`set_event_loop`."

msgid "Set *loop* as the current event loop for the current OS thread."
msgstr "Ange *loop* som aktuell händelseslinga för den aktuella OS-tråden."

msgid "Create and return a new event loop object."
msgstr "Skapa och returnera ett nytt objekt för händelseslingan."

msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Observera att beteendet hos funktionerna :func:`get_event_loop`, :func:"
"`set_event_loop` och :func:`new_event_loop` kan ändras genom :ref:`setting a "
"custom event loop policy <asyncio-policies>`."

msgid "Contents"
msgstr "Innehåll"

msgid "This documentation page contains the following sections:"
msgstr "Denna dokumentationssida innehåller följande avsnitt:"

msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"Avsnittet `Event Loop Methods`_ är referensdokumentationen för API:erna för "
"händelseslingan;"

msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"Avsnittet `Callback Handles`_ dokumenterar instanserna :class:`Handle` och :"
"class:`TimerHandle` som returneras från schemaläggningsmetoder som :meth:"
"`loop.call_soon` och :meth:`loop.call_later`;"

msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"Avsnittet `Server Objects`_ dokumenterar typer som returneras från metoder "
"för händelseslingor som :meth:`loop.create_server`;"

msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"Avsnittet `Event Loop Implementations`_ dokumenterar klasserna :class:"
"`SelectorEventLoop` och :class:`ProactorEventLoop`;"

msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"Avsnittet \"Exempel\" visar hur man arbetar med vissa API:er för "
"händelseslingor."

msgid "Event Loop Methods"
msgstr "Metoder för händelseslingor"

msgid "Event loops have **low-level** APIs for the following:"
msgstr "Händelseslingor har **lågnivå** API:er för följande:"

msgid "Running and stopping the loop"
msgstr "Starta och stoppa slingan"

msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr "Kör tills *future* (en instans av :class:`Future`) har slutförts."

msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Om argumentet är ett :ref:`coroutine-objekt <coroutine>` schemaläggs det "
"implicit för att köras som en :class:`asyncio.Task`."

msgid "Return the Future's result or raise its exception."
msgstr "Returnera Framtidens resultat eller ta upp dess undantag."

msgid "Run the event loop until :meth:`stop` is called."
msgstr "Kör händelseslingan tills :meth:`stop` anropas."

msgid ""
"If :meth:`stop` is called before :meth:`run_forever` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"Om :meth:`stop` anropas innan :meth:`run_forever` anropas, kommer loopen att "
"fråga I/O-väljaren en gång med en timeout på noll, köra alla callbacks som "
"är schemalagda som svar på I/O-händelser (och de som redan var schemalagda) "
"och sedan avsluta."

msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Om :meth:`stop` anropas medan :meth:`run_forever` körs, kommer loopen att "
"köra den aktuella batchen av callbacks och sedan avslutas. Observera att nya "
"återuppringningar som schemalagts av återuppringningar inte kommer att köras "
"i det här fallet; istället kommer de att köras nästa gång :meth:"
"`run_forever` eller :meth:`run_until_complete` anropas."

msgid "Stop the event loop."
msgstr "Stoppa händelseslingan."

msgid "Return ``True`` if the event loop is currently running."
msgstr "Returnerar ``True`` om händelseslingan körs för närvarande."

msgid "Return ``True`` if the event loop was closed."
msgstr "Returnerar ``True`` om händelseslingan stängdes."

msgid "Close the event loop."
msgstr "Stäng händelseslingan."

msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"Slingan får inte vara igång när denna funktion anropas. Alla väntande "
"återuppringningar kommer att kasseras."

msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"Den här metoden rensar alla köer och stänger av exekveraren, men väntar inte "
"på att exekveraren ska bli klar."

msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Denna metod är idempotent och irreversibel.  Inga andra metoder bör anropas "
"efter att händelseslingan har stängts."

msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"Schemalägger alla öppna :term:`asynkrona generator`-objekt att stängas med "
"ett :meth:`~agen.aclose`-anrop.  Efter anrop av denna metod kommer "
"händelseslingan att utfärda en varning om en ny asynkron generator itereras. "
"Detta bör användas för att på ett tillförlitligt sätt avsluta alla "
"schemalagda asynkrona generatorer."

msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ""
"Observera att det inte finns något behov av att anropa denna funktion när :"
"func:`asyncio.run` används."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.run_until_complete(loop.shutdown_asyncgens())\n"
"    loop.close()"
msgstr ""
"försök:\n"
"    loop.run_forever()\n"
"finally: kör\n"
"    loop.run_until_complete(loop.shutdown_asyncgens())\n"
"    loop.close()"

msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`~concurrent.futures.ThreadPoolExecutor`. Once "
"this method has been called, using the default executor with :meth:`loop."
"run_in_executor` will raise a :exc:`RuntimeError`."
msgstr ""
"Schemalägg stängningen av standardutföraren och vänta på att den ska ansluta "
"sig till alla trådar i :class:`~concurrent.futures.ThreadPoolExecutor`. När "
"denna metod har anropats, kommer användning av standardutföraren med :meth:"
"`loop.run_in_executor` att ge upphov till ett :exc:`RuntimeError`."

msgid ""
"The *timeout* parameter specifies the amount of time (in :class:`float` "
"seconds) the executor will be given to finish joining. With the default, "
"``None``, the executor is allowed an unlimited amount of time."
msgstr ""
"Parametern *timeout* anger hur lång tid (i :class:`float`-sekunder) som "
"köraren får på sig att avsluta anslutningen. Med standardvärdet ``None`` får "
"exekutören obegränsad tid på sig."

msgid ""
"If the *timeout* is reached, a :exc:`RuntimeWarning` is emitted and the "
"default executor is terminated without waiting for its threads to finish "
"joining."
msgstr ""
"Om *timeout* uppnås skickas en :exc:`RuntimeWarning` ut och "
"standardkörningen avslutas utan att vänta på att dess trådar ska ansluta sig."

msgid ""
"Do not call this method when using :func:`asyncio.run`, as the latter "
"handles default executor shutdown automatically."
msgstr ""
"Anropa inte den här metoden när du använder :func:`asyncio.run`, eftersom "
"den senare hanterar standardavstängning av exekveraren automatiskt."

msgid "Added the *timeout* parameter."
msgstr "Parametern *timeout* har lagts till."

msgid "Scheduling callbacks"
msgstr "Schemaläggning av återuppringningar"

msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Schemalägg *callback* :term:`callback` så att den anropas med *args*-"
"argument vid nästa iteration av händelseslingan."

msgid ""
"Return an instance of :class:`asyncio.Handle`, which can be used later to "
"cancel the callback."
msgstr ""
"Returnerar en instans av :class:`asyncio.Handle`, som kan användas senare "
"för att avbryta återuppringningen."

msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Callbacks anropas i den ordning som de registrerades. Varje callback kommer "
"att anropas exakt en gång."

msgid ""
"The optional keyword-only *context* argument specifies a custom :class:"
"`contextvars.Context` for the *callback* to run in. Callbacks use the "
"current context when no *context* is provided."
msgstr ""
"Det valfria argumentet *context*, som endast innehåller nyckelord, anger en "
"anpassad :class:`contextvars.Context` som *callback* ska köras i. "
"Återkallelser använder den aktuella kontexten när ingen *kontext* anges."

msgid "Unlike :meth:`call_soon_threadsafe`, this method is not thread-safe."
msgstr ""
"Till skillnad från :meth:`call_soon_threadsafe` är den här metoden inte "
"trådsäker."

msgid ""
"A thread-safe variant of :meth:`call_soon`. When scheduling callbacks from "
"another thread, this function *must* be used, since :meth:`call_soon` is not "
"thread-safe."
msgstr ""
"En trådsäker variant av :meth:`call_soon`. Vid schemaläggning av callbacks "
"från en annan tråd *måste* denna funktion användas, eftersom :meth:"
"`call_soon` inte är trådsäker."

msgid ""
"This function is safe to be called from a reentrant context or signal "
"handler, however, it is not safe or fruitful to use the returned handle in "
"such contexts."
msgstr ""
"Denna funktion är säker att anropa från en reentrant kontext eller "
"signalhanterare, men det är inte säkert eller fruktbart att använda det "
"returnerade handtaget i sådana sammanhang."

msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"Utlöser :exc:`RuntimeError` om den anropas i en loop som har stängts. Detta "
"kan hända i en sekundär tråd när huvudapplikationen stängs ner."

msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Se :ref:``concurrency and multithreading <asyncio-multithreading>` i "
"dokumentationen."

msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Parametern *context* (endast nyckelord) har lagts till. Se :pep:`567` för "
"mer information."

msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"De flesta :mod:`asyncio`-schemaläggningsfunktioner tillåter inte att "
"nyckelordsargument skickas.  För att göra det, använd :func:`functools."
"partial`::"

msgid ""
"# will schedule \"print(\"Hello\", flush=True)\"\n"
"loop.call_soon(\n"
"    functools.partial(print, \"Hello\", flush=True))"
msgstr ""
"# kommer att schemalägga \"print(\"Hello\", flush=True)\"\n"
"loop.call_soon(\n"
"    functools.partial(print, \"Hello\", flush=True))"

msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"Att använda partiella objekt är vanligtvis mer praktiskt än att använda "
"lambdas, eftersom asyncio kan göra partiella objekt bättre i felsöknings- "
"och felmeddelanden."

msgid "Scheduling delayed callbacks"
msgstr "Schemaläggning av fördröjda återuppringningar"

msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"Event loop tillhandahåller mekanismer för att schemalägga callback-"
"funktioner som ska anropas vid någon tidpunkt i framtiden.  Händelseslingan "
"använder monotona klockor för att hålla reda på tiden."

msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Schemalägg *callback* som ska anropas efter det angivna *delay*-antalet "
"sekunder (kan vara antingen ett int eller ett float)."

msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
"En instans av :class:`asyncio.TimerHandle` returneras som kan användas för "
"att avbryta återuppringningen."

msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* kommer att anropas exakt en gång.  Om två callbacks är "
"schemalagda för exakt samma tid, är ordningen i vilken de anropas "
"odefinierad."

msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"De valfria positionella *args* kommer att skickas till callbacken när den "
"anropas. Om du vill att återuppringningen ska anropas med nyckelordsargument "
"använder du :func:`functools.partial`."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *callback* ska köras i. "
"Den aktuella kontexten används när ingen *kontext* anges."

msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"I Python 3.7 och tidigare med standardimplementeringen av händelseslingan "
"kunde *fördröjningen* inte överstiga en dag. Detta har åtgärdats i Python "
"3.8."

msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Schemalägg *callback* så att den anropas vid den angivna absoluta "
"tidsstämpeln *when* (en int eller en float), med samma tidsreferens som :"
"meth:`loop.time`."

msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "Den här metodens beteende är detsamma som :meth:`call_later`."

msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"I Python 3.7 och tidigare med standardimplementeringen av händelseslingan "
"kunde skillnaden mellan *when* och aktuell tid inte överstiga en dag.  Detta "
"har åtgärdats i Python 3.8."

msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Returnerar aktuell tid, som ett :class:`float`-värde, enligt "
"händelseslingans interna monotona klocka."

msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"I Python 3.7 och tidigare skulle timeouts (relativ *delay* eller absolut "
"*when*) inte överstiga en dag.  Detta har åtgärdats i Python 3.8."

msgid "The :func:`asyncio.sleep` function."
msgstr "Funktionen :func:`asyncio.sleep`."

msgid "Creating Futures and Tasks"
msgstr "Skapa framtidsutsikter och uppgifter"

msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr ""
"Skapa ett :class:`asyncio.Future`-objekt som är kopplat till händelseslingan."

msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Detta är det föredragna sättet att skapa Futures i asyncio. Detta gör det "
"möjligt för tredjeparts händelseslingor att tillhandahålla alternativa "
"implementeringar av Future-objektet (med bättre prestanda eller "
"instrumentering)."

msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a :"
"class:`Task` object."
msgstr ""
"Schemalägg utförandet av :ref:`coroutine <coroutine>` *coro*. Returnerar "
"ett :class:`Task`-objekt."

msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"Händelseslingor från tredje part kan använda sin egen subklass av :class:"
"`Task` för interoperabilitet. I det här fallet är resultattypen en subklass "
"av :class:`Task`."

msgid ""
"The full function signature is largely the same as that of the :class:`Task` "
"constructor (or factory) - all of the keyword arguments to this function are "
"passed through to that interface."
msgstr ""
"Den fullständiga funktionssignaturen är i stort sett densamma som för :class:"
"`Task`-konstruktören (eller fabriken) - alla nyckelordsargument till denna "
"funktion skickas vidare till det gränssnittet."

msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Om argumentet *name* anges och inte ``None``, anges det som namnet på "
"uppgiften med hjälp av :meth:`Task.set_name`."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *coro* ska köras i. Den "
"aktuella kontextkopian skapas när ingen *kontext* anges."

msgid ""
"An optional keyword-only *eager_start* argument allows specifying if the "
"task should execute eagerly during the call to create_task, or be scheduled "
"later. If *eager_start* is not passed the mode set by :meth:`loop."
"set_task_factory` will be used."
msgstr ""
"Ett valfritt argument *eager_start*, som endast innehåller nyckelord, gör "
"det möjligt att ange om uppgiften ska utföras ivrigt under anropet till "
"create_task eller schemaläggas senare. Om *eager_start* inte anges kommer "
"det läge som anges av :meth:`loop.set_task_factory` att användas."

msgid "Added the *name* parameter."
msgstr "Parametern *name* har lagts till."

msgid "Added the *context* parameter."
msgstr "Parametern *context* har lagts till."

msgid ""
"Added ``kwargs`` which passes on arbitrary extra parameters, including  "
"``name`` and ``context``."
msgstr ""
"Lagt till ``kwargs`` som skickar vidare godtyckliga extra parametrar, "
"inklusive ``name`` och ``context``."

msgid ""
"Rolled back the change that passes on *name* and *context* (if it is None), "
"while still passing on other arbitrary keyword arguments (to avoid breaking "
"backwards compatibility with 3.13.3)."
msgstr ""
"Återställde ändringen som skickar vidare *name* och *context* (om det är "
"None), men som fortfarande skickar vidare andra godtyckliga "
"nyckelordsargument (för att undvika att bryta bakåtkompatibiliteten med "
"3.13.3)."

msgid ""
"All *kwargs* are now passed on. The *eager_start* parameter works with eager "
"task factories."
msgstr ""
"Alla *kwargs* skickas nu vidare. Parametern *eager_start* fungerar med "
"\"eager task factories\"."

msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr "Ange en uppgiftsfabrik som ska användas av :meth:`loop.create_task`."

msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro, "
"**kwargs)``, where *loop* is a reference to the active event loop, and "
"*coro* is a coroutine object.  The callable must pass on all *kwargs*, and "
"return a :class:`asyncio.Task`-compatible object."
msgstr ""
"Om *factory* är ``None`` kommer standarduppgiftsfabriken att ställas in. "
"Annars måste *factory* vara en *callable* med en signatur som matchar "
"``(loop, coro, **kwargs)``, där *loop* är en referens till den aktiva "
"händelseslingan och *coro* är ett coroutine-objekt.  Callable måste skicka "
"vidare alla *kwargs* och returnera ett :class:`asyncio.Task`-kompatibelt "
"objekt."

msgid "Required that all *kwargs* are passed on to :class:`asyncio.Task`."
msgstr "Kräver att alla *kwargs* skickas vidare till :class:`asyncio.Task`."

msgid ""
"*name* is no longer passed to task factories. *context* is no longer passed "
"to task factories if it is ``None``."
msgstr ""
"*name* skickas inte längre till uppgiftsfabriker. *context* skickas inte "
"längre till uppgiftsfabriker om det är ``None``."

msgid ""
"*name* and *context* are now unconditionally passed on to task factories "
"again."
msgstr ""
"*name* och *context* skickas nu ovillkorligen vidare till uppgiftsfabrikerna "
"igen."

msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"Returnerar en uppgiftsfabrik eller ``None`` om standardfabriken används."

msgid "Opening network connections"
msgstr "Öppna nätverksanslutningar"

msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"Öppna en anslutning för strömmande transport till en given adress som "
"specificeras av *host* och *port*."

msgid ""
"The socket family can be either :py:const:`~socket.AF_INET` or :py:const:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"Socketfamiljen kan vara antingen :py:const:`~socket.AF_INET` eller :py:const:"
"`~socket.AF_INET6` beroende på *host* (eller argumentet *family*, om det "
"anges)."

msgid "The socket type will be :py:const:`~socket.SOCK_STREAM`."
msgstr "Socket-typen kommer att vara :py:const:`~socket.SOCK_STREAM`."

msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* måste vara en anropsbar som returnerar en :ref:`asyncio "
"protocol <asyncio-protocol>`-implementering."

msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Denna metod försöker upprätta anslutningen i bakgrunden. Om det lyckas "
"returnerar den ett par ``(transport, protokoll)``."

msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr ""
"Den kronologiska sammanfattningen av den underliggande transaktionen är "
"följande:"

msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"Anslutningen upprättas och en :ref:`transport <asyncio-transport>` skapas "
"för den."

msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* anropas utan argument och förväntas returnera en :ref:"
"`protocol <asyncio-protocol>`-instans."

msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"Protokollinstansen kopplas till transporten genom att anropa dess metod :"
"meth:`~BaseProtocol.connection_made`."

msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "En ``(transport, protokoll)``-tupel returneras vid framgång."

msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"Den skapade transporten är en implementationsberoende dubbelriktad ström."

msgid "Other arguments:"
msgstr "Övriga argument:"

msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*: om den anges och inte är false, skapas en SSL/TLS-transport (som "
"standard skapas en vanlig TCP-transport).  Om *ssl* är ett :class:`ssl."
"SSLContext`-objekt används detta sammanhang för att skapa transporten; om "
"*ssl* är :const:`True` används ett standardkontext som returneras från :func:"
"`ssl.create_default_context`."

msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS säkerhetsaspekter <ssl-security>`"

msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* anger eller åsidosätter det värdnamn som målserverns "
"certifikat ska matchas mot.  Ska endast skickas om *ssl* inte är ``None``.  "
"Som standard används värdet för *host*-argumentet.  Om *host* är tomt finns "
"det inget standardvärde och du måste ange ett värde för *server_hostname*.  "
"Om *server_hostname* är en tom sträng inaktiveras matchning av värdnamn "
"(vilket är en allvarlig säkerhetsrisk eftersom det möjliggör potentiella man-"
"in-the-middle-attacker)."

msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* är den valfria adressfamiljen, protokollet och "
"flaggorna som ska skickas vidare till getaddrinfo() för upplösning av "
"*host*. Om de anges bör de alla vara heltal från motsvarande :mod:`socket`-"
"modulkonstanter."

msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, om det anges, aktiverar Happy Eyeballs för den här "
"anslutningen. Det bör vara ett flyttal som representerar den tid i sekunder "
"som ska vänta på att ett anslutningsförsök ska slutföras innan nästa försök "
"påbörjas parallellt. Detta är \"Connection Attempt Delay\" enligt "
"definitionen i :rfc:`8305`. Ett förnuftigt standardvärde som rekommenderas "
"av RFC är ``0,25`` (250 millisekunder)."

msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* styr omordning av adresser när ett värdnamn kopplas till flera "
"IP-adresser. Om ``0`` eller ospecificerat görs ingen omordning och "
"adresserna prövas i den ordning som returneras av :meth:`getaddrinfo`. Om "
"ett positivt heltal anges, sammanflätas adresserna efter adressfamilj och "
"det angivna heltalet tolkas som \"First Address Family Count\" enligt "
"definitionen i :rfc:`8305`. Standardvärdet är ``0`` om "
"*happy_eyeballs_delay* inte har angetts och ``1`` om så är fallet."

msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, om det anges, ska vara ett befintligt, redan anslutet :class:`socket."
"socket'-objekt som ska användas av transporten. Om *sock* anges ska inget av "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* eller *local_addr* specificeras."

msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's :meth:`~asyncio."
"BaseTransport.close` method."
msgstr ""
"Argumentet *sock* överför ägandet av sockeln till den transport som skapats. "
"För att stänga sockeln anropar du transportens :meth:`~asyncio.BaseTransport."
"close`-metod."

msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, om det anges, är en ``(local_host, local_port)``-tupel som "
"används för att binda uttaget lokalt.  *local_host* och *local_port* söks "
"upp med hjälp av ``getaddrinfo()``, på samma sätt som *host* och *port*."

msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* är (för en TLS-anslutning) den tid i sekunder som "
"ska vänta på att TLS-handskakningen ska slutföras innan anslutningen "
"avbryts. ``60,0`` sekunder om ``None`` (standard)."

msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_shutdown_timeout* är den tid i sekunder som ska vänta på att SSL-"
"avstängningen ska slutföras innan anslutningen avbryts. ``30.0`` sekunder om "
"``None`` (standard)."

msgid ""
"*all_errors* determines what exceptions are raised when a connection cannot "
"be created. By default, only a single ``Exception`` is raised: the first "
"exception if there is only one or all errors have same message, or a single "
"``OSError`` with the error messages combined. When ``all_errors`` is "
"``True``, an ``ExceptionGroup`` will be raised containing all exceptions "
"(even if there is only one)."
msgstr ""
"*all_errors* avgör vilka undantag som tas upp när en anslutning inte kan "
"skapas. Som standard genereras endast ett enda ``Exception``: det första "
"undantaget om det bara finns ett eller om alla fel har samma meddelande, "
"eller ett enda ``OSError`` med felmeddelandena kombinerade. När "
"``all_errors`` är ``True`` kommer en ``ExceptionGroup`` att skapas som "
"innehåller alla undantag (även om det bara finns ett)."

msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Lagt till stöd för SSL/TLS i :class:`ProactorEventLoop`."

msgid ""
"The socket option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set "
"by default for all TCP connections."
msgstr ""
"Socket-alternativet :ref:`socket.TCP_NODELAY <socket-unix-constants>` är "
"inställt som standard för alla TCP-anslutningar."

msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Parametern *ssl_handshake_timeout* har lagts till."

msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Lagt till parametrarna *happy_eyeballs_delay* och *interleave*."

msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual-stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Algoritm för glada ögonbollar: Framgång med Dual-Stack-värdar. När en "
"servers IPv4-sökväg och -protokoll fungerar, men serverns IPv6-sökväg och -"
"protokoll inte fungerar, upplever en dual-stack-klientapplikation en "
"betydande anslutningsfördröjning jämfört med en klient med enbart IPv4.  "
"Detta är inte önskvärt eftersom det leder till att dual-stack-klienten får "
"en sämre användarupplevelse.  Detta dokument specificerar krav för "
"algoritmer som minskar denna för användaren synliga fördröjning och "
"tillhandahåller en algoritm."

msgid "For more information: https://datatracker.ietf.org/doc/html/rfc6555"
msgstr "För mer information: https://datatracker.ietf.org/doc/html/rfc6555"

msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "Parametern *ssl_shutdown_timeout* har lagts till."

msgid "*all_errors* was added."
msgstr "*all_errors* har lagts till."

msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
"Funktionen :func:`open_connection` är ett alternativt API på hög nivå.  Den "
"returnerar ett par (:class:`StreamReader`, :class:`StreamWriter`) som kan "
"användas direkt i async/await-kod."

msgid "Create a datagram connection."
msgstr "Skapa en datagramanslutning."

msgid ""
"The socket family can be either :py:const:`~socket.AF_INET`, :py:const:"
"`~socket.AF_INET6`, or :py:const:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"Socketfamiljen kan vara antingen :py:const:`~socket.AF_INET`, :py:const:"
"`~socket.AF_INET6` eller :py:const:`~socket.AF_UNIX`, beroende på *host* "
"(eller argumentet *family*, om det anges)."

msgid "The socket type will be :py:const:`~socket.SOCK_DGRAM`."
msgstr "Socket-typen är :py:const:`~socket.SOCK_DGRAM`."

msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* måste vara en callable som returnerar en :ref:`protocol "
"<asyncio-protocol>` implementation."

msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "En tupel av ``(transport, protokoll)`` returneras vid framgång."

msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr*, om den anges, är en ``(local_host, local_port)``-tupel som "
"används för att binda socket lokalt.  *local_host* och *local_port* söks upp "
"med hjälp av :meth:`getaddrinfo`."

msgid ""
"On Windows, when using the proactor event loop with ``local_addr=None``, an :"
"exc:`OSError` with :attr:`!errno.WSAEINVAL` will be raised when running it."
msgstr ""
"I Windows, när du använder proactor-händelseslingan med ``local_addr=None``, "
"kommer ett :exc:`OSError` med :attr:`!errno.WSAEINVAL` att uppstå när du kör "
"det."

msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, om den anges, är en ``(remote_host, remote_port)``-tupel som "
"används för att ansluta sockeln till en fjärradress.  *remote_host* och "
"*remote_port* söks upp med hjälp av :meth:`getaddrinfo`."

msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* är den valfria adressfamiljen, protokollet och "
"flaggorna som ska skickas vidare till :meth:`getaddrinfo` för *host*-"
"upplösning. Om de anges bör de alla vara heltal från motsvarande :mod:"
"`socket`-modulkonstanter."

msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :ref:`socket.SO_REUSEPORT <socket-unix-constants>` constant "
"is not defined then this capability is unsupported."
msgstr ""
"*reuse_port* talar om för kärnan att den här ändpunkten får vara bunden till "
"samma port som andra befintliga ändpunkter är bundna till, så länge de alla "
"sätter denna flagga när de skapas. Detta alternativ stöds inte av Windows "
"och vissa Unix. Om konstanten :ref:`socket.SO_REUSEPORT <socket-unix-"
"constants>` inte är definierad stöds inte denna funktion."

msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* talar om för kärnan att den här slutpunkten får skicka "
"meddelanden till broadcast-adressen."

msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"*sock* kan eventuellt anges för att använda ett befintligt, redan anslutet, :"
"class:`socket.socket`-objekt som ska användas av transporten. Om detta anges "
"ska *local_addr* och *remote_addr* utelämnas (måste vara :const:`None`)."

msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Se :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` och :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` exempel."

msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"Parametrarna *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast* och *sock* har lagts till."

msgid "Added support for Windows."
msgstr "Stöd för Windows har lagts till."

msgid ""
"The *reuse_address* parameter is no longer supported, as using :ref:`socket."
"SO_REUSEADDR <socket-unix-constants>` poses a significant security concern "
"for UDP. Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
"Parametern *reuse_address* stöds inte längre, eftersom användning av :ref:"
"`socket.SO_REUSEADDR <socket-unix-constants>` utgör ett betydande "
"säkerhetsproblem för UDP. Om du uttryckligen skickar ``reuse_address=True`` "
"kommer ett undantag att uppstå."

msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"När flera processer med olika UID:er tilldelar uttag till en identisk UDP-"
"socketadress med ``SO_REUSEADDR`` kan inkommande paket fördelas slumpmässigt "
"mellan uttagen."

msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :ref:`socket.SO_REUSEPORT <socket-"
"unix-constants>` is used instead, which specifically prevents processes with "
"differing UIDs from assigning sockets to the same socket address."
msgstr ""
"För plattformar som stöds kan *reuse_port* användas som ersättning för "
"liknande funktionalitet. Med *reuse_port* används istället :ref:`socket."
"SO_REUSEPORT <socket-unix-constants>`, vilket specifikt förhindrar att "
"processer med olika UID:n tilldelar uttag till samma uttagsadress."

msgid ""
"The *reuse_address* parameter, disabled since Python 3.8.1, 3.7.6 and "
"3.6.10, has been entirely removed."
msgstr ""
"Parametern *reuse_address*, som varit inaktiverad sedan Python 3.8.1, 3.7.6 "
"och 3.6.10, har tagits bort helt."

msgid "Create a Unix connection."
msgstr "Skapa en Unix-anslutning."

msgid ""
"The socket family will be :py:const:`~socket.AF_UNIX`; socket type will be :"
"py:const:`~socket.SOCK_STREAM`."
msgstr ""
"Socket-familjen är :py:const:`~socket.AF_UNIX`; socket-typen är :py:const:"
"`~socket.SOCK_STREAM`."

msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* är namnet på ett Unix-domänuttag och är obligatoriskt om inte "
"parametern *sock* har angetts.  Abstrakta Unix-sockets, :class:`str`, :class:"
"`bytes` och :class:`~pathlib.Path`-sökvägar stöds."

msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Se dokumentationen för metoden :meth:`loop.create_connection` för "
"information om argument till denna metod."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`."
msgstr ""
"Parametern *ssl_handshake_timeout* har lagts till. Parametern *path* kan nu "
"vara en :term:`path-liknande objekt`."

msgid "Creating network servers"
msgstr "Skapa nätverksservrar"

msgid ""
"Create a TCP server (socket type :const:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Skapa en TCP-server (socket-typ :const:`~socket.SOCK_STREAM`) som lyssnar på "
"*port* på *host*-adressen."

msgid "Returns a :class:`Server` object."
msgstr "Returnerar ett :class:`Server`-objekt."

msgid "Arguments:"
msgstr "Argument:"

msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"Parametern *host* kan ställas in på flera olika typer som avgör var servern "
"ska lyssna:"

msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"Om *host* är en sträng är TCP-servern bunden till ett enda "
"nätverksgränssnitt som anges av *host*."

msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Om *host* är en sekvens av strängar, är TCP-servern bunden till alla "
"nätverksgränssnitt som anges av sekvensen."

msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Om *host* är en tom sträng eller ``None`` antas alla gränssnitt och en lista "
"med flera socklar returneras (troligen en för IPv4 och en annan för IPv6)."

msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"Parametern *port* kan användas för att ange vilken port som servern ska "
"lyssna på. Om ``0`` eller ``None`` (standard) väljs en slumpmässig oanvänd "
"port (observera att om *host* är kopplad till flera nätverksgränssnitt väljs "
"en slumpmässig port för varje gränssnitt)."

msgid ""
"*family* can be set to either :const:`socket.AF_INET` or :const:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :const:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* kan sättas till antingen :const:`socket.AF_INET` eller :const:"
"`~socket.AF_INET6` för att tvinga uttaget att använda IPv4 eller IPv6. Om "
"den inte anges kommer *familjen* att bestämmas utifrån värdnamnet (standard "
"är :const:`~socket.AF_UNSPEC`)."

msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* är en bitmask för :meth:`getaddrinfo`."

msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* kan eventuellt anges för att använda ett redan befintligt socket-"
"objekt. Om *host* och *port* anges får de inte specificeras."

msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"Argumentet *sock* överför äganderätten till sockeln till den server som "
"skapats. För att stänga sockeln anropar du serverns :meth:`~asyncio.Server."
"close`-metod."

msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* är det maximala antalet anslutningar i kö som skickas till :meth:"
"`~socket.socket.listen` (standardvärde 100)."

msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* kan sättas till en :class:`~ssl.SSLContext`-instans för att aktivera "
"TLS över de accepterade anslutningarna."

msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* säger till kärnan att återanvända en lokal socket i "
"``TIME_WAIT``-tillstånd, utan att vänta på att dess naturliga timeout ska "
"löpa ut. Om inte specificerat kommer det automatiskt att sättas till "
"``True`` på Unix."

msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* talar om för kärnan att den här ändpunkten får vara bunden till "
"samma port som andra befintliga ändpunkter är bundna till, så länge de alla "
"sätter denna flagga när de skapas. Detta alternativ stöds inte i Windows."

msgid ""
"*keep_alive* set to ``True`` keeps connections active by enabling the "
"periodic transmission of messages."
msgstr ""
"*keep_alive* satt till ``True`` håller anslutningar aktiva genom att "
"möjliggöra periodisk överföring av meddelanden."

msgid "Added the *keep_alive* parameter."
msgstr "Parametern *keep_alive* har lagts till."

msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* är (för en TLS-server) den tid i sekunder som ska "
"vänta på att TLS-handskakningen ska slutföras innan anslutningen avbryts. "
"``60,0`` sekunder om ``None`` (standard)."

msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"*start_serving* satt till ``True`` (standard) gör att den skapade servern "
"börjar ta emot anslutningar omedelbart.  När den är inställd på ``False`` "
"bör användaren vänta på :meth:`Server.start_serving` eller :meth:`Server."
"serve_forever` för att få servern att börja acceptera anslutningar."

msgid "The *host* parameter can be a sequence of strings."
msgstr "Parametern *host* kan vara en sekvens av strängar."

msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set by default "
"for all TCP connections."
msgstr ""
"Parametrarna *ssl_handshake_timeout* och *start_serving* har lagts till. "
"Socket-alternativet :ref:`socket.TCP_NODELAY <socket-unix-constants>` är "
"inställt som standard för alla TCP-anslutningar."

msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"Funktionen :func:`start_server` är ett alternativt API på högre nivå som "
"returnerar ett par av :class:`StreamReader` och :class:`StreamWriter` som "
"kan användas i en async/await-kod."

msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:const:`~socket."
"AF_UNIX` socket family."
msgstr ""
"Liknar :meth:`loop.create_server` men fungerar med socketfamiljen :py:const:"
"`~socket.AF_UNIX`."

msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* är namnet på ett Unix-domänuttag och är obligatoriskt om inte ett "
"*sock*-argument anges.  Abstrakta Unix-sockets, :class:`str`, :class:`bytes` "
"och :class:`~pathlib.Path`-sökvägar stöds."

msgid ""
"If *cleanup_socket* is true then the Unix socket will automatically be "
"removed from the filesystem when the server is closed, unless the socket has "
"been replaced after the server has been created."
msgstr ""
"Om *cleanup_socket* är true kommer Unix-sockeln automatiskt att tas bort "
"från filsystemet när servern stängs, såvida inte sockeln har bytts ut efter "
"att servern skapades."

msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Se dokumentationen för metoden :meth:`loop.create_server` för information om "
"argument till den här metoden."

msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"Parametrarna *ssl_handshake_timeout* och *start_serving* har lagts till. "
"Parametern *path* kan nu vara ett :class:`~pathlib.Path`-objekt."

msgid "Added the *cleanup_socket* parameter."
msgstr "Parametern *cleanup_socket* har lagts till."

msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr ""
"Omhänderta en redan accepterad anslutning till ett transport/protokoll-par."

msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Den här metoden kan användas av servrar som accepterar anslutningar utanför "
"asyncio men som använder asyncio för att hantera dem."

msgid "Parameters:"
msgstr "Parametrar:"

msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* är ett redan existerande socket-objekt som returneras från :meth:"
"`socket.accept <socket.socket.accept>`."

msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* kan sättas till en :class:`~ssl.SSLContext` för att aktivera SSL över "
"de accepterade anslutningarna."

msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* är (för en SSL-anslutning) den tid i sekunder som "
"ska vänta på att SSL-handskakningen ska slutföras innan anslutningen "
"avbryts. ``60,0`` sekunder om ``None`` (standard)."

msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Returnerar ett par ``(transport, protokoll)``."

msgid "Transferring files"
msgstr "Överföring av filer"

msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Skicka en *fil* över en *transport*.  Returnera det totala antalet bytes som "
"skickats."

msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"Metoden använder högpresterande :meth:`os.sendfile` om sådan finns "
"tillgänglig."

msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* måste vara ett vanligt filobjekt som öppnas i binärt läge."

msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* anger varifrån filen ska börja läsas. Om det anges är *count* det "
"totala antalet byte som ska överföras i motsats till att skicka filen tills "
"EOF nås. Filens position uppdateras alltid, även om metoden ger upphov till "
"ett fel, och :meth:`file.tell() <io.IOBase.tell>` kan användas för att få "
"fram det faktiska antalet byte som skickats."

msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback* satt till ``True`` gör att asyncio manuellt läser och skickar "
"filen när plattformen inte stöder systemanropet sendfile (t.ex. Windows "
"eller SSL-socket på Unix)."

msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Utlöser :exc:`SendfileNotAvailableError` om systemet inte stöder syscallen "
"*sendfile* och *fallback* är ``False``."

msgid "TLS Upgrade"
msgstr "TLS-uppgradering"

msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Uppgradera en befintlig transportbaserad anslutning till TLS."

msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""
"Skapa en TLS-kodare/avkodare-instans och infoga den mellan *transport* och "
"*protokoll*. Kodaren/avkodaren implementerar både protokoll som vetter mot "
"*transport* och transport som vetter mot *protokoll*."

msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""
"Returnerar den skapade instansen med två gränssnitt. Efter *await* måste "
"*protokollet* sluta använda den ursprungliga *transporten* och kommunicera "
"med det returnerade objektet endast eftersom kodaren cachar data på "
"*protokollsidan* och sporadiskt utbyter extra TLS-sessionspaket med "
"*transport*."

msgid ""
"In some situations (e.g. when the passed transport is already closing) this "
"may return ``None``."
msgstr ""
"I vissa situationer (t.ex. när den passerade transporten redan är stängd) "
"kan detta returnera ``None``."

msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"*transport* och *protocol* instanser som metoder som :meth:`~loop."
"create_server` och :meth:`~loop.create_connection` returnerar."

msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: en konfigurerad instans av :class:`~ssl.SSLContext`."

msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* passerar ``True`` när en anslutning på serversidan uppgraderas "
"(som den som skapades av :meth:`~loop.create_server`)."

msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: anger eller åsidosätter det värdnamn som målserverns "
"certifikat ska matchas mot."

msgid "Watching file descriptors"
msgstr "Titta på filbeskrivningar"

msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Börja övervaka filbeskrivaren *fd* för lästillgänglighet och anropa "
"*callback* med de angivna argumenten när *fd* är tillgänglig för läsning."

msgid ""
"Any preexisting callback registered for *fd* is cancelled and replaced by "
"*callback*."
msgstr ""
"Eventuella tidigare registrerade callbacks för *fd* avbryts och ersätts av "
"*callback*."

msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr ""
"Slutar övervaka filbeskrivaren *fd* för lästillgänglighet. Returnerar "
"``True`` om *fd* tidigare övervakades för läsningar."

msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Börja övervaka filbeskrivaren *fd* för skrivtillgänglighet och anropa "
"*callback* med de angivna argumenten när *fd* är tillgänglig för skrivning."

msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Använd :func:`functools.partial` :ref:`för att skicka nyckelordsargument "
"<asyncio-pass-keywords>` till *callback*."

msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr ""
"Slutar övervaka filbeskrivaren *fd* för skrivtillgänglighet. Returnerar "
"``True`` om *fd* tidigare övervakades för skrivningar."

msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""
"Se även :ref:``Platformstöd <asyncio-platform-support>` för vissa "
"begränsningar av dessa metoder."

msgid "Working with socket objects directly"
msgstr "Arbeta direkt med socket-objekt"

msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"I allmänhet är protokollimplementeringar som använder transportbaserade API:"
"er som :meth:`loop.create_connection` och :meth:`loop.create_server` "
"snabbare än implementeringar som arbetar direkt med sockets. Det finns dock "
"vissa användningsfall när prestanda inte är avgörande och det är bekvämare "
"att arbeta med :class:`~socket.socket`-objekt direkt."

msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"Ta emot upp till *nbytes* från *sock*.  Asynkron version av :meth:`socket."
"recv() <socket.socket.recv>`."

msgid "Return the received data as a bytes object."
msgstr "Returnerar den mottagna datan som ett bytesobjekt."

msgid "*sock* must be a non-blocking socket."
msgstr "*sock* måste vara ett icke-blockerande uttag."

msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"Även om den här metoden alltid har dokumenterats som en coroutine-metod, "
"returnerade utgåvor före Python 3.7 en :class:`Future`. Sedan Python 3.7 är "
"detta en ``async def``-metod."

msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Tar emot data från *sock* till bufferten *buf*.  Modellerad efter den "
"blockerande :meth:`socket.recv_into() <socket.socket.recv_into>`-metoden."

msgid "Return the number of bytes written to the buffer."
msgstr "Returnerar antalet bytes som skrivits till bufferten."

msgid ""
"Receive a datagram of up to *bufsize* from *sock*.  Asynchronous version of :"
"meth:`socket.recvfrom() <socket.socket.recvfrom>`."
msgstr ""
"Ta emot ett datagram på upp till *bufsize* från *sock*.  Asynkron version "
"av :meth:`socket.recvfrom() <socket.socket.recvfrom>`."

msgid "Return a tuple of (received data, remote address)."
msgstr "Returnera en tupel av (mottagna data, fjärradress)."

msgid ""
"Receive a datagram of up to *nbytes* from *sock* into *buf*. Asynchronous "
"version of :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."
msgstr ""
"Ta emot ett datagram på upp till *nbytes* från *sock* till *buf*. Asynkron "
"version av :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."

msgid "Return a tuple of (number of bytes received, remote address)."
msgstr "Returnera en tupel av (antal mottagna byte, fjärradress)."

msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"Skicka *data* till *sock* socket. Asynkron version av :meth:`socket."
"sendall() <socket.socket.sendall>`."

msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Denna metod fortsätter att skicka till uttaget tills antingen all data i "
"*data* har skickats eller ett fel inträffar.  ``None`` returneras vid "
"framgång.  Vid fel uppstår ett undantag. Dessutom finns det inget sätt att "
"avgöra hur mycket data, om någon, som framgångsrikt behandlades av den "
"mottagande änden av anslutningen."

msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"Även om metoden alltid dokumenterats som en coroutine-metod, returnerade den "
"före Python 3.7 en :class:`Future`. Sedan Python 3.7 är detta en ``async "
"def``-metod."

msgid ""
"Send a datagram from *sock* to *address*. Asynchronous version of :meth:"
"`socket.sendto() <socket.socket.sendto>`."
msgstr ""
"Skicka ett datagram från *sock* till *address*. Asynkron version av :meth:"
"`socket.sendto() <socket.socket.sendto>`."

msgid "Return the number of bytes sent."
msgstr "Returnera antalet bytes som skickats."

msgid "Connect *sock* to a remote socket at *address*."
msgstr "Anslut *sock* till en fjärrsockel på *address*."

msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr "Asynkron version av :meth:`socket.connect() <socket.socket.connect>`."

msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``address`` behöver inte längre lösas.  ``sock_connect`` kommer att försöka "
"kontrollera om *adressen* redan är löst genom att anropa :func:`socket."
"inet_pton`.  Om inte, kommer :meth:`loop.getaddrinfo` att användas för att "
"lösa upp *adressen*."

msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` och :func:`asyncio.open_connection() "
"<open_connection>`."

msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Acceptera en anslutning.  Modellerad efter den blockerande :meth:`socket."
"accept() <socket.socket.accept>`-metoden."

msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"Uttaget måste vara bundet till en adress och lyssna efter anslutningar. "
"Returvärdet är ett par ``(conn, address)`` där *conn* är ett *nytt* "
"socketobjekt som kan användas för att skicka och ta emot data på "
"anslutningen och *address* är den adress som är bunden till sockeln i andra "
"änden av anslutningen."

msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` och :func:`start_server`."

msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Skicka en fil med hjälp av högpresterande :mod:`os.sendfile` om möjligt. "
"Returnerar det totala antalet bytes som skickats."

msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ""
"Asynkron version av :meth:`socket.sendfile() <socket.socket.sendfile>`."

msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""
"*sock* måste vara en icke-blockerande :const:`socket.SOCK_STREAM` :class:"
"`~socket.socket`."

msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* måste vara ett vanligt filobjekt som öppnas i binärt läge."

msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, när den är inställd på ``True``, gör att asyncio manuellt läser "
"och skickar filen när plattformen inte stöder sendfile syscall (t.ex. "
"Windows eller SSL-socket på Unix)."

msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Utlöser :exc:`SendfileNotAvailableError` om systemet inte stöder syscall "
"*sendfile* och *fallback* är ``False``."

msgid "DNS"
msgstr "DNS"

msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Asynkron version av :meth:`socket.getaddrinfo`."

msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Asynkron version av :meth:`socket.getnameinfo`."

msgid ""
"Both *getaddrinfo* and *getnameinfo* internally utilize their synchronous "
"versions through the loop's default thread pool executor. When this executor "
"is saturated, these methods may experience delays, which higher-level "
"networking libraries may report as increased timeouts. To mitigate this, "
"consider using a custom executor for other user tasks, or setting a default "
"executor with a larger number of workers."
msgstr ""
"Både *getaddrinfo* och *getnameinfo* använder internt sina synkrona "
"versioner via loopens standardtrådpoolsexekverare. När denna exekverare är "
"mättad kan dessa metoder uppleva fördröjningar, vilket nätverksbibliotek på "
"högre nivå kan rapportera som ökade tidsavbrott. För att mildra detta bör du "
"överväga att använda en anpassad exekverare för andra användaruppgifter "
"eller ställa in en standardexekverare med ett större antal arbetare."

msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"Både metoderna *getaddrinfo* och *getnameinfo* har alltid dokumenterats att "
"returnera en coroutine, men före Python 3.7 returnerade de i själva verket :"
"class:`asyncio.Future`-objekt.  Från och med Python 3.7 är båda metoderna "
"coroutines."

msgid "Working with pipes"
msgstr "Arbeta med rör"

msgid "Register the read end of *pipe* in the event loop."
msgstr "Registrera lässlutet av *pipe* i händelseslingan."

msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* är en :term:`filliknande objekt <file object>`."

msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Returnerar paret ``(transport, protocol)``, där *transport* stöder "
"gränssnittet :class:`ReadTransport` och *protocol* är ett objekt som "
"instantierats av *protocol_factory*."

msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"Med :class:`SelectorEventLoop` händelseslinga är *pipe* inställd på icke-"
"blockerande läge."

msgid "Register the write end of *pipe* in the event loop."
msgstr "Registrera den skrivande änden av *pipe* i händelseslingan."

msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* är :term:`filliknande objekt <file object>`."

msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Returnerar paret ``(transport, protocol)``, där *transport* stöder :class:"
"`WriteTransport`-gränssnittet och *protocol* är ett objekt som instantierats "
"av *protocol_factory*."

msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` har inte stöd för ovanstående metoder i Windows.  "
"Använd :class:`ProactorEventLoop` istället för Windows."

msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ""
"Metoderna :meth:`loop.subprocess_exec` och :meth:`loop.subprocess_shell`."

msgid "Unix signals"
msgstr "Unix-signaler"

msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Ställ in *callback* som hanterare av signalen *signum*."

msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"Återanropet kommer att anropas av *loop*, tillsammans med andra köade "
"återanrop och körbara coroutines i den händelseslingan. Till skillnad från "
"signalhanterare som registreras med :func:`signal.signal`, får en "
"återuppringning som registreras med den här funktionen interagera med "
"händelseslingan."

msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Ge upphov till :exc:`ValueError` om signalnumret är ogiltigt eller inte kan "
"fångas upp. Raise :exc:`RuntimeError` om det finns ett problem med att "
"konfigurera hanteraren."

msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""
"Precis som :func:`signal.signal` måste den här funktionen anropas i "
"huvudtråden."

msgid "Remove the handler for the *sig* signal."
msgstr "Ta bort hanteraren för signalen *sig*."

msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Returnerar ``True`` om signalhanteraren togs bort, eller ``False`` om ingen "
"hanterare ställdes in för den givna signalen."

msgid "The :mod:`signal` module."
msgstr "Modulen :mod:`signal`."

msgid "Executing code in thread or process pools"
msgstr "Exekvering av kod i tråd- eller processpooler"

msgid "Arrange for *func* to be called in the specified executor."
msgstr "Ordna så att *func* anropas i den angivna exekveraren."

msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``. The "
"default executor can be set by :meth:`loop.set_default_executor`, otherwise, "
"a :class:`concurrent.futures.ThreadPoolExecutor` will be lazy-initialized "
"and used by :func:`run_in_executor` if needed."
msgstr ""
"Argumentet *executor* bör vara en instans av :class:`concurrent.futures."
"Executor`. Standardutföraren används om *executor* är ``None``. "
"Standardutföraren kan ställas in med :meth:`loop.set_default_executor`, "
"annars kommer en :class:`concurrent.futures.ThreadPoolExecutor` att "
"initieras latent och användas av :func:`run_in_executor` vid behov."

msgid ""
"import asyncio\n"
"import concurrent.futures\n"
"\n"
"def blocking_io():\n"
"    # File operations (such as logging) can block the\n"
"    # event loop: run them in a thread pool.\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"def cpu_bound():\n"
"    # CPU-bound operations will block the event loop:\n"
"    # in general it is preferable to run them in a\n"
"    # process pool.\n"
"    return sum(i * i for i in range(10 ** 7))\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    ## Options:\n"
"\n"
"    # 1. Run in the default loop's executor:\n"
"    result = await loop.run_in_executor(\n"
"        None, blocking_io)\n"
"    print('default thread pool', result)\n"
"\n"
"    # 2. Run in a custom thread pool:\n"
"    with concurrent.futures.ThreadPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, blocking_io)\n"
"        print('custom thread pool', result)\n"
"\n"
"    # 3. Run in a custom process pool:\n"
"    with concurrent.futures.ProcessPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('custom process pool', result)\n"
"\n"
"    # 4. Run in a custom interpreter pool:\n"
"    with concurrent.futures.InterpreterPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('custom interpreter pool', result)\n"
"\n"
"if __name__ == '__main__':\n"
"    asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import concurrent.futures\n"
"\n"
"def blocking_io():\n"
"    # Filoperationer (t.ex. loggning) kan blockera\n"
"    # händelseslingan: kör dem i en trådpool.\n"
"    med open('/dev/urandom', 'rb') som f:\n"
"        return f.read(100)\n"
"\n"
"def cpu_bound():\n"
"    # CPU-bundna operationer kommer att blockera händelseslingan:\n"
"    # i allmänhet är det att föredra att köra dem i en\n"
"    # processpool.\n"
"    return sum(i * i för i i intervallet(10 ** 7))\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    ## Alternativ:\n"
"\n"
"    # 1. Kör i standardslingans exekverare:\n"
"    result = await loop.run_in_executor(\n"
"        Ingen, blockering_io)\n"
"    print('standard trådpool', resultat)\n"
"\n"
"    # 2. Kör i en anpassad trådpool:\n"
"    med concurrent.futures.ThreadPoolExecutor() som pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, blockering_io)\n"
"        print('anpassad trådpool', resultat)\n"
"\n"
"    # 3. Kör i en anpassad processpool:\n"
"    med concurrent.futures.ProcessPoolExecutor() som pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('anpassad processpool', resultat)\n"
"\n"
"    # 4. Kör i en anpassad tolkpool:\n"
"    med concurrent.futures.InterpreterPoolExecutor() som pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('anpassad tolkpool', resultat)\n"
"\n"
"if __name__ == '__main__':\n"
"    asyncio.run(main())"

msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""
"Observera att startpunktsskyddet (``if __name__ == '__main__'``) krävs för "
"alternativ 3 på grund av de speciella egenskaperna hos :mod:"
"`multiprocessing`, som används av :class:`~concurrent.futures."
"ProcessPoolExecutor`. Se :ref:``Säker import av huvudmodulen "
"<multiprocessing-safe-main-import>`."

msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Denna metod returnerar ett :class:`asyncio.Future`-objekt."

msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Använd :func:`functools.partial` :ref:`för att skicka nyckelordsargument "
"<asyncio-pass-keywords>` till *func*."

msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` konfigurerar inte längre ``max_workers`` för "
"den trådpoolsexekutor som den skapar, utan överlåter det till "
"trådpoolsexekutorn (:class:`~concurrent.futures.ThreadPoolExecutor`) att "
"ange standardvärdet."

msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`, which includes :class:`~concurrent.futures."
"InterpreterPoolExecutor`."
msgstr ""
"Ställ in *executor* som den standardexecutor som används av :meth:"
"`run_in_executor`. *executor* måste vara en instans av :class:`~concurrent."
"futures.ThreadPoolExecutor`, vilket inkluderar :class:`~concurrent.futures."
"InterpreterPoolExecutor`."

msgid ""
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"*executor* måste vara en instans av :class:`~concurrent.futures."
"ThreadPoolExecutor`."

msgid "Error Handling API"
msgstr "API för felhantering"

msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "Gör det möjligt att anpassa hur undantag hanteras i händelseslingan."

msgid "Set *handler* as the new event loop exception handler."
msgstr "Ange *handler* som den nya undantagshanteraren för händelseslingan."

msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"Om *handler* är ``None`` kommer standardhanteraren för undantag att "
"användas.  Annars måste *handler* vara en callable med en signatur som "
"matchar ``(loop, context)``, där ``loop`` är en referens till den aktiva "
"händelseslingan och ``context`` är ett ``dict``-objekt som innehåller "
"detaljer om undantaget (se :meth:`call_exception_handler`-dokumentationen "
"för detaljer om context)."

msgid ""
"If the handler is called on behalf of a :class:`~asyncio.Task` or :class:"
"`~asyncio.Handle`, it is run in the :class:`contextvars.Context` of that "
"task or callback handle."
msgstr ""
"Om hanteraren anropas på uppdrag av en :class:`~asyncio.Task` eller :class:"
"`~asyncio.Handle`, körs den i :class:`contextvars.Context` för den uppgiften "
"eller callback-handtaget."

msgid ""
"The handler may be called in the :class:`~contextvars.Context` of the task "
"or handle where the exception originated."
msgstr ""
"Hanteraren kan anropas i :class:`~contextvars.Context` för den uppgift eller "
"det handtag där undantaget uppstod."

msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Returnerar den aktuella undantagshanteraren, eller ``None`` om ingen egen "
"undantagshanterare har angetts."

msgid "Default exception handler."
msgstr "Standardhantering av undantag."

msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Detta anropas när ett undantag inträffar och ingen undantagshanterare är "
"inställd. Detta kan anropas av en anpassad undantagshanterare som vill "
"använda standardhanterarens beteende."

msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr ""
"*context*-parametern har samma betydelse som i :meth:"
"`call_exception_handler`."

msgid "Call the current event loop exception handler."
msgstr "Anropa den aktuella undantagshanteraren för händelseslingan."

msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* är ett ``dict``-objekt som innehåller följande nycklar (nya "
"nycklar kan komma att införas i framtida Python-versioner):"

msgid "'message': Error message;"
msgstr "\"meddelande\": Felmeddelande;"

msgid "'exception' (optional): Exception object;"
msgstr "\"undantag\" (valfritt): Objekt för undantag;"

msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "\"future\" (valfritt): :class:`asyncio.Future` instans;"

msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'task' (valfritt): :class:`asyncio.Task` instans;"

msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (valfritt): :class:`asyncio.Handle` instans;"

msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "\"protocol\" (valfritt): :ref:`Protocol <asyncio-protocol>` instance;"

msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"\"transport\" (valfritt): :ref:`Transport <asyncio-transport>` instance;"

msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "'socket' (valfritt): :class:`socket.socket` instans;"

msgid "'source_traceback' (optional): Traceback of the source;"
msgstr "\"source_traceback\" (valfritt): Traceback för källan;"

msgid "'handle_traceback' (optional): Traceback of the handle;"
msgstr "\"handle_traceback\" (valfritt): Traceback för handtaget;"

msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "\"asyncgen\" (valfritt): Asynkron generator som orsakade"

msgid "the exception."
msgstr "undantaget."

msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler` method."
msgstr ""
"Denna metod bör inte överbelastas i underklassade händelseslingor.  För "
"anpassad undantagshantering, använd metoden :meth:`set_exception_handler`."

msgid "Enabling debug mode"
msgstr "Aktivering av felsökningsläge"

msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Hämta felsökningsläget (:class:`bool`) för händelseslingan."

msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"Standardvärdet är ``True`` om miljövariabeln :envvar:`PYTHONASYNCIODEBUG` är "
"inställd på en icke-tom sträng, annars ``False``."

msgid "Set the debug mode of the event loop."
msgstr "Ställ in felsökningsläget för händelseslingan."

msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"Den nya :ref:`Python Development Mode <devmode>` kan nu också användas för "
"att aktivera felsökningsläget."

msgid ""
"This attribute can be used to set the minimum execution duration in seconds "
"that is considered \"slow\". When debug mode is enabled, \"slow\" callbacks "
"are logged."
msgstr ""
"Detta attribut kan användas för att ange den minsta exekveringstid i "
"sekunder som anses vara \"långsam\". När felsökningsläget är aktiverat "
"loggas \"långsamma\" callbacks."

msgid "Default value is 100 milliseconds."
msgstr "Standardvärdet är 100 millisekunder."

msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`debuggläge för asyncio <asyncio-debug-mode>`."

msgid "Running Subprocesses"
msgstr "Körning av underprocesser"

msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Metoder som beskrivs i detta underavsnitt är på låg nivå.  I vanlig async/"
"await-kod bör du överväga att använda bekvämlighetsfunktionerna på hög nivå :"
"func:`asyncio.create_subprocess_shell` och :func:`asyncio."
"create_subprocess_exec` istället."

msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See :ref:"
"`Subprocess Support on Windows <asyncio-windows-subprocess>` for details."
msgstr ""
"I Windows har standardhändelseslingan :class:`ProactorEventLoop` stöd för "
"underprocesser, medan :class:`SelectorEventLoop` inte har det. Se :ref:"
"``Subprocessstöd på Windows <asyncio-windows-subprocess>` för mer "
"information."

msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Skapa en subprocess från ett eller flera strängargument som anges av *args*."

msgid "*args* must be a list of strings represented by:"
msgstr "*args* måste vara en lista med strängar som representeras av:"

msgid ":class:`str`;"
msgstr ":class:`str`;"

msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"eller :class:`bytes`, kodad enligt :ref:`filsystemskodning <filesystem-"
"encoding>`."

msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""
"Den första strängen anger det körbara programmet och de återstående "
"strängarna anger argumenten.  Tillsammans bildar strängargumenten "
"programmets ``argv``."

msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"Detta liknar standardbibliotekets klass :class:`subprocess.Popen` som "
"anropas med ``shell=False`` och en lista med strängar som första argument; "
"men där :class:`~subprocess.Popen` tar ett enda argument som är en lista med "
"strängar, tar *subprocess_exec* flera strängargument."

msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* måste vara en callable som returnerar en subklass av "
"klassen :class:`asyncio.SubprocessProtocol`."

msgid "Other parameters:"
msgstr "Övriga parametrar:"

msgid "*stdin* can be any of these:"
msgstr "*stdin* kan vara vilket som helst av dessa:"

msgid "a file-like object"
msgstr "ett filliknande objekt"

msgid ""
"an existing file descriptor (a positive integer), for example those created "
"with :meth:`os.pipe`"
msgstr ""
"en befintlig filbeskrivare (ett positivt heltal), t.ex. de som skapats med :"
"meth:`os.pipe`"

msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""
"konstanten :const:`subprocess.PIPE` (standard) som skapar ett nytt rör och "
"ansluter det,"

msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"värdet ``None`` som gör att subprocessen ärver filbeskrivaren från den här "
"processen"

msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""
"konstanten :const:`subprocess.DEVNULL` som anger att den speciella filen :"
"data:`os.devnull` ska användas"

msgid "*stdout* can be any of these:"
msgstr "*stdout* kan vara vilken som helst av dessa:"

msgid "*stderr* can be any of these:"
msgstr "*stderr* kan vara vilken som helst av dessa:"

msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"konstanten :const:`subprocess.STDOUT` som kopplar standardfelströmmen till "
"processens standardutgångsström"

msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"Alla andra nyckelordsargument skickas till :class:`subprocess.Popen` utan "
"tolkning, med undantag för *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* och *errors*, som inte bör anges alls."

msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"API:et för underprocesser i ``asyncio`` stöder inte avkodning av strömmar "
"som text. :func:`bytes.decode` kan användas för att konvertera byte som "
"returneras från strömmen till text."

msgid ""
"If a file-like object passed as *stdin*, *stdout* or *stderr* represents a "
"pipe, then the other side of this pipe should be registered with :meth:"
"`~loop.connect_write_pipe` or :meth:`~loop.connect_read_pipe` for use with "
"the event loop."
msgstr ""
"Om ett filliknande objekt som skickas som *stdin*, *stdout* eller *stderr* "
"representerar en pipe, ska den andra sidan av denna pipe registreras med :"
"meth:`~loop.connect_write_pipe` eller :meth:`~loop.connect_read_pipe` för "
"användning med händelseslingan."

msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""
"Se konstruktören för klassen :class:`subprocess.Popen` för dokumentation om "
"andra argument."

msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Returnerar ett par ``(transport, protocol)``, där *transport* överensstämmer "
"med basklassen :class:`asyncio.SubprocessTransport` och *protocol* är ett "
"objekt som instantierats av *protocol_factory*."

msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Skapa en underprocess från *cmd*, som kan vara en :class:`str` eller en :"
"class:`bytes`-sträng kodad enligt :ref:`filsystemets kodning <filesystem-"
"encoding>`, med hjälp av plattformens \"shell\"-syntax."

msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"Detta liknar standardbibliotekets :class:`subprocess.Popen`-klass som "
"anropas med ``shell=True``."

msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""
"*protocol_factory* måste vara en callable som returnerar en subklass av "
"klassen :class:`SubprocessProtocol`."

msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"Se :meth:`~loop.subprocess_exec` för mer information om de återstående "
"argumenten."

msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Returnerar ett par ``(transport, protocol)``, där *transport* överensstämmer "
"med basklassen :class:`SubprocessTransport` och *protocol* är ett objekt som "
"instantierats av *protocol_factory*."

msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"Det är applikationens ansvar att se till att alla blanksteg och "
"specialtecken citeras på rätt sätt för att undvika `shell injection <https://"
"en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ sårbarheter. "
"Funktionen :func:`shlex.quote` kan användas för att på rätt sätt undkomma "
"blanksteg och specialtecken i strängar som ska användas för att konstruera "
"skalkommandon."

msgid "Callback Handles"
msgstr "Handtag för återuppringning"

msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""
"Ett omslagsobjekt för återuppringning som returneras av :meth:`loop."
"call_soon`, :meth:`loop.call_soon_threadsafe`."

msgid ""
"Return the :class:`contextvars.Context` object associated with the handle."
msgstr ""
"Returnerar :class:`contextvars.Context`-objektet som är associerat med "
"handtaget."

msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""
"Avbryt återuppringningen.  Om återkallelsen redan har avbrutits eller "
"utförts har denna metod ingen effekt."

msgid "Return ``True`` if the callback was cancelled."
msgstr "Returnerar ``True`` om återuppringningen avbröts."

msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""
"Ett omslagsobjekt för återuppringning som returneras av :meth:`loop."
"call_later` och :meth:`loop.call_at`."

msgid "This class is a subclass of :class:`Handle`."
msgstr "Denna klass är en underklass till :class:`Handle`."

msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr "Returnerar en schemalagd callback-tid som :class:`float` sekunder."

msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""
"Tiden är en absolut tidsstämpel som använder samma tidsreferens som :meth:"
"`loop.time`."

msgid "Server Objects"
msgstr "Serverobjekt"

msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"Serverobjekt skapas av funktionerna :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server` och :func:`start_unix_server`."

msgid "Do not instantiate the :class:`Server` class directly."
msgstr "Instansiera inte :class:`Server`-klassen direkt."

msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"*Server*-objekt är asynkrona kontexthanterare.  När det används i en ``async "
"with``-sats är det garanterat att Server-objektet är stängt och inte "
"accepterar nya anslutningar när ``async with``-satsen är klar::"

msgid ""
"srv = await loop.create_server(...)\n"
"\n"
"async with srv:\n"
"    # some code\n"
"\n"
"# At this point, srv is closed and no longer accepts new connections."
msgstr ""
"srv = await loop.skapa_server(...)\n"
"\n"
"asynkron med srv:\n"
"    # lite kod\n"
"\n"
"# Vid denna tidpunkt är srv stängd och accepterar inte längre nya "
"anslutningar."

msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr "Server-objektet är en asynkron kontexthanterare sedan Python 3.7."

msgid ""
"This class was exposed publicly as ``asyncio.Server`` in Python 3.9.11, "
"3.10.3 and 3.11."
msgstr ""
"Denna klass exponerades offentligt som ``asyncio.Server`` i Python 3.9.11, "
"3.10.3 och 3.11."

msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Stoppa servering: stäng lyssnande uttag och sätt attributet :attr:`sockets` "
"till ``None``."

msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"De uttag som representerar befintliga inkommande klientanslutningar lämnas "
"öppna."

msgid ""
"The server is closed asynchronously; use the :meth:`wait_closed` coroutine "
"to wait until the server is closed (and no more connections are active)."
msgstr ""
"Servern stängs asynkront; använd :meth:`wait_closed` coroutine för att vänta "
"tills servern är stängd (och inga fler anslutningar är aktiva)."

msgid "Close all existing incoming client connections."
msgstr "Stäng alla befintliga inkommande kundanslutningar."

msgid ""
"Calls :meth:`~asyncio.BaseTransport.close` on all associated transports."
msgstr ""
"Anropar :meth:`~asyncio.BaseTransport.close` på alla associerade transporter."

msgid ""
":meth:`close` should be called before :meth:`close_clients` when closing the "
"server to avoid races with new clients connecting."
msgstr ""
":meth:`close` bör anropas före :meth:`close_clients` när servern stängs för "
"att undvika tävlingar med nya klienter som ansluter."

msgid ""
"Close all existing incoming client connections immediately, without waiting "
"for pending operations to complete."
msgstr ""
"Stäng alla befintliga inkommande klientanslutningar omedelbart, utan att "
"vänta på att väntande åtgärder ska slutföras."

msgid ""
"Calls :meth:`~asyncio.WriteTransport.abort` on all associated transports."
msgstr ""
"Anropar :meth:`~asyncio.WriteTransport.abort` på alla associerade "
"transporter."

msgid ""
":meth:`close` should be called before :meth:`abort_clients` when closing the "
"server to avoid races with new clients connecting."
msgstr ""
":meth:`close` bör anropas före :meth:`abort_clients` när servern stängs för "
"att undvika tävlingar med nya klienter som ansluter."

msgid "Return the event loop associated with the server object."
msgstr "Returnerar den händelseslinga som är kopplad till serverobjektet."

msgid "Start accepting connections."
msgstr "Börja acceptera kontakter."

msgid ""
"This method is idempotent, so it can be called when the server is already "
"serving."
msgstr ""
"Denna metod är idempotent, så den kan anropas när servern redan är i drift."

msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"Nyckelordsparametern *start_serving* till :meth:`loop.create_server` och :"
"meth:`asyncio.start_server` gör det möjligt att skapa ett serverobjekt som "
"inte accepterar anslutningar initialt.  I det här fallet kan ``Server."
"start_serving()`` eller :meth:`Server.serve_forever` användas för att få "
"servern att börja acceptera anslutningar."

msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Börja acceptera anslutningar tills coroutinen avbryts. Om uppgiften "
"``serve_forever`` avbryts stängs servern."

msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Denna metod kan anropas om servern redan accepterar anslutningar.  Endast en "
"``serve_forever`` uppgift kan finnas per ett *Server*-objekt."

msgid ""
"async def client_connected(reader, writer):\n"
"    # Communicate with the client with\n"
"    # reader/writer streams.  For example:\n"
"    await reader.readline()\n"
"\n"
"async def main(host, port):\n"
"    srv = await asyncio.start_server(\n"
"        client_connected, host, port)\n"
"    await srv.serve_forever()\n"
"\n"
"asyncio.run(main('127.0.0.1', 0))"
msgstr ""
"async def client_connected(läsare, skribent):\n"
"    # Kommunicera med klienten med\n"
"    # strömmar av läsare/skrivare.  Till exempel\n"
"    await läsare.readline()\n"
"\n"
"async def main(host, port):\n"
"    srv = await asyncio.start_server(\n"
"        client_connected, host, port)\n"
"    await srv.serve_forever()\n"
"\n"
"asyncio.run(main('127.0.0.1', 0))"

msgid "Return ``True`` if the server is accepting new connections."
msgstr "Returnerar ``True`` om servern accepterar nya anslutningar."

msgid ""
"Wait until the :meth:`close` method completes and all active connections "
"have finished."
msgstr ""
"Vänta tills metoden :meth:`close` har slutförts och alla aktiva anslutningar "
"har avslutats."

msgid ""
"List of socket-like objects, ``asyncio.trsock.TransportSocket``, which the "
"server is listening on."
msgstr ""
"Lista över socket-liknande objekt, ``asyncio.trsock.TransportSocket``, som "
"servern lyssnar på."

msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"Före Python 3.7 brukade ``Server.sockets`` returnera en intern lista över "
"serverns sockets direkt.  I 3.7 returneras en kopia av den listan."

msgid "Event Loop Implementations"
msgstr "Implementering av händelseslingor"

msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio levereras med två olika implementationer av händelseslingor: :class:"
"`SelectorEventLoop` och :class:`ProactorEventLoop`."

msgid "By default asyncio is configured to use :class:`EventLoop`."
msgstr "Som standard är asyncio konfigurerat att använda :class:`EventLoop`."

msgid ""
"A subclass of :class:`AbstractEventLoop` based on the :mod:`selectors` "
"module."
msgstr ""
"En underklass till :class:`AbstractEventLoop` baserad på modulen :mod:"
"`selectors`."

msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Använder den effektivaste *väljaren* som finns tillgänglig för den givna "
"plattformen.  Det är också möjligt att manuellt konfigurera den exakta "
"implementeringen av väljaren som ska användas::"

msgid ""
"import asyncio\n"
"import selectors\n"
"\n"
"async def main():\n"
"   ...\n"
"\n"
"loop_factory = lambda: asyncio.SelectorEventLoop(selectors."
"SelectSelector())\n"
"asyncio.run(main(), loop_factory=loop_factory)"
msgstr ""
"import asyncio\n"
"import väljare\n"
"\n"
"async def main():\n"
"   ...\n"
"\n"
"loop_factory = lambda: asyncio.SelectorEventLoop(selectors."
"SelectSelector())\n"
"asyncio.run(main(), loop_factory=loop_factory)"

msgid ""
"A subclass of :class:`AbstractEventLoop` for Windows that uses \"I/O "
"Completion Ports\" (IOCP)."
msgstr ""
"En underklass till :class:`AbstractEventLoop` för Windows som använder \"I/O "
"Completion Ports\" (IOCP)."

msgid ""
"`MSDN documentation on I/O Completion Ports <https://learn.microsoft.com/"
"windows/win32/fileio/i-o-completion-ports>`_."
msgstr ""
"mSDN-dokumentation om I/O Completion Ports <https://learn.microsoft.com/"
"windows/win32/fileio/i-o-completion-ports>`_."

msgid ""
"An alias to the most efficient available subclass of :class:"
"`AbstractEventLoop` for the given platform."
msgstr ""
"Ett alias till den mest effektiva tillgängliga underklassen till :class:"
"`AbstractEventLoop` för den givna plattformen."

msgid ""
"It is an alias to :class:`SelectorEventLoop` on Unix and :class:"
"`ProactorEventLoop` on Windows."
msgstr ""
"Det är ett alias till :class:`SelectorEventLoop` på Unix och :class:"
"`ProactorEventLoop` på Windows."

msgid "Abstract base class for asyncio-compliant event loops."
msgstr "Abstrakt basklass för asynciokompatibla händelseslingor."

msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""
"Avsnittet :ref:`asyncio-event-loop-methods` listar alla metoder som en "
"alternativ implementation av ``AbstractEventLoop`` borde ha definierat."

msgid "Examples"
msgstr "Exempel"

msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"Observera att alla exempel i detta avsnitt **avsiktligt** visar hur man "
"använder lågnivå-API:er för händelseslingor, som :meth:`loop.run_forever` "
"och :meth:`loop.call_soon`.  Moderna asyncio-applikationer behöver sällan "
"skrivas på det här sättet; överväg att använda högnivåfunktioner som :func:"
"`asyncio.run`."

msgid "Hello World with call_soon()"
msgstr "Hello World med call_soon()"

msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Ett exempel där metoden :meth:`loop.call_soon` används för att schemalägga "
"en återuppringning. Återkallelsen visar ``\"Hello World\"`` och stoppar "
"sedan händelseslingan::"

msgid ""
"import asyncio\n"
"\n"
"def hello_world(loop):\n"
"    \"\"\"A callback to print 'Hello World' and stop the event loop\"\"\"\n"
"    print('Hello World')\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule a call to hello_world()\n"
"loop.call_soon(hello_world, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"\n"
"def hello_world(loop):\n"
"    \"\"\"A callback to print 'Hello World' and stop the event loop\"\"\"\n"
"    print('Hello World')\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule a call to hello_world()\n"
"loop.call_soon(hello_world, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"

msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"Ett liknande :ref:`Hello World <coroutine>` exempel skapat med en coroutine "
"och funktionen :func:`run`."

msgid "Display the current date with call_later()"
msgstr "Visa aktuellt datum med call_later()"

msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Ett exempel på en callback som visar aktuellt datum varje sekund. "
"Återuppringningen använder metoden :meth:`loop.call_later` för att "
"schemalägga om sig själv efter 5 sekunder, och stoppar sedan "
"händelseslingan::"

msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"def display_date(end_time, loop):\n"
"    print(datetime.datetime.now())\n"
"    if (loop.time() + 1.0) < end_time:\n"
"        loop.call_later(1, display_date, end_time, loop)\n"
"    else:\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule the first call to display_date()\n"
"end_time = loop.time() + 5.0\n"
"loop.call_soon(display_date, end_time, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"def display_date(slut_tid, loop):\n"
"    print(datetime.datetime.now())\n"
"    if (loop.time() + 1.0) < end_time:\n"
"        loop.call_later(1, display_date, end_time, loop)\n"
"    annat:\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schemalägg det första anropet till display_date()\n"
"end_time = loop.time() + 5.0\n"
"loop.call_soon(display_date, end_time, loop)\n"
"\n"
"# Blockerande anrop avbrutet av loop.stop()\n"
"försök:\n"
"    loop.run_forever()\n"
"finally: loop.run_forever()\n"
"    loop.close()"

msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"Ett liknande :ref:`aktuellt datum <asyncio_example_sleep>` exempel skapat "
"med en coroutine och funktionen :func:`run`."

msgid "Watch a file descriptor for read events"
msgstr "Bevaka en filbeskrivare för läshändelser"

msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""
"Vänta tills en filbeskrivningsenhet har tagit emot data med hjälp av "
"metoden :meth:`loop.add_reader` och stäng sedan händelseslingan::"

msgid ""
"import asyncio\n"
"from socket import socketpair\n"
"\n"
"# Create a pair of connected file descriptors\n"
"rsock, wsock = socketpair()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"def reader():\n"
"    data = rsock.recv(100)\n"
"    print(\"Received:\", data.decode())\n"
"\n"
"    # We are done: unregister the file descriptor\n"
"    loop.remove_reader(rsock)\n"
"\n"
"    # Stop the event loop\n"
"    loop.stop()\n"
"\n"
"# Register the file descriptor for read event\n"
"loop.add_reader(rsock, reader)\n"
"\n"
"# Simulate the reception of data from the network\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"try:\n"
"    # Run the event loop\n"
"    loop.run_forever()\n"
"finally:\n"
"    # We are done. Close sockets and the event loop.\n"
"    rsock.close()\n"
"    wsock.close()\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"from socket import socketpair\n"
"\n"
"# Create a pair of connected file descriptors\n"
"rsock, wsock = socketpair()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"def reader():\n"
"    data = rsock.recv(100)\n"
"    print(\"Received:\", data.decode())\n"
"\n"
"    # We are done: unregister the file descriptor\n"
"    loop.remove_reader(rsock)\n"
"\n"
"    # Stop the event loop\n"
"    loop.stop()\n"
"\n"
"# Register the file descriptor for read event\n"
"loop.add_reader(rsock, reader)\n"
"\n"
"# Simulate the reception of data from the network\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"try:\n"
"    # Run the event loop\n"
"    loop.run_forever()\n"
"finally:\n"
"    # We are done. Close sockets and the event loop.\n"
"    rsock.close()\n"
"    wsock.close()\n"
"    loop.close()"

msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"En liknande :ref:`example <asyncio_example_create_connection>` med "
"transporter, protokoll och metoden :meth:`loop.create_connection`."

msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"En annan liknande :ref:`exempel <asyncio_example_create_connection-streams>` "
"som använder högnivåfunktionen :func:`asyncio.open_connection` och streams."

msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Ange signalhanterare för SIGINT och SIGTERM"

msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Detta ``signals``-exempel fungerar bara på Unix.)"

msgid ""
"Register handlers for signals :const:`~signal.SIGINT` and :const:`~signal."
"SIGTERM` using the :meth:`loop.add_signal_handler` method::"
msgstr ""
"Registrera hanterare för signalerna :const:`~signal.SIGINT` och :const:"
"`~signal.SIGTERM` med hjälp av metoden :meth:`loop.add_signal_handler`::"

msgid ""
"import asyncio\n"
"import functools\n"
"import os\n"
"import signal\n"
"\n"
"def ask_exit(signame, loop):\n"
"    print(\"got signal %s: exit\" % signame)\n"
"    loop.stop()\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    for signame in {'SIGINT', 'SIGTERM'}:\n"
"        loop.add_signal_handler(\n"
"            getattr(signal, signame),\n"
"            functools.partial(ask_exit, signame, loop))\n"
"\n"
"    await asyncio.sleep(3600)\n"
"\n"
"print(\"Event loop running for 1 hour, press Ctrl+C to interrupt.\")\n"
"print(f\"pid {os.getpid()}: send SIGINT or SIGTERM to exit.\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import functools\n"
"import os\n"
"import signal\n"
"\n"
"def ask_exit(signame, loop):\n"
"    print(\"got signal %s: exit\" % signame)\n"
"    loop.stop()\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    for signame in {'SIGINT', 'SIGTERM'}:\n"
"        loop.add_signal_handler(\n"
"            getattr(signal, signame),\n"
"            functools.partial(ask_exit, signame, loop))\n"
"\n"
"    await asyncio.sleep(3600)\n"
"\n"
"print(\"Event loop running for 1 hour, press Ctrl+C to interrupt.\")\n"
"print(f\"pid {os.getpid()}: send SIGINT or SIGTERM to exit.\")\n"
"\n"
"asyncio.run(main())"
