# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!argparse` --- Parser for command-line options, arguments and "
"subcommands"
msgstr ""
":mod:`!argparse` --- Parser för kommandoradsalternativ, argument och "
"underkommandon"

msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**Källkod:** :source:`Lib/argparse.py`"

msgid ""
"While :mod:`argparse` is the default recommended standard library module for "
"implementing basic command line applications, authors with more exacting "
"requirements for exactly how their command line applications behave may find "
"it doesn't provide the necessary level of control. Refer to :ref:`choosing-"
"an-argument-parser` for alternatives to consider when ``argparse`` doesn't "
"support behaviors that the application requires (such as entirely disabling "
"support for interspersed options and positional arguments, or accepting "
"option parameter values that start with ``-`` even when they correspond to "
"another defined option)."
msgstr ""
"Medan :mod:`argparse` är den rekommenderade standardbiblioteksmodulen för "
"implementering av grundläggande kommandoradsapplikationer, kan författare "
"med mer krävande krav på exakt hur deras kommandoradsapplikationer beter sig "
"tycka att den inte ger den nödvändiga kontrollnivån. Se :ref:`choosing-an-"
"argument-parser` för alternativ att överväga när ``argparse`` inte stöder "
"beteenden som programmet kräver (t.ex. att helt inaktivera stöd för "
"insprängda alternativ och positionella argument, eller att acceptera "
"alternativparametervärden som börjar med ``-`` även om de motsvarar ett "
"annat definierat alternativ)."

msgid "Tutorial"
msgstr "Handledning"

msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the :ref:"
"`argparse tutorial <argparse-tutorial>`."
msgstr ""
"Den här sidan innehåller API-referensinformation. För en mer skonsam "
"introduktion till Python kommandoradsanalys, ta en titt på :ref:`argparse "
"tutorial <argparse-tutorial>`."

msgid ""
"The :mod:`!argparse` module makes it easy to write user-friendly command-"
"line interfaces. The program defines what arguments it requires, and :mod:`!"
"argparse` will figure out how to parse those out of :data:`sys.argv`.  The :"
"mod:`!argparse` module also automatically generates help and usage "
"messages.  The module will also issue errors when users give the program "
"invalid arguments."
msgstr ""
"Modulen :mod:`!argparse` gör det enkelt att skriva användarvänliga "
"kommandoradsgränssnitt. Programmet definierar vilka argument det behöver "
"och :mod:`!argparse` räknar ut hur dessa ska tolkas ur :data:`sys.argv`.  "
"Modulen :mod:`!argparse` genererar också automatiskt hjälp- och "
"användningsmeddelanden.  Modulen kommer också att ge felmeddelanden när "
"användare ger programmet ogiltiga argument."

msgid ""
"The :mod:`!argparse` module's support for command-line interfaces is built "
"around an instance of :class:`argparse.ArgumentParser`.  It is a container "
"for argument specifications and has options that apply to the parser as "
"whole::"
msgstr ""
":mod:`!argparse`-modulens stöd för kommandoradsgränssnitt är uppbyggt kring "
"en instans av :class:`argparse.ArgumentParser`.  Den är en behållare för "
"argumentspecifikationer och har alternativ som gäller för parsern som "
"helhet::"

msgid ""
"parser = argparse.ArgumentParser(\n"
"                    prog='ProgramName',\n"
"                    description='What the program does',\n"
"                    epilog='Text at the bottom of help')"
msgstr ""
"parser = argparse.ArgumentParser(\n"
"                    prog='Programnamn',\n"
"                    description='Vad programmet gör',\n"
"                    epilog='Text längst ner i hjälpen')"

msgid ""
"The :meth:`ArgumentParser.add_argument` method attaches individual argument "
"specifications to the parser.  It supports positional arguments, options "
"that accept values, and on/off flags::"
msgstr ""
"Metoden :meth:`ArgumentParser.add_argument` kopplar individuella "
"argumentspecifikationer till parsern.  Den stöder positionella argument, "
"alternativ som accepterar värden och on/off-flaggor::"

msgid ""
"parser.add_argument('filename')           # positional argument\n"
"parser.add_argument('-c', '--count')      # option that takes a value\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true')  # on/off flag"
msgstr ""
"parser.add_argument('filnamn') # positionellt argument\n"
"parser.add_argument('-c', '--count') # alternativ som tar ett värde\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true') # på/av-flagga"

msgid ""
"The :meth:`ArgumentParser.parse_args` method runs the parser and places the "
"extracted data in a :class:`argparse.Namespace` object::"
msgstr ""
"Metoden :meth:`ArgumentParser.parse_args` kör parsern och placerar de "
"extraherade uppgifterna i ett :class:`argparse.Namespace`-objekt::"

msgid ""
"args = parser.parse_args()\n"
"print(args.filename, args.count, args.verbose)"
msgstr ""
"args = parser.parse_args()\n"
"print(args.filnamn, args.antal, args.verbose)"

msgid ""
"If you're looking for a guide about how to upgrade :mod:`optparse` code to :"
"mod:`!argparse`, see :ref:`Upgrading Optparse Code <upgrading-optparse-"
"code>`."
msgstr ""
"Om du letar efter en guide om hur du uppgraderar :mod:`optparse`-kod till :"
"mod:`!argparse`, se :ref:`Uppgradering av Optparse-kod <upgrading-optparse-"
"code>`."

msgid "ArgumentParser objects"
msgstr "ArgumentParser-objekt"

msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be passed "
"as keyword arguments. Each parameter has its own more detailed description "
"below, but in short they are:"
msgstr ""
"Skapa ett nytt :class:`ArgumentParser`-objekt. Alla parametrar ska skickas "
"som nyckelordsargument. Varje parameter har sin egen mer detaljerade "
"beskrivning nedan, men i korthet är de:"

msgid ""
"prog_ - The name of the program (default: generated from the ``__main__`` "
"module attributes and ``sys.argv[0]``)"
msgstr ""
"prog_ - Namnet på programmet (standard: genereras från modulattributen "
"``__main__`` och ```sys.argv[0]``)"

msgid ""
"usage_ - The string describing the program usage (default: generated from "
"arguments added to parser)"
msgstr ""
"usage_ - Sträng som beskriver hur programmet används (standard: genereras "
"från argument som läggs till i parsern)"

msgid ""
"description_ - Text to display before the argument help (by default, no text)"
msgstr ""
"description_ - Text som ska visas före argumentet help (ingen text som "
"standard)"

msgid "epilog_ - Text to display after the argument help (by default, no text)"
msgstr ""
"epilog_ - Text som ska visas efter argumentet help (ingen text som standard)"

msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments should "
"also be included"
msgstr ""
"parents_ - En lista över :class:`ArgumentParser`-objekt vars argument också "
"ska inkluderas"

msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ - En klass för att anpassa hjälputmatningen"

msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr ""
"prefix_chars_ - Uppsättningen av tecken som prefixar valfria argument "
"(standard: '-')"

msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from which "
"additional arguments should be read (default: ``None``)"
msgstr ""
"fromfile_prefix_chars_ - Uppsättningen tecken som prefixar filer från vilka "
"ytterligare argument ska läsas (standard: ``None``)"

msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr ""
"argument_default_ - Det globala standardvärdet för argument (standard: "
"``None``)"

msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr ""
"conflict_handler_ - Strategi för att lösa motstridiga tillval (vanligtvis "
"onödig)"

msgid ""
"add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr ""
"add_help_ - Lägg till ett ``-h/--help``-alternativ till parsern (standard: "
"``True``)"

msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation is "
"unambiguous (default: ``True``)"
msgstr ""
"allow_abbrev_ - Tillåter att långa alternativ förkortas om förkortningen är "
"entydig (standard: ``True``)"

msgid ""
"exit_on_error_ - Determines whether or not :class:`!ArgumentParser` exits "
"with error info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ - Bestämmer om :class:`!ArgumentParser` avslutas med "
"felinformation när ett fel inträffar eller inte. (standard: ``True``)"

msgid ""
"suggest_on_error_ - Enables suggestions for mistyped argument choices and "
"subparser names (default: ``False``)"
msgstr ""
"suggest_on_error_ - Aktiverar förslag för felskrivna argumentval och namn på "
"subparser (standard: ``False``)"

msgid "color_ - Allow color output (default: ``True``)"
msgstr "color_ - Tillåt färgutmatning (standard: ``True``)"

msgid "*allow_abbrev* parameter was added."
msgstr "*parametern allow_abbrev* har lagts till."

msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short flags "
"such as ``-vv`` to mean ``-v -v``."
msgstr ""
"I tidigare versioner avaktiverade *allow_abbrev* också gruppering av korta "
"flaggor som ``-vv`` för att betyda ``-v -v``."

msgid "*exit_on_error* parameter was added."
msgstr "*parametern exit_on_error* har lagts till."

msgid "*suggest_on_error* and *color* parameters were added."
msgstr "*parametrarna suggest_on_error* och *color* har lagts till."

msgid "The following sections describe how each of these are used."
msgstr "I följande avsnitt beskrivs hur de olika funktionerna används."

msgid "prog"
msgstr "prog"

msgid ""
"By default, :class:`ArgumentParser` calculates the name of the program to "
"display in help messages depending on the way the Python interpreter was run:"
msgstr ""
"Som standard beräknar :class:`ArgumentParser` namnet på det program som ska "
"visas i hjälpmeddelanden beroende på hur Python-tolken kördes:"

msgid ""
"The :func:`base name <os.path.basename>` of ``sys.argv[0]`` if a file was "
"passed as argument."
msgstr ""
":func:`basnamn <os.path.basename>` av ``sys.argv[0]`` om en fil skickades "
"som argument."

msgid ""
"The Python interpreter name followed by ``sys.argv[0]`` if a directory or a "
"zipfile was passed as argument."
msgstr ""
"Namnet på Python-tolken följt av ``sys.argv[0]`` om en katalog eller en zip-"
"fil skickades som argument."

msgid ""
"The Python interpreter name followed by ``-m`` followed by the module or "
"package name if the :option:`-m` option was used."
msgstr ""
"Python-tolkens namn följt av ``-m`` följt av modul- eller paketnamnet om "
"alternativet :option:`-m` användes."

msgid ""
"This default is almost always desirable because it will make the help "
"messages match the string that was used to invoke the program on the command "
"line. However, to change this default behavior, another value can be "
"supplied using the ``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Denna standard är nästan alltid önskvärd eftersom det gör att "
"hjälpmeddelandena matchar den sträng som användes för att anropa programmet "
"på kommandoraden. För att ändra detta standardbeteende kan dock ett annat "
"värde anges med argumentet ``prog=`` till :class:`ArgumentParser`::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='mittprogram')\n"
">>> parser.print_help()\n"
"användning: myprogram [-h]\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta"

msgid ""
"Note that the program name, whether determined from ``sys.argv[0]``, from "
"the ``__main__`` module attributes or from the ``prog=`` argument, is "
"available to help messages using the ``%(prog)s`` format specifier."
msgstr ""
"Observera att programnamnet, oavsett om det hämtas från ```sys.argv[0]``, "
"från modulattributen ``__main__`` eller från argumentet ``prog=``, är "
"tillgängligt för hjälpmeddelanden som använder formatspecificeraren "
"``%(prog)s``."

msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='mittprogram')\n"
">>> parser.add_argument('--foo', help='foo i %(prog)s-programmet')\n"
">>> parser.print_help()\n"
"användning: myprogram [-h] [--foo FOO]\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" --foo FOO foo i programmet myprogram"

msgid ""
"The default ``prog`` value now reflects how ``__main__`` was actually "
"executed, rather than always being ``os.path.basename(sys.argv[0])``."
msgstr ""
"Standardvärdet för ``prog`` återspeglar nu hur ``__main__`` faktiskt "
"exekverades, i stället för att alltid vara ``os.path.basename(sys.argv[0])``."

msgid "usage"
msgstr "användning"

msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the "
"arguments it contains. The default message can be overridden with the "
"``usage=`` keyword argument::"
msgstr ""
"Som standard beräknar :class:`ArgumentParser` användningsmeddelandet från de "
"argument som den innehåller. Standardmeddelandet kan åsidosättas med "
"nyckelordet ``usage=`` argument::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar hjälp')\n"
">>> parser.print_help()\n"
"användning: PROG [alternativ]\n"
"\n"
"positionella argument:\n"
" bar bar hjälp\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" --foo [FOO] foo hjälp"

msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program name "
"in your usage messages."
msgstr ""
"Formatangivelsen ``%(prog)s`` är tillgänglig för att fylla i programnamnet i "
"dina användningsmeddelanden."

msgid ""
"When a custom usage message is specified for the main parser, you may also "
"want to consider passing  the ``prog`` argument to :meth:`~ArgumentParser."
"add_subparsers` or the ``prog`` and the ``usage`` arguments to :meth:"
"`~_SubParsersAction.add_parser`, to ensure consistent command prefixes and "
"usage information across subparsers."
msgstr ""
"När ett anpassat användningsmeddelande anges för huvudparsern kanske du "
"också vill överväga att skicka argumentet ``prog`` till :meth:"
"`~ArgumentParser.add_subparsers` eller argumenten ``prog`` och ``usage`` "
"till :meth:`~_SubParsersAction.add_parser`, för att säkerställa konsekventa "
"kommandoprefix och användningsinformation mellan underparsers."

msgid "description"
msgstr "beskrivning"

msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief description "
"of what the program does and how it works.  In help messages, the "
"description is displayed between the command-line usage string and the help "
"messages for the various arguments."
msgstr ""
"De flesta anrop till konstruktören :class:`ArgumentParser` kommer att "
"använda nyckelordsargumentet ``description=``.  Detta argument ger en kort "
"beskrivning av vad programmet gör och hur det fungerar.  I hjälpmeddelanden "
"visas beskrivningen mellan kommandoradsanvändningssträngen och "
"hjälpmeddelandena för de olika argumenten."

msgid ""
"By default, the description will be line-wrapped so that it fits within the "
"given space.  To change this behavior, see the formatter_class_ argument."
msgstr ""
"Som standard kommer beskrivningen att radbrytas så att den ryms inom det "
"angivna utrymmet.  För att ändra detta beteende, se argumentet "
"formatter_class_."

msgid "epilog"
msgstr "epilog"

msgid ""
"Some programs like to display additional description of the program after "
"the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Vissa program vill visa ytterligare en beskrivning av programmet efter "
"beskrivningen av argumenten.  Sådan text kan anges med hjälp av argumentet "
"``epilog=`` till :class:`ArgumentParser`::"

msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"... beskrivning=\"En foo som barrar\",\n"
"... epilog=\"Och det är så du skulle foo en bar\")\n"
">>> parser.print_help()\n"
"användning: argparse.py [-h]\n"
"\n"
"En foo som barrar\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
"\n"
"Och det är så du gör foo en bar"

msgid ""
"As with the description_ argument, the ``epilog=`` text is by default line-"
"wrapped, but this behavior can be adjusted with the formatter_class_ "
"argument to :class:`ArgumentParser`."
msgstr ""
"Precis som med argumentet description_ är texten ``epilog=`` som standard "
"radbrytande, men detta beteende kan justeras med argumentet formatter_class_ "
"till :class:`ArgumentParser`."

msgid "parents"
msgstr "föräldrar"

msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all the "
"shared arguments and passed to ``parents=`` argument to :class:"
"`ArgumentParser` can be used.  The ``parents=`` argument takes a list of :"
"class:`ArgumentParser` objects, collects all the positional and optional "
"actions from them, and adds these actions to the :class:`ArgumentParser` "
"object being constructed::"
msgstr ""
"Ibland delar flera parsers en gemensam uppsättning argument. Istället för "
"att upprepa definitionerna av dessa argument, kan en enda parser med alla de "
"delade argumenten och som skickas till ``parents=`` argumentet till :class:"
"`ArgumentParser` användas.  Argumentet ``parents=`` tar en lista med :class:"
"`ArgumentParser`-objekt, samlar in alla positionella och valfria åtgärder "
"från dem och lägger till dessa åtgärder till :class:`ArgumentParser`-"
"objektet som konstrueras::"

msgid ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"
msgstr ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namnrymd(foo='XXX', förälder=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namnrymd(bar='YYY', förälder=None)"

msgid ""
"Note that most parent parsers will specify ``add_help=False``.  Otherwise, "
"the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the "
"parent and one in the child) and raise an error."
msgstr ""
"Observera att de flesta överordnade parsers kommer att ange "
"``add_help=False``.  Annars kommer :class:`ArgumentParser` att se två ``-h/--"
"help``-alternativ (ett i den överordnade och ett i den underordnade) och ge "
"upphov till ett fel."

msgid ""
"You must fully initialize the parsers before passing them via ``parents=``. "
"If you change the parent parsers after the child parser, those changes will "
"not be reflected in the child."
msgstr ""
"Du måste initialisera parsarna fullständigt innan du skickar dem via "
"``parents=``. Om du ändrar de överordnade parsarna efter den underordnade "
"parsern kommer dessa ändringar inte att återspeglas i den underordnade "
"parsern."

msgid "formatter_class"
msgstr "formatter_klass"

msgid ""
":class:`ArgumentParser` objects allow the help formatting to be customized "
"by specifying an alternate formatting class.  Currently, there are four such "
"classes:"
msgstr ""
":class:`ArgumentParser`-objekt gör det möjligt att anpassa "
"hjälpformateringen genom att ange en alternativ formateringsklass.  För "
"närvarande finns det fyra sådana klasser:"

msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` give "
"more control over how textual descriptions are displayed. By default, :class:"
"`ArgumentParser` objects line-wrap the description_ and epilog_ texts in "
"command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` och :class:`RawTextHelpFormatter` ger "
"mer kontroll över hur textbeskrivningar visas. Som standard radbryter :class:"
"`ArgumentParser`-objekten texten description_ och epilog_ i "
"kommandoradshjälpmeddelanden::"

msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''this description\n"
"...         was indented weird\n"
"...             but that is okay''',\n"
"...     epilog='''\n"
"...             likewise for this epilog whose whitespace will\n"
"...         be cleaned up and whose words will be wrapped\n"
"...         across a couple lines''')\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"this description was indented weird but that is okay\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"likewise for this epilog whose whitespace will be cleaned up and whose "
"words\n"
"will be wrapped across a couple lines"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"... prog='PROG',\n"
"... description='''den här beskrivningen\n"
"... var indragen konstigt\n"
"... men det är okej''',\n"
"... epilog='''\n"
"... likaså för denna epilog vars blanksteg kommer att\n"
"... städas upp och vars ord kommer att lindas in\n"
"... över ett par rader''')\n"
">>> parser.print_help()\n"
"användning: PROG [-h]\n"
"\n"
"den här beskrivningen var indragen konstigt men det är okej\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
"\n"
"likadant för denna epilog vars blanksteg kommer att rensas upp och vars ord\n"
"kommer att lindas in över ett par rader"

msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted and "
"should not be line-wrapped::"
msgstr ""
"Om du anger :class:`RawDescriptionHelpFormatter` som ``formatter_class=`` "
"indikerar det att description_ och epilog_ redan är korrekt formaterade och "
"inte ska radbrytas:"

msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Please do not mess up this text!\n"
"...         --------------------------------\n"
"...             I have indented it\n"
"...             exactly the way\n"
"...             I want it\n"
"...         '''))\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"Please do not mess up this text!\n"
"--------------------------------\n"
"   I have indented it\n"
"   exactly the way\n"
"   I want it\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"... prog='PROG',\n"
"... formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"... description=textwrap.dedent('''\\\n"
"...         Snälla, förstör inte den här texten!\n"
"...         --------------------------------\n"
"...             Jag har indragit den\n"
"... exakt på samma sätt\n"
"...             Jag vill ha det\n"
"...         '''))\n"
">>> parser.print_help()\n"
"användning: PROG [-h]\n"
"\n"
"Snälla, förstör inte den här texten!\n"
"--------------------------------\n"
"   Jag har indragit den\n"
"   exakt på det sätt\n"
"   Jag vill ha det\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta"

msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple newlines are "
"replaced with one. If you wish to preserve multiple blank lines, add spaces "
"between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` bibehåller blanksteg för alla typer av "
"hjälptexter, inklusive argumentbeskrivningar. Flera nya linjer ersätts dock "
"med en. Om du vill bevara flera tomma rader lägger du till mellanslag mellan "
"nylinjerna."

msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information about "
"default values to each of the argument help messages::"
msgstr ""
":class:`ArgumentDefaultsHelpFormatter` lägger automatiskt till information "
"om standardvärden till varje argumenthjälpmeddelande::"

msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"... prog='PROG',\n"
"... formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"användning: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positionella argument:\n"
" bar BAR! (standard: [1, 2, 3])\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" --foo FOO FOO FOO! (standard: 42)"

msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for "
"each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` använder namnet på typ_argumentet för "
"varje argument som visningsnamn för dess värden (i stället för att använda "
"dest_ som den vanliga formateraren gör)::"

msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"... prog='PROG',\n"
"... formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"användning: PROG [-h] [--foo int] float\n"
"\n"
"positionella argument:\n"
"  float\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  --foo int"

msgid "prefix_chars"
msgstr "prefix_chars"

msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. ``-f/--foo``. "
"Parsers that need to support different or additional prefix characters, e.g. "
"for options like ``+f`` or ``/foo``, may specify them using the "
"``prefix_chars=`` argument to the :class:`ArgumentParser` constructor::"
msgstr ""
"De flesta kommandoradsalternativ använder ``-`` som prefix, t.ex. ``-f/--"
"foo``. Parsers som behöver stödja andra eller ytterligare prefixtecken, t."
"ex. för alternativ som ``+f`` eller ``/foo``, kan ange dem med argumentet "
"``prefix_chars=`` till :class:`ArgumentParser`-konstruktören::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.lägg_till_argument('+f')\n"
">>> parser.lägg_till_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namnrymd(bar='Y', f='X')"

msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to be "
"disallowed."
msgstr ""
"Argumentet ``prefix_chars=`` är som standard ``'-'``. Om du anger en "
"uppsättning tecken som inte innehåller ``-`` kommer alternativen ``-f/--"
"foo`` inte att tillåtas."

msgid "fromfile_prefix_chars"
msgstr "frånfil_prefix_chars"

msgid ""
"Sometimes, when dealing with a particularly long argument list, it may make "
"sense to keep the list of arguments in a file rather than typing it out at "
"the command line.  If the ``fromfile_prefix_chars=`` argument is given to "
"the :class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be replaced "
"by the arguments they contain.  For example::"
msgstr ""
"Ibland, när man har att göra med en särskilt lång argumentlista, kan det "
"vara vettigt att spara listan med argument i en fil i stället för att skriva "
"ut den på kommandoraden.  Om argumentet ``fromfile_prefix_chars=`` ges till "
"konstruktören :class:`ArgumentParser`, kommer argument som börjar med något "
"av de angivna tecknen att behandlas som filer och ersättas av de argument de "
"innehåller.  Till exempel::"

msgid ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"...     fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"
msgstr ""
">>> med open('args.txt', 'w', encoding=sys.getfilesystemencoding()) som fp:\n"
"... fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namnrymd(f='bar')"

msgid ""
"Arguments read from a file must be one per line by default (but see also :"
"meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if they "
"were in the same place as the original file referencing argument on the "
"command line.  So in the example above, the expression ``['-f', 'foo', "
"'@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', '-"
"f', 'bar']``."
msgstr ""
"Argument som läses från en fil måste som standard vara en per rad (men se "
"även :meth:`~ArgumentParser.convert_arg_line_to_args`) och behandlas som om "
"de stod på samma plats som det ursprungliga filrefererande argumentet på "
"kommandoraden.  I exemplet ovan anses alltså uttrycket ``['-f', 'foo', "
"'@args.txt']`` vara likvärdigt med uttrycket ``['-f', 'foo', '-f', 'bar']``."

msgid ""
"Empty lines are treated as empty strings (``''``), which are allowed as "
"values but not as arguments. Empty lines that are read as arguments will "
"result in an \"unrecognized arguments\" error."
msgstr ""
"Tomma rader behandlas som tomma strängar (``''``), som är tillåtna som "
"värden men inte som argument. Tomma rader som läses som argument resulterar "
"i felet \"unrecognized arguments\"."

msgid ""
":class:`ArgumentParser` uses :term:`filesystem encoding and error handler` "
"to read the file containing arguments."
msgstr ""
":class:`ArgumentParser` använder :term:`filsystemkodning och felhantering` "
"för att läsa filen som innehåller argument."

msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that "
"arguments will never be treated as file references."
msgstr ""
"Argumentet ``fromfile_prefix_chars=`` har standardvärdet ``None``, vilket "
"innebär att argument aldrig kommer att behandlas som filreferenser."

msgid ""
":class:`ArgumentParser` changed encoding and errors to read arguments files "
"from default (e.g. :func:`locale.getpreferredencoding(False) <locale."
"getpreferredencoding>` and ``\"strict\"``) to the :term:`filesystem encoding "
"and error handler`. Arguments file should be encoded in UTF-8 instead of "
"ANSI Codepage on Windows."
msgstr ""
":class:`ArgumentParser` ändrade kodning och fel för att läsa argumentfiler "
"från standard (t.ex. :func:`locale.getpreferredencoding(False) <locale."
"getpreferredencoding>` och ``\"strict\"``) till :term:`filsystemets kodning "
"och felhantering`. Argumentsfilen bör kodas i UTF-8 istället för ANSI "
"Codepage på Windows."

msgid "argument_default"
msgstr "argument_default"

msgid ""
"Generally, argument defaults are specified either by passing a default to :"
"meth:`~ArgumentParser.add_argument` or by calling the :meth:`~ArgumentParser."
"set_defaults` methods with a specific set of name-value pairs.  Sometimes "
"however, it may be useful to specify a single parser-wide default for "
"arguments.  This can be accomplished by passing the ``argument_default=`` "
"keyword argument to :class:`ArgumentParser`.  For example, to globally "
"suppress attribute creation on :meth:`~ArgumentParser.parse_args` calls, we "
"supply ``argument_default=SUPPRESS``::"
msgstr ""
"I allmänhet anges standardvärden för argument antingen genom att skicka ett "
"standardvärde till :meth:`~ArgumentParser.add_argument` eller genom att "
"anropa metoderna :meth:`~ArgumentParser.set_defaults` med en specifik "
"uppsättning namn-värde-par.  Ibland kan det dock vara användbart att ange en "
"enda parser-omfattande standard för argument.  Detta kan åstadkommas genom "
"att skicka nyckelordsargumentet ``argument_default=`` till :class:"
"`ArgumentParser`.  Till exempel, för att globalt undertrycka skapandet av "
"attribut vid :meth:`~ArgumentParser.parse_args`-anrop, anger vi "
"``argument_default=SUPPRESS``::"

msgid ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"
msgstr ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.lägg_till_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namnrymd(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namnrymd()"

msgid "allow_abbrev"
msgstr "tillåt_abbrev"

msgid ""
"Normally, when you pass an argument list to the :meth:`~ArgumentParser."
"parse_args` method of an :class:`ArgumentParser`, it :ref:`recognizes "
"abbreviations <prefix-matching>` of long options."
msgstr ""
"Normalt, när du skickar en argumentlista till metoden :meth:`~ArgumentParser."
"parse_args` i en :class:`ArgumentParser`, :ref:``känner den igen "
"förkortningar <prefix-matching>` av långa alternativ."

msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr ""
"Denna funktion kan avaktiveras genom att ställa in ``allow_abbrev`` till "
"``False``::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"användning: PROG [-h] [--foobar] [--foonley]\n"
"PROG: fel: oigenkända argument: --foon"

msgid "conflict_handler"
msgstr "konflikt_hanterare"

msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option string "
"that is already in use::"
msgstr ""
":class:`ArgumentParser`-objekt tillåter inte två åtgärder med samma "
"alternativsträng.  Som standard gör :class:`ArgumentParser`-objekt ett "
"undantag om ett försök görs att skapa ett argument med en alternativsträng "
"som redan används::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='gammal foo hjälp')\n"
">>> parser.add_argument('--foo', help='ny foo-hjälp')\n"
"Traceback (senaste anropet senast):\n"
" ..\n"
"ArgumentError: argument --foo: motstridiga alternativ sträng(ar): --foo"

msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override any "
"older arguments with the same option string.  To get this behavior, the "
"value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument "
"of :class:`ArgumentParser`::"
msgstr ""
"Ibland (t.ex. när man använder parents_) kan det vara användbart att helt "
"enkelt åsidosätta äldre argument med samma alternativsträng.  För att få "
"detta beteende kan värdet ``'resolve'`` anges till argumentet "
"``conflict_handler=`` i :class:`ArgumentParser`::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='gammal foo hjälp')\n"
">>> parser.add_argument('--foo', help='ny foo-hjälp')\n"
">>> parser.print_help()\n"
"användning: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" -f FOO gammal foo hjälp\n"
" --foo FOO ny foo hjälp"

msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of "
"its option strings are overridden.  So, in the example above, the old ``-f/--"
"foo`` action is retained as the ``-f`` action, because only the ``--foo`` "
"option string was overridden."
msgstr ""
"Observera att :class:`ArgumentParser`-objekt endast tar bort en åtgärd om "
"alla dess alternativsträngar är åsidosatta.  Så i exemplet ovan behålls den "
"gamla åtgärden ``-f/--foo`` som åtgärden ``-f``, eftersom endast "
"alternativsträngen ``--foo`` åsidosattes."

msgid "add_help"
msgstr "lägg till_hjälp"

msgid ""
"By default, :class:`ArgumentParser` objects add an option which simply "
"displays the parser's help message. If ``-h`` or ``--help`` is supplied at "
"the command line, the :class:`!ArgumentParser` help will be printed."
msgstr ""
"Som standard lägger :class:`ArgumentParser`-objekt till ett alternativ som "
"helt enkelt visar parserns hjälpmeddelande. Om ``-h`` eller ``--help`` anges "
"på kommandoraden, kommer :class:`!ArgumentParser` hjälp att skrivas ut."

msgid ""
"Occasionally, it may be useful to disable the addition of this help option. "
"This can be achieved by passing ``False`` as the ``add_help=`` argument to :"
"class:`ArgumentParser`::"
msgstr ""
"Ibland kan det vara bra att avaktivera tillägget av detta hjälpalternativ. "
"Detta kan göras genom att ange ``False`` som argument för ``add_help=`` "
"till :class:`ArgumentParser`::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"options:\n"
" --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo hjälp')\n"
">>> parser.print_help()\n"
"användning: PROG [--foo FOO]\n"
"\n"
"alternativ:\n"
" --foo FOO foo hjälp"

msgid ""
"The help option is typically ``-h/--help``. The exception to this is if the "
"``prefix_chars=`` is specified and does not include ``-``, in which case ``-"
"h`` and ``--help`` are not valid options.  In this case, the first character "
"in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"Hjälpalternativet är vanligtvis ``-h/--help``. Undantaget är om "
"``prefix_chars=`` anges och inte inkluderar ``-``, i vilket fall ``-h`` och "
"``--help`` inte är giltiga alternativ.  I detta fall används det första "
"tecknet i ``prefix_chars`` som prefix för hjälpalternativen::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"options:\n"
"  +h, ++help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"användning: PROG [+h]\n"
"\n"
"alternativ:\n"
"  +h, ++help visa detta hjälpmeddelande och avsluta"

msgid "exit_on_error"
msgstr "exit_on_error"

msgid ""
"Normally, when you pass an invalid argument list to the :meth:"
"`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it will "
"print a *message* to :data:`sys.stderr` and exit with a status code of 2."
msgstr ""
"När du skickar en ogiltig argumentlista till metoden :meth:`~ArgumentParser."
"parse_args` i en :class:`ArgumentParser`, skriver den normalt ut ett "
"*meddelande* till :data:`sys.stderr` och avslutas med statuskoden 2."

msgid ""
"If the user would like to catch errors manually, the feature can be enabled "
"by setting ``exit_on_error`` to ``False``::"
msgstr ""
"Om användaren vill fånga upp fel manuellt kan funktionen aktiveras genom att "
"ställa in ``exit_on_error`` till ``False``::"

msgid ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, "
"const=None, default=None, type=<class 'int'>, choices=None, help=None, "
"metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--integers a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Catching an argumentError')\n"
"...\n"
"Catching an argumentError"
msgstr ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, "
"const=None, default=None, type=<class 'int'>, choices=None, help=None, "
"metavar=None)\n"
">>> försök:\n"
"... parser.parse_args('--integers a'.split())\n"
"... except argparse.argumentError:\n"
"... print('Fångar ett argumentfel')\n"
"...\n"
"Fångar upp ett argumentFel"

msgid "suggest_on_error"
msgstr "föreslå_på_fel"

msgid ""
"By default, when a user passes an invalid argument choice or subparser "
"name, :class:`ArgumentParser` will exit with error info and list the "
"permissible argument choices (if specified) or subparser names as part of "
"the error message."
msgstr ""
"Som standard, när en användare skickar ett ogiltigt argumentval eller "
"subparsernamn, kommer :class:`ArgumentParser` att avslutas med "
"felinformation och lista de tillåtna argumentvalen (om de anges) eller "
"subparsernamnen som en del av felmeddelandet."

msgid ""
"If the user would like to enable suggestions for mistyped argument choices "
"and subparser names, the feature can be enabled by setting "
"``suggest_on_error`` to ``True``. Note that this only applies for arguments "
"when the choices specified are strings::"
msgstr ""
"Om användaren vill aktivera förslag för felskrivna argumentval och namn på "
"subparser kan funktionen aktiveras genom att ställa in ```uggest_on_error`` "
"till ``True``. Observera att detta endast gäller för argument när de angivna "
"alternativen är strängar::"

msgid ""
">>> parser = argparse.ArgumentParser(description='Process some integers.',\n"
"                                     suggest_on_error=True)\n"
">>> parser.add_argument('--action', choices=['sum', 'max'])\n"
">>> parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"...                     help='an integer for the accumulator')\n"
">>> parser.parse_args(['--action', 'sumn', 1, 2, 3])\n"
"tester.py: error: argument --action: invalid choice: 'sumn', maybe you meant "
"'sum'? (choose from 'sum', 'max')"
msgstr ""
">>> parser = argparse.ArgumentParser(description='Bearbeta några heltal.',\n"
"                                     suggest_on_error=True)\n"
">>> parser.add_argument('--action', choices=['sum', 'max'])\n"
">>> parser.add_argument('heltal', metavar='N', type=int, nargs='+',\n"
"... help='ett heltal för ackumulatorn')\n"
">>> parser.parse_args(['--action', 'sumn', 1, 2, 3])\n"
"tester.py: error: argument --action: ogiltigt val: 'sumn', du kanske menade "
"'sum'? (välj bland 'sum', 'max')"

msgid ""
"If you're writing code that needs to be compatible with older Python "
"versions and want to opportunistically use ``suggest_on_error`` when it's "
"available, you can set it as an attribute after initializing the parser "
"instead of using the keyword argument::"
msgstr ""
"Om du skriver kod som måste vara kompatibel med äldre Python-versioner och "
"vill använda ``suggest_on_error`` när det är tillgängligt, kan du ställa in "
"det som ett attribut efter initiering av parsern istället för att använda "
"nyckelordsargumentet::"

msgid ""
">>> parser = argparse.ArgumentParser(description='Process some integers.')\n"
">>> parser.suggest_on_error = True"
msgstr ""
">>> parser = argparse.ArgumentParser(description=\"Bearbeta några heltal."
"\")\n"
">>> parser.suggest_on_error = True"

msgid "color"
msgstr "färg"

msgid ""
"By default, the help message is printed in color using `ANSI escape "
"sequences <https://en.wikipedia.org/wiki/ANSI_escape_code>`__. If you want "
"plain text help messages, you can disable this :ref:`in your local "
"environment <using-on-controlling-color>`, or in the argument parser itself "
"by setting ``color`` to ``False``::"
msgstr ""
"Som standard skrivs hjälpmeddelandet ut i färg med hjälp av `ANSI escape-"
"sekvenser &lt;https://en.wikipedia.org/wiki/ANSI_escape_code&gt;`__. Om du "
"vill ha hjälpmeddelanden i klartext kan du inaktivera detta :ref:``i din "
"lokala miljö <using-on-controlling-color>`, eller i själva argumentparsern "
"genom att sätta ``color`` till ``False``::"

msgid ""
">>> parser = argparse.ArgumentParser(description='Process some integers.',\n"
"...                                  color=False)\n"
">>> parser.add_argument('--action', choices=['sum', 'max'])\n"
">>> parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"...                     help='an integer for the accumulator')\n"
">>> parser.parse_args(['--help'])"
msgstr ""
">>> parser = argparse.ArgumentParser(description='Behandla några heltal.',\n"
"... color=False)\n"
">>> parser.add_argument('--action', choices=['sum', 'max'])\n"
">>> parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"... help='ett heltal för ackumulatorn')\n"
">>> parser.parse_args(['--help'])"

msgid "The add_argument() method"
msgstr "Metoden add_argument()"

msgid ""
"Define how a single command-line argument should be parsed.  Each parameter "
"has its own more detailed description below, but in short they are:"
msgstr ""
"Definiera hur ett enskilt kommandoradsargument ska tolkas.  Varje parameter "
"har sin egen mer detaljerade beskrivning nedan, men i korthet är de följande:"

msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. ``'foo'`` "
"or ``'-f', '--foo'``."
msgstr ""
"`namn eller flaggor`_ - Antingen ett namn eller en lista med "
"alternativsträngar, t.ex. ``'foo'`` eller ``'-f', '--foo'``."

msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr ""
"action_ - Den grundläggande typ av åtgärd som ska vidtas när detta argument "
"påträffas på kommandoraden."

msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr "nargs_ - Antalet kommandoradsargument som ska användas."

msgid ""
"const_ - A constant value required by some action_ and nargs_ selections."
msgstr ""
"const_ - Ett konstant värde som krävs för vissa action_- och nargs_-val."

msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr ""
"default_ - Det värde som produceras om argumentet inte finns på "
"kommandoraden och om det inte finns i namnrymdsobjektet."

msgid ""
"type_ - The type to which the command-line argument should be converted."
msgstr "type_ - Den typ som kommandoradsargumentet ska konverteras till."

msgid "choices_ - A sequence of the allowable values for the argument."
msgstr "choices_ - En sekvens av tillåtna värden för argumentet."

msgid ""
"required_ - Whether or not the command-line option may be omitted (optionals "
"only)."
msgstr ""
"required_ - Om kommandoradsalternativet kan utelämnas eller inte (endast "
"optioner)."

msgid "help_ - A brief description of what the argument does."
msgstr "help_ - En kort beskrivning av vad argumentet gör."

msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ - Ett namn för argumentet i användningsmeddelanden."

msgid ""
"dest_ - The name of the attribute to be added to the object returned by :"
"meth:`parse_args`."
msgstr ""
"dest_ - Namnet på det attribut som ska läggas till i det objekt som "
"returneras av :meth:`parse_args`."

msgid "deprecated_ - Whether or not use of the argument is deprecated."
msgstr "deprecated_ - Om användningen av argumentet är föråldrad eller inte."

msgid "name or flags"
msgstr "namn eller flaggor"

msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, like "
"a list of filenames, is expected.  The first arguments passed to :meth:"
"`~ArgumentParser.add_argument` must therefore be either a series of flags, "
"or a simple argument name."
msgstr ""
"Metoden :meth:`~ArgumentParser.add_argument` måste veta om ett valfritt "
"argument, som ``-f`` eller ``--foo``, eller ett positionellt argument, som "
"en lista med filnamn, förväntas.  De första argumenten som skickas till :"
"meth:`~ArgumentParser.add_argument` måste därför vara antingen en serie "
"flaggor eller ett enkelt argumentnamn."

msgid "For example, an optional argument could be created like::"
msgstr "Ett valfritt argument kan t.ex. skapas på följande sätt::"

msgid ">>> parser.add_argument('-f', '--foo')"
msgstr ">>> parser.add_argument('-f', '--foo')"

msgid "while a positional argument could be created like::"
msgstr "medan ett positionellt argument kan skapas som::"

msgid ">>> parser.add_argument('bar')"
msgstr ">>> parser.add_argument('bar')"

msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments will "
"be identified by the ``-`` prefix, and the remaining arguments will be "
"assumed to be positional::"
msgstr ""
"När :meth:`~ArgumentParser.parse_args` anropas kommer valfria argument att "
"identifieras med prefixet ``-``, och de återstående argumenten kommer att "
"antas vara positionella::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.lägg_till_argument('-f', '--foo')\n"
">>> parser.lägg_till_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namnrymd(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"användning: PROG [-h] [-f FOO] bar\n"
"PROG: fel: följande argument krävs: bar"

msgid ""
"By default, :mod:`!argparse` automatically handles the internal naming and "
"display names of arguments, simplifying the process without requiring "
"additional configuration. As such, you do not need to specify the dest_ and "
"metavar_ parameters. The dest_ parameter defaults to the argument name with "
"underscores ``_`` replacing hyphens ``-`` . The metavar_ parameter defaults "
"to the upper-cased name. For example::"
msgstr ""
"Som standard hanterar :mod:`!argparse` automatiskt den interna namngivningen "
"och visningsnamnen för argument, vilket förenklar processen utan att kräva "
"ytterligare konfiguration. Därför behöver du inte ange parametrarna dest_ "
"och metavar_. Parametern dest_ är som standard argumentnamnet med "
"understrykningar ``_`` som ersätter bindestreck ``-`` . Parametern metavar_ "
"använder som standard namnet med versaler. Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo-bar')\n"
">>> parser.parse_args(['--foo-bar', 'FOO-BAR']\n"
"Namespace(foo_bar='FOO-BAR')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo-bar FOO-BAR]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo-bar FOO-BAR"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo-bar')\n"
">>> parser.parse_args(['--foo-bar', 'FOO-BAR']\n"
"Namespace(foo_bar='FOO-BAR')\n"
">>> parser.print_help()\n"
"användning:  [-h] [--foo-bar FOO-BAR]\n"
"\n"
"valfria argument:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" --foo-bar FOO-BAR"

msgid "action"
msgstr "åtgärd"

msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an attribute "
"to the object returned by :meth:`~ArgumentParser.parse_args`.  The "
"``action`` keyword argument specifies how the command-line arguments should "
"be handled. The supplied actions are:"
msgstr ""
":class:`ArgumentParser`-objekt associerar kommandoradsargument med "
"åtgärder.  Dessa åtgärder kan göra nästan vad som helst med de "
"kommandoradsargument som associeras med dem, även om de flesta åtgärder helt "
"enkelt lägger till ett attribut till det objekt som returneras av :meth:"
"`~ArgumentParser.parse_args`.  Nyckelordsargumentet ``action`` anger hur "
"kommandoradsargumenten ska hanteras. De medföljande åtgärderna är:"

msgid ""
"``'store'`` - This just stores the argument's value.  This is the default "
"action."
msgstr ""
"``'store'`` - Detta lagrar bara argumentets värde.  Detta är "
"standardåtgärden."

msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword "
"argument; note that the const_ keyword argument defaults to ``None``.  The "
"``'store_const'`` action is most commonly used with optional arguments that "
"specify some sort of flag.  For example::"
msgstr ""
"``'store_const'`` - Detta lagrar det värde som anges av const_-"
"nyckelordsargumentet; observera att const_-nyckelordsargumentet som standard "
"är ``None``.  Aktionen ``'store_const'`` används oftast med valfria argument "
"som anger någon form av flagga.  Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namnrymd(foo=42)"

msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively::"
msgstr ""
"``'store_true'`` och ``'store_false'`` - Dessa är specialfall av "
"``'store_const'`` som används för att lagra värdena ``True`` respektive "
"``False``.  Dessutom skapar de standardvärden för ``False`` respektive "
"``True``::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namnrymd(foo=True, bar=False, baz=True)"

msgid ""
"``'append'`` - This stores a list, and appends each argument value to the "
"list. It is useful to allow an option to be specified multiple times. If the "
"default value is non-empty, the default elements will be present in the "
"parsed value for the option, with any values from the command line appended "
"after those default values. Example usage::"
msgstr ""
"``'append'`` - Detta lagrar en lista och lägger till varje argumentvärde i "
"listan. Det är användbart för att tillåta att ett alternativ anges flera "
"gånger. Om standardvärdet inte är tomt kommer standardelementen att finnas i "
"det analyserade värdet för alternativet, med eventuella värden från "
"kommandoraden tillagda efter dessa standardvärden. Exempel på användning::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append')\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['1', '2'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append')\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namnrymd(foo=['1', '2'])"

msgid ""
"``'append_const'`` - This stores a list, and appends the value specified by "
"the const_ keyword argument to the list; note that the const_ keyword "
"argument defaults to ``None``. The ``'append_const'`` action is typically "
"useful when multiple arguments need to store constants to the same list. For "
"example::"
msgstr ""
"``'append_const'`` - Detta lagrar en lista och lägger till det värde som "
"anges av const_-nyckelordsargumentet till listan; observera att const_-"
"nyckelordsargumentet som standard är ``None``. Åtgärden ``'append_const'`` "
"är vanligtvis användbar när flera argument behöver lagra konstanter i samma "
"lista. Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', "
"const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', "
"const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', "
"const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', "
"const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namnrymd(types=[<class 'str'>, <class 'int'>])"

msgid ""
"``'extend'`` - This stores a list and appends each item from the multi-value "
"argument list to it. The ``'extend'`` action is typically used with the "
"nargs_ keyword argument value ``'+'`` or ``'*'``. Note that when nargs_ is "
"``None`` (the default) or ``'?'``, each character of the argument string "
"will be appended to the list. Example usage::"
msgstr ""
"``'extend'`` - Detta lagrar en lista och lägger till varje objekt från den "
"flervärdiga argumentlistan till den. Åtgärden ``'extend'`` används "
"vanligtvis med nyckelordet nargs_ med argumentvärdet ``'+'`` eller ``'*'``. "
"Observera att när nargs_ är ``None`` (standard) eller ``'?'``, kommer varje "
"tecken i argumentsträngen att läggas till i listan. Exempel på användning::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", "
"type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", "
"\"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", "
"type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", "
"\"f4\"])\n"
"Namnrymd(foo=['f1', 'f2', 'f3', 'f4'])"

msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. For "
"example, this is useful for increasing verbosity levels::"
msgstr ""
"``'count'`` - Detta räknar antalet gånger ett nyckelordsargument förekommer. "
"Detta är t.ex. användbart för att öka ordrikedomen::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namnrymd(verbose=3)"

msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr ""
"Observera att *standard* kommer att vara ``None`` om det inte uttryckligen "
"sätts till *0*."

msgid ""
"``'help'`` - This prints a complete help message for all the options in the "
"current parser and then exits. By default a help action is automatically "
"added to the parser. See :class:`ArgumentParser` for details of how the "
"output is created."
msgstr ""
"``'help'`` - Detta skriver ut ett komplett hjälpmeddelande för alla "
"alternativ i den aktuella parsern och avslutar sedan. Som standard läggs en "
"hjälpåtgärd automatiskt till i parsern. Se :class:`ArgumentParser` för "
"detaljer om hur utdata skapas."

msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the :meth:"
"`~ArgumentParser.add_argument` call, and prints version information and "
"exits when invoked::"
msgstr ""
"``'version'`` - Detta förväntar sig ett ``version=`` nyckelordsargument i :"
"meth:`~ArgumentParser.add_argument`-anropet, och skriver ut "
"versionsinformation och avslutas när det anropas::"

msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s "
"2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s "
"2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"

msgid ""
"You may also specify an arbitrary action by passing an :class:`Action` "
"subclass (e.g. :class:`BooleanOptionalAction`) or other object that "
"implements the same interface. Only actions that consume command-line "
"arguments (e.g. ``'store'``, ``'append'``, ``'extend'``, or custom actions "
"with non-zero ``nargs``) can be used with positional arguments."
msgstr ""
"Du kan också ange en godtycklig åtgärd genom att skicka en :class:`Action`-"
"underklass (t.ex. :class:`BooleanOptionalAction`) eller ett annat objekt som "
"implementerar samma gränssnitt. Endast åtgärder som använder "
"kommandoradsargument (t.ex. ``'store'``, ``'append'``, ``'extend'`` eller "
"anpassade åtgärder med ``nargs`` som inte är noll) kan användas med "
"positionella argument."

msgid ""
"The recommended way to create a custom action is to extend :class:`Action`, "
"overriding the :meth:`!__call__` method and optionally the :meth:`!__init__` "
"and :meth:`!format_usage` methods. You can also register custom actions "
"using the :meth:`~ArgumentParser.register` method and reference them by "
"their registered name."
msgstr ""
"Det rekommenderade sättet att skapa en anpassad åtgärd är att utöka :class:"
"`Action`, åsidosätta metoden :meth:`!__call__` och eventuellt metoderna :"
"meth:`!__init__` och :meth:`!format_usage`. Du kan också registrera "
"anpassade åtgärder med hjälp av metoden :meth:`~ArgumentParser.register` och "
"referera till dem med deras registrerade namn."

msgid "An example of a custom action::"
msgstr "Ett exempel på en anpassad åtgärd::"

msgid ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"
msgstr ""
">>> klass FooAction(argparse.Action):\n"
"... def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"... om nargs inte är None:\n"
"... raise ValueError(\"nargs är inte tillåtet\")\n"
"... super().__init__(option_strings, dest, **kwargs)\n"
"... def __call__(self, parser, namespace, values, option_string=None):\n"
"... print('%r %r %r' % (namespace, values, option_string))\n"
"... setattr(namespace, self.dest, värden)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"

msgid "For more details, see :class:`Action`."
msgstr "För mer information, se :class:`Action`."

msgid "nargs"
msgstr "nargs"

msgid ""
":class:`ArgumentParser` objects usually associate a single command-line "
"argument with a single action to be taken.  The ``nargs`` keyword argument "
"associates a different number of command-line arguments with a single "
"action. See also :ref:`specifying-ambiguous-arguments`. The supported values "
"are:"
msgstr ""
":class:`ArgumentParser`-objekt associerar vanligtvis ett enda "
"kommandoradsargument med en enda åtgärd som skall vidtas.  "
"Nyckelordsargumentet ``nargs`` associerar ett annat antal "
"kommandoradsargument med en enda åtgärd. Se även :ref:`specifying-ambiguous-"
"arguments`. De värden som stöds är:"

msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be gathered "
"together into a list.  For example::"
msgstr ""
"``N`` (ett heltal).  ``N`` argument från kommandoraden kommer att samlas "
"ihop till en lista.  Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namnrymd(bar=['c'], foo=['a', 'b'])"

msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different from "
"the default, in which the item is produced by itself."
msgstr ""
"Observera att ``nargs=1`` producerar en lista med ett objekt.  Detta skiljer "
"sig från standardinställningen, där varje objekt produceras för sig."

msgid ""
"``'?'``. One argument will be consumed from the command line if possible, "
"and produced as a single item.  If no command-line argument is present, the "
"value from default_ will be produced.  Note that for optional arguments, "
"there is an additional case - the option string is present but not followed "
"by a command-line argument.  In this case the value from const_ will be "
"produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``. Ett argument hämtas från kommandoraden om möjligt och produceras "
"som ett enda objekt.  Om det inte finns något argument på kommandoraden "
"produceras värdet från default_.  Observera att för valfria argument finns "
"det ytterligare ett fall - alternativsträngen finns men följs inte av ett "
"kommandoradsargument.  I detta fall kommer värdet från const_ att "
"produceras.  Några exempel för att illustrera detta::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namnrymd(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namnrymd(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namnområde(bar='d', foo='d')"

msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input and "
"output files::"
msgstr ""
"En av de vanligaste användningarna av ``nargs='?'`` är att tillåta valfria "
"inmatnings- och utdatafiler::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?')\n"
">>> parser.add_argument('outfile', nargs='?')\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namespace(infile='input.txt', outfile='output.txt')\n"
">>> parser.parse_args(['input.txt'])\n"
"Namespace(infile='input.txt', outfile=None)\n"
">>> parser.parse_args([])\n"
"Namespace(infile=None, outfile=None)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?')\n"
">>> parser.add_argument('outfile', nargs='?')\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namnrymd(infile='input.txt', outfile='output.txt')\n"
">>> parser.parse_args(['input.txt'])\n"
"Namespace(infile='input.txt', outfile=None)\n"
">>> parser.parse_args([])\n"
"Namnrymd(infile=None, outfile=None)"

msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  Note "
"that it generally doesn't make much sense to have more than one positional "
"argument with ``nargs='*'``, but multiple optional arguments with "
"``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``.  Alla kommandoradsargument som finns samlas i en lista.  Observera "
"att det i allmänhet inte är särskilt meningsfullt att ha mer än ett "
"positionellt argument med ``nargs='*'``, men det är möjligt att ha flera "
"valfria argument med ``nargs='*'``.  Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"

msgid ""
"``'+'``. Just like ``'*'``, all command-line arguments present are gathered "
"into a list.  Additionally, an error message will be generated if there "
"wasn't at least one command-line argument present.  For example::"
msgstr ""
"``'+'``. Precis som i ``'*'`` samlas alla kommandoradsargument som finns i "
"en lista.  Dessutom genereras ett felmeddelande om det inte fanns minst ett "
"kommandoradsargument.  Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] foo [foo ...]\n"
"PROG: error: the following arguments are required: foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"användning: PROG [-h] foo [foo ...]\n"
"PROG: fel: följande argument krävs: foo"

msgid ""
"If the ``nargs`` keyword argument is not provided, the number of arguments "
"consumed is determined by the action_.  Generally this means a single "
"command-line argument will be consumed and a single item (not a list) will "
"be produced. Actions that do not consume command-line arguments (e.g. "
"``'store_const'``) set ``nargs=0``."
msgstr ""
"Om nyckelordsargumentet ``nargs`` inte anges, bestäms antalet argument som "
"förbrukas av action_.  I allmänhet innebär detta att ett enda "
"kommandoradsargument kommer att förbrukas och ett enda objekt (inte en "
"lista) kommer att produceras. Åtgärder som inte förbrukar "
"kommandoradsargument (t.ex. ``'store_const'``) anger ``nargs=0``."

msgid "const"
msgstr "konst"

msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to "
"hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
"Argumentet ``const`` i :meth:`~ArgumentParser.add_argument` används för att "
"hålla konstanta värden som inte läses från kommandoraden men som krävs för "
"de olika :class:`ArgumentParser`-åtgärderna.  De två vanligaste "
"användningarna av den är:"

msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add "
"the ``const`` value to one of the attributes of the object returned by :meth:"
"`~ArgumentParser.parse_args`. See the action_ description for examples. If "
"``const`` is not provided to :meth:`~ArgumentParser.add_argument`, it will "
"receive a default value of ``None``."
msgstr ""
"När :meth:`~ArgumentParser.add_argument` anropas med "
"``action='store_const'`` eller ``action='append_const'``.  Dessa åtgärder "
"lägger till ``const``-värdet till ett av attributen i objektet som "
"returneras av :meth:`~ArgumentParser.parse_args`. Se beskrivningen av "
"action_ för exempel. Om ``const`` inte anges till :meth:`~ArgumentParser."
"add_argument`, kommer det att få ett standardvärde på ``None``."

msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When "
"parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be assumed "
"to be ``None`` instead.  See the nargs_ description for examples."
msgstr ""
"När :meth:`~ArgumentParser.add_argument` anropas med optionssträngar (som ``-"
"f`` eller ``--foo``) och ``nargs='?'``.  Detta skapar ett valfritt argument "
"som kan följas av noll eller ett kommandoradsargument. Om alternativsträngen "
"påträffas utan något efterföljande kommandoradsargument när kommandoraden "
"analyseras, kommer värdet på ``const`` att antas vara ``None`` istället.  Se "
"nargs_-beskrivningen för exempel."

msgid ""
"``const=None`` by default, including when ``action='append_const'`` or "
"``action='store_const'``."
msgstr ""
"``const=None`` som standard, inklusive när ``action='append_const'`` eller "
"``action='store_const'``."

msgid "default"
msgstr "standard"

msgid ""
"All optional arguments and some positional arguments may be omitted at the "
"command line.  The ``default`` keyword argument of :meth:`~ArgumentParser."
"add_argument`, whose value defaults to ``None``, specifies what value should "
"be used if the command-line argument is not present. For optional arguments, "
"the ``default`` value is used when the option string was not present at the "
"command line::"
msgstr ""
"Alla valfria argument och vissa positionella argument kan utelämnas på "
"kommandoraden.  Nyckelordsargumentet ``default`` i :meth:`~ArgumentParser."
"add_argument`, vars standardvärde är ``None``, anger vilket värde som ska "
"användas om kommandoradsargumentet inte finns med. För valfria argument "
"används ``default``-värdet när alternativsträngen inte fanns på "
"kommandoraden::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namnrymd(foo='2')\n"
">>> parser.parse_args([])\n"
"Namnrymd(foo=42)"

msgid ""
"If the target namespace already has an attribute set, the action *default* "
"will not overwrite it::"
msgstr ""
"Om målnamnrymden redan har en attributuppsättning kommer åtgärden *default* "
"inte att skriva över den::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namnområde(foo=101)"

msgid ""
"If the ``default`` value is a string, the parser parses the value as if it "
"were a command-line argument.  In particular, the parser applies any type_ "
"conversion argument, if provided, before setting the attribute on the :class:"
"`Namespace` return value.  Otherwise, the parser uses the value as is::"
msgstr ""
"Om ``default``-värdet är en sträng, analyserar parsern värdet som om det "
"vore ett kommandoradsargument.  I synnerhet tillämpar parsern ett typ_-"
"konverteringsargument, om det tillhandahålls, innan attributet ställs in på "
"returvärdet för :class:`Namespace`.  Annars använder parsern värdet som det "
"är::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namnrymd(längd=10, bredd=10,5)"

msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr ""
"För positionella argument med nargs_ lika med ``?`` eller ``*`` används "
"``default``-värdet om inget kommandoradsargument fanns::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namnrymd(foo='a')\n"
">>> parser.parse_args([])\n"
"Namnrymd(foo=42)"

msgid ""
"For required_ arguments, the ``default`` value is ignored. For example, this "
"applies to positional arguments with nargs_ values other than ``?`` or "
"``*``, or optional arguments marked as ``required=True``."
msgstr ""
"För obligatoriska_ argument ignoreras ``default``-värdet. Detta gäller t.ex. "
"positionella argument med nargs_-värden andra än ``?`` eller ``*``, eller "
"valfria argument markerade som ``required=True``."

msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if "
"the command-line argument was not present::"
msgstr ""
"Om du anger ``default=argparse.SUPPRESS`` läggs inget attribut till om "
"kommandoradsargumentet inte fanns::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namnrymd()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namnrymd(foo='1')"

msgid "type"
msgstr "typ"

msgid ""
"By default, the parser reads command-line arguments in as simple strings. "
"However, quite often the command-line string should instead be interpreted "
"as another type, such as a :class:`float` or :class:`int`.  The ``type`` "
"keyword for :meth:`~ArgumentParser.add_argument` allows any necessary type-"
"checking and type conversions to be performed."
msgstr ""
"Som standard läser parsern in kommandoradsargument som enkla strängar. Men "
"ofta bör kommandoradssträngen istället tolkas som en annan typ, t.ex. en :"
"class:`float` eller :class:`int`.  Nyckelordet ``type`` för :meth:"
"`~ArgumentParser.add_argument` gör att alla nödvändiga typkontroller och "
"typkonverteringar kan utföras."

msgid ""
"If the type_ keyword is used with the default_ keyword, the type converter "
"is only applied if the default is a string."
msgstr ""
"Om nyckelordet type_ används tillsammans med nyckelordet default_ tillämpas "
"typomvandlaren endast om default är en sträng."

msgid ""
"The argument to ``type`` can be a callable that accepts a single string or "
"the name of a registered type (see :meth:`~ArgumentParser.register`) If the "
"function raises :exc:`ArgumentTypeError`, :exc:`TypeError`, or :exc:"
"`ValueError`, the exception is caught and a nicely formatted error message "
"is displayed. Other exception types are not handled."
msgstr ""
"Argumentet till ``type`` kan vara en callable som accepterar en enda sträng "
"eller namnet på en registrerad typ (se :meth:`~ArgumentParser.register`) Om "
"funktionen ger upphov till :exc:`ArgumentTypeError`, :exc:`TypeError` eller :"
"exc:`ValueError` fångas undantaget upp och ett snyggt formaterat "
"felmeddelande visas. Andra undantagstyper hanteras inte."

msgid "Common built-in types and functions can be used as type converters:"
msgstr "Vanliga inbyggda typer och funktioner kan användas som typomvandlare:"

msgid ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('datapath', type=pathlib.Path)"
msgstr ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('datapath', type=pathlib.Path)"

msgid "User defined functions can be used as well:"
msgstr "Användardefinierade funktioner kan också användas:"

msgid ""
">>> def hyphenated(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(short_title='\"the-tale-of-two-citi')"
msgstr ""
">>> def bindestreck(sträng):\n"
"... return '-'.join([ord[:4] för ord i string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args([''Berättelsen om två städer''])\n"
"Namespace(kort_titel='\"berättelsen-om-två-städer\"')"

msgid ""
"The :func:`bool` function is not recommended as a type converter.  All it "
"does is convert empty strings to ``False`` and non-empty strings to "
"``True``. This is usually not what is desired."
msgstr ""
"Funktionen :func:`bool` rekommenderas inte som typomvandlare.  Allt den gör "
"är att konvertera tomma strängar till ``False`` och icke-tomma strängar till "
"``True``. Detta är vanligtvis inte vad som önskas."

msgid ""
"In general, the ``type`` keyword is a convenience that should only be used "
"for simple conversions that can only raise one of the three supported "
"exceptions. Anything with more interesting error-handling or resource "
"management should be done downstream after the arguments are parsed."
msgstr ""
"I allmänhet är nyckelordet ``type`` en bekvämlighet som bara bör användas "
"för enkla konverteringar som bara kan ge upphov till ett av de tre undantag "
"som stöds. Allt med mer intressant felhantering eller resurshantering bör "
"göras nedströms efter att argumenten har analyserats."

msgid ""
"For example, JSON or YAML conversions have complex error cases that require "
"better reporting than can be given by the ``type`` keyword.  A :exc:`~json."
"JSONDecodeError` would not be well formatted and a :exc:`FileNotFoundError` "
"exception would not be handled at all."
msgstr ""
"Till exempel har JSON- eller YAML-konverteringar komplexa fel som kräver "
"bättre rapportering än vad som kan ges av nyckelordet ``type``.  Ett :exc:"
"`~json.JSONDecodeError` skulle inte vara välformaterat och ett :exc:"
"`FileNotFoundError` undantag skulle inte hanteras alls."

msgid ""
"Even :class:`~argparse.FileType` has its limitations for use with the "
"``type`` keyword.  If one argument uses :class:`~argparse.FileType` and then "
"a subsequent argument fails, an error is reported but the file is not "
"automatically closed.  In this case, it would be better to wait until after "
"the parser has run and then use the :keyword:`with`-statement to manage the "
"files."
msgstr ""
"Även :class:`~argparse.FileType` har sina begränsningar för användning med "
"nyckelordet ``type``.  Om ett argument använder :class:`~argparse.FileType` "
"och sedan ett efterföljande argument misslyckas, rapporteras ett fel men "
"filen stängs inte automatiskt.  I det här fallet är det bättre att vänta "
"tills efter att parsern har körts och sedan använda :keyword:`with`-"
"statement för att hantera filerna."

msgid ""
"For type checkers that simply check against a fixed set of values, consider "
"using the choices_ keyword instead."
msgstr ""
"För typkontrollprogram som bara kontrollerar mot en fast uppsättning värden "
"kan du överväga att använda nyckelordet choices_ i stället."

msgid "choices"
msgstr "val"

msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a sequence object as the *choices* "
"keyword argument to :meth:`~ArgumentParser.add_argument`.  When the command "
"line is parsed, argument values will be checked, and an error message will "
"be displayed if the argument was not one of the acceptable values::"
msgstr ""
"Vissa kommandoradsargument bör väljas från en begränsad uppsättning värden. "
"Dessa kan hanteras genom att skicka ett sequence-objekt som argument för "
"nyckelordet *choices* till :meth:`~ArgumentParser.add_argument`.  När "
"kommandoraden analyseras kontrolleras argumentvärdena och ett felmeddelande "
"visas om argumentet inte var ett av de godtagbara värdena::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',\n"
"'paper', 'scissors')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', val=['sten', 'papper', 'sax'])\n"
">>> parser.parse_args(['rock'])\n"
"Namnrymd(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"användning: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: ogiltigt val: 'fire' (välj från 'rock',\n"
"'papper', 'sax')"

msgid ""
"Note that inclusion in the *choices* sequence is checked after any type_ "
"conversions have been performed, so the type of the objects in the *choices* "
"sequence should match the type_ specified."
msgstr ""
"Observera att inkludering i *choices*-sekvensen kontrolleras efter att "
"eventuella typ_-konverteringar har utförts, så typen av objekten i *choices*-"
"sekvensen bör överensstämma med den typ_ som anges."

msgid ""
"Any sequence can be passed as the *choices* value, so :class:`list` "
"objects, :class:`tuple` objects, and custom sequences are all supported."
msgstr ""
"Vilken sekvens som helst kan skickas som *choices*-värde, så :class:`list`-"
"objekt, :class:`tuple`-objekt och anpassade sekvenser stöds alla."

msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr ""
"Användning av :class:`enum.Enum` rekommenderas inte eftersom det är svårt "
"att kontrollera dess utseende i användnings-, hjälp- och felmeddelanden."

msgid ""
"Formatted choices override the default *metavar* which is normally derived "
"from *dest*.  This is usually what you want because the user never sees the "
"*dest* parameter.  If this display isn't desirable (perhaps because there "
"are many choices), just specify an explicit metavar_."
msgstr ""
"Formaterade val åsidosätter standardvärdet *metavar* som normalt härleds "
"från *dest*.  Detta är vanligtvis vad du vill ha eftersom användaren aldrig "
"ser parametern *dest*.  Om den här visningen inte är önskvärd (kanske för "
"att det finns många valmöjligheter), ange bara en explicit metavar_."

msgid "required"
msgstr "obligatoriskt"

msgid ""
"In general, the :mod:`!argparse` module assumes that flags like ``-f`` and "
"``--bar`` indicate *optional* arguments, which can always be omitted at the "
"command line. To make an option *required*, ``True`` can be specified for "
"the ``required=`` keyword argument to :meth:`~ArgumentParser.add_argument`::"
msgstr ""
"I allmänhet antar modulen :mod:`!argparse` att flaggor som ``-f`` och ``--"
"bar`` anger *valfria* argument, som alltid kan utelämnas på kommandoraden. "
"För att göra ett alternativ *krävt* kan ``True`` anges för "
"nyckelordsargumentet ``required=`` till :meth:`~ArgumentParser."
"add_argument`::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: [-h] --foo FOO\n"
": error: the following arguments are required: --foo"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"användning: [-h] --foo FOO\n"
": fel: följande argument krävs: --foo"

msgid ""
"As the example shows, if an option is marked as ``required``, :meth:"
"`~ArgumentParser.parse_args` will report an error if that option is not "
"present at the command line."
msgstr ""
"Som exemplet visar, om ett alternativ är markerat som ``required``, kommer :"
"meth:`~ArgumentParser.parse_args` att rapportera ett fel om det alternativet "
"inte finns på kommandoraden."

msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when possible."
msgstr ""
"Obligatoriska alternativ anses i allmänhet vara dålig form eftersom "
"användare förväntar sig att *alternativ* ska vara *valbara*, och därför bör "
"de undvikas när det är möjligt."

msgid "help"
msgstr "hjälp"

msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or ``--help`` "
"at the command line), these ``help`` descriptions will be displayed with "
"each argument."
msgstr ""
"Värdet ``help`` är en sträng som innehåller en kort beskrivning av "
"argumentet. När en användare begär hjälp (vanligtvis genom att använda ``-"
"h`` eller ``--help`` på kommandoraden) visas dessa ``help``-beskrivningar "
"för varje argument."

msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The "
"available specifiers include the program name, ``%(prog)s`` and most keyword "
"arguments to :meth:`~ArgumentParser.add_argument`, e.g. ``%(default)s``, "
"``%(type)s``, etc.::"
msgstr ""
"Strängarna ``help`` kan innehålla olika formatspecifikatorer för att undvika "
"upprepning av t.ex. programnamnet eller argumentet default_.  De "
"tillgängliga specifikatorerna inkluderar programnamnet, ``%(prog)s`` och de "
"flesta nyckelordsargument till :meth:`~ArgumentParser.add_argument`, t.ex. "
"``%(default)s``, ``%(type)s``, etc:"

msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: %(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"... help='stapeln till %(prog)s (standard: %(default)s)')\n"
">>> parser.print_help()\n"
"användning: frobble [-h] [bar]\n"
"\n"
"positionella argument:\n"
" bar baren till frobble (standard: 42)\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta"

msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""
"Eftersom hjälpsträngen stöder %-f-matrisering måste du, om du vill att en "
"bokstavlig ``%`` ska visas i hjälpsträngen, escapen den som ``%%``."

msgid ""
":mod:`!argparse` supports silencing the help entry for certain options, by "
"setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`!argparse` stöder att tysta ner hjälptexten för vissa alternativ genom "
"att ställa in värdet ``help`` till ``argparse.SUPPRESS``::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"användning: frobble [-h]\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta"

msgid "metavar"
msgstr "metavar"

msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way to "
"refer to each expected argument.  By default, :class:`!ArgumentParser` "
"objects use the dest_ value as the \"name\" of each object.  By default, for "
"positional argument actions, the dest_ value is used directly, and for "
"optional argument actions, the dest_ value is uppercased.  So, a single "
"positional argument with ``dest='bar'`` will be referred to as ``bar``. A "
"single optional argument ``--foo`` that should be followed by a single "
"command-line argument will be referred to as ``FOO``.  An example::"
msgstr ""
"När :class:`ArgumentParser` genererar hjälpmeddelanden behöver den något "
"sätt att hänvisa till varje förväntat argument.  Som standard använder :"
"class:`!ArgumentParser`-objekt dest_-värdet som \"namn\" för varje objekt.  "
"Som standard används dest_-värdet direkt för åtgärder med positionella "
"argument, och för åtgärder med valfria argument används dest_-värdet med "
"versaler.  Ett enskilt positionellt argument med ``dest='bar'`` kommer "
"alltså att kallas ``bar``. Ett enda valfritt argument ``--foo`` som ska "
"följas av ett enda kommandoradsargument kommer att refereras till som "
"``FOO``.  Ett exempel::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.lägg_till_argument('--foo')\n"
">>> parser.lägg_till_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namnrymd(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"användning:  [-h] [--foo FOO] bar\n"
"\n"
"positionella argument:\n"
" bar\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" --foo FOO"

msgid "An alternative name can be specified with ``metavar``::"
msgstr "Ett alternativt namn kan anges med ``metavar``::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namnrymd(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"användning:  [-h] [--foo YYYY] XXX\n"
"\n"
"positionella argument:\n"
" XXX\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" --foo YYY"

msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the "
"attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"Observera att ``metavar`` endast ändrar det *visade* namnet - attributets "
"namn på :meth:`~ArgumentParser.parse_args`-objektet bestäms fortfarande av "
"dest_-värdet."

msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for "
"each of the arguments::"
msgstr ""
"Olika värden på ``nargs`` kan göra att metavar används flera gånger. Om man "
"ger en tupel till ``metavar`` anges en annan visning för vart och ett av "
"argumenten::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"options:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"användning: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"alternativ:\n"
" -h, --help visa detta hjälpmeddelande och avsluta\n"
" -x X X\n"
" --foo bar baz"

msgid "dest"
msgstr "dest"

msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of the "
"object returned by :meth:`~ArgumentParser.parse_args`.  The name of this "
"attribute is determined by the ``dest`` keyword argument of :meth:"
"`~ArgumentParser.add_argument`.  For positional argument actions, ``dest`` "
"is normally supplied as the first argument to :meth:`~ArgumentParser."
"add_argument`::"
msgstr ""
"De flesta :class:`ArgumentParser`-åtgärder lägger till ett värde som ett "
"attribut för det objekt som returneras av :meth:`~ArgumentParser."
"parse_args`.  Namnet på detta attribut bestäms av nyckelordsargumentet "
"``dest`` i :meth:`~ArgumentParser.add_argument`.  För åtgärder med "
"positionella argument anges ``dest`` normalt som det första argumentet till :"
"meth:`~ArgumentParser.add_argument`::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.lägg_till_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namnrymd(bar='XXX')"

msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred "
"from the option strings.  :class:`ArgumentParser` generates the value of "
"``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest`` "
"will be derived from the first short option string by stripping the initial "
"``-`` character.  Any internal ``-`` characters will be converted to ``_`` "
"characters to make sure the string is a valid attribute name.  The examples "
"below illustrate this behavior::"
msgstr ""
"För valfria argumentåtgärder härleds värdet av ``dest`` normalt från "
"alternativsträngarna. :class:`ArgumentParser` genererar värdet av ``dest`` "
"genom att ta den första långa alternativsträngen och ta bort den inledande "
"``--``-strängen.  Om inga långa alternativsträngar har angetts, kommer "
"``dest`` att härledas från den första korta alternativsträngen genom att ta "
"bort det inledande tecknet ``-``.  Alla interna ``-``-tecken konverteras "
"till ``_``-tecken för att säkerställa att strängen är ett giltigt "
"attributnamn.  Exemplen nedan illustrerar detta beteende::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.lägg_till_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namnrymd(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namnområde(foo_bar='1', x='2')"

msgid "``dest`` allows a custom attribute name to be provided::"
msgstr "``dest`` tillåter att ett anpassat attributnamn anges::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namnrymd(bar='XXX')"

msgid "deprecated"
msgstr "utfasad"

msgid ""
"During a project's lifetime, some arguments may need to be removed from the "
"command line. Before removing them, you should inform your users that the "
"arguments are deprecated and will be removed. The ``deprecated`` keyword "
"argument of :meth:`~ArgumentParser.add_argument`, which defaults to "
"``False``, specifies if the argument is deprecated and will be removed in "
"the future. For arguments, if ``deprecated`` is ``True``, then a warning "
"will be printed to :data:`sys.stderr` when the argument is used::"
msgstr ""
"Under ett projekts livstid kan vissa argument behöva tas bort från "
"kommandoraden. Innan du tar bort dem bör du informera dina användare om att "
"argumenten är föråldrade och kommer att tas bort. Nyckelordsargumentet "
"``deprecated`` i :meth:`~ArgumentParser.add_argument`, som har ``False`` som "
"standard, anger om argumentet är föråldrat och kommer att tas bort i "
"framtiden. För argument, om ``deprecated`` är ``True``, kommer en varning "
"att skrivas ut till :data:`sys.stderr` när argumentet används::"

msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='snake.py')\n"
">>> parser.add_argument('--legs', default=0, type=int, deprecated=True)\n"
">>> parser.parse_args([])\n"
"Namespace(legs=0)\n"
">>> parser.parse_args(['--legs', '4'])\n"
"snake.py: warning: option '--legs' is deprecated\n"
"Namespace(legs=4)"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='snake.py')\n"
">>> parser.add_argument('--legs', default=0, type=int, deprecated=True)\n"
">>> parser.parse_args([])\n"
"Namnområde(ben=0)\n"
">>> parser.parse_args(['--legs', '4'])\n"
"snake.py: varning: alternativet '--legs' är föråldrat\n"
"Namnrymd(ben=4)"

msgid "Action classes"
msgstr "Åtgärdsklasser"

msgid ""
":class:`!Action` classes implement the Action API, a callable which returns "
"a callable which processes arguments from the command-line. Any object which "
"follows this API may be passed as the ``action`` parameter to :meth:"
"`~ArgumentParser.add_argument`."
msgstr ""
":class:`!Action`-klasser implementerar Action API, en anropsbar som "
"returnerar en anropsbar som bearbetar argument från kommandoraden. Alla "
"objekt som följer detta API kan skickas som parametern ``action`` till :meth:"
"`~ArgumentParser.add_argument`."

msgid ""
":class:`!Action` objects are used by an :class:`ArgumentParser` to represent "
"the information needed to parse a single argument from one or more strings "
"from the command line. The :class:`!Action` class must accept the two "
"positional arguments plus any keyword arguments passed to :meth:"
"`ArgumentParser.add_argument` except for the ``action`` itself."
msgstr ""
":class:`!Action`-objekt används av en :class:`ArgumentParser` för att "
"representera den information som behövs för att analysera ett enda argument "
"från en eller flera strängar från kommandoraden. Klassen :class:`!Action` "
"måste acceptera de två positionella argumenten plus alla nyckelordsargument "
"som skickas till :meth:`ArgumentParser.add_argument` förutom själva "
"``action``."

msgid ""
"Instances of :class:`!Action` (or return value of any callable to the "
"``action`` parameter) should have attributes :attr:`!dest`, :attr:`!"
"option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!required`, :attr:`!"
"help`, etc. defined. The easiest way to ensure these attributes are defined "
"is to call :meth:`!Action.__init__`."
msgstr ""
"Instanser av :class:`!Action` (eller returvärdet av en anropbar till "
"parametern ``action``) bör ha attributen :attr:`!dest`, :attr:`!"
"option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!required`, :attr:`!"
"help`, etc. definierade. Det enklaste sättet att säkerställa att dessa "
"attribut är definierade är att anropa :meth:`!Action.__init__`."

msgid ""
":class:`!Action` instances should be callable, so subclasses must override "
"the :meth:`!__call__` method, which should accept four parameters:"
msgstr ""
":class:`!Action`-instanser ska vara anropsbara, så underklasser måste "
"åsidosätta :meth:`!__call__`-metoden, som ska acceptera fyra parametrar:"

msgid ""
"*parser* - The :class:`ArgumentParser` object which contains this action."
msgstr ""
"*parser* - Det :class:`ArgumentParser`-objekt som innehåller denna åtgärd."

msgid ""
"*namespace* - The :class:`Namespace` object that will be returned by :meth:"
"`~ArgumentParser.parse_args`.  Most actions add an attribute to this object "
"using :func:`setattr`."
msgstr ""
"*namespace* - Det :class:`Namespace`-objekt som kommer att returneras av :"
"meth:`~ArgumentParser.parse_args`.  De flesta åtgärder lägger till ett "
"attribut till detta objekt med hjälp av :func:`setattr`."

msgid ""
"*values* - The associated command-line arguments, with any type conversions "
"applied.  Type conversions are specified with the type_ keyword argument to :"
"meth:`~ArgumentParser.add_argument`."
msgstr ""
"*values* - De associerade kommandoradsargumenten, med eventuella "
"typkonverteringar tillämpade.  Typkonverteringar anges med "
"nyckelordsargumentet type_ till :meth:`~ArgumentParser.add_argument`."

msgid ""
"*option_string* - The option string that was used to invoke this action. The "
"``option_string`` argument is optional, and will be absent if the action is "
"associated with a positional argument."
msgstr ""
"*option_string* - Den alternativsträng som användes för att anropa denna "
"åtgärd. Argumentet ``option_string`` är valfritt och saknas om åtgärden "
"associeras med ett positionellt argument."

msgid ""
"The :meth:`!__call__` method may perform arbitrary actions, but will "
"typically set attributes on the ``namespace`` based on ``dest`` and "
"``values``."
msgstr ""
"Metoden :meth:`!__call__` kan utföra godtyckliga åtgärder, men kommer "
"vanligtvis att ställa in attribut på ``namespace`` baserat på ``dest`` och "
"``values``."

msgid ""
":class:`!Action` subclasses can define a :meth:`!format_usage` method that "
"takes no argument and return a string which will be used when printing the "
"usage of the program. If such method is not provided, a sensible default "
"will be used."
msgstr ""
":class:`!Action` subklasser kan definiera en :meth:`!format_usage` metod som "
"inte tar något argument och returnerar en sträng som kommer att användas vid "
"utskrift av programmets användning. Om en sådan metod inte tillhandahålls "
"kommer en förnuftig standard att användas."

msgid ""
"A subclass of :class:`Action` for handling boolean flags with positive and "
"negative options. Adding a single argument such as ``--foo`` automatically "
"creates both ``--foo`` and ``--no-foo`` options, storing ``True`` and "
"``False`` respectively::"
msgstr ""
"En subklass av :class:`Action` för hantering av booleska flaggor med "
"positiva och negativa alternativ. Genom att lägga till ett enda argument som "
"``--foo`` skapas automatiskt både ``--foo`` och ``--no-foo`` alternativ, som "
"lagrar ``True`` respektive ``False``::"

msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namnrymd(foo=False)"

msgid "The parse_args() method"
msgstr "Metoden parse_args()"

msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr ""
"Konverterar argumentsträngar till objekt och tilldelar dem som attribut för "
"namnrymden.  Returnera det ifyllda namnområdet."

msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are "
"created and how they are assigned. See the documentation for :meth:`!"
"add_argument` for details."
msgstr ""
"Tidigare anrop till :meth:`add_argument` avgör exakt vilka objekt som skapas "
"och hur de tilldelas. Se dokumentationen för :meth:`!add_argument` för mer "
"information."

msgid ""
"args_ - List of strings to parse.  The default is taken from :data:`sys."
"argv`."
msgstr ""
"args_ - Lista över strängar som ska analyseras.  Standardvärdet hämtas från :"
"data:`sys.argv`."

msgid ""
"namespace_ - An object to take the attributes.  The default is a new empty :"
"class:`Namespace` object."
msgstr ""
"namespace_ - Ett objekt som tar emot attributen.  Standard är ett nytt tomt :"
"class:`Namespace`-objekt."

msgid "Option value syntax"
msgstr "Syntax för optionsvärde"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest case, "
"the option and its value are passed as two separate arguments::"
msgstr ""
"Metoden :meth:`~ArgumentParser.parse_args` stöder flera sätt att ange värdet "
"på ett alternativ (om det tar ett sådant).  I det enklaste fallet skickas "
"alternativet och dess värde som två separata argument::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.lägg_till_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namnrymd(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namnrymd(foo='FOO', x=None)"

msgid ""
"For long options (options with names longer than a single character), the "
"option and value can also be passed as a single command-line argument, using "
"``=`` to separate them::"
msgstr ""
"För långa alternativ (alternativ med namn som är längre än ett enda tecken) "
"kan alternativet och värdet också skickas som ett enda argument på "
"kommandoraden, med ``=`` för att separera dem::"

msgid ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namnrymd(foo='FOO', x=None)"

msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr ""
"För korta alternativ (alternativ som bara är ett tecken långa) kan "
"alternativet och dess värde sammankopplas::"

msgid ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"
msgstr ""
">>> parser.parse_args(['-xX'])\n"
"Namnrymd(foo=None, x='X')"

msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a value::"
msgstr ""
"Flera korta alternativ kan sammanfogas med hjälp av ett enda prefix ``-``, "
"så länge som endast det sista alternativet (eller inget av dem) kräver ett "
"värde::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namnrymd(x=True, y=True, z='Z')"

msgid "Invalid arguments"
msgstr "Ogiltiga argument"

msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks "
"for a variety of errors, including ambiguous options, invalid types, invalid "
"options, wrong number of positional arguments, etc.  When it encounters such "
"an error, it exits and prints the error along with a usage message::"
msgstr ""
"När kommandoraden analyseras kontrollerar :meth:`~ArgumentParser.parse_args` "
"en mängd olika fel, inklusive tvetydiga alternativ, ogiltiga typer, ogiltiga "
"alternativ, fel antal positionella argument, etc.  När den stöter på ett "
"sådant fel avslutas den och skriver ut felet tillsammans med ett "
"användningsmeddelande::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.lägg_till_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # ogiltig typ\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"användning: PROG [-h] [--foo FOO] [bar]\n"
"PROG: fel: argument --foo: ogiltigt int-värde: 'spam'\n"
"\n"
">>> # ogiltigt alternativ\n"
">>> parser.parse_args(['--bar'])\n"
"användning: PROG [-h] [--foo FOO] [bar]\n"
"PROG: fel: inget sådant alternativ: --bar\n"
"\n"
">>> # fel antal argument\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"användning: PROG [-h] [--foo FOO] [bar]\n"
"PROG: fel: extra argument hittades: badger"

msgid "Arguments containing ``-``"
msgstr "Argument som innehåller ``-``"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` could "
"either be an attempt to specify an option or an attempt to provide a "
"positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they look "
"like negative numbers and there are no options in the parser that look like "
"negative numbers::"
msgstr ""
"Metoden :meth:`~ArgumentParser.parse_args` försöker ge felmeddelanden när "
"det är uppenbart att användaren har gjort ett misstag, men vissa situationer "
"är i sig tvetydiga.  Till exempel kan kommandoradsargumentet ``-1`` antingen "
"vara ett försök att ange ett alternativ eller ett försök att ange ett "
"positionsargument. Metoden :meth:`~ArgumentParser.parse_args` är försiktig "
"här: positionella argument får endast börja med ``-`` om de ser ut som "
"negativa tal och det inte finns några alternativ i parsern som ser ut som "
"negativa tal::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # no negative number options, so -1 is a positional argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # no negative number options, so -1 and -5 are positional arguments\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # negative number options present, so -1 is an option\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # negative number options present, so -2 is an option\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # negative number options present, so both -1s are options\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.lägg_till_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # inga negativa talalternativ, så -1 är ett positionellt argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namnrymd(foo=None, x='-1')\n"
"\n"
">>> # inga negativa talalternativ, så -1 och -5 är positionella argument\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # alternativ för negativa tal finns, så -1 är ett alternativ\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namnrymd(foo=None, one='X')\n"
"\n"
">>> # alternativ för negativa tal finns, så -2 är ett alternativ\n"
">>> parser.parse_args(['-2'])\n"
"användning: PROG [-h] [-1 ONE] [foo]\n"
"PROG: fel: inget sådant alternativ: -2\n"
"\n"
">>> # negativt antal alternativ närvarande, så båda -1 är alternativ\n"
">>> parser.parse_args(['-1', '-1'])\n"
"användning: PROG [-h] [-1 ONE] [foo]\n"
"PROG: fel: argument -1: förväntat ett argument"

msgid ""
"If you have positional arguments that must begin with ``-`` and don't look "
"like negative numbers, you can insert the pseudo-argument ``'--'`` which "
"tells :meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""
"Om du har positionella argument som måste börja med ``-`` och inte ser ut "
"som negativa tal, kan du infoga pseudoargumentet ``'--'`` som talar om för :"
"meth:`~ArgumentParser.parse_args` att allt efter det är ett positionellt "
"argument::"

msgid ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"
msgstr ""
">>> parser.parse_args(['--', '-f'])\n"
"Namnrymd(foo='-f', one=None)"

msgid ""
"See also :ref:`the argparse howto on ambiguous arguments <specifying-"
"ambiguous-arguments>` for more details."
msgstr ""
"Se även :ref:`the argparse howto on ambiguous arguments <specifying-"
"ambiguous-arguments>` för mer information."

msgid "Argument abbreviations (prefix matching)"
msgstr "Argumentförkortningar (prefixmatchning)"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the "
"abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""
"Metoden :meth:`~ArgumentParser.parse_args` :ref:``by default <allow_abbrev>` "
"tillåter att långa alternativ förkortas till ett prefix, om förkortningen är "
"otvetydig (prefixet matchar ett unikt alternativ)::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.lägg_till_argument('-bacon')\n"
">>> parser.lägg_till_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namnrymd(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namnrymd(bacon=None, grävling='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"användning: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: fel: tvetydigt alternativ: -ba kan matcha -badger, -bacon"

msgid ""
"An error is produced for arguments that could produce more than one options. "
"This feature can be disabled by setting :ref:`allow_abbrev` to ``False``."
msgstr ""
"Ett felmeddelande visas för argument som kan ge mer än ett alternativ. Denna "
"funktion kan avaktiveras genom att ställa in :ref:`allow_abbrev` till "
"``False``."

msgid "Beyond ``sys.argv``"
msgstr "Bortom ``sys.argv``"

msgid ""
"Sometimes it may be useful to have an :class:`ArgumentParser` parse "
"arguments other than those of :data:`sys.argv`.  This can be accomplished by "
"passing a list of strings to :meth:`~ArgumentParser.parse_args`.  This is "
"useful for testing at the interactive prompt::"
msgstr ""
"Ibland kan det vara användbart att låta en :class:`ArgumentParser` analysera "
"andra argument än de som finns i :data:`sys.argv`.  Detta kan åstadkommas "
"genom att skicka en lista med strängar till :meth:`~ArgumentParser."
"parse_args`.  Detta är användbart för att testa vid den interaktiva "
"prompten::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"
msgstr ""
"&gt;&gt;&gt; parser = argparse.ArgumentParser()\n"
"&gt;&gt;&gt; parser.lägg_till_argument(\n"
"...     'heltal', metavar='int', type=int, choices=intervall(10),\n"
"... nargs='+', help='ett heltal i intervallet 0..9')\n"
"&gt;&gt;&gt; parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"... default=max, help='summera heltalen (default: hitta max)')\n"
"&gt;&gt;&gt; parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(ackumulera=<built-in function max>, heltal=[1, 2, 3, 4])\n"
"&gt;&gt;&gt; parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(ackumulera=<built-in function sum>, heltal=[1, 2, 3, 4])"

msgid "The Namespace object"
msgstr "Namespace-objektet"

msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to create "
"an object holding attributes and return it."
msgstr ""
"Enkel klass som används som standard av :meth:`~ArgumentParser.parse_args` "
"för att skapa ett objekt som innehåller attribut och returnera det."

msgid ""
"This class is deliberately simple, just an :class:`object` subclass with a "
"readable string representation. If you prefer to have dict-like view of the "
"attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""
"Den här klassen är avsiktligt enkel, bara en :class:`object`-underklass med "
"en läsbar strängrepresentation. Om du föredrar att ha en diktliknande vy "
"över attributen kan du använda Pythons standardidiom, :func:`vars`::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.lägg_till_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"

msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign attributes "
"to an already existing object, rather than a new :class:`Namespace` object.  "
"This can be achieved by specifying the ``namespace=`` keyword argument::"
msgstr ""
"Det kan också vara användbart att låta en :class:`ArgumentParser` tilldela "
"attribut till ett redan existerande objekt, snarare än ett nytt :class:"
"`Namespace`-objekt.  Detta kan uppnås genom att ange nyckelordet "
"``namespace=`` argument::"

msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"
msgstr ""
">>> klass C:\n"
"... pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"

msgid "Other utilities"
msgstr "Andra verktyg"

msgid "Sub-commands"
msgstr "Underkommandon"

msgid ""
"Many programs split up their functionality into a number of subcommands, for "
"example, the ``svn`` program can invoke subcommands like ``svn checkout``, "
"``svn update``, and ``svn commit``.  Splitting up functionality this way can "
"be a particularly good idea when a program performs several different "
"functions which require different kinds of command-line arguments. :class:"
"`ArgumentParser` supports the creation of such subcommands with the :meth:`!"
"add_subparsers` method.  The :meth:`!add_subparsers` method is normally "
"called with no arguments and returns a special action object.  This object "
"has a single method, :meth:`~_SubParsersAction.add_parser`, which takes a "
"command name and any :class:`!ArgumentParser` constructor arguments, and "
"returns an :class:`!ArgumentParser` object that can be modified as usual."
msgstr ""
"Många program delar upp sin funktionalitet i ett antal underkommandon, till "
"exempel kan programmet ```svn`` anropa underkommandon som ```svn checkout``, "
"``vn update`` och ``vn commit``.  Att dela upp funktionalitet på det här "
"sättet kan vara en särskilt bra idé när ett program utför flera olika "
"funktioner som kräver olika typer av kommandoradsargument. :class:"
"`ArgumentParser` stöder skapandet av sådana underkommandon med metoden :meth:"
"`!add_subparsers`.  Metoden :meth:`!add_subparsers` anropas normalt utan "
"argument och returnerar ett speciellt action-objekt.  Detta objekt har en "
"enda metod, :meth:`~_SubParsersAction.add_parser`, som tar ett kommandonamn "
"och eventuella :class:`!ArgumentParser`-konstruktorargument, och returnerar "
"ett :class:`!ArgumentParser`-objekt som kan modifieras som vanligt."

msgid "Description of parameters:"
msgstr "Beskrivning av parametrar:"

msgid ""
"*title* - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""
"*title* - titel för sub-parser-gruppen i hjälputmatningen; standard är "
"\"subcommands\" om beskrivning anges, annars används titel för "
"positionsargument"

msgid ""
"*description* - description for the sub-parser group in help output, by "
"default ``None``"
msgstr ""
"*description* - beskrivning för sub-parser-gruppen i hjälputdata, standard "
"``None``"

msgid ""
"*prog* - usage information that will be displayed with sub-command help, by "
"default the name of the program and any positional arguments before the "
"subparser argument"
msgstr ""
"*prog* - användningsinformation som kommer att visas med hjälp för "
"underkommandon, som standard namnet på programmet och eventuella "
"positionsargument före subparser-argumentet"

msgid ""
"*parser_class* - class which will be used to create sub-parser instances, by "
"default the class of the current parser (e.g. :class:`ArgumentParser`)"
msgstr ""
"*parser_class* - klass som kommer att användas för att skapa sub-parser-"
"instanser, som standard klassen för den aktuella parsern (t.ex. :class:"
"`ArgumentParser`)"

msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr ""
"action_ - den grundläggande typ av åtgärd som ska vidtas när detta argument "
"påträffas på kommandoraden"

msgid ""
"dest_ - name of the attribute under which sub-command name will be stored; "
"by default ``None`` and no value is stored"
msgstr ""
"dest_ - namnet på det attribut under vilket namnet på underkommandot lagras; "
"som standard ``None`` och inget värde lagras"

msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr ""
"required_ - Huruvida ett underkommando måste anges eller inte, som standard "
"``False`` (tillagd i 3.7)"

msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr ""
"help_ - hjälp för sub-parser-gruppen i hjälputmatningen, som standard "
"``None``"

msgid ""
"metavar_ - string presenting available subcommands in help; by default it is "
"``None`` and presents subcommands in form {cmd1, cmd2, ..}"
msgstr ""
"metavar_ - sträng som presenterar tillgängliga underkommandon i hjälpen; som "
"standard är den ``None`` och presenterar underkommandon i form {cmd1, "
"cmd2, ..}"

msgid "Some example usage::"
msgstr "Några exempel på användning::"

msgid ""
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='subcommand help')\n"
">>>\n"
">>> # create the parser for the \"a\" command\n"
">>> parser_a = subparsers.add_parser('a', help='a help')\n"
">>> parser_a.add_argument('bar', type=int, help='bar help')\n"
">>>\n"
">>> # create the parser for the \"b\" command\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz "
"help')\n"
">>>\n"
">>> # parse some argument lists\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"
msgstr ""
">>> # skapa parsern på högsta nivån\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='underkommandohjälp')\n"
">>>\n"
">>> # skapa parsern för kommandot \"a\"\n"
">>> parser_a = subparsers.add_parser('a', help='a hjälp')\n"
">>> parser_a.add_argument('bar', type=int, help='bar hjälp')\n"
">>>\n"
">>> # skapa parsern för kommandot \"b\"\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz "
"help')\n"
">>>\n"
">>> # analysera några argumentlistor\n"
">>> parser.parse_args(['a', '12'])\n"
"Namnrymd(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namnrymd(baz='Z', foo=True)"

msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the "
"command line (and not any other subparsers).  So in the example above, when "
"the ``a`` command is specified, only the ``foo`` and ``bar`` attributes are "
"present, and when the ``b`` command is specified, only the ``foo`` and "
"``baz`` attributes are present."
msgstr ""
"Observera att det objekt som returneras av :meth:`parse_args` endast "
"innehåller attribut för huvudparsern och den underparser som valdes på "
"kommandoraden (och inte några andra underparsers).  Så i exemplet ovan, när "
"kommandot ``a`` anges, är det bara attributen ``foo`` och ``bar`` som finns, "
"och när kommandot ``b`` anges, är det bara attributen ``foo`` och ``baz`` "
"som finns."

msgid ""
"Similarly, when a help message is requested from a subparser, only the help "
"for that particular parser will be printed.  The help message will not "
"include parent parser or sibling parser messages.  (A help message for each "
"subparser command, however, can be given by supplying the ``help=`` argument "
"to :meth:`~_SubParsersAction.add_parser` as above.)"
msgstr ""
"På samma sätt gäller att när ett hjälpmeddelande begärs från en subparser, "
"skrivs endast hjälpen för den aktuella parsern ut.  Hjälpmeddelandet "
"innehåller inte meddelanden från den överordnade parsern eller "
"syskonparsern.  (Ett hjälpmeddelande för varje subparser-kommando kan dock "
"ges genom att ange argumentet ``help=`` till :meth:`~_SubParsersAction."
"add_parser` enligt ovan)"

msgid ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   subcommand help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"
msgstr ""
">>> parser.parse_args(['--help'])\n"
"användning: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positionella argument:\n"
"  {a,b} underkommando hjälp\n"
"    a a hjälp\n"
"    b b hjälp\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  --foo foo hjälp\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"användning: PROG a [-h] bar\n"
"\n"
"positionella argument:\n"
"  bar bar hjälp\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"användning: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  --baz {X,Y,Z} baz hjälp"

msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the subparser's "
"commands will appear in their own group in the help output.  For example::"
msgstr ""
"Metoden :meth:`add_subparsers` har även stöd för nyckelordsargumenten "
"``title`` och ``description``.  När något av dem finns med visas kommandona "
"för underparsaren i en egen grupp i hjälputmatningen.  Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='underkommandon',\n"
"... description='giltiga underkommandon',\n"
"... help='ytterligare hjälp')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"användning:  [-h] {foo,bar} ...\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"\n"
"underkommandon:\n"
"  giltiga underkommandon\n"
"\n"
"  {foo,bar} ytterligare hjälp"

msgid ""
"Furthermore, :meth:`~_SubParsersAction.add_parser` supports an additional "
"*aliases* argument, which allows multiple strings to refer to the same "
"subparser. This example, like ``svn``, aliases ``co`` as a shorthand for "
"``checkout``::"
msgstr ""
"Dessutom stöder :meth:`~_SubParsersAction.add_parser` ett ytterligare "
"*aliases*-argument, vilket gör att flera strängar kan referera till samma "
"subparser. Detta exempel, liksom ```svn``, alias ``co`` som en förkortning "
"för ``checkout``::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', alias=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namnrymd(foo='bar')"

msgid ""
":meth:`~_SubParsersAction.add_parser` supports also an additional "
"*deprecated* argument, which allows to deprecate the subparser."
msgstr ""
":meth:`~_SubParsersAction.add_parser` stöder också ett ytterligare "
"*deprecated*-argument, som gör det möjligt att depreciera subparsern."

msgid ""
"One particularly effective way of handling subcommands is to combine the use "
"of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` so "
"that each subparser knows which Python function it should execute.  For "
"example::"
msgstr ""
"Ett särskilt effektivt sätt att hantera underkommandon är att kombinera "
"användningen av metoden :meth:`add_subparsers` med anrop till :meth:"
"`set_defaults` så att varje subparser vet vilken Python-funktion den ska "
"utföra.  Till exempel::"

msgid ""
">>> # subcommand functions\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # create the parser for the \"foo\" command\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # create the parser for the \"bar\" command\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"
msgstr ""
">>> # funktioner för underkommandon\n"
">>> def foo(args):\n"
"... print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"... print('((%s))' % args.z)\n"
"...\n"
">>> # skapa parsern på högsta nivån\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # skapa parsern för kommandot \"foo\"\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # skapa parsern för kommandot \"bar\"\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # analysera args och anropa den funktion som valdes\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # analysera args och anropa den funktion som valdes\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"

msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle the "
"different actions for each of your subparsers.  However, if it is necessary "
"to check the name of the subparser that was invoked, the ``dest`` keyword "
"argument to the :meth:`add_subparsers` call will work::"
msgstr ""
"På så sätt kan du låta :meth:`parse_args` göra jobbet att anropa lämplig "
"funktion efter att parsningen av argumenten är klar.  Att associera "
"funktioner med åtgärder på det här sättet är vanligtvis det enklaste sättet "
"att hantera olika åtgärder för var och en av dina subparsers.  Men om det är "
"nödvändigt att kontrollera namnet på den subparsare som anropades, fungerar "
"nyckelordsargumentet ``dest`` till :meth:`add_subparsers`-anropet::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namnrymd(subparser_name='2', y='frobble')"

msgid "New *required* keyword-only parameter."
msgstr "Ny *krävd* parameter som endast innehåller nyckelord."

msgid ""
"Subparser's *prog* is no longer affected by a custom usage message in the "
"main parser."
msgstr ""
"Subparsers *prog* påverkas inte längre av ett anpassat användningsmeddelande "
"i huvudparsern."

msgid "FileType objects"
msgstr "FileType-objekt"

msgid ""
"The :class:`FileType` factory creates objects that can be passed to the type "
"argument of :meth:`ArgumentParser.add_argument`.  Arguments that have :class:"
"`FileType` objects as their type will open command-line arguments as files "
"with the requested modes, buffer sizes, encodings and error handling (see "
"the :func:`open` function for more details)::"
msgstr ""
"Fabriken :class:`FileType` skapar objekt som kan skickas till typargumentet "
"i :meth:`ArgumentParser.add_argument`.  Argument som har :class:`FileType`-"
"objekt som typ kommer att öppna kommandoradsargument som filer med de "
"begärda lägena, buffertstorlekarna, kodningarna och felhanteringen (se "
"funktionen :func:`open` för mer information)::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, "
"raw=<_io.FileIO name='raw.dat' mode='wb'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, "
"raw=<_io.FileIO name='raw.dat' mode='wb'>)"

msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically "
"convert this into :data:`sys.stdin` for readable :class:`FileType` objects "
"and :data:`sys.stdout` for writable :class:`FileType` objects::"
msgstr ""
"FileType-objekt förstår pseudoargumentet ``'-'`` och konverterar detta "
"automatiskt till :data:`sys.stdin` för läsbara :class:`FileType`-objekt och :"
"data:`sys.stdout` för skrivbara :class:`FileType`-objekt::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"
msgstr ""
"&gt;&gt;&gt; parser = argparse.ArgumentParser()\n"
"&gt;&gt;&gt; parser.add_argument('infile', type=argparse.FileType('r'))\n"
"&gt;&gt;&gt; parser.parse_args(['-'])\n"
"Namnrymd(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"

msgid ""
"If one argument uses *FileType* and then a subsequent argument fails, an "
"error is reported but the file is not automatically closed. This can also "
"clobber the output files. In this case, it would be better to wait until "
"after the parser has run and then use the :keyword:`with`-statement to "
"manage the files."
msgstr ""
"Om ett argument använder *FileType* och ett efterföljande argument "
"misslyckas, rapporteras ett fel men filen stängs inte automatiskt. Detta kan "
"också förstöra utdatafilerna. I det här fallet är det bättre att vänta tills "
"parsern har körts och sedan använda :keyword:`with`-statement för att "
"hantera filerna."

msgid "Added the *encodings* and *errors* parameters."
msgstr "Parametrarna *encodings* och *errors* har lagts till."

msgid "Argument groups"
msgstr "Argumentgrupper"

msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"options\" when displaying help messages. When "
"there is a better conceptual grouping of arguments than this default one, "
"appropriate groups can be created using the :meth:`!add_argument_group` "
"method::"
msgstr ""
"Som standard grupperar :class:`ArgumentParser` kommandoradsargument i "
"\"positionella argument\" och \"alternativ\" när hjälpmeddelanden visas. När "
"det finns en bättre konceptuell gruppering av argument än denna "
"standardgruppering kan lämpliga grupper skapas med hjälp av metoden :meth:`!"
"add_argument_group`::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo hjälp')\n"
">>> group.add_argument('bar', help='bar hjälp')\n"
">>> parser.print_help()\n"
"användning: PROG [--foo FOO] bar\n"
"\n"
"grupp:\n"
"  bar bar hjälp\n"
"  --foo FOO foo hjälp"

msgid ""
"The :meth:`add_argument_group` method returns an argument group object which "
"has an :meth:`~ArgumentParser.add_argument` method just like a regular :"
"class:`ArgumentParser`.  When an argument is added to the group, the parser "
"treats it just like a normal argument, but displays the argument in a "
"separate group for help messages.  The :meth:`!add_argument_group` method "
"accepts *title* and *description* arguments which can be used to customize "
"this display::"
msgstr ""
"Metoden :meth:`add_argument_group` returnerar ett argumentgruppsobjekt som "
"har en metod :meth:`~ArgumentParser.add_argument` precis som en vanlig :"
"class:`ArgumentParser`.  När ett argument läggs till i gruppen behandlar "
"parsern det precis som ett vanligt argument, men visar argumentet i en "
"separat grupp för hjälpmeddelanden.  Metoden :meth:`!add_argument_group` "
"accepterar argumenten *title* och *description* som kan användas för att "
"anpassa denna visning::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 beskrivning')\n"
">>> group1.add_argument('foo', help='foo hjälp')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar hjälp')\n"
">>> parser.print_help()\n"
"användning: PROG [--bar BAR] foo\n"
"\n"
"grupp1:\n"
"  grupp1 beskrivning\n"
"\n"
"  foo foo hjälp\n"
"\n"
"grupp2 beskrivning\n"
"  grupp2 beskrivning\n"
"\n"
"  --bar BAR BAR bar hjälp"

msgid ""
"The optional, keyword-only parameters argument_default_ and "
"conflict_handler_ allow for finer-grained control of the behavior of the "
"argument group. These parameters have the same meaning as in the :class:"
"`ArgumentParser` constructor, but apply specifically to the argument group "
"rather than the entire parser."
msgstr ""
"De valfria parametrarna argument_default_ och conflict_handler_, som endast "
"innehåller nyckelord, ger möjlighet till mer detaljerad kontroll av "
"argumentgruppens beteende. Dessa parametrar har samma betydelse som i :class:"
"`ArgumentParser`-konstruktören, men gäller specifikt för argumentgruppen "
"snarare än för hela parsern."

msgid ""
"Note that any arguments not in your user-defined groups will end up back in "
"the usual \"positional arguments\" and \"optional arguments\" sections."
msgstr ""
"Observera att alla argument som inte finns i dina användardefinierade "
"grupper hamnar tillbaka i de vanliga avsnitten \"positionella argument\" och "
"\"valfria argument\"."

msgid ""
"Calling :meth:`add_argument_group` on an argument group now raises an "
"exception. This nesting was never supported, often failed to work correctly, "
"and was unintentionally exposed through inheritance."
msgstr ""
"Anrop av :meth:`add_argument_group` på en argumentgrupp ger nu upphov till "
"ett undantag. Denna nestning stöddes aldrig, fungerade ofta inte korrekt och "
"exponerades oavsiktligt genom arv."

msgid "Passing prefix_chars_ to :meth:`add_argument_group` is now deprecated."
msgstr ""
"Att skicka prefix_chars_ till :meth:`add_argument_group` är nu föråldrat."

msgid "Mutual exclusion"
msgstr "Ömsesidigt uteslutande"

msgid ""
"Create a mutually exclusive group. :mod:`!argparse` will make sure that only "
"one of the arguments in the mutually exclusive group was present on the "
"command line::"
msgstr ""
"Skapa en ömsesidigt exklusiv grupp. :mod:`!argparse` kommer att se till att "
"endast ett av argumenten i den ömsesidigt exklusiva gruppen fanns på "
"kommandoraden::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namnrymd(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namnområde(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"användning: PROG [-h] [--foo | --bar]\n"
"PROG: fel: argument --bar: inte tillåtet med argument --foo"

msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required* "
"argument, to indicate that at least one of the mutually exclusive arguments "
"is required::"
msgstr ""
"Metoden :meth:`add_mutually_exclusive_group` accepterar också ett *required*-"
"argument, för att ange att minst ett av de ömsesidigt uteslutande argumenten "
"krävs::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"användning: PROG [-h] (--foo | --bar)\n"
"PROG: fel: ett av argumenten --foo --bar är obligatoriskt"

msgid ""
"Note that currently mutually exclusive argument groups do not support the "
"*title* and *description* arguments of :meth:`~ArgumentParser."
"add_argument_group`. However, a mutually exclusive group can be added to an "
"argument group that has a title and description. For example::"
msgstr ""
"Observera att argumentgrupper som för närvarande är ömsesidigt exklusiva "
"inte stöder argumenten *title* och *description* i :meth:`~ArgumentParser."
"add_argument_group`. En ömsesidigt exklusiv grupp kan dock läggas till i en "
"argumentgrupp som har en titel och en beskrivning. Till exempel::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Group title', 'Group description')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo help')\n"
">>> exclusive_group.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"Group title:\n"
"  Group description\n"
"\n"
"  --foo FOO   foo help\n"
"  --bar BAR   bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Grupptitel', 'Gruppbeskrivning')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo hjälp')\n"
">>> exclusive_group.add_argument('--bar', help='bar hjälp')\n"
">>> parser.print_help()\n"
"användning: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"\n"
"Gruppens titel:\n"
"  Gruppens beskrivning\n"
"\n"
"  --foo FOO foo hjälp\n"
"  --bar BAR bar bar hjälp"

msgid ""
"Calling :meth:`add_argument_group` or :meth:`add_mutually_exclusive_group` "
"on a mutually exclusive group now raises an exception. This nesting was "
"never supported, often failed to work correctly, and was unintentionally "
"exposed through inheritance."
msgstr ""
"Anrop av :meth:`add_argument_group` eller :meth:"
"`add_mutually_exclusive_group` på en ömsesidigt exklusiv grupp ger nu upphov "
"till ett undantag. Denna nestning stöddes aldrig, fungerade ofta inte "
"korrekt och exponerades oavsiktligt genom arv."

msgid "Parser defaults"
msgstr "Standardvärden för parser"

msgid ""
"Most of the time, the attributes of the object returned by :meth:"
"`parse_args` will be fully determined by inspecting the command-line "
"arguments and the argument actions.  :meth:`set_defaults` allows some "
"additional attributes that are determined without any inspection of the "
"command line to be added::"
msgstr ""
"För det mesta kommer attributen för det objekt som returneras av :meth:"
"`parse_args` att vara helt bestämda genom att inspektera "
"kommandoradsargumenten och argumentåtgärderna. :meth:`set_defaults` gör att "
"några ytterligare attribut som bestäms utan någon inspektion av "
"kommandoraden kan läggas till::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namnrymd(bar=42, baz='badger', foo=736)"

msgid ""
"Note that parser-level defaults always override argument-level defaults::"
msgstr ""
"Observera att standardvärden på parsernivå alltid åsidosätter standardvärden "
"på argumentnivå::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namnrymd(foo='spam')"

msgid ""
"Parser-level defaults can be particularly useful when working with multiple "
"parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an "
"example of this type."
msgstr ""
"Standardvärden på parser-nivå kan vara särskilt användbara när man arbetar "
"med flera parsers.  Se metoden :meth:`~ArgumentParser.add_subparsers` för "
"ett exempel på denna typ."

msgid ""
"Get the default value for a namespace attribute, as set by either :meth:"
"`~ArgumentParser.add_argument` or by :meth:`~ArgumentParser.set_defaults`::"
msgstr ""
"Hämta standardvärdet för ett namnrymdsattribut, som anges antingen av :meth:"
"`~ArgumentParser.add_argument` eller av :meth:`~ArgumentParser."
"set_defaults`::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"

msgid "Printing help"
msgstr "Hjälp med utskrift"

msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will take "
"care of formatting and printing any usage or error messages.  However, "
"several formatting methods are available:"
msgstr ""
"I de flesta typiska applikationer kommer :meth:`~ArgumentParser.parse_args` "
"att ta hand om formateringen och skriva ut eventuella användnings- eller "
"felmeddelanden.  Det finns dock flera formateringsmetoder tillgängliga:"

msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` is "
"assumed."
msgstr ""
"Skriv ut en kort beskrivning av hur :class:`ArgumentParser` ska anropas på "
"kommandoraden.  Om *file* är ``None``, antas :data:`sys.stdout`."

msgid ""
"Print a help message, including the program usage and information about the "
"arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""
"Skriv ut ett hjälpmeddelande, inklusive programanvändning och information om "
"de argument som registrerats med :class:`ArgumentParser`.  Om *file* är "
"``None``, antas :data:`sys.stdout`."

msgid ""
"There are also variants of these methods that simply return a string instead "
"of printing it:"
msgstr ""
"Det finns också varianter av dessa metoder som helt enkelt returnerar en "
"sträng i stället för att skriva ut den:"

msgid ""
"Return a string containing a brief description of how the :class:"
"`ArgumentParser` should be invoked on the command line."
msgstr ""
"Returnerar en sträng som innehåller en kort beskrivning av hur :class:"
"`ArgumentParser` ska anropas på kommandoraden."

msgid ""
"Return a string containing a help message, including the program usage and "
"information about the arguments registered with the :class:`ArgumentParser`."
msgstr ""
"Returnerar en sträng som innehåller ett hjälpmeddelande, inklusive "
"programanvändning och information om de argument som registrerats med :class:"
"`ArgumentParser`."

msgid "Partial parsing"
msgstr "Partiell parsning"

msgid ""
"Sometimes a script only needs to handle a specific set of command-line "
"arguments, leaving any unrecognized arguments for another script or program. "
"In these cases, the :meth:`~ArgumentParser.parse_known_args` method can be "
"useful."
msgstr ""
"Ibland behöver ett skript bara hantera en viss uppsättning "
"kommandoradsargument och lämna eventuella oigenkända argument till ett annat "
"skript eller program. I dessa fall kan metoden :meth:`~ArgumentParser."
"parse_known_args` vara användbar."

msgid ""
"This method works similarly to :meth:`~ArgumentParser.parse_args`, but it "
"does not raise an error for extra, unrecognized arguments. Instead, it "
"parses the known arguments and returns a two item tuple that contains the "
"populated namespace and the list of any unrecognized arguments."
msgstr ""
"Den här metoden fungerar på samma sätt som :meth:`~ArgumentParser."
"parse_args`, men den ger inte felmeddelanden för extra, okända argument. "
"Istället analyserar den de kända argumenten och returnerar en tupel med två "
"objekt som innehåller den fyllda namnrymden och listan över eventuella "
"okända argument."

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.lägg_till_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namnrymd(bar='BAR', foo=True), ['--badger', 'spam'])"

msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to :meth:"
"`~ArgumentParser.parse_known_args`. The parser may consume an option even if "
"it's just a prefix of one of its known options, instead of leaving it in the "
"remaining arguments list."
msgstr ""
":ref:`Prefixmatchning <prefix-matching>` regler gäller för :meth:"
"`~ArgumentParser.parse_known_args`. Parsern kan konsumera ett alternativ "
"även om det bara är ett prefix av ett av dess kända alternativ, istället för "
"att lämna det i den återstående argumentlistan."

msgid "Customizing file parsing"
msgstr "Anpassa filparsning"

msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* keyword "
"argument to the :class:`ArgumentParser` constructor) are read one argument "
"per line. :meth:`convert_arg_line_to_args` can be overridden for fancier "
"reading."
msgstr ""
"Argument som läses från en fil (se nyckelordsargumentet "
"*fromfile_prefix_chars* till konstruktören :class:`ArgumentParser`) läses "
"ett argument per rad. :meth:`convert_arg_line_to_args` kan åsidosättas för "
"mer avancerad läsning."

msgid ""
"This method takes a single argument *arg_line* which is a string read from "
"the argument file.  It returns a list of arguments parsed from this string. "
"The method is called once per line read from the argument file, in order."
msgstr ""
"Denna metod tar ett enda argument *arg_line* som är en sträng som läses från "
"argumentfilen.  Den returnerar en lista med argument som tolkats från denna "
"sträng. Metoden anropas en gång per rad som läses från argumentfilen, i "
"ordning."

msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""
"En användbar överstyrning av denna metod är en som behandlar varje "
"mellanslagsseparerat ord som ett argument.  Följande exempel visar hur man "
"gör detta::"

msgid ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"
msgstr ""
"klass MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"

msgid "Exiting methods"
msgstr "Spännande metoder"

msgid ""
"This method terminates the program, exiting with the specified *status* and, "
"if given, it prints a *message* to :data:`sys.stderr` before that. The user "
"can override this method to handle these steps differently::"
msgstr ""
"Den här metoden avslutar programmet med den angivna *statusen* och, om den "
"anges, skriver den ut ett *meddelande* till :data:`sys.stderr` innan dess. "
"Användaren kan åsidosätta den här metoden för att hantera dessa steg "
"annorlunda::"

msgid ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Exiting because of an error: {message}')\n"
"        exit(status)"
msgstr ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Avslutar på grund av ett fel: {message}')\n"
"        exit(status)"

msgid ""
"This method prints a usage message, including the *message*, to :data:`sys."
"stderr` and terminates the program with a status code of 2."
msgstr ""
"Denna metod skriver ut ett användningsmeddelande, inklusive *message*, till :"
"data:`sys.stderr` och avslutar programmet med statuskoden 2."

msgid "Intermixed parsing"
msgstr "Intermixad parsning"

msgid ""
"A number of Unix commands allow the user to intermix optional arguments with "
"positional arguments.  The :meth:`~ArgumentParser.parse_intermixed_args` "
"and :meth:`~ArgumentParser.parse_known_intermixed_args` methods support this "
"parsing style."
msgstr ""
"Ett antal Unix-kommandon tillåter användaren att blanda valfria argument med "
"positionella argument.  Metoderna :meth:`~ArgumentParser."
"parse_intermixed_args` och :meth:`~ArgumentParser."
"parse_known_intermixed_args` stöder denna parsningsstil."

msgid ""
"These parsers do not support all the :mod:`!argparse` features, and will "
"raise exceptions if unsupported features are used.  In particular, "
"subparsers, and mutually exclusive groups that include both optionals and "
"positionals are not supported."
msgstr ""
"Dessa parsers har inte stöd för alla :mod:`!argparse`-funktioner, och kommer "
"att ge upphov till undantag om funktioner som inte stöds används.  I "
"synnerhet stöds inte subparsers och ömsesidigt exklusiva grupper som "
"innehåller både optionals och positionals."

msgid ""
"The following example shows the difference between :meth:`~ArgumentParser."
"parse_known_args` and :meth:`~ArgumentParser.parse_intermixed_args`: the "
"former returns ``['2', '3']`` as unparsed arguments, while the latter "
"collects all the positionals into ``rest``.  ::"
msgstr ""
"Följande exempel visar skillnaden mellan :meth:`~ArgumentParser."
"parse_known_args` och :meth:`~ArgumentParser.parse_intermixed_args`: den "
"förra returnerar ``['2', '3']`` som oanalyserade argument, medan den senare "
"samlar alla positionaler i ``rest``. ::"

msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.lägg_till_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namnrymd(cmd='doit', foo='bar', rest=[1, 2, 3])"

msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item tuple "
"containing the populated namespace and the list of remaining argument "
"strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an error if "
"there are any remaining unparsed argument strings."
msgstr ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returnerar en tupel med "
"två objekt som innehåller den fyllda namnrymden och listan över återstående "
"argumentsträngar. :meth:`~ArgumentParser.parse_intermixed_args` ger upphov "
"till ett fel om det finns några återstående oanalyserade argumentsträngar."

msgid "Registering custom types or actions"
msgstr "Registrering av anpassade typer eller åtgärder"

msgid ""
"Sometimes it's desirable to use a custom string in error messages to provide "
"more user-friendly output. In these cases, :meth:`!register` can be used to "
"register custom actions or types with a parser and allow you to reference "
"the type by their registered name instead of their callable name."
msgstr ""
"Ibland är det önskvärt att använda en anpassad sträng i felmeddelanden för "
"att ge en mer användarvänlig utdata. I dessa fall kan :meth:`!register` "
"användas för att registrera anpassade åtgärder eller typer med en parser och "
"låta dig referera till typen med deras registrerade namn istället för deras "
"anropsbara namn."

msgid ""
"The :meth:`!register` method accepts three arguments - a *registry_name*, "
"specifying the internal registry where the object will be stored (e.g., "
"``action``, ``type``), *value*, which is the key under which the object will "
"be registered, and object, the callable to be registered."
msgstr ""
"Metoden :meth:`!register` tar emot tre argument - ett *registry_name*, som "
"anger det interna register där objektet ska lagras (t.ex. ``action``, "
"``type``), *value*, som är den nyckel under vilken objektet ska registreras, "
"och object, den anropbara enhet som ska registreras."

msgid ""
"The following example shows how to register a custom type with a parser::"
msgstr ""
"Följande exempel visar hur man registrerar en anpassad typ med en parser::"

msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'hexadecimal integer', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', type='hexadecimal integer')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, "
"default=None, type='hexadecimal integer', choices=None, required=False, "
"help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namespace(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"usage: PROG [-h] [--foo FOO]\n"
"PROG: error: argument --foo: invalid 'hexadecimal integer' value: '1.2'"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'hexadecimalt heltal', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', typ='hexadecimalt heltal')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, "
"default=None, type='hexadecimal integer', choices=None, required=False, "
"help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namnrymd(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"användning: PROG [-h] [--foo FOO]\n"
"PROG: fel: argument --foo: ogiltigt 'hexadecimalt heltal' värde: '1.2'"

msgid "Exceptions"
msgstr "Undantag"

msgid "An error from creating or using an argument (optional or positional)."
msgstr ""
"Ett fel vid skapande eller användning av ett argument (valfritt eller "
"positionellt)."

msgid ""
"The string value of this exception is the message, augmented with "
"information about the argument that caused it."
msgstr ""
"Strängvärdet för detta undantag är meddelandet, kompletterat med information "
"om det argument som orsakade det."

msgid ""
"Raised when something goes wrong converting a command line string to a type."
msgstr ""
"Utlöses när något går fel när en kommandoradssträng konverteras till en typ."

msgid "Guides and Tutorials"
msgstr "Guider och handledning"

msgid "? (question mark)"
msgstr "? (frågetecken)"

msgid "in argparse module"
msgstr "i argparse-modulen"

msgid "* (asterisk)"
msgstr "* (asterisk)"

msgid "+ (plus)"
msgstr "+ (plus)"
