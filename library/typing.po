# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!typing` --- Support for type hints"
msgstr ":mod:`!typing` --- Stöd för typtips"

msgid "**Source code:** :source:`Lib/typing.py`"
msgstr "**Källkod:** :source:`Lib/typing.py`"

msgid ""
"The Python runtime does not enforce function and variable type annotations. "
"They can be used by third party tools such as :term:`type checkers <static "
"type checker>`, IDEs, linters, etc."
msgstr ""
"Pythons runtime tvingar inte fram funktions- och variabeltypsannoteringar. "
"De kan användas av tredjepartsverktyg som :term:`typkontroll <static type "
"checker>`, IDE:er, linters, etc."

msgid "This module provides runtime support for type hints."
msgstr "Denna modul ger runtime-stöd för typtips."

msgid "Consider the function below::"
msgstr "Tänk på funktionen nedan::"

msgid ""
"def surface_area_of_cube(edge_length: float) -> str:\n"
"    return f\"The surface area of the cube is {6 * edge_length ** 2}.\""
msgstr ""
"def surface_area_of_cube(edge_length: float) -> str:\n"
"    return f\"Kubens yta är {6 * kantlängd ** 2}.\""

msgid ""
"The function ``surface_area_of_cube`` takes an argument expected to be an "
"instance of :class:`float`, as indicated by the :term:`type hint` "
"``edge_length: float``. The function is expected to return an instance of :"
"class:`str`, as indicated by the ``-> str`` hint."
msgstr ""
"Funktionen ``surface_area_of_cube`` tar ett argument som förväntas vara en "
"instans av :class:`float`, vilket indikeras av :term:`type hint` "
"``edge_length: float``. Funktionen förväntas returnera en instans av :class:"
"`str`, vilket indikeras av ``-> str`` hintet."

msgid ""
"While type hints can be simple classes like :class:`float` or :class:`str`, "
"they can also be more complex. The :mod:`typing` module provides a "
"vocabulary of more advanced type hints."
msgstr ""
"Även om typhänvisningar kan vara enkla klasser som :class:`float` eller :"
"class:`str`, kan de också vara mer komplexa. Modulen :mod:`typing` "
"tillhandahåller en vokabulär med mer avancerade typhänvisningar."

msgid ""
"New features are frequently added to the ``typing`` module. The :pypi:"
"`typing_extensions` package provides backports of these new features to "
"older versions of Python."
msgstr ""
"Nya funktioner läggs ofta till i modulen ``typing``. Paketet :pypi:"
"`typing_extensions` tillhandahåller bakåtporter av dessa nya funktioner till "
"äldre versioner av Python."

msgid ""
"`Typing cheat sheet <https://mypy.readthedocs.io/en/stable/cheat_sheet_py3."
"html>`_"
msgstr ""
"`Typing cheat sheet <https://mypy.readthedocs.io/en/stable/cheat_sheet_py3."
"html>`_"

msgid "A quick overview of type hints (hosted at the mypy docs)"
msgstr "En snabb översikt över typtips (värd på mypy-dokumenten)"

msgid ""
"Type System Reference section of `the mypy docs <https://mypy.readthedocs.io/"
"en/stable/index.html>`_"
msgstr ""
"Type System Reference-avsnittet av `the mypy docs <https://mypy.readthedocs."
"io/en/stable/index.html>`_"

msgid ""
"The Python typing system is standardised via PEPs, so this reference should "
"broadly apply to most Python type checkers. (Some parts may still be "
"specific to mypy.)"
msgstr ""
"Pythons typsystem är standardiserat via PEPs, så denna referens bör i stort "
"sett gälla för de flesta Python-typkontrollörer. (Vissa delar kan "
"fortfarande vara specifika för mypy.)"

msgid "`Static Typing with Python <https://typing.python.org/en/latest/>`_"
msgstr "`Static Typing with Python <https://typing.python.org/en/latest/>`_"

msgid ""
"Type-checker-agnostic documentation written by the community detailing type "
"system features, useful typing related tools and typing best practices."
msgstr ""
"Typkontrollagnostisk dokumentation skriven av communityn som beskriver "
"typsystemets funktioner, användbara typrelaterade verktyg och bästa praxis "
"för typning."

msgid "Specification for the Python Type System"
msgstr "Specifikation för Pythons typsystem"

msgid ""
"The canonical, up-to-date specification of the Python type system can be "
"found at `Specification for the Python type system <https://typing.python."
"org/en/latest/spec/index.html>`_."
msgstr ""
"Den kanoniska, uppdaterade specifikationen för Pythons typsystem finns på "
"`Specification for the Python type system <https://typing.python.org/en/"
"latest/spec/index.html>`_."

msgid "Type aliases"
msgstr "Typ av alias"

msgid ""
"A type alias is defined using the :keyword:`type` statement, which creates "
"an instance of :class:`TypeAliasType`. In this example, ``Vector`` and "
"``list[float]`` will be treated equivalently by static type checkers::"
msgstr ""
"Ett typalias definieras med hjälp av :keyword:`type`-satsen, som skapar en "
"instans av :class:`TypeAliasType`. I det här exemplet kommer ``Vector`` och "
"``list[float]`` att behandlas likvärdigt av statiska typkontrollanter::"

msgid ""
"type Vector = list[float]\n"
"\n"
"def scale(scalar: float, vector: Vector) -> Vector:\n"
"    return [scalar * num for num in vector]\n"
"\n"
"# passes type checking; a list of floats qualifies as a Vector.\n"
"new_vector = scale(2.0, [1.0, -4.2, 5.4])"
msgstr ""
"typ Vektor = lista[float]\n"
"\n"
"def scale(scalar: float, vector: Vector) -> Vector:\n"
"    return [skalär * num för num i vektor]\n"
"\n"
"# klarar typkontroll; en lista med flottörer kvalificerar sig som en "
"vektor.\n"
"ny_vektor = skala(2,0, [1,0, -4,2, 5,4])"

msgid ""
"Type aliases are useful for simplifying complex type signatures. For "
"example::"
msgstr ""
"Typaliaser är användbara för att förenkla komplexa typsignaturer. Till "
"exempel::"

msgid ""
"from collections.abc import Sequence\n"
"\n"
"type ConnectionOptions = dict[str, str]\n"
"type Address = tuple[str, int]\n"
"type Server = tuple[Address, ConnectionOptions]\n"
"\n"
"def broadcast_message(message: str, servers: Sequence[Server]) -> None:\n"
"    ...\n"
"\n"
"# The static type checker will treat the previous type signature as\n"
"# being exactly equivalent to this one.\n"
"def broadcast_message(\n"
"    message: str,\n"
"    servers: Sequence[tuple[tuple[str, int], dict[str, str]]]\n"
") -> None:\n"
"    ..."
msgstr ""
"från collections.abc import Sequence\n"
"\n"
"type ConnectionOptions = dict[str, str]\n"
"type Address = tuple[str, int]\n"
"type Server = tuple[Adress, ConnectionOptions]\n"
"\n"
"def broadcast_message(message: str, servers: Sequence[Server]) -> None:\n"
"    ...\n"
"\n"
"# Den statiska typkontrollen kommer att behandla den föregående "
"typsignaturen som\n"
"# som exakt likvärdig med den här.\n"
"def broadcast_message(\n"
"    meddelande: str,\n"
"    servrar: Sequence[tuple[tuple[str, int], dict[str, str]]]]\n"
") -> Ingen:\n"
"    ..."

msgid ""
"The :keyword:`type` statement is new in Python 3.12. For backwards "
"compatibility, type aliases can also be created through simple assignment::"
msgstr ""
"Satsen :keyword:`type` är ny i Python 3.12. För bakåtkompatibilitet kan "
"typaliaser också skapas genom enkel tilldelning::"

msgid "Vector = list[float]"
msgstr "Vektor = lista[float]"

msgid ""
"Or marked with :data:`TypeAlias` to make it explicit that this is a type "
"alias, not a normal variable assignment::"
msgstr ""
"Eller markerad med :data:`TypeAlias` för att göra det tydligt att detta är "
"ett typalias, inte en normal variabeltilldelning::"

msgid ""
"from typing import TypeAlias\n"
"\n"
"Vector: TypeAlias = list[float]"
msgstr ""
"från typing import TypeAlias\n"
"\n"
"Vektor: TypeAlias = lista[float]"

msgid "NewType"
msgstr "NyTyp"

msgid "Use the :class:`NewType` helper to create distinct types::"
msgstr "Använd hjälpen :class:`NewType` för att skapa distinkta typer::"

msgid ""
"from typing import NewType\n"
"\n"
"UserId = NewType('UserId', int)\n"
"some_id = UserId(524313)"
msgstr ""
"från typing import NewType\n"
"\n"
"UserId = NewType('UserId', int)\n"
"some_id = UserId(524313)"

msgid ""
"The static type checker will treat the new type as if it were a subclass of "
"the original type. This is useful in helping catch logical errors::"
msgstr ""
"Den statiska typkontrollen behandlar den nya typen som om den vore en "
"subklass av den ursprungliga typen. Detta är användbart för att hjälpa till "
"att fånga logiska fel::"

msgid ""
"def get_user_name(user_id: UserId) -> str:\n"
"    ...\n"
"\n"
"# passes type checking\n"
"user_a = get_user_name(UserId(42351))\n"
"\n"
"# fails type checking; an int is not a UserId\n"
"user_b = get_user_name(-1)"
msgstr ""
"def get_user_name(user_id: UserId) -> str:\n"
"    ...\n"
"\n"
"# passerar typkontroll\n"
"user_a = get_user_name(UserId(42351))\n"
"\n"
"# misslyckas med typkontroll; en int är inte en UserId\n"
"user_b = get_user_name(-1)"

msgid ""
"You may still perform all ``int`` operations on a variable of type "
"``UserId``, but the result will always be of type ``int``. This lets you "
"pass in a ``UserId`` wherever an ``int`` might be expected, but will prevent "
"you from accidentally creating a ``UserId`` in an invalid way::"
msgstr ""
"Du kan fortfarande utföra alla ``int``-operationer på en variabel av typen "
"``UserId``, men resultatet kommer alltid att vara av typen ``int``. Detta "
"gör att du kan skicka in ett ``UserId`` överallt där ett ``int`` kan "
"förväntas, men förhindrar att du av misstag skapar ett ``UserId`` på ett "
"ogiltigt sätt::"

msgid ""
"# 'output' is of type 'int', not 'UserId'\n"
"output = UserId(23413) + UserId(54341)"
msgstr ""
"# 'output' är av typen 'int', inte 'UserId'\n"
"output = UserId(23413) + UserId(54341)"

msgid ""
"Note that these checks are enforced only by the static type checker. At "
"runtime, the statement ``Derived = NewType('Derived', Base)`` will make "
"``Derived`` a callable that immediately returns whatever parameter you pass "
"it. That means the expression ``Derived(some_value)`` does not create a new "
"class or introduce much overhead beyond that of a regular function call."
msgstr ""
"Observera att dessa kontroller endast verkställs av den statiska "
"typkontrollen. Vid körning kommer uttalandet ``Derived = NewType('Derived', "
"Base)`` att göra ``Derived`` till en callable som omedelbart returnerar "
"vilken parameter du än ger den. Det betyder att uttrycket "
"``Derived(some_value)`` inte skapar en ny klass eller introducerar mycket "
"overhead utöver det som ett vanligt funktionsanrop gör."

msgid ""
"More precisely, the expression ``some_value is Derived(some_value)`` is "
"always true at runtime."
msgstr ""
"Mer exakt är uttrycket ``något_värde är Derived(något_värde)`` alltid sant "
"vid körning."

msgid "It is invalid to create a subtype of ``Derived``::"
msgstr "Det är ogiltigt att skapa en subtyp av ``Derived``::"

msgid ""
"from typing import NewType\n"
"\n"
"UserId = NewType('UserId', int)\n"
"\n"
"# Fails at runtime and does not pass type checking\n"
"class AdminUserId(UserId): pass"
msgstr ""
"från typing import NewType\n"
"\n"
"UserId = NewType('UserId', int)\n"
"\n"
"# Misslyckas vid körning och klarar inte typkontroll\n"
"class AdminUserId(UserId): pass"

msgid ""
"However, it is possible to create a :class:`NewType` based on a 'derived' "
"``NewType``::"
msgstr ""
"Det är dock möjligt att skapa en :class:`NewType` baserad på en 'härledd' "
"``NewType``::"

msgid ""
"from typing import NewType\n"
"\n"
"UserId = NewType('UserId', int)\n"
"\n"
"ProUserId = NewType('ProUserId', UserId)"
msgstr ""
"från typing import NewType\n"
"\n"
"UserId = NewType('UserId', int)\n"
"\n"
"ProUserId = NewType('ProUserId', UserId)"

msgid "and typechecking for ``ProUserId`` will work as expected."
msgstr "och typkontroll för ``ProUserId`` kommer att fungera som förväntat."

msgid "See :pep:`484` for more details."
msgstr "Se :pep:`484` för mer information."

msgid ""
"Recall that the use of a type alias declares two types to be *equivalent* to "
"one another. Doing ``type Alias = Original`` will make the static type "
"checker treat ``Alias`` as being *exactly equivalent* to ``Original`` in all "
"cases. This is useful when you want to simplify complex type signatures."
msgstr ""
"Kom ihåg att användningen av ett typalias förklarar att två typer är "
"*ekvivalenta* med varandra. Genom att göra ``typ Alias = Original`` kommer "
"den statiska typkontrollen att behandla ``Alias`` som *exakt likvärdig* med "
"``Original`` i alla fall. Detta är användbart när du vill förenkla komplexa "
"typsignaturer."

msgid ""
"In contrast, ``NewType`` declares one type to be a *subtype* of another. "
"Doing ``Derived = NewType('Derived', Original)`` will make the static type "
"checker treat ``Derived`` as a *subclass* of ``Original``, which means a "
"value of type ``Original`` cannot be used in places where a value of type "
"``Derived`` is expected. This is useful when you want to prevent logic "
"errors with minimal runtime cost."
msgstr ""
"Däremot förklarar ``NewType`` att en typ är en *subtyp* av en annan. Om du "
"gör ``Derived = NewType('Derived', Original)`` kommer den statiska "
"typkontrollen att behandla ``Derived`` som en *subklass* av ``Original``, "
"vilket innebär att ett värde av typen ``Original`` inte kan användas på "
"platser där ett värde av typen ``Derived`` förväntas. Detta är användbart "
"när du vill förhindra logiska fel med minimal körtidskostnad."

msgid ""
"``NewType`` is now a class rather than a function.  As a result, there is "
"some additional runtime cost when calling ``NewType`` over a regular "
"function."
msgstr ""
"``NewType`` är nu en klass snarare än en funktion.  Som ett resultat av "
"detta finns det en viss extra körtidskostnad när man anropar ``NewType`` "
"över en vanlig funktion."

msgid ""
"The performance of calling ``NewType`` has been restored to its level in "
"Python 3.9."
msgstr ""
"Prestandan för att anropa ``NewType`` har återställts till samma nivå som i "
"Python 3.9."

msgid "Annotating callable objects"
msgstr "Annotering av anropsbara objekt"

msgid ""
"Functions -- or other :term:`callable` objects -- can be annotated using :"
"class:`collections.abc.Callable` or deprecated :data:`typing.Callable`. "
"``Callable[[int], str]`` signifies a function that takes a single parameter "
"of type :class:`int` and returns a :class:`str`."
msgstr ""
"Funktioner -- eller andra :term:`callable`-objekt -- kan annoteras med :"
"class:`collections.abc.Callable` eller den föråldrade :data:`typing."
"Callable`. ``Callable[[int], str]`` betecknar en funktion som tar en enda "
"parameter av typen :class:`int` och returnerar en :class:`str`."

msgid "For example:"
msgstr "Till exempel:"

msgid ""
"from collections.abc import Callable, Awaitable\n"
"\n"
"def feeder(get_next_item: Callable[[], str]) -> None:\n"
"    ...  # Body\n"
"\n"
"def async_query(on_success: Callable[[int], None],\n"
"                on_error: Callable[[int, Exception], None]) -> None:\n"
"    ...  # Body\n"
"\n"
"async def on_update(value: str) -> None:\n"
"    ...  # Body\n"
"\n"
"callback: Callable[[str], Awaitable[None]] = on_update"
msgstr ""
"from collections.abc import Callable, Awaitable\n"
"\n"
"def feeder(get_next_item: Callable[[], str]) -> None:\n"
"    ...  # Body\n"
"\n"
"def async_query(on_success: Callable[[int], None],\n"
"                on_error: Callable[[int, Exception], None]) -> None:\n"
"    ...  # Body\n"
"\n"
"async def on_update(value: str) -> None:\n"
"    ...  # Body\n"
"\n"
"callback: Callable[[str], Awaitable[None]] = on_update"

msgid ""
"The subscription syntax must always be used with exactly two values: the "
"argument list and the return type.  The argument list must be a list of "
"types, a :class:`ParamSpec`, :data:`Concatenate`, or an ellipsis. The return "
"type must be a single type."
msgstr ""
"Subscriptionsyntaxen måste alltid användas med exakt två värden: "
"argumentlistan och returtypen.  Argumentlistan måste vara en lista med "
"typer, en :class:`ParamSpec`, :data:`Concatenate` eller en ellips. "
"Returtypen måste vara en enda typ."

msgid ""
"If a literal ellipsis ``...`` is given as the argument list, it indicates "
"that a callable with any arbitrary parameter list would be acceptable:"
msgstr ""
"Om en bokstavlig ellips ``...`` anges som argumentlista, indikerar det att "
"en callable med godtycklig parameterlista skulle vara acceptabel:"

msgid ""
"def concat(x: str, y: str) -> str:\n"
"    return x + y\n"
"\n"
"x: Callable[..., str]\n"
"x = str     # OK\n"
"x = concat  # Also OK"
msgstr ""
"def concat(x: str, y: str) -> str:\n"
"    returnerar x + y\n"
"\n"
"x: Kallbar[..., str]\n"
"x = str # OK\n"
"x = concat # Också OK"

msgid ""
"``Callable`` cannot express complex signatures such as functions that take a "
"variadic number of arguments, :ref:`overloaded functions <overload>`, or "
"functions that have keyword-only parameters. However, these signatures can "
"be expressed by defining a :class:`Protocol` class with a :meth:`~object."
"__call__` method:"
msgstr ""
"``Callable`` kan inte uttrycka komplexa signaturer som funktioner som tar "
"ett variabelt antal argument, :ref:``overloaded functions <overload>``, "
"eller funktioner som har parametrar som endast innehåller nyckelord. Dessa "
"signaturer kan dock uttryckas genom att definiera en :class:`Protocol`-klass "
"med en :meth:`~object.__call__`-metod:"

msgid ""
"from collections.abc import Iterable\n"
"from typing import Protocol\n"
"\n"
"class Combiner(Protocol):\n"
"    def __call__(self, *vals: bytes, maxlen: int | None = None) -> "
"list[bytes]: ...\n"
"\n"
"def batch_proc(data: Iterable[bytes], cb_results: Combiner) -> bytes:\n"
"    for item in data:\n"
"        ...\n"
"\n"
"def good_cb(*vals: bytes, maxlen: int | None = None) -> list[bytes]:\n"
"    ...\n"
"def bad_cb(*vals: bytes, maxitems: int | None) -> list[bytes]:\n"
"    ...\n"
"\n"
"batch_proc([], good_cb)  # OK\n"
"batch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because "
"of\n"
"                         # different name and kind in the callback"
msgstr ""
"from collections.abc import Iterable\n"
"from typing import Protocol\n"
"\n"
"class Combiner(Protocol):\n"
"    def __call__(self, *vals: bytes, maxlen: int | None = None) -> "
"list[bytes]: ...\n"
"\n"
"def batch_proc(data: Iterable[bytes], cb_results: Combiner) -> bytes:\n"
"    for item in data:\n"
"        ...\n"
"\n"
"def good_cb(*vals: bytes, maxlen: int | None = None) -> list[bytes]:\n"
"    ...\n"
"def bad_cb(*vals: bytes, maxitems: int | None) -> list[bytes]:\n"
"    ...\n"
"\n"
"batch_proc([], good_cb)  # OK\n"
"batch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because "
"of\n"
"                         # different name and kind in the callback"

msgid ""
"Callables which take other callables as arguments may indicate that their "
"parameter types are dependent on each other using :class:`ParamSpec`. "
"Additionally, if that callable adds or removes arguments from other "
"callables, the :data:`Concatenate` operator may be used.  They take the form "
"``Callable[ParamSpecVariable, ReturnType]`` and "
"``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], "
"ReturnType]`` respectively."
msgstr ""
"Anropsbara filer som tar andra anropsbara filer som argument kan ange att "
"deras parametertyper är beroende av varandra med hjälp av :class:"
"`ParamSpec`. Dessutom, om denna anropsbarhet lägger till eller tar bort "
"argument från andra anropsbara objekt, kan operatorn :data:`Concatenate` "
"användas.  De har formen ``Callable[ParamSpecVariable, ReturnType]`` "
"respektive ``Callable[Concatenate[Arg1Type, Arg2Type, ..., "
"ParamSpecVariable], ReturnType]``."

msgid ""
"``Callable`` now supports :class:`ParamSpec` and :data:`Concatenate`. See :"
"pep:`612` for more details."
msgstr ""
"``Callable`` stöder nu :class:`ParamSpec` och :data:`Concatenate`. Se :pep:"
"`612` för mer information."

msgid ""
"The documentation for :class:`ParamSpec` and :class:`Concatenate` provides "
"examples of usage in ``Callable``."
msgstr ""
"Dokumentationen för :class:`ParamSpec` och :class:`Concatenate` ger exempel "
"på användning i ``Callable``."

msgid "Generics"
msgstr "Generiska läkemedel"

msgid ""
"Since type information about objects kept in containers cannot be statically "
"inferred in a generic way, many container classes in the standard library "
"support subscription to denote the expected types of container elements."
msgstr ""
"Eftersom typinformation om objekt som förvaras i containrar inte kan "
"härledas statiskt på ett generiskt sätt, stöder många containerklasser i "
"standardbiblioteket subscription för att ange de förväntade typerna av "
"containerelement."

msgid ""
"from collections.abc import Mapping, Sequence\n"
"\n"
"class Employee: ...\n"
"\n"
"# Sequence[Employee] indicates that all elements in the sequence\n"
"# must be instances of \"Employee\".\n"
"# Mapping[str, str] indicates that all keys and all values in the mapping\n"
"# must be strings.\n"
"def notify_by_email(employees: Sequence[Employee],\n"
"                    overrides: Mapping[str, str]) -> None: ..."
msgstr ""
"from collections.abc import Mapping, Sequence\n"
"\n"
"class Employee: ...\n"
"\n"
"# Sequence[Employee] indicates that all elements in the sequence\n"
"# must be instances of \"Employee\".\n"
"# Mapping[str, str] indicates that all keys and all values in the mapping\n"
"# must be strings.\n"
"def notify_by_email(employees: Sequence[Employee],\n"
"                    overrides: Mapping[str, str]) -> None: ..."

msgid ""
"Generic functions and classes can be parameterized by using :ref:`type "
"parameter syntax <type-params>`::"
msgstr ""
"Generiska funktioner och klasser kan parametriseras med hjälp av :ref:`type "
"parameter syntax <type-params>`::"

msgid ""
"from collections.abc import Sequence\n"
"\n"
"def first[T](l: Sequence[T]) -> T:  # Function is generic over the TypeVar "
"\"T\"\n"
"    return l[0]"
msgstr ""
"från collections.abc import Sequence\n"
"\n"
"def first[T](l: Sequence[T]) -> T:  # Funktionen är generisk över TypeVar "
"\"T\"\n"
"    return l[0]"

msgid "Or by using the :class:`TypeVar` factory directly::"
msgstr "Eller genom att använda :class:`TypeVar`-fabriken direkt::"

msgid ""
"from collections.abc import Sequence\n"
"from typing import TypeVar\n"
"\n"
"U = TypeVar('U')                  # Declare type variable \"U\"\n"
"\n"
"def second(l: Sequence[U]) -> U:  # Function is generic over the TypeVar "
"\"U\"\n"
"    return l[1]"
msgstr ""
"from collections.abc import Sequence\n"
"from typing import TypeVar\n"
"\n"
"U = TypeVar('U')                  # Declare type variable \"U\"\n"
"\n"
"def second(l: Sequence[U]) -> U:  # Function is generic over the TypeVar "
"\"U\"\n"
"    return l[1]"

msgid "Syntactic support for generics is new in Python 3.12."
msgstr "Syntaktiskt stöd för generics är nytt i Python 3.12."

msgid "Annotating tuples"
msgstr "Annotering av tuples"

msgid ""
"For most containers in Python, the typing system assumes that all elements "
"in the container will be of the same type. For example::"
msgstr ""
"För de flesta behållare i Python förutsätter typningssystemet att alla "
"element i behållaren är av samma typ. Till exempel::"

msgid ""
"from collections.abc import Mapping\n"
"\n"
"# Type checker will infer that all elements in ``x`` are meant to be ints\n"
"x: list[int] = []\n"
"\n"
"# Type checker error: ``list`` only accepts a single type argument:\n"
"y: list[int, str] = [1, 'foo']\n"
"\n"
"# Type checker will infer that all keys in ``z`` are meant to be strings,\n"
"# and that all values in ``z`` are meant to be either strings or ints\n"
"z: Mapping[str, str | int] = {}"
msgstr ""
"från collections.abc import Mapping\n"
"\n"
"# Type checker kommer att dra slutsatsen att alla element i ``x`` är avsedda "
"att vara ints\n"
"x: lista[int] = []\n"
"\n"
"# Fel i typkontrollen: ``list`` accepterar bara ett enda typargument:\n"
"y: list[int, str] = [1, 'foo']\n"
"\n"
"# Typkontrollen drar slutsatsen att alla nycklar i ``z`` är avsedda att vara "
"strängar,\n"
"# och att alla värden i ``z`` är tänkta att vara antingen strängar eller "
"ints\n"
"z: Mappning[str, str | int] = {}"

msgid ""
":class:`list` only accepts one type argument, so a type checker would emit "
"an error on the ``y`` assignment above. Similarly, :class:`~collections.abc."
"Mapping` only accepts two type arguments: the first indicates the type of "
"the keys, and the second indicates the type of the values."
msgstr ""
":class:`list` accepterar bara ett typargument, så en typkontroll skulle ge "
"ett felmeddelande om ``y``-tilldelningen ovan. På samma sätt accepterar :"
"class:`~collections.abc.Mapping` bara två typargument: det första anger "
"typen av nycklar och det andra anger typen av värden."

msgid ""
"Unlike most other Python containers, however, it is common in idiomatic "
"Python code for tuples to have elements which are not all of the same type. "
"For this reason, tuples are special-cased in Python's typing system. :class:"
"`tuple` accepts *any number* of type arguments::"
msgstr ""
"Till skillnad från de flesta andra Python-containrar är det dock vanligt i "
"idiomatisk Python-kod att tupler har element som inte alla är av samma typ. "
"Av denna anledning är tupler specialklassade i Pythons typsystem. :class:"
"`tuple` accepterar *valfritt antal* typargument::"

msgid ""
"# OK: ``x`` is assigned to a tuple of length 1 where the sole element is an "
"int\n"
"x: tuple[int] = (5,)\n"
"\n"
"# OK: ``y`` is assigned to a tuple of length 2;\n"
"# element 1 is an int, element 2 is a str\n"
"y: tuple[int, str] = (5, \"foo\")\n"
"\n"
"# Error: the type annotation indicates a tuple of length 1,\n"
"# but ``z`` has been assigned to a tuple of length 3\n"
"z: tuple[int] = (1, 2, 3)"
msgstr ""
"# OK: ``x`` tilldelas en tupel av längd 1 där det enda elementet är en int\n"
"x: tuple[int] = (5,)\n"
"\n"
"# OK: ``y`` tilldelas en tupel av längd 2;\n"
"# element 1 är en int, element 2 är en str\n"
"y: tuple[int, str] = (5, \"foo\")\n"
"\n"
"# Fel: typannoteringen anger en tupel med längden 1,\n"
"# men ``z`` har tilldelats en tupel med längden 3\n"
"z: tupel[int] = (1, 2, 3)"

msgid ""
"To denote a tuple which could be of *any* length, and in which all elements "
"are of the same type ``T``, use ``tuple[T, ...]``. To denote an empty tuple, "
"use ``tuple[()]``. Using plain ``tuple`` as an annotation is equivalent to "
"using ``tuple[Any, ...]``::"
msgstr ""
"För att beteckna en tupel som kan vara av *valfri* längd och där alla "
"element är av samma typ ``T``, använd ``tuple[T, ...]``. För att beteckna en "
"tom tupel, använd ``tuple[()]``. Att använda vanlig ``tuple`` som en "
"annotation är likvärdigt med att använda ``tuple[Any, ...]``::"

msgid ""
"x: tuple[int, ...] = (1, 2)\n"
"# These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any "
"length\n"
"x = (1, 2, 3)\n"
"x = ()\n"
"# This reassignment is an error: all elements in ``x`` must be ints\n"
"x = (\"foo\", \"bar\")\n"
"\n"
"# ``y`` can only ever be assigned to an empty tuple\n"
"y: tuple[()] = ()\n"
"\n"
"z: tuple = (\"foo\", \"bar\")\n"
"# These reassignments are OK: plain ``tuple`` is equivalent to "
"``tuple[Any, ...]``\n"
"z = (1, 2, 3)\n"
"z = ()"
msgstr ""
"x: tuple[int, ...] = (1, 2)\n"
"# Dessa omfördelningar är OK: ``tuple[int, ...]`` indikerar att x kan vara "
"av valfri längd\n"
"x = (1, 2, 3)\n"
"x = ()\n"
"# Denna omfördelning är ett fel: alla element i ``x`` måste vara ints\n"
"x = (\"foo\", \"bar\")\n"
"\n"
"# ``y`` kan bara någonsin tilldelas en tom tupel\n"
"y: tuple[()] = ()\n"
"\n"
"z: tuple = (\"foo\", \"bar\")\n"
"# Dessa omfördelningar är OK: vanlig ``tuple`` är likvärdig med "
"``tuple[Any, ...]```\n"
"z = (1, 2, 3)\n"
"z = ()"

msgid "The type of class objects"
msgstr "Typ av klassobjekt"

msgid ""
"A variable annotated with ``C`` may accept a value of type ``C``. In "
"contrast, a variable annotated with ``type[C]`` (or deprecated :class:"
"`typing.Type[C] <Type>`) may accept values that are classes themselves -- "
"specifically, it will accept the *class object* of ``C``. For example::"
msgstr ""
"En variabel annoterad med ``C`` kan acceptera ett värde av typen ``C``. "
"Däremot kan en variabel annoterad med ``type[C]`` (eller föråldrade :class:"
"`typing.Type[C] <Type>`) acceptera värden som är klasser i sig -- specifikt "
"kommer den att acceptera *class object* av ``C``. Till exempel::"

msgid ""
"a = 3         # Has type ``int``\n"
"b = int       # Has type ``type[int]``\n"
"c = type(a)   # Also has type ``type[int]``"
msgstr ""
"a = 3 # Har typen ``int``\n"
"b = int # Har typen ``typ[int]``\n"
"c = type(a) # Har också typen ``type[int]``"

msgid "Note that ``type[C]`` is covariant::"
msgstr "Observera att ``type[C]`` är kovariant::"

msgid ""
"class User: ...\n"
"class ProUser(User): ...\n"
"class TeamUser(User): ...\n"
"\n"
"def make_new_user(user_class: type[User]) -> User:\n"
"    # ...\n"
"    return user_class()\n"
"\n"
"make_new_user(User)      # OK\n"
"make_new_user(ProUser)   # Also OK: ``type[ProUser]`` is a subtype of "
"``type[User]``\n"
"make_new_user(TeamUser)  # Still fine\n"
"make_new_user(User())    # Error: expected ``type[User]`` but got ``User``\n"
"make_new_user(int)       # Error: ``type[int]`` is not a subtype of "
"``type[User]``"
msgstr ""
"klass Användare: ...\n"
"klassen ProUser(Användare): ...\n"
"klassen TeamUser(Användare): ...\n"
"\n"
"def make_new_user(user_class: type[User]) -> Användare:\n"
"    # ...\n"
"    returnera user_class()\n"
"\n"
"make_new_user(Användare) # OK\n"
"make_new_user(ProUser) # Också OK: ``typ[ProUser]`` är en subtyp av "
"``typ[User]``\n"
"make_new_user(TeamUser) # Fortfarande bra\n"
"make_new_user(User()) # Fel: förväntade mig ``type[User]`` men fick "
"``User``\n"
"make_new_user(int) # Fel: ``type[int]`` är inte en subtyp av ``type[User]``"

msgid ""
"The only legal parameters for :class:`type` are classes, :data:`Any`, :ref:"
"`type variables <generics>`, and unions of any of these types. For example::"
msgstr ""
"De enda lagliga parametrarna för :class:`type` är klasser, :data:`Any`, :ref:"
"`type variables <generics>` och unioner av någon av dessa typer. Till "
"exempel::"

msgid ""
"def new_non_team_user(user_class: type[BasicUser | ProUser]): ...\n"
"\n"
"new_non_team_user(BasicUser)  # OK\n"
"new_non_team_user(ProUser)    # OK\n"
"new_non_team_user(TeamUser)   # Error: ``type[TeamUser]`` is not a subtype\n"
"                              # of ``type[BasicUser | ProUser]``\n"
"new_non_team_user(User)       # Also an error"
msgstr ""
"def new_non_team_user(user_class: type[BasicUser | ProUser]): ...\n"
"\n"
"new_non_team_user(BasicUser) # OK\n"
"new_non_team_user(ProUser) # OK\n"
"new_non_team_user(TeamUser) # Fel: ``type[TeamUser]`` är inte en subtyp\n"
"                              # av ``type[BasicUser | ProUser]``\n"
"new_non_team_user(User) # Också ett fel"

msgid ""
"``type[Any]`` is equivalent to :class:`type`, which is the root of Python's :"
"ref:`metaclass hierarchy <metaclasses>`."
msgstr ""
"``type[Any]`` är ekvivalent med :class:`type`, som är roten till Pythons :"
"ref:`metaklasshierarki <metaclasses>`."

msgid "Annotating generators and coroutines"
msgstr "Annotering av generatorer och coroutines"

msgid ""
"A generator can be annotated using the generic type :class:"
"`Generator[YieldType, SendType, ReturnType] <collections.abc.Generator>`. "
"For example::"
msgstr ""
"En generator kan annoteras med hjälp av den generiska typen :class:"
"`Generator[YieldType, SendType, ReturnType] <collections.abc.Generator>`. "
"Till exempel::"

msgid ""
"def echo_round() -> Generator[int, float, str]:\n"
"    sent = yield 0\n"
"    while sent >= 0:\n"
"        sent = yield round(sent)\n"
"    return 'Done'"
msgstr ""
"def echo_round() -> Generator[int, float, str]:\n"
"    sent = avkastning 0\n"
"    medan sent >= 0:\n"
"        sent = yield round(sent)\n"
"    return 'Klar'"

msgid ""
"Note that unlike many other generic classes in the standard library, the "
"``SendType`` of :class:`~collections.abc.Generator` behaves contravariantly, "
"not covariantly or invariantly."
msgstr ""
"Observera att till skillnad från många andra generiska klasser i "
"standardbiblioteket beter sig ``SendType`` i :class:`~collections.abc."
"Generator` kontravariant, inte kovariant eller invariant."

msgid ""
"The ``SendType`` and ``ReturnType`` parameters default to :const:`!None`::"
msgstr ""
"Parametrarna ``SendType`` och ``ReturnType`` är som standard :const:`!None`::"

msgid ""
"def infinite_stream(start: int) -> Generator[int]:\n"
"    while True:\n"
"        yield start\n"
"        start += 1"
msgstr ""
"def infinite_stream(start: int) -> Generator[int]:\n"
"    while True:\n"
"        avkastning start\n"
"        start += 1"

msgid "It is also possible to set these types explicitly::"
msgstr "Det är också möjligt att ange dessa typer explicit::"

msgid ""
"def infinite_stream(start: int) -> Generator[int, None, None]:\n"
"    while True:\n"
"        yield start\n"
"        start += 1"
msgstr ""
"def infinite_stream(start: int) -> Generator[int, None, None]:\n"
"    medan True:\n"
"        avkastning start\n"
"        start += 1"

msgid ""
"Simple generators that only ever yield values can also be annotated as "
"having a return type of either :class:`Iterable[YieldType] <collections.abc."
"Iterable>` or :class:`Iterator[YieldType] <collections.abc.Iterator>`::"
msgstr ""
"Enkla generatorer som bara ger värden kan också annoteras som att de har en "
"returtyp av antingen :class:`Iterable[YieldType] <collections.abc.Iterable>` "
"eller :class:`Iterator[YieldType] <collections.abc.Iterator>`::"

msgid ""
"def infinite_stream(start: int) -> Iterator[int]:\n"
"    while True:\n"
"        yield start\n"
"        start += 1"
msgstr ""
"def infinite_stream(start: int) -> Iterator[int]:\n"
"    medan True:\n"
"        avkastning start\n"
"        start += 1"

msgid ""
"Async generators are handled in a similar fashion, but don't expect a "
"``ReturnType`` type argument (:class:`AsyncGenerator[YieldType, SendType] "
"<collections.abc.AsyncGenerator>`). The ``SendType`` argument defaults to :"
"const:`!None`, so the following definitions are equivalent::"
msgstr ""
"Asynkrona generatorer hanteras på ett liknande sätt, men förvänta dig inte "
"ett argument av typen ``ReturnType`` (:class:`AsyncGenerator[YieldType, "
"SendType] <collections.abc.AsyncGenerator>`). Argumentet ``SendType`` är som "
"standard :const:`!None`, så följande definitioner är likvärdiga::"

msgid ""
"async def infinite_stream(start: int) -> AsyncGenerator[int]:\n"
"    while True:\n"
"        yield start\n"
"        start = await increment(start)\n"
"\n"
"async def infinite_stream(start: int) -> AsyncGenerator[int, None]:\n"
"    while True:\n"
"        yield start\n"
"        start = await increment(start)"
msgstr ""
"async def infinite_stream(start: int) -> AsyncGenerator[int]:\n"
"    while True:\n"
"        avkastning start\n"
"        start = vänta på inkrement(start)\n"
"\n"
"async def infinite_stream(start: int) -> AsyncGenerator[int, None]:\n"
"    while True:\n"
"        avkastning start\n"
"        start = await increment(start)"

msgid ""
"As in the synchronous case, :class:`AsyncIterable[YieldType] <collections."
"abc.AsyncIterable>` and :class:`AsyncIterator[YieldType] <collections.abc."
"AsyncIterator>` are available as well::"
msgstr ""
"Precis som i det synkrona fallet är :class:`AsyncIterable[YieldType] "
"<collections.abc.AsyncIterable>` och :class:`AsyncIterator[YieldType] "
"<collections.abc.AsyncIterator>` också tillgängliga::"

msgid ""
"async def infinite_stream(start: int) -> AsyncIterator[int]:\n"
"    while True:\n"
"        yield start\n"
"        start = await increment(start)"
msgstr ""
"async def infinite_stream(start: int) -> AsyncIterator[int]:\n"
"    medan True:\n"
"        avkastning start\n"
"        start = vänta på inkrement(start)"

msgid ""
"Coroutines can be annotated using :class:`Coroutine[YieldType, SendType, "
"ReturnType] <collections.abc.Coroutine>`. Generic arguments correspond to "
"those of :class:`~collections.abc.Generator`, for example::"
msgstr ""
"Coroutines kan annoteras med :class:`Coroutine[YieldType, SendType, "
"ReturnType] <collections.abc.Coroutine>`. Generiska argument motsvarar de i :"
"class:`~collections.abc.Generator`, till exempel::"

msgid ""
"from collections.abc import Coroutine\n"
"c: Coroutine[list[str], str, int]  # Some coroutine defined elsewhere\n"
"x = c.send('hi')                   # Inferred type of 'x' is list[str]\n"
"async def bar() -> None:\n"
"    y = await c                    # Inferred type of 'y' is int"
msgstr ""
"from collections.abc import Coroutine\n"
"c: Coroutine[list[str], str, int]  # Some coroutine defined elsewhere\n"
"x = c.send('hi')                   # Inferred type of 'x' is list[str]\n"
"async def bar() -> None:\n"
"    y = await c                    # Inferred type of 'y' is int"

msgid "User-defined generic types"
msgstr "Användardefinierade generiska typer"

msgid "A user-defined class can be defined as a generic class."
msgstr "En användardefinierad klass kan definieras som en generisk klass."

msgid ""
"from logging import Logger\n"
"\n"
"class LoggedVar[T]:\n"
"    def __init__(self, value: T, name: str, logger: Logger) -> None:\n"
"        self.name = name\n"
"        self.logger = logger\n"
"        self.value = value\n"
"\n"
"    def set(self, new: T) -> None:\n"
"        self.log('Set ' + repr(self.value))\n"
"        self.value = new\n"
"\n"
"    def get(self) -> T:\n"
"        self.log('Get ' + repr(self.value))\n"
"        return self.value\n"
"\n"
"    def log(self, message: str) -> None:\n"
"        self.logger.info('%s: %s', self.name, message)"
msgstr ""
"from logging import Logger\n"
"\n"
"klass LoggedVar[T]:\n"
"    def __init__(self, value: T, name: str, logger: Logger) -> None:\n"
"        self.name = namn\n"
"        self.logger = logger\n"
"        self.value = värde\n"
"\n"
"    def set(self, new: T) -> None:\n"
"        self.log('Set ' + repr(self.value))\n"
"        self.värde = nytt\n"
"\n"
"    def get(self) -> T:\n"
"        self.log('Get ' + repr(self.value))\n"
"        return self.värde\n"
"\n"
"    def log(self, message: str) -> None:\n"
"        self.logger.info('%s: %s', self.name, message)"

msgid ""
"This syntax indicates that the class ``LoggedVar`` is parameterised around a "
"single :ref:`type variable <typevar>` ``T`` . This also makes ``T`` valid as "
"a type within the class body."
msgstr ""
"Denna syntax anger att klassen ``LoggedVar`` är parameteriserad kring en "
"enda :ref:`typvariabel <typevar>``T`` . Detta gör också ``T`` giltig som en "
"typ inom klassens kropp."

msgid ""
"Generic classes implicitly inherit from :class:`Generic`. For compatibility "
"with Python 3.11 and lower, it is also possible to inherit explicitly from :"
"class:`Generic` to indicate a generic class::"
msgstr ""
"Generiska klasser ärver implicit från :class:`Generic`. För kompatibilitet "
"med Python 3.11 och lägre är det också möjligt att ärva explicit från :class:"
"`Generic` för att ange en generisk klass::"

msgid ""
"from typing import TypeVar, Generic\n"
"\n"
"T = TypeVar('T')\n"
"\n"
"class LoggedVar(Generic[T]):\n"
"    ..."
msgstr ""
"från typing import TypeVar, Generisk\n"
"\n"
"T = TypeVar('T')\n"
"\n"
"klass LoggedVar(Generic[T]):\n"
"    ..."

msgid ""
"Generic classes have :meth:`~object.__class_getitem__` methods, meaning they "
"can be parameterised at runtime (e.g. ``LoggedVar[int]`` below)::"
msgstr ""
"Generiska klasser har :meth:`~object.__class_getitem__`-metoder, vilket "
"innebär att de kan parametriseras vid körning (t.ex. ``LoggedVar[int]`` "
"nedan)::"

msgid ""
"from collections.abc import Iterable\n"
"\n"
"def zero_all_vars(vars: Iterable[LoggedVar[int]]) -> None:\n"
"    for var in vars:\n"
"        var.set(0)"
msgstr ""
"från collections.abc import Iterable\n"
"\n"
"def zero_all_vars(vars: Iterable[LoggedVar[int]]) -> None:\n"
"    för var i vars:\n"
"        var.set(0)"

msgid ""
"A generic type can have any number of type variables. All varieties of :"
"class:`TypeVar` are permissible as parameters for a generic type::"
msgstr ""
"En generisk typ kan ha ett valfritt antal typvariabler. Alla varianter av :"
"class:`TypeVar` är tillåtna som parametrar för en generisk typ::"

msgid ""
"from typing import TypeVar, Generic, Sequence\n"
"\n"
"class WeirdTrio[T, B: Sequence[bytes], S: (int, str)]:\n"
"    ...\n"
"\n"
"OldT = TypeVar('OldT', contravariant=True)\n"
"OldB = TypeVar('OldB', bound=Sequence[bytes], covariant=True)\n"
"OldS = TypeVar('OldS', int, str)\n"
"\n"
"class OldWeirdTrio(Generic[OldT, OldB, OldS]):\n"
"    ..."
msgstr ""
"from typing import TypeVar, Generic, Sequence\n"
"\n"
"class WeirdTrio[T, B: Sequence[bytes], S: (int, str)]:\n"
"    ...\n"
"\n"
"OldT = TypeVar('OldT', contravariant=True)\n"
"OldB = TypeVar('OldB', bound=Sequence[bytes], covariant=True)\n"
"OldS = TypeVar('OldS', int, str)\n"
"\n"
"class OldWeirdTrio(Generic[OldT, OldB, OldS]):\n"
"    ..."

msgid ""
"Each type variable argument to :class:`Generic` must be distinct. This is "
"thus invalid::"
msgstr ""
"Varje typvariabelargument till :class:`Generic` måste vara distinkt. Detta "
"är alltså ogiltigt:"

msgid ""
"from typing import TypeVar, Generic\n"
"...\n"
"\n"
"class Pair[M, M]:  # SyntaxError\n"
"    ...\n"
"\n"
"T = TypeVar('T')\n"
"\n"
"class Pair(Generic[T, T]):   # INVALID\n"
"    ..."
msgstr ""
"from typing import TypeVar, Generisk\n"
"...\n"
"\n"
"klassen Par[M, M]:  # Syntaxfel\n"
"    ...\n"
"\n"
"T = TypVar('T')\n"
"\n"
"klass Par(Generisk[T, T]):   # INVALID\n"
"    ..."

msgid "Generic classes can also inherit from other classes::"
msgstr "Generiska klasser kan också ärva från andra klasser::"

msgid ""
"from collections.abc import Sized\n"
"\n"
"class LinkedList[T](Sized):\n"
"    ..."
msgstr ""
"från collections.abc import Sized\n"
"\n"
"class LinkedList[T](Sized):\n"
"    ..."

msgid ""
"When inheriting from generic classes, some type parameters could be fixed::"
msgstr "När man ärvde från generiska klasser kunde vissa typparametrar fixas::"

msgid ""
"from collections.abc import Mapping\n"
"\n"
"class MyDict[T](Mapping[str, T]):\n"
"    ..."
msgstr ""
"från collections.abc import Mapping\n"
"\n"
"class MyDict[T](Mapping[str, T]):\n"
"    ..."

msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr "I det här fallet har ``MyDict`` en enda parameter, ``T``."

msgid ""
"Using a generic class without specifying type parameters assumes :data:`Any` "
"for each position. In the following example, ``MyIterable`` is not generic "
"but implicitly inherits from ``Iterable[Any]``:"
msgstr ""
"Om man använder en generisk klass utan att ange typparametrar antas :data:"
"`Any` för varje position. I följande exempel är ``MyIterable`` inte generisk "
"utan ärver implicit från ``Iterable[Any]``:"

msgid ""
"from collections.abc import Iterable\n"
"\n"
"class MyIterable(Iterable): # Same as Iterable[Any]\n"
"    ..."
msgstr ""
"från collections.abc import Iterable\n"
"\n"
"klass MyIterable(Iterable): # Samma som Iterable[Any]\n"
"    ..."

msgid "User-defined generic type aliases are also supported. Examples::"
msgstr "Användardefinierade alias för generiska typer stöds också. Exempel::"

msgid ""
"from collections.abc import Iterable\n"
"\n"
"type Response[S] = Iterable[S] | int\n"
"\n"
"# Return type here is same as Iterable[str] | int\n"
"def response(query: str) -> Response[str]:\n"
"    ...\n"
"\n"
"type Vec[T] = Iterable[tuple[T, T]]\n"
"\n"
"def inproduct[T: (int, float, complex)](v: Vec[T]) -> T: # Same as "
"Iterable[tuple[T, T]]\n"
"    return sum(x*y for x, y in v)"
msgstr ""
"från collections.abc import Iterable\n"
"\n"
"type Response[S] = Iterable[S] | int\n"
"\n"
"# Returtypen här är samma som Iterable[str] | int\n"
"def response(query: str) -> Response[str]:\n"
"    ...\n"
"\n"
"type Vec[T] = Iterabel[tuple[T, T]]\n"
"\n"
"def inproduct[T: (int, float, complex)](v: Vec[T]) -> T: # Samma som "
"Iterable[tuple[T, T]]\n"
"    return sum(x*y för x, y i v)"

msgid ""
"For backward compatibility, generic type aliases can also be created through "
"a simple assignment::"
msgstr ""
"För bakåtkompatibilitet kan generiska typaliaser också skapas genom en enkel "
"tilldelning::"

msgid ""
"from collections.abc import Iterable\n"
"from typing import TypeVar\n"
"\n"
"S = TypeVar(\"S\")\n"
"Response = Iterable[S] | int"
msgstr ""
"from collections.abc import Iterable\n"
"from typing import TypeVar\n"
"\n"
"S = TypeVar(\"S\")\n"
"Response = Iterable[S] | int"

msgid ":class:`Generic` no longer has a custom metaclass."
msgstr ":class:`Generic` har inte längre någon egen metaklass."

msgid ""
"Syntactic support for generics and type aliases is new in version 3.12. "
"Previously, generic classes had to explicitly inherit from :class:`Generic` "
"or contain a type variable in one of their bases."
msgstr ""
"Syntaktiskt stöd för generiska klasser och typalias är nytt i version 3.12. "
"Tidigare var generiska klasser tvungna att uttryckligen ärva från :class:"
"`Generic` eller innehålla en typvariabel i en av sina baser."

msgid ""
"User-defined generics for parameter expressions are also supported via "
"parameter specification variables in the form ``[**P]``.  The behavior is "
"consistent with type variables' described above as parameter specification "
"variables are treated by the :mod:`!typing` module as a specialized type "
"variable.  The one exception to this is that a list of types can be used to "
"substitute a :class:`ParamSpec`::"
msgstr ""
"Användardefinierad generik för parameteruttryck stöds också via "
"parameterspecifikationsvariabler i formen ``[**P]``.  Beteendet "
"överensstämmer med typvariabler som beskrivs ovan eftersom "
"parameterspecifikationsvariabler behandlas av modulen :mod:`!typing` som en "
"specialiserad typvariabel.  Det enda undantaget från detta är att en lista "
"med typer kan användas för att ersätta en :class:`ParamSpec`::"

msgid ""
">>> class Z[T, **P]: ...  # T is a TypeVar; P is a ParamSpec\n"
"...\n"
">>> Z[int, [dict, float]]\n"
"__main__.Z[int, [dict, float]]"
msgstr ""
">>> klass Z[T, **P]: ...  # T är en TypeVar; P är en ParamSpec\n"
"...\n"
">>> Z[int, [dict, float]]\n"
"__main__.Z[int, [dict, float]]"

msgid ""
"Classes generic over a :class:`ParamSpec` can also be created using explicit "
"inheritance from :class:`Generic`. In this case, ``**`` is not used::"
msgstr ""
"Klasser som är generiska över en :class:`ParamSpec` kan också skapas med "
"hjälp av explicit arv från :class:`Generic`. I detta fall används inte "
"``**``:"

msgid ""
"from typing import ParamSpec, Generic\n"
"\n"
"P = ParamSpec('P')\n"
"\n"
"class Z(Generic[P]):\n"
"    ..."
msgstr ""
"from typing import ParamSpec, Generisk\n"
"\n"
"P = ParamSpec('P')\n"
"\n"
"klass Z(Generisk[P]):\n"
"    ..."

msgid ""
"Another difference between :class:`TypeVar` and :class:`ParamSpec` is that a "
"generic with only one parameter specification variable will accept parameter "
"lists in the forms ``X[[Type1, Type2, ...]]`` and also ``X[Type1, "
"Type2, ...]`` for aesthetic reasons.  Internally, the latter is converted to "
"the former, so the following are equivalent::"
msgstr ""
"En annan skillnad mellan :class:`TypeVar` och :class:`ParamSpec` är att en "
"generik med endast en parameterspecifikationsvariabel kommer att acceptera "
"parameterlistor i formerna ``X[[Type1, Type2, ...]]`` och även ``X[Type1, "
"Type2, ...]`` av estetiska skäl.  Internt konverteras den senare till den "
"förra, så följande är likvärdiga::"

msgid ""
">>> class X[**P]: ...\n"
"...\n"
">>> X[int, str]\n"
"__main__.X[[int, str]]\n"
">>> X[[int, str]]\n"
"__main__.X[[int, str]]"
msgstr ""
">>> klass X[**P]: ...\n"
"...\n"
">>> X[int, str]\n"
"__main__.X[[int, str]] >>> X[[int, str]]\n"
">>> X[[int, str]]\n"
"__main__.X[[int, str]] >>> X[[int, str]]"

msgid ""
"Note that generics with :class:`ParamSpec` may not have correct "
"``__parameters__`` after substitution in some cases because they are "
"intended primarily for static type checking."
msgstr ""
"Observera att generiker med :class:`ParamSpec` kanske inte har korrekta "
"``__parametrar__`` efter substitution i vissa fall eftersom de främst är "
"avsedda för statisk typkontroll."

msgid ""
":class:`Generic` can now be parameterized over parameter expressions. See :"
"class:`ParamSpec` and :pep:`612` for more details."
msgstr ""
":class:`Generic` kan nu parametriseras över parameteruttryck. Se :class:"
"`ParamSpec` och :pep:`612` för mer information."

msgid ""
"A user-defined generic class can have ABCs as base classes without a "
"metaclass conflict. Generic metaclasses are not supported. The outcome of "
"parameterizing generics is cached, and most types in the :mod:`!typing` "
"module are :term:`hashable` and comparable for equality."
msgstr ""
"En användardefinierad generisk klass kan ha ABC som basklasser utan att det "
"uppstår en metaklasskonflikt. Generiska metaklasser stöds inte. Resultatet "
"av parametrisering av generiska klasser cachas och de flesta typer i "
"modulen :mod:`!typing` är :term:`hashable` och jämförbara med avseende på "
"likhet."

msgid "The :data:`Any` type"
msgstr ":data:`Vilken typ som helst"

msgid ""
"A special kind of type is :data:`Any`. A static type checker will treat "
"every type as being compatible with :data:`Any` and :data:`Any` as being "
"compatible with every type."
msgstr ""
"En speciell typ av typ är :data:`Any`. En statisk typkontroll kommer att "
"behandla varje typ som kompatibel med :data:`Any` och :data:`Any` som "
"kompatibel med varje typ."

msgid ""
"This means that it is possible to perform any operation or method call on a "
"value of type :data:`Any` and assign it to any variable::"
msgstr ""
"Detta innebär att det är möjligt att utföra valfri operation eller "
"metodanrop på ett värde av typen :data:`Any` och tilldela det till valfri "
"variabel::"

msgid ""
"from typing import Any\n"
"\n"
"a: Any = None\n"
"a = []          # OK\n"
"a = 2           # OK\n"
"\n"
"s: str = ''\n"
"s = a           # OK\n"
"\n"
"def foo(item: Any) -> int:\n"
"    # Passes type checking; 'item' could be any type,\n"
"    # and that type might have a 'bar' method\n"
"    item.bar()\n"
"    ..."
msgstr ""
"från typing import Any\n"
"\n"
"a: Vilken som helst = Ingen\n"
"a = [] # OK\n"
"a = 2 # OK\n"
"\n"
"s: str = ''\n"
"s = a # OK\n"
"\n"
"def foo(objekt: valfritt) -> int:\n"
"    # Klarar typkontroll; 'item' kan vara vilken typ som helst,\n"
"    # och den typen kan ha en \"bar\"-metod\n"
"    item.bar()\n"
"    ..."

msgid ""
"Notice that no type checking is performed when assigning a value of type :"
"data:`Any` to a more precise type. For example, the static type checker did "
"not report an error when assigning ``a`` to ``s`` even though ``s`` was "
"declared to be of type :class:`str` and receives an :class:`int` value at "
"runtime!"
msgstr ""
"Observera att ingen typkontroll utförs när ett värde av typen :data:`Any` "
"tilldelas till en mer exakt typ. Till exempel rapporterade den statiska "
"typkontrollen inte ett fel när ``a`` tilldelades ``s`` trots att ``s`` "
"deklarerades vara av typen :class:`str` och får ett värde av typen :class:"
"`int` vid körning!"

msgid ""
"Furthermore, all functions without a return type or parameter types will "
"implicitly default to using :data:`Any`::"
msgstr ""
"Dessutom kommer alla funktioner utan returtyp eller parametertyper att "
"implicit använda :data:`Any`::"

msgid ""
"def legacy_parser(text):\n"
"    ...\n"
"    return data\n"
"\n"
"# A static type checker will treat the above\n"
"# as having the same signature as:\n"
"def legacy_parser(text: Any) -> Any:\n"
"    ...\n"
"    return data"
msgstr ""
"def legacy_parser(text):\n"
"    ...\n"
"    returnera data\n"
"\n"
"# En statisk typkontroll kommer att behandla ovanstående\n"
"# som att den har samma signatur som:\n"
"def legacy_parser(text: Any) -> Any:\n"
"    ...\n"
"    returnerar data"

msgid ""
"This behavior allows :data:`Any` to be used as an *escape hatch* when you "
"need to mix dynamically and statically typed code."
msgstr ""
"Detta beteende gör att :data:`Any` kan användas som en *escape-lucka* när du "
"behöver blanda dynamiskt och statiskt typad kod."

msgid ""
"Contrast the behavior of :data:`Any` with the behavior of :class:`object`. "
"Similar to :data:`Any`, every type is a subtype of :class:`object`. However, "
"unlike :data:`Any`, the reverse is not true: :class:`object` is *not* a "
"subtype of every other type."
msgstr ""
"Kontrastera beteendet hos :data:`Any` med beteendet hos :class:`object`. I "
"likhet med :data:`Any` är varje typ en subtyp av :class:`object`. Men till "
"skillnad från :data:`Any` är det omvända inte sant: :class:`object` är "
"*inte* en subtyp av alla andra typer."

msgid ""
"That means when the type of a value is :class:`object`, a type checker will "
"reject almost all operations on it, and assigning it to a variable (or using "
"it as a return value) of a more specialized type is a type error. For "
"example::"
msgstr ""
"Det innebär att när typen av ett värde är :class:`object`, kommer en "
"typkontroll att avvisa nästan alla operationer på det, och att tilldela det "
"till en variabel (eller använda det som ett returvärde) av en mer "
"specialiserad typ är ett typfel. Till exempel::"

msgid ""
"def hash_a(item: object) -> int:\n"
"    # Fails type checking; an object does not have a 'magic' method.\n"
"    item.magic()\n"
"    ...\n"
"\n"
"def hash_b(item: Any) -> int:\n"
"    # Passes type checking\n"
"    item.magic()\n"
"    ...\n"
"\n"
"# Passes type checking, since ints and strs are subclasses of object\n"
"hash_a(42)\n"
"hash_a(\"foo\")\n"
"\n"
"# Passes type checking, since Any is compatible with all types\n"
"hash_b(42)\n"
"hash_b(\"foo\")"
msgstr ""
"def hash_a(item: objekt) -> int:\n"
"    # Misslyckas med typkontroll; ett objekt har inte en \"magic\"-metod.\n"
"    objekt.magic()\n"
"    ...\n"
"\n"
"def hash_b(item: valfritt) -> int:\n"
"    # Klarar typkontroll\n"
"    item.magic()\n"
"    ...\n"
"\n"
"# Klarar typkontroll, eftersom ints och strs är subklasser av objekt\n"
"hash_a(42)\n"
"hash_a(\"foo\")\n"
"\n"
"# Klarar typkontroll, eftersom Any är kompatibel med alla typer\n"
"hash_b(42)\n"
"hash_b(\"foo\")"

msgid ""
"Use :class:`object` to indicate that a value could be any type in a typesafe "
"manner. Use :data:`Any` to indicate that a value is dynamically typed."
msgstr ""
"Använd :class:`object` för att ange att ett värde kan vara av vilken typ som "
"helst på ett typsäkert sätt. Använd :data:`Any` för att ange att ett värde "
"är dynamiskt typat."

msgid "Nominal vs structural subtyping"
msgstr "Nominell kontra strukturell subtypning"

msgid ""
"Initially :pep:`484` defined the Python static type system as using *nominal "
"subtyping*. This means that a class ``A`` is allowed where a class ``B`` is "
"expected if and only if ``A`` is a subclass of ``B``."
msgstr ""
"Ursprungligen definierade :pep:`484` Pythons statiska typsystem som att det "
"använder *nominal subtyping*. Detta innebär att en klass ``A`` är tillåten "
"där en klass ``B`` förväntas om och endast om ``A`` är en subklass av ``B``."

msgid ""
"This requirement previously also applied to abstract base classes, such as :"
"class:`~collections.abc.Iterable`. The problem with this approach is that a "
"class had to be explicitly marked to support them, which is unpythonic and "
"unlike what one would normally do in idiomatic dynamically typed Python "
"code. For example, this conforms to :pep:`484`::"
msgstr ""
"Detta krav gällde tidigare även för abstrakta basklasser, såsom :class:"
"`~collections.abc.Iterable`. Problemet med detta tillvägagångssätt är att en "
"klass måste markeras explicit för att stödja dem, vilket är opytoniskt och "
"olikt vad man normalt skulle göra i idiomatisk dynamiskt typad Python-kod. "
"Till exempel överensstämmer detta med :pep:`484`::"

msgid ""
"from collections.abc import Sized, Iterable, Iterator\n"
"\n"
"class Bucket(Sized, Iterable[int]):\n"
"    ...\n"
"    def __len__(self) -> int: ...\n"
"    def __iter__(self) -> Iterator[int]: ..."
msgstr ""
"from collections.abc import Sized, Iterable, Iterator\n"
"\n"
"class Bucket(Sized, Iterable[int]):\n"
"    ...\n"
"    def __len__(self) -> int: ...\n"
"    def __iter__(self) -> Iterator[int]: ..."

msgid ""
":pep:`544` allows to solve this problem by allowing users to write the above "
"code without explicit base classes in the class definition, allowing "
"``Bucket`` to be implicitly considered a subtype of both ``Sized`` and "
"``Iterable[int]`` by static type checkers. This is known as *structural "
"subtyping* (or static duck-typing)::"
msgstr ""
":pep:`544` löser detta problem genom att tillåta användare att skriva "
"ovanstående kod utan explicita basklasser i klassdefinitionen, vilket gör "
"att ``Bucket`` implicit kan betraktas som en subtyp av både ``Sized`` och "
"``Iterable[int]`` av statiska typkontroller. Detta är känt som *strukturell "
"subtypning* (eller statisk duck-typning)::"

msgid ""
"from collections.abc import Iterator, Iterable\n"
"\n"
"class Bucket:  # Note: no base classes\n"
"    ...\n"
"    def __len__(self) -> int: ...\n"
"    def __iter__(self) -> Iterator[int]: ...\n"
"\n"
"def collect(items: Iterable[int]) -> int: ...\n"
"result = collect(Bucket())  # Passes type check"
msgstr ""
"från collections.abc import Iterator, Iterable\n"
"\n"
"klassen Bucket:  # Obs: inga basklasser\n"
"    ...\n"
"    def __len__(self) -> int: ...\n"
"    def __iter__(self) -> Iterator[int]: ...\n"
"\n"
"def collect(items: Iterable[int]) -> int: ...\n"
"result = collect(Bucket()) # Klarar typkontroll"

msgid ""
"Moreover, by subclassing a special class :class:`Protocol`, a user can "
"define new custom protocols to fully enjoy structural subtyping (see "
"examples below)."
msgstr ""
"Genom att subklassa en speciell klass :class:`Protocol` kan en användare "
"dessutom definiera nya anpassade protokoll för att fullt ut utnyttja "
"strukturell subtypning (se exempel nedan)."

msgid "Module contents"
msgstr "Modulens innehåll"

msgid ""
"The ``typing`` module defines the following classes, functions and "
"decorators."
msgstr ""
"Modulen ``typing`` definierar följande klasser, funktioner och dekoratorer."

msgid "Special typing primitives"
msgstr "Särskilda typningsprimitiver"

msgid "Special types"
msgstr "Särskilda typer"

msgid ""
"These can be used as types in annotations. They do not support subscription "
"using ``[]``."
msgstr ""
"Dessa kan användas som typer i annoteringar. De stöder inte prenumeration "
"med hjälp av ``[]``."

msgid "Special type indicating an unconstrained type."
msgstr "Särskild typ som anger en obegränsad typ."

msgid "Every type is compatible with :data:`Any`."
msgstr "Varje typ är kompatibel med :data:`Any`."

msgid ":data:`Any` is compatible with every type."
msgstr ":data:`Any` är kompatibel med alla typer."

msgid ""
":data:`Any` can now be used as a base class. This can be useful for avoiding "
"type checker errors with classes that can duck type anywhere or are highly "
"dynamic."
msgstr ""
":data:`Any` kan nu användas som basklass. Detta kan vara användbart för att "
"undvika fel i typkontrollerna för klasser som kan få typ var som helst eller "
"som är mycket dynamiska."

msgid "A :ref:`constrained type variable <typing-constrained-typevar>`."
msgstr "En :ref:`begränsad typvariabel <typing-constrained-typevar>`."

msgid "Definition::"
msgstr "Definition::"

msgid "AnyStr = TypeVar('AnyStr', str, bytes)"
msgstr "AnyStr = TypeVar('AnyStr', str, bytes)"

msgid ""
"``AnyStr`` is meant to be used for functions that may accept :class:`str` "
"or :class:`bytes` arguments but cannot allow the two to mix."
msgstr ""
"``AnyStr`` är avsedd att användas för funktioner som kan acceptera :class:"
"`str` eller :class:`bytes` argument men som inte kan tillåta att de två "
"blandas."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"def concat(a: AnyStr, b: AnyStr) -> AnyStr:\n"
"    return a + b\n"
"\n"
"concat(\"foo\", \"bar\")    # OK, output has type 'str'\n"
"concat(b\"foo\", b\"bar\")  # OK, output has type 'bytes'\n"
"concat(\"foo\", b\"bar\")   # Error, cannot mix str and bytes"
msgstr ""
"def concat(a: AnyStr, b: AnyStr) -> AnyStr:\n"
"    returnerar a + b\n"
"\n"
"concat(\"foo\", \"bar\") # OK, utdata har typen 'str'\n"
"concat(b\"foo\", b\"bar\") # OK, utdata har typen 'bytes'\n"
"concat(\"foo\", b\"bar\") # Fel, kan inte blanda str och bytes"

msgid ""
"Note that, despite its name, ``AnyStr`` has nothing to do with the :class:"
"`Any` type, nor does it mean \"any string\". In particular, ``AnyStr`` and "
"``str | bytes`` are different from each other and have different use cases::"
msgstr ""
"Observera att trots sitt namn har ``AnyStr`` inget att göra med typen :class:"
"`Any`` och betyder inte heller \"vilken sträng som helst\". I synnerhet "
"skiljer sig ``AnyStr`` och ``str | bytes`` från varandra och har olika "
"användningsområden::"

msgid ""
"# Invalid use of AnyStr:\n"
"# The type variable is used only once in the function signature,\n"
"# so cannot be \"solved\" by the type checker\n"
"def greet_bad(cond: bool) -> AnyStr:\n"
"    return \"hi there!\" if cond else b\"greetings!\"\n"
"\n"
"# The better way of annotating this function:\n"
"def greet_proper(cond: bool) -> str | bytes:\n"
"    return \"hi there!\" if cond else b\"greetings!\""
msgstr ""
"# Ogiltig användning av AnyStr:\n"
"# Typvariabeln används bara en gång i funktionssignaturen,\n"
"# så den kan inte \"lösas\" av typkontrollen\n"
"def greet_bad(cond: bool) -> AnyStr:\n"
"    return \"hej där!\" if cond else b\"hälsningar!\"\n"
"\n"
"# Det bättre sättet att kommentera den här funktionen:\n"
"def greet_proper(cond: bool) -> str | bytes:\n"
"    return \"hej där!\" if cond else b\"hälsningar!\""

msgid ""
"Deprecated in favor of the new :ref:`type parameter syntax <type-params>`. "
"Use ``class A[T: (str, bytes)]: ...`` instead of importing ``AnyStr``. See :"
"pep:`695` for more details."
msgstr ""
"Föråldrad till förmån för den nya :ref:`typ parametersyntaxen <type-"
"params>`. Använd ``class A[T: (str, bytes)]: ...`` istället för att "
"importera ``AnyStr``. Se :pep:`695` för mer information."

msgid ""
"In Python 3.16, ``AnyStr`` will be removed from ``typing.__all__``, and "
"deprecation warnings will be emitted at runtime when it is accessed or "
"imported from ``typing``. ``AnyStr`` will be removed from ``typing`` in "
"Python 3.18."
msgstr ""
"I Python 3.16 kommer ``AnyStr`` att tas bort från ``typing.__all__``, och "
"deprecation-varningar kommer att utfärdas vid körning när den nås eller "
"importeras från ``typing``. ``AnyStr`` kommer att tas bort från ``typing`` i "
"Python 3.18."

msgid "Special type that includes only literal strings."
msgstr "Speciell typ som endast innehåller bokstavliga strängar."

msgid ""
"Any string literal is compatible with ``LiteralString``, as is another "
"``LiteralString``. However, an object typed as just ``str`` is not. A string "
"created by composing ``LiteralString``-typed objects is also acceptable as a "
"``LiteralString``."
msgstr ""
"Alla bokstavliga strängar är kompatibla med ``LiteralString``, liksom en "
"annan ``LiteralString``. Men ett objekt typat som bara ``str`` är inte det. "
"En sträng som skapas genom att komponera ``LiteralString``-typade objekt är "
"också acceptabel som en ``LiteralString``."

msgid "Example:"
msgstr "Exempel:"

msgid ""
"def run_query(sql: LiteralString) -> None:\n"
"    ...\n"
"\n"
"def caller(arbitrary_string: str, literal_string: LiteralString) -> None:\n"
"    run_query(\"SELECT * FROM students\")  # OK\n"
"    run_query(literal_string)  # OK\n"
"    run_query(\"SELECT * FROM \" + literal_string)  # OK\n"
"    run_query(arbitrary_string)  # type checker error\n"
"    run_query(  # type checker error\n"
"        f\"SELECT * FROM students WHERE name = {arbitrary_string}\"\n"
"    )"
msgstr ""
"def run_query(sql: LiteralString) -> Ingen:\n"
"    ...\n"
"\n"
"def caller(arbitrary_string: str, literal_string: LiteralString) -> None:\n"
"    run_query(\"SELECT * FROM studenter\") # OK\n"
"    run_query(litteral_sträng) # OK\n"
"    run_query(\"SELECT * FROM \" + literal_string) # OK\n"
"    run_query(godtycklig_sträng) # typkontrollfel\n"
"    run_query( # typkontrollfel\n"
"        f\"SELECT * FROM studenter WHERE namn = {arbitrary_string}\"\n"
"    )"

msgid ""
"``LiteralString`` is useful for sensitive APIs where arbitrary user-"
"generated strings could generate problems. For example, the two cases above "
"that generate type checker errors could be vulnerable to an SQL injection "
"attack."
msgstr ""
"``LiteralString`` är användbart för känsliga API:er där godtyckliga "
"användargenererade strängar kan skapa problem. Till exempel kan de två "
"fallen ovan som genererar typkontrollfel vara sårbara för en SQL-"
"injektionsattack."

msgid "See :pep:`675` for more details."
msgstr "Se :pep:`675` för mer information."

msgid ""
":data:`!Never` and :data:`!NoReturn` represent the `bottom type <https://en."
"wikipedia.org/wiki/Bottom_type>`_, a type that has no members."
msgstr ""
":data:`!Never` och :data:`!NoReturn` representerar `bottentypen <https://en."
"wikipedia.org/wiki/Bottom_type>`_, en typ som inte har några medlemmar."

msgid ""
"They can be used to indicate that a function never returns, such as :func:"
"`sys.exit`::"
msgstr ""
"De kan användas för att ange att en funktion aldrig återkommer, t.ex. :func:"
"`sys.exit`::"

msgid ""
"from typing import Never  # or NoReturn\n"
"\n"
"def stop() -> Never:\n"
"    raise RuntimeError('no way')"
msgstr ""
"från typning import Aldrig # eller NoReturn\n"
"\n"
"def stop() -> Aldrig:\n"
"    raise RuntimeError('inget sätt')"

msgid ""
"Or to define a function that should never be called, as there are no valid "
"arguments, such as :func:`assert_never`::"
msgstr ""
"Eller för att definiera en funktion som aldrig ska anropas, eftersom det "
"inte finns några giltiga argument, t.ex. :func:`assert_never`::"

msgid ""
"from typing import Never  # or NoReturn\n"
"\n"
"def never_call_me(arg: Never) -> None:\n"
"    pass\n"
"\n"
"def int_or_str(arg: int | str) -> None:\n"
"    never_call_me(arg)  # type checker error\n"
"    match arg:\n"
"        case int():\n"
"            print(\"It's an int\")\n"
"        case str():\n"
"            print(\"It's a str\")\n"
"        case _:\n"
"            never_call_me(arg)  # OK, arg is of type Never (or NoReturn)"
msgstr ""
"från typning import Aldrig # eller NoReturn\n"
"\n"
"def never_call_me(arg: Never) -> None:\n"
"    pass\n"
"\n"
"def int_or_str(arg: int | str) -> None:\n"
"    never_call_me(arg) # typkontrollfel\n"
"    matcha arg:\n"
"        fall int():\n"
"            print(\"Det är en int\")\n"
"        fall str():\n"
"            print(\"Det är en str\")\n"
"        fall _:\n"
"            never_call_me(arg) # OK, arg är av typen Never (eller NoReturn)"

msgid ""
":data:`!Never` and :data:`!NoReturn` have the same meaning in the type "
"system and static type checkers treat both equivalently."
msgstr ""
":data:`!Never` och :data:`!NoReturn` har samma betydelse i typsystemet och "
"statiska typkontroller behandlar båda likvärdigt."

msgid "Added :data:`NoReturn`."
msgstr "Lagt till :data:`NoReturn`."

msgid "Added :data:`Never`."
msgstr "Lagt till :data:`Never`."

msgid "Special type to represent the current enclosed class."
msgstr "Speciell typ för att representera den aktuella inneslutna klassen."

msgid ""
"from typing import Self, reveal_type\n"
"\n"
"class Foo:\n"
"    def return_self(self) -> Self:\n"
"        ...\n"
"        return self\n"
"\n"
"class SubclassOfFoo(Foo): pass\n"
"\n"
"reveal_type(Foo().return_self())  # Revealed type is \"Foo\"\n"
"reveal_type(SubclassOfFoo().return_self())  # Revealed type is "
"\"SubclassOfFoo\""
msgstr ""
"från typing import Self, reveal_type\n"
"\n"
"klass Foo:\n"
"    def return_self(self) -> Self:\n"
"        ...\n"
"        returnera själv\n"
"\n"
"klass SubclassOfFoo(Foo): pass\n"
"\n"
"reveal_type(Foo().return_self()) # Avslöjad typ är \"Foo\"\n"
"reveal_type(SubclassOfFoo().return_self()) # Avslöjad typ är "
"\"SubclassOfFoo\""

msgid ""
"This annotation is semantically equivalent to the following, albeit in a "
"more succinct fashion::"
msgstr ""
"Denna annotation är semantiskt likvärdig med följande, om än på ett mer "
"kortfattat sätt::"

msgid ""
"from typing import TypeVar\n"
"\n"
"Self = TypeVar(\"Self\", bound=\"Foo\")\n"
"\n"
"class Foo:\n"
"    def return_self(self: Self) -> Self:\n"
"        ...\n"
"        return self"
msgstr ""
"från typing import TypeVar\n"
"\n"
"Self = TypeVar(\"Self\", bound=\"Foo\")\n"
"\n"
"klass Foo:\n"
"    def return_self(self: Self) -> Self:\n"
"        ...\n"
"        returnera själv"

msgid ""
"In general, if something returns ``self``, as in the above examples, you "
"should use ``Self`` as the return annotation. If ``Foo.return_self`` was "
"annotated as returning ``\"Foo\"``, then the type checker would infer the "
"object returned from ``SubclassOfFoo.return_self`` as being of type ``Foo`` "
"rather than ``SubclassOfFoo``."
msgstr ""
"I allmänhet, om något returnerar ``self``, som i exemplen ovan, bör du "
"använda ``Self`` som returannotering. Om ``Foo.return_self`` annoterades som "
"att returnera ``\"Foo\"``, skulle typkontrollen härleda objektet som "
"returneras från ``SubclassOfFoo.return_self`` som att vara av typen ``Foo`` "
"snarare än ``SubclassOfFoo``."

msgid "Other common use cases include:"
msgstr "Andra vanliga användningsområden är t.ex:"

msgid ""
":class:`classmethod`\\s that are used as alternative constructors and return "
"instances of the ``cls`` parameter."
msgstr ""
":class:`classmethod` som används som alternativa konstruktörer och "
"returnerar instanser av parametern ``cls``."

msgid "Annotating an :meth:`~object.__enter__` method which returns self."
msgstr "Anteckna en :meth:`~object.__enter__`-metod som returnerar self."

msgid ""
"You should not use ``Self`` as the return annotation if the method is not "
"guaranteed to return an instance of a subclass when the class is subclassed::"
msgstr ""
"Du bör inte använda ``Self`` som returannotering om metoden inte garanterat "
"returnerar en instans av en underklass när klassen är underklassad::"

msgid ""
"class Eggs:\n"
"    # Self would be an incorrect return annotation here,\n"
"    # as the object returned is always an instance of Eggs,\n"
"    # even in subclasses\n"
"    def returns_eggs(self) -> \"Eggs\":\n"
"        return Eggs()"
msgstr ""
"klass Ägg:\n"
"    # Själv skulle vara en felaktig returannotering här,\n"
"    # eftersom objektet som returneras alltid är en instans av Eggs,\n"
"    # även i underklasser\n"
"    def returns_eggs(self) -> \"Ägg\":\n"
"        returnerar Eggs()"

msgid "See :pep:`673` for more details."
msgstr "Se :pep:`673` för mer information."

msgid ""
"Special annotation for explicitly declaring a :ref:`type alias <type-"
"aliases>`."
msgstr ""
"Särskild annotering för att explicit deklarera en :ref:`typ alias <type-"
"aliases>`."

msgid ""
"from typing import TypeAlias\n"
"\n"
"Factors: TypeAlias = list[int]"
msgstr ""
"från typing import TypeAlias\n"
"\n"
"Faktorer: TypeAlias = lista[int]"

msgid ""
"``TypeAlias`` is particularly useful on older Python versions for annotating "
"aliases that make use of forward references, as it can be hard for type "
"checkers to distinguish these from normal variable assignments:"
msgstr ""
"``TypeAlias`` är särskilt användbart på äldre Python-versioner för att "
"annotera alias som använder sig av framåtriktade referenser, eftersom det "
"kan vara svårt för typkontrollanter att skilja dessa från normala "
"variabeltilldelningar:"

msgid ""
"from typing import Generic, TypeAlias, TypeVar\n"
"\n"
"T = TypeVar(\"T\")\n"
"\n"
"# \"Box\" does not exist yet,\n"
"# so we have to use quotes for the forward reference on Python <3.12.\n"
"# Using ``TypeAlias`` tells the type checker that this is a type alias "
"declaration,\n"
"# not a variable assignment to a string.\n"
"BoxOfStrings: TypeAlias = \"Box[str]\"\n"
"\n"
"class Box(Generic[T]):\n"
"    @classmethod\n"
"    def make_box_of_strings(cls) -> BoxOfStrings: ..."
msgstr ""
"from typing import Generisk, TypeAlias, TypeVar\n"
"\n"
"T = TypeVar(\"T\")\n"
"\n"
"# \"Box\" existerar inte ännu,\n"
"# så vi måste använda citattecken för den framåtriktade referensen på Python "
"<3.12.\n"
"# Att använda ``TypeAlias`` talar om för typkontrollanten att detta är en "
"aliasdeklaration,\n"
"# inte en variabeltilldelning till en sträng.\n"
"BoxOfStrings: TypeAlias = \"Box[str]\"\n"
"\n"
"klass Box(Generic[T]):\n"
"    @klassmetod\n"
"    def make_box_of_strings(cls) -> BoxOfStrings: ..."

msgid "See :pep:`613` for more details."
msgstr "Se :pep:`613` för mer information."

msgid ""
":data:`TypeAlias` is deprecated in favor of the :keyword:`type` statement, "
"which creates instances of :class:`TypeAliasType` and which natively "
"supports forward references. Note that while :data:`TypeAlias` and :class:"
"`TypeAliasType` serve similar purposes and have similar names, they are "
"distinct and the latter is not the type of the former. Removal of :data:"
"`TypeAlias` is not currently planned, but users are encouraged to migrate "
"to :keyword:`type` statements."
msgstr ""
":data:`TypeAlias` är avfört till förmån för :keyword:`type`-satsen, som "
"skapar instanser av :class:`TypeAliasType` och som stöder framåtriktade "
"referenser. Observera att även om :data:`TypeAlias` och :class:"
"`TypeAliasType` tjänar liknande syften och har liknande namn, är de "
"distinkta och den senare är inte typen av den förra. Avlägsnande av :data:"
"`TypeAlias` är för närvarande inte planerat, men användare uppmuntras att "
"migrera till :keyword:`type`-satser."

msgid "Special forms"
msgstr "Särskilda formulär"

msgid ""
"These can be used as types in annotations. They all support subscription "
"using ``[]``, but each has a unique syntax."
msgstr ""
"Dessa kan användas som typer i annoteringar. De stöder alla prenumeration "
"med hjälp av ``[]``, men varje har en unik syntax."

msgid ""
"Union type; ``Union[X, Y]`` is equivalent to ``X | Y`` and means either X or "
"Y."
msgstr ""
"Unionstyp; ``Union[X, Y]`` är ekvivalent med ``X | Y`` och betyder antingen "
"X eller Y."

msgid ""
"To define a union, use e.g. ``Union[int, str]`` or the shorthand ``int | "
"str``. Using that shorthand is recommended. Details:"
msgstr ""
"För att definiera en union, använd t.ex. ``Union[int, str]`` eller "
"kortformen ``int | str``. Det är rekommenderat att använda den kortformen. "
"Mer information:"

msgid "The arguments must be types and there must be at least one."
msgstr "Argumenten måste vara typer och det måste finnas minst ett."

msgid "Unions of unions are flattened, e.g.::"
msgstr "Unioner av unioner är tillplattade, t.ex.::"

msgid "Union[Union[int, str], float] == Union[int, str, float]"
msgstr "Union[Union[int, str], float] == Union[int, str, float]"

msgid ""
"However, this does not apply to unions referenced through a type alias, to "
"avoid forcing evaluation of the underlying :class:`TypeAliasType`::"
msgstr ""
"Detta gäller dock inte för unioner som refereras till via ett typalias, för "
"att undvika att tvinga fram en utvärdering av den underliggande :class:"
"`TypeAliasType`::"

msgid ""
"type A = Union[int, str]\n"
"Union[A, float] != Union[int, str, float]"
msgstr ""
"typ A = Union[int, str]\n"
"Union[A, float] != Union[int, str, float]"

msgid "Unions of a single argument vanish, e.g.::"
msgstr "Sammanslutningar av ett enda argument försvinner, t.ex.::"

msgid "Union[int] == int  # The constructor actually returns int"
msgstr "Union[int] == int # Konstruktören returnerar faktiskt int"

msgid "Redundant arguments are skipped, e.g.::"
msgstr "Överflödiga argument hoppas över, t.ex.::"

msgid "Union[int, str, int] == Union[int, str] == int | str"
msgstr "Union[int, str, int] == Union[int, str] == int | str"

msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr "Vid jämförelse av unioner ignoreras argumentordningen, t.ex.::"

msgid "Union[int, str] == Union[str, int]"
msgstr "Union[int, str] == Union[str, int]"

msgid "You cannot subclass or instantiate a ``Union``."
msgstr "Du kan inte underklassa eller instansiera en ``Union``."

msgid "You cannot write ``Union[X][Y]``."
msgstr "Du kan inte skriva ``Union[X][Y]``."

msgid "Don't remove explicit subclasses from unions at runtime."
msgstr "Ta inte bort explicita underklasser från unioner vid körning."

msgid ""
"Unions can now be written as ``X | Y``. See :ref:`union type "
"expressions<types-union>`."
msgstr ""
"Unioner kan nu skrivas som ``X | Y``. Se :ref:``unionstyputtryck<types-"
"union>`."

msgid ""
":class:`types.UnionType` is now an alias for :class:`Union`, and both "
"``Union[int, str]`` and ``int | str`` create instances of the same class. To "
"check whether an object is a ``Union`` at runtime, use ``isinstance(obj, "
"Union)``. For compatibility with earlier versions of Python, use "
"``get_origin(obj) is typing.Union or get_origin(obj) is types.UnionType``."
msgstr ""
":class:`types.UnionType` är nu ett alias för :class:`Union`, och både "
"``Union[int, str]`` och ``int | str`` skapar instanser av samma klass. För "
"att kontrollera om ett objekt är en ``Union`` vid runtime, använd "
"``isinstance(obj, Union)``. För kompatibilitet med tidigare versioner av "
"Python, använd ``get_origin(obj) is typing.Union eller get_origin(obj) is "
"types.UnionType``."

msgid "``Optional[X]`` is equivalent to ``X | None`` (or ``Union[X, None]``)."
msgstr ""
"``Optional[X]`` är ekvivalent med ``X | None`` (eller ``Union[X, None]``)."

msgid ""
"Note that this is not the same concept as an optional argument, which is one "
"that has a default.  An optional argument with a default does not require "
"the ``Optional`` qualifier on its type annotation just because it is "
"optional. For example::"
msgstr ""
"Observera att detta inte är samma koncept som ett optionellt argument, "
"vilket är ett argument som har en default.  Ett valfritt argument med en "
"standard kräver inte ``Optional`` kvalifieraren på sin typannotering bara "
"för att det är valfritt. Till exempel::"

msgid ""
"def foo(arg: int = 0) -> None:\n"
"    ..."
msgstr ""
"def foo(arg: int = 0) -> None:\n"
"    ..."

msgid ""
"On the other hand, if an explicit value of ``None`` is allowed, the use of "
"``Optional`` is appropriate, whether the argument is optional or not. For "
"example::"
msgstr ""
"Å andra sidan, om ett explicit värde av ``None`` är tillåtet, är "
"användningen av ``Optional`` lämplig, oavsett om argumentet är valfritt "
"eller inte. Till exempel::"

msgid ""
"def foo(arg: Optional[int] = None) -> None:\n"
"    ..."
msgstr ""
"def foo(arg: Valfritt[int] = Ingen) -> Ingen:\n"
"    ..."

msgid ""
"Optional can now be written as ``X | None``. See :ref:`union type "
"expressions<types-union>`."
msgstr ""
"Optional kan nu skrivas som ``X | None``. Se :ref:``unionstyputtryck<types-"
"union>`."

msgid "Special form for annotating higher-order functions."
msgstr "Särskilt formulär för annotering av funktioner av högre ordning."

msgid ""
"``Concatenate`` can be used in conjunction with :ref:`Callable <annotating-"
"callables>` and :class:`ParamSpec` to annotate a higher-order callable which "
"adds, removes, or transforms parameters of another callable.  Usage is in "
"the form ``Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable]``. "
"``Concatenate`` is currently only valid when used as the first argument to "
"a :ref:`Callable <annotating-callables>`. The last parameter to "
"``Concatenate`` must be a :class:`ParamSpec` or ellipsis (``...``)."
msgstr ""
"``Concatenate`` kan användas tillsammans med :ref:``Callable <annotating-"
"callables>`` och :class:`ParamSpec` för att annotera en högre ordningens "
"callable som lägger till, tar bort eller transformerar parametrar för en "
"annan callable.  Användningen är i formen ``Concatenate[Arg1Type, "
"Arg2Type, ..., ParamSpecVariable]``. ``Concatenate`` är för närvarande "
"endast giltig när den används som det första argumentet till en :ref:"
"`Callable <annotating-callables>`. Den sista parametern till ``Concatenate`` "
"måste vara en :class:`ParamSpec` eller ellips (``...``)."

msgid ""
"For example, to annotate a decorator ``with_lock`` which provides a :class:"
"`threading.Lock` to the decorated function,  ``Concatenate`` can be used to "
"indicate that ``with_lock`` expects a callable which takes in a ``Lock`` as "
"the first argument, and returns a callable with a different type signature.  "
"In this case, the :class:`ParamSpec` indicates that the returned callable's "
"parameter types are dependent on the parameter types of the callable being "
"passed in::"
msgstr ""
"Till exempel, för att annotera en dekorator ``with_lock`` som "
"tillhandahåller en :class:`threading.Lock` till den dekorerade funktionen, "
"kan ``Concatenate`` användas för att indikera att ``with_lock`` förväntar "
"sig en anropbar som tar in en ``Lock`` som första argument, och returnerar "
"en anropbar med en annan typsignatur.  I detta fall indikerar :class:"
"`ParamSpec` att parametertyperna för den returnerade anropbara är beroende "
"av parametertyperna för den anropbara som skickas in::"

msgid ""
"from collections.abc import Callable\n"
"from threading import Lock\n"
"from typing import Concatenate\n"
"\n"
"# Use this lock to ensure that only one thread is executing a function\n"
"# at any time.\n"
"my_lock = Lock()\n"
"\n"
"def with_lock[**P, R](f: Callable[Concatenate[Lock, P], R]) -> Callable[P, "
"R]:\n"
"    '''A type-safe decorator which provides a lock.'''\n"
"    def inner(*args: P.args, **kwargs: P.kwargs) -> R:\n"
"        # Provide the lock as the first argument.\n"
"        return f(my_lock, *args, **kwargs)\n"
"    return inner\n"
"\n"
"@with_lock\n"
"def sum_threadsafe(lock: Lock, numbers: list[float]) -> float:\n"
"    '''Add a list of numbers together in a thread-safe manner.'''\n"
"    with lock:\n"
"        return sum(numbers)\n"
"\n"
"# We don't need to pass in the lock ourselves thanks to the decorator.\n"
"sum_threadsafe([1.1, 2.2, 3.3])"
msgstr ""
"from collections.abc import Callable\n"
"from threading import Lock\n"
"from typing import Concatenate\n"
"\n"
"# Use this lock to ensure that only one thread is executing a function\n"
"# at any time.\n"
"my_lock = Lock()\n"
"\n"
"def with_lock[**P, R](f: Callable[Concatenate[Lock, P], R]) -> Callable[P, "
"R]:\n"
"    '''A type-safe decorator which provides a lock.'''\n"
"    def inner(*args: P.args, **kwargs: P.kwargs) -> R:\n"
"        # Provide the lock as the first argument.\n"
"        return f(my_lock, *args, **kwargs)\n"
"    return inner\n"
"\n"
"@with_lock\n"
"def sum_threadsafe(lock: Lock, numbers: list[float]) -> float:\n"
"    '''Add a list of numbers together in a thread-safe manner.'''\n"
"    with lock:\n"
"        return sum(numbers)\n"
"\n"
"# We don't need to pass in the lock ourselves thanks to the decorator.\n"
"sum_threadsafe([1.1, 2.2, 3.3])"

msgid ""
":pep:`612` -- Parameter Specification Variables (the PEP which introduced "
"``ParamSpec`` and ``Concatenate``)"
msgstr ""
":pep:`612` -- Variabler för parameterspecifikation (PEP:n som introducerade "
"``ParamSpec`` och ``Concatenate``)"

msgid ":class:`ParamSpec`"
msgstr ":class:`ParamSpec`"

msgid ":ref:`annotating-callables`"
msgstr ":ref:`annoterande-kallelser`"

msgid "Special typing form to define \"literal types\"."
msgstr "Särskild typform för att definiera \"bokstavstyper\"."

msgid ""
"``Literal`` can be used to indicate to type checkers that the annotated "
"object has a value equivalent to one of the provided literals."
msgstr ""
"``Literal`` kan användas för att indikera för typkontrollanter att det "
"annoterade objektet har ett värde som motsvarar en av de angivna "
"litteralerna."

msgid ""
"def validate_simple(data: Any) -> Literal[True]:  # always returns True\n"
"    ...\n"
"\n"
"type Mode = Literal['r', 'rb', 'w', 'wb']\n"
"def open_helper(file: str, mode: Mode) -> str:\n"
"    ...\n"
"\n"
"open_helper('/some/path', 'r')      # Passes type check\n"
"open_helper('/other/path', 'typo')  # Error in type checker"
msgstr ""
"def validate_simple(data: Any) -> Literal[True]:  # returnerar alltid True\n"
"    ...\n"
"\n"
"type Mode = Literal['r', 'rb', 'w', 'wb']\n"
"def open_helper(file: str, mode: Mode) -> str:\n"
"    ...\n"
"\n"
"open_helper('/some/path', 'r') # Klarar typkontroll\n"
"open_helper('/other/path', 'typo') # Fel i typkontrollen"

msgid ""
"``Literal[...]`` cannot be subclassed. At runtime, an arbitrary value is "
"allowed as type argument to ``Literal[...]``, but type checkers may impose "
"restrictions. See :pep:`586` for more details about literal types."
msgstr ""
"``Literal[...]`` kan inte underklassas. Vid körning tillåts ett godtyckligt "
"värde som typargument till ``Literal[...]``, men typkontrollanter kan införa "
"restriktioner. Se :pep:`586` för mer information om litterala typer."

msgid "Additional details:"
msgstr "Ytterligare detaljer:"

msgid "The arguments must be literal values and there must be at least one."
msgstr ""
"Argumenten måste vara bokstavliga värden och det måste finnas minst ett."

msgid "Nested ``Literal`` types are flattened, e.g.::"
msgstr "Nästlade ``Literal``-typer plattas ut, t.ex.::"

msgid "assert Literal[Literal[1, 2], 3] == Literal[1, 2, 3]"
msgstr "assert Literal[Literal[1, 2], 3] == Literal[1, 2, 3]"

msgid ""
"However, this does not apply to ``Literal`` types referenced through a type "
"alias, to avoid forcing evaluation of the underlying :class:`TypeAliasType`::"
msgstr ""
"Detta gäller dock inte för ``Literal``-typer som refereras till via ett "
"typalias, för att undvika att tvinga fram en utvärdering av den "
"underliggande :class:`TypeAliasType`::"

msgid ""
"type A = Literal[1, 2]\n"
"assert Literal[A, 3] != Literal[1, 2, 3]"
msgstr ""
"typ A = Litteral[1, 2]\n"
"assert Litteral[A, 3] != Litteral[1, 2, 3]"

msgid "assert Literal[1, 2, 1] == Literal[1, 2]"
msgstr "assert Literal[1, 2, 1] == Literal[1, 2]"

msgid "When comparing literals, the argument order is ignored, e.g.::"
msgstr "Vid jämförelse av literaler ignoreras argumentordningen, t.ex.::"

msgid "assert Literal[1, 2] == Literal[2, 1]"
msgstr "assert Literal[1, 2] == Literal[2, 1]"

msgid "You cannot subclass or instantiate a ``Literal``."
msgstr "Du kan inte underklassa eller instansiera en ``Literal``."

msgid "You cannot write ``Literal[X][Y]``."
msgstr "Du kan inte skriva ``Literal[X][Y]``."

msgid ""
"``Literal`` now de-duplicates parameters.  Equality comparisons of "
"``Literal`` objects are no longer order dependent. ``Literal`` objects will "
"now raise a :exc:`TypeError` exception during equality comparisons if one of "
"their parameters are not :term:`hashable`."
msgstr ""
"``Literal`` avduplicerar nu parametrar.  Jämlikhetsjämförelser av "
"``Literal``-objekt är inte längre beroende av ordning. ``Literal`` objekt "
"kommer nu att ge upphov till ett :exc:`TypeError` undantag under "
"jämlikhetsjämförelser om en av deras parametrar inte är :term:`hashable`."

msgid "Special type construct to mark class variables."
msgstr "Särskild typkonstruktion för att markera klassvariabler."

msgid ""
"As introduced in :pep:`526`, a variable annotation wrapped in ClassVar "
"indicates that a given attribute is intended to be used as a class variable "
"and should not be set on instances of that class. Usage::"
msgstr ""
"Som introducerades i :pep:`526`, anger en variabelannotation omsluten av "
"ClassVar att ett visst attribut är avsett att användas som en klassvariabel "
"och inte bör ställas in på instanser av den klassen. Användning::"

msgid ""
"class Starship:\n"
"    stats: ClassVar[dict[str, int]] = {} # class variable\n"
"    damage: int = 10                     # instance variable"
msgstr ""
"klass Starship:\n"
"    stats: ClassVar[dict[str, int]] = {} # klassvariabel\n"
"    damage: int = 10 # instansvariabel"

msgid ":data:`ClassVar` accepts only types and cannot be further subscribed."
msgstr ""
":data:`ClassVar` accepterar endast typer och kan inte tecknas ytterligare."

msgid ""
":data:`ClassVar` is not a class itself, and should not be used with :func:"
"`isinstance` or :func:`issubclass`. :data:`ClassVar` does not change Python "
"runtime behavior, but it can be used by third-party type checkers. For "
"example, a type checker might flag the following code as an error::"
msgstr ""
":data:`ClassVar` är inte en klass i sig, och bör inte användas med :func:"
"`isinstance` eller :func:`issubclass`. :data:`ClassVar` ändrar inte Pythons "
"körtidsbeteende, men kan användas av tredjeparts typkontrollanter. Till "
"exempel kan en typkontrollant flagga följande kod som ett fel::"

msgid ""
"enterprise_d = Starship(3000)\n"
"enterprise_d.stats = {} # Error, setting class variable on instance\n"
"Starship.stats = {}     # This is OK"
msgstr ""
"enterprise_d = Stjärnskepp(3000)\n"
"enterprise_d.stats = {} # Fel, inställning av klassvariabel på instans\n"
"Starship.stats = {} # Det här är OK"

msgid ":data:`ClassVar` can now be nested in :data:`Final` and vice versa."
msgstr ":data:`ClassVar` kan nu nestas i :data:`Final` och vice versa."

msgid "Special typing construct to indicate final names to type checkers."
msgstr ""
"Särskild typkonstruktion för att ange slutliga namn till typkontrollanter."

msgid ""
"Final names cannot be reassigned in any scope. Final names declared in class "
"scopes cannot be overridden in subclasses."
msgstr ""
"Slutnamn kan inte omfördelas i något scope. Slutnamn som deklareras i "
"klassens scope kan inte åsidosättas i underklasser."

msgid ""
"MAX_SIZE: Final = 9000\n"
"MAX_SIZE += 1  # Error reported by type checker\n"
"\n"
"class Connection:\n"
"    TIMEOUT: Final[int] = 10\n"
"\n"
"class FastConnector(Connection):\n"
"    TIMEOUT = 1  # Error reported by type checker"
msgstr ""
"MAX_SIZE: Slutlig = 9000\n"
"MAX_SIZE += 1 # Fel rapporterat av typkontroll\n"
"\n"
"klass Anslutning:\n"
"    TIMEOUT: Final[int] = 10\n"
"\n"
"klass FastConnector(Anslutning):\n"
"    TIMEOUT = 1 # Fel rapporterat av typkontroll"

msgid ""
"There is no runtime checking of these properties. See :pep:`591` for more "
"details."
msgstr ""
"Det finns ingen körtidskontroll av dessa egenskaper. Se :pep:`591` för mer "
"information."

msgid ":data:`Final` can now be nested in :data:`ClassVar` and vice versa."
msgstr ":data:`Final` kan nu nestas i :data:`ClassVar` och vice versa."

msgid "Special typing construct to mark a :class:`TypedDict` key as required."
msgstr ""
"Speciell typningskonstruktion för att markera en :class:`TypedDict`-nyckel "
"som nödvändig."

msgid ""
"This is mainly useful for ``total=False`` TypedDicts. See :class:`TypedDict` "
"and :pep:`655` for more details."
msgstr ""
"Detta är främst användbart för ``total=False`` TypedDicts. Se :class:"
"`TypedDict` och :pep:`655` för mer information."

msgid ""
"Special typing construct to mark a :class:`TypedDict` key as potentially "
"missing."
msgstr ""
"Speciell typningskonstruktion för att markera en :class:`TypedDict`-nyckel "
"som potentiellt saknad."

msgid "See :class:`TypedDict` and :pep:`655` for more details."
msgstr "Se :class:`TypedDict` och :pep:`655` för mer information."

msgid ""
"A special typing construct to mark an item of a :class:`TypedDict` as read-"
"only."
msgstr ""
"En speciell typningskonstruktion för att markera ett objekt i en :class:"
"`TypedDict` som skrivskyddat."

msgid ""
"class Movie(TypedDict):\n"
"   title: ReadOnly[str]\n"
"   year: int\n"
"\n"
"def mutate_movie(m: Movie) -> None:\n"
"   m[\"year\"] = 1999  # allowed\n"
"   m[\"title\"] = \"The Matrix\"  # typechecker error"
msgstr ""
"klass Film(TypedDict):\n"
"   titel: ReadOnly[str]\n"
"   year: int\n"
"\n"
"def mutate_movie(m: Movie) -> None:\n"
"   m[\"year\"] = 1999 # tillåtet\n"
"   m[\"title\"] = \"The Matrix\" # typkontrollfel"

msgid "There is no runtime checking for this property."
msgstr "Det finns ingen runtime-kontroll för denna egenskap."

msgid "See :class:`TypedDict` and :pep:`705` for more details."
msgstr "Se :class:`TypedDict` och :pep:`705` för mer information."

msgid "Special typing form to add context-specific metadata to an annotation."
msgstr ""
"Särskilt skrivformulär för att lägga till kontextspecifika metadata i en "
"annotering."

msgid ""
"Add metadata ``x`` to a given type ``T`` by using the annotation "
"``Annotated[T, x]``. Metadata added using ``Annotated`` can be used by "
"static analysis tools or at runtime. At runtime, the metadata is stored in "
"a :attr:`!__metadata__` attribute."
msgstr ""
"Lägg till metadata ``x`` till en given typ ``T`` genom att använda "
"annotationen ``Annotated[T, x]``. Metadata som läggs till med ``Annotated`` "
"kan användas av statiska analysverktyg eller vid körning. Vid körning lagras "
"metadata i ett :attr:`!__metadata__`-attribut."

msgid ""
"If a library or tool encounters an annotation ``Annotated[T, x]`` and has no "
"special logic for the metadata, it should ignore the metadata and simply "
"treat the annotation as ``T``. As such, ``Annotated`` can be useful for code "
"that wants to use annotations for purposes outside Python's static typing "
"system."
msgstr ""
"Om ett bibliotek eller verktyg stöter på en annotation ``Annotated[T, x]`` "
"och inte har någon speciell logik för metadata, bör det ignorera metadata "
"och helt enkelt behandla annotationen som ``T``. Som sådan kan ``Annotated`` "
"vara användbar för kod som vill använda annotationer för ändamål utanför "
"Pythons statiska typningssystem."

msgid ""
"Using ``Annotated[T, x]`` as an annotation still allows for static "
"typechecking of ``T``, as type checkers will simply ignore the metadata "
"``x``. In this way, ``Annotated`` differs from the :func:`@no_type_check "
"<no_type_check>` decorator, which can also be used for adding annotations "
"outside the scope of the typing system, but completely disables typechecking "
"for a function or class."
msgstr ""
"Att använda ``Annotated[T, x]`` som en annotation tillåter fortfarande "
"statisk typkontroll av ``T``, eftersom typkontrollerna helt enkelt ignorerar "
"metadata ``x``. På så sätt skiljer sig ``Annotated`` från dekoratorn :func:"
"`@no_type_check <no_type_check>`, som också kan användas för att lägga till "
"annotationer utanför typsystemets räckvidd, men som helt inaktiverar "
"typkontroll för en funktion eller klass."

msgid ""
"The responsibility of how to interpret the metadata lies with the tool or "
"library encountering an ``Annotated`` annotation. A tool or library "
"encountering an ``Annotated`` type can scan through the metadata elements to "
"determine if they are of interest (e.g., using :func:`isinstance`)."
msgstr ""
"Ansvaret för hur metadata ska tolkas ligger hos det verktyg eller bibliotek "
"som stöter på en ``Annotated``-annotation. Ett verktyg eller bibliotek som "
"stöter på en ``Annotated``-typ kan söka igenom metadataelementen för att "
"avgöra om de är av intresse (t.ex. med hjälp av :func:`isinstance`)."

msgid ""
"Here is an example of how you might use ``Annotated`` to add metadata to "
"type annotations if you were doing range analysis:"
msgstr ""
"Här är ett exempel på hur du kan använda ``Annotated`` för att lägga till "
"metadata till typannoteringar om du gör intervallanalys:"

msgid ""
"@dataclass\n"
"class ValueRange:\n"
"    lo: int\n"
"    hi: int\n"
"\n"
"T1 = Annotated[int, ValueRange(-10, 5)]\n"
"T2 = Annotated[T1, ValueRange(-20, 3)]"
msgstr ""
"@dataklass\n"
"klass Värdeintervall:\n"
"    lo: int\n"
"    hi: int\n"
"\n"
"T1 = Annoterad[int, Värdeintervall(-10, 5)]\n"
"T2 = Annoterad[T1, Värdeintervall(-20, 3)]"

msgid ""
"The first argument to ``Annotated`` must be a valid type. Multiple metadata "
"elements can be supplied as ``Annotated`` supports variadic arguments. The "
"order of the metadata elements is preserved and matters for equality checks::"
msgstr ""
"Det första argumentet till ``Annotated`` måste vara en giltig typ. Flera "
"metadataelement kan anges eftersom ``Annotated`` stöder variadiska argument. "
"Ordningen på metadataelementen bevaras och är viktig för "
"jämlikhetskontroller::"

msgid ""
"@dataclass\n"
"class ctype:\n"
"     kind: str\n"
"\n"
"a1 = Annotated[int, ValueRange(3, 10), ctype(\"char\")]\n"
"a2 = Annotated[int, ctype(\"char\"), ValueRange(3, 10)]\n"
"\n"
"assert a1 != a2  # Order matters"
msgstr ""
"@dataklass\n"
"klass ctyp:\n"
"     typ: str\n"
"\n"
"a1 = Annoterad[int, Värdeintervall(3, 10), ctype(\"char\")]\n"
"a2 = Annoterad[int, ctype(\"char\"), Värdeintervall(3, 10)]\n"
"\n"
"assert a1 != a2 # Ordningen har betydelse"

msgid ""
"It is up to the tool consuming the annotations to decide whether the client "
"is allowed to add multiple metadata elements to one annotation and how to "
"merge those annotations."
msgstr ""
"Det är upp till det verktyg som konsumerar annotationerna att avgöra om "
"klienten får lägga till flera metadataelement i en annotation och hur dessa "
"annotationer ska slås samman."

msgid ""
"Nested ``Annotated`` types are flattened. The order of the metadata elements "
"starts with the innermost annotation::"
msgstr ""
"Nästlade ``Annotated``-typer plattas ut. Ordningen på metadataelementen "
"börjar med den innersta annotationen::"

msgid ""
"assert Annotated[Annotated[int, ValueRange(3, 10)], ctype(\"char\")] == "
"Annotated[\n"
"    int, ValueRange(3, 10), ctype(\"char\")\n"
"]"
msgstr ""
"assert Annoterad[Annoterad[int, ValueRange(3, 10)], ctype(\"char\")] == "
"Annoterad[\n"
"    int, Värdeintervall(3, 10), ctype(\"char\")\n"
"]"

msgid ""
"However, this does not apply to ``Annotated`` types referenced through a "
"type alias, to avoid forcing evaluation of the underlying :class:"
"`TypeAliasType`::"
msgstr ""
"Detta gäller dock inte för ``Annoterade`` typer som refereras till via ett "
"typalias, för att undvika att tvinga fram en utvärdering av den "
"underliggande :class:`TypeAliasType`::"

msgid ""
"type From3To10[T] = Annotated[T, ValueRange(3, 10)]\n"
"assert Annotated[From3To10[int], ctype(\"char\")] != Annotated[\n"
"   int, ValueRange(3, 10), ctype(\"char\")\n"
"]"
msgstr ""
"type From3To10[T] = Annoterad[T, ValueRange(3, 10)]\n"
"assert Annoterad[From3To10[int], ctype(\"char\")] != Annoterad[\n"
"   int, Värdeintervall(3, 10), ctype(\"char\")\n"
"]"

msgid "Duplicated metadata elements are not removed::"
msgstr "Duplicerade metadataelement tas inte bort:"

msgid ""
"assert Annotated[int, ValueRange(3, 10)] != Annotated[\n"
"    int, ValueRange(3, 10), ValueRange(3, 10)\n"
"]"
msgstr ""
"assert Annoterad[int, Värdeintervall(3, 10)] != Annoterad[\n"
"    int, Värdeintervall(3, 10), Värdeintervall(3, 10)\n"
"]"

msgid "``Annotated`` can be used with nested and generic aliases:"
msgstr "``Annotated`` kan användas med nästlade och generiska alias:"

msgid ""
"@dataclass\n"
"class MaxLen:\n"
"    value: int\n"
"\n"
"type Vec[T] = Annotated[list[tuple[T, T]], MaxLen(10)]\n"
"\n"
"# When used in a type annotation, a type checker will treat \"V\" the same "
"as\n"
"# ``Annotated[list[tuple[int, int]], MaxLen(10)]``:\n"
"type V = Vec[int]"
msgstr ""
"@dataklass\n"
"klass MaxLen:\n"
"    värde: int\n"
"\n"
"type Vec[T] = Annoterad[list[tuple[T, T]], MaxLen(10)]\n"
"\n"
"# När det används i en typannotering kommer en typkontroll att behandla "
"\"V\" på samma sätt som\n"
"# ``Annoterad[lista[tupel[int, int]], MaxLen(10)]``:\n"
"typ V = Vec[int]"

msgid "``Annotated`` cannot be used with an unpacked :class:`TypeVarTuple`::"
msgstr ""
"``Annotated`` kan inte användas med en uppackad :class:`TypeVarTuple`::"

msgid ""
"type Variadic[*Ts] = Annotated[*Ts, Ann1] = Annotated[T1, T2, T3, ..., "
"Ann1]  # NOT valid"
msgstr ""
"type Variadic[*Ts] = Annoterad[*Ts, Ann1] = Annoterad[T1, T2, T3, ..., Ann1] "
"# INTE giltig"

msgid ""
"where ``T1``, ``T2``, ... are :class:`TypeVars <TypeVar>`. This is invalid "
"as only one type should be passed to Annotated."
msgstr ""
"där ``T1``, ``T2``, ... är :class:`TypeVars <TypeVar>`. Detta är ogiltigt "
"eftersom endast en typ ska skickas till Annotated."

msgid ""
"By default, :func:`get_type_hints` strips the metadata from annotations. "
"Pass ``include_extras=True`` to have the metadata preserved:"
msgstr ""
"Som standard tar :func:`get_type_hints` bort metadata från annoteringar. "
"Passera ``include_extras=True`` för att få metadata bevarade:"

msgid ""
">>> from typing import Annotated, get_type_hints\n"
">>> def func(x: Annotated[int, \"metadata\"]) -> None: pass\n"
"...\n"
">>> get_type_hints(func)\n"
"{'x': <class 'int'>, 'return': <class 'NoneType'>}\n"
">>> get_type_hints(func, include_extras=True)\n"
"{'x': typing.Annotated[int, 'metadata'], 'return': <class 'NoneType'>}"
msgstr ""
">>> from typing import Annoterad, get_type_hints\n"
">>> def func(x: Annoterad[int, \"metadata\"]) -> Ingen: pass\n"
"...\n"
">>> get_type_hints(func)\n"
"{'x': <klass 'int'>, 'return': <klass 'NoneType'>}\n"
">>> get_type_hints(func, include_extras=True)\n"
"{'x': typing.Annotated[int, 'metadata'], 'return': <klass 'NoneType'>}"

msgid ""
"At runtime, the metadata associated with an ``Annotated`` type can be "
"retrieved via the :attr:`!__metadata__` attribute:"
msgstr ""
"Vid körning kan de metadata som är associerade med en ``Annotated``-typ "
"hämtas via attributet :attr:`!__metadata__`:"

msgid ""
">>> from typing import Annotated\n"
">>> X = Annotated[int, \"very\", \"important\", \"metadata\"]\n"
">>> X\n"
"typing.Annotated[int, 'very', 'important', 'metadata']\n"
">>> X.__metadata__\n"
"('very', 'important', 'metadata')"
msgstr ""
">>> from typing import Annoterad\n"
">>> X = Annoterad[int, \"mycket\", \"viktig\", \"metadata\"]\n"
">>> X\n"
"typing.Annoterad[int, 'mycket', 'viktig', 'metadata']\n"
">>> X.__metadata__\n"
"('mycket', 'viktigt', 'metadata')"

msgid ""
"If you want to retrieve the original type wrapped by ``Annotated``, use the :"
"attr:`!__origin__` attribute:"
msgstr ""
"Om du vill hämta den ursprungliga typen som omsluts av ``Annotated``, använd "
"attributet :attr:`!__origin__``:"

msgid ""
">>> from typing import Annotated, get_origin\n"
">>> Password = Annotated[str, \"secret\"]\n"
">>> Password.__origin__\n"
"<class 'str'>"
msgstr ""
">>> from typing import Annoterad, get_origin\n"
">>> Lösenord = Annoterad[str, \"hemlig\"]\n"
">>> Lösenord.__origin__\n"
"<klass 'str'>"

msgid "Note that using :func:`get_origin` will return ``Annotated`` itself:"
msgstr ""
"Observera att om du använder :func:`get_origin` kommer ``Annotated`` själv "
"att returneras:"

msgid ""
">>> get_origin(Password)\n"
"typing.Annotated"
msgstr ""
">>> get_origin(Lösenord)\n"
"typning.antecknad"

msgid ":pep:`593` - Flexible function and variable annotations"
msgstr ":pep:`593` - Flexibla funktions- och variabelannoteringar"

msgid "The PEP introducing ``Annotated`` to the standard library."
msgstr "PEP som introducerar ``Annotated`` till standardbiblioteket."

msgid ""
"Special typing construct for marking user-defined type predicate functions."
msgstr ""
"Särskild typkonstruktion för att markera användardefinierade "
"typpredikatsfunktioner."

msgid ""
"``TypeIs`` can be used to annotate the return type of a user-defined type "
"predicate function.  ``TypeIs`` only accepts a single type argument. At "
"runtime, functions marked this way should return a boolean and take at least "
"one positional argument."
msgstr ""
"``TypeIs`` kan användas för att kommentera returtypen för en "
"användardefinierad typ predikatfunktion.  ``TypeIs`` accepterar endast ett "
"enda typargument. Vid körning ska funktioner som markeras på detta sätt "
"returnera en boolean och ta minst ett positionellt argument."

msgid ""
"``TypeIs`` aims to benefit *type narrowing* -- a technique used by static "
"type checkers to determine a more precise type of an expression within a "
"program's code flow.  Usually type narrowing is done by analyzing "
"conditional code flow and applying the narrowing to a block of code.  The "
"conditional expression here is sometimes referred to as a \"type "
"predicate\"::"
msgstr ""
"``TypeIs`` syftar till att gynna *type narrowing* -- en teknik som används "
"av statiska typkontroller för att bestämma en mer exakt typ av ett uttryck "
"inom ett programs kodflöde.  Vanligtvis görs typförminskning genom att "
"analysera villkorligt kodflöde och tillämpa förminskningen på ett kodblock.  "
"Det villkorliga uttrycket här kallas ibland för ett \"typ predikat\"::"

msgid ""
"def is_str(val: str | float):\n"
"    # \"isinstance\" type predicate\n"
"    if isinstance(val, str):\n"
"        # Type of ``val`` is narrowed to ``str``\n"
"        ...\n"
"    else:\n"
"        # Else, type of ``val`` is narrowed to ``float``.\n"
"        ..."
msgstr ""
"def is_str(val: str | float):\n"
"    # \"isinstance\" typ predikat\n"
"    if isinstance(val, str):\n"
"        # Typen av ``val`` är begränsad till ``str``\n"
"        ...\n"
"    else:\n"
"        # Annars är typen av ``val`` begränsad till ``float``.\n"
"        ..."

msgid ""
"Sometimes it would be convenient to use a user-defined boolean function as a "
"type predicate.  Such a function should use ``TypeIs[...]`` or :data:"
"`TypeGuard` as its return type to alert static type checkers to this "
"intention.  ``TypeIs`` usually has more intuitive behavior than "
"``TypeGuard``, but it cannot be used when the input and output types are "
"incompatible (e.g., ``list[object]`` to ``list[int]``) or when the function "
"does not return ``True`` for all instances of the narrowed type."
msgstr ""
"Ibland kan det vara praktiskt att använda en användardefinierad boolesk "
"funktion som ett typpredikat.  En sådan funktion bör använda ``TypeIs[...]`` "
"eller :data:`TypeGuard` som sin returtyp för att varna statiska "
"typkontrollanter för denna avsikt.  ``TypeIs`` har vanligtvis ett mer "
"intuitivt beteende än ``TypeGuard``, men det kan inte användas när in- och "
"utdatatyperna är inkompatibla (t.ex. ``list[object]`` till ``list[int]``) "
"eller när funktionen inte returnerar ``True`` för alla instanser av den "
"begränsade typen."

msgid ""
"Using  ``-> TypeIs[NarrowedType]`` tells the static type checker that for a "
"given function:"
msgstr ""
"Att använda ``-> TypeIs[NarrowedType]`` säger till den statiska "
"typkontrollen att för en given funktion:"

msgid "The return value is a boolean."
msgstr "Returvärdet är en boolean."

msgid ""
"If the return value is ``True``, the type of its argument is the "
"intersection of the argument's original type and ``NarrowedType``."
msgstr ""
"Om returvärdet är ``True`` är typen för dess argument skärningspunkten "
"mellan argumentets ursprungliga typ och ``NarrowedType``."

msgid ""
"If the return value is ``False``, the type of its argument is narrowed to "
"exclude ``NarrowedType``."
msgstr ""
"Om returvärdet är ``False``, begränsas typen av dess argument för att "
"utesluta ``NarrowedType``."

msgid ""
"from typing import assert_type, final, TypeIs\n"
"\n"
"class Parent: pass\n"
"class Child(Parent): pass\n"
"@final\n"
"class Unrelated: pass\n"
"\n"
"def is_parent(val: object) -> TypeIs[Parent]:\n"
"    return isinstance(val, Parent)\n"
"\n"
"def run(arg: Child | Unrelated):\n"
"    if is_parent(arg):\n"
"        # Type of ``arg`` is narrowed to the intersection\n"
"        # of ``Parent`` and ``Child``, which is equivalent to\n"
"        # ``Child``.\n"
"        assert_type(arg, Child)\n"
"    else:\n"
"        # Type of ``arg`` is narrowed to exclude ``Parent``,\n"
"        # so only ``Unrelated`` is left.\n"
"        assert_type(arg, Unrelated)"
msgstr ""
"från typing import assert_type, final, TypeIs\n"
"\n"
"klass Förälder: pass\n"
"class Barn(Förälder): pass\n"
"@final\n"
"klass Obesläktad: pass\n"
"\n"
"def is_parent(val: object) -> TypeIs[Parent]:\n"
"    return isinstance(val, Förälder)\n"
"\n"
"def run(arg: Barn | Obesläktad):\n"
"    if is_parent(arg):\n"
"        # Typen av ``arg`` är begränsad till skärningspunkten\n"
"        # av ``Parent`` och ``Child``, vilket är ekvivalent med\n"
"        # ``Child``.\n"
"        assert_type(arg, Barn)\n"
"    else:\n"
"        # Typen av ``arg`` är begränsad till att utesluta ``Parent``,\n"
"        # så att endast ``Unrelated`` återstår.\n"
"        assert_type(arg, Obesläktad)"

msgid ""
"The type inside ``TypeIs`` must be consistent with the type of the "
"function's argument; if it is not, static type checkers will raise an "
"error.  An incorrectly written ``TypeIs`` function can lead to unsound "
"behavior in the type system; it is the user's responsibility to write such "
"functions in a type-safe manner."
msgstr ""
"Typen i ``TypeIs`` måste stämma överens med typen i funktionens argument; om "
"den inte gör det kommer statiska typkontroller att ge ett felmeddelande.  En "
"felaktigt skriven ``TypeIs``-funktion kan leda till osunt beteende i "
"typsystemet; det är användarens ansvar att skriva sådana funktioner på ett "
"typsäkert sätt."

msgid ""
"If a ``TypeIs`` function is a class or instance method, then the type in "
"``TypeIs`` maps to the type of the second parameter (after ``cls`` or "
"``self``)."
msgstr ""
"Om en ``TypeIs``-funktion är en klass- eller instansmetod, så mappas typen i "
"``TypeIs`` till typen för den andra parametern (efter ``cls`` eller "
"``self``)."

msgid ""
"In short, the form ``def foo(arg: TypeA) -> TypeIs[TypeB]: ...``, means that "
"if ``foo(arg)`` returns ``True``, then ``arg`` is an instance of ``TypeB``, "
"and if it returns ``False``, it is not an instance of ``TypeB``."
msgstr ""
"Kort sagt, formen ``def foo(arg: TypeA) -> TypeIs[TypeB]: ...``, betyder att "
"om ``foo(arg)`` returnerar ``True``, så är ``arg`` en instans av ``TypeB``, "
"och om den returnerar ``False``, så är den inte en instans av ``TypeB``."

msgid ""
"``TypeIs`` also works with type variables.  For more information, see :pep:"
"`742` (Narrowing types with ``TypeIs``)."
msgstr ""
"``TypeIs`` fungerar också med typvariabler.  För mer information, se :pep:"
"`742` (Begränsa typer med ``TypeIs``)."

msgid ""
"Type predicate functions are user-defined functions that return whether "
"their argument is an instance of a particular type. ``TypeGuard`` works "
"similarly to :data:`TypeIs`, but has subtly different effects on type "
"checking behavior (see below)."
msgstr ""
"Type predicate functions är användardefinierade funktioner som returnerar om "
"deras argument är en instans av en viss typ. ``TypeGuard`` fungerar på "
"liknande sätt som :data:`TypeIs`, men har subtilt olika effekter på "
"typkontrollbeteendet (se nedan)."

msgid ""
"Using  ``-> TypeGuard`` tells the static type checker that for a given "
"function:"
msgstr ""
"Att använda ``-> TypeGuard`` säger till den statiska typkontrollen att för "
"en given funktion:"

msgid ""
"If the return value is ``True``, the type of its argument is the type inside "
"``TypeGuard``."
msgstr ""
"Om returvärdet är ``True``, är typen av dess argument den typ som finns i "
"``TypeGuard``."

msgid ""
"``TypeGuard`` also works with type variables.  See :pep:`647` for more "
"details."
msgstr ""
"``TypeGuard`` fungerar även med typvariabler.  Se :pep:`647` för mer "
"information."

msgid ""
"def is_str_list(val: list[object]) -> TypeGuard[list[str]]:\n"
"    '''Determines whether all objects in the list are strings'''\n"
"    return all(isinstance(x, str) for x in val)\n"
"\n"
"def func1(val: list[object]):\n"
"    if is_str_list(val):\n"
"        # Type of ``val`` is narrowed to ``list[str]``.\n"
"        print(\" \".join(val))\n"
"    else:\n"
"        # Type of ``val`` remains as ``list[object]``.\n"
"        print(\"Not a list of strings!\")"
msgstr ""
"def is_str_list(val: list[object]) -> TypeGuard[list[str]]:\n"
"    '''Bestämmer om alla objekt i listan är strängar'''\n"
"    return all(isinstance(x, str) för x i val)\n"
"\n"
"def func1(val: lista[objekt]):\n"
"    if is_str_list(val):\n"
"        # Typen av ``val`` begränsas till ``list[str]``.\n"
"        print(\" \".join(val))\n"
"    else:\n"
"        # Typen av ``val`` förblir ``list[object]``.\n"
"        print(\"Inte en lista med strängar!\")"

msgid "``TypeIs`` and ``TypeGuard`` differ in the following ways:"
msgstr "``TypeIs`` och ``TypeGuard`` skiljer sig åt på följande sätt:"

msgid ""
"``TypeIs`` requires the narrowed type to be a subtype of the input type, "
"while ``TypeGuard`` does not.  The main reason is to allow for things like "
"narrowing ``list[object]`` to ``list[str]`` even though the latter is not a "
"subtype of the former, since ``list`` is invariant."
msgstr ""
"``TypeIs`` kräver att den inskränkta typen är en subtyp av inmatningstypen, "
"medan ``TypeGuard`` inte gör det.  Huvudskälet är att tillåta saker som att "
"begränsa ``list[object]`` till ``list[str]`` även om den senare inte är en "
"subtyp av den förra, eftersom ``list`` är invariant."

msgid ""
"When a ``TypeGuard`` function returns ``True``, type checkers narrow the "
"type of the variable to exactly the ``TypeGuard`` type. When a ``TypeIs`` "
"function returns ``True``, type checkers can infer a more precise type "
"combining the previously known type of the variable with the ``TypeIs`` "
"type. (Technically, this is known as an intersection type.)"
msgstr ""
"När en ``TypeGuard``-funktion returnerar ``True``, begränsar typkontrollerna "
"variabelns typ till exakt ``TypeGuard``-typen. När en ``TypeIs``-funktion "
"returnerar ``True`` kan typkontrollanter härleda en mer exakt typ genom att "
"kombinera den tidigare kända typen av variabeln med ``TypeIs``-typen. "
"(Tekniskt sett är detta känt som en intersektionstyp.)"

msgid ""
"When a ``TypeGuard`` function returns ``False``, type checkers cannot narrow "
"the type of the variable at all. When a ``TypeIs`` function returns "
"``False``, type checkers can narrow the type of the variable to exclude the "
"``TypeIs`` type."
msgstr ""
"När en ``TypeGuard``-funktion returnerar ``False`` kan typkontrollanter inte "
"begränsa variabelns typ alls. När en ``TypeIs``-funktion returnerar "
"``False`` kan typkontrollanter begränsa variabelns typ för att utesluta "
"``TypeIs``-typen."

msgid "Typing operator to conceptually mark an object as having been unpacked."
msgstr ""
"Typoperator för att konceptuellt markera att ett objekt har packats upp."

msgid ""
"For example, using the unpack operator ``*`` on a :ref:`type variable tuple "
"<typevartuple>` is equivalent to using ``Unpack`` to mark the type variable "
"tuple as having been unpacked::"
msgstr ""
"Om du till exempel använder uppackningsoperatorn ``*`` på en :ref:"
"`typvariabel-tupel <typevartuple>` är det likvärdigt med att använda "
"``Unpack`` för att markera att typvariabel-tupeln har packats upp::"

msgid ""
"Ts = TypeVarTuple('Ts')\n"
"tup: tuple[*Ts]\n"
"# Effectively does:\n"
"tup: tuple[Unpack[Ts]]"
msgstr ""
"Ts = TypeVarTuple('Ts')\n"
"tup: tuple[*Ts]\n"
"# Gör det effektivt:\n"
"tup: tuple[Unpack[Ts]]"

msgid ""
"In fact, ``Unpack`` can be used interchangeably with ``*`` in the context "
"of :class:`typing.TypeVarTuple <TypeVarTuple>` and :class:`builtins.tuple "
"<tuple>` types. You might see ``Unpack`` being used explicitly in older "
"versions of Python, where ``*`` couldn't be used in certain places::"
msgstr ""
"I själva verket kan ``Unpack`` användas omväxlande med ``*`` i samband med :"
"class:`typing.TypeVarTuple <TypeVarTuple>` och :class:`builtins.tuple "
"<tuple>` typer. Du kan se ``Unpack`` användas explicit i äldre versioner av "
"Python, där ``*`` inte kunde användas på vissa ställen::"

msgid ""
"# In older versions of Python, TypeVarTuple and Unpack\n"
"# are located in the `typing_extensions` backports package.\n"
"from typing_extensions import TypeVarTuple, Unpack\n"
"\n"
"Ts = TypeVarTuple('Ts')\n"
"tup: tuple[*Ts]         # Syntax error on Python <= 3.10!\n"
"tup: tuple[Unpack[Ts]]  # Semantically equivalent, and backwards-compatible"
msgstr ""
"# I äldre versioner av Python finns TypeVarTuple och Unpack\n"
"# finns i bakportspaketet `typing_extensions`.\n"
"from typing_extensions import TypeVarTuple, Unpack\n"
"\n"
"Ts = TypeVarTuple('Ts')\n"
"tup: tuple[*Ts] # Syntaxfel på Python <= 3.10!\n"
"tup: tuple[Unpack[Ts]]  # Semantiskt likvärdig och bakåtkompatibel"

msgid ""
"``Unpack`` can also be used along with :class:`typing.TypedDict` for typing "
"``**kwargs`` in a function signature::"
msgstr ""
"``Unpack`` kan också användas tillsammans med :class:`typing.TypedDict` för "
"att skriva ``**kwargs`` i en funktionssignatur::"

msgid ""
"from typing import TypedDict, Unpack\n"
"\n"
"class Movie(TypedDict):\n"
"    name: str\n"
"    year: int\n"
"\n"
"# This function expects two keyword arguments - `name` of type `str`\n"
"# and `year` of type `int`.\n"
"def foo(**kwargs: Unpack[Movie]): ..."
msgstr ""
"från typing import TypedDict, Packa upp\n"
"\n"
"klass Movie(TypedDict):\n"
"    namn: str\n"
"    år: int\n"
"\n"
"# Denna funktion förväntar sig två nyckelordsargument - `name` av typen "
"`str`\n"
"# och `year` av typen `int`.\n"
"def foo(**kwargs: Unpack[Movie]): ..."

msgid ""
"See :pep:`692` for more details on using ``Unpack`` for ``**kwargs`` typing."
msgstr ""
"Se :pep:`692` för mer information om att använda ``Unpack`` för ``**kwargs`` "
"typning."

msgid "Building generic types and type aliases"
msgstr "Skapa generiska typer och typaliaser"

msgid ""
"The following classes should not be used directly as annotations. Their "
"intended purpose is to be building blocks for creating generic types and "
"type aliases."
msgstr ""
"Följande klasser bör inte användas direkt som annotationer. Deras avsedda "
"syfte är att vara byggstenar för att skapa generiska typer och typaliaser."

msgid ""
"These objects can be created through special syntax (:ref:`type parameter "
"lists <type-params>` and the :keyword:`type` statement). For compatibility "
"with Python 3.11 and earlier, they can also be created without the dedicated "
"syntax, as documented below."
msgstr ""
"Dessa objekt kan skapas genom speciell syntax (:ref:`typ parameterlistor "
"<type-params>` och :keyword:`type`-satsen). För kompatibilitet med Python "
"3.11 och tidigare kan de också skapas utan den särskilda syntaxen, enligt "
"vad som dokumenteras nedan."

msgid "Abstract base class for generic types."
msgstr "Abstrakt basklass för generiska typer."

msgid ""
"A generic type is typically declared by adding a list of type parameters "
"after the class name::"
msgstr ""
"En generisk typ deklareras vanligen genom att en lista med typparametrar "
"läggs till efter klassnamnet::"

msgid ""
"class Mapping[KT, VT]:\n"
"    def __getitem__(self, key: KT) -> VT:\n"
"        ...\n"
"        # Etc."
msgstr ""
"klass Mapping[KT, VT]:\n"
"    def __getitem__(self, key: KT) -> VT:\n"
"        ...\n"
"        # Etc."

msgid ""
"Such a class implicitly inherits from ``Generic``. The runtime semantics of "
"this syntax are discussed in the :ref:`Language Reference <generic-classes>`."
msgstr ""
"En sådan klass ärver implicit från ``Generic``. Körtidssemantiken för denna "
"syntax diskuteras i :ref:``Language Reference <generic-classes>``."

msgid "This class can then be used as follows::"
msgstr "Denna klass kan sedan användas på följande sätt::"

msgid ""
"def lookup_name[X, Y](mapping: Mapping[X, Y], key: X, default: Y) -> Y:\n"
"    try:\n"
"        return mapping[key]\n"
"    except KeyError:\n"
"        return default"
msgstr ""
"def lookup_name[X, Y](mapping: Mapping[X, Y], key: X, default: Y) -> Y:\n"
"    try:\n"
"        return mappning[nyckel]\n"
"    utom KeyError:\n"
"        returnera standard"

msgid ""
"Here the brackets after the function name indicate a :ref:`generic function "
"<generic-functions>`."
msgstr ""
"Här anger parenteserna efter funktionsnamnet en :ref:`generisk funktion "
"<generic-functions>`."

msgid ""
"For backwards compatibility, generic classes can also be declared by "
"explicitly inheriting from ``Generic``. In this case, the type parameters "
"must be declared separately::"
msgstr ""
"För bakåtkompatibilitet kan generiska klasser också deklareras genom att "
"uttryckligen ärva från ``Generic``. I detta fall måste typ-parametrarna "
"deklareras separat::"

msgid ""
"KT = TypeVar('KT')\n"
"VT = TypeVar('VT')\n"
"\n"
"class Mapping(Generic[KT, VT]):\n"
"    def __getitem__(self, key: KT) -> VT:\n"
"        ...\n"
"        # Etc."
msgstr ""
"KT = TypeVar('KT')\n"
"VT = TypVar('VT')\n"
"\n"
"klass Mapping(Generic[KT, VT]):\n"
"    def __getitem__(self, key: KT) -> VT:\n"
"        ...\n"
"        # Etc."

msgid "Type variable."
msgstr "Typ av variabel."

msgid ""
"The preferred way to construct a type variable is via the dedicated syntax "
"for :ref:`generic functions <generic-functions>`, :ref:`generic classes "
"<generic-classes>`, and :ref:`generic type aliases <generic-type-aliases>`::"
msgstr ""
"Det föredragna sättet att konstruera en typvariabel är via den särskilda "
"syntaxen för :ref:`generiska funktioner <generic-functions>`, :ref:"
"`generiska klasser <generic-classes>` och :ref:`generiska typalias <generic-"
"type-aliases>`::"

msgid ""
"class Sequence[T]:  # T is a TypeVar\n"
"    ..."
msgstr ""
"klass Sekvens[T]:  # T är en TypeVar\n"
"    ..."

msgid ""
"This syntax can also be used to create bounded and constrained type "
"variables::"
msgstr ""
"Denna syntax kan också användas för att skapa avgränsade och begränsade "
"typvariabler::"

msgid ""
"class StrSequence[S: str]:  # S is a TypeVar with a `str` upper bound;\n"
"    ...                     # we can say that S is \"bounded by `str`\"\n"
"\n"
"\n"
"class StrOrBytesSequence[A: (str, bytes)]:  # A is a TypeVar constrained to "
"str or bytes\n"
"    ..."
msgstr ""
"klass StrSequence[S: str]:  # S är en TypeVar med en övre gräns för `str`;\n"
"    ...                     # vi kan säga att S är \"avgränsad av `str`\"\n"
"\n"
"\n"
"class StrOrBytesSequence[A: (str, bytes)]:  # A är en TypeVar som begränsas "
"till str eller bytes\n"
"    ..."

msgid ""
"However, if desired, reusable type variables can also be constructed "
"manually, like so::"
msgstr ""
"Om så önskas kan återanvändbara typvariabler dock också konstrueras "
"manuellt, på följande sätt::"

msgid ""
"T = TypeVar('T')  # Can be anything\n"
"S = TypeVar('S', bound=str)  # Can be any subtype of str\n"
"A = TypeVar('A', str, bytes)  # Must be exactly str or bytes"
msgstr ""
"T = TypeVar('T') # Kan vara vad som helst\n"
"S = TypeVar('S', bound=str) # Kan vara vilken subtyp som helst av str\n"
"A = TypeVar('A', str, bytes) # Måste vara exakt str eller bytes"

msgid ""
"Type variables exist primarily for the benefit of static type checkers.  "
"They serve as the parameters for generic types as well as for generic "
"function and type alias definitions. See :class:`Generic` for more "
"information on generic types.  Generic functions work as follows::"
msgstr ""
"Typvariabler är främst till för att underlätta för statiska "
"typkontrollanter.  De fungerar som parametrar för generiska typer samt för "
"generiska funktions- och typaliasdefinitioner. Se :class:`Generic` för mer "
"information om generiska typer.  Generiska funktioner fungerar på följande "
"sätt::"

msgid ""
"def repeat[T](x: T, n: int) -> Sequence[T]:\n"
"    \"\"\"Return a list containing n references to x.\"\"\"\n"
"    return [x]*n\n"
"\n"
"\n"
"def print_capitalized[S: str](x: S) -> S:\n"
"    \"\"\"Print x capitalized, and return x.\"\"\"\n"
"    print(x.capitalize())\n"
"    return x\n"
"\n"
"\n"
"def concatenate[A: (str, bytes)](x: A, y: A) -> A:\n"
"    \"\"\"Add two strings or bytes objects together.\"\"\"\n"
"    return x + y"
msgstr ""
"def repeat[T](x: T, n: int) -> Sekvens[T]:\n"
"    \"\"\"Returnera en lista som innehåller n referenser till x.\"\"\"\"\n"
"    returnerar [x]*n\n"
"\n"
"\n"
"def print_capitalized[S: str](x: S) -> S:\n"
"    \"\"\"Skriv ut x med stora bokstäver och returnera x.\"\"\"\n"
"    print(x.capitalize())\n"
"    returnerar x\n"
"\n"
"\n"
"def concatenate[A: (str, bytes)](x: A, y: A) -> A:\n"
"    \"\"\"Lägg ihop två strängar eller bytes-objekt.\"\"\"\n"
"    returnerar x + y"

msgid ""
"Note that type variables can be *bounded*, *constrained*, or neither, but "
"cannot be both bounded *and* constrained."
msgstr ""
"Observera att typvariabler kan vara *begränsade*, *begränsade* eller "
"ingetdera, men kan inte vara både begränsade *och*begränsade."

msgid ""
"The variance of type variables is inferred by type checkers when they are "
"created through the :ref:`type parameter syntax <type-params>` or when "
"``infer_variance=True`` is passed. Manually created type variables may be "
"explicitly marked covariant or contravariant by passing ``covariant=True`` "
"or ``contravariant=True``. By default, manually created type variables are "
"invariant. See :pep:`484` and :pep:`695` for more details."
msgstr ""
"Variansen hos typvariabler härleds av typkontrollanter när de skapas genom :"
"ref:`type-parametersyntaxen <type-params>` eller när ``infer_variance=True`` "
"anges. Manuellt skapade typvariabler kan uttryckligen markeras som "
"covarianta eller contravarianta genom att ange ``covariant=True`` eller "
"``contravariant=True``. Som standard är manuellt skapade typvariabler "
"invarianta. Se :pep:`484` och :pep:`695` för mer information."

msgid ""
"Bounded type variables and constrained type variables have different "
"semantics in several important ways. Using a *bounded* type variable means "
"that the ``TypeVar`` will be solved using the most specific type possible::"
msgstr ""
"Variabler av typen Bounded och variabler av typen Constrained har olika "
"semantik på flera viktiga sätt. Att använda en *begränsad* typvariabel "
"innebär att ``TypeVar`` kommer att lösas med hjälp av den mest specifika typ "
"som är möjlig::"

msgid ""
"x = print_capitalized('a string')\n"
"reveal_type(x)  # revealed type is str\n"
"\n"
"class StringSubclass(str):\n"
"    pass\n"
"\n"
"y = print_capitalized(StringSubclass('another string'))\n"
"reveal_type(y)  # revealed type is StringSubclass\n"
"\n"
"z = print_capitalized(45)  # error: int is not a subtype of str"
msgstr ""
"x = print_capitalized('en sträng')\n"
"reveal_type(x) # avslöjad typ är str\n"
"\n"
"klass StringSubclass(str):\n"
"    pass\n"
"\n"
"y = print_capitalized(StringSubclass('en annan sträng'))\n"
"reveal_type(y) # avslöjad typ är StringSubclass\n"
"\n"
"z = print_capitalized(45) # fel: int är inte en subtyp av str"

msgid ""
"The upper bound of a type variable can be a concrete type, abstract type "
"(ABC or Protocol), or even a union of types::"
msgstr ""
"Den övre gränsen för en typvariabel kan vara en konkret typ, en abstrakt typ "
"(ABC eller Protocol) eller till och med en sammanslagning av typer::"

msgid ""
"# Can be anything with an __abs__ method\n"
"def print_abs[T: SupportsAbs](arg: T) -> None:\n"
"    print(\"Absolute value:\", abs(arg))\n"
"\n"
"U = TypeVar('U', bound=str|bytes)  # Can be any subtype of the union str|"
"bytes\n"
"V = TypeVar('V', bound=SupportsAbs)  # Can be anything with an __abs__ method"
msgstr ""
"# Kan vara vad som helst med en __abs__-metod\n"
"def print_abs[T: SupportsAbs](arg: T) -> None:\n"
"    print(\"Absolut värde:\", abs(arg))\n"
"\n"
"U = TypeVar('U', bound=str|bytes) # Kan vara vilken subtyp som helst av "
"unionen str|bytes\n"
"V = TypeVar('V', bound=SupportsAbs) # Kan vara vad som helst med en __abs__-"
"metod"

msgid ""
"Using a *constrained* type variable, however, means that the ``TypeVar`` can "
"only ever be solved as being exactly one of the constraints given::"
msgstr ""
"Att använda en *begränsad* typvariabel innebär dock att ``TypVar`` bara "
"någonsin kan lösas som exakt en av de begränsningar som anges::"

msgid ""
"a = concatenate('one', 'two')\n"
"reveal_type(a)  # revealed type is str\n"
"\n"
"b = concatenate(StringSubclass('one'), StringSubclass('two'))\n"
"reveal_type(b)  # revealed type is str, despite StringSubclass being passed "
"in\n"
"\n"
"c = concatenate('one', b'two')  # error: type variable 'A' can be either str "
"or bytes in a function call, but not both"
msgstr ""
"a = konkatenera('ett', 'två')\n"
"reveal_type(a) # avslöjad typ är str\n"
"\n"
"b = konkatenera(StringSubclass('ett'), StringSubclass('två'))\n"
"reveal_type(b) # avslöjad typ är str, trots att StringSubclass skickades in\n"
"\n"
"c = concatenate('one', b'two') # fel: typvariabeln 'A' kan vara antingen str "
"eller bytes i ett funktionsanrop, men inte båda"

msgid "At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`."
msgstr ""
"Vid körning kommer ``isinstance(x, T)`` att ge upphov till :exc:`TypeError`."

msgid "The name of the type variable."
msgstr "Namnet på typvariabeln."

msgid "Whether the type var has been explicitly marked as covariant."
msgstr "Om typen var uttryckligen har markerats som kovariant."

msgid "Whether the type var has been explicitly marked as contravariant."
msgstr "Om typen var uttryckligen har markerats som kontravariant."

msgid ""
"Whether the type variable's variance should be inferred by type checkers."
msgstr "Huruvida typvariabelns varians ska härledas av typkontrollanter."

msgid "The upper bound of the type variable, if any."
msgstr "Den övre gränsen för typvariabeln, om sådan finns."

msgid ""
"For type variables created through :ref:`type parameter syntax <type-"
"params>`, the bound is evaluated only when the attribute is accessed, not "
"when the type variable is created (see :ref:`lazy-evaluation`)."
msgstr ""
"För typvariabler som skapats genom :ref:`typ parametersyntax <type-params>` "
"utvärderas bindningen endast när attributet används, inte när typvariabeln "
"skapas (se :ref:`lazy-evaluation`)."

msgid ""
"An :term:`evaluate function` corresponding to the :attr:`~TypeVar.__bound__` "
"attribute. When called directly, this method supports only the :attr:"
"`~annotationlib.Format.VALUE` format, which is equivalent to accessing the :"
"attr:`~TypeVar.__bound__` attribute directly, but the method object can be "
"passed to :func:`annotationlib.call_evaluate_function` to evaluate the value "
"in a different format."
msgstr ""
"En :term:`evaluate-funktion` som motsvarar attributet :attr:`~TypeVar."
"__bound__`. Vid direkt anrop stöder denna metod endast formatet :attr:"
"`~annotationlib.Format.VALUE`, vilket motsvarar direkt åtkomst till "
"attributet :attr:`~TypeVar.__bound__`, men metodobjektet kan skickas till :"
"func:`annotationlib.call_evaluate_function` för att utvärdera värdet i ett "
"annat format."

msgid "A tuple containing the constraints of the type variable, if any."
msgstr ""
"En tupel som innehåller begränsningarna för typvariabeln, om sådana finns."

msgid ""
"For type variables created through :ref:`type parameter syntax <type-"
"params>`, the constraints are evaluated only when the attribute is accessed, "
"not when the type variable is created (see :ref:`lazy-evaluation`)."
msgstr ""
"För typvariabler som skapats genom :ref:`type parameter syntax <type-"
"params>` utvärderas begränsningarna endast när attributet används, inte när "
"typvariabeln skapas (se :ref:`lazy-evaluation`)."

msgid ""
"An :term:`evaluate function` corresponding to the :attr:`~TypeVar."
"__constraints__` attribute. When called directly, this method supports only "
"the :attr:`~annotationlib.Format.VALUE` format, which is equivalent to "
"accessing the :attr:`~TypeVar.__constraints__` attribute directly, but the "
"method object can be passed to :func:`annotationlib.call_evaluate_function` "
"to evaluate the value in a different format."
msgstr ""
"En :term:`evaluate-funktion` som motsvarar attributet :attr:`~TypeVar."
"__constraints__`. Vid direkt anrop stöder denna metod endast formatet :attr:"
"`~annotationlib.Format.VALUE`, vilket motsvarar direkt åtkomst till "
"attributet :attr:`~TypeVar.__constraints__`, men metodobjektet kan skickas "
"till :func:`annotationlib.call_evaluate_function` för att utvärdera värdet i "
"ett annat format."

msgid ""
"The default value of the type variable, or :data:`typing.NoDefault` if it "
"has no default."
msgstr ""
"Typvariabelns standardvärde, eller :data:`typing.NoDefault` om den inte har "
"något standardvärde."

msgid ""
"An :term:`evaluate function` corresponding to the :attr:`~TypeVar."
"__default__` attribute. When called directly, this method supports only the :"
"attr:`~annotationlib.Format.VALUE` format, which is equivalent to accessing "
"the :attr:`~TypeVar.__default__` attribute directly, but the method object "
"can be passed to :func:`annotationlib.call_evaluate_function` to evaluate "
"the value in a different format."
msgstr ""
"En :term:`evaluate-funktion` som motsvarar attributet :attr:`~TypeVar."
"__default__`. Vid direkt anrop stöder denna metod endast formatet :attr:"
"`~annotationlib.Format.VALUE`, vilket motsvarar direkt åtkomst till "
"attributet :attr:`~TypeVar.__default__`, men metodobjektet kan skickas till :"
"func:`annotationlib.call_evaluate_function` för att utvärdera värdet i ett "
"annat format."

msgid ""
"Return whether or not the type variable has a default value. This is "
"equivalent to checking whether :attr:`__default__` is not the :data:`typing."
"NoDefault` singleton, except that it does not force evaluation of the :ref:"
"`lazily evaluated <lazy-evaluation>` default value."
msgstr ""
"Returnerar om typvariabeln har ett standardvärde eller inte. Detta är "
"likvärdigt med att kontrollera om :attr:`__default__` inte är :data:`typing."
"NoDefault` singleton, förutom att det inte tvingar fram utvärdering av :ref:"
"`lazily evaluated <lazy-evaluation>` standardvärde."

msgid ""
"Type variables can now be declared using the :ref:`type parameter <type-"
"params>` syntax introduced by :pep:`695`. The ``infer_variance`` parameter "
"was added."
msgstr ""
"Typvariabler kan nu deklareras med hjälp av syntaxen :ref:`type parameter "
"<type-params>` som introducerades av :pep:`695`. Parametern "
"``infer_variance`` har lagts till."

msgid "Support for default values was added."
msgstr "Stöd för standardvärden har lagts till."

msgid ""
"Type variable tuple. A specialized form of :ref:`type variable <typevar>` "
"that enables *variadic* generics."
msgstr ""
"Typvariabel-tupel. En specialiserad form av :ref:`typvariabel <typevar>` som "
"möjliggör *variadisk* generik."

msgid ""
"Type variable tuples can be declared in :ref:`type parameter lists <type-"
"params>` using a single asterisk (``*``) before the name::"
msgstr ""
"Typvariabeltuples kan deklareras i :ref:`typparameterlistor <type-params>` "
"med en enda asterisk (``*``) före namnet::"

msgid ""
"def move_first_element_to_last[T, *Ts](tup: tuple[T, *Ts]) -> tuple[*Ts, "
"T]:\n"
"    return (*tup[1:], tup[0])"
msgstr ""
"def move_first_element_to_last[T, *Ts](tup: tuple[T, *Ts]) -> tuple[*Ts, "
"T]:\n"
"    return (*tup[1:], tup[0])"

msgid "Or by explicitly invoking the ``TypeVarTuple`` constructor::"
msgstr "Eller genom att uttryckligen anropa ``TypeVarTuple``-konstruktören::"

msgid ""
"T = TypeVar(\"T\")\n"
"Ts = TypeVarTuple(\"Ts\")\n"
"\n"
"def move_first_element_to_last(tup: tuple[T, *Ts]) -> tuple[*Ts, T]:\n"
"    return (*tup[1:], tup[0])"
msgstr ""
"T = TypVar(\"T\")\n"
"Ts = TypeVarTuple(\"Ts\")\n"
"\n"
"def move_first_element_to_last(tup: tuple[T, *Ts]) -> tuple[*Ts, T]:\n"
"    return (*tup[1:], tup[0])"

msgid ""
"A normal type variable enables parameterization with a single type. A type "
"variable tuple, in contrast, allows parameterization with an *arbitrary* "
"number of types by acting like an *arbitrary* number of type variables "
"wrapped in a tuple. For example::"
msgstr ""
"En normal typvariabel möjliggör parametrisering med en enda typ. En "
"typvariabel-tupel, däremot, tillåter parameterisering med ett *viljilöst* "
"antal typer genom att fungera som ett *viljilöst* antal typvariabler som är "
"förpackade i en tupel. Till exempel::"

msgid ""
"# T is bound to int, Ts is bound to ()\n"
"# Return value is (1,), which has type tuple[int]\n"
"move_first_element_to_last(tup=(1,))\n"
"\n"
"# T is bound to int, Ts is bound to (str,)\n"
"# Return value is ('spam', 1), which has type tuple[str, int]\n"
"move_first_element_to_last(tup=(1, 'spam'))\n"
"\n"
"# T is bound to int, Ts is bound to (str, float)\n"
"# Return value is ('spam', 3.0, 1), which has type tuple[str, float, int]\n"
"move_first_element_to_last(tup=(1, 'spam', 3.0))\n"
"\n"
"# This fails to type check (and fails at runtime)\n"
"# because tuple[()] is not compatible with tuple[T, *Ts]\n"
"# (at least one element is required)\n"
"move_first_element_to_last(tup=())"
msgstr ""
"# T är bundet till int, Ts är bundet till ()\n"
"# Returvärdet är (1,), som har typen tuple[int]\n"
"flytta_första_elementet_till_det_senaste(tup=(1,))\n"
"\n"
"# T är bundet till int, Ts är bundet till (str,)\n"
"# Returvärdet är ('spam', 1), som har typen tuple[str, int]\n"
"move_first_element_to_last(tup=(1, 'spam'))\n"
"\n"
"# T är bundet till int, Ts är bundet till (str, float)\n"
"# Returvärdet är ('spam', 3.0, 1), som har typen tuple[str, float, int]\n"
"move_first_element_to_last(tup=(1, 'spam', 3.0))\n"
"\n"
"# Detta misslyckas med typkontrollen (och misslyckas vid körning)\n"
"# eftersom tuple[()] inte är kompatibel med tuple[T, *Ts]\n"
"# (minst ett element krävs)\n"
"move_first_element_to_last(tup=())"

msgid ""
"Note the use of the unpacking operator ``*`` in ``tuple[T, *Ts]``. "
"Conceptually, you can think of ``Ts`` as a tuple of type variables ``(T1, "
"T2, ...)``. ``tuple[T, *Ts]`` would then become ``tuple[T, *(T1, "
"T2, ...)]``, which is equivalent to ``tuple[T, T1, T2, ...]``. (Note that in "
"older versions of Python, you might see this written using :data:`Unpack "
"<Unpack>` instead, as ``Unpack[Ts]``.)"
msgstr ""
"Notera användningen av uppackningsoperatorn ``*`` i ``tuple[T, *Ts]``. "
"Konceptuellt kan du tänka på ``Ts`` som en tupel av typvariabler ``(T1, "
"T2, ...)``. ``tuple[T, *Ts]`` skulle då bli ``tuple[T, *(T1, T2, ...)]``, "
"vilket är likvärdigt med ``tuple[T, T1, T2, ...]``. (Observera att i äldre "
"versioner av Python kan du se detta skrivet med :data:`Unpack <Unpack>` "
"istället, som ``Unpack[Ts]``.)"

msgid ""
"Type variable tuples must *always* be unpacked. This helps distinguish type "
"variable tuples from normal type variables::"
msgstr ""
"Typvariabeltuples måste *alltid* vara uppackade. Detta hjälper till att "
"skilja typvariabeltuples från vanliga typvariabler::"

msgid ""
"x: Ts          # Not valid\n"
"x: tuple[Ts]   # Not valid\n"
"x: tuple[*Ts]  # The correct way to do it"
msgstr ""
"x: Ts # Inte giltig\n"
"x: tuple[Ts] # Inte giltig\n"
"x: tuple[*Ts] # Det korrekta sättet att göra det"

msgid ""
"Type variable tuples can be used in the same contexts as normal type "
"variables. For example, in class definitions, arguments, and return types::"
msgstr ""
"Typvariabeltuples kan användas i samma sammanhang som vanliga typvariabler. "
"Till exempel i klassdefinitioner, argument och returtyper::"

msgid ""
"class Array[*Shape]:\n"
"    def __getitem__(self, key: tuple[*Shape]) -> float: ...\n"
"    def __abs__(self) -> \"Array[*Shape]\": ...\n"
"    def get_shape(self) -> tuple[*Shape]: ..."
msgstr ""
"klass Array[*Shape]:\n"
"    def __getitem__(self, key: tuple[*Shape]) -> float: ...\n"
"    def __abs__(self) -> \"Array[*Shape]\": ...\n"
"    def get_shape(self) -> tuple[*Shape]: ..."

msgid ""
"Type variable tuples can be happily combined with normal type variables:"
msgstr "Typvariabeltuples kan kombineras med vanliga typvariabler:"

msgid ""
"class Array[DType, *Shape]:  # This is fine\n"
"    pass\n"
"\n"
"class Array2[*Shape, DType]:  # This would also be fine\n"
"    pass\n"
"\n"
"class Height: ...\n"
"class Width: ...\n"
"\n"
"float_array_1d: Array[float, Height] = Array()     # Totally fine\n"
"int_array_2d: Array[int, Height, Width] = Array()  # Yup, fine too"
msgstr ""
"klass Array[DType, *Shape]:  # Det här är bra\n"
"    passera\n"
"\n"
"klassen Array2[*Shape, DType]:  # Det här skulle också vara bra\n"
"    pass\n"
"\n"
"klass Höjd: ...\n"
"class Bredd: ...\n"
"\n"
"float_array_1d: Array[float, Height] = Array() # Helt okej\n"
"int_array_2d: Array[int, Height, Width] = Array() # Japp, det går också bra"

msgid ""
"However, note that at most one type variable tuple may appear in a single "
"list of type arguments or type parameters::"
msgstr ""
"Observera dock att högst en typvariabel-tupel kan förekomma i en enda lista "
"med typargument eller typparametrar::"

msgid ""
"x: tuple[*Ts, *Ts]            # Not valid\n"
"class Array[*Shape, *Shape]:  # Not valid\n"
"    pass"
msgstr ""
"x: tuple[*Ts, *Ts] # Inte giltig\n"
"klass Array[*Shape, *Shape]:  # Inte giltig\n"
"    pass"

msgid ""
"Finally, an unpacked type variable tuple can be used as the type annotation "
"of ``*args``::"
msgstr ""
"Slutligen kan en uppackad typvariabel-tupel användas som typannotering för "
"``*args``::"

msgid ""
"def call_soon[*Ts](\n"
"    callback: Callable[[*Ts], None],\n"
"    *args: *Ts\n"
") -> None:\n"
"    ...\n"
"    callback(*args)"
msgstr ""
"def call_soon[*Ts](\n"
"    återuppringning: Kallbar[[*Ts], Ingen],\n"
"    *args: *Ts\n"
") -> Ingen:\n"
"    ...\n"
"    återuppringning(*args)"

msgid ""
"In contrast to non-unpacked annotations of ``*args`` - e.g. ``*args: int``, "
"which would specify that *all* arguments are ``int`` - ``*args: *Ts`` "
"enables reference to the types of the *individual* arguments in ``*args``. "
"Here, this allows us to ensure the types of the ``*args`` passed to "
"``call_soon`` match the types of the (positional) arguments of ``callback``."
msgstr ""
"I motsats till icke-uppackade annoteringar av ``*args`` - t.ex. ``*args: "
"int``, som skulle ange att *alla* argument är ``int`` - ``*args: *Ts`` "
"möjliggör referens till typerna av de *individuella* argumenten i ``*args``. "
"Här tillåter detta oss att säkerställa att typerna av ``*args`` som skickas "
"till ``call_soon`` matchar typerna av (positionella) argument i ``callback``."

msgid "See :pep:`646` for more details on type variable tuples."
msgstr "Se :pep:`646` för mer information om typvariabeltuples."

msgid "The name of the type variable tuple."
msgstr "Namnet på typvariabeln tuple."

msgid ""
"The default value of the type variable tuple, or :data:`typing.NoDefault` if "
"it has no default."
msgstr ""
"Standardvärdet för typvariabeln tuple, eller :data:`typing.NoDefault` om den "
"inte har något standardvärde."

msgid ""
"An :term:`evaluate function` corresponding to the :attr:`~TypeVarTuple."
"__default__` attribute. When called directly, this method supports only the :"
"attr:`~annotationlib.Format.VALUE` format, which is equivalent to accessing "
"the :attr:`~TypeVarTuple.__default__` attribute directly, but the method "
"object can be passed to :func:`annotationlib.call_evaluate_function` to "
"evaluate the value in a different format."
msgstr ""
"En :term:`evaluate-funktion` som motsvarar attributet :attr:`~TypeVarTuple."
"__default__`. Vid direkt anrop stöder denna metod endast formatet :attr:"
"`~annotationlib.Format.VALUE`, vilket motsvarar direkt åtkomst till "
"attributet :attr:`~TypeVarTuple.__default__`, men metodobjektet kan skickas "
"till :func:`annotationlib.call_evaluate_function` för att utvärdera värdet i "
"ett annat format."

msgid ""
"Return whether or not the type variable tuple has a default value. This is "
"equivalent to checking whether :attr:`__default__` is not the :data:`typing."
"NoDefault` singleton, except that it does not force evaluation of the :ref:"
"`lazily evaluated <lazy-evaluation>` default value."
msgstr ""
"Returnerar om typvariabeln tuple har ett standardvärde eller inte. Detta är "
"likvärdigt med att kontrollera om :attr:`__default__` inte är :data:`typing."
"NoDefault` singleton, förutom att det inte tvingar fram utvärdering av :ref:"
"`lazily evaluated <lazy-evaluation>` standardvärde."

msgid ""
"Type variable tuples can now be declared using the :ref:`type parameter "
"<type-params>` syntax introduced by :pep:`695`."
msgstr ""
"Typvariabeltuples kan nu deklareras med hjälp av syntaxen :ref:`type "
"parameter <type-params>` som introducerades av :pep:`695`."

msgid ""
"Parameter specification variable.  A specialized version of :ref:`type "
"variables <typevar>`."
msgstr ""
"Variabel för parameterspecifikation.  En specialiserad version av :ref:"
"`typvariabler <typevar>`."

msgid ""
"In :ref:`type parameter lists <type-params>`, parameter specifications can "
"be declared with two asterisks (``**``)::"
msgstr ""
"I :ref:``typ parameter lists <type-params>`` kan parameterspecifikationer "
"deklareras med två asterisker (``**``)::"

msgid "type IntFunc[**P] = Callable[P, int]"
msgstr "typ IntFunc[**P] = Anropsbar[P, int]"

msgid ""
"For compatibility with Python 3.11 and earlier, ``ParamSpec`` objects can "
"also be created as follows::"
msgstr ""
"För kompatibilitet med Python 3.11 och tidigare kan ``ParamSpec``-objekt "
"också skapas på följande sätt::"

msgid "P = ParamSpec('P')"
msgstr "P = ParamSpec('P')"

msgid ""
"Parameter specification variables exist primarily for the benefit of static "
"type checkers.  They are used to forward the parameter types of one callable "
"to another callable -- a pattern commonly found in higher order functions "
"and decorators.  They are only valid when used in ``Concatenate``, or as the "
"first argument to ``Callable``, or as parameters for user-defined Generics.  "
"See :class:`Generic` for more information on generic types."
msgstr ""
"Parameterspecifikationsvariabler är främst till för att underlätta för "
"statiska typkontrollanter.  De används för att vidarebefordra "
"parametertyperna för en anropbar till en annan anropbar -- ett mönster som "
"är vanligt förekommande i högre ordningens funktioner och dekoratorer.  De "
"är endast giltiga när de används i ``Concatenate``, eller som det första "
"argumentet till ``Callable``, eller som parametrar för användardefinierade "
"Generics.  Se :class:`Generic` för mer information om generiska typer."

msgid ""
"For example, to add basic logging to a function, one can create a decorator "
"``add_logging`` to log function calls.  The parameter specification variable "
"tells the type checker that the callable passed into the decorator and the "
"new callable returned by it have inter-dependent type parameters::"
msgstr ""
"Om man t.ex. vill lägga till grundläggande loggning i en funktion kan man "
"skapa en dekorator ``add_logging`` för att logga funktionsanrop.  "
"Parameterspecifikationsvariabeln talar om för typkontrollen att den "
"anropsbarhet som skickas till dekoratorn och den nya anropsbarhet som "
"returneras av den har typparametrar som är beroende av varandra::"

msgid ""
"from collections.abc import Callable\n"
"import logging\n"
"\n"
"def add_logging[T, **P](f: Callable[P, T]) -> Callable[P, T]:\n"
"    '''A type-safe decorator to add logging to a function.'''\n"
"    def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n"
"        logging.info(f'{f.__name__} was called')\n"
"        return f(*args, **kwargs)\n"
"    return inner\n"
"\n"
"@add_logging\n"
"def add_two(x: float, y: float) -> float:\n"
"    '''Add two numbers together.'''\n"
"    return x + y"
msgstr ""
"from collections.abc import Callable\n"
"import logging\n"
"\n"
"def add_logging[T, **P](f: Callable[P, T]) -> Callable[P, T]:\n"
"    '''A type-safe decorator to add logging to a function.'''\n"
"    def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n"
"        logging.info(f'{f.__name__} was called')\n"
"        return f(*args, **kwargs)\n"
"    return inner\n"
"\n"
"@add_logging\n"
"def add_two(x: float, y: float) -> float:\n"
"    '''Add two numbers together.'''\n"
"    return x + y"

msgid ""
"Without ``ParamSpec``, the simplest way to annotate this previously was to "
"use a :class:`TypeVar` with upper bound ``Callable[..., Any]``.  However "
"this causes two problems:"
msgstr ""
"Utan ``ParamSpec`` var det enklaste sättet att annotera detta tidigare att "
"använda en :class:`TypeVar` med övre gränsen ``Callable[..., Any]``.  Detta "
"orsakar dock två problem:"

msgid ""
"The type checker can't type check the ``inner`` function because ``*args`` "
"and ``**kwargs`` have to be typed :data:`Any`."
msgstr ""
"Typkontrollen kan inte typkontrollera funktionen ``inner`` eftersom "
"``*args`` och ``**kwargs`` måste vara typade :data:`Any`."

msgid ""
":func:`~cast` may be required in the body of the ``add_logging`` decorator "
"when returning the ``inner`` function, or the static type checker must be "
"told to ignore the ``return inner``."
msgstr ""
":func:`~cast` kan krävas i kroppen av ``add_logging`` dekoratorn när den "
"returnerar ``inner`` funktionen, eller så måste den statiska typkontrollen "
"sägas att ignorera ``return inner``."

msgid ""
"Since ``ParamSpec`` captures both positional and keyword parameters, ``P."
"args`` and ``P.kwargs`` can be used to split a ``ParamSpec`` into its "
"components.  ``P.args`` represents the tuple of positional parameters in a "
"given call and should only be used to annotate ``*args``.  ``P.kwargs`` "
"represents the mapping of keyword parameters to their values in a given "
"call, and should be only be used to annotate ``**kwargs``.  Both attributes "
"require the annotated parameter to be in scope. At runtime, ``P.args`` and "
"``P.kwargs`` are instances respectively of :class:`ParamSpecArgs` and :class:"
"`ParamSpecKwargs`."
msgstr ""
"Eftersom ``ParamSpec`` fångar både positionella parametrar och "
"nyckelordsparametrar kan ``P.args`` och ``P.kwargs`` användas för att dela "
"upp en ``ParamSpec`` i dess komponenter.  ``P.args`` representerar tupeln av "
"positionella parametrar i ett givet anrop och bör endast användas för att "
"annotera ``*args``.  ``P.kwargs`` representerar mappningen av "
"nyckelordsparametrar till deras värden i ett givet anrop och bör endast "
"användas för att annotera ``**kwargs``.  Båda attributen kräver att den "
"annoterade parametern är i scope. Vid körning är ``P.args`` och ``P.kwargs`` "
"instanser av :class:`ParamSpecArgs` respektive :class:`ParamSpecKwargs`."

msgid "The name of the parameter specification."
msgstr "Namnet på parameterspecifikationen."

msgid ""
"The default value of the parameter specification, or :data:`typing."
"NoDefault` if it has no default."
msgstr ""
"Standardvärdet för parameterspecifikationen, eller :data:`typing.NoDefault` "
"om den inte har något standardvärde."

msgid ""
"An :term:`evaluate function` corresponding to the :attr:`~ParamSpec."
"__default__` attribute. When called directly, this method supports only the :"
"attr:`~annotationlib.Format.VALUE` format, which is equivalent to accessing "
"the :attr:`~ParamSpec.__default__` attribute directly, but the method object "
"can be passed to :func:`annotationlib.call_evaluate_function` to evaluate "
"the value in a different format."
msgstr ""
"En :term:`evaluate-funktion` som motsvarar attributet :attr:`~ParamSpec."
"__default__`. Vid direkt anrop stöder denna metod endast formatet :attr:"
"`~annotationlib.Format.VALUE`, vilket motsvarar direkt åtkomst till "
"attributet :attr:`~ParamSpec.__default__`, men metodobjektet kan skickas "
"till :func:`annotationlib.call_evaluate_function` för att utvärdera värdet i "
"ett annat format."

msgid ""
"Return whether or not the parameter specification has a default value. This "
"is equivalent to checking whether :attr:`__default__` is not the :data:"
"`typing.NoDefault` singleton, except that it does not force evaluation of "
"the :ref:`lazily evaluated <lazy-evaluation>` default value."
msgstr ""
"Returnerar om parameterspecifikationen har ett standardvärde eller inte. "
"Detta är likvärdigt med att kontrollera om :attr:`__default__` inte är :data:"
"`typing.NoDefault` singleton, förutom att det inte tvingar fram utvärdering "
"av :ref:`lazily evaluated <lazy-evaluation>` standardvärde."

msgid ""
"Parameter specification variables created with ``covariant=True`` or "
"``contravariant=True`` can be used to declare covariant or contravariant "
"generic types.  The ``bound`` argument is also accepted, similar to :class:"
"`TypeVar`.  However the actual semantics of these keywords are yet to be "
"decided."
msgstr ""
"Parameterspecifikationsvariabler skapade med ``covariant=True`` eller "
"``contravariant=True`` kan användas för att deklarera kovarianta eller "
"kontravarianta generiska typer.  Argumentet ``bound`` accepteras också, på "
"samma sätt som för :class:`TypeVar`.  Den faktiska semantiken för dessa "
"nyckelord är dock ännu inte fastställd."

msgid ""
"Parameter specifications can now be declared using the :ref:`type parameter "
"<type-params>` syntax introduced by :pep:`695`."
msgstr ""
"Parameterspecifikationer kan nu deklareras med hjälp av syntaxen :ref:`type "
"parameter <type-params>` som introducerades av :pep:`695`."

msgid ""
"Only parameter specification variables defined in global scope can be "
"pickled."
msgstr ""
"Endast parameterspecifika variabler som definieras i global omfattning kan "
"picklas."

msgid ":data:`Concatenate`"
msgstr ":data:`Koncatenate`"

msgid ""
"Arguments and keyword arguments attributes of a :class:`ParamSpec`. The ``P."
"args`` attribute of a ``ParamSpec`` is an instance of ``ParamSpecArgs``, and "
"``P.kwargs`` is an instance of ``ParamSpecKwargs``. They are intended for "
"runtime introspection and have no special meaning to static type checkers."
msgstr ""
"Attribut för argument och nyckelordsargument för en :class:`ParamSpec`. "
"Attributet ``P.args`` för en ``ParamSpec`` är en instans av "
"``ParamSpecArgs``, och ``P.kwargs`` är en instans av ``ParamSpecKwargs``. De "
"är avsedda för introspektion under körning och har ingen särskild betydelse "
"för statiska typkontroller."

msgid ""
"Calling :func:`get_origin` on either of these objects will return the "
"original ``ParamSpec``:"
msgstr ""
"Anrop av :func:`get_origin` på något av dessa objekt kommer att returnera "
"den ursprungliga ``ParamSpec``:"

msgid ""
">>> from typing import ParamSpec, get_origin\n"
">>> P = ParamSpec(\"P\")\n"
">>> get_origin(P.args) is P\n"
"True\n"
">>> get_origin(P.kwargs) is P\n"
"True"
msgstr ""
">>> from typing import ParamSpec, get_origin\n"
">>> P = ParamSpec(\"P\")\n"
">>> get_origin(P.args) är P\n"
"Sant\n"
">>> get_origin(P.kwargs) är P\n"
"Sann"

msgid "The type of type aliases created through the :keyword:`type` statement."
msgstr "Typen av typalias som skapas genom :keyword:`type`-satsen."

msgid ""
">>> type Alias = int\n"
">>> type(Alias)\n"
"<class 'typing.TypeAliasType'>"
msgstr ""
">>> typ Alias = int\n"
">>> typ(Alias)\n"
"<klass 'typing.TypeAliasType'>"

msgid "The name of the type alias:"
msgstr "Namnet på typaliaset:"

msgid ""
">>> type Alias = int\n"
">>> Alias.__name__\n"
"'Alias'"
msgstr ""
">>> typ Alias = int\n"
">>> Alias.__name__\n"
"'Alias'"

msgid "The module in which the type alias was defined::"
msgstr "Den modul där typaliaset definierades::"

msgid ""
">>> type Alias = int\n"
">>> Alias.__module__\n"
"'__main__'"
msgstr ""
">>> typ Alias = int\n"
">>> Alias.__module__\n"
"'__main__'"

msgid ""
"The type parameters of the type alias, or an empty tuple if the alias is not "
"generic:"
msgstr ""
"Typparametrarna för typaliaset, eller en tom tupel om aliaset inte är "
"generiskt:"

msgid ""
">>> type ListOrSet[T] = list[T] | set[T]\n"
">>> ListOrSet.__type_params__\n"
"(T,)\n"
">>> type NotGeneric = int\n"
">>> NotGeneric.__type_params__\n"
"()"
msgstr ""
">>> typ ListOrSet[T] = list[T] | set[T]\n"
">>> ListOrSet.__type_params__\n"
"(T,)\n"
">>> typ NotGeneric = int\n"
">>> NotGeneric.__type_params__ (T,)\n"
"()"

msgid ""
"The type alias's value. This is :ref:`lazily evaluated <lazy-evaluation>`, "
"so names used in the definition of the alias are not resolved until the "
"``__value__`` attribute is accessed:"
msgstr ""
"Typaliasets värde. Detta är :ref:``lazily evaluated <lazy-evaluation>``, så "
"namn som används i definitionen av aliaset löses inte förrän attributet "
"``__value__`` nås:"

msgid ""
">>> type Mutually = Recursive\n"
">>> type Recursive = Mutually\n"
">>> Mutually\n"
"Mutually\n"
">>> Recursive\n"
"Recursive\n"
">>> Mutually.__value__\n"
"Recursive\n"
">>> Recursive.__value__\n"
"Mutually"
msgstr ""
">>> typ Ömsesidigt = Rekursiv\n"
">>> typ Rekursiv = Ömsesidigt\n"
">>> Mutuellt\n"
"Ömsesidigt\n"
">>> Rekursiv\n"
"Rekursiv\n"
">>> Ömsesidigt.__värde__\n"
"Rekursiv\n"
">>> Rekursiv.__värde__\n"
"Ömsesidigt"

msgid ""
"An :term:`evaluate function` corresponding to the :attr:`__value__` "
"attribute. When called directly, this method supports only the :attr:"
"`~annotationlib.Format.VALUE` format, which is equivalent to accessing the :"
"attr:`__value__` attribute directly, but the method object can be passed to :"
"func:`annotationlib.call_evaluate_function` to evaluate the value in a "
"different format:"
msgstr ""
"En :term:`evaluate-funktion` som motsvarar attributet :attr:`__value__`. Vid "
"direkt anrop stöder denna metod endast formatet :attr:`~annotationlib.Format."
"VALUE`, vilket motsvarar direkt åtkomst till attributet :attr:`__value__`, "
"men metodobjektet kan skickas till :func:`annotationlib."
"call_evaluate_function` för att utvärdera värdet i ett annat format:"

msgid ""
">>> type Alias = undefined\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"...\n"
"NameError: name 'undefined' is not defined\n"
">>> from annotationlib import Format, call_evaluate_function\n"
">>> Alias.evaluate_value(Format.VALUE)\n"
"Traceback (most recent call last):\n"
"...\n"
"NameError: name 'undefined' is not defined\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.FORWARDREF)\n"
"ForwardRef('undefined')"
msgstr ""
">>> typ Alias = odefinierad\n"
">>> Alias.__värde__\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"NameError: namnet 'undefined' är inte definierat\n"
">>> from annotationlib import Format, call_evaluate_function\n"
">>> Alias.evaluate_value(Format.VALUE)\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"NameError: namnet 'undefined' är inte definierat\n"
">>> call_evaluate_function(Alias.evaluate_value, Format.FORWARDREF)\n"
"ForwardRef('odefinierad')"

msgid "Unpacking"
msgstr "Uppackning"

msgid ""
"Type aliases support star unpacking using the ``*Alias`` syntax. This is "
"equivalent to using ``Unpack[Alias]`` directly:"
msgstr ""
"Typalias stöder uppackning av stjärnor med hjälp av syntaxen ``*Alias``. "
"Detta är likvärdigt med att använda ``Unpack[Alias]`` direkt:"

msgid ""
">>> type Alias = tuple[int, str]\n"
">>> type Unpacked = tuple[bool, *Alias]\n"
">>> Unpacked.__value__\n"
"tuple[bool, typing.Unpack[Alias]]"
msgstr ""
">>> typ Alias = tuple[int, str]\n"
">>> typ Unpacked = tuple[bool, *Alias]\n"
">>> Uppackad.__värde__\n"
"tuple[bool, typing.Unpack[Alias]]"

msgid "Other special directives"
msgstr "Andra särskilda direktiv"

msgid ""
"These functions and classes should not be used directly as annotations. "
"Their intended purpose is to be building blocks for creating and declaring "
"types."
msgstr ""
"Dessa funktioner och klasser ska inte användas direkt som annotationer. "
"Deras avsedda syfte är att vara byggstenar för att skapa och deklarera typer."

msgid "Typed version of :func:`collections.namedtuple`."
msgstr "Typad version av :func:`collections.namedtuple`."

msgid "Usage::"
msgstr "Användning::"

msgid ""
"class Employee(NamedTuple):\n"
"    name: str\n"
"    id: int"
msgstr ""
"class Anställd(NamedTuple):\n"
"    name: str\n"
"    id: int"

msgid "This is equivalent to::"
msgstr "Detta är likvärdigt med::"

msgid "Employee = collections.namedtuple('Employee', ['name', 'id'])"
msgstr "Anställd = collections.namedtuple('Anställd', ['namn', 'id'])"

msgid ""
"To give a field a default value, you can assign to it in the class body::"
msgstr ""
"För att ge ett fält ett standardvärde kan du tilldela det i klassen body::"

msgid ""
"class Employee(NamedTuple):\n"
"    name: str\n"
"    id: int = 3\n"
"\n"
"employee = Employee('Guido')\n"
"assert employee.id == 3"
msgstr ""
"class Anställd(NamedTuple):\n"
"    name: str\n"
"    id: int = 3\n"
"\n"
"anställd = Anställd('Guido')\n"
"assert anställd.id == 3"

msgid ""
"Fields with a default value must come after any fields without a default."
msgstr ""
"Fält med ett standardvärde måste komma efter alla fält utan standardvärde."

msgid ""
"The resulting class has an extra attribute ``__annotations__`` giving a dict "
"that maps the field names to the field types.  (The field names are in the "
"``_fields`` attribute and the default values are in the ``_field_defaults`` "
"attribute, both of which are part of the :func:`~collections.namedtuple` "
"API.)"
msgstr ""
"Den resulterande klassen har ett extra attribut ``__annotations__`` som ger "
"en dict som mappar fältnamnen till fälttyperna.  (Fältnamnen finns i "
"attributet ``_fields`` och standardvärdena finns i attributet "
"``_field_defaults``, som båda är en del av :func:`~collections.namedtuple` "
"API)"

msgid "``NamedTuple`` subclasses can also have docstrings and methods::"
msgstr "``NamedTuple`` subklasser kan också ha docstrings och metoder::"

msgid ""
"class Employee(NamedTuple):\n"
"    \"\"\"Represents an employee.\"\"\"\n"
"    name: str\n"
"    id: int = 3\n"
"\n"
"    def __repr__(self) -> str:\n"
"        return f'<Employee {self.name}, id={self.id}>'"
msgstr ""
"class Anställd(NamedTuple):\n"
"    \"\"\"Representerar en anställd.\"\"\"\n"
"    namn: str\n"
"    id: int = 3\n"
"\n"
"    def __repr__(self) -> str:\n"
"        return f'<Anställd {self.name}, id={self.id}>'"

msgid "``NamedTuple`` subclasses can be generic::"
msgstr "``NamedTuple`` subklasser kan vara generiska::"

msgid ""
"class Group[T](NamedTuple):\n"
"    key: T\n"
"    group: list[T]"
msgstr ""
"class Group[T](NamedTuple):\n"
"    nyckel: T\n"
"    group: lista[T]"

msgid "Backward-compatible usage::"
msgstr "Bakåtkompatibel användning::"

msgid ""
"# For creating a generic NamedTuple on Python 3.11\n"
"T = TypeVar(\"T\")\n"
"\n"
"class Group(NamedTuple, Generic[T]):\n"
"    key: T\n"
"    group: list[T]\n"
"\n"
"# A functional syntax is also supported\n"
"Employee = NamedTuple('Employee', [('name', str), ('id', int)])"
msgstr ""
"# För att skapa en generisk NamedTuple på Python 3.11\n"
"T = TypeVar(\"T\")\n"
"\n"
"class Group(NamedTuple, Generisk[T]):\n"
"    nyckel: T\n"
"    group: lista[T]\n"
"\n"
"# Det finns också stöd för en funktionell syntax\n"
"Employee = NamedTuple('Employee', [('name', str), ('id', int)])"

msgid "Added support for :pep:`526` variable annotation syntax."
msgstr "Lagt till stöd för :pep:`526` variabelannotationssyntax."

msgid "Added support for default values, methods, and docstrings."
msgstr "Stöd för standardvärden, metoder och docstrings har lagts till."

msgid ""
"The ``_field_types`` and ``__annotations__`` attributes are now regular "
"dictionaries instead of instances of ``OrderedDict``."
msgstr ""
"Attributen ``_field_types`` och ``__annotations__`` är nu vanliga ordböcker "
"istället för instanser av ``OrderedDict``."

msgid ""
"Removed the ``_field_types`` attribute in favor of the more standard "
"``__annotations__`` attribute which has the same information."
msgstr ""
"Attributet ``_field_types`` har tagits bort till förmån för det mer "
"standardiserade attributet ``__annotations__`` som innehåller samma "
"information."

msgid "Added support for generic namedtuples."
msgstr "Lagt till stöd för generiska namntuples."

msgid ""
"Using :func:`super` (and the ``__class__`` :term:`closure variable`) in "
"methods of ``NamedTuple`` subclasses is unsupported and causes a :class:"
"`TypeError`."
msgstr ""
"Att använda :func:`super` (och ``__class__`` :term:`closure variable`) i "
"metoder i underklasser till ``NamedTuple`` stöds inte och orsakar ett :class:"
"`TypeError`."

msgid ""
"The undocumented keyword argument syntax for creating NamedTuple classes "
"(``NT = NamedTuple(\"NT\", x=int)``) is deprecated, and will be disallowed "
"in 3.15. Use the class-based syntax or the functional syntax instead."
msgstr ""
"Den odokumenterade syntaxen med nyckelordsargument för att skapa NamedTuple-"
"klasser (``NT = NamedTuple(\"NT\", x=int)``) är föråldrad och kommer att "
"förbjudas i 3.15. Använd den klassbaserade syntaxen eller den funktionella "
"syntaxen istället."

msgid ""
"When using the functional syntax to create a NamedTuple class, failing to "
"pass a value to the 'fields' parameter (``NT = NamedTuple(\"NT\")``) is "
"deprecated. Passing ``None`` to the 'fields' parameter (``NT = "
"NamedTuple(\"NT\", None)``) is also deprecated. Both will be disallowed in "
"Python 3.15. To create a NamedTuple class with 0 fields, use ``class "
"NT(NamedTuple): pass`` or ``NT = NamedTuple(\"NT\", [])``."
msgstr ""
"När du använder den funktionella syntaxen för att skapa en NamedTuple-klass "
"är det föråldrat att inte skicka ett värde till parametern 'fields' (``NT = "
"NamedTuple(\"NT\")``). Att skicka ``None`` till parametern 'fields' (``NT = "
"NamedTuple(\"NT\", None)``) är också föråldrat. Båda kommer att vara "
"otillåtna i Python 3.15. För att skapa en NamedTuple-klass med 0 fält, "
"använd ``class NT(NamedTuple): pass`` eller ``NT = NamedTuple(\"NT\", [])``."

msgid "Helper class to create low-overhead :ref:`distinct types <distinct>`."
msgstr ""
"Hjälpklass för att skapa låga kostnader :ref:`distinct types <distinct>`."

msgid ""
"A ``NewType`` is considered a distinct type by a typechecker. At runtime, "
"however, calling a ``NewType`` returns its argument unchanged."
msgstr ""
"En ``NewType`` betraktas som en distinkt typ av en typkontrollör. Vid "
"körning returnerar dock anrop av en ``NewType`` dess argument oförändrat."

msgid ""
"UserId = NewType('UserId', int)  # Declare the NewType \"UserId\"\n"
"first_user = UserId(1)  # \"UserId\" returns the argument unchanged at "
"runtime"
msgstr ""
"UserId = NewType('UserId', int) # Deklarera NewType \"UserId\"\n"
"first_user = UserId(1) # \"UserId\" returnerar argumentet oförändrat vid "
"körning"

msgid "The module in which the new type is defined."
msgstr "Den modul i vilken den nya typen definieras."

msgid "The name of the new type."
msgstr "Namnet på den nya typen."

msgid "The type that the new type is based on."
msgstr "Den typ som den nya typen är baserad på."

msgid "``NewType`` is now a class rather than a function."
msgstr "``NewType`` är nu en klass snarare än en funktion."

msgid "Base class for protocol classes."
msgstr "Basklass för protokollklasser."

msgid "Protocol classes are defined like this::"
msgstr "Protokollklasserna definieras på följande sätt::"

msgid ""
"class Proto(Protocol):\n"
"    def meth(self) -> int:\n"
"        ..."
msgstr ""
"klass Proto(Protokoll):\n"
"    def meth(self) -> int:\n"
"        ..."

msgid ""
"Such classes are primarily used with static type checkers that recognize "
"structural subtyping (static duck-typing), for example::"
msgstr ""
"Sådana klasser används främst med statiska typkontrollprogram som känner "
"igen strukturell subtypning (statisk duck-typning), t.ex:"

msgid ""
"class C:\n"
"    def meth(self) -> int:\n"
"        return 0\n"
"\n"
"def func(x: Proto) -> int:\n"
"    return x.meth()\n"
"\n"
"func(C())  # Passes static type check"
msgstr ""
"klass C:\n"
"    def meth(self) -> int:\n"
"        return 0\n"
"\n"
"def func(x: Proto) -> int:\n"
"    return x.meth()\n"
"\n"
"func(C()) # Passerar statisk typkontroll"

msgid ""
"See :pep:`544` for more details. Protocol classes decorated with :func:"
"`runtime_checkable` (described later) act as simple-minded runtime protocols "
"that check only the presence of given attributes, ignoring their type "
"signatures. Protocol classes without this decorator cannot be used as the "
"second argument to :func:`isinstance` or :func:`issubclass`."
msgstr ""
"Se :pep:`544` för mer information. Protokollklasser dekorerade med :func:"
"`runtime_checkable` (beskrivs senare) fungerar som enkla körtidsprotokoll "
"som endast kontrollerar förekomsten av givna attribut och ignorerar deras "
"typsignaturer. Protokollklasser utan denna dekorator kan inte användas som "
"det andra argumentet till :func:`isinstance` eller :func:`issubclass`."

msgid "Protocol classes can be generic, for example::"
msgstr "Protokollklasserna kan vara generiska, till exempel::"

msgid ""
"class GenProto[T](Protocol):\n"
"    def meth(self) -> T:\n"
"        ..."
msgstr ""
"klass GenProto[T](Protokoll):\n"
"    def meth(self) -> T:\n"
"        ..."

msgid ""
"In code that needs to be compatible with Python 3.11 or older, generic "
"Protocols can be written as follows::"
msgstr ""
"I kod som måste vara kompatibel med Python 3.11 eller äldre kan generiska "
"protokoll skrivas på följande sätt::"

msgid ""
"T = TypeVar(\"T\")\n"
"\n"
"class GenProto(Protocol[T]):\n"
"    def meth(self) -> T:\n"
"        ..."
msgstr ""
"T = TypVar(\"T\")\n"
"\n"
"klass GenProto(Protokoll[T]):\n"
"    def meth(self) -> T:\n"
"        ..."

msgid "Mark a protocol class as a runtime protocol."
msgstr "Markera en protokollklass som ett runtime-protokoll."

msgid ""
"Such a protocol can be used with :func:`isinstance` and :func:`issubclass`. "
"This allows a simple-minded structural check, very similar to \"one trick "
"ponies\" in :mod:`collections.abc` such as :class:`~collections.abc."
"Iterable`.  For example::"
msgstr ""
"Ett sådant protokoll kan användas med :func:`isinstance` och :func:"
"`issubclass`. Detta möjliggör en enkel strukturell kontroll, mycket lik "
"\"one trick ponies\" i :mod:`collections.abc` såsom :class:`~collections.abc."
"Iterable`.  Till exempel::"

msgid ""
"@runtime_checkable\n"
"class Closable(Protocol):\n"
"    def close(self): ...\n"
"\n"
"assert isinstance(open('/some/file'), Closable)\n"
"\n"
"@runtime_checkable\n"
"class Named(Protocol):\n"
"    name: str\n"
"\n"
"import threading\n"
"assert isinstance(threading.Thread(name='Bob'), Named)"
msgstr ""
"@runtime_checkable\n"
"class Closable(Protocol):\n"
"    def close(self): ...\n"
"\n"
"assert isinstance(open('/some/file'), Closable)\n"
"\n"
"@runtime_checkable\n"
"class Named(Protocol):\n"
"    name: str\n"
"\n"
"import threading\n"
"assert isinstance(threading.Thread(name='Bob'), Named)"

msgid ""
"This decorator raises :exc:`TypeError` when applied to a non-protocol class."
msgstr ""
"Denna dekorator ger upphov till :exc:`TypeError` när den tillämpas på en "
"icke-protokollklass."

msgid ""
":func:`!runtime_checkable` will check only the presence of the required "
"methods or attributes, not their type signatures or types. For example, :"
"class:`ssl.SSLObject` is a class, therefore it passes an :func:`issubclass` "
"check against :ref:`Callable <annotating-callables>`. However, the ``ssl."
"SSLObject.__init__`` method exists only to raise a :exc:`TypeError` with a "
"more informative message, therefore making it impossible to call "
"(instantiate) :class:`ssl.SSLObject`."
msgstr ""
":func:`!runtime_checkable` kontrollerar endast förekomsten av de nödvändiga "
"metoderna eller attributen, inte deras typsignaturer eller typer. Till "
"exempel är :class:`ssl.SSLObject` en klass, därför klarar den en :func:"
"`issubclass`-kontroll mot :ref:`Callable <annotating-callables>`. Men "
"metoden ``ssl.SSLObject.__init__`` existerar bara för att ge upphov till "
"ett :exc:`TypeError` med ett mer informativt meddelande, vilket gör det "
"omöjligt att anropa (instansiera) :class:`ssl.SSLObject`."

msgid ""
"An :func:`isinstance` check against a runtime-checkable protocol can be "
"surprisingly slow compared to an ``isinstance()`` check against a non-"
"protocol class. Consider using alternative idioms such as :func:`hasattr` "
"calls for structural checks in performance-sensitive code."
msgstr ""
"En :func:`isinstance`-kontroll mot ett protokoll som kan kontrolleras under "
"körtiden kan vara förvånansvärt långsam jämfört med en ``isinstance()``-"
"kontroll mot en icke-protokollklass. Överväg att använda alternativa idiom "
"som :func:`hasattr`-anrop för strukturella kontroller i prestandakänslig kod."

msgid ""
"The internal implementation of :func:`isinstance` checks against runtime-"
"checkable protocols now uses :func:`inspect.getattr_static` to look up "
"attributes (previously, :func:`hasattr` was used). As a result, some objects "
"which used to be considered instances of a runtime-checkable protocol may no "
"longer be considered instances of that protocol on Python 3.12+, and vice "
"versa. Most users are unlikely to be affected by this change."
msgstr ""
"Den interna implementationen av :func:`isinstance`-kontroller mot runtime-"
"checkable-protokoll använder nu :func:`inspect.getattr_static` för att leta "
"upp attribut (tidigare användes :func:`hasattr`). Som ett resultat kan vissa "
"objekt som tidigare betraktades som instanser av ett runtime-checkable-"
"protokoll inte längre betraktas som instanser av det protokollet på Python "
"3.12+, och vice versa. De flesta användare kommer troligen inte att påverkas "
"av denna ändring."

msgid ""
"The members of a runtime-checkable protocol are now considered \"frozen\" at "
"runtime as soon as the class has been created. Monkey-patching attributes "
"onto a runtime-checkable protocol will still work, but will have no impact "
"on :func:`isinstance` checks comparing objects to the protocol. See :ref:"
"`What's new in Python 3.12 <whatsnew-typing-py312>` for more details."
msgstr ""
"Medlemmarna i ett protokoll som kan kontrolleras vid körning betraktas nu "
"som ”frysta” vid körning så snart klassen har skapats. Att lägga till "
"attribut till ett protokoll som kan kontrolleras vid körning fungerar "
"fortfarande, men har ingen inverkan på :func:`isinstance`-kontroller som "
"jämför objekt med protokollet. Se :ref:`Vad är nytt i Python 3.12 <whatsnew-"
"typing-py312>` för mer information."

msgid ""
"Special construct to add type hints to a dictionary. At runtime it is a "
"plain :class:`dict`."
msgstr ""
"Specialkonstruktion för att lägga till typtips i en ordbok. Vid körning är "
"det en vanlig :class:`dict`."

msgid ""
"``TypedDict`` declares a dictionary type that expects all of its instances "
"to have a certain set of keys, where each key is associated with a value of "
"a consistent type. This expectation is not checked at runtime but is only "
"enforced by type checkers. Usage::"
msgstr ""
"``TypedDict`` deklarerar en ordbokstyp som förväntar sig att alla dess "
"instanser ska ha en viss uppsättning nycklar, där varje nyckel är associerad "
"med ett värde av en konsekvent typ. Denna förväntan kontrolleras inte vid "
"körning utan verkställs endast av typkontrollanter. Användning::"

msgid ""
"class Point2D(TypedDict):\n"
"    x: int\n"
"    y: int\n"
"    label: str\n"
"\n"
"a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n"
"b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n"
"\n"
"assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')"
msgstr ""
"klass Point2D(TypedDict):\n"
"    x: int\n"
"    y: int\n"
"    etikett: str\n"
"\n"
"a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n"
"b: Point2D = {'z': 3, 'label': 'bad'}           # Misslyckas med "
"typkontroll\n"
"\n"
"assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')"

msgid ""
"An alternative way to create a ``TypedDict`` is by using function-call "
"syntax. The second argument must be a literal :class:`dict`::"
msgstr ""
"Ett alternativt sätt att skapa en ``TypedDict`` är att använda syntax för "
"funktionsanrop. Det andra argumentet måste vara en bokstavlig :class:`dict`::"

msgid "Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})"
msgstr "Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})"

msgid ""
"This functional syntax allows defining keys which are not valid :ref:"
"`identifiers <identifiers>`, for example because they are keywords or "
"contain hyphens, or when key names must not be :ref:`mangled <private-name-"
"mangling>` like regular private names::"
msgstr ""
"Denna funktionella syntax gör det möjligt att definiera nycklar som inte är "
"giltiga :ref:`identifierare <identifiers>`, till exempel för att de är "
"nyckelord eller innehåller bindestreck, eller när nyckelnamn inte får :ref:"
"`manglas <private-name-mangling>` som vanliga privata namn::"

msgid ""
"# raises SyntaxError\n"
"class Point2D(TypedDict):\n"
"    in: int  # 'in' is a keyword\n"
"    x-y: int  # name with hyphens\n"
"\n"
"class Definition(TypedDict):\n"
"    __schema: str  # mangled to `_Definition__schema`\n"
"\n"
"# OK, functional syntax\n"
"Point2D = TypedDict('Point2D', {'in': int, 'x-y': int})\n"
"Definition = TypedDict('Definition', {'__schema': str})  # not mangled"
msgstr ""
"# raises SyntaxError\n"
"klass Point2D(TypedDict):\n"
"    in: int # 'in' är ett nyckelord\n"
"    x-y: int # namn med bindestreck\n"
"\n"
"klass Definition(TypedDict):\n"
"    __schema: str # manglad till `_Definition__schema`\n"
"\n"
"# OK, funktionell syntax\n"
"Point2D = TypedDict('Point2D', {'in': int, 'x-y': int})\n"
"Definition = TypedDict('Definition', {'__schema': str}) # inte manglad"

msgid ""
"By default, all keys must be present in a ``TypedDict``. It is possible to "
"mark individual keys as non-required using :data:`NotRequired`::"
msgstr ""
"Som standard måste alla nycklar finnas i en ``TypedDict``. Det är möjligt "
"att markera enskilda nycklar som icke-obligatoriska med :data:`NotRequired`::"

msgid ""
"class Point2D(TypedDict):\n"
"    x: int\n"
"    y: int\n"
"    label: NotRequired[str]\n"
"\n"
"# Alternative syntax\n"
"Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': "
"NotRequired[str]})"
msgstr ""
"klass Point2D(TypedDict):\n"
"    x: int\n"
"    y: int\n"
"    etikett: InteKrävs[str]\n"
"\n"
"# Alternativ syntax\n"
"Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': "
"NotRequired[str]})"

msgid ""
"This means that a ``Point2D`` ``TypedDict`` can have the ``label`` key "
"omitted."
msgstr ""
"Detta innebär att en ``Point2D`` ``TypedDict`` kan ha nyckeln ``label`` "
"utelämnad."

msgid ""
"It is also possible to mark all keys as non-required by default by "
"specifying a totality of ``False``::"
msgstr ""
"Det är också möjligt att markera alla nycklar som icke nödvändiga som "
"standard genom att ange ett antal ``False``::"

msgid ""
"class Point2D(TypedDict, total=False):\n"
"    x: int\n"
"    y: int\n"
"\n"
"# Alternative syntax\n"
"Point2D = TypedDict('Point2D', {'x': int, 'y': int}, total=False)"
msgstr ""
"class Point2D(TypedDict, total=False):\n"
"    x: int\n"
"    y: int\n"
"\n"
"# Alternativ syntax\n"
"Point2D = TypedDict('Point2D', {'x': int, 'y': int}, total=False)"

msgid ""
"This means that a ``Point2D`` ``TypedDict`` can have any of the keys "
"omitted. A type checker is only expected to support a literal ``False`` or "
"``True`` as the value of the ``total`` argument. ``True`` is the default, "
"and makes all items defined in the class body required."
msgstr ""
"Detta innebär att en ``Point2D`` ``TypedDict`` kan ha någon av nycklarna "
"utelämnad. En typkontroll förväntas endast stödja en bokstavlig ``False`` "
"eller ``True`` som värdet av ``total`` argumentet. ``True`` är standard och "
"gör att alla objekt som definieras i klassens kropp är obligatoriska."

msgid ""
"Individual keys of a ``total=False`` ``TypedDict`` can be marked as required "
"using :data:`Required`::"
msgstr ""
"Enskilda nycklar i en ``TypedDict`` med ``total=False`` kan markeras som "
"obligatoriska med :data:`Required`::"

msgid ""
"class Point2D(TypedDict, total=False):\n"
"    x: Required[int]\n"
"    y: Required[int]\n"
"    label: str\n"
"\n"
"# Alternative syntax\n"
"Point2D = TypedDict('Point2D', {\n"
"    'x': Required[int],\n"
"    'y': Required[int],\n"
"    'label': str\n"
"}, total=False)"
msgstr ""
"class Point2D(TypedDict, total=False):\n"
"    x: Krävs[int]\n"
"    y: Krävs[int]\n"
"    etikett: str\n"
"\n"
"# Alternativ syntax\n"
"Point2D = TypedDict('Point2D', {\n"
"    'x': Krävs[int],\n"
"    'y': Krävs[int],\n"
"    'label': str\n"
"}, total=False)"

msgid ""
"It is possible for a ``TypedDict`` type to inherit from one or more other "
"``TypedDict`` types using the class-based syntax. Usage::"
msgstr ""
"Det är möjligt för en typ av ``TypedDict`` att ärva från en eller flera "
"andra typer av ``TypedDict`` med hjälp av den klassbaserade syntaxen. "
"Användning::"

msgid ""
"class Point3D(Point2D):\n"
"    z: int"
msgstr ""
"klass Point3D(Point2D):\n"
"    z: int"

msgid ""
"``Point3D`` has three items: ``x``, ``y`` and ``z``. It is equivalent to "
"this definition::"
msgstr ""
"``Point3D`` har tre objekt: ``x``, ``y`` och ``z``. Den är ekvivalent med "
"denna definition::"

msgid ""
"class Point3D(TypedDict):\n"
"    x: int\n"
"    y: int\n"
"    z: int"
msgstr ""
"klass Point3D(TypedDict):\n"
"    x: int\n"
"    y: int\n"
"    z: int"

msgid ""
"A ``TypedDict`` cannot inherit from a non-\\ ``TypedDict`` class, except "
"for :class:`Generic`. For example::"
msgstr ""
"En ``TypedDict`` kan inte ärva från en icke ``TypedDict``-klass, förutom :"
"class:`Generic``. Till exempel::"

msgid ""
"class X(TypedDict):\n"
"    x: int\n"
"\n"
"class Y(TypedDict):\n"
"    y: int\n"
"\n"
"class Z(object): pass  # A non-TypedDict class\n"
"\n"
"class XY(X, Y): pass  # OK\n"
"\n"
"class XZ(X, Z): pass  # raises TypeError"
msgstr ""
"klass X(TypedDict):\n"
"    x: int\n"
"\n"
"klass Y(TypedDict):\n"
"    y: int\n"
"\n"
"class Z(object): pass # En icke-TypedDict-klass\n"
"\n"
"class XY(X, Y): pass # OK\n"
"\n"
"class XZ(X, Z): pass # ger upphov till TypeError"

msgid "A ``TypedDict`` can be generic::"
msgstr "En ``TypedDict`` kan vara generisk::"

msgid ""
"class Group[T](TypedDict):\n"
"    key: T\n"
"    group: list[T]"
msgstr ""
"class Group[T](TypedDict):\n"
"    nyckel: T\n"
"    group: lista[T]"

msgid ""
"To create a generic ``TypedDict`` that is compatible with Python 3.11 or "
"lower, inherit from :class:`Generic` explicitly:"
msgstr ""
"För att skapa en generisk ``TypedDict`` som är kompatibel med Python 3.11 "
"eller lägre, ärva från :class:`Generic` explicit:"

msgid ""
"T = TypeVar(\"T\")\n"
"\n"
"class Group(TypedDict, Generic[T]):\n"
"    key: T\n"
"    group: list[T]"
msgstr ""
"T = TypVar(\"T\")\n"
"\n"
"class Group(TypedDict, Generisk[T]):\n"
"    nyckel: T\n"
"    group: lista[T]"

msgid ""
"A ``TypedDict`` can be introspected via annotations dicts (see :ref:"
"`annotations-howto` for more information on annotations best practices), :"
"attr:`__total__`, :attr:`__required_keys__`, and :attr:`__optional_keys__`."
msgstr ""
"En ``TypedDict`` kan introspekteras via annotationsdict (se :ref:"
"`annotations-howto` för mer information om bästa praxis för annotationer), :"
"attr:`__total__`, :attr:`__required_keys__` och :attr:`__optional_keys__`."

msgid ""
"``Point2D.__total__`` gives the value of the ``total`` argument. Example:"
msgstr "``Point2D.__total__`` ger värdet av argumentet ``total``. Exempel:"

msgid ""
">>> from typing import TypedDict\n"
">>> class Point2D(TypedDict): pass\n"
">>> Point2D.__total__\n"
"True\n"
">>> class Point2D(TypedDict, total=False): pass\n"
">>> Point2D.__total__\n"
"False\n"
">>> class Point3D(Point2D): pass\n"
">>> Point3D.__total__\n"
"True"
msgstr ""
">>> from typing import TypedDict\n"
">>> class Point2D(TypedDict): pass\n"
">>> Point2D.__total__\n"
"Sann\n"
">>> class Point2D(TypedDict, total=False): pass\n"
">>> Point2D.__total__\n"
"False\n"
">>> klass Point3D(Point2D): pass\n"
">>> Point3D.__total__\n"
"True"

msgid ""
"This attribute reflects *only* the value of the ``total`` argument to the "
"current ``TypedDict`` class, not whether the class is semantically total. "
"For example, a ``TypedDict`` with ``__total__`` set to ``True`` may have "
"keys marked with :data:`NotRequired`, or it may inherit from another "
"``TypedDict`` with ``total=False``. Therefore, it is generally better to "
"use :attr:`__required_keys__` and :attr:`__optional_keys__` for "
"introspection."
msgstr ""
"Detta attribut återspeglar *endast* värdet av argumentet ``total`` till den "
"aktuella ``TypedDict``-klassen, inte om klassen är semantiskt total. Till "
"exempel kan en ``TypedDict`` med ``__total__`` satt till ``True`` ha nycklar "
"markerade med :data:`NotRequired`, eller så kan den ärva från en annan "
"``TypedDict`` med ``total=False``. Därför är det i allmänhet bättre att "
"använda :attr:`__required_keys__` och :attr:`__optional_keys__` för "
"introspektion."

msgid ""
"``Point2D.__required_keys__`` and ``Point2D.__optional_keys__`` return :"
"class:`frozenset` objects containing required and non-required keys, "
"respectively."
msgstr ""
"``Point2D.__required_keys__`` och ``Point2D.__optional_keys__`` returnerar :"
"class:`frozenset`-objekt som innehåller obligatoriska respektive icke-"
"obligatoriska nycklar."

msgid ""
"Keys marked with :data:`Required` will always appear in "
"``__required_keys__`` and keys marked with :data:`NotRequired` will always "
"appear in ``__optional_keys__``."
msgstr ""
"Nycklar som är markerade med :data:`Required` kommer alltid att visas i "
"``__required_keys__`` och nycklar som är markerade med :data:`NotRequired`` "
"kommer alltid att visas i ``__optional_keys__``."

msgid ""
"For backwards compatibility with Python 3.10 and below, it is also possible "
"to use inheritance to declare both required and non-required keys in the "
"same ``TypedDict`` . This is done by declaring a ``TypedDict`` with one "
"value for the ``total`` argument and then inheriting from it in another "
"``TypedDict`` with a different value for ``total``:"
msgstr ""
"För bakåtkompatibilitet med Python 3.10 och lägre är det också möjligt att "
"använda arv för att deklarera både obligatoriska och icke-obligatoriska "
"nycklar i samma ``TypedDict``. Detta görs genom att deklarera en "
"``TypedDict`` med ett värde för argumentet ``total`` och sedan ärva från den "
"i en annan ``TypedDict`` med ett annat värde för ``total``:"

msgid ""
">>> class Point2D(TypedDict, total=False):\n"
"...     x: int\n"
"...     y: int\n"
"...\n"
">>> class Point3D(Point2D):\n"
"...     z: int\n"
"...\n"
">>> Point3D.__required_keys__ == frozenset({'z'})\n"
"True\n"
">>> Point3D.__optional_keys__ == frozenset({'x', 'y'})\n"
"True"
msgstr ""
">>> class Point2D(TypedDict, total=False):\n"
"... x: int\n"
"... y: int\n"
"...\n"
">>> klass Point3D(Point2D):\n"
"... z: int\n"
"...\n"
">>> Point3D.__required_keys__ == frozenset({'z'})\n"
"Sant\n"
">>> Point3D.__optional_keys__ == frozenset({'x', 'y'})\n"
"Sant"

msgid ""
"If ``from __future__ import annotations`` is used or if annotations are "
"given as strings, annotations are not evaluated when the ``TypedDict`` is "
"defined. Therefore, the runtime introspection that ``__required_keys__`` and "
"``__optional_keys__`` rely on may not work properly, and the values of the "
"attributes may be incorrect."
msgstr ""
"Om ``from __future__ import annotations`` används eller om annoteringar "
"anges som strängar, utvärderas inte annoteringarna när ``TypedDict`` "
"definieras. Därför kan det hända att den introspektion under körning som "
"``__required_keys__`` och ``__optional_keys__`` förlitar sig på inte "
"fungerar korrekt, och attributens värden kan vara felaktiga."

msgid "Support for :data:`ReadOnly` is reflected in the following attributes:"
msgstr "Stöd för :data:`ReadOnly` återspeglas i följande attribut:"

msgid ""
"A :class:`frozenset` containing the names of all read-only keys. Keys are "
"read-only if they carry the :data:`ReadOnly` qualifier."
msgstr ""
"En :class:`frozenset` som innehåller namnen på alla skrivskyddade nycklar. "
"Nycklar är skrivskyddade om de har :data:`ReadOnly`-kvalificeraren."

msgid ""
"A :class:`frozenset` containing the names of all mutable keys. Keys are "
"mutable if they do not carry the :data:`ReadOnly` qualifier."
msgstr ""
"En :class:`frozenset` som innehåller namnen på alla mutabla nycklar. Nycklar "
"är mutabla om de inte har :data:`ReadOnly`-kvalificeraren."

msgid ""
"See the `TypedDict <https://typing.python.org/en/latest/spec/typeddict."
"html#typeddict>`_ section in the typing documentation for more examples and "
"detailed rules."
msgstr ""
"Se avsnittet `TypedDict <https://typing.python.org/en/latest/spec/typeddict."
"html#typeddict>`_ i typningsdokumentationen för fler exempel och detaljerade "
"regler."

msgid ""
"Added support for marking individual keys as :data:`Required` or :data:"
"`NotRequired`. See :pep:`655`."
msgstr ""
"Lagt till stöd för att markera enskilda nycklar som :data:`Required` eller :"
"data:`NotRequired`. Se :pep:`655`."

msgid "Added support for generic ``TypedDict``\\ s."
msgstr "Lagt till stöd för generiska ``TypedDict``."

msgid ""
"Removed support for the keyword-argument method of creating ``TypedDict``\\ "
"s."
msgstr ""
"Borttaget stöd för nyckelord-argument-metoden för att skapa ``TypedDict``."

msgid "Support for the :data:`ReadOnly` qualifier was added."
msgstr "Stöd för kvalifikatorn :data:`ReadOnly` har lagts till."

msgid ""
"When using the functional syntax to create a TypedDict class, failing to "
"pass a value to the 'fields' parameter (``TD = TypedDict(\"TD\")``) is "
"deprecated. Passing ``None`` to the 'fields' parameter (``TD = "
"TypedDict(\"TD\", None)``) is also deprecated. Both will be disallowed in "
"Python 3.15. To create a TypedDict class with 0 fields, use ``class "
"TD(TypedDict): pass`` or ``TD = TypedDict(\"TD\", {})``."
msgstr ""
"När du använder den funktionella syntaxen för att skapa en TypedDict-klass "
"är det föråldrat att inte skicka ett värde till parametern 'fields' (``TDD = "
"TypedDict(\"TD\")``). Att skicka ``None`` till parametern 'fields' (``TD = "
"TypedDict(\"TD\", None)``) är också föråldrat. Båda kommer att vara "
"otillåtna i Python 3.15. För att skapa en TypedDict-klass med 0 fält, använd "
"``class TD(TypedDict): pass`` eller ``TD = TypedDict(\"TD\", {})``."

msgid "Protocols"
msgstr "Protokoll"

msgid ""
"The following protocols are provided by the :mod:`!typing` module. All are "
"decorated with :func:`@runtime_checkable <runtime_checkable>`."
msgstr ""
"Följande protokoll tillhandahålls av modulen :mod:`!typing`. Alla är "
"dekorerade med :func:`@runtime_checkable <runtime_checkable>`."

msgid ""
"An ABC with one abstract method ``__abs__`` that is covariant in its return "
"type."
msgstr ""
"En ABC med en abstrakt metod ``__abs__`` som är kovariant i sin returtyp."

msgid "An ABC with one abstract method ``__bytes__``."
msgstr "En ABC med en abstrakt metod ``__bytes__``."

msgid "An ABC with one abstract method ``__complex__``."
msgstr "En ABC med en abstrakt metod ``__complex__``."

msgid "An ABC with one abstract method ``__float__``."
msgstr "En ABC med en abstrakt metod ``__float__``."

msgid "An ABC with one abstract method ``__index__``."
msgstr "En ABC med en abstrakt metod ``__index__``."

msgid "An ABC with one abstract method ``__int__``."
msgstr "En ABC med en abstrakt metod ``__int__``."

msgid ""
"An ABC with one abstract method ``__round__`` that is covariant in its "
"return type."
msgstr ""
"En ABC med en abstrakt metod ``__round__`` som är kovariant i sin returtyp."

msgid "ABCs and Protocols for working with I/O"
msgstr "ABC och protokoll för att arbeta med I/O"

msgid ""
"Generic class ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])`` and "
"``BinaryIO(IO[bytes])`` represent the types of I/O streams such as returned "
"by :func:`open`. Please note that these classes are not protocols, and their "
"interface is fairly broad."
msgstr ""
"Den generiska klassen ``IO[AnyStr]`` och dess underklasser "
"``TextIO(IO[str])`` och ``BinaryIO(IO[bytes])`` representerar de typer av I/"
"O-strömmar som returneras av :func:`open`. Observera att dessa klasser inte "
"är protokoll och att deras gränssnitt är ganska brett."

msgid ""
"The protocols :class:`io.Reader` and :class:`io.Writer` offer a simpler "
"alternative for argument types, when only the ``read()`` or ``write()`` "
"methods are accessed, respectively::"
msgstr ""
"Protokollen :class:`io.Reader` och :class:`io.Writer` erbjuder ett enklare "
"alternativ för argumenttyper, när endast metoderna ``read()`` respektive "
"``write()`` används::"

msgid ""
"def read_and_write(reader: Reader[str], writer: Writer[bytes]):\n"
"    data = reader.read()\n"
"    writer.write(data.encode())"
msgstr ""
"def read_and_write(reader: Reader[str], writer: Writer[bytes]):\n"
"    data = reader.read()\n"
"    writer.write(data.encode())"

msgid ""
"Also consider using :class:`collections.abc.Iterable` for iterating over the "
"lines of an input stream::"
msgstr ""
"Överväg också att använda :class:`collections.abc.Iterable` för att iterera "
"över raderna i en inmatningsström::"

msgid ""
"def read_config(stream: Iterable[str]):\n"
"    for line in stream:\n"
"        ..."
msgstr ""
"def read_config(stream: Iterable[str]):\n"
"    för rad i ström:\n"
"        ..."

msgid "Functions and decorators"
msgstr "Funktioner och dekoratorer"

msgid "Cast a value to a type."
msgstr "Kasta ett värde till en typ."

msgid ""
"This returns the value unchanged.  To the type checker this signals that the "
"return value has the designated type, but at runtime we intentionally don't "
"check anything (we want this to be as fast as possible)."
msgstr ""
"Detta returnerar värdet oförändrat.  För typkontrollanten signalerar detta "
"att returvärdet har den angivna typen, men vid körning kontrollerar vi "
"avsiktligt ingenting (vi vill att det ska gå så snabbt som möjligt)."

msgid ""
"Ask a static type checker to confirm that *val* has an inferred type of "
"*typ*."
msgstr ""
"Be en statisk typkontrollör att bekräfta att *val* har en härledd typ av "
"*typ*."

msgid ""
"At runtime this does nothing: it returns the first argument unchanged with "
"no checks or side effects, no matter the actual type of the argument."
msgstr ""
"Vid körning gör detta ingenting: det returnerar det första argumentet "
"oförändrat utan kontroller eller sidoeffekter, oavsett argumentets faktiska "
"typ."

msgid ""
"When a static type checker encounters a call to ``assert_type()``, it emits "
"an error if the value is not of the specified type::"
msgstr ""
"När en statisk typkontrollör stöter på ett anrop till ``assert_type()``, "
"avger den ett fel om värdet inte är av den angivna typen::"

msgid ""
"def greet(name: str) -> None:\n"
"    assert_type(name, str)  # OK, inferred type of `name` is `str`\n"
"    assert_type(name, int)  # type checker error"
msgstr ""
"def greet(namn: str) -> None:\n"
"    assert_type(name, str) # OK, den härledda typen av `namn` är `str`\n"
"    assert_type(name, int) # fel i typkontrollen"

msgid ""
"This function is useful for ensuring the type checker's understanding of a "
"script is in line with the developer's intentions::"
msgstr ""
"Denna funktion är användbar för att säkerställa att typkontrollantens "
"förståelse av ett skript är i linje med utvecklarens avsikter::"

msgid ""
"def complex_function(arg: object):\n"
"    # Do some complex type-narrowing logic,\n"
"    # after which we hope the inferred type will be `int`\n"
"    ...\n"
"    # Test whether the type checker correctly understands our function\n"
"    assert_type(arg, int)"
msgstr ""
"def komplex_funktion(arg: objekt):\n"
"    # Gör en del komplex logik för typbegränsning,\n"
"    # varefter vi hoppas att den härledda typen kommer att vara `int`\n"
"    ...\n"
"    # Testa om typkontrollen förstår vår funktion korrekt\n"
"    assert_type(arg, int)"

msgid ""
"Ask a static type checker to confirm that a line of code is unreachable."
msgstr "Be en statisk typkontroll att bekräfta att en kodrad är oåtkomlig."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"def int_or_str(arg: int | str) -> None:\n"
"    match arg:\n"
"        case int():\n"
"            print(\"It's an int\")\n"
"        case str():\n"
"            print(\"It's a str\")\n"
"        case _ as unreachable:\n"
"            assert_never(unreachable)"
msgstr ""
"def int_or_str(arg: int | str) -> None:\n"
"    matcha arg:\n"
"        fall int():\n"
"            print(\"Det är en int\")\n"
"        fall str():\n"
"            print(\"Det är en str\")\n"
"        fall _ som oåtkomlig:\n"
"            assert_never(oåtkomlig)"

msgid ""
"Here, the annotations allow the type checker to infer that the last case can "
"never execute, because ``arg`` is either an :class:`int` or a :class:`str`, "
"and both options are covered by earlier cases."
msgstr ""
"Här gör annotationerna det möjligt för typkontrollen att dra slutsatsen att "
"det sista fallet aldrig kan utföras, eftersom ``arg`` antingen är en :class:"
"`int` eller en :class:`str`, och båda alternativen täcks av tidigare fall."

msgid ""
"If a type checker finds that a call to ``assert_never()`` is reachable, it "
"will emit an error. For example, if the type annotation for ``arg`` was "
"instead ``int | str | float``, the type checker would emit an error pointing "
"out that ``unreachable`` is of type :class:`float`. For a call to "
"``assert_never`` to pass type checking, the inferred type of the argument "
"passed in must be the bottom type, :data:`Never`, and nothing else."
msgstr ""
"Om en typkontrollör upptäcker att ett anrop till ``assert_never()`` är "
"nåbart, kommer den att avge ett felmeddelande. Till exempel, om "
"typannoteringen för ``arg`` istället var ``int | str | float``, skulle "
"typkontrollen avge ett felmeddelande som påpekar att ``unreachable`` är av "
"typen :class:`float`. För att ett anrop till ``assert_never`` ska klara "
"typkontrollen måste den härledda typen av argumentet som skickas in vara "
"bottentypen, :data:`Never`, och inget annat."

msgid "At runtime, this throws an exception when called."
msgstr "Vid körning kastar detta ett undantag när det anropas."

msgid ""
"`Unreachable Code and Exhaustiveness Checking <https://typing.python.org/en/"
"latest/guides/unreachable.html>`__ has more information about exhaustiveness "
"checking with static typing."
msgstr ""
"i `Unreachable Code and Exhaustiveness Checking <https://typing.python.org/"
"en/latest/guides/unreachable.html>`__ finns mer information om kontroll av "
"fullständighet med statisk typning."

msgid "Ask a static type checker to reveal the inferred type of an expression."
msgstr ""
"Be en statisk typkontrollör att avslöja den härledda typen för ett uttryck."

msgid ""
"When a static type checker encounters a call to this function, it emits a "
"diagnostic with the inferred type of the argument. For example::"
msgstr ""
"När en statisk typkontrollör stöter på ett anrop till denna funktion avger "
"den en diagnostik med den härledda typen av argumentet. Till exempel::"

msgid ""
"x: int = 1\n"
"reveal_type(x)  # Revealed type is \"builtins.int\""
msgstr ""
"x: int = 1\n"
"reveal_type(x) # Avslöjad typ är \"builtins.int\""

msgid ""
"This can be useful when you want to debug how your type checker handles a "
"particular piece of code."
msgstr ""
"Detta kan vara användbart när du vill felsöka hur din typkontroll hanterar "
"en viss kod."

msgid ""
"At runtime, this function prints the runtime type of its argument to :data:"
"`sys.stderr` and returns the argument unchanged (allowing the call to be "
"used within an expression)::"
msgstr ""
"Vid körning skriver denna funktion ut körtidstypen för sitt argument till :"
"data:`sys.stderr` och returnerar argumentet oförändrat (vilket gör att "
"anropet kan användas inom ett uttryck)::"

msgid ""
"x = reveal_type(1)  # prints \"Runtime type is int\"\n"
"print(x)  # prints \"1\""
msgstr ""
"x = reveal_type(1) # skriver ut \"Körtidstypen är int\"\n"
"print(x) # skriver ut \"1\""

msgid ""
"Note that the runtime type may be different from (more or less specific "
"than) the type statically inferred by a type checker."
msgstr ""
"Observera att körtidstypen kan skilja sig från (mer eller mindre specifik "
"än) den typ som statiskt härleds av en typkontroll."

msgid ""
"Most type checkers support ``reveal_type()`` anywhere, even if the name is "
"not imported from ``typing``. Importing the name from ``typing``, however, "
"allows your code to run without runtime errors and communicates intent more "
"clearly."
msgstr ""
"De flesta typkontrollprogram stöder ``reveal_type()`` var som helst, även om "
"namnet inte importeras från ``typing``. Att importera namnet från ``typing`` "
"gör dock att din kod kan köras utan körtidsfel och kommunicerar avsikten "
"tydligare."

msgid ""
"Decorator to mark an object as providing :func:`dataclass <dataclasses."
"dataclass>`-like behavior."
msgstr ""
"Dekorator för att markera att ett objekt har ett :func:`dataklass "
"<dataklasser.dataklass>`-liknande beteende."

msgid ""
"``dataclass_transform`` may be used to decorate a class, metaclass, or a "
"function that is itself a decorator. The presence of "
"``@dataclass_transform()`` tells a static type checker that the decorated "
"object performs runtime \"magic\" that transforms a class in a similar way "
"to :func:`@dataclasses.dataclass <dataclasses.dataclass>`."
msgstr ""
"``dataclass_transform`` kan användas för att dekorera en klass, metaklass "
"eller en funktion som i sig är en dekorator. Närvaron av "
"``@dataclass_transform()`` talar om för en statisk typkontrollant att det "
"dekorerade objektet utför \"magi\" under körning som transformerar en klass "
"på ett liknande sätt som :func:`@dataclasses.dataclass <dataclasses."
"dataclass>`."

msgid "Example usage with a decorator function:"
msgstr "Exempel på användning med en dekoratorfunktion:"

msgid ""
"@dataclass_transform()\n"
"def create_model[T](cls: type[T]) -> type[T]:\n"
"    ...\n"
"    return cls\n"
"\n"
"@create_model\n"
"class CustomerModel:\n"
"    id: int\n"
"    name: str"
msgstr ""
"@dataklass_transform()\n"
"def create_model[T](cls: type[T]) -> type[T]:\n"
"    ...\n"
"    returnera cls\n"
"\n"
"@skapa_modell\n"
"klass CustomerModel:\n"
"    id: int\n"
"    namn: str"

msgid "On a base class::"
msgstr "På en basklass::"

msgid ""
"@dataclass_transform()\n"
"class ModelBase: ...\n"
"\n"
"class CustomerModel(ModelBase):\n"
"    id: int\n"
"    name: str"
msgstr ""
"@dataklass_transform()\n"
"klass ModelBase: ...\n"
"\n"
"klass CustomerModel(ModelBase):\n"
"    id: int\n"
"    name: str"

msgid "On a metaclass::"
msgstr "På en metaklass::"

msgid ""
"@dataclass_transform()\n"
"class ModelMeta(type): ...\n"
"\n"
"class ModelBase(metaclass=ModelMeta): ...\n"
"\n"
"class CustomerModel(ModelBase):\n"
"    id: int\n"
"    name: str"
msgstr ""
"@dataklass_transform()\n"
"klass ModelMeta(typ): ...\n"
"\n"
"klass ModelBase(metaklass=ModelMeta): ...\n"
"\n"
"klass CustomerModel(ModelBase):\n"
"    id: int\n"
"    name: str"

msgid ""
"The ``CustomerModel`` classes defined above will be treated by type checkers "
"similarly to classes created with :func:`@dataclasses.dataclass <dataclasses."
"dataclass>`. For example, type checkers will assume these classes have "
"``__init__`` methods that accept ``id`` and ``name``."
msgstr ""
"Klasserna ``CustomerModel`` som definieras ovan kommer att behandlas av "
"typkontrollprogram på samma sätt som klasser som skapats med :func:"
"`@dataclasses.dataclass <dataclasses.dataclass>`. Exempelvis kommer "
"typkontrollerna att anta att dessa klasser har ``__init__``-metoder som "
"accepterar ``id`` och ``name``."

msgid ""
"The decorated class, metaclass, or function may accept the following bool "
"arguments which type checkers will assume have the same effect as they would "
"have on the :func:`@dataclasses.dataclass<dataclasses.dataclass>` decorator: "
"``init``, ``eq``, ``order``, ``unsafe_hash``, ``frozen``, ``match_args``, "
"``kw_only``, and ``slots``. It must be possible for the value of these "
"arguments (``True`` or ``False``) to be statically evaluated."
msgstr ""
"Den dekorerade klassen, metaklassen eller funktionen kan acceptera följande "
"bool-argument som typkontrollanter kommer att anta har samma effekt som de "
"skulle ha på :func:`@dataclasses.dataclass<dataclasses.dataclass>`-"
"dekoratorn: ``init``, ``eq``, ``order``, ``unsafe_hash``, ``frozen``, "
"``match_args``, ``kw_only`` och ``slots``. Det måste vara möjligt att "
"statiskt utvärdera värdet av dessa argument (``True`` eller ``False``)."

msgid ""
"The arguments to the ``dataclass_transform`` decorator can be used to "
"customize the default behaviors of the decorated class, metaclass, or "
"function:"
msgstr ""
"Argumenten till dekoratorn ``dataclass_transform`` kan användas för att "
"anpassa standardbeteendena för den dekorerade klassen, metaklassen eller "
"funktionen:"

msgid "Parameters"
msgstr "Parametrar"

msgid ""
"Indicates whether the ``eq`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``True``."
msgstr ""
"Anger om parametern ``eq`` ska antas vara ``True`` eller ``False`` om den "
"utelämnas av anroparen. Standardvärdet är ``True``."

msgid ""
"Indicates whether the ``order`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``."
msgstr ""
"Anger om parametern ``order`` ska antas vara ``True`` eller ``False`` om den "
"utelämnas av den som anropar. Standardvärdet är ``False``."

msgid ""
"Indicates whether the ``kw_only`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``."
msgstr ""
"Anger om parametern ``kw_only`` ska antas vara ``True`` eller ``False`` om "
"den utelämnas av den som anropar. Standardvärdet är ``False``."

msgid ""
"Indicates whether the ``frozen`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``.  .. "
"versionadded:: 3.12"
msgstr ""
"Anger om parametern ``frozen`` ska antas vara ``True`` eller ``False`` om "
"den utelämnas av den som anropar. Standardvärdet är ``False``.  .. "
"versionadded:: 3.12"

msgid ""
"Indicates whether the ``frozen`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``."
msgstr ""
"Anger om parametern ``frozen`` ska antas vara ``True`` eller ``False`` om "
"den utelämnas av den som anropar. Standardvärdet är ``False``."

msgid ""
"Specifies a static list of supported classes or functions that describe "
"fields, similar to :func:`dataclasses.field`. Defaults to ``()``."
msgstr ""
"Anger en statisk lista över klasser eller funktioner som stöds och som "
"beskriver fält, liknande :func:`dataclasses.field`. Standardvärdet är ``()``."

msgid ""
"Arbitrary other keyword arguments are accepted in order to allow for "
"possible future extensions."
msgstr ""
"Godtyckliga andra nyckelordsargument accepteras för att möjliggöra "
"eventuella framtida tillägg."

msgid ""
"Type checkers recognize the following optional parameters on field "
"specifiers:"
msgstr ""
"Typkontroller känner igen följande valfria parametrar på fältspecifikatorer:"

msgid "**Recognised parameters for field specifiers**"
msgstr "**Erkända parametrar för fältangivelser**"

msgid "Parameter name"
msgstr "Parameternamn"

msgid "Description"
msgstr "Beskrivning"

msgid "``init``"
msgstr "``init``"

msgid ""
"Indicates whether the field should be included in the synthesized "
"``__init__`` method. If unspecified, ``init`` defaults to ``True``."
msgstr ""
"Anger om fältet ska ingå i den syntetiserade metoden ``__init__``. Om inget "
"anges är ``init`` standardvärdet ``True``."

msgid "``default``"
msgstr "``standard``"

msgid "Provides the default value for the field."
msgstr "Anger standardvärdet för fältet."

msgid "``default_factory``"
msgstr "``standard_fabrik``"

msgid ""
"Provides a runtime callback that returns the default value for the field. If "
"neither ``default`` nor ``default_factory`` are specified, the field is "
"assumed to have no default value and must be provided a value when the class "
"is instantiated."
msgstr ""
"Tillhandahåller ett runtime callback som returnerar standardvärdet för "
"fältet. Om varken ``default`` eller ``default_factory`` anges, antas fältet "
"inte ha något standardvärde och måste förses med ett värde när klassen "
"instansieras."

msgid "``factory``"
msgstr "\"fabrik"

msgid "An alias for the ``default_factory`` parameter on field specifiers."
msgstr "Ett alias för parametern ``default_factory`` på fältspecifikatorer."

msgid "``kw_only``"
msgstr "``kw_only``"

msgid ""
"Indicates whether the field should be marked as keyword-only. If ``True``, "
"the field will be keyword-only. If ``False``, it will not be keyword-only. "
"If unspecified, the value of the ``kw_only`` parameter on the object "
"decorated with ``dataclass_transform`` will be used, or if that is "
"unspecified, the value of ``kw_only_default`` on ``dataclass_transform`` "
"will be used."
msgstr ""
"Anger om fältet ska markeras som endast nyckelord. Om ``True``, kommer "
"fältet att vara nyckelordsskyddat. Om ``False``, kommer det inte att vara "
"nyckelordsskyddat. Om det är ospecificerat, kommer värdet på parametern "
"``kw_only`` på objektet som dekorerats med ``dataclass_transform`` att "
"användas, eller om det är ospecificerat, kommer värdet på "
"``kw_only_default`` på ``dataclass_transform`` att användas."

msgid "``alias``"
msgstr "``alias``"

msgid ""
"Provides an alternative name for the field. This alternative name is used in "
"the synthesized ``__init__`` method."
msgstr ""
"Anger ett alternativt namn för fältet. Detta alternativa namn används i den "
"syntetiserade metoden ``__init__``."

msgid ""
"At runtime, this decorator records its arguments in the "
"``__dataclass_transform__`` attribute on the decorated object. It has no "
"other runtime effect."
msgstr ""
"Vid körning registrerar denna dekorator sina argument i attributet "
"``__dataclass_transform__`` på det dekorerade objektet. Den har ingen annan "
"effekt under körning."

msgid "See :pep:`681` for more details."
msgstr "Se :pep:`681` för mer information."

msgid "Decorator for creating overloaded functions and methods."
msgstr "Dekorator för att skapa överladdade funktioner och metoder."

msgid ""
"The ``@overload`` decorator allows describing functions and methods that "
"support multiple different combinations of argument types. A series of "
"``@overload``-decorated definitions must be followed by exactly one non-"
"``@overload``-decorated definition (for the same function/method)."
msgstr ""
"Dekoratorn ``@overload`` gör det möjligt att beskriva funktioner och metoder "
"som stöder flera olika kombinationer av argumenttyper. En serie "
"``@overload``-dekorerade definitioner måste följas av exakt en icke "
"``@overload``-dekorerad definition (för samma funktion/metod)."

msgid ""
"``@overload``-decorated definitions are for the benefit of the type checker "
"only, since they will be overwritten by the non-``@overload``-decorated "
"definition. The non-``@overload``-decorated definition, meanwhile, will be "
"used at runtime but should be ignored by a type checker.  At runtime, "
"calling an ``@overload``-decorated function directly will raise :exc:"
"`NotImplementedError`."
msgstr ""
"``@overload``-dekorerade definitioner är endast till fördel för "
"typkontrollanten, eftersom de kommer att skrivas över av den "
"icke``@overload``-dekorerade definitionen. Den icke ``@overload``-dekorerade "
"definitionen kommer däremot att användas vid körning men bör ignoreras av en "
"typkontrollant.  Vid körning kommer anrop av en ``@overload``-dekorerad "
"funktion direkt att ge upphov till :exc:`NotImplementedError`."

msgid ""
"An example of overload that gives a more precise type than can be expressed "
"using a union or a type variable:"
msgstr ""
"Ett exempel på överbelastning som ger en mer exakt typ än vad som kan "
"uttryckas med hjälp av en union eller en typvariabel:"

msgid ""
"@overload\n"
"def process(response: None) -> None:\n"
"    ...\n"
"@overload\n"
"def process(response: int) -> tuple[int, str]:\n"
"    ...\n"
"@overload\n"
"def process(response: bytes) -> str:\n"
"    ...\n"
"def process(response):\n"
"    ...  # actual implementation goes here"
msgstr ""
"@överbelastning\n"
"def process(svar: None) -> None:\n"
"    ...\n"
"@överbelastning\n"
"def process(response: int) -> tuple[int, str]:\n"
"    ...\n"
"@överbelastning\n"
"def process(svar: bytes) -> str:\n"
"    ...\n"
"def process(svar):\n"
"    ...  # faktisk implementering går här"

msgid ""
"See :pep:`484` for more details and comparison with other typing semantics."
msgstr ""
"Se :pep:`484` för mer information och jämförelse med annan typningssemantik."

msgid ""
"Overloaded functions can now be introspected at runtime using :func:"
"`get_overloads`."
msgstr ""
"Överladdade funktioner kan nu introspekteras vid körning med :func:"
"`get_overloads`."

msgid ""
"Return a sequence of :func:`@overload <overload>`-decorated definitions for "
"*func*."
msgstr ""
"Returnerar en sekvens av :func:`@overload <overload>`-dekorerade "
"definitioner för *func*."

msgid ""
"*func* is the function object for the implementation of the overloaded "
"function. For example, given the definition of ``process`` in the "
"documentation for :func:`@overload <overload>`, ``get_overloads(process)`` "
"will return a sequence of three function objects for the three defined "
"overloads. If called on a function with no overloads, ``get_overloads()`` "
"returns an empty sequence."
msgstr ""
"*func* är funktionsobjektet för implementeringen av den överladdade "
"funktionen. Till exempel, givet definitionen av ``process`` i "
"dokumentationen för :func:`@overload <overload>`, kommer "
"``get_overloads(process)`` att returnera en sekvens av tre funktionsobjekt "
"för de tre definierade överbelastningarna. Om den anropas på en funktion "
"utan överbelastningar returnerar ``get_overloads()`` en tom sekvens."

msgid ""
"``get_overloads()`` can be used for introspecting an overloaded function at "
"runtime."
msgstr ""
"``get_overloads()`` kan användas för att introspektera en överbelastad "
"funktion under körning."

msgid "Clear all registered overloads in the internal registry."
msgstr "Rensa alla registrerade överbelastningar i det interna registret."

msgid "This can be used to reclaim the memory used by the registry."
msgstr "Detta kan användas för att återta det minne som används av registret."

msgid "Decorator to indicate final methods and final classes."
msgstr "Dekorator för att ange slutgiltiga metoder och slutgiltiga klasser."

msgid ""
"Decorating a method with ``@final`` indicates to a type checker that the "
"method cannot be overridden in a subclass. Decorating a class with "
"``@final`` indicates that it cannot be subclassed."
msgstr ""
"Att dekorera en metod med ``@final`` indikerar för en typkontrollant att "
"metoden inte kan åsidosättas i en underklass. Att dekorera en klass med "
"``@final`` indikerar att den inte kan subklassas."

msgid ""
"class Base:\n"
"    @final\n"
"    def done(self) -> None:\n"
"        ...\n"
"class Sub(Base):\n"
"    def done(self) -> None:  # Error reported by type checker\n"
"        ...\n"
"\n"
"@final\n"
"class Leaf:\n"
"    ...\n"
"class Other(Leaf):  # Error reported by type checker\n"
"    ..."
msgstr ""
"klass Bas:\n"
"    @slutlig\n"
"    def done(self) -> Ingen:\n"
"        ...\n"
"klassen Sub(Base):\n"
"    def done(self) -> None:  # Fel rapporterat av typkontroll\n"
"        ...\n"
"\n"
"@slutlig\n"
"klass Leaf:\n"
"    ...\n"
"klass Annan(Blad):  # Fel rapporterat av typkontroll\n"
"    ..."

msgid ""
"The decorator will now attempt to set a ``__final__`` attribute to ``True`` "
"on the decorated object. Thus, a check like ``if getattr(obj, \"__final__\", "
"False)`` can be used at runtime to determine whether an object ``obj`` has "
"been marked as final. If the decorated object does not support setting "
"attributes, the decorator returns the object unchanged without raising an "
"exception."
msgstr ""
"Dekoratorn kommer nu att försöka sätta attributet ``__final__`` till "
"``True`` på det dekorerade objektet. Således kan en kontroll som ``if "
"getattr(obj, \"__final__\", False)`` användas vid runtime för att avgöra om "
"ett objekt ``obj`` har markerats som final. Om det dekorerade objektet inte "
"har stöd för att sätta attribut, returnerar dekoratorn objektet oförändrat "
"utan att skapa ett undantag."

msgid "Decorator to indicate that annotations are not type hints."
msgstr "Dekorator för att ange att annotationer inte är typtips."

msgid ""
"This works as a class or function :term:`decorator`.  With a class, it "
"applies recursively to all methods and classes defined in that class (but "
"not to methods defined in its superclasses or subclasses). Type checkers "
"will ignore all annotations in a function or class with this decorator."
msgstr ""
"Detta fungerar som en klass eller funktion :term:`decorator`.  För en klass "
"gäller den rekursivt för alla metoder och klasser som definieras i den "
"klassen (men inte för metoder som definieras i dess superklasser eller "
"subklasser). Typkontrollanter ignorerar alla annoteringar i en funktion "
"eller klass med denna dekorator."

msgid "``@no_type_check`` mutates the decorated object in place."
msgstr "``@no_type_check`` muterar det dekorerade objektet på plats."

msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr ""
"Dekorator för att ge en annan dekorator :func:`no_type_check`-effekten."

msgid ""
"This wraps the decorator with something that wraps the decorated function "
"in :func:`no_type_check`."
msgstr ""
"Detta omsluter dekoratorn med något som omsluter den dekorerade funktionen "
"i :func:`no_type_check`."

msgid ""
"No type checker ever added support for ``@no_type_check_decorator``. It is "
"therefore deprecated, and will be removed in Python 3.15."
msgstr ""
"Ingen typkontroll har någonsin lagt till stöd för "
"``@no_type_check_decorator``. Det är därför föråldrat och kommer att tas "
"bort i Python 3.15."

msgid ""
"Decorator to indicate that a method in a subclass is intended to override a "
"method or attribute in a superclass."
msgstr ""
"Dekorator för att ange att en metod i en subklass är avsedd att åsidosätta "
"en metod eller ett attribut i en superklass."

msgid ""
"Type checkers should emit an error if a method decorated with ``@override`` "
"does not, in fact, override anything. This helps prevent bugs that may occur "
"when a base class is changed without an equivalent change to a child class."
msgstr ""
"Typkontroller bör avge ett felmeddelande om en metod som dekorerats med "
"``@override`` i själva verket inte åsidosätter något. Detta hjälper till att "
"förhindra buggar som kan uppstå när en basklass ändras utan att en "
"underordnad klass ändras på motsvarande sätt."

msgid ""
"class Base:\n"
"    def log_status(self) -> None:\n"
"        ...\n"
"\n"
"class Sub(Base):\n"
"    @override\n"
"    def log_status(self) -> None:  # Okay: overrides Base.log_status\n"
"        ...\n"
"\n"
"    @override\n"
"    def done(self) -> None:  # Error reported by type checker\n"
"        ..."
msgstr ""
"klass Bas:\n"
"    def log_status(self) -> Ingen:\n"
"        ...\n"
"\n"
"klass Sub(Base):\n"
"    @override\n"
"    def log_status(self) -> Ingen:  # Okej: åsidosätter Base.log_status\n"
"        ...\n"
"\n"
"    @överstyrning\n"
"    def done(self) -> Ingen:  # Fel rapporterat av typkontroll\n"
"        ..."

msgid "There is no runtime checking of this property."
msgstr "Det finns ingen runtime-kontroll av denna egenskap."

msgid ""
"The decorator will attempt to set an ``__override__`` attribute to ``True`` "
"on the decorated object. Thus, a check like ``if getattr(obj, "
"\"__override__\", False)`` can be used at runtime to determine whether an "
"object ``obj`` has been marked as an override.  If the decorated object does "
"not support setting attributes, the decorator returns the object unchanged "
"without raising an exception."
msgstr ""
"Dekoratorn kommer att försöka sätta ett ``__override__`` attribut till "
"``True`` på det dekorerade objektet. Således kan en kontroll som ``if "
"getattr(obj, \"__override__\", False)`` användas vid körning för att avgöra "
"om ett objekt ``obj`` har markerats som en åsidosättning.  Om det dekorerade "
"objektet inte har stöd för att ställa in attribut, returnerar dekoratorn "
"objektet oförändrat utan att skapa ett undantag."

msgid "See :pep:`698` for more details."
msgstr "Se :pep:`698` för mer information."

msgid "Decorator to mark a class or function as unavailable at runtime."
msgstr ""
"Dekorator för att markera att en klass eller funktion inte är tillgänglig "
"vid körning."

msgid ""
"This decorator is itself not available at runtime. It is mainly intended to "
"mark classes that are defined in type stub files if an implementation "
"returns an instance of a private class::"
msgstr ""
"Denna dekorator är i sig inte tillgänglig vid körning. Den är främst avsedd "
"att markera klasser som definieras i typstub-filer om en implementation "
"returnerar en instans av en privat klass::"

msgid ""
"@type_check_only\n"
"class Response:  # private or not available at runtime\n"
"    code: int\n"
"    def get_header(self, name: str) -> str: ...\n"
"\n"
"def fetch_response() -> Response: ..."
msgstr ""
"@typ_kontroll_endast\n"
"klass Svar:  # privat eller inte tillgänglig vid körning\n"
"    kod: int\n"
"    def get_header(self, name: str) -> str: ...\n"
"\n"
"def fetch_response() -> Svar: ..."

msgid ""
"Note that returning instances of private classes is not recommended. It is "
"usually preferable to make such classes public."
msgstr ""
"Observera att det inte är rekommenderat att returnera instanser av privata "
"klasser. Det är oftast att föredra att göra sådana klasser publika."

msgid "Introspection helpers"
msgstr "Hjälpmedel för introspektion"

msgid ""
"Return a dictionary containing type hints for a function, method, module or "
"class object."
msgstr ""
"Returnerar en dictionary som innehåller typtips för en funktion, metod, "
"modul eller klassobjekt."

msgid ""
"This is often the same as ``obj.__annotations__``, but this function makes "
"the following changes to the annotations dictionary:"
msgstr ""
"Detta är ofta samma sak som ``obj.__annotations__``, men denna funktion gör "
"följande ändringar i annotationsordlistan:"

msgid ""
"Forward references encoded as string literals or :class:`ForwardRef` objects "
"are handled by evaluating them in *globalns*, *localns*, and (where "
"applicable) *obj*'s :ref:`type parameter <type-params>` namespace. If "
"*globalns* or *localns* is not given, appropriate namespace dictionaries are "
"inferred from *obj*."
msgstr ""
"Framåtriktade referenser som kodas som stränglitteraler eller :class:"
"`ForwardRef`-objekt hanteras genom att de utvärderas i *globalns*, *localns* "
"och (i förekommande fall) *obj*:s :ref:`typparameter <type-params>` "
"namnrymd. Om *globalns* eller *localns* inte anges, härleds lämpliga "
"namnrymdsordböcker från *obj*."

msgid "``None`` is replaced with :class:`types.NoneType`."
msgstr "``None`` ersätts med :class:`types.NoneType`."

msgid ""
"If :func:`@no_type_check <no_type_check>` has been applied to *obj*, an "
"empty dictionary is returned."
msgstr ""
"Om :func:`@no_type_check <no_type_check>` har tillämpats på *obj* returneras "
"en tom ordbok."

msgid ""
"If *obj* is a class ``C``, the function returns a dictionary that merges "
"annotations from ``C``'s base classes with those on ``C`` directly. This is "
"done by traversing :attr:`C.__mro__ <type.__mro__>` and iteratively "
"combining ``__annotations__`` dictionaries. Annotations on classes appearing "
"earlier in the :term:`method resolution order` always take precedence over "
"annotations on classes appearing later in the method resolution order."
msgstr ""
"Om *obj* är en klass ``C`` returnerar funktionen en ordbok som sammanfogar "
"anteckningar från ``C`` basklasser med dem på ``C`` direkt. Detta görs genom "
"att traversera :attr:`C.__mro__ <type.__mro__>` och iterativt kombinera "
"``__annotations__`` dictionaries. Anteckningar om klasser som förekommer "
"tidigare i :term:``method resolution order`` har alltid företräde framför "
"anteckningar om klasser som förekommer senare i metodupplösningsordningen."

msgid ""
"The function recursively replaces all occurrences of ``Annotated[T, ...]`` "
"with ``T``, unless *include_extras* is set to ``True`` (see :class:"
"`Annotated` for more information)."
msgstr ""
"Funktionen ersätter rekursivt alla förekomster av ``Annotated[T, ...]`` med "
"``T``, såvida inte *include_extras* är satt till ``True`` (se :class:"
"`Annotated` för mer information)."

msgid ""
"See also :func:`annotationlib.get_annotations`, a lower-level function that "
"returns annotations more directly."
msgstr ""
"Se även :func:`annotationlib.get_annotations`, en funktion på lägre nivå som "
"returnerar annoteringar mer direkt."

msgid ""
"If any forward references in the annotations of *obj* are not resolvable or "
"are not valid Python code, this function will raise an exception such as :"
"exc:`NameError`. For example, this can happen with imported :ref:`type "
"aliases <type-aliases>` that include forward references, or with names "
"imported under :data:`if TYPE_CHECKING <TYPE_CHECKING>`."
msgstr ""
"Om några framåtriktade referenser i annoteringarna för *obj* inte kan lösas "
"eller inte är giltig Python-kod, kommer denna funktion att ge upphov till "
"ett undantag som :exc:`NameError`. Detta kan till exempel hända med "
"importerade :ref:`type aliases <type-aliases>` som innehåller framåtriktade "
"referenser, eller med namn som importeras under :data:`if TYPE_CHECKING "
"<TYPE_CHECKING>`."

msgid ""
"Added ``include_extras`` parameter as part of :pep:`593`. See the "
"documentation on :data:`Annotated` for more information."
msgstr ""
"Lade till parametern ``include_extras`` som en del av :pep:`593`. Se "
"dokumentationen för :data:`Annotated` för mer information."

msgid ""
"Previously, ``Optional[t]`` was added for function and method annotations if "
"a default value equal to ``None`` was set. Now the annotation is returned "
"unchanged."
msgstr ""
"Tidigare lades ``Optional[t]`` till för funktions- och metodannoteringar om "
"ett standardvärde som var lika med ``None`` angavs. Nu returneras "
"annoteringen oförändrad."

msgid ""
"Get the unsubscripted version of a type: for a typing object of the form "
"``X[Y, Z, ...]`` return ``X``."
msgstr ""
"Hämta den osubscripterade versionen av en typ: för ett typobjekt av formen "
"``X[Y, Z, ...]`` returneras ``X``."

msgid ""
"If ``X`` is a typing-module alias for a builtin or :mod:`collections` class, "
"it will be normalized to the original class. If ``X`` is an instance of :"
"class:`ParamSpecArgs` or :class:`ParamSpecKwargs`, return the underlying :"
"class:`ParamSpec`. Return ``None`` for unsupported objects."
msgstr ""
"Om ``X`` är ett typing-module alias för en inbyggd klass eller :mod:"
"`collections` klass, kommer den att normaliseras till den ursprungliga "
"klassen. Om ``X`` är en instans av :class:`ParamSpecArgs` eller :class:"
"`ParamSpecKwargs`, returneras den underliggande :class:`ParamSpec`. "
"Returnerar ``None`` för objekt som inte stöds."

msgid "Examples:"
msgstr "Exempel:"

msgid ""
"assert get_origin(str) is None\n"
"assert get_origin(Dict[str, int]) is dict\n"
"assert get_origin(Union[int, str]) is Union\n"
"assert get_origin(Annotated[str, \"metadata\"]) is Annotated\n"
"P = ParamSpec('P')\n"
"assert get_origin(P.args) is P\n"
"assert get_origin(P.kwargs) is P"
msgstr ""
"assert get_origin(str) är ingen\n"
"assert get_origin(Dict[str, int]) är dict\n"
"assert get_origin(Union[int, str]) är Union\n"
"assert get_origin(Annotated[str, \"metadata\"]) is Annotated\n"
"P = ParamSpec('P')\n"
"assert get_origin(P.args) is P\n"
"assert get_origin(P.kwargs) är P"

msgid ""
"Get type arguments with all substitutions performed: for a typing object of "
"the form ``X[Y, Z, ...]`` return ``(Y, Z, ...)``."
msgstr ""
"Hämta typargument med alla substitutioner utförda: för ett typobjekt av "
"formen ``X[Y, Z, ...]`` returneras ``(Y, Z, ...)``."

msgid ""
"If ``X`` is a union or :class:`Literal` contained in another generic type, "
"the order of ``(Y, Z, ...)`` may be different from the order of the original "
"arguments ``[Y, Z, ...]`` due to type caching. Return ``()`` for unsupported "
"objects."
msgstr ""
"Om ``X`` är en union eller :class:`Literal` som ingår i en annan generisk "
"typ, kan ordningen på ``(Y, Z, ...)`` skilja sig från ordningen på de "
"ursprungliga argumenten ``[Y, Z, ...]`` på grund av typcaching. Returnera "
"``()`` för objekt som inte stöds."

msgid ""
"assert get_args(int) == ()\n"
"assert get_args(Dict[int, str]) == (int, str)\n"
"assert get_args(Union[int, str]) == (int, str)"
msgstr ""
"assert get_args(int) == ()\n"
"assert get_args(Dict[int, str]) == (int, str)\n"
"assert get_args(Union[int, str]) == (int, str)"

msgid "Return the set of members defined in a :class:`Protocol`."
msgstr ""
"Returnerar den uppsättning medlemmar som definieras i en :class:`Protocol`."

msgid ""
">>> from typing import Protocol, get_protocol_members\n"
">>> class P(Protocol):\n"
"...     def a(self) -> str: ...\n"
"...     b: int\n"
">>> get_protocol_members(P) == frozenset({'a', 'b'})\n"
"True"
msgstr ""
">>> from typing import Protokoll, get_protocol_members\n"
">>> klass P(Protokoll):\n"
"... def a(self) -> str: ...\n"
"... b: int\n"
">>> get_protocol_members(P) == frozenset({'a', 'b'})\n"
"True"

msgid "Raise :exc:`TypeError` for arguments that are not Protocols."
msgstr "Utlös :exc:`TypeError` för argument som inte är protokoll."

msgid "Determine if a type is a :class:`Protocol`."
msgstr "Avgör om en typ är en :class:`Protocol`."

msgid ""
"class P(Protocol):\n"
"    def a(self) -> str: ...\n"
"    b: int\n"
"\n"
"is_protocol(P)    # => True\n"
"is_protocol(int)  # => False"
msgstr ""
"klass P(Protokoll):\n"
"    def a(self) -> str: ...\n"
"    b: int\n"
"\n"
"is_protocol(P) # => True\n"
"is_protocol(int) # => Falsk"

msgid "Check if a type is a :class:`TypedDict`."
msgstr "Kontrollera om en typ är en :class:`TypedDict`."

msgid ""
"class Film(TypedDict):\n"
"    title: str\n"
"    year: int\n"
"\n"
"assert is_typeddict(Film)\n"
"assert not is_typeddict(list | str)\n"
"\n"
"# TypedDict is a factory for creating typed dicts,\n"
"# not a typed dict itself\n"
"assert not is_typeddict(TypedDict)"
msgstr ""
"klass Film(TypedDict):\n"
"    titel: str\n"
"    år: int\n"
"\n"
"assert is_typeddict(Film)\n"
"assert not is_typeddict(lista | str)\n"
"\n"
"# TypedDict är en fabrik för att skapa typade dikter,\n"
"# inte en typad dikt i sig själv\n"
"assert not is_typeddict(TypedDict)"

msgid ""
"Class used for internal typing representation of string forward references."
msgstr ""
"Klass som används för intern typningsrepresentation av strängens "
"framåtriktade referenser."

msgid ""
"For example, ``List[\"SomeClass\"]`` is implicitly transformed into "
"``List[ForwardRef(\"SomeClass\")]``.  :class:`!ForwardRef` should not be "
"instantiated by a user, but may be used by introspection tools."
msgstr ""
"Exempelvis omvandlas ``List[\"SomeClass\"]`` implicit till "
"``List[ForwardRef(\"SomeClass\")]``. :class:`!ForwardRef` bör inte "
"instansieras av en användare, men kan användas av introspektionsverktyg."

msgid ""
":pep:`585` generic types such as ``list[\"SomeClass\"]`` will not be "
"implicitly transformed into ``list[ForwardRef(\"SomeClass\")]`` and thus "
"will not automatically resolve to ``list[SomeClass]``."
msgstr ""
":pep:`585` generiska typer som ``list[\"SomeClass\"]`` kommer inte att "
"implicit transformeras till ``list[ForwardRef(\"SomeClass\")]`` och kommer "
"därför inte automatiskt att lösas upp till ``list[SomeClass]``."

msgid ""
"This is now an alias for :class:`annotationlib.ForwardRef`. Several "
"undocumented behaviors of this class have been changed; for example, after a "
"``ForwardRef`` has been evaluated, the evaluated value is no longer cached."
msgstr ""
"Detta är nu ett alias för :class:`annotationlib.ForwardRef`. Flera "
"odokumenterade beteenden hos denna klass har ändrats; till exempel, efter "
"att en ``ForwardRef`` har utvärderats, cachelagras inte längre det "
"utvärderade värdet."

msgid "Evaluate an :class:`annotationlib.ForwardRef` as a :term:`type hint`."
msgstr ""
"Utvärdera en :class:`annotationlib.ForwardRef` som en :term:`type hint`."

msgid ""
"This is similar to calling :meth:`annotationlib.ForwardRef.evaluate`, but "
"unlike that method, :func:`!evaluate_forward_ref` also recursively evaluates "
"forward references nested within the type hint."
msgstr ""
"Detta liknar anropet av :meth:`annotationlib.ForwardRef.evaluate`, men till "
"skillnad från den metoden utvärderar :func:`!evaluate_forward_ref` även "
"framåtriktade referenser som är kapslade i typtipset rekursivt."

msgid ""
"See the documentation for :meth:`annotationlib.ForwardRef.evaluate` for the "
"meaning of the *owner*, *globals*, *locals*, *type_params*, and *format* "
"parameters."
msgstr ""
"Se dokumentationen för :meth:`annotationlib.ForwardRef.evaluate` för "
"betydelsen av parametrarna *owner*, *globals*, *locals*, *type_params* och "
"*format*."

msgid ""
"A sentinel object used to indicate that a type parameter has no default "
"value. For example:"
msgstr ""
"Ett sentinel-objekt som används för att ange att en typ-parameter inte har "
"något standardvärde. Ett exempel:"

msgid ""
">>> T = TypeVar(\"T\")\n"
">>> T.__default__ is typing.NoDefault\n"
"True\n"
">>> S = TypeVar(\"S\", default=None)\n"
">>> S.__default__ is None\n"
"True"
msgstr ""
">>> T = TypeVar(\"T\")\n"
">>> T.__default__ är typing.NoDefault\n"
"Sant\n"
">>> S = TypeVar(\"S\", default=None)\n"
">>> S.__default__ är Ingen\n"
"True"

msgid "Constant"
msgstr "Konstant"

msgid ""
"A special constant that is assumed to be ``True`` by 3rd party static type "
"checkers. It's ``False`` at runtime."
msgstr ""
"En speciell konstant som antas vara ``True`` av statiska typkontrollanter "
"från tredje part. Den är ``False`` vid runtime."

msgid ""
"A module which is expensive to import, and which only contain types used for "
"typing annotations, can be safely imported inside an ``if TYPE_CHECKING:`` "
"block.  This prevents the module from actually being imported at runtime; "
"annotations aren't eagerly evaluated (see :pep:`649`) so using undefined "
"symbols in annotations is harmless--as long as you don't later examine them. "
"Your static type analysis tool will set ``TYPE_CHECKING`` to ``True`` during "
"static type analysis, which means the module will be imported and the types "
"will be checked properly during such analysis."
msgstr ""
"En modul som är dyr att importera, och som bara innehåller typer som används "
"för att skriva annoteringar, kan säkert importeras inuti ett ``if "
"TYPE_CHECKING:``-block.  Detta förhindrar att modulen faktiskt importeras "
"vid körning; anteckningar utvärderas inte ivrigt (se :pep:`649`) så att "
"använda odefinierade symboler i anteckningar är ofarligt - så länge du inte "
"senare undersöker dem. Ditt statiska typanalysverktyg kommer att sätta "
"``TYPE_CHECKING`` till ``True`` under statisk typanalys, vilket innebär att "
"modulen kommer att importeras och typerna kommer att kontrolleras korrekt "
"under en sådan analys."

msgid ""
"if TYPE_CHECKING:\n"
"    import expensive_mod\n"
"\n"
"def fun(arg: expensive_mod.SomeType) -> None:\n"
"    local_var: expensive_mod.AnotherType = other_fun()"
msgstr ""
"om TYPE_CHECKING:\n"
"    import dyr_mod\n"
"\n"
"def fun(arg: expensive_mod.SomeType) -> None:\n"
"    local_var: expensive_mod.AnotherType = other_fun()"

msgid ""
"If you occasionally need to examine type annotations at runtime which may "
"contain undefined symbols, use :meth:`annotationlib.get_annotations` with a "
"``format`` parameter of :attr:`annotationlib.Format.STRING` or :attr:"
"`annotationlib.Format.FORWARDREF` to safely retrieve the annotations without "
"raising :exc:`NameError`."
msgstr ""
"Om du ibland behöver undersöka typannoteringar vid körning som kan innehålla "
"odefinierade symboler, använd :meth:`annotationlib.get_annotations` med en "
"``format`` parameter av :attr:`annotationlib.Format.STRING` eller :attr:"
"`annotationlib.Format.FORWARDREF` för att säkert hämta annoteringarna utan "
"att ge upphov till :exc:`NameError`."

msgid "Deprecated aliases"
msgstr "Föråldrade alias"

msgid ""
"This module defines several deprecated aliases to pre-existing standard "
"library classes. These were originally included in the :mod:`!typing` module "
"in order to support parameterizing these generic classes using ``[]``. "
"However, the aliases became redundant in Python 3.9 when the corresponding "
"pre-existing classes were enhanced to support ``[]`` (see :pep:`585`)."
msgstr ""
"Denna modul definierar flera föråldrade alias till redan existerande "
"standardbiblioteksklasser. Dessa ingick ursprungligen i modulen :mod:`!"
"typing` för att stödja parametrisering av dessa generiska klasser med hjälp "
"av ``[]``. Aliasen blev dock överflödiga i Python 3.9 när de motsvarande "
"befintliga klasserna förbättrades för att stödja ``[]`` (se :pep:`585`)."

msgid ""
"The redundant types are deprecated as of Python 3.9. However, while the "
"aliases may be removed at some point, removal of these aliases is not "
"currently planned. As such, no deprecation warnings are currently issued by "
"the interpreter for these aliases."
msgstr ""
"De överflödiga typerna är föråldrade från och med Python 3.9. Men även om "
"alias kan tas bort vid någon tidpunkt, är det för närvarande inte planerat "
"att ta bort dessa alias. Därför utfärdas för närvarande inga deprecation-"
"varningar av tolken för dessa alias."

msgid ""
"If at some point it is decided to remove these deprecated aliases, a "
"deprecation warning will be issued by the interpreter for at least two "
"releases prior to removal. The aliases are guaranteed to remain in the :mod:"
"`!typing` module without deprecation warnings until at least Python 3.14."
msgstr ""
"Om det vid någon tidpunkt beslutas att ta bort dessa föråldrade aliaser, "
"kommer en varning om föråldring att utfärdas av tolken i minst två utgåvor "
"innan borttagningen. Aliasen kommer garanterat att finnas kvar i :mod:`!"
"typing`-modulen utan deprecation-varningar fram till åtminstone Python 3.14."

msgid ""
"Type checkers are encouraged to flag uses of the deprecated types if the "
"program they are checking targets a minimum Python version of 3.9 or newer."
msgstr ""
"Typkontrollanter uppmanas att flagga användningar av de föråldrade typerna "
"om programmet de kontrollerar riktar sig till en minsta Python-version av "
"3.9 eller nyare."

msgid "Aliases to built-in types"
msgstr "Aliaser till inbyggda typer"

msgid "Deprecated alias to :class:`dict`."
msgstr "Föråldrat alias till :class:`dict`."

msgid ""
"Note that to annotate arguments, it is preferred to use an abstract "
"collection type such as :class:`~collections.abc.Mapping` rather than to "
"use :class:`dict` or :class:`!typing.Dict`."
msgstr ""
"Observera att för att annotera argument är det bättre att använda en "
"abstrakt samlingstyp som :class:`~collections.abc.Mapping` än att använda :"
"class:`dict` eller :class:`!typing.Dict`."

msgid ""
":class:`builtins.dict <dict>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
" class:`builtins.dict <dict>` stöder nu subskription (``[]``). Se :pep:`585` "
"och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`list`."
msgstr "Föråldrat alias till :class:`list`."

msgid ""
"Note that to annotate arguments, it is preferred to use an abstract "
"collection type such as :class:`~collections.abc.Sequence` or :class:"
"`~collections.abc.Iterable` rather than to use :class:`list` or :class:`!"
"typing.List`."
msgstr ""
"Observera att för att annotera argument är det bättre att använda en "
"abstrakt samlingstyp som :class:`~collections.abc.Sequence` eller :class:"
"`~collections.abc.Iterable` än att använda :class:`list` eller :class:`!"
"typing.List`."

msgid ""
":class:`builtins.list <list>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.list <list>` stöder nu subskription (``[]``). Se :pep:`585` "
"och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`builtins.set <set>`."
msgstr "Föråldrat alias till :class:`builtins.set <set>`."

msgid ""
"Note that to annotate arguments, it is preferred to use an abstract "
"collection type such as :class:`collections.abc.Set` rather than to use :"
"class:`set` or :class:`typing.Set`."
msgstr ""
"Observera att för att annotera argument är det bättre att använda en "
"abstrakt samlingstyp som :class:`collections.abc.Set` än att använda :class:"
"`set` eller :class:`typing.Set`."

msgid ""
":class:`builtins.set <set>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
" :class:`builtins.set <set>` stöder nu subskription (``[]``). Se :pep:`585` "
"och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`builtins.frozenset <frozenset>`."
msgstr "Föråldrat alias till :class:`builtins.frozenset <frozenset>`."

msgid ""
":class:`builtins.frozenset <frozenset>` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.frozenset <frozenset>` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias for :class:`tuple`."
msgstr "Föråldrat alias för :class:`tuple`."

msgid ""
":class:`tuple` and ``Tuple`` are special-cased in the type system; see :ref:"
"`annotating-tuples` for more details."
msgstr ""
":class:`tuple` och ``Tuple`` är specialfall i typsystemet; se :ref:"
"`annotating-tuples` för mer information."

msgid ""
":class:`builtins.tuple <tuple>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
" :class:`builtins.tuple <tuple>` har nu stöd för subskription (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`type`."
msgstr "Föråldrat alias till :class:`type`."

msgid ""
"See :ref:`type-of-class-objects` for details on using :class:`type` or "
"``typing.Type`` in type annotations."
msgstr ""
"Se :ref:`type-of-class-objects` för detaljer om hur man använder :class:"
"`type` eller ``typing.Type`` i typannoteringar."

msgid ""
":class:`builtins.type <type>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.type <type>` stöder nu subskription (``[]``). Se :pep:`585` "
"och :ref:`types-genericalias`."

msgid "Aliases to types in :mod:`collections`"
msgstr "Alias till typer i :mod:`samlingar`"

msgid "Deprecated alias to :class:`collections.defaultdict`."
msgstr "Föråldrat alias till :class:`collections.defaultdict`."

msgid ""
":class:`collections.defaultdict` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.defaultdict` har nu stöd för subskription (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.OrderedDict`."
msgstr "Föråldrat alias till :class:`collections.OrderedDict`."

msgid ""
":class:`collections.OrderedDict` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.OrderedDict` har nu stöd för subskription (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.ChainMap`."
msgstr "Föråldrat alias till :class:`collections.ChainMap`."

msgid ""
":class:`collections.ChainMap` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.ChainMap` har nu stöd för subskription (``[]``). Se :pep:"
"`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.Counter`."
msgstr "Föråldrat alias till :class:`collections.Counter`."

msgid ""
":class:`collections.Counter` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.Counter` har nu stöd för subskription (``[]``). Se :pep:"
"`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.deque`."
msgstr "Föråldrat alias till :class:`collections.deque`."

msgid ""
":class:`collections.deque` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.deque` har nu stöd för subskription (``[]``). Se :pep:"
"`585` och :ref:`types-genericalias`."

msgid "Aliases to other concrete types"
msgstr "Alias till andra konkreta typer"

msgid ""
"Deprecated aliases corresponding to the return types from :func:`re.compile` "
"and :func:`re.match`."
msgstr ""
"Föråldrade alias som motsvarar returtyperna från :func:`re.compile` och :"
"func:`re.match`."

msgid ""
"These types (and the corresponding functions) are generic over :data:"
"`AnyStr`. ``Pattern`` can be specialised as ``Pattern[str]`` or "
"``Pattern[bytes]``; ``Match`` can be specialised as ``Match[str]`` or "
"``Match[bytes]``."
msgstr ""
"Dessa typer (och motsvarande funktioner) är generiska över :data:`AnyStr`. "
"``Pattern`` kan specialiseras som ``Pattern[str]`` eller ``Pattern[bytes]``; "
"``Match`` kan specialiseras som ``Match[str]`` eller ``Match[bytes]``."

msgid ""
"Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``. See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
"Klasserna ``Pattern`` och ``Match`` från :mod:`re` har nu stöd för ``[]``. "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias for :class:`str`."
msgstr "Föråldrat alias för :class:`str`."

msgid ""
"``Text`` is provided to supply a forward compatible path for Python 2 code: "
"in Python 2, ``Text`` is an alias for ``unicode``."
msgstr ""
"``Text`` tillhandahålls för att tillhandahålla en framåtkompatibel sökväg "
"för Python 2-kod: i Python 2 är ``Text`` ett alias för ``unicode``."

msgid ""
"Use ``Text`` to indicate that a value must contain a unicode string in a "
"manner that is compatible with both Python 2 and Python 3::"
msgstr ""
"Använd ``Text`` för att ange att ett värde måste innehålla en unicode-sträng "
"på ett sätt som är kompatibelt med både Python 2 och Python 3::"

msgid ""
"def add_unicode_checkmark(text: Text) -> Text:\n"
"    return text + u' \\u2713'"
msgstr ""
"def add_unicode_checkmark(text: Text) -> Text:\n"
"    return text + u' \\u2713'"

msgid ""
"Python 2 is no longer supported, and most type checkers also no longer "
"support type checking Python 2 code. Removal of the alias is not currently "
"planned, but users are encouraged to use :class:`str` instead of ``Text``."
msgstr ""
"Python 2 stöds inte längre, och de flesta typkontrollprogram stöder inte "
"heller längre typkontroll av Python 2-kod. Det är för närvarande inte "
"planerat att ta bort aliaset, men användare uppmuntras att använda :class:"
"`str` istället för ``Text``."

msgid "Aliases to container ABCs in :mod:`collections.abc`"
msgstr "Alias till container ABC i :mod:`collections.abc`"

msgid "Deprecated alias to :class:`collections.abc.Set`."
msgstr "Föråldrat alias till :class:`collections.abc.Set`."

msgid ""
":class:`collections.abc.Set` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Set` har nu stöd för subskription (``[]``). Se :pep:"
"`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Collection`."
msgstr "Föråldrat alias till :class:`collections.abc.Collection`."

msgid ""
":class:`collections.abc.Collection` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Collection` har nu stöd för subskription (``[]``). "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Container`."
msgstr "Föråldrat alias till :class:`collections.abc.Container`."

msgid ""
":class:`collections.abc.Container` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Container` har nu stöd för subscripting (``[]``). "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.ItemsView`."
msgstr "Föråldrat alias till :class:`collections.abc.ItemsView`."

msgid ""
":class:`collections.abc.ItemsView` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ItemsView` stöder nu subskription (``[]``). Se :pep:"
"`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.KeysView`."
msgstr "Föråldrat alias till :class:`collections.abc.KeysView`."

msgid ""
":class:`collections.abc.KeysView` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.KeysView` har nu stöd för subscripting (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Mapping`."
msgstr "Föråldrat alias till :class:`collections.abc.Mapping`."

msgid ""
":class:`collections.abc.Mapping` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Mapping` har nu stöd för subskription (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.MappingView`."
msgstr "Föråldrat alias till :class:`collections.abc.MappingView`."

msgid ""
":class:`collections.abc.MappingView` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MappingView` stöder nu subskription (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.MutableMapping`."
msgstr "Föråldrat alias till :class:`collections.abc.MutableMapping`."

msgid ""
":class:`collections.abc.MutableMapping` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableMapping` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.MutableSequence`."
msgstr "Föråldrat alias till :class:`collections.abc.MutableSequence`."

msgid ""
":class:`collections.abc.MutableSequence` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSequence` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.MutableSet`."
msgstr "Föråldrat alias till :class:`collections.abc.MutableSet`."

msgid ""
":class:`collections.abc.MutableSet` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSet` har nu stöd för subscripting (``[]``). "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Sequence`."
msgstr "Föråldrat alias till :class:`collections.abc.Sequence`."

msgid ""
":class:`collections.abc.Sequence` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Sequence` har nu stöd för subskription (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.ValuesView`."
msgstr "Föråldrat alias till :class:`collections.abc.ValuesView`."

msgid ""
":class:`collections.abc.ValuesView` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ValuesView` stöder nu subskription (``[]``). Se :pep:"
"`585` och :ref:`types-genericalias`."

msgid "Aliases to asynchronous ABCs in :mod:`collections.abc`"
msgstr "Aliaser till asynkrona ABC i :mod:`collections.abc`"

msgid "Deprecated alias to :class:`collections.abc.Coroutine`."
msgstr "Föråldrat alias till :class:`collections.abc.Coroutine`."

msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using :class:"
"`collections.abc.Coroutine` and ``typing.Coroutine`` in type annotations."
msgstr ""
"Se :ref:`annotating-generators-and-coroutines` för detaljer om hur man "
"använder :class:`collections.abc.Coroutine` och ``typing.Coroutine`` i "
"typannoteringar."

msgid ""
":class:`collections.abc.Coroutine` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Coroutine` har nu stöd för subscripting (``[]``). "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.AsyncGenerator`."
msgstr "Föråldrat alias till :class:`collections.abc.AsyncGenerator`."

msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using :class:"
"`collections.abc.AsyncGenerator` and ``typing.AsyncGenerator`` in type "
"annotations."
msgstr ""
"Se :ref:`annotating-generators-and-coroutines` för detaljer om hur du "
"använder :class:`collections.abc.AsyncGenerator` och ``typing."
"AsyncGenerator`` i typannoteringar."

msgid ""
":class:`collections.abc.AsyncGenerator` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncGenerator` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "The ``SendType`` parameter now has a default."
msgstr "Parametern ``SendType`` har nu en standard."

msgid "Deprecated alias to :class:`collections.abc.AsyncIterable`."
msgstr "Föråldrat alias till :class:`collections.abc.AsyncIterable`."

msgid ""
":class:`collections.abc.AsyncIterable` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterable` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.AsyncIterator`."
msgstr "Föråldrat alias till :class:`collections.abc.AsyncIterator`."

msgid ""
":class:`collections.abc.AsyncIterator` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterator` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Awaitable`."
msgstr "Föråldrat alias till :class:`collections.abc.Awaitable`."

msgid ""
":class:`collections.abc.Awaitable` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Awaitable` har nu stöd för subscripting (``[]``). "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Aliases to other ABCs in :mod:`collections.abc`"
msgstr "Alias till andra ABC i :mod:`collections.abc`"

msgid "Deprecated alias to :class:`collections.abc.Iterable`."
msgstr "Föråldrat alias till :class:`collections.abc.Iterable`."

msgid ""
":class:`collections.abc.Iterable` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterable` har nu stöd för subscripting (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Iterator`."
msgstr "Föråldrat alias till :class:`collections.abc.Iterator`."

msgid ""
":class:`collections.abc.Iterator` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterator` har nu stöd för subscripting (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Callable`."
msgstr "Föråldrat alias till :class:`collections.abc.Callable`."

msgid ""
"See :ref:`annotating-callables` for details on how to use :class:"
"`collections.abc.Callable` and ``typing.Callable`` in type annotations."
msgstr ""
"Se :ref:`annotating-callables` för detaljer om hur man använder :class:"
"`collections.abc.Callable` och ``typing.Callable`` i typannoteringar."

msgid ""
":class:`collections.abc.Callable` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Callable` har nu stöd för subscripting (``[]``). Se :"
"pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Generator`."
msgstr "Föråldrat alias till :class:`collections.abc.Generator`."

msgid ""
"See :ref:`annotating-generators-and-coroutines` for details on using :class:"
"`collections.abc.Generator` and ``typing.Generator`` in type annotations."
msgstr ""
"Se :ref:`annotating-generators-and-coroutines` för detaljer om hur man "
"använder :class:`collections.abc.Generator` och ``typing.Generator`` i "
"typannoteringar."

msgid ""
":class:`collections.abc.Generator` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Generator` har nu stöd för subskription (``[]``). "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Default values for the send and return types were added."
msgstr "Standardvärden för send- och return-typerna har lagts till."

msgid "Deprecated alias to :class:`collections.abc.Hashable`."
msgstr "Föråldrat alias till :class:`collections.abc.Hashable`."

msgid "Use :class:`collections.abc.Hashable` directly instead."
msgstr "Använd :class:`collections.abc.Hashable` direkt istället."

msgid "Deprecated alias to :class:`collections.abc.Reversible`."
msgstr "Föråldrat alias till :class:`collections.abc.Reversible`."

msgid ""
":class:`collections.abc.Reversible` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Reversible` har nu stöd för subscripting (``[]``). "
"Se :pep:`585` och :ref:`types-genericalias`."

msgid "Deprecated alias to :class:`collections.abc.Sized`."
msgstr "Föråldrat alias till :class:`collections.abc.Sized`."

msgid "Use :class:`collections.abc.Sized` directly instead."
msgstr "Använd :class:`collections.abc.Sized` direkt istället."

msgid "Aliases to :mod:`contextlib` ABCs"
msgstr "Aliaser till :mod:`contextlib` ABC"

msgid "Deprecated alias to :class:`contextlib.AbstractContextManager`."
msgstr "Föråldrat alias till :class:`contextlib.AbstractContextManager`."

msgid ""
"The first type parameter, ``T_co``, represents the type returned by the :"
"meth:`~object.__enter__` method. The optional second type parameter, "
"``ExitT_co``, which defaults to ``bool | None``, represents the type "
"returned by the :meth:`~object.__exit__` method."
msgstr ""
"Den första typparametern, ``T_co``, representerar den typ som returneras av "
"metoden :meth:`~object.__enter__`. Den valfria andra typ-parametern, "
"``ExitT_co``, som som standard är ``bool | None``, representerar den typ som "
"returneras av metoden :meth:`~object.__exit__`."

msgid ""
":class:`contextlib.AbstractContextManager` now supports subscripting "
"(``[]``). See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`contextlib.AbstractContextManager` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "Added the optional second type parameter, ``ExitT_co``."
msgstr "Lagt till den valfria andra typparametern, ``ExitT_co``."

msgid "Deprecated alias to :class:`contextlib.AbstractAsyncContextManager`."
msgstr "Föråldrat alias till :class:`contextlib.AbstractAsyncContextManager`."

msgid ""
"The first type parameter, ``T_co``, represents the type returned by the :"
"meth:`~object.__aenter__` method. The optional second type parameter, "
"``AExitT_co``, which defaults to ``bool | None``, represents the type "
"returned by the :meth:`~object.__aexit__` method."
msgstr ""
"Den första typparametern, ``T_co``, representerar den typ som returneras av "
"metoden :meth:`~object.__aenter__`. Den valfria andra typ-parametern, "
"``AExitT_co``, som som standard är ``bool | None``, representerar den typ "
"som returneras av metoden :meth:`~object.__aexit__`."

msgid ""
":class:`contextlib.AbstractAsyncContextManager` now supports subscripting "
"(``[]``). See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`contextlib.AbstractAsyncContextManager` har nu stöd för subscripting "
"(``[]``). Se :pep:`585` och :ref:`types-genericalias`."

msgid "Added the optional second type parameter, ``AExitT_co``."
msgstr "Den valfria andra typparametern ``AExitT_co`` har lagts till."

msgid "Deprecation Timeline of Major Features"
msgstr "Tidslinje för utfasning av viktiga funktioner"

msgid ""
"Certain features in ``typing`` are deprecated and may be removed in a future "
"version of Python. The following table summarizes major deprecations for "
"your convenience. This is subject to change, and not all deprecations are "
"listed."
msgstr ""
"Vissa funktioner i ``typing`` är föråldrade och kan tas bort i en framtida "
"version av Python. Följande tabell sammanfattar större föråldringar för din "
"bekvämlighet. Detta kan komma att ändras, och alla föråldringar är inte "
"listade."

msgid "Feature"
msgstr "Funktion"

msgid "Deprecated in"
msgstr "Avskrivna i"

msgid "Projected removal"
msgstr "Förväntat borttagande"

msgid "PEP/issue"
msgstr "PEP/fråga"

msgid "``typing`` versions of standard collections"
msgstr "``typning`` av versioner av standardsamlingar"

msgid "3.9"
msgstr "3.9"

msgid "Undecided (see :ref:`deprecated-aliases` for more information)"
msgstr "Obestämd (se :ref:`deprecated-aliases` för mer information)"

msgid ":pep:`585`"
msgstr ":pep:`585``"

msgid ":data:`typing.Text`"
msgstr ":data:`typing.Text`"

msgid "3.11"
msgstr "3.11"

msgid "Undecided"
msgstr "Väntande"

msgid ":gh:`92332`"
msgstr ":gh:`92332``"

msgid ":class:`typing.Hashable` and :class:`typing.Sized`"
msgstr ":class:`typing.Hashable` och :class:`typing.Sized`"

msgid "3.12"
msgstr "3.12"

msgid ":gh:`94309`"
msgstr ":gh:`94309``"

msgid ":data:`typing.TypeAlias`"
msgstr ":data:`typing.TypeAlias`"

msgid ":pep:`695`"
msgstr ":pep:`695``"

msgid ":func:`@typing.no_type_check_decorator <no_type_check_decorator>`"
msgstr ":func:`@typing.no_type_check_decorator <no_type_check_decorator>`"

msgid "3.13"
msgstr "3.13"

msgid "3.15"
msgstr "3.15"

msgid ":gh:`106309`"
msgstr ":gh:`106309``"

msgid ":data:`typing.AnyStr`"
msgstr ":data:`typning.AnyStr`"

msgid "3.18"
msgstr "3.18"

msgid ":gh:`105578`"
msgstr ":gh:`105578``"
