# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!threading` --- Thread-based parallelism"
msgstr ":mod:`!threading` --- Trådbaserad parallellism"

msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**Källkod:** :source:`Lib/threading.py`"

msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module."
msgstr ""
"Denna modul konstruerar trådningsgränssnitt på högre nivå ovanpå modulen :"
"mod:`_thread` på lägre nivå."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"The :mod:`!threading` module provides a way to run multiple `threads "
"<https://en.wikipedia.org/wiki/Thread_(computing)>`_ (smaller units of a "
"process) concurrently within a single process. It allows for the creation "
"and management of threads, making it possible to execute tasks in parallel, "
"sharing memory space. Threads are particularly useful when tasks are I/O "
"bound, such as file operations or making network requests, where much of the "
"time is spent waiting for external resources."
msgstr ""
"Modulen :mod:`!threading` ger möjlighet att köra flera `threads <https://en."
"wikipedia.org/wiki/Thread_(computing)>`_ (mindre enheter av en process) "
"samtidigt inom en och samma process. Den gör det möjligt att skapa och "
"hantera trådar, vilket gör det möjligt att utföra uppgifter parallellt och "
"dela minnesutrymme. Trådar är särskilt användbara när uppgifter är I/O-"
"bundna, t.ex. filoperationer eller nätverksförfrågningar, där en stor del av "
"tiden går åt till att vänta på externa resurser."

msgid ""
"A typical use case for :mod:`!threading` includes managing a pool of worker "
"threads that can process multiple tasks concurrently.  Here's a basic "
"example of creating and starting threads using :class:`~threading.Thread`::"
msgstr ""
"Ett typiskt användningsområde för :mod:`!threading` är att hantera en pool "
"av arbetstrådar som kan bearbeta flera uppgifter samtidigt.  Här är ett "
"grundläggande exempel på att skapa och starta trådar med :class:`~threading."
"Thread`::"

msgid ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"    print(f\"crawl started for {link}\")\n"
"    time.sleep(delay)  # Blocking I/O (simulating a network request)\n"
"    print(f\"crawl ended for {link}\")\n"
"\n"
"links = [\n"
"    \"https://python.org\",\n"
"    \"https://docs.python.org\",\n"
"    \"https://peps.python.org\",\n"
"]\n"
"\n"
"# Start threads for each link\n"
"threads = []\n"
"for link in links:\n"
"    # Using `args` to pass positional arguments and `kwargs` for keyword "
"arguments\n"
"    t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"    threads.append(t)\n"
"\n"
"# Start each thread\n"
"for t in threads:\n"
"    t.start()\n"
"\n"
"# Wait for all threads to finish\n"
"for t in threads:\n"
"    t.join()"
msgstr ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"    print(f\"crawl started for {link}\")\n"
"    time.sleep(delay)  # Blocking I/O (simulating a network request)\n"
"    print(f\"crawl ended for {link}\")\n"
"\n"
"links = [\n"
"    \"https://python.org\",\n"
"    \"https://docs.python.org\",\n"
"    \"https://peps.python.org\",\n"
"]\n"
"\n"
"# Start threads for each link\n"
"threads = []\n"
"for link in links:\n"
"    # Using `args` to pass positional arguments and `kwargs` for keyword "
"arguments\n"
"    t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"    threads.append(t)\n"
"\n"
"# Start each thread\n"
"for t in threads:\n"
"    t.start()\n"
"\n"
"# Wait for all threads to finish\n"
"for t in threads:\n"
"    t.join()"

msgid "This module used to be optional, it is now always available."
msgstr "Denna modul var tidigare valfri, men är nu alltid tillgänglig."

msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of "
"the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` erbjuder ett gränssnitt på "
"högre nivå för att flytta uppgifter till en bakgrundstråd utan att blockera "
"exekveringen av den anropande tråden, samtidigt som man kan hämta resultaten "
"när det behövs."

msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ""
":mod:`queue` tillhandahåller ett trådsäkert gränssnitt för utbyte av data "
"mellan pågående trådar."

msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ""
":mod:`asyncio` erbjuder en alternativ metod för att uppnå samtidighet på "
"uppgiftsnivå utan att behöva använda flera operativsystemtrådar."

msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some "
"methods and functions. These are deprecated as of Python 3.10, but they are "
"still supported for compatibility with Python 2.5 and lower."
msgstr ""
"I Python 2.x-serien innehöll denna modul ``camelCase``-namn för vissa "
"metoder och funktioner. Dessa är föråldrade från och med Python 3.10, men de "
"stöds fortfarande för kompatibilitet med Python 2.5 och lägre."

msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain "
"performance-oriented libraries might overcome this limitation). If you want "
"your application to make better use of the computational resources of multi-"
"core machines, you are advised to use :mod:`multiprocessing` or :class:"
"`concurrent.futures.ProcessPoolExecutor`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"I CPython, på grund av :term:`Global Interpreter Lock <global interpreter "
"lock>`, kan endast en tråd exekvera Python-kod samtidigt (även om vissa "
"prestandaorienterade bibliotek kan övervinna denna begränsning). Om du vill "
"att din applikation ska utnyttja beräkningsresurserna i flerkärniga maskiner "
"bättre rekommenderas du att använda :mod:`multiprocessing` eller :class:"
"`concurrent.futures.ProcessPoolExecutor`. Trådning är dock fortfarande en "
"lämplig modell om du vill köra flera I/O-bundna uppgifter samtidigt."

msgid "GIL and performance considerations"
msgstr "GIL och prestandaöverväganden"

msgid ""
"Unlike the :mod:`multiprocessing` module, which uses separate processes to "
"bypass the :term:`global interpreter lock` (GIL), the threading module "
"operates within a single process, meaning that all threads share the same "
"memory space. However, the GIL limits the performance gains of threading "
"when it comes to CPU-bound tasks, as only one thread can execute Python "
"bytecode at a time. Despite this, threads remain a useful tool for achieving "
"concurrency in many scenarios."
msgstr ""
"Till skillnad från :mod:`multiprocessing`-modulen, som använder separata "
"processer för att kringgå :term:`global interpreter lock` (GIL), arbetar "
"threading-modulen inom en enda process, vilket innebär att alla trådar delar "
"samma minnesutrymme. GIL begränsar dock prestandavinsterna med trådning när "
"det gäller CPU-bundna uppgifter, eftersom endast en tråd kan exekvera Python-"
"bytekod åt gången. Trots detta är trådar fortfarande ett användbart verktyg "
"för att uppnå samtidighet i många scenarier."

msgid ""
"As of Python 3.13, :term:`free-threaded <free threading>` builds can disable "
"the GIL, enabling true parallel execution of threads, but this feature is "
"not available by default (see :pep:`703`)."
msgstr ""
"Från och med Python 3.13 kan :term:``free-threaded <free threading>`` builds "
"inaktivera GIL, vilket möjliggör äkta parallellkörning av trådar, men den "
"här funktionen är inte tillgänglig som standard (se :pep:`703`)."

msgid "Reference"
msgstr "Referens"

msgid "This module defines the following functions:"
msgstr "Denna modul definierar följande funktioner:"

msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"Returnerar antalet :class:`Thread`-objekt som för närvarande lever.  Antalet "
"som returneras är lika med längden på listan som returneras av :func:`."
"enumerate`."

msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "Funktionen ``activeCount`` är ett föråldrat alias för denna funktion."

msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`!threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"Returnerar det aktuella :class:`Thread`-objektet, motsvarande den anropande "
"enhetens kontrolltråd.  Om anroparens kontrolltråd inte skapades genom "
"modulen :mod:`!threading`, returneras ett dummy-trådobjekt med begränsad "
"funktionalitet."

msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr ""
"Funktionen ``currentThread`` är ett föråldrat alias för denna funktion."

msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "Hantera undantag som uppkommit genom :func:`Thread.run`."

msgid "The *args* argument has the following attributes:"
msgstr "Argumentet *args* har följande attribut:"

msgid "*exc_type*: Exception type."
msgstr "*exc_type*: Typ av undantag."

msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_värde*: Undantagsvärde, kan vara ``None``."

msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: Exception traceback, kan vara ``None``."

msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*tråd*: Tråd som orsakade undantaget, kan vara ``None``."

msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"Om *exc_type* är :exc:`SystemExit`, ignoreras undantaget i tysthet. Annars "
"skrivs undantaget ut på :data:`sys.stderr`."

msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr ""
"Om denna funktion ger upphov till ett undantag anropas :func:`sys."
"excepthook` för att hantera det."

msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`threading.excepthook` kan åsidosättas för att styra hur obehandlade "
"undantag som tas upp av :func:`Thread.run` hanteras."

msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception "
"is no longer needed."
msgstr ""
"Att lagra *exc_value* med en anpassad krok kan skapa en referenscykel. Den "
"bör rensas explicit för att bryta referenscykeln när undantaget inte längre "
"behövs."

msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"Om du lagrar *thread* med en anpassad krok kan den återuppstå om den är "
"inställd på ett objekt som håller på att slutföras. Undvik att lagra "
"*thread* efter att den anpassade kroken har slutförts för att undvika att "
"objekt återuppstår."

msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` hanterar undantag som inte fångats upp."

msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""
"Innehåller det ursprungliga värdet av :func:`threading.excepthook`. Det "
"sparas så att det ursprungliga värdet kan återställas om de skulle råka "
"ersättas med trasiga eller alternativa objekt."

msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Returnerar \"trådidentifieraren\" för den aktuella tråden.  Detta är ett "
"heltal som inte är noll.  Dess värde har ingen direkt betydelse; det är "
"avsett som en magisk cookie som kan användas t.ex. för att indexera en "
"ordbok med trådspecifika data.  Trådidentifierare kan återanvändas när en "
"tråd avslutas och en ny tråd skapas."

msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Returnerar det inbyggda integrerade tråd-ID:t för den aktuella tråden som "
"tilldelats av kärnan. Detta är ett icke-negativt heltal. Dess värde kan "
"användas för att unikt identifiera just denna tråd i hela systemet (tills "
"tråden avslutas, varefter värdet kan återanvändas av operativsystemet)."

msgid "Added support for GNU/kFreeBSD."
msgstr "Lagt till stöd för GNU/kFreeBSD."

msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by :func:"
"`current_thread`.  It excludes terminated threads and threads that have not "
"yet been started.  However, the main thread is always part of the result, "
"even when terminated."
msgstr ""
"Returnerar en lista över alla :class:`Thread`-objekt som för närvarande är "
"aktiva.  Listan inkluderar daemoniska trådar och dummy-trådobjekt som "
"skapats av :func:`current_thread`.  Den utesluter avslutade trådar och "
"trådar som ännu inte har startats.  Huvudtråden är dock alltid en del av "
"resultatet, även när den har avslutats."

msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"Returnerar huvudobjektet :class:`Thread`.  Under normala förhållanden är "
"huvudtråden den tråd från vilken Python-tolken startades."

msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"Ställ in en spårningsfunktion för alla trådar som startas från modulen :mod:"
"`!threading`. *func* kommer att skickas till :func:`sys.settrace` för varje "
"tråd, innan dess :meth:`~Thread.run` metod anropas."

msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr ""
"Ställ in en spårningsfunktion för alla trådar som startas från modulen :mod:"
"`!threading` och alla Python-trådar som körs för närvarande."

msgid ""
"The *func* will be passed to  :func:`sys.settrace` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"*func* kommer att skickas till :func:`sys.settrace` för varje tråd, innan "
"dess :meth:`~Thread.run`-metod anropas."

msgid "Get the trace function as set by :func:`settrace`."
msgstr "Hämta spårningsfunktionen som den ställts in av :func:`settrace`."

msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"Ställ in en profilfunktion för alla trådar som startas från modulen :mod:`!"
"threading`. *func* kommer att skickas till :func:`sys.setprofile` för varje "
"tråd, innan dess :meth:`~Thread.run`-metod anropas."

msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr ""
"Ange en profilfunktion för alla trådar som startas från modulen :mod:`!"
"threading` och alla Python-trådar som körs för närvarande."

msgid ""
"The *func* will be passed to  :func:`sys.setprofile` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"*func* kommer att skickas till :func:`sys.setprofile` för varje tråd, innan "
"dess :meth:`~Thread.run`-metod anropas."

msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "Hämta den profileringsfunktion som ställts in av :func:`setprofile`."

msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Returnerar den trådstackstorlek som används när nya trådar skapas.  Det "
"valfria argumentet *size* anger den stackstorlek som ska användas för senare "
"skapade trådar och måste vara 0 (använd plattformens eller konfigurerade "
"standard) eller ett positivt heltalsvärde på minst 32 768 (32 KiB). Om "
"*size* inte anges används 0.  Om ändring av trådstackens storlek inte stöds, "
"uppstår ett :exc:`RuntimeError`.  Om den angivna stackstorleken är ogiltig, "
"uppstår ett :exc:`ValueError` och stackstorleken ändras inte.  32 KiB är för "
"närvarande det minsta stödda stackstorleksvärdet för att garantera "
"tillräckligt med stackutrymme för själva tolken.  Observera att vissa "
"plattformar kan ha särskilda restriktioner för värden på stackstorleken, t."
"ex. att den minsta stackstorleken måste vara > 32 KiB eller att allokering "
"måste ske i multiplar av sidstorleken i systemminnet - "
"plattformsdokumentationen bör läsas för mer information (4 KiB-sidor är "
"vanliga; att använda multiplar av 4096 för stackstorleken är det föreslagna "
"tillvägagångssättet i avsaknad av mer specifik information)."

msgid "Unix platforms with POSIX threads support."
msgstr "Unix-plattformar med stöd för POSIX-trådar."

msgid "This module also defines the following constant:"
msgstr "Denna modul definierar också följande konstant:"

msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"Det högsta tillåtna värdet för parametern *timeout* i blockeringsfunktioner "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Om du anger en timeout som är större än detta värde kommer ett :exc:"
"`OverflowError` att uppstå."

msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""
"Denna modul definierar ett antal klasser som beskrivs närmare i avsnitten "
"nedan."

msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"Utformningen av denna modul är löst baserad på Javas trådningsmodell. Men "
"där Java gör lås och villkorliga variabler till grundläggande beteende för "
"varje objekt, är de separata objekt i Python.  Pythons :class:`Thread`-klass "
"stöder en delmängd av beteendet hos Javas Thread-klass; för närvarande finns "
"det inga prioriteringar, inga trådgrupper och trådar kan inte förstöras, "
"stoppas, avbrytas, återupptas eller avbrytas.  De statiska metoderna i Javas "
"Thread-klass mappas, när de implementeras, till funktioner på modulnivå."

msgid "All of the methods described below are executed atomically."
msgstr "Alla metoder som beskrivs nedan utförs atomiskt."

msgid "Thread-local data"
msgstr "Trådlokala data"

msgid ""
"Thread-local data is data whose values are thread specific. If you have data "
"that you want to be local to a thread, create a :class:`local` object and "
"use its attributes::"
msgstr ""
"Trådlokala data är data vars värden är trådspecifika. Om du har data som du "
"vill ska vara lokala för en tråd skapar du ett :class:`local`-objekt och "
"använder dess attribut::"

msgid ""
">>> mydata = local()\n"
">>> mydata.number = 42\n"
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata = lokal()\n"
">>> mydata.nummer = 42\n"
">>> mydata.nummer\n"
"42"

msgid "You can also access the :class:`local`-object's dictionary::"
msgstr "Du kan också komma åt :class:`local`-objektets ordbok::"

msgid ""
">>> mydata.__dict__\n"
"{'number': 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"
msgstr ""
">>> mydata.__dict__\n"
"{\"nummer\": 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"

msgid "If we access the data in a different thread::"
msgstr "Om vi kommer åt data i en annan tråd::"

msgid ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"
msgstr ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"

msgid ""
"we get different data.  Furthermore, changes made in the other thread don't "
"affect data seen in this thread::"
msgstr ""
"får vi olika data.  Dessutom påverkar ändringar som gjorts i den andra "
"tråden inte data som ses i den här tråden::"

msgid ""
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata.nummer\n"
"42"

msgid ""
"Of course, values you get from a :class:`local` object, including their :"
"attr:`~object.__dict__` attribute, are for whatever thread was current at "
"the time the attribute was read.  For that reason, you generally don't want "
"to save these values across threads, as they apply only to the thread they "
"came from."
msgstr ""
"Naturligtvis gäller värden som du får från ett :class:`local`-objekt, "
"inklusive deras :attr:`~object.__dict__`-attribut, för den tråd som var "
"aktuell när attributet lästes.  Av den anledningen vill du i allmänhet inte "
"spara dessa värden i olika trådar, eftersom de endast gäller för den tråd de "
"kom från."

msgid ""
"You can create custom :class:`local` objects by subclassing the :class:"
"`local` class::"
msgstr ""
"Du kan skapa egna :class:`local`-objekt genom att underklassa :class:`local`-"
"klassen::"

msgid ""
">>> class MyLocal(local):\n"
"...     number = 2\n"
"...     def __init__(self, /, **kw):\n"
"...         self.__dict__.update(kw)\n"
"...     def squared(self):\n"
"...         return self.number ** 2"
msgstr ""
">>> klass MyLocal(lokal):\n"
"... antal = 2\n"
"... def __init__(self, /, **kw):\n"
"... self.__dict__.update(kw)\n"
"... def squared(self):\n"
"... return self.number ** 2"

msgid ""
"This can be useful to support default values, methods and initialization.  "
"Note that if you define an :py:meth:`~object.__init__` method, it will be "
"called each time the :class:`local` object is used in a separate thread.  "
"This is necessary to initialize each thread's dictionary."
msgstr ""
"Detta kan vara användbart för att stödja standardvärden, metoder och "
"initialisering.  Observera att om du definierar en :py:meth:`~object."
"__init__`-metod kommer den att anropas varje gång :class:`local`-objektet "
"används i en separat tråd.  Detta är nödvändigt för att initiera varje tråds "
"dictionary."

msgid "Now if we create a :class:`local` object::"
msgstr "Om vi nu skapar ett :class:`local`-objekt::"

msgid ">>> mydata = MyLocal(color='red')"
msgstr ">>> mydata = MyLocal(färg='röd')"

msgid "we have a default number::"
msgstr "vi har ett standardnummer::"

msgid ""
">>> mydata.number\n"
"2"
msgstr ""
">>> mydata.nummer\n"
"2"

msgid "an initial color::"
msgstr "en initial färg::"

msgid ""
">>> mydata.color\n"
"'red'\n"
">>> del mydata.color"
msgstr ""
">>> mydata.färg\n"
"'röd'\n"
">>> del mydata.färg"

msgid "And a method that operates on the data::"
msgstr "Och en metod som fungerar på data::"

msgid ""
">>> mydata.squared()\n"
"4"
msgstr ""
">>> mydata.kvadrerad()\n"
"4"

msgid "As before, we can access the data in a separate thread::"
msgstr "Precis som tidigare kan vi komma åt data i en separat tråd::"

msgid ""
">>> log = []\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[('color', 'red')], 11]"
msgstr ""
">>> logg = []\n"
">>> tråd = threading.tråd(mål=f)\n"
">>> tråd.start()\n"
">>> tråd.join()\n"
">>> logg\n"
"[[('color', 'red')], 11]"

msgid "without affecting this thread's data::"
msgstr "utan att påverka den här trådens data::"

msgid ""
">>> mydata.number\n"
"2\n"
">>> mydata.color\n"
"Traceback (most recent call last):\n"
"...\n"
"AttributeError: 'MyLocal' object has no attribute 'color'"
msgstr ""
">>> mydata.nummer\n"
"2\n"
">>> mydata.färg\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"AttributeError: Objektet 'MyLocal' har inget attribut 'color'"

msgid ""
"Note that subclasses can define :term:`__slots__`, but they are not thread "
"local. They are shared across threads::"
msgstr ""
"Observera att underklasser kan definiera :term:`__slots__`, men de är inte "
"trådlokala. De delas mellan olika trådar::"

msgid ""
">>> class MyLocal(local):\n"
"...     __slots__ = 'number'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'red'"
msgstr ""
">>> klass MyLocal(lokal):\n"
"...     __slots__ = 'antal'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'röd'"

msgid "So, the separate thread::"
msgstr "Så, den separata tråden::"

msgid ""
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()"
msgstr ""
">>> tråd = threading.tråd(mål=f)\n"
">>> tråd.start()\n"
">>> tråd.join()"

msgid "affects what we see::"
msgstr "påverkar vad vi ser::"

msgid ""
">>> mydata.number\n"
"11"
msgstr ""
">>> mydata.nummer\n"
"11"

msgid "A class that represents thread-local data."
msgstr "En klass som representerar trådlokala data."

msgid "Thread objects"
msgstr "Trådobjekt"

msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the "
"``__init__()`` and :meth:`~Thread.run` methods of this class."
msgstr ""
"Klassen :class:`Thread` representerar en aktivitet som körs i en separat "
"kontrolltråd.  Det finns två sätt att specificera aktiviteten: genom att "
"skicka ett anropsbart objekt till konstruktören eller genom att åsidosätta "
"metoden :meth:`~Thread.run` i en subklass.  Inga andra metoder (förutom "
"konstruktören) bör åsidosättas i en subklass.  Med andra ord, *endast* "
"åsidosätt metoderna ``__init__()`` och :meth:`~Thread.run` i denna klass."

msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"När ett trådobjekt har skapats måste dess aktivitet startas genom att anropa "
"trådens metod :meth:`~Thread.start`.  Detta anropar metoden :meth:`~Thread."
"run` i en separat kontrolltråd."

msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"När trådens aktivitet har startat anses tråden vara \"levande\". Den slutar "
"att vara levande när dess :meth:`~Thread.run`-metod avslutas -- antingen "
"normalt eller genom att ett ohanterat undantag uppstår.  Metoden :meth:"
"`~Thread.is_alive` testar om tråden är vid liv."

msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"Andra trådar kan anropa en tråds :meth:`~Thread.join`-metod.  Detta "
"blockerar den anropande tråden tills den tråd vars :meth:`~Thread.join`-"
"metod anropas har avslutats."

msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""
"En tråd har ett namn.  Namnet kan skickas till konstruktören och läsas eller "
"ändras genom attributet :attr:`~Thread.name`."

msgid ""
"If the :meth:`~Thread.run` method raises an exception, :func:`threading."
"excepthook` is called to handle it. By default, :func:`threading.excepthook` "
"ignores silently :exc:`SystemExit`."
msgstr ""
"Om metoden :meth:`~Thread.run` ger upphov till ett undantag anropas :func:"
"`threading.excepthook` för att hantera det. Som standard ignorerar :func:"
"`threading.excepthook` tyst :exc:`SystemExit`."

msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"En tråd kan flaggas som en \"daemon-tråd\".  Betydelsen av denna flagga är "
"att hela Python-programmet avslutas när det bara finns daemon-trådar kvar.  "
"Det initiala värdet ärvs från den skapande tråden.  Flaggan kan sättas genom "
"egenskapen :attr:`~Thread.daemon` eller konstruktörsargumentet *daemon*."

msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"Daemon-trådar stoppas plötsligt vid nedstängning.  Deras resurser (t.ex. "
"öppna filer, databastransaktioner etc.) kanske inte frigörs på rätt sätt. Om "
"du vill att dina trådar ska sluta på ett elegant sätt, gör dem inte till "
"daemoner och använd en lämplig signalmekanism, t.ex. en :class:`Event`."

msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"Det finns ett \"main thread\"-objekt; detta motsvarar den första "
"kontrolltråden i Python-programmet.  Det är inte en daemon-tråd."

msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :ref:`joined <meth-thread-join>`.  They "
"are never deleted, since it is impossible to detect the termination of alien "
"threads."
msgstr ""
"Det finns en möjlighet att \"dummy thread objects\" skapas. Detta är "
"trådobjekt som motsvarar \"främmande trådar\", dvs. kontrolltrådar som "
"startas utanför trådningsmodulen, t.ex. direkt från C-kod.  Dummy thread-"
"objekt har begränsad funktionalitet; de betraktas alltid som levande och "
"daemoniska, och kan inte :ref:`joined <meth-thread-join>`.  De raderas "
"aldrig, eftersom det är omöjligt att upptäcka att främmande trådar har "
"avslutats."

msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"Denna konstruktor ska alltid anropas med nyckelordsargument.  Argumenten är:"

msgid ""
"*group* should be ``None``; reserved for future extension when a :class:`!"
"ThreadGroup` class is implemented."
msgstr ""
"*group* bör vara ``None``; reserverad för framtida tillägg när en :class:`!"
"ThreadGroup`-klass implementeras."

msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* är det anropsbara objekt som ska anropas av metoden :meth:`run`. "
"Standardvärdet är ``None``, vilket innebär att ingenting anropas."

msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*name* är trådens namn. Som standard konstrueras ett unikt namn av formen "
"\"Thread-*N*\" där *N* är ett litet decimaltal, eller \"Thread-*N* "
"(target)\" där \"target\" är ``target.__name__`` om argumentet *target* "
"anges."

msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr ""
"*args* är en lista eller tupel av argument för målanropet.  Standardvärdet "
"är ``()``."

msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* är en ordbok med nyckelordsargument för målanropet. Standardvärdet "
"är ``{}``."

msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""
"Om inte ``None``, anger *daemon* explicit om tråden är daemonisk. Om "
"``None`` (standard) ärvs daemonic-egenskapen från den aktuella tråden."

msgid ""
"*context* is the :class:`~contextvars.Context` value to use when starting "
"the thread.  The default value is ``None`` which indicates that the :data:"
"`sys.flags.thread_inherit_context` flag controls the behaviour.  If the flag "
"is true, threads will start with a copy of the context of the caller of :"
"meth:`~Thread.start`.  If false, they will start with an empty context.  To "
"explicitly start with an empty context, pass a new instance of :class:"
"`~contextvars.Context()`.  To explicitly start with a copy of the current "
"context, pass the value from :func:`~contextvars.copy_context`. The flag "
"defaults true on free-threaded builds and false otherwise."
msgstr ""
"*context* är :class:`~contextvars.Context`-värdet som ska användas när "
"tråden startas.  Standardvärdet är ``None`` vilket indikerar att :data:`sys."
"flags.thread_inherit_context`-flaggan styr beteendet.  Om flaggan är true "
"kommer trådar att starta med en kopia av kontexten för den som anropar :meth:"
"`~Thread.start`.  Om den är false startar de med en tom kontext.  För att "
"uttryckligen starta med en tom kontext, skicka en ny instans av :class:"
"`~contextvars.Context()`.  För att uttryckligen starta med en kopia av den "
"aktuella kontexten, skicka värdet från :func:`~contextvars.copy_context`. "
"Flaggan är som standard true på free-threaded builds och false annars."

msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"Om subklassen åsidosätter konstruktorn måste den se till att anropa "
"basklassens konstruktor (``Thread.__init__()``) innan den gör något annat "
"med tråden."

msgid "Added the *daemon* parameter."
msgstr "Parametern *daemon* har lagts till."

msgid "Use the *target* name if *name* argument is omitted."
msgstr "Använd *target*-namnet om *name*-argumentet utelämnas."

msgid "Added the *context* parameter."
msgstr "Parametern *context* har lagts till."

msgid "Start the thread's activity."
msgstr "Starta trådens aktivitet."

msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"Den får anropas högst en gång per trådobjekt.  Den ordnar så att objektets :"
"meth:`~Thread.run`-metod anropas i en separat kontrolltråd."

msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"Denna metod kommer att ge upphov till ett :exc:`RuntimeError` om den anropas "
"mer än en gång på samma trådobjekt."

msgid ""
"If supported, set the operating system thread name to :attr:`threading."
"Thread.name`. The name can be truncated depending on the operating system "
"thread name limits."
msgstr ""
"Om det stöds, ange operativsystemets trådnamn till :attr:`threading.Thread."
"name`. Namnet kan avkortas beroende på operativsystemets begränsningar för "
"trådnamn."

msgid "Set the operating system thread name."
msgstr "Ställ in operativsystemets trådnamn."

msgid "Method representing the thread's activity."
msgstr "Metod som representerar trådens aktivitet."

msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"Du kan åsidosätta denna metod i en subklass.  Standardmetoden :meth:`run` "
"anropar det anropsbara objekt som skickats till objektets konstruktör som "
"*target*-argument, om något, med positions- och nyckelordsargument som "
"hämtas från *args*- respektive *kwargs*-argumenten."

msgid ""
"Using list or tuple as the *args* argument which passed to the :class:"
"`Thread` could achieve the same effect."
msgstr ""
"Om man använder list eller tuple som *args*-argument som skickas till :class:"
"`Thread` kan man uppnå samma effekt."

msgid "Example::"
msgstr "Exempel::"

msgid ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"
msgstr ""
">>> from threading import Tråd\n"
">>> t = Tråd(mål=utskrift, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Tråd(mål=utskrift, args=(1,))\n"
">>> t.run()\n"
"1"

msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"Vänta tills tråden avslutas. Detta blockerar den anropande tråden tills den "
"tråd vars :meth:`~Thread.join`-metod anropas avslutas -- antingen normalt "
"eller genom ett ohanterat undantag -- eller tills den valfria timeouten "
"inträffar."

msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""
"När argumentet *timeout* finns med och inte ``None``, ska det vara ett "
"flyttal som anger en tidsgräns för operationen i sekunder (eller bråkdelar "
"därav). Eftersom :meth:`~Thread.join` alltid returnerar ``None`` måste du "
"anropa :meth:`~Thread.is_alive` efter :meth:`~Thread.join` för att avgöra om "
"en timeout inträffat -- om tråden fortfarande är vid liv har anropet av :"
"meth:`~Thread.join` tidsavgränsats."

msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"Om argumentet *timeout* inte finns med eller om det är ``None``, blockeras "
"åtgärden tills tråden avslutas."

msgid "A thread can be joined many times."
msgstr "En tråd kan anslutas många gånger."

msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` ger upphov till ett :exc:`RuntimeError` om ett försök "
"görs att ansluta till den aktuella tråden eftersom det skulle orsaka ett "
"dödläge. Det är också ett fel att :meth:`~Thread.join` en tråd innan den har "
"startats och försök att göra det ger upphov till samma undantag."

msgid ""
"If an attempt is made to join a running daemonic thread in late stages of :"
"term:`Python finalization <interpreter shutdown>` :meth:`!join` raises a :"
"exc:`PythonFinalizationError`."
msgstr ""
"Om ett försök görs att ansluta till en pågående daemonisk tråd i ett sent "
"skede av :term:`Python finalization <interpreter shutdown>` ger :meth:`!"
"join` upphov till ett :exc:`PythonFinalizationError`."

msgid "May raise :exc:`PythonFinalizationError`."
msgstr "Kan ge upphov till :exc:`PythonFinalizationError`."

msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"En sträng som endast används för identifieringsändamål. Den har ingen "
"semantik. Flera trådar kan ges samma namn.  Det initiala namnet sätts av "
"konstruktören."

msgid ""
"On some platforms, the thread name is set at the operating system level when "
"the thread starts, so that it is visible in task managers. This name may be "
"truncated to fit in a system-specific limit (for example, 15 bytes on Linux "
"or 63 bytes on macOS)."
msgstr ""
"På vissa plattformar anges trådnamnet på operativsystemsnivå när tråden "
"startar, så att det syns i aktivitetshanterare. Namnet kan trunkeras för att "
"rymmas inom en systemspecifik gräns (t.ex. 15 byte på Linux eller 63 byte på "
"macOS)."

msgid ""
"Changes to *name* are only reflected at the OS level when the currently "
"running thread is renamed. (Setting the *name* attribute of a different "
"thread only updates the Python Thread object.)"
msgstr ""
"Ändringar av *name* återspeglas endast på OS-nivå när den tråd som körs för "
"tillfället byter namn. (Att ställa in *name*-attributet för en annan tråd "
"uppdaterar bara Python Thread-objektet)"

msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
"Föråldrat getter/setter API för :attr:`~Thread.name`; använd det direkt som "
"en egenskap istället."

msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"Trådidentifieraren för denna tråd eller ``None`` om tråden inte har "
"startats.  Detta är ett heltal som inte är noll.  Se funktionen :func:"
"`get_ident`.  Trådidentifierare kan återanvändas när en tråd avslutas och en "
"ny tråd skapas.  Identifieraren är tillgänglig även efter att tråden har "
"avslutats."

msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This "
"is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Tråd-ID (``TID``) för denna tråd, som tilldelats av operativsystemet "
"(kärnan). Detta är ett icke-negativt heltal, eller ``None`` om tråden inte "
"har startats. Se funktionen :func:`get_native_id`. Detta värde kan användas "
"för att unikt identifiera just denna tråd i hela systemet (tills tråden "
"avslutas, varefter värdet kan återanvändas av operativsystemet)."

msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr ""
"I likhet med process-ID:n är tråd-ID:n endast giltiga (garanterat unika i "
"hela systemet) från det att tråden skapas till dess att tråden har avslutats."

msgid "Return whether the thread is alive."
msgstr "Returnerar om tråden är vid liv."

msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"Denna metod returnerar ``True`` precis innan metoden :meth:`~Thread.run` "
"startar till precis efter att metoden :meth:`~Thread.run` avslutas.  "
"Modulfunktionen :func:`.enumerate` returnerar en lista över alla levande "
"trådar."

msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``) "
"or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to :attr:"
"`~Thread.daemon` = ``False``."
msgstr ""
"Ett booleskt värde som anger om denna tråd är en daemon-tråd (``True``) "
"eller inte (``False``).  Detta måste anges innan :meth:`~Thread.start` "
"anropas, annars kommer :exc:`RuntimeError` att aktiveras.  Dess initiala "
"värde ärvs från den tråd som skapar den; huvudtråden är inte en daemon-tråd "
"och därför har alla trådar som skapas i huvudtråden som standard :attr:"
"`~Thread.daemon` = ``False``."

msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"Hela Python-programmet avslutas när inga levande icke-daemon-trådar finns "
"kvar."

msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr ""
"Föråldrad getter/setter API för :attr:`~Thread.daemon`; använd den direkt "
"som en egenskap istället."

msgid "Lock objects"
msgstr "Lås objekt"

msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"Ett primitivt lås är en synkroniseringsprimitiv som inte ägs av en viss tråd "
"när den är låst.  I Python är det för närvarande den lägsta tillgängliga "
"synkroniseringsprimitiven, som implementeras direkt av tilläggsmodulen :mod:"
"`_thread`."

msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"Ett primitivt lås är i ett av två tillstånd, \"låst\" eller \"olåst\". Det "
"skapas i det olåsta tillståndet.  Det har två grundläggande metoder, :meth:"
"`~Lock.acquire` och :meth:`~Lock.release`.  När tillståndet är upplåst "
"ändrar :meth:`~Lock.acquire` tillståndet till locked och återgår "
"omedelbart.  När tillståndet är locked blockerar :meth:`~Lock.acquire` tills "
"ett anrop till :meth:`~Lock.release` i en annan tråd ändrar det till "
"unlocked, då återställer anropet till :meth:`~Lock.acquire` det till locked "
"och returnerar.  Metoden :meth:`~Lock.release` bör endast anropas i låst "
"tillstånd; den ändrar tillståndet till olåst och returnerar omedelbart. Om "
"ett försök görs att frigöra ett olåst lås, kommer ett :exc:`RuntimeError` "
"att uppstå."

msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr "Lås stöder också :ref:``context management protocol <with-locks>``."

msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""
"När mer än en tråd är blockerad i :meth:`~Lock.acquire` i väntan på att "
"tillståndet ska övergå till olåst, fortsätter endast en tråd när ett anrop "
"av :meth:`~Lock.release` återställer tillståndet till olåst; vilken av de "
"väntande trådarna som fortsätter är inte definierat och kan variera mellan "
"olika implementationer."

msgid "All methods are executed atomically."
msgstr "Alla metoder utförs atomiskt."

msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"Klassen som implementerar primitiva låsobjekt.  När en tråd har förvärvat "
"ett lås blockeras efterföljande försök att förvärva det tills det släpps; "
"vilken tråd som helst kan släppa det."

msgid ""
"``Lock`` is now a class. In earlier Pythons, ``Lock`` was a factory function "
"which returned an instance of the underlying private lock type."
msgstr ""
"``Lock`` är nu en klass. I tidigare Pythons var ``Lock`` en fabriksfunktion "
"som returnerade en instans av den underliggande privata låstypen."

msgid "Acquire a lock, blocking or non-blocking."
msgstr "Förvärva ett lås, blockerande eller icke-blockerande."

msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"När den anropas med argumentet *blocking* satt till ``True`` (standard), "
"blockeras den tills låset låses upp, sedan sätts den till locked och "
"returnerar ``True``."

msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"Blockera inte när anropet görs med argumentet *blocking* satt till "
"``False``. Om ett anrop med *blocking* satt till ``True`` skulle blockera, "
"returnera ``False`` omedelbart; i annat fall, sätt låset till locked och "
"returnera ``True``."

msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"När *timeout* anropas med ett positivt värde för argumentet med flyttal, "
"blockeras blockeringen i högst det antal sekunder som anges av *timeout* och "
"så länge som låset inte kan förvärvas.  Ett *timeout*-argument på ``-1`` "
"anger en obegränsad väntan.  Det är förbjudet att ange en *timeout* när "
"*blocking* är ``False``."

msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""
"Returvärdet är ``True`` om låset har förvärvats framgångsrikt, ``False`` om "
"inte (t.ex. om *timeout* har löpt ut)."

msgid "The *timeout* parameter is new."
msgstr "Parametern *timeout* är ny."

msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""
"Låsinhämtning kan nu avbrytas av signaler på POSIX om den underliggande "
"trådningsimplementationen stöder det."

msgid "Lock acquisition can now be interrupted by signals on Windows."
msgstr "Låsinhämtning kan nu avbrytas av signaler i Windows."

msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""
"Frigör ett lås.  Detta kan anropas från vilken tråd som helst, inte bara "
"från den tråd som har förvärvat låset."

msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"När låset är låst återställer du det till olåst och återvänder.  Om några "
"andra trådar är blockerade i väntan på att låset ska låsas upp, tillåter du "
"att exakt en av dem fortsätter."

msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "När den anropas på ett olåst lås uppstår ett :exc:`RuntimeError`."

msgid "There is no return value."
msgstr "Det finns inget returvärde."

msgid "Return ``True`` if the lock is acquired."
msgstr "Returnerar ``True`` om låset är förvärvat."

msgid "RLock objects"
msgstr "RLock-objekt"

msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"Ett reentrant lås är en synkroniseringsprimitiv som kan förvärvas flera "
"gånger av samma tråd.  Internt använder det koncepten \"ägande tråd\" och "
"\"rekursionsnivå\" utöver det låsta/olåsta tillstånd som används av "
"primitiva lås.  I låst tillstånd äger någon tråd låset; i olåst tillstånd "
"äger ingen tråd det."

msgid ""
"Threads call a lock's :meth:`~RLock.acquire` method to lock it, and its :"
"meth:`~Lock.release` method to unlock it."
msgstr ""
"Trådar anropar ett lås :meth:`~RLock.acquire`-metod för att låsa det, och "
"dess :meth:`~Lock.release`-metod för att låsa upp det."

msgid ""
"Reentrant locks support the :ref:`context management protocol <with-locks>`, "
"so it is recommended to use :keyword:`with` instead of manually calling :"
"meth:`~RLock.acquire` and :meth:`~RLock.release` to handle acquiring and "
"releasing the lock for a block of code."
msgstr ""
"Reentranta lås stöder :ref:`context management protocol <with-locks>`, så "
"det rekommenderas att använda :keyword:`with` istället för att manuellt "
"anropa :meth:`~RLock.acquire` och :meth:`~RLock.release` för att hantera "
"förvärv och frigörande av låset för ett kodblock."

msgid ""
"RLock's :meth:`~RLock.acquire`/:meth:`~RLock.release` call pairs may be "
"nested, unlike Lock's :meth:`~Lock.acquire`/:meth:`~Lock.release`. Only the "
"final :meth:`~RLock.release` (the :meth:`~Lock.release` of the outermost "
"pair) resets the lock to an unlocked state and allows another thread blocked "
"in :meth:`~RLock.acquire` to proceed."
msgstr ""
"RLocks anropspar :meth:`~RLock.acquire`/:meth:`~RLock.release` kan vara "
"nästlade, till skillnad från Locks :meth:`~Lock.acquire`/:meth:`~Lock."
"release`. Endast det sista :meth:`~RLock.release` (det yttersta parets :meth:"
"`~Lock.release`) återställer låset till ett olåst tillstånd och tillåter en "
"annan tråd som blockerats i :meth:`~RLock.acquire` att fortsätta."

msgid ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` must be used in pairs: each "
"acquire must have a release in the thread that has acquired the lock. "
"Failing to call release as many times the lock has been acquired can lead to "
"deadlock."
msgstr ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` måste användas i par: varje "
"acquire måste ha en release i den tråd som har förvärvat låset. Om man inte "
"anropar release lika många gånger som låset har förvärvats kan det leda till "
"dödläge."

msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"Denna klass implementerar objekt med återkommande lås.  Ett reentrant lås "
"måste släppas av den tråd som förvärvade det.  När en tråd har förvärvat ett "
"reentrant lås kan samma tråd förvärva det igen utan att blockera; tråden "
"måste släppa det en gång för varje gång den har förvärvat det."

msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""
"Observera att ``RLock`` faktiskt är en fabriksfunktion som returnerar en "
"instans av den mest effektiva versionen av den konkreta RLock-klassen som "
"stöds av plattformen."

msgid ":ref:`Using RLock as a context manager <with-locks>`"
msgstr ":ref:`Användning av RLock som kontexthanterare <with-locks>`"

msgid ""
"Recommended over manual :meth:`!acquire` and :meth:`release` calls whenever "
"practical."
msgstr ""
"Rekommenderas framför manuella :meth:`!acquire`- och :meth:`release`-anrop "
"när det är praktiskt möjligt."

msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default):"
msgstr ""
"När den anropas med argumentet *blocking* inställt på ``True`` (standard):"

msgid "If no thread owns the lock, acquire the lock and return immediately."
msgstr ""
"Om ingen tråd äger låset, förvärvar du låset och återvänder omedelbart."

msgid ""
"If another thread owns the lock, block until we are able to acquire lock, or "
"*timeout*, if set to a positive float value."
msgstr ""
"Om en annan tråd äger låset blockeras det tills vi kan förvärva låset eller "
"*timeout*, om det är inställt på ett positivt floatvärde."

msgid ""
"If the same thread owns the lock, acquire the lock again, and return "
"immediately. This is the difference between :class:`Lock` and :class:`!"
"RLock`; :class:`Lock` handles this case the same as the previous, blocking "
"until the lock can be acquired."
msgstr ""
"Om samma tråd äger låset, förvärvar du låset igen och återvänder omedelbart. "
"Detta är skillnaden mellan :class:`Lock` och :class:`!RLock`; :class:`Lock` "
"hanterar detta fall på samma sätt som det föregående och blockerar tills "
"låset kan förvärvas."

msgid "When invoked with the *blocking* argument set to ``False``:"
msgstr "När den anropas med argumentet *blocking* satt till ``False``:"

msgid "If another thread owns the lock, return immediately."
msgstr "Om en annan tråd äger låset, returnera omedelbart."

msgid ""
"If the same thread owns the lock, acquire the lock again and return "
"immediately."
msgstr ""
"Om samma tråd äger låset, förvärvar du låset igen och återvänder omedelbart."

msgid ""
"In all cases, if the thread was able to acquire the lock, return ``True``. "
"If the thread was unable to acquire the lock (i.e. if not blocking or the "
"timeout was reached) return ``False``."
msgstr ""
"I samtliga fall, om tråden kunde förvärva låset, returneras ``True``. Om "
"tråden inte kunde förvärva låset (d.v.s. om den inte blockerade eller om "
"timeouten uppnåddes) returneras ``False``."

msgid ""
"If called multiple times, failing to call :meth:`~RLock.release` as many "
"times may lead to deadlock. Consider using :class:`!RLock` as a context "
"manager rather than calling acquire/release directly."
msgstr ""
"Om den anropas flera gånger kan det leda till dödläge om inte :meth:`~RLock."
"release` anropas lika många gånger. Överväg att använda :class:`!RLock` som "
"en kontexthanterare istället för att anropa acquire/release direkt."

msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"Frigör ett lås och dekrementera rekursionsnivån.  Om den efter "
"dekrementeringen är noll, återställ låset till olåst (ägs inte av någon "
"tråd), och om några andra trådar är blockerade i väntan på att låset ska bli "
"olåst, låt exakt en av dem fortsätta.  Om rekursionsnivån fortfarande inte "
"är noll efter dekrementeringen förblir låset låst och ägs av den anropande "
"tråden."

msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is not "
"acquired."
msgstr ""
"Anropa endast denna metod när den anropande tråden äger låset. Ett :exc:"
"`RuntimeError` uppstår om denna metod anropas när låset inte är förvärvat."

msgid "Return a boolean indicating whether this object is locked right now."
msgstr "Returnerar en boolean som anger om detta objekt är låst just nu."

msgid "Condition objects"
msgstr "Konditionera objekt"

msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""
"En villkorsvariabel är alltid associerad med någon form av lås; detta kan "
"anges eller så skapas ett som standard.  Att skicka in ett lås är användbart "
"när flera villkorsvariabler måste dela på samma lås.  Låset är en del av "
"villkorsobjektet: du behöver inte spåra det separat."

msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""
"En villkorsvariabel följer :ref:`context management protocol <with-locks>`: "
"genom att använda ``with``-satsen förvärvas det associerade låset under hela "
"det inneslutna blocket.  Metoderna :meth:`~Condition.acquire` och :meth:"
"`~Condition.release` anropar också motsvarande metoder för det associerade "
"låset."

msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""
"Andra metoder måste anropas med det associerade låset kvar.  Metoden :meth:"
"`~Condition.wait` frigör låset och blockerar sedan tills en annan tråd "
"väcker det genom att anropa :meth:`~Condition.notify` eller :meth:"
"`~Condition.notify_all`.  När den har väckts återtar :meth:`~Condition.wait` "
"låset och återgår.  Det är också möjligt att ange en timeout."

msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""
"Metoden :meth:`~Condition.notify` väcker en av de trådar som väntar på "
"villkorsvariabeln, om det finns några som väntar.  Metoden :meth:`~Condition."
"notify_all` väcker alla trådar som väntar på villkorsvariabeln."

msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"Observera: metoderna :meth:`~Condition.notify` och :meth:`~Condition."
"notify_all` frigör inte låset; detta innebär att den tråd eller de trådar "
"som väcks inte kommer att återvända från sitt anrop av :meth:`~Condition."
"wait` omedelbart, utan först när den tråd som anropade :meth:`~Condition."
"notify` eller :meth:`~Condition.notify_all` slutligen släpper äganderätten "
"till låset."

msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""
"Den typiska programmeringsstilen som använder villkorsvariabler använder "
"låset för att synkronisera åtkomst till ett delat tillstånd; trådar som är "
"intresserade av en viss förändring av tillståndet anropar :meth:`~Condition."
"wait` upprepade gånger tills de ser det önskade tillståndet, medan trådar "
"som ändrar tillståndet anropar :meth:`~Condition.notify` eller :meth:"
"`~Condition.notify_all` när de ändrar tillståndet på ett sådant sätt att det "
"möjligen kan vara ett önskat tillstånd för en av de väntande.  Följande kod "
"är till exempel en generisk producent-konsument-situation med obegränsad "
"buffertkapacitet::"

msgid ""
"# Consume one item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produce one item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"
msgstr ""
"# Konsumera ett föremål\n"
"med cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    hämta_ett_tillgängligt_objekt()\n"
"\n"
"# Producera ett objekt\n"
"med cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"

msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"``while``-loopen som kontrollerar applikationens villkor är nödvändig "
"eftersom :meth:`~Condition.wait` kan returneras efter godtyckligt lång tid "
"och det villkor som föranledde :meth:`~Condition.notify`-anropet kanske inte "
"längre är sant.  Detta är inbyggt i programmering med flera trådar.  "
"Metoden :meth:`~Condition.wait_for` kan användas för att automatisera "
"villkorskontrollen och underlättar beräkningen av timeouts::"

msgid ""
"# Consume an item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"
msgstr ""
"# Konsumera ett föremål\n"
"med cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    hämta_ett_tillgängligt_objekt()"

msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""
"För att välja mellan :meth:`~Condition.notify` och :meth:`~Condition."
"notify_all` bör du överväga om en tillståndsändring kan vara intressant för "
"endast en eller flera väntande trådar.  I en typisk producent-konsument-"
"situation behöver t.ex. en konsumenttråd bara väckas om ett objekt läggs "
"till i bufferten."

msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""
"Denna klass implementerar objekt för villkorsvariabler.  En villkorsvariabel "
"tillåter en eller flera trådar att vänta tills de får ett meddelande från en "
"annan tråd."

msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"Om argumentet *lock* anges och inte ``None``, måste det vara ett :class:"
"`Lock`- eller :class:`RLock`-objekt, och det används som underliggande lås.  "
"Annars skapas ett nytt :class:`RLock`-objekt som används som det "
"underliggande låset."

msgid "changed from a factory function to a class."
msgstr "ändrades från en fabriksfunktion till en klass."

msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"Förvärva det underliggande låset. Denna metod anropar motsvarande metod på "
"det underliggande låset; returvärdet är vad den metoden returnerar."

msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"Frigör det underliggande låset. Denna metod anropar motsvarande metod på det "
"underliggande låset; det finns inget returvärde."

msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"Vänta tills du blir meddelad eller tills en timeout inträffar. Om den "
"anropande tråden inte har förvärvat låset när denna metod anropas, kommer "
"ett :exc:`RuntimeError` att uppstå."

msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"Denna metod frigör det underliggande låset och blockerar sedan tills den "
"väcks av ett :meth:`notify`- eller :meth:`notify_all`-anrop för samma "
"tillståndsvariabel i en annan tråd, eller tills den valfria timeouten "
"inträffar.  När den har väckts eller fått timeout återtar den låset och "
"återvänder."

msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"När argumentet *timeout* finns med och inte ``None``, ska det vara ett "
"flyttal som anger en tidsgräns för operationen i sekunder (eller bråkdelar "
"därav)."

msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"När det underliggande låset är ett :class:`RLock` frigörs det inte med hjälp "
"av dess :meth:`release`-metod, eftersom detta kanske inte låser upp låset "
"när det har förvärvats flera gånger rekursivt.  Istället används ett internt "
"gränssnitt för klassen :class:`RLock`, som verkligen låser upp det även om "
"det har förvärvats rekursivt flera gånger. Ett annat internt gränssnitt "
"används sedan för att återställa rekursionsnivån när låset förvärvas på nytt."

msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""
"Returvärdet är ``True`` om inte en given *timeout* har löpt ut, i vilket "
"fall det är ``False``."

msgid "Previously, the method always returned ``None``."
msgstr "Tidigare returnerade metoden alltid ``None``."

msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"Vänta tills ett villkor utvärderas till sant.  *predicate* ska vara en "
"callable vars resultat kommer att tolkas som ett booleskt värde. En "
"*timeout* kan anges som ger den maximala tiden att vänta."

msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"Denna verktygsmetod kan anropa :meth:`wait` upprepade gånger tills "
"predikatet är uppfyllt eller tills en timeout inträffar. Returvärdet är det "
"sista returvärdet för predikatet och kommer att utvärderas till ``False`` om "
"metoden tidsavbröts."

msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""
"Om man bortser från timeout-funktionen motsvarar anrop av denna metod "
"ungefär att skriva::"

msgid ""
"while not predicate():\n"
"    cv.wait()"
msgstr ""
"while not predicate():\n"
"    cv.vänta()"

msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"Därför gäller samma regler som för :meth:`wait`: Låset måste hållas när det "
"anropas och återfås när det returneras.  Predikatet utvärderas med låset "
"kvar."

msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Som standard väcks en tråd som väntar på detta villkor, om det finns någon.  "
"Om den anropande tråden inte har förvärvat låset när denna metod anropas, "
"kommer ett :exc:`RuntimeError` att uppstå."

msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"Den här metoden väcker högst *n* av de trådar som väntar på "
"villkorvariabeln; den är ingen operation om inga trådar väntar."

msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"Den nuvarande implementationen väcker exakt *n* trådar om minst *n* trådar "
"väntar.  Det är dock inte säkert att förlita sig på detta beteende. En "
"framtida, optimerad implementering kan ibland väcka fler än *n* trådar."

msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"Notera: en väckt tråd återvänder inte från sitt :meth:`wait`-anrop förrän "
"den kan återta låset.  Eftersom :meth:`notify` inte släpper låset, bör dess "
"anropare göra det."

msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Väck alla trådar som väntar på detta villkor.  Denna metod fungerar som :"
"meth:`notify`, men väcker alla väntande trådar istället för en. Om den "
"anropande tråden inte har förvärvat låset när denna metod anropas, kommer "
"ett :exc:`RuntimeError` att uppstå."

msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "Metoden ``notifyAll`` är ett föråldrat alias för denna metod."

msgid "Semaphore objects"
msgstr "Semaför-objekt"

msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"Detta är en av de äldsta synkroniseringsprimitiverna i datavetenskapens "
"historia, uppfunnen av den tidiga holländska datavetaren Edsger W. Dijkstra "
"(han använde namnen ``P()`` och ``V()`` istället för :meth:`~Semaphore."
"acquire` och :meth:`~Semaphore.release`)."

msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""
"En semafor hanterar en intern räknare som decimeras vid varje anrop av :meth:"
"`~Semaphore.acquire` och ökas vid varje anrop av :meth:`~Semaphore."
"release`.  Räknaren kan aldrig gå under noll; när :meth:`~Semaphore.acquire` "
"upptäcker att den är noll blockerar den och väntar tills någon annan tråd "
"anropar :meth:`~Semaphore.release`."

msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Semaforer stöder också :ref:``context management protocol <with-locks>``."

msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""
"Denna klass implementerar semaforobjekt.  En semafor hanterar en atomisk "
"räknare som representerar antalet :meth:`release`-anrop minus antalet :meth:"
"`acquire`-anrop, plus ett initialt värde.  Metoden :meth:`acquire` blockerar "
"om det behövs tills den kan återvända utan att räknaren blir negativ. Om "
"*value* inte anges är standardvärdet 1."

msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""
"Det valfria argumentet anger det initiala *värdet* för den interna räknaren; "
"standardvärdet är ``1``. Om det angivna *värdet* är mindre än 0, uppstår :"
"exc:`ValueError`."

msgid "Acquire a semaphore."
msgstr "Förvärva en semafor."

msgid "When invoked without arguments:"
msgstr "När den anropas utan argument:"

msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""
"Om den interna räknaren är större än noll vid inmatningen, dekrementera den "
"med ett och returnera ``True`` omedelbart."

msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"Om den interna räknaren är noll vid inmatningen, blockera tills den väcks "
"genom ett anrop till :meth:`~Semaphore.release`.  När du har väckts (och "
"räknaren är större än 0), dekrementera räknaren med 1 och returnera "
"``True``.  Exakt en tråd kommer att väckas vid varje anrop till :meth:"
"`~Semaphore.release`.  Ordningen i vilken trådarna väcks bör inte förlitas "
"på."

msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do "
"the same thing as when called without arguments, and return ``True``."
msgstr ""
"Blockera inte när den anropas med *blocking* satt till ``False``.  Om ett "
"anrop utan argument skulle blockera, returnera ``False`` omedelbart; i annat "
"fall, gör samma sak som vid anrop utan argument och returnera ``True``."

msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"När den anropas med en *timeout* annan än ``None``, kommer den att blockera "
"i högst *timeout* sekunder.  Om förvärvet inte slutförs framgångsrikt inom "
"detta intervall returneras ``False``.  Returnera annars ``True``."

msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr ""
"Släpp en semafor och öka den interna räknaren med *n*.  När den var noll vid "
"inmatningen och andra trådar väntar på att den ska bli större än noll igen, "
"väcker du *n* av dessa trådar."

msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr ""
"Lagt till parametern *n* för att släppa flera väntande trådar samtidigt."

msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"Klass som implementerar begränsade semaforobjekt.  En bounded semaphore "
"kontrollerar att dess aktuella värde inte överstiger dess initiala värde.  "
"Om så är fallet, genereras :exc:`ValueError`. I de flesta situationer "
"används semaforer för att bevaka resurser med begränsad kapacitet.  Om "
"semaforen släpps för många gånger är det ett tecken på en bugg.  Om *värde* "
"inte anges är standardvärdet 1."

msgid ":class:`Semaphore` example"
msgstr ":class:`Semaphore` exempel"

msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"Semaforer används ofta för att bevaka resurser med begränsad kapacitet, t."
"ex. en databasserver.  I alla situationer där resursens storlek är fast bör "
"du använda en begränsad semafor.  Innan du skapar några arbetstrådar skulle "
"din huvudtråd initiera semaforen::"

msgid ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"
msgstr ""
"maxanslutningar = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(värde=maxconnections)"

msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"När de har skapats anropar arbetstrådarna semaforens metoder för att "
"förvärva och frigöra när de behöver ansluta till servern::"

msgid ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... use connection ...\n"
"    finally:\n"
"        conn.close()"
msgstr ""
"med pool_sema:\n"
"    conn = connectdb()\n"
"    försöker:\n"
"        # ... använd anslutning ...\n"
"    slutligen: # ..:\n"
"        conn.close()"

msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"Användningen av en begränsad semafor minskar risken för att ett "
"programmeringsfel som gör att semaforen släpps mer än den förvärvas inte "
"upptäcks."

msgid "Event objects"
msgstr "Händelseobjekt"

msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"Detta är en av de enklaste mekanismerna för kommunikation mellan trådar: en "
"tråd signalerar en händelse och andra trådar väntar på den."

msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"Ett eventobjekt hanterar en intern flagga som kan sättas till true med "
"metoden :meth:`~Event.set` och återställas till false med metoden :meth:"
"`~Event.clear`.  Metoden :meth:`~Event.wait` blockerar tills flaggan är sann."

msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""
"Klass som implementerar händelseobjekt.  En händelse hanterar en flagga som "
"kan sättas till true med metoden :meth:`~Event.set` och återställas till "
"false med metoden :meth:`clear`.  Metoden :meth:`wait` blockerar tills "
"flaggan är sann. Flaggan är initialt falsk."

msgid "Return ``True`` if and only if the internal flag is true."
msgstr "Returnerar ``True`` om och endast om den interna flaggan är sann."

msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "Metoden ``isSet`` är ett föråldrat alias för denna metod."

msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"Sätt den interna flaggan till true. Alla trådar som väntar på att den ska "
"bli sann väcks. Trådar som anropar :meth:`wait` när flaggan är true kommer "
"inte att blockera alls."

msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"Återställer den interna flaggan till false. Därefter kommer trådar som "
"anropar :meth:`wait` att blockeras tills :meth:`.set` anropas för att sätta "
"den interna flaggan till true igen."

msgid ""
"Block as long as the internal flag is false and the timeout, if given, has "
"not expired. The return value represents the reason that this blocking "
"method returned; ``True`` if returning because the internal flag is set to "
"true, or ``False`` if a timeout is given and the internal flag did not "
"become true within the given wait time."
msgstr ""
"Blockerar så länge som den interna flaggan är falsk och timeouten, om en "
"sådan har angetts, inte har löpt ut. Returvärdet representerar anledningen "
"till att denna blockeringsmetod returnerades; ``True`` om den returneras "
"eftersom den interna flaggan är satt till true, eller ``False`` om en "
"timeout ges och den interna flaggan inte blev true inom den givna väntetiden."

msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds, or "
"fractions thereof."
msgstr ""
"När timeout-argumentet finns och inte är ``None``, ska det vara ett flyttal "
"som anger en timeout för operationen i sekunder eller bråkdelar därav."

msgid "Timer objects"
msgstr "Timer-objekt"

msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"Den här klassen representerar en åtgärd som ska utföras först efter att en "
"viss tid har gått --- en timer. :class:`Timer` är en underklass till :class:"
"`Thread` och fungerar som sådan också som ett exempel på hur man skapar egna "
"trådar."

msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the timer "
"will wait before executing its action may not be exactly the same as the "
"interval specified by the user."
msgstr ""
"Timers startas, precis som trådar, genom att anropa deras metod :meth:`Timer."
"start <Thread.start>`.  Timern kan stoppas (innan dess åtgärd har påbörjats) "
"genom att anropa metoden :meth:`~Timer.cancel`.  Det intervall som timern "
"väntar på innan den utför sin åtgärd behöver inte vara exakt detsamma som "
"det intervall som anges av användaren."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # after 30 seconds, \"hello, world\" will be printed"
msgstr ""
"def hello():\n"
"    print(\"hej, världen\")\n"
"\n"
"t = Timer(30.0, hallå)\n"
"t.start() # efter 30 sekunder kommer \"hello, world\" att skrivas ut"

msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"Skapa en timer som kör *function* med argumenten *args* och "
"nyckelordsargumenten *kwargs*, efter att *interval* sekunder har passerat. "
"Om *args* är ``None`` (standard) kommer en tom lista att användas. Om "
"*kwargs* är ``None`` (standard) kommer en tom dict att användas."

msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"Stoppa timern och avbryt utförandet av timerns åtgärd.  Detta fungerar bara "
"om timern fortfarande befinner sig i vänteläge."

msgid "Barrier objects"
msgstr "Barriärobjekt"

msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"Denna klass tillhandahåller en enkel synkroniseringsprimitiv för användning "
"av ett fast antal trådar som behöver vänta på varandra.  Var och en av "
"trådarna försöker passera barriären genom att anropa metoden :meth:`~Barrier."
"wait` och blockerar tills alla trådar har gjort sina anrop till :meth:"
"`~Barrier.wait`. Vid denna punkt släpps trådarna samtidigt."

msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr ""
"Barriären kan återanvändas ett obegränsat antal gånger för samma antal "
"trådar."

msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""
"Som ett exempel följer här ett enkelt sätt att synkronisera en klient- och "
"servertråd::"

msgid ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"
msgstr ""
"b = Barriär(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        anslutning = acceptera_anslutning()\n"
"        process_server_connection(anslutning)\n"
"\n"
"def klient():\n"
"    b.wait()\n"
"    medan True:\n"
"        anslutning = make_connection()\n"
"        process_client_connection(anslutning)"

msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"Skapa ett barriärobjekt för *parties* antal trådar.  En *action*, när den "
"tillhandahålls, är en callable som ska anropas av en av trådarna när de "
"släpps.  *timeout* är standardvärdet för timeout om inget anges för metoden :"
"meth:`wait`."

msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"Passera barriären.  När alla trådar som är parter i barriären har anropat "
"denna funktion släpps de samtidigt.  Om en *timeout* anges används den i "
"stället för den som angavs i klassens konstruktor."

msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"Returvärdet är ett heltal i intervallet 0 till *parties* -- 1, olika för "
"varje tråd.  Detta kan användas för att välja en tråd för att göra några "
"speciella hushållsarbeten, t.ex.::"

msgid ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Only one thread needs to print this\n"
"    print(\"passed the barrier\")"
msgstr ""
"i = barriär.vänta()\n"
"if i == 0:\n"
"    # Endast en tråd behöver skriva ut detta\n"
"    print(\"passerade barriären\")"

msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"Om en *action* tillhandahölls till konstruktören kommer en av trådarna att "
"ha anropat den innan den släpps.  Om detta anrop ger upphov till ett fel, "
"försätts barriären i det brutna tillståndet."

msgid "If the call times out, the barrier is put into the broken state."
msgstr "Om anropet tidsbegränsas försätts barriären i ett trasigt tillstånd."

msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""
"Denna metod kan ge upphov till ett :class:`BrokenBarrierError` undantag om "
"barriären bryts eller återställs medan en tråd väntar."

msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Återställer barriären till det tomma standardtillståndet.  Alla trådar som "
"väntar på den kommer att få undantaget :class:`BrokenBarrierError`."

msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr ""
"Observera att denna funktion kan kräva viss extern synkronisering om det "
"finns andra trådar vars tillstånd är okänt.  Om en barriär bryts kan det "
"vara bättre att bara lämna den och skapa en ny."

msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"Sätter barriären i ett trasigt tillstånd.  Detta gör att alla aktiva eller "
"framtida anrop till :meth:`wait` misslyckas med :class:"
"`BrokenBarrierError`.  Använd detta till exempel om en av trådarna behöver "
"avbrytas för att undvika att applikationen låser sig."

msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"Det kan vara att föredra att helt enkelt skapa barriären med ett vettigt "
"*timeout*-värde för att automatiskt skydda sig mot att en av trådarna går "
"fel."

msgid "The number of threads required to pass the barrier."
msgstr "Det antal trådar som krävs för att passera barriären."

msgid "The number of threads currently waiting in the barrier."
msgstr "Antalet trådar som för närvarande väntar i barriären."

msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "En boolean som är ``True`` om barriären är i ett trasigt tillstånd."

msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Detta undantag, en underklass till :exc:`RuntimeError`, uppstår när "
"objektet :class:`Barrier` återställs eller bryts."

msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr "Använda lås, villkor och semaforer i :keyword:`!with`-satsen"

msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with` "
"statement.  The ``acquire`` method will be called when the block is entered, "
"and ``release`` will be called when the block is exited.  Hence, the "
"following snippet::"
msgstr ""
"Alla objekt som tillhandahålls av denna modul och som har metoderna "
"``acquire`` och ``release`` kan användas som kontexthanterare för en :"
"keyword:`with`-sats.  Metoden ``acquire`` kommer att anropas när blocket "
"skrivs in och ``release`` kommer att anropas när blocket skrivs ut.  Därav "
"följande utdrag::"

msgid ""
"with some_lock:\n"
"    # do something..."
msgstr ""
"med något_lås:\n"
"    # gör något..."

msgid "is equivalent to::"
msgstr "är likvärdig med::"

msgid ""
"some_lock.acquire()\n"
"try:\n"
"    # do something...\n"
"finally:\n"
"    some_lock.release()"
msgstr ""
"some_lock.acquire()\n"
"försök:\n"
"    # gör något...\n"
"slutligen:\n"
"    some_lock.release()"

msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
"För närvarande kan objekten :class:`Lock`, :class:`RLock`, :class:"
"`Condition`, :class:`Semaphore` och :class:`BoundedSemaphore` användas som :"
"keyword:`with` statement context managers."

msgid "trace function"
msgstr "spårningsfunktion"

msgid "debugger"
msgstr "felsökare"

msgid "profile function"
msgstr "profilfunktion"
