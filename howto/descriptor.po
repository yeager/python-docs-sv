# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Descriptor Guide"
msgstr "Guide för deskriptorer"

msgid "Author"
msgstr "Författare"

msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

msgid "Contact"
msgstr "Kontakt"

msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

msgid "Contents"
msgstr "Innehåll"

msgid ""
":term:`Descriptors <descriptor>` let objects customize attribute lookup, "
"storage, and deletion."
msgstr ""
":term:`Deskriptorer <descriptor>` låter objekt anpassa sökning, lagring och "
"borttagning av attribut."

msgid "This guide has four major sections:"
msgstr "Denna guide består av fyra huvudavsnitt:"

msgid ""
"The \"primer\" gives a basic overview, moving gently from simple examples, "
"adding one feature at a time.  Start here if you're new to descriptors."
msgstr ""
"\"Primer\" ger en grundläggande översikt och går försiktigt vidare från "
"enkla exempel och lägger till en funktion i taget.  Börja här om du är "
"nybörjare på deskriptorer."

msgid ""
"The second section shows a complete, practical descriptor example.  If you "
"already know the basics, start there."
msgstr ""
"I det andra avsnittet visas ett komplett, praktiskt exempel på en "
"descriptor.  Om du redan kan grunderna kan du börja där."

msgid ""
"The third section provides a more technical tutorial that goes into the "
"detailed mechanics of how descriptors work.  Most people don't need this "
"level of detail."
msgstr ""
"I det tredje avsnittet finns en mer teknisk handledning som går in i detalj "
"på hur deskriptorer fungerar.  De flesta människor behöver inte denna "
"detaljnivå."

msgid ""
"The last section has pure Python equivalents for built-in descriptors that "
"are written in C.  Read this if you're curious about how functions turn into "
"bound methods or about the implementation of common tools like :func:"
"`classmethod`, :func:`staticmethod`, :func:`property`, and :term:`__slots__`."
msgstr ""
"Det sista avsnittet har rena Python-ekvivalenter för inbyggda deskriptorer "
"som är skrivna i C. Läs detta om du är nyfiken på hur funktioner blir till "
"bundna metoder eller om implementeringen av vanliga verktyg som :func:"
"`classmethod`, :func:`staticmethod`, :func:`property` och :term:`__slots__`."

msgid "Primer"
msgstr "Tändhatt"

msgid ""
"In this primer, we start with the most basic possible example and then we'll "
"add new capabilities one by one."
msgstr ""
"I den här guiden börjar vi med ett så grundläggande exempel som möjligt och "
"sedan lägger vi till nya funktioner en efter en."

msgid "Simple example: A descriptor that returns a constant"
msgstr "Enkelt exempel: En deskriptor som returnerar en konstant"

msgid ""
"The :class:`!Ten` class is a descriptor whose :meth:`~object.__get__` method "
"always returns the constant ``10``:"
msgstr ""
"Klassen :class:`!Ten` är en deskriptor vars :meth:`~object.__get__`-metod "
"alltid returnerar konstanten ``10``:"

msgid ""
"class Ten:\n"
"    def __get__(self, obj, objtype=None):\n"
"        return 10"
msgstr ""
"class Ten:\n"
"    def __get__(self, obj, objtype=None):\n"
"        return 10"

msgid ""
"To use the descriptor, it must be stored as a class variable in another "
"class:"
msgstr ""
"För att kunna använda deskriptorn måste den lagras som en klassvariabel i en "
"annan klass:"

msgid ""
"class A:\n"
"    x = 5                       # Regular class attribute\n"
"    y = Ten()                   # Descriptor instance"
msgstr ""
"class A:\n"
"    x = 5                       # Regular class attribute\n"
"    y = Ten()                   # Descriptor instance"

msgid ""
"An interactive session shows the difference between normal attribute lookup "
"and descriptor lookup:"
msgstr ""
"En interaktiv session visar skillnaden mellan normal attributuppslagning och "
"deskriptoruppslagning:"

msgid ""
">>> a = A()                     # Make an instance of class A\n"
">>> a.x                         # Normal attribute lookup\n"
"5\n"
">>> a.y                         # Descriptor lookup\n"
"10"
msgstr ""
">>> a = A()                     # Make an instance of class A\n"
">>> a.x                         # Normal attribute lookup\n"
"5\n"
">>> a.y                         # Descriptor lookup\n"
"10"

msgid ""
"In the ``a.x`` attribute lookup, the dot operator finds ``'x': 5`` in the "
"class dictionary.  In the ``a.y`` lookup, the dot operator finds a "
"descriptor instance, recognized by its ``__get__`` method. Calling that "
"method returns ``10``."
msgstr ""
"I attributuppslagningen ``a.x`` hittar punktoperatorn ``'x': 5`` i "
"klassordlistan.  I ``a.y``-uppslagningen hittar dot-operatorn en descriptor-"
"instans, som känns igen på dess metod ``__get__``. Anrop av den metoden "
"returnerar ``10``."

msgid ""
"Note that the value ``10`` is not stored in either the class dictionary or "
"the instance dictionary.  Instead, the value ``10`` is computed on demand."
msgstr ""
"Observera att värdet ``10`` inte lagras i vare sig klassordlistan eller "
"instansordlistan.  Istället beräknas värdet ``10`` på begäran."

msgid ""
"This example shows how a simple descriptor works, but it isn't very useful. "
"For retrieving constants, normal attribute lookup would be better."
msgstr ""
"Detta exempel visar hur en enkel descriptor fungerar, men det är inte "
"särskilt användbart. För att hämta konstanter skulle normal "
"attributuppslagning vara bättre."

msgid ""
"In the next section, we'll create something more useful, a dynamic lookup."
msgstr ""
"I nästa avsnitt ska vi skapa något mer användbart, en dynamisk uppslagning."

msgid "Dynamic lookups"
msgstr "Dynamiska uppslagningar"

msgid ""
"Interesting descriptors typically run computations instead of returning "
"constants:"
msgstr ""
"Intressanta deskriptorer kör vanligtvis beräkningar istället för att "
"returnera konstanter:"

msgid ""
"import os\n"
"\n"
"class DirectorySize:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return len(os.listdir(obj.dirname))\n"
"\n"
"class Directory:\n"
"\n"
"    size = DirectorySize()              # Descriptor instance\n"
"\n"
"    def __init__(self, dirname):\n"
"        self.dirname = dirname          # Regular instance attribute"
msgstr ""
"import os\n"
"\n"
"class DirectorySize:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return len(os.listdir(obj.dirname))\n"
"\n"
"class Directory:\n"
"\n"
"    size = DirectorySize()              # Descriptor instance\n"
"\n"
"    def __init__(self, dirname):\n"
"        self.dirname = dirname          # Regular instance attribute"

msgid ""
"An interactive session shows that the lookup is dynamic — it computes "
"different, updated answers each time::"
msgstr ""
"En interaktiv session visar att uppslagningen är dynamisk - den beräknar "
"olika, uppdaterade svar varje gång::"

msgid ""
">>> s = Directory('songs')\n"
">>> g = Directory('games')\n"
">>> s.size                              # The songs directory has twenty "
"files\n"
"20\n"
">>> g.size                              # The games directory has three "
"files\n"
"3\n"
">>> os.remove('games/chess')            # Delete a game\n"
">>> g.size                              # File count is automatically "
"updated\n"
"2"
msgstr ""
">>> s = Directory('songs')\n"
">>> g = Directory('games')\n"
">>> s.size                              # The songs directory has twenty "
"files\n"
"20\n"
">>> g.size                              # The games directory has three "
"files\n"
"3\n"
">>> os.remove('games/chess')            # Delete a game\n"
">>> g.size                              # File count is automatically "
"updated\n"
"2"

msgid ""
"Besides showing how descriptors can run computations, this example also "
"reveals the purpose of the parameters to :meth:`~object.__get__`.  The "
"*self* parameter is *size*, an instance of *DirectorySize*.  The *obj* "
"parameter is either *g* or *s*, an instance of *Directory*.  It is the *obj* "
"parameter that lets the :meth:`~object.__get__` method learn the target "
"directory.  The *objtype* parameter is the class *Directory*."
msgstr ""
"Förutom att visa hur deskriptorer kan utföra beräkningar, avslöjar detta "
"exempel också syftet med parametrarna i :meth:`~object.__get__`.  Parametern "
"*self* är *size*, en instans av *DirectorySize*.  Parametern *obj* är "
"antingen *g* eller *s*, en instans av *Directory*.  Det är parametern *obj* "
"som gör att metoden :meth:`~object.__get__` kan lära sig målkatalogen.  "
"Parametern *objtype* är klassen *Directory*."

msgid "Managed attributes"
msgstr "Hanterade attribut"

msgid ""
"A popular use for descriptors is managing access to instance data.  The "
"descriptor is assigned to a public attribute in the class dictionary while "
"the actual data is stored as a private attribute in the instance "
"dictionary.  The descriptor's :meth:`~object.__get__` and :meth:`~object."
"__set__` methods are triggered when the public attribute is accessed."
msgstr ""
"Ett populärt användningsområde för deskriptorer är att hantera åtkomst till "
"instansdata.  Deskriptorn tilldelas ett offentligt attribut i klassordlistan "
"medan de faktiska uppgifterna lagras som ett privat attribut i "
"instansordlistan.  Deskriptorns metoder :meth:`~object.__get__` och :meth:"
"`~object.__set__` utlöses när det publika attributet används."

msgid ""
"In the following example, *age* is the public attribute and *_age* is the "
"private attribute.  When the public attribute is accessed, the descriptor "
"logs the lookup or update:"
msgstr ""
"I följande exempel är *age* det publika attributet och *_age* det privata "
"attributet.  När det publika attributet används loggar deskriptorn sökningen "
"eller uppdateringen:"

msgid ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAgeAccess:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = obj._age\n"
"        logging.info('Accessing %r giving %r', 'age', value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', 'age', value)\n"
"        obj._age = value\n"
"\n"
"class Person:\n"
"\n"
"    age = LoggedAgeAccess()             # Descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                # Regular instance attribute\n"
"        self.age = age                  # Calls __set__()\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1                   # Calls both __get__() and __set__()"
msgstr ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAgeAccess:\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = obj._age\n"
"        logging.info('Accessing %r giving %r', 'age', value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', 'age', value)\n"
"        obj._age = value\n"
"\n"
"class Person:\n"
"\n"
"    age = LoggedAgeAccess()             # Descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                # Regular instance attribute\n"
"        self.age = age                  # Calls __set__()\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1                   # Calls both __get__() and __set__()"

msgid ""
"An interactive session shows that all access to the managed attribute *age* "
"is logged, but that the regular attribute *name* is not logged:"
msgstr ""
"En interaktiv session visar att all åtkomst till det hanterade attributet "
"*age* loggas, men att det vanliga attributet *name* inte loggas:"

msgid ""
">>> mary = Person('Mary M', 30)         # The initial age update is logged\n"
"INFO:root:Updating 'age' to 30\n"
">>> dave = Person('David D', 40)\n"
"INFO:root:Updating 'age' to 40\n"
"\n"
">>> vars(mary)                          # The actual data is in a private "
"attribute\n"
"{'name': 'Mary M', '_age': 30}\n"
">>> vars(dave)\n"
"{'name': 'David D', '_age': 40}\n"
"\n"
">>> mary.age                            # Access the data and log the "
"lookup\n"
"INFO:root:Accessing 'age' giving 30\n"
"30\n"
">>> mary.birthday()                     # Updates are logged as well\n"
"INFO:root:Accessing 'age' giving 30\n"
"INFO:root:Updating 'age' to 31\n"
"\n"
">>> dave.name                           # Regular attribute lookup isn't "
"logged\n"
"'David D'\n"
">>> dave.age                            # Only the managed attribute is "
"logged\n"
"INFO:root:Accessing 'age' giving 40\n"
"40"
msgstr ""
">>> mary = Person('Mary M', 30)         # The initial age update is logged\n"
"INFO:root:Updating 'age' to 30\n"
">>> dave = Person('David D', 40)\n"
"INFO:root:Updating 'age' to 40\n"
"\n"
">>> vars(mary)                          # The actual data is in a private "
"attribute\n"
"{'name': 'Mary M', '_age': 30}\n"
">>> vars(dave)\n"
"{'name': 'David D', '_age': 40}\n"
"\n"
">>> mary.age                            # Access the data and log the "
"lookup\n"
"INFO:root:Accessing 'age' giving 30\n"
"30\n"
">>> mary.birthday()                     # Updates are logged as well\n"
"INFO:root:Accessing 'age' giving 30\n"
"INFO:root:Updating 'age' to 31\n"
"\n"
">>> dave.name                           # Regular attribute lookup isn't "
"logged\n"
"'David D'\n"
">>> dave.age                            # Only the managed attribute is "
"logged\n"
"INFO:root:Accessing 'age' giving 40\n"
"40"

msgid ""
"One major issue with this example is that the private name *_age* is "
"hardwired in the *LoggedAgeAccess* class.  That means that each instance can "
"only have one logged attribute and that its name is unchangeable.  In the "
"next example, we'll fix that problem."
msgstr ""
"Ett stort problem med detta exempel är att det privata namnet *_age* är "
"fastkopplat i klassen *LoggedAgeAccess*.  Det innebär att varje instans bara "
"kan ha ett loggat attribut och att dess namn är oföränderligt.  I nästa "
"exempel ska vi åtgärda det problemet."

msgid "Customized names"
msgstr "Anpassade namn"

msgid ""
"When a class uses descriptors, it can inform each descriptor about which "
"variable name was used."
msgstr ""
"När en klass använder descriptors kan den informera varje descriptor om "
"vilket variabelnamn som användes."

msgid ""
"In this example, the :class:`!Person` class has two descriptor instances, "
"*name* and *age*.  When the :class:`!Person` class is defined, it makes a "
"callback to :meth:`~object.__set_name__` in *LoggedAccess* so that the field "
"names can be recorded, giving each descriptor its own *public_name* and "
"*private_name*:"
msgstr ""
"I det här exemplet har klassen :class:`!Person` två deskriptorinstanser, "
"*name* och *age*.  När klassen :class:`!Person` definieras gör den ett anrop "
"till :meth:`~object.__set_name__` i *LoggedAccess* så att fältnamnen kan "
"registreras och varje deskriptor får sina egna *public_name* och "
"*private_name*:"

msgid ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAccess:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.public_name = name\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = getattr(obj, self.private_name)\n"
"        logging.info('Accessing %r giving %r', self.public_name, value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', self.public_name, value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"class Person:\n"
"\n"
"    name = LoggedAccess()                # First descriptor instance\n"
"    age = LoggedAccess()                 # Second descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                 # Calls the first descriptor\n"
"        self.age = age                   # Calls the second descriptor\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1"
msgstr ""
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class LoggedAccess:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.public_name = name\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        value = getattr(obj, self.private_name)\n"
"        logging.info('Accessing %r giving %r', self.public_name, value)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        logging.info('Updating %r to %r', self.public_name, value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"class Person:\n"
"\n"
"    name = LoggedAccess()                # First descriptor instance\n"
"    age = LoggedAccess()                 # Second descriptor instance\n"
"\n"
"    def __init__(self, name, age):\n"
"        self.name = name                 # Calls the first descriptor\n"
"        self.age = age                   # Calls the second descriptor\n"
"\n"
"    def birthday(self):\n"
"        self.age += 1"

msgid ""
"An interactive session shows that the :class:`!Person` class has called :"
"meth:`~object.__set_name__` so that the field names would be recorded.  Here "
"we call :func:`vars` to look up the descriptor without triggering it:"
msgstr ""
"En interaktiv session visar att klassen :class:`!Person` har anropat :meth:"
"`~object.__set_name__` så att fältnamnen skulle registreras.  Här anropar "
"vi :func:`vars` för att leta upp deskriptorn utan att trigga den:"

msgid ""
">>> vars(vars(Person)['name'])\n"
"{'public_name': 'name', 'private_name': '_name'}\n"
">>> vars(vars(Person)['age'])\n"
"{'public_name': 'age', 'private_name': '_age'}"
msgstr ""
">>> vars(vars(Person)['name'])\n"
"{'public_name': 'name', 'private_name': '_name'}\n"
">>> vars(vars(Person)['age'])\n"
"{'public_name': 'age', 'private_name': '_age'}"

msgid "The new class now logs access to both *name* and *age*:"
msgstr "Den nya klassen loggar nu åtkomst till både *namn* och *ålder*:"

msgid ""
">>> pete = Person('Peter P', 10)\n"
"INFO:root:Updating 'name' to 'Peter P'\n"
"INFO:root:Updating 'age' to 10\n"
">>> kate = Person('Catherine C', 20)\n"
"INFO:root:Updating 'name' to 'Catherine C'\n"
"INFO:root:Updating 'age' to 20"
msgstr ""
">>> pete = Person('Peter P', 10)\n"
"INFO:root:Updating 'name' to 'Peter P'\n"
"INFO:root:Updating 'age' to 10\n"
">>> kate = Person('Catherine C', 20)\n"
"INFO:root:Updating 'name' to 'Catherine C'\n"
"INFO:root:Updating 'age' to 20"

msgid "The two *Person* instances contain only the private names:"
msgstr "De två *Person*-instanserna innehåller endast de privata namnen:"

msgid ""
">>> vars(pete)\n"
"{'_name': 'Peter P', '_age': 10}\n"
">>> vars(kate)\n"
"{'_name': 'Catherine C', '_age': 20}"
msgstr ""
">>> vars(pete)\n"
"{'_name': 'Peter P', '_age': 10}\n"
">>> vars(kate)\n"
"{'_name': 'Catherine C', '_age': 20}"

msgid "Closing thoughts"
msgstr "Avslutande tankar"

msgid ""
"A :term:`descriptor` is what we call any object that defines :meth:`~object."
"__get__`, :meth:`~object.__set__`, or :meth:`~object.__delete__`."
msgstr ""
"En :term:`descriptor` är vad vi kallar alla objekt som definierar :meth:"
"`~object.__get__`, :meth:`~object.__set__` eller :meth:`~object.__delete__`."

msgid ""
"Optionally, descriptors can have a :meth:`~object.__set_name__` method.  "
"This is only used in cases where a descriptor needs to know either the class "
"where it was created or the name of class variable it was assigned to.  "
"(This method, if present, is called even if the class is not a descriptor.)"
msgstr ""
"Eventuellt kan deskriptorer ha en :meth:`~object.__set_name__`-metod.  Denna "
"används endast i de fall då en descriptor behöver veta antingen vilken klass "
"den skapades i eller namnet på den klassvariabel som den tilldelades.  "
"(Denna metod, om den finns, anropas även om klassen inte är en descriptor)"

msgid ""
"Descriptors get invoked by the dot operator during attribute lookup.  If a "
"descriptor is accessed indirectly with ``vars(some_class)"
"[descriptor_name]``, the descriptor instance is returned without invoking it."
msgstr ""
"Deskriptorer anropas av dot-operatorn under attributuppslagning.  Om en "
"descriptor nås indirekt med ``vars(some_class)[descriptor_name]`` returneras "
"descriptor-instansen utan att den anropas."

msgid ""
"Descriptors only work when used as class variables.  When put in instances, "
"they have no effect."
msgstr ""
"Descriptors fungerar bara när de används som klassvariabler.  När de läggs "
"in i instanser har de ingen effekt."

msgid ""
"The main motivation for descriptors is to provide a hook allowing objects "
"stored in class variables to control what happens during attribute lookup."
msgstr ""
"Huvudmotivet för deskriptorer är att tillhandahålla en krok som gör det "
"möjligt för objekt som lagras i klassvariabler att styra vad som händer "
"under attributuppslagningen."

msgid ""
"Traditionally, the calling class controls what happens during lookup. "
"Descriptors invert that relationship and allow the data being looked-up to "
"have a say in the matter."
msgstr ""
"Traditionellt sett kontrollerar den anropande klassen vad som händer under "
"uppslagningen. Deskriptorer vänder på det förhållandet och låter de data som "
"söks upp ha ett ord med i laget."

msgid ""
"Descriptors are used throughout the language.  It is how functions turn into "
"bound methods.  Common tools like :func:`classmethod`, :func:"
"`staticmethod`, :func:`property`, and :func:`functools.cached_property` are "
"all implemented as descriptors."
msgstr ""
"Deskriptorer används i hela språket.  Det är så funktioner förvandlas till "
"bundna metoder.  Vanliga verktyg som :func:`classmethod`, :func:"
"`staticmethod`, :func:`property` och :func:`functools.cached_property` är "
"alla implementerade som deskriptorer."

msgid "Complete Practical Example"
msgstr "Komplett praktiskt exempel"

msgid ""
"In this example, we create a practical and powerful tool for locating "
"notoriously hard to find data corruption bugs."
msgstr ""
"I det här exemplet skapar vi ett praktiskt och kraftfullt verktyg för att "
"lokalisera fel som är svåra att hitta när det gäller datakorruption."

msgid "Validator class"
msgstr "Klass för validerare"

msgid ""
"A validator is a descriptor for managed attribute access.  Prior to storing "
"any data, it verifies that the new value meets various type and range "
"restrictions.  If those restrictions aren't met, it raises an exception to "
"prevent data corruption at its source."
msgstr ""
"En validator är en deskriptor för hanterad attributåtkomst.  Innan data "
"lagras verifieras att det nya värdet uppfyller olika typ- och "
"intervallrestriktioner.  Om dessa begränsningar inte uppfylls, skapar den "
"ett undantag för att förhindra att data korrumperas vid källan."

msgid ""
"This :class:`!Validator` class is both an :term:`abstract base class` and a "
"managed attribute descriptor:"
msgstr ""
"Denna :class:`!Validator`-klass är både en :term:`abstrakt basklass` och en "
"hanterad attributbeskrivare:"

msgid ""
"from abc import ABC, abstractmethod\n"
"\n"
"class Validator(ABC):\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.private_name = '_' + name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return getattr(obj, self.private_name)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        self.validate(value)\n"
"        setattr(obj, self.private_name, value)\n"
"\n"
"    @abstractmethod\n"
"    def validate(self, value):\n"
"        pass"
msgstr ""
"från abc import ABC, abstractmethod\n"
"\n"
"klass Validator(ABC):\n"
"\n"
"    def __set_name__(self, ägare, namn):\n"
"        self.private_name = '_' + namn\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return getattr(obj, self.private_name)\n"
"\n"
"    def __set__(self, obj, värde):\n"
"        self.validate(värde)\n"
"        setattr(obj, self.private_name, värde)\n"
"\n"
"    @abstraktmetod\n"
"    def validate(self, värde):\n"
"        passera"

msgid ""
"Custom validators need to inherit from :class:`!Validator` and must supply "
"a :meth:`!validate` method to test various restrictions as needed."
msgstr ""
"Egna validerare måste ärva från :class:`!Validator` och måste tillhandahålla "
"en :meth:`!validate`-metod för att testa olika begränsningar efter behov."

msgid "Custom validators"
msgstr "Anpassade validerare"

msgid "Here are three practical data validation utilities:"
msgstr "Här är tre praktiska verktyg för validering av data:"

msgid ""
":class:`!OneOf` verifies that a value is one of a restricted set of options."
msgstr ""
":class:`!OneOf` verifierar att ett värde är ett av en begränsad uppsättning "
"alternativ."

msgid ""
":class:`!Number` verifies that a value is either an :class:`int` or :class:"
"`float`.  Optionally, it verifies that a value is between a given minimum or "
"maximum."
msgstr ""
":class:`!Number` verifierar att ett värde är antingen en :class:`int` eller "
"en :class:`float`.  Eventuellt verifierar den att ett värde ligger mellan "
"ett givet minimum eller maximum."

msgid ""
":class:`!String` verifies that a value is a :class:`str`.  Optionally, it "
"validates a given minimum or maximum length.  It can validate a user-defined "
"`predicate <https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)>`_ "
"as well."
msgstr ""
":class:`!String` verifierar att ett värde är en :class:`str`.  Eventuellt "
"validerar den en given minsta eller största längd.  Den kan även validera "
"ett användardefinierat `predikat <https://en.wikipedia.org/wiki/"
"Predicate_(mathematical_logic)>`_."

msgid ""
"class OneOf(Validator):\n"
"\n"
"    def __init__(self, *options):\n"
"        self.options = set(options)\n"
"\n"
"    def validate(self, value):\n"
"        if value not in self.options:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be one of {self.options!r}'\n"
"            )\n"
"\n"
"class Number(Validator):\n"
"\n"
"    def __init__(self, minvalue=None, maxvalue=None):\n"
"        self.minvalue = minvalue\n"
"        self.maxvalue = maxvalue\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, (int, float)):\n"
"            raise TypeError(f'Expected {value!r} to be an int or float')\n"
"        if self.minvalue is not None and value < self.minvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be at least {self.minvalue!r}'\n"
"            )\n"
"        if self.maxvalue is not None and value > self.maxvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no more than {self.maxvalue!r}'\n"
"            )\n"
"\n"
"class String(Validator):\n"
"\n"
"    def __init__(self, minsize=None, maxsize=None, predicate=None):\n"
"        self.minsize = minsize\n"
"        self.maxsize = maxsize\n"
"        self.predicate = predicate\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, str):\n"
"            raise TypeError(f'Expected {value!r} to be an str')\n"
"        if self.minsize is not None and len(value) < self.minsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no smaller than {self.minsize!"
"r}'\n"
"            )\n"
"        if self.maxsize is not None and len(value) > self.maxsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no bigger than {self.maxsize!r}'\n"
"            )\n"
"        if self.predicate is not None and not self.predicate(value):\n"
"            raise ValueError(\n"
"                f'Expected {self.predicate} to be true for {value!r}'\n"
"            )"
msgstr ""
"class OneOf(Validator):\n"
"\n"
"    def __init__(self, *options):\n"
"        self.options = set(options)\n"
"\n"
"    def validate(self, value):\n"
"        if value not in self.options:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be one of {self.options!r}'\n"
"            )\n"
"\n"
"class Number(Validator):\n"
"\n"
"    def __init__(self, minvalue=None, maxvalue=None):\n"
"        self.minvalue = minvalue\n"
"        self.maxvalue = maxvalue\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, (int, float)):\n"
"            raise TypeError(f'Expected {value!r} to be an int or float')\n"
"        if self.minvalue is not None and value < self.minvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be at least {self.minvalue!r}'\n"
"            )\n"
"        if self.maxvalue is not None and value > self.maxvalue:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no more than {self.maxvalue!r}'\n"
"            )\n"
"\n"
"class String(Validator):\n"
"\n"
"    def __init__(self, minsize=None, maxsize=None, predicate=None):\n"
"        self.minsize = minsize\n"
"        self.maxsize = maxsize\n"
"        self.predicate = predicate\n"
"\n"
"    def validate(self, value):\n"
"        if not isinstance(value, str):\n"
"            raise TypeError(f'Expected {value!r} to be an str')\n"
"        if self.minsize is not None and len(value) < self.minsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no smaller than {self.minsize!"
"r}'\n"
"            )\n"
"        if self.maxsize is not None and len(value) > self.maxsize:\n"
"            raise ValueError(\n"
"                f'Expected {value!r} to be no bigger than {self.maxsize!r}'\n"
"            )\n"
"        if self.predicate is not None and not self.predicate(value):\n"
"            raise ValueError(\n"
"                f'Expected {self.predicate} to be true for {value!r}'\n"
"            )"

msgid "Practical application"
msgstr "Praktisk tillämpning"

msgid "Here's how the data validators can be used in a real class:"
msgstr "Så här kan datavaliderarna användas i en riktig klass:"

msgid ""
"class Component:\n"
"\n"
"    name = String(minsize=3, maxsize=10, predicate=str.isupper)\n"
"    kind = OneOf('wood', 'metal', 'plastic')\n"
"    quantity = Number(minvalue=0)\n"
"\n"
"    def __init__(self, name, kind, quantity):\n"
"        self.name = name\n"
"        self.kind = kind\n"
"        self.quantity = quantity"
msgstr ""
"class Component:\n"
"\n"
"    name = String(minsize=3, maxsize=10, predicate=str.isupper)\n"
"    kind = OneOf('wood', 'metal', 'plastic')\n"
"    quantity = Number(minvalue=0)\n"
"\n"
"    def __init__(self, name, kind, quantity):\n"
"        self.name = name\n"
"        self.kind = kind\n"
"        self.quantity = quantity"

msgid "The descriptors prevent invalid instances from being created:"
msgstr "Deskriptorerna förhindrar att ogiltiga instanser skapas:"

msgid ""
">>> Component('Widget', 'metal', 5)      # Blocked: 'Widget' is not all "
"uppercase\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected <method 'isupper' of 'str' objects> to be true for "
"'Widget'\n"
"\n"
">>> Component('WIDGET', 'metle', 5)      # Blocked: 'metle' is misspelled\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected 'metle' to be one of {'metal', 'plastic', 'wood'}\n"
"\n"
">>> Component('WIDGET', 'metal', -5)     # Blocked: -5 is negative\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected -5 to be at least 0\n"
"\n"
">>> Component('WIDGET', 'metal', 'V')    # Blocked: 'V' isn't a number\n"
"Traceback (most recent call last):\n"
"    ...\n"
"TypeError: Expected 'V' to be an int or float\n"
"\n"
">>> c = Component('WIDGET', 'metal', 5)  # Allowed:  The inputs are valid"
msgstr ""
">>> Component('Widget', 'metal', 5)      # Blocked: 'Widget' is not all "
"uppercase\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected <method 'isupper' of 'str' objects> to be true for "
"'Widget'\n"
"\n"
">>> Component('WIDGET', 'metle', 5)      # Blocked: 'metle' is misspelled\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected 'metle' to be one of {'metal', 'plastic', 'wood'}\n"
"\n"
">>> Component('WIDGET', 'metal', -5)     # Blocked: -5 is negative\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: Expected -5 to be at least 0\n"
"\n"
">>> Component('WIDGET', 'metal', 'V')    # Blocked: 'V' isn't a number\n"
"Traceback (most recent call last):\n"
"    ...\n"
"TypeError: Expected 'V' to be an int or float\n"
"\n"
">>> c = Component('WIDGET', 'metal', 5)  # Allowed:  The inputs are valid"

msgid "Technical Tutorial"
msgstr "Teknisk handledning"

msgid ""
"What follows is a more technical tutorial for the mechanics and details of "
"how descriptors work."
msgstr ""
"Det som följer är en mer teknisk handledning för mekaniken och detaljerna i "
"hur deskriptorer fungerar."

msgid "Abstract"
msgstr "Abstrakt"

msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Provides an example showing how object relational mappings work."
msgstr ""
"Definierar deskriptorer, sammanfattar protokollet och visar hur deskriptorer "
"anropas.  Ger ett exempel som visar hur objektrelationsmappningar fungerar."

msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works."
msgstr ""
"Att lära sig om deskriptorer ger inte bara tillgång till en större "
"uppsättning verktyg, det skapar också en djupare förståelse för hur Python "
"fungerar."

msgid "Definition and introduction"
msgstr "Definition och introduktion"

msgid ""
"In general, a descriptor is an attribute value that has one of the methods "
"in the descriptor protocol.  Those methods are :meth:`~object.__get__`, :"
"meth:`~object.__set__`, and :meth:`~object.__delete__`.  If any of those "
"methods are defined for an attribute, it is said to be a :term:`descriptor`."
msgstr ""
"I allmänhet är en deskriptor ett attributvärde som har en av metoderna i "
"deskriptorprotokollet.  Dessa metoder är :meth:`~object.__get__`, :meth:"
"`~object.__set__` och :meth:`~object.__delete__`.  Om någon av dessa metoder "
"är definierade för ett attribut, sägs det vara en :term:`descriptor`."

msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the method resolution order of ``type(a)``. If the looked-"
"up value is an object defining one of the descriptor methods, then Python "
"may override the default behavior and invoke the descriptor method instead. "
"Where this occurs in the precedence chain depends on which descriptor "
"methods were defined."
msgstr ""
"Standardbeteendet för attributåtkomst är att hämta, ställa in eller ta bort "
"attributet från ett objekts ordbok.  Till exempel har ``a.x`` en "
"uppslagskedja som börjar med ``a.__dict__['x']``, sedan ``type(a)."
"__dict__['x']``, och fortsätter genom metodupplösningsordningen för "
"``type(a)``. Om det sökta värdet är ett objekt som definierar en av "
"deskriptormetoderna, kan Python åsidosätta standardbeteendet och anropa "
"deskriptormetoden istället. Var detta sker i prioriteringskedjan beror på "
"vilka deskriptormetoder som definierades."

msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super`.  They are used throughout Python itself.  Descriptors simplify "
"the underlying C code and offer a flexible set of new tools for everyday "
"Python programs."
msgstr ""
"Deskriptorer är ett kraftfullt protokoll för allmänna ändamål.  De är "
"mekanismen bakom egenskaper, metoder, statiska metoder, klassmetoder och :"
"func:`super`.  De används i hela Python självt.  Descriptors förenklar den "
"underliggande C-koden och erbjuder en flexibel uppsättning nya verktyg för "
"vardagliga Python-program."

msgid "Descriptor protocol"
msgstr "Protokoll för deskriptorer"

msgid "``descr.__get__(self, obj, type=None)``"
msgstr "``descr.__get__(self, obj, type=None)```"

msgid "``descr.__set__(self, obj, value)``"
msgstr "``descr.__set__(self, obj, value)```"

msgid "``descr.__delete__(self, obj)``"
msgstr "``descr.__delete__(self, obj)``"

msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr ""
"Det är allt det är.  Definiera någon av dessa metoder och ett objekt "
"betraktas som en deskriptor och kan åsidosätta standardbeteendet när det "
"söks upp som ett attribut."

msgid ""
"If an object defines :meth:`~object.__set__` or :meth:`~object.__delete__`, "
"it is considered a data descriptor.  Descriptors that only define :meth:"
"`~object.__get__` are called non-data descriptors (they are often used for "
"methods but other uses are possible)."
msgstr ""
"Om ett objekt definierar :meth:`~object.__set__` eller :meth:`~object."
"__delete__`, betraktas det som en datadeskriptor.  Deskriptorer som bara "
"definierar :meth:`~object.__get__` kallas icke-datadeskriptorer (de används "
"ofta för metoder men andra användningsområden är möjliga)."

msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"Datadeskriptorer och icke-datadeskriptorer skiljer sig åt när det gäller hur "
"åsidosättanden beräknas i förhållande till poster i en instans ordbok.  Om "
"en instans ordbok har en post med samma namn som en datadeskriptor, har "
"datadeskriptorn företräde.  Om en instans ordbok har en post med samma namn "
"som en icke datadeskriptor, har ordboksposten företräde."

msgid ""
"To make a read-only data descriptor, define both :meth:`~object.__get__` "
"and :meth:`~object.__set__` with the :meth:`~object.__set__` raising an :exc:"
"`AttributeError` when called.  Defining the :meth:`~object.__set__` method "
"with an exception raising placeholder is enough to make it a data descriptor."
msgstr ""
"För att skapa en skrivskyddad databeskrivare definierar du både :meth:"
"`~object.__get__` och :meth:`~object.__set__` med :meth:`~object.__set__` "
"som ger upphov till ett :exc:`AttributeError` när den anropas.  Att "
"definiera metoden :meth:`~object.__set__` med en platshållare som ger upphov "
"till ett undantag är tillräckligt för att göra den till en databeskrivare."

msgid "Overview of descriptor invocation"
msgstr "Översikt över anrop av deskriptor"

msgid ""
"A descriptor can be called directly with ``desc.__get__(obj)`` or ``desc."
"__get__(None, cls)``."
msgstr ""
"En deskriptor kan anropas direkt med ``desc.__get__(obj)`` eller ``desc."
"__get__(None, cls)``."

msgid ""
"But it is more common for a descriptor to be invoked automatically from "
"attribute access."
msgstr ""
"Det är dock vanligare att en descriptor anropas automatiskt från "
"attributåtkomst."

msgid ""
"The expression ``obj.x`` looks up the attribute ``x`` in the chain of "
"namespaces for ``obj``.  If the search finds a descriptor outside of the "
"instance :attr:`~object.__dict__`, its :meth:`~object.__get__` method is "
"invoked according to the precedence rules listed below."
msgstr ""
"Uttrycket ``obj.x`` letar upp attributet ``x`` i kedjan av namnrymder för "
"``obj``.  Om sökningen hittar en deskriptor utanför instansen :attr:`~object."
"__dict__`, anropas dess metod :meth:`~object.__get__` enligt de "
"prioritetsregler som anges nedan."

msgid ""
"The details of invocation depend on whether ``obj`` is an object, class, or "
"instance of super."
msgstr ""
"Detaljerna i anropet beror på om ``obj`` är ett objekt, en klass eller en "
"instans av super."

msgid "Invocation from an instance"
msgstr "Anrop från en instans"

msgid ""
"Instance lookup scans through a chain of namespaces giving data descriptors "
"the highest priority, followed by instance variables, then non-data "
"descriptors, then class variables, and lastly :meth:`~object.__getattr__` if "
"it is provided."
msgstr ""
"Instance lookup skannar genom en kedja av namnrymder med högsta prioritet "
"för datadeskriptorer, följt av instansvariabler, sedan icke-"
"datadeskriptorer, sedan klassvariabler och slutligen :meth:`~object."
"__getattr__` om den tillhandahålls."

msgid ""
"If a descriptor is found for ``a.x``, then it is invoked with: ``desc."
"__get__(a, type(a))``."
msgstr ""
"Om en deskriptor hittas för ``a.x``, så anropas den med: ``desc.__get__(a, "
"type(a))``."

msgid ""
"The logic for a dotted lookup is in :meth:`object.__getattribute__`.  Here "
"is a pure Python equivalent:"
msgstr ""
"Logiken för en prickad uppslagning finns i :meth:`object.__getattribute__`.  "
"Här är en ren Python-motsvarighet:"

msgid ""
"def find_name_in_mro(cls, name, default):\n"
"    \"Emulate _PyType_Lookup() in Objects/typeobject.c\"\n"
"    for base in cls.__mro__:\n"
"        if name in vars(base):\n"
"            return vars(base)[name]\n"
"    return default\n"
"\n"
"def object_getattribute(obj, name):\n"
"    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\n"
"    null = object()\n"
"    objtype = type(obj)\n"
"    cls_var = find_name_in_mro(objtype, name, null)\n"
"    descr_get = getattr(type(cls_var), '__get__', null)\n"
"    if descr_get is not null:\n"
"        if (hasattr(type(cls_var), '__set__')\n"
"            or hasattr(type(cls_var), '__delete__')):\n"
"            return descr_get(cls_var, obj, objtype)     # data descriptor\n"
"    if hasattr(obj, '__dict__') and name in vars(obj):\n"
"        return vars(obj)[name]                          # instance variable\n"
"    if descr_get is not null:\n"
"        return descr_get(cls_var, obj, objtype)         # non-data "
"descriptor\n"
"    if cls_var is not null:\n"
"        return cls_var                                  # class variable\n"
"    raise AttributeError(name)"
msgstr ""
"def find_name_in_mro(cls, name, default):\n"
"    \"Emulate _PyType_Lookup() in Objects/typeobject.c\"\n"
"    for base in cls.__mro__:\n"
"        if name in vars(base):\n"
"            return vars(base)[name]\n"
"    return default\n"
"\n"
"def object_getattribute(obj, name):\n"
"    \"Emulate PyObject_GenericGetAttr() in Objects/object.c\"\n"
"    null = object()\n"
"    objtype = type(obj)\n"
"    cls_var = find_name_in_mro(objtype, name, null)\n"
"    descr_get = getattr(type(cls_var), '__get__', null)\n"
"    if descr_get is not null:\n"
"        if (hasattr(type(cls_var), '__set__')\n"
"            or hasattr(type(cls_var), '__delete__')):\n"
"            return descr_get(cls_var, obj, objtype)     # data descriptor\n"
"    if hasattr(obj, '__dict__') and name in vars(obj):\n"
"        return vars(obj)[name]                          # instance variable\n"
"    if descr_get is not null:\n"
"        return descr_get(cls_var, obj, objtype)         # non-data "
"descriptor\n"
"    if cls_var is not null:\n"
"        return cls_var                                  # class variable\n"
"    raise AttributeError(name)"

msgid ""
"Note, there is no :meth:`~object.__getattr__` hook in the :meth:`~object."
"__getattribute__` code.  That is why calling :meth:`~object."
"__getattribute__` directly or with ``super().__getattribute__`` will bypass :"
"meth:`~object.__getattr__` entirely."
msgstr ""
"Observera att det inte finns någon :meth:`~object.__getattr__`-krok i :meth:"
"`~object.__getattribute__`-koden.  Därför kommer anrop av :meth:`~object."
"__getattribute__` direkt eller med ``super().__getattribute__`` att kringgå :"
"meth:`~object.__getattr__` helt och hållet."

msgid ""
"Instead, it is the dot operator and the :func:`getattr` function that are "
"responsible for invoking :meth:`~object.__getattr__` whenever :meth:`~object."
"__getattribute__` raises an :exc:`AttributeError`.  Their logic is "
"encapsulated in a helper function:"
msgstr ""
"Istället är det punktoperatorn och funktionen :func:`getattr` som ansvarar "
"för att anropa :meth:`~object.__getattr__` närhelst :meth:`~object."
"__getattribute__` ger upphov till ett :exc:`AttributeError`.  Deras logik är "
"inkapslad i en hjälpfunktion:"

msgid ""
"def getattr_hook(obj, name):\n"
"    \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\n"
"    try:\n"
"        return obj.__getattribute__(name)\n"
"    except AttributeError:\n"
"        if not hasattr(type(obj), '__getattr__'):\n"
"            raise\n"
"    return type(obj).__getattr__(obj, name)             # __getattr__"
msgstr ""
"def getattr_hook(obj, name):\n"
"    \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\"\n"
"    try:\n"
"        return obj.__getattribute__(name)\n"
"    except AttributeError:\n"
"        if not hasattr(type(obj), '__getattr__'):\n"
"            raise\n"
"    return type(obj).__getattr__(obj, name)             # __getattr__"

msgid "Invocation from a class"
msgstr "Anrop från en klass"

msgid ""
"The logic for a dotted lookup such as ``A.x`` is in :meth:`!type."
"__getattribute__`.  The steps are similar to those for :meth:`!object."
"__getattribute__` but the instance dictionary lookup is replaced by a search "
"through the class's :term:`method resolution order`."
msgstr ""
"Logiken för en prickad uppslagning som ``A.x`` finns i :meth:`!type."
"__getattribute__`.  Stegen liknar dem för :meth:`!object.__getattribute__` "
"men uppslagningen i instansordboken ersätts av en sökning genom klassens :"
"term:`method resolution order`."

msgid "If a descriptor is found, it is invoked with ``desc.__get__(None, A)``."
msgstr "Om en descriptor hittas anropas den med ``desc.__get__(None, A)``."

msgid ""
"The full C implementation can be found in :c:func:`!type_getattro` and :c:"
"func:`!_PyType_Lookup` in :source:`Objects/typeobject.c`."
msgstr ""
"Den fullständiga C-implementeringen finns i :c:func:`!type_getattro` och :c:"
"func:`!_PyType_Lookup` i :source:`Objects/typeobject.c`."

msgid "Invocation from super"
msgstr "Anrop från super"

msgid ""
"The logic for super's dotted lookup is in the :meth:`~object."
"__getattribute__` method for object returned by :func:`super`."
msgstr ""
"Logiken för Supers prickade uppslagning finns i metoden :meth:`~object."
"__getattribute__` för objekt som returneras av :func:`super`."

msgid ""
"A dotted lookup such as ``super(A, obj).m`` searches ``obj.__class__."
"__mro__`` for the base class ``B`` immediately following ``A`` and then "
"returns ``B.__dict__['m'].__get__(obj, A)``.  If not a descriptor, ``m`` is "
"returned unchanged."
msgstr ""
"En prickad uppslagning som ``super(A, obj).m`` söker i ``obj.__class__."
"__mro__`` efter basklassen ``B`` omedelbart efter ``A`` och returnerar sedan "
"``B.__dict__['m'].__get__(obj, A)``.  Om det inte är en deskriptor "
"returneras ``m`` oförändrad."

msgid ""
"The full C implementation can be found in :c:func:`!super_getattro` in :"
"source:`Objects/typeobject.c`.  A pure Python equivalent can be found in "
"`Guido's Tutorial <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."
msgstr ""
"Den fullständiga C-implementeringen finns i :c:func:`!super_getattro` i :"
"source:`Objects/typeobject.c`.  En ren Python-ekvivalent finns i `Guido's "
"Tutorial <https://www.python.org/download/releases/2.2.3/descrintro/"
"#cooperation>`_."

msgid "Summary of invocation logic"
msgstr "Sammanfattning av anropslogiken"

msgid ""
"The mechanism for descriptors is embedded in the :meth:`~object."
"__getattribute__` methods for :class:`object`, :class:`type`, and :func:"
"`super`."
msgstr ""
"Mekanismen för deskriptorer är inbäddad i metoderna :meth:`~object."
"__getattribute__` för :class:`object`, :class:`type` och :func:`super`."

msgid "The important points to remember are:"
msgstr "De viktiga punkterna att komma ihåg är:"

msgid "Descriptors are invoked by the :meth:`~object.__getattribute__` method."
msgstr "Deskriptorer anropas med metoden :meth:`~object.__getattribute__`."

msgid ""
"Classes inherit this machinery from :class:`object`, :class:`type`, or :func:"
"`super`."
msgstr ""
"Klasser ärver detta maskineri från :class:`object`, :class:`type` eller :"
"func:`super`."

msgid ""
"Overriding :meth:`~object.__getattribute__` prevents automatic descriptor "
"calls because all the descriptor logic is in that method."
msgstr ""
"Åsidosättande av :meth:`~object.__getattribute__` förhindrar automatiska "
"descriptor-anrop eftersom all descriptor-logik finns i den metoden."

msgid ""
":meth:`!object.__getattribute__` and :meth:`!type.__getattribute__` make "
"different calls to :meth:`~object.__get__`.  The first includes the instance "
"and may include the class.  The second puts in ``None`` for the instance and "
"always includes the class."
msgstr ""
":meth:`!object.__getattribute__` and :meth:`!type.__getattribute__` make "
"different calls to :meth:`~object.__get__`.  The first includes the instance "
"and may include the class.  The second puts in ``None`` for the instance and "
"always includes the class."

msgid "Data descriptors always override instance dictionaries."
msgstr "Data descriptors har alltid företräde framför instance dictionaries."

msgid "Non-data descriptors may be overridden by instance dictionaries."
msgstr "Deskriptorer som inte är data kan åsidosättas av instansordlistor."

msgid "Automatic name notification"
msgstr "Automatisk namnavisering"

msgid ""
"Sometimes it is desirable for a descriptor to know what class variable name "
"it was assigned to.  When a new class is created, the :class:`type` "
"metaclass scans the dictionary of the new class.  If any of the entries are "
"descriptors and if they define :meth:`~object.__set_name__`, that method is "
"called with two arguments.  The *owner* is the class where the descriptor is "
"used, and the *name* is the class variable the descriptor was assigned to."
msgstr ""
"Ibland är det önskvärt att en deskriptor vet vilket klassvariabelnamn den "
"tilldelades.  När en ny klass skapas skannar metaklassen :class:`type` den "
"nya klassens dictionary.  Om någon av posterna är deskriptorer och om de "
"definierar :meth:`~object.__set_name__`, anropas den metoden med två "
"argument.  *owner* är den klass där deskriptorn används och *name* är den "
"klassvariabel som deskriptorn tilldelades."

msgid ""
"The implementation details are in :c:func:`!type_new` and :c:func:`!"
"set_names` in :source:`Objects/typeobject.c`."
msgstr ""
"Implementationsdetaljerna finns i :c:func:`!type_new` och :c:func:`!"
"set_names` i :source:`Objects/typeobject.c`."

msgid ""
"Since the update logic is in :meth:`!type.__new__`, notifications only take "
"place at the time of class creation.  If descriptors are added to the class "
"afterwards, :meth:`~object.__set_name__` will need to be called manually."
msgstr ""
"Eftersom uppdateringslogiken finns i :meth:`!type.__new__`, sker "
"notifieringar endast vid tidpunkten för klassens skapande.  Om deskriptorer "
"läggs till i klassen efteråt måste :meth:`~object.__set_name__` anropas "
"manuellt."

msgid "ORM example"
msgstr "Exempel på ORM"

msgid ""
"The following code is a simplified skeleton showing how data descriptors "
"could be used to implement an `object relational mapping <https://en."
"wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."
msgstr ""
"Följande kod är ett förenklat skelett som visar hur databeskrivare kan "
"användas för att implementera en \"objektrelationsmappning\" <https://en."
"wikipedia.org/wiki/Object%E2%80%93relational_mapping>`_."

msgid ""
"The essential idea is that the data is stored in an external database.  The "
"Python instances only hold keys to the database's tables.  Descriptors take "
"care of lookups or updates:"
msgstr ""
"Grundtanken är att data lagras i en extern databas.  Python-instanserna "
"innehåller bara nycklar till databasens tabeller.  Deskriptorer tar hand om "
"uppslagningar eller uppdateringar:"

msgid ""
"class Field:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}"
"=?;'\n"
"        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}"
"=?;'\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return conn.execute(self.fetch, [obj.key]).fetchone()[0]\n"
"\n"
"    def __set__(self, obj, value):\n"
"        conn.execute(self.store, [value, obj.key])\n"
"        conn.commit()"
msgstr ""
"class Field:\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.fetch = f'SELECT {name} FROM {owner.table} WHERE {owner.key}"
"=?;'\n"
"        self.store = f'UPDATE {owner.table} SET {name}=? WHERE {owner.key}"
"=?;'\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return conn.execute(self.fetch, [obj.key]).fetchone()[0]\n"
"\n"
"    def __set__(self, obj, value):\n"
"        conn.execute(self.store, [value, obj.key])\n"
"        conn.commit()"

msgid ""
"We can use the :class:`!Field` class to define `models <https://en.wikipedia."
"org/wiki/Database_model>`_ that describe the schema for each table in a "
"database:"
msgstr ""
"Vi kan använda :class:`!Field`-klassen för att definiera `modeller <https://"
"en.wikipedia.org/wiki/Database_model>`_ som beskriver schemat för varje "
"tabell i en databas:"

msgid ""
"class Movie:\n"
"    table = 'Movies'                    # Table name\n"
"    key = 'title'                       # Primary key\n"
"    director = Field()\n"
"    year = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key\n"
"\n"
"class Song:\n"
"    table = 'Music'\n"
"    key = 'title'\n"
"    artist = Field()\n"
"    year = Field()\n"
"    genre = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key"
msgstr ""
"class Movie:\n"
"    table = 'Movies'                    # Table name\n"
"    key = 'title'                       # Primary key\n"
"    director = Field()\n"
"    year = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key\n"
"\n"
"class Song:\n"
"    table = 'Music'\n"
"    key = 'title'\n"
"    artist = Field()\n"
"    year = Field()\n"
"    genre = Field()\n"
"\n"
"    def __init__(self, key):\n"
"        self.key = key"

msgid "To use the models, first connect to the database::"
msgstr "För att använda modellerna måste du först ansluta till databasen::"

msgid ""
">>> import sqlite3\n"
">>> conn = sqlite3.connect('entertainment.db')"
msgstr ""
">>> import sqlite3\n"
">>> conn = sqlite3.connect('entertainment.db')"

msgid ""
"An interactive session shows how data is retrieved from the database and how "
"it can be updated:"
msgstr ""
"En interaktiv session visar hur data hämtas från databasen och hur den kan "
"uppdateras:"

msgid ""
">>> Movie('Star Wars').director\n"
"'George Lucas'\n"
">>> jaws = Movie('Jaws')\n"
">>> f'Released in {jaws.year} by {jaws.director}'\n"
"'Released in 1975 by Steven Spielberg'\n"
"\n"
">>> Song('Country Roads').artist\n"
"'John Denver'\n"
"\n"
">>> Movie('Star Wars').director = 'J.J. Abrams'\n"
">>> Movie('Star Wars').director\n"
"'J.J. Abrams'"
msgstr ""
">>> Movie('Star Wars').director\n"
"'George Lucas'\n"
">>> jaws = Movie('Jaws')\n"
">>> f'Released in {jaws.year} by {jaws.director}'\n"
"'Released in 1975 by Steven Spielberg'\n"
"\n"
">>> Song('Country Roads').artist\n"
"'John Denver'\n"
"\n"
">>> Movie('Star Wars').director = 'J.J. Abrams'\n"
">>> Movie('Star Wars').director\n"
"'J.J. Abrams'"

msgid "Pure Python Equivalents"
msgstr "Rena Python-ekvivalenter"

msgid ""
"The descriptor protocol is simple and offers exciting possibilities.  "
"Several use cases are so common that they have been prepackaged into built-"
"in tools. Properties, bound methods, static methods, class methods, and "
"\\_\\_slots\\_\\_ are all based on the descriptor protocol."
msgstr ""
"Descriptor-protokollet är enkelt och erbjuder spännande möjligheter.  Flera "
"användningsfall är så vanliga att de har paketerats i inbyggda verktyg. "
"Egenskaper, bundna metoder, statiska metoder, klassmetoder och "
"\\_\\_slots\\_\\_ är alla baserade på descriptor-protokollet."

msgid "Properties"
msgstr "Egenskaper"

msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers a function call upon access to an attribute.  Its signature "
"is::"
msgstr ""
"Anrop av :func:`property` är ett kortfattat sätt att bygga en "
"databeskrivning som utlöser ett funktionsanrop vid åtkomst till ett "
"attribut.  Dess signatur är::"

msgid "property(fget=None, fset=None, fdel=None, doc=None) -> property"
msgstr "property(fget=None, fset=None, fdel=None, doc=None) -> property"

msgid ""
"The documentation shows a typical use to define a managed attribute ``x``:"
msgstr ""
"Dokumentationen visar en typisk användning för att definiera ett hanterat "
"attribut ``x``:"

msgid ""
"class C:\n"
"    def getx(self): return self.__x\n"
"    def setx(self, value): self.__x = value\n"
"    def delx(self): del self.__x\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"
msgstr ""
"class C:\n"
"    def getx(self): return self.__x\n"
"    def setx(self, value): self.__x = value\n"
"    def delx(self): del self.__x\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"

msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent that implements most of the core "
"functionality:"
msgstr ""
"För att se hur :func:`property` implementeras i termer av "
"descriptorprotokollet, här är en ren Python-motsvarighet som implementerar "
"det mesta av kärnfunktionaliteten:"

msgid ""
"class Property:\n"
"    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n"
"\n"
"    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n"
"        self.fget = fget\n"
"        self.fset = fset\n"
"        self.fdel = fdel\n"
"        if doc is None and fget is not None:\n"
"            doc = fget.__doc__\n"
"        self.__doc__ = doc\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.__name__ = name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        if obj is None:\n"
"            return self\n"
"        if self.fget is None:\n"
"            raise AttributeError\n"
"        return self.fget(obj)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        if self.fset is None:\n"
"            raise AttributeError\n"
"        self.fset(obj, value)\n"
"\n"
"    def __delete__(self, obj):\n"
"        if self.fdel is None:\n"
"            raise AttributeError\n"
"        self.fdel(obj)\n"
"\n"
"    def getter(self, fget):\n"
"        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n"
"\n"
"    def setter(self, fset):\n"
"        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n"
"\n"
"    def deleter(self, fdel):\n"
"        return type(self)(self.fget, self.fset, fdel, self.__doc__)"
msgstr ""
"class Property:\n"
"    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n"
"\n"
"    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n"
"        self.fget = fget\n"
"        self.fset = fset\n"
"        self.fdel = fdel\n"
"        if doc is None and fget is not None:\n"
"            doc = fget.__doc__\n"
"        self.__doc__ = doc\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self.__name__ = name\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        if obj is None:\n"
"            return self\n"
"        if self.fget is None:\n"
"            raise AttributeError\n"
"        return self.fget(obj)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        if self.fset is None:\n"
"            raise AttributeError\n"
"        self.fset(obj, value)\n"
"\n"
"    def __delete__(self, obj):\n"
"        if self.fdel is None:\n"
"            raise AttributeError\n"
"        self.fdel(obj)\n"
"\n"
"    def getter(self, fget):\n"
"        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n"
"\n"
"    def setter(self, fset):\n"
"        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n"
"\n"
"    def deleter(self, fdel):\n"
"        return type(self)(self.fget, self.fset, fdel, self.__doc__)"

msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ""
"Inbyggda :func:`property` är till hjälp när ett användargränssnitt har gett "
"tillgång till attribut och efterföljande ändringar kräver att en metod "
"används."

msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor:"
msgstr ""
"Till exempel kan en kalkylbladsklass ge åtkomst till ett cellvärde genom "
"``Cell('b10').value``. Senare förbättringar av programmet kräver att cellen "
"räknas om vid varje åtkomst, men programmeraren vill inte påverka befintlig "
"klientkod som har direkt åtkomst till attributet.  Lösningen är att linda in "
"åtkomst till värdeattributet i en egenskapsdatadeskriptor:"

msgid ""
"class Cell:\n"
"    ...\n"
"\n"
"    @property\n"
"    def value(self):\n"
"        \"Recalculate the cell before returning value\"\n"
"        self.recalc()\n"
"        return self._value"
msgstr ""
"class Cell:\n"
"    ...\n"
"\n"
"    @property\n"
"    def value(self):\n"
"        \"Recalculate the cell before returning value\"\n"
"        self.recalc()\n"
"        return self._value"

msgid ""
"Either the built-in :func:`property` or our :func:`!Property` equivalent "
"would work in this example."
msgstr ""
"Antingen den inbyggda :func:`property` eller vår :func:`!Property`-"
"ekvivalent skulle fungera i det här exemplet."

msgid "Functions and methods"
msgstr "Funktioner och metoder"

msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""
"Pythons objektorienterade funktioner bygger på en funktionsbaserad miljö. "
"Med hjälp av icke-datadeskriptorer sammanfogas de två sömlöst."

msgid ""
"Functions stored in class dictionaries get turned into methods when invoked. "
"Methods only differ from regular functions in that the object instance is "
"prepended to the other arguments.  By convention, the instance is called "
"*self* but could be called *this* or any other variable name."
msgstr ""
"Funktioner som lagras i klassordböcker omvandlas till metoder när de "
"anropas. Metoder skiljer sig från vanliga funktioner endast genom att "
"objektinstansen läggs till de andra argumenten.  Enligt konvention kallas "
"instansen *self*, men den kan kallas *this* eller något annat variabelnamn."

msgid ""
"Methods can be created manually with :class:`types.MethodType` which is "
"roughly equivalent to:"
msgstr ""
"Metoder kan skapas manuellt med :class:`types.MethodType` vilket i stort "
"sett motsvarar:"

msgid ""
"class MethodType:\n"
"    \"Emulate PyMethod_Type in Objects/classobject.c\"\n"
"\n"
"    def __init__(self, func, obj):\n"
"        self.__func__ = func\n"
"        self.__self__ = obj\n"
"\n"
"    def __call__(self, *args, **kwargs):\n"
"        func = self.__func__\n"
"        obj = self.__self__\n"
"        return func(obj, *args, **kwargs)\n"
"\n"
"    def __getattribute__(self, name):\n"
"        \"Emulate method_getset() in Objects/classobject.c\"\n"
"        if name == '__doc__':\n"
"            return self.__func__.__doc__\n"
"        return object.__getattribute__(self, name)\n"
"\n"
"    def __getattr__(self, name):\n"
"        \"Emulate method_getattro() in Objects/classobject.c\"\n"
"        return getattr(self.__func__, name)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Emulate method_descr_get() in Objects/classobject.c\"\n"
"        return self"
msgstr ""
"class MethodType:\n"
"    \"Emulate PyMethod_Type in Objects/classobject.c\"\n"
"\n"
"    def __init__(self, func, obj):\n"
"        self.__func__ = func\n"
"        self.__self__ = obj\n"
"\n"
"    def __call__(self, *args, **kwargs):\n"
"        func = self.__func__\n"
"        obj = self.__self__\n"
"        return func(obj, *args, **kwargs)\n"
"\n"
"    def __getattribute__(self, name):\n"
"        \"Emulate method_getset() in Objects/classobject.c\"\n"
"        if name == '__doc__':\n"
"            return self.__func__.__doc__\n"
"        return object.__getattribute__(self, name)\n"
"\n"
"    def __getattr__(self, name):\n"
"        \"Emulate method_getattro() in Objects/classobject.c\"\n"
"        return getattr(self.__func__, name)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Emulate method_descr_get() in Objects/classobject.c\"\n"
"        return self"

msgid ""
"To support automatic creation of methods, functions include the :meth:"
"`~object.__get__` method for binding methods during attribute access.  This "
"means that functions are non-data descriptors that return bound methods "
"during dotted lookup from an instance.  Here's how it works:"
msgstr ""
"För att stödja automatiskt skapande av metoder innehåller funktioner "
"metoden :meth:`~object.__get__` för att binda metoder under "
"attributåtkomst.  Detta innebär att funktioner är icke-databeskrivare som "
"returnerar bundna metoder under prickad uppslagning från en instans.  Så här "
"fungerar det:"

msgid ""
"class Function:\n"
"    ...\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Simulate func_descr_get() in Objects/funcobject.c\"\n"
"        if obj is None:\n"
"            return self\n"
"        return MethodType(self, obj)"
msgstr ""
"class Function:\n"
"    ...\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Simulate func_descr_get() in Objects/funcobject.c\"\n"
"        if obj is None:\n"
"            return self\n"
"        return MethodType(self, obj)"

msgid ""
"Running the following class in the interpreter shows how the function "
"descriptor works in practice:"
msgstr ""
"Genom att köra följande klass i tolken visas hur funktionsbeskrivaren "
"fungerar i praktiken:"

msgid ""
"class D:\n"
"    def f(self):\n"
"         return self\n"
"\n"
"class D2:\n"
"    pass"
msgstr ""
"class D:\n"
"    def f(self):\n"
"         return self\n"
"\n"
"class D2:\n"
"    pass"

msgid ""
"The function has a :term:`qualified name` attribute to support introspection:"
msgstr ""
"Funktionen har ett :term:`kvalificerat namn`-attribut för att stödja "
"introspektion:"

msgid ""
">>> D.f.__qualname__\n"
"'D.f'"
msgstr ""
">>> D.f.__qualname__\n"
"'D.f'"

msgid ""
"Accessing the function through the class dictionary does not invoke :meth:"
"`~object.__get__`.  Instead, it just returns the underlying function object::"
msgstr ""
"Om du öppnar funktionen via klassordlistan anropas inte :meth:`~object."
"__get__`.  Istället returneras bara den underliggande funktionens objekt::"

msgid ""
">>> D.__dict__['f']\n"
"<function D.f at 0x00C45070>"
msgstr ""
">>> D.__dict__['f']\n"
"<function D.f at 0x00C45070>"

msgid ""
"Dotted access from a class calls :meth:`~object.__get__` which just returns "
"the underlying function unchanged::"
msgstr ""
"Punktad åtkomst från en klass anropar :meth:`~object.__get__` som bara "
"returnerar den underliggande funktionen oförändrad::"

msgid ""
">>> D.f\n"
"<function D.f at 0x00C45070>"
msgstr ""
">>> D.f\n"
"<function D.f at 0x00C45070>"

msgid ""
"The interesting behavior occurs during dotted access from an instance.  The "
"dotted lookup calls :meth:`~object.__get__` which returns a bound method "
"object::"
msgstr ""
"Det intressanta beteendet inträffar under prickad åtkomst från en instans.  "
"Den prickade uppslagningen anropar :meth:`~object.__get__` som returnerar en "
"bunden metod object::"

msgid ""
">>> d = D()\n"
">>> d.f\n"
"<bound method D.f of <__main__.D object at 0x00B18C90>>"
msgstr ""
">>> d = D()\n"
">>> d.f\n"
"<bound method D.f of <__main__.D object at 0x00B18C90>>"

msgid ""
"Internally, the bound method stores the underlying function and the bound "
"instance::"
msgstr ""
"Internt lagrar den bundna metoden den underliggande funktionen och den "
"bundna instansen::"

msgid ""
">>> d.f.__func__\n"
"<function D.f at 0x00C45070>\n"
"\n"
">>> d.f.__self__\n"
"<__main__.D object at 0x00B18C90>"
msgstr ""
">>> d.f.__func__\n"
"<function D.f at 0x00C45070>\n"
"\n"
">>> d.f.__self__\n"
"<__main__.D object at 0x00B18C90>"

msgid ""
"If you have ever wondered where *self* comes from in regular methods or "
"where *cls* comes from in class methods, this is it!"
msgstr ""
"Om du någonsin har undrat var *self* kommer ifrån i vanliga metoder eller "
"var *cls* kommer ifrån i klassmetoder, så har du svaret här!"

msgid "Kinds of methods"
msgstr "Olika typer av metoder"

msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr ""
"Deskriptorer för icke-data ger en enkel mekanism för variationer på de "
"vanliga mönstren för att binda funktioner till metoder."

msgid ""
"To recap, functions have a :meth:`~object.__get__` method so that they can "
"be converted to a method when accessed as attributes.  The non-data "
"descriptor transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  "
"Calling ``cls.f(*args)`` becomes ``f(*args)``."
msgstr ""
"För att sammanfatta har funktioner en :meth:`~object.__get__`-metod så att "
"de kan konverteras till en metod när de används som attribut.  Icke-data "
"deskriptorn omvandlar ett anrop av ``obj.f(*args)`` till ``f(obj, *args)``.  "
"Anrop av ``cls.f(*args)`` blir ``f(*args)``."

msgid "This chart summarizes the binding and its two most useful variants:"
msgstr ""
"I detta diagram sammanfattas bindningen och dess två mest användbara "
"varianter:"

msgid "Transformation"
msgstr "Omvandling"

msgid "Called from an object"
msgstr "Anropas från ett objekt"

msgid "Called from a class"
msgstr "Anropas från en klass"

msgid "function"
msgstr "funktion"

msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

msgid "f(\\*args)"
msgstr "f(\\*args)"

msgid "staticmethod"
msgstr "statisk metod"

msgid "classmethod"
msgstr "klassmetod"

msgid "f(type(obj), \\*args)"
msgstr "f(typ(obj), \\*args)"

msgid "f(cls, \\*args)"
msgstr "f(cls, \\*args)"

msgid "Static methods"
msgstr "Statiska metoder"

msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"Statiska metoder returnerar den underliggande funktionen utan ändringar.  "
"Anrop av antingen ``c.f`` eller ``C.f`` motsvarar en direkt uppslagning i "
"``object.__getattribute__(c, \"f\")`` eller ``object.__getattribute__(C, "
"\"f\")``. Därmed blir funktionen identiskt tillgänglig från antingen ett "
"objekt eller en klass."

msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr ""
"Bra kandidater för statiska metoder är metoder som inte refererar till "
"variabeln ``self``."

msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> 0.9332`` or ``Sample.erf(1.5) --> 0.9332``."
msgstr ""
"Ett statistikpaket kan t.ex. innehålla en containerklass för experimentella "
"data.  Klassen innehåller normala metoder för att beräkna genomsnitt, "
"medelvärde, median och annan beskrivande statistik som är beroende av data. "
"Det kan dock finnas användbara funktioner som är begreppsmässigt relaterade "
"men som inte är beroende av data.  Till exempel är ``erf(x)`` en praktisk "
"konverteringsrutin som förekommer i statistiskt arbete men som inte är "
"direkt beroende av en viss dataset. Den kan anropas antingen från ett objekt "
"eller en klass:  ``s.erf(1,5) --> 0,9332`` eller ``Sample.erf(1,5) --> "
"0,9332``."

msgid ""
"Since static methods return the underlying function with no changes, the "
"example calls are unexciting:"
msgstr ""
"Eftersom statiska metoder returnerar den underliggande funktionen utan några "
"ändringar är exempelanropen inte särskilt spännande:"

msgid ""
"class E:\n"
"    @staticmethod\n"
"    def f(x):\n"
"        return x * 10"
msgstr ""
"class E:\n"
"    @staticmethod\n"
"    def f(x):\n"
"        return x * 10"

msgid ""
">>> E.f(3)\n"
"30\n"
">>> E().f(3)\n"
"30"
msgstr ""
">>> E.f(3)\n"
"30\n"
">>> E().f(3)\n"
"30"

msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this:"
msgstr ""
"Med hjälp av icke-data descriptor-protokollet skulle en ren Python-version "
"av :func:`staticmethod` se ut så här:"

msgid ""
"import functools\n"
"\n"
"class StaticMethod:\n"
"    \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return self.f\n"
"\n"
"    def __call__(self, *args, **kwds):\n"
"        return self.f(*args, **kwds)\n"
"\n"
"    @property\n"
"    def __annotations__(self):\n"
"        return self.f.__annotations__"
msgstr ""
"import functools\n"
"\n"
"class StaticMethod:\n"
"    \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        return self.f\n"
"\n"
"    def __call__(self, *args, **kwds):\n"
"        return self.f(*args, **kwds)\n"
"\n"
"    @property\n"
"    def __annotations__(self):\n"
"        return self.f.__annotations__"

msgid ""
"The :func:`functools.update_wrapper` call adds a ``__wrapped__`` attribute "
"that refers to the underlying function.  Also it carries forward the "
"attributes necessary to make the wrapper look like the wrapped function, "
"including :attr:`~function.__name__`, :attr:`~function.__qualname__`, and :"
"attr:`~function.__doc__`."
msgstr ""
"Anropet :func:`functools.update_wrapper` lägger till ett ``__wrapped__``-"
"attribut som refererar till den underliggande funktionen.  Det överför också "
"de attribut som är nödvändiga för att få omslaget att se ut som den omslutna "
"funktionen, inklusive :attr:`~function.__name__`, :attr:`~function."
"__qualname__` och :attr:`~function.__doc__`."

msgid "Class methods"
msgstr "Klassmetoder"

msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class:"
msgstr ""
"Till skillnad från statiska metoder lägger klassmetoder till klassreferensen "
"i argumentlistan innan funktionen anropas.  Detta format är detsamma oavsett "
"om den som anropar är ett objekt eller en klass:"

msgid ""
"class F:\n"
"    @classmethod\n"
"    def f(cls, x):\n"
"        return cls.__name__, x"
msgstr ""
"class F:\n"
"    @classmethod\n"
"    def f(cls, x):\n"
"        return cls.__name__, x"

msgid ""
">>> F.f(3)\n"
"('F', 3)\n"
">>> F().f(3)\n"
"('F', 3)"
msgstr ""
">>> F.f(3)\n"
"('F', 3)\n"
">>> F().f(3)\n"
"('F', 3)"

msgid ""
"This behavior is useful whenever the method only needs to have a class "
"reference and does not rely on data stored in a specific instance.  One use "
"for class methods is to create alternate class constructors.  For example, "
"the classmethod :func:`dict.fromkeys` creates a new dictionary from a list "
"of keys.  The pure Python equivalent is:"
msgstr ""
"Detta beteende är användbart när metoden bara behöver ha en klassreferens "
"och inte förlitar sig på data som lagras i en specifik instans.  Ett sätt "
"att använda klassmetoder är att skapa alternativa klasskonstruktörer.  Till "
"exempel skapar klassmetoden :func:`dict.fromkeys` en ny ordbok från en lista "
"med nycklar.  Den rena Python-ekvivalenten är:"

msgid ""
"class Dict(dict):\n"
"    @classmethod\n"
"    def fromkeys(cls, iterable, value=None):\n"
"        \"Emulate dict_fromkeys() in Objects/dictobject.c\"\n"
"        d = cls()\n"
"        for key in iterable:\n"
"            d[key] = value\n"
"        return d"
msgstr ""
"class Dict(dict):\n"
"    @classmethod\n"
"    def fromkeys(cls, iterable, value=None):\n"
"        \"Emulate dict_fromkeys() in Objects/dictobject.c\"\n"
"        d = cls()\n"
"        for key in iterable:\n"
"            d[key] = value\n"
"        return d"

msgid "Now a new dictionary of unique keys can be constructed like this:"
msgstr "Nu kan en ny ordbok med unika nycklar konstrueras så här:"

msgid ""
">>> d = Dict.fromkeys('abracadabra')\n"
">>> type(d) is Dict\n"
"True\n"
">>> d\n"
"{'a': None, 'b': None, 'r': None, 'c': None, 'd': None}"
msgstr ""
">>> d = Dict.fromkeys('abracadabra')\n"
">>> type(d) is Dict\n"
"True\n"
">>> d\n"
"{'a': None, 'b': None, 'r': None, 'c': None, 'd': None}"

msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this:"
msgstr ""
"Med hjälp av icke-data descriptor-protokollet skulle en ren Python-version "
"av :func:`classmethod` se ut så här:"

msgid ""
"import functools\n"
"\n"
"class ClassMethod:\n"
"    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, cls=None):\n"
"        if cls is None:\n"
"            cls = type(obj)\n"
"        return MethodType(self.f, cls)"
msgstr ""
"import functools\n"
"\n"
"class ClassMethod:\n"
"    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n"
"\n"
"    def __init__(self, f):\n"
"        self.f = f\n"
"        functools.update_wrapper(self, f)\n"
"\n"
"    def __get__(self, obj, cls=None):\n"
"        if cls is None:\n"
"            cls = type(obj)\n"
"        return MethodType(self.f, cls)"

msgid ""
"The :func:`functools.update_wrapper` call in ``ClassMethod`` adds a "
"``__wrapped__`` attribute that refers to the underlying function.  Also it "
"carries forward the attributes necessary to make the wrapper look like the "
"wrapped function: :attr:`~function.__name__`, :attr:`~function."
"__qualname__`, :attr:`~function.__doc__`, and :attr:`~function."
"__annotations__`."
msgstr ""
"Anropet :func:`functools.update_wrapper` i ``ClassMethod`` lägger till ett "
"``__wrapped__``-attribut som refererar till den underliggande funktionen.  "
"Det för också vidare de attribut som är nödvändiga för att få omslaget att "
"se ut som den omslutna funktionen: :attr:`~function.__name__`, :attr:"
"`~function.__qualname__`, :attr:`~function.__doc__`, och :attr:`~function."
"__annotations__`."

msgid "Member objects and __slots__"
msgstr "Medlemsobjekt och __slots__"

msgid ""
"When a class defines ``__slots__``, it replaces instance dictionaries with a "
"fixed-length array of slot values.  From a user point of view that has "
"several effects:"
msgstr ""
"När en klass definierar ``__slots__`` ersätter den instansordböcker med en "
"array av slot-värden med fast längd.  Ur användarens synvinkel har detta "
"flera effekter:"

msgid ""
"1. Provides immediate detection of bugs due to misspelled attribute "
"assignments.  Only attribute names specified in ``__slots__`` are allowed:"
msgstr ""
"1. Ger omedelbar upptäckt av buggar som beror på felstavade "
"attributtilldelningar.  Endast attributnamn som anges i ``__slots__`` är "
"tillåtna:"

msgid ""
"class Vehicle:\n"
"    __slots__ = ('id_number', 'make', 'model')"
msgstr ""
"class Vehicle:\n"
"    __slots__ = ('id_number', 'make', 'model')"

msgid ""
">>> auto = Vehicle()\n"
">>> auto.id_nubmer = 'VYE483814LQEX'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Vehicle' object has no attribute 'id_nubmer'"
msgstr ""
">>> auto = Vehicle()\n"
">>> auto.id_nubmer = 'VYE483814LQEX'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Vehicle' object has no attribute 'id_nubmer'"

msgid ""
"2. Helps create immutable objects where descriptors manage access to private "
"attributes stored in ``__slots__``:"
msgstr ""
"2. Hjälper till att skapa oföränderliga objekt där deskriptorer hanterar "
"åtkomst till privata attribut som lagras i ``__slots__``:"

msgid ""
"class Immutable:\n"
"\n"
"    __slots__ = ('_dept', '_name')          # Replace the instance "
"dictionary\n"
"\n"
"    def __init__(self, dept, name):\n"
"        self._dept = dept                   # Store to private attribute\n"
"        self._name = name                   # Store to private attribute\n"
"\n"
"    @property                               # Read-only descriptor\n"
"    def dept(self):\n"
"        return self._dept\n"
"\n"
"    @property\n"
"    def name(self):                         # Read-only descriptor\n"
"        return self._name"
msgstr ""
"klass Oföränderlig:\n"
"\n"
"    __slots__ = ('_dept', '_name') # Byt ut instansordboken\n"
"\n"
"    def __init__(self, dept, name):\n"
"        self._dept = dept # Lagra till privat attribut\n"
"        self._name = name # Lagra till privat attribut\n"
"\n"
"    @property # skrivskyddad beskrivare\n"
"    def dept(self):\n"
"        return self._dept\n"
"\n"
"    @egenskap\n"
"    def namn(self):                         # skrivskyddad deskriptor\n"
"        returnerar self._name"

msgid ""
">>> mark = Immutable('Botany', 'Mark Watney')\n"
">>> mark.dept\n"
"'Botany'\n"
">>> mark.dept = 'Space Pirate'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: property 'dept' of 'Immutable' object has no setter\n"
">>> mark.location = 'Mars'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Immutable' object has no attribute 'location'"
msgstr ""
">>> mark = Immutable('Botany', 'Mark Watney')\n"
">>> mark.dept\n"
"'Botany'\n"
">>> mark.dept = 'Space Pirate'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: property 'dept' of 'Immutable' object has no setter\n"
">>> mark.location = 'Mars'\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'Immutable' object has no attribute 'location'"

msgid ""
"3. Saves memory.  On a 64-bit Linux build, an instance with two attributes "
"takes 48 bytes with ``__slots__`` and 152 bytes without.  This `flyweight "
"design pattern <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ likely "
"only matters when a large number of instances are going to be created."
msgstr ""
"3. Sparar minne.  På en 64-bitars Linux-version tar en instans med två "
"attribut 48 byte med ``__slots__`` och 152 byte utan.  Detta "
"`flygviktsdesignmönster <https://en.wikipedia.org/wiki/Flyweight_pattern>`_ "
"spelar troligen bara roll när ett stort antal instanser ska skapas."

msgid ""
"4. Improves speed.  Reading instance variables is 35% faster with "
"``__slots__`` (as measured with Python 3.10 on an Apple M1 processor)."
msgstr ""
"4. Förbättrar hastigheten.  Läsning av instansvariabler är 35% faster med "
"``__slots__`` (enligt mätning med Python 3.10 på en Apple M1-processor)."

msgid ""
"5. Blocks tools like :func:`functools.cached_property` which require an "
"instance dictionary to function correctly:"
msgstr ""
"5. Blockerar verktyg som :func:`functools.cached_property` som kräver en "
"instansordbok för att fungera korrekt:"

msgid ""
"from functools import cached_property\n"
"\n"
"class CP:\n"
"    __slots__ = ()                          # Eliminates the instance dict\n"
"\n"
"    @cached_property                        # Requires an instance dict\n"
"    def pi(self):\n"
"        return 4 * sum((-1.0)**n / (2.0*n + 1.0)\n"
"                       for n in reversed(range(100_000)))"
msgstr ""
"from functools import cached_property\n"
"\n"
"class CP:\n"
"    __slots__ = ()                          # Eliminates the instance dict\n"
"\n"
"    @cached_property                        # Requires an instance dict\n"
"    def pi(self):\n"
"        return 4 * sum((-1.0)**n / (2.0*n + 1.0)\n"
"                       for n in reversed(range(100_000)))"

msgid ""
">>> CP().pi\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: No '__dict__' attribute on 'CP' instance to cache 'pi' property."
msgstr ""
">>> CP().pi\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: No '__dict__' attribute on 'CP' instance to cache 'pi' property."

msgid ""
"It is not possible to create an exact drop-in pure Python version of "
"``__slots__`` because it requires direct access to C structures and control "
"over object memory allocation.  However, we can build a mostly faithful "
"simulation where the actual C structure for slots is emulated by a private "
"``_slotvalues`` list.  Reads and writes to that private structure are "
"managed by member descriptors:"
msgstr ""
"Det är inte möjligt att skapa en exakt drop-in ren Python-version av "
"``__slots__`` eftersom det kräver direkt tillgång till C-strukturer och "
"kontroll över objektminnesallokering.  Vi kan dock bygga en mestadels trogen "
"simulering där den faktiska C-strukturen för slots emuleras av en privat "
"``_slotvalues``-lista.  Läsningar och skrivningar till den privata "
"strukturen hanteras av medlemsdeskriptorer:"

msgid ""
"null = object()\n"
"\n"
"class Member:\n"
"\n"
"    def __init__(self, name, clsname, offset):\n"
"        'Emulate PyMemberDef in Include/structmember.h'\n"
"        # Also see descr_new() in Objects/descrobject.c\n"
"        self.name = name\n"
"        self.clsname = clsname\n"
"        self.offset = offset\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        'Emulate member_get() in Objects/descrobject.c'\n"
"        # Also see PyMember_GetOne() in Python/structmember.c\n"
"        if obj is None:\n"
"            return self\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        return value\n"
"\n"
"    def __set__(self, obj, value):\n"
"        'Emulate member_set() in Objects/descrobject.c'\n"
"        obj._slotvalues[self.offset] = value\n"
"\n"
"    def __delete__(self, obj):\n"
"        'Emulate member_delete() in Objects/descrobject.c'\n"
"        value = obj._slotvalues[self.offset]\n"
"        if value is null:\n"
"            raise AttributeError(self.name)\n"
"        obj._slotvalues[self.offset] = null\n"
"\n"
"    def __repr__(self):\n"
"        'Emulate member_repr() in Objects/descrobject.c'\n"
"        return f'<Member {self.name!r} of {self.clsname!r}>'"
msgstr ""
"null = objekt()\n"
"\n"
"klass Medlem:\n"
"\n"
"    def __init__(self, name, clsname, offset):\n"
"        'Emulera PyMemberDef i Include/structmember.h'\n"
"        # Se även descr_new() i Objects/descrobject.c\n"
"        self.name = namn\n"
"        self.clsname = clsname\n"
"        self.offset = offset\n"
"\n"
"    def __get__(self, obj, objtype=None):\n"
"        \"Emulera member_get() i Objects/descrobject.c\n"
"        # Se även PyMember_GetOne() i Python/structmember.c\n"
"        om obj är None:\n"
"            return self\n"
"        värde = obj._slotvalues[self.offset]\n"
"        om värdet är null:\n"
"            raise AttributeError(self.name)\n"
"        returnera värde\n"
"\n"
"    def __set__(self, obj, värde):\n"
"        'Emulera member_set() i Objects/descrobject.c'\n"
"        obj._slotvalues[self.offset] = värde\n"
"\n"
"    def __delete__(self, obj):\n"
"        \"Emulera member_delete() i Objects/descrobject.c\n"
"        värde = obj._slotvalues[self.offset]\n"
"        om värdet är null:\n"
"            raise AttributeError(self.name)\n"
"        obj._slotvalues[self.offset] = null\n"
"\n"
"    def __repr__(self):\n"
"        'Emulera member_repr() i Objects/descrobject.c'\n"
"        return f'<Medlem {self.name!r} av {self.clsname!r}>'"

msgid ""
"The :meth:`!type.__new__` method takes care of adding member objects to "
"class variables:"
msgstr ""
"Metoden :meth:`!type.__new__` tar hand om att lägga till medlemsobjekt i "
"klassvariabler:"

msgid ""
"class Type(type):\n"
"    'Simulate how the type metaclass adds member objects for slots'\n"
"\n"
"    def __new__(mcls, clsname, bases, mapping, **kwargs):\n"
"        'Emulate type_new() in Objects/typeobject.c'\n"
"        # type_new() calls PyTypeReady() which calls add_methods()\n"
"        slot_names = mapping.get('slot_names', [])\n"
"        for offset, name in enumerate(slot_names):\n"
"            mapping[name] = Member(name, clsname, offset)\n"
"        return type.__new__(mcls, clsname, bases, mapping, **kwargs)"
msgstr ""
"klass Typ(typ):\n"
"    'Simulera hur metaklassen type lägger till medlemsobjekt för slots'\n"
"\n"
"    def __new__(mcls, clsname, baser, mappning, **kwargs):\n"
"        \"Emulera type_new() i Objects/typeobject.c\n"
"        # type_new() anropar PyTypeReady() som anropar add_methods()\n"
"        slot_names = mappning.get('slot_names', [])\n"
"        för offset, namn i enumerate(slot_names):\n"
"            mappning[namn] = Member(namn, clsnamn, offset)\n"
"        return type.__new__(mcls, clsname, baser, mappning, **kwargs)"

msgid ""
"The :meth:`object.__new__` method takes care of creating instances that have "
"slots instead of an instance dictionary.  Here is a rough simulation in pure "
"Python:"
msgstr ""
"Metoden :meth:`object.__new__` tar hand om att skapa instanser som har slots "
"istället för en instansordbok.  Här är en grov simulering i ren Python:"

msgid ""
"class Object:\n"
"    'Simulate how object.__new__() allocates memory for __slots__'\n"
"\n"
"    def __new__(cls, *args, **kwargs):\n"
"        'Emulate object_new() in Objects/typeobject.c'\n"
"        inst = super().__new__(cls)\n"
"        if hasattr(cls, 'slot_names'):\n"
"            empty_slots = [null] * len(cls.slot_names)\n"
"            object.__setattr__(inst, '_slotvalues', empty_slots)\n"
"        return inst\n"
"\n"
"    def __setattr__(self, name, value):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__setattr__(name, value)\n"
"\n"
"    def __delattr__(self, name):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__delattr__(name)"
msgstr ""
"class Object:\n"
"    'Simulate how object.__new__() allocates memory for __slots__'\n"
"\n"
"    def __new__(cls, *args, **kwargs):\n"
"        'Emulate object_new() in Objects/typeobject.c'\n"
"        inst = super().__new__(cls)\n"
"        if hasattr(cls, 'slot_names'):\n"
"            empty_slots = [null] * len(cls.slot_names)\n"
"            object.__setattr__(inst, '_slotvalues', empty_slots)\n"
"        return inst\n"
"\n"
"    def __setattr__(self, name, value):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__setattr__(name, value)\n"
"\n"
"    def __delattr__(self, name):\n"
"        'Emulate _PyObject_GenericSetAttrWithDict() Objects/object.c'\n"
"        cls = type(self)\n"
"        if hasattr(cls, 'slot_names') and name not in cls.slot_names:\n"
"            raise AttributeError(\n"
"                f'{cls.__name__!r} object has no attribute {name!r}'\n"
"            )\n"
"        super().__delattr__(name)"

msgid ""
"To use the simulation in a real class, just inherit from :class:`!Object` "
"and set the :term:`metaclass` to :class:`Type`:"
msgstr ""
"För att använda simuleringen i en riktig klass är det bara att ärva från :"
"class:`!Object` och sätta :term:`metaclass` till :class:`Type`:"

msgid ""
"class H(Object, metaclass=Type):\n"
"    'Instance variables stored in slots'\n"
"\n"
"    slot_names = ['x', 'y']\n"
"\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y"
msgstr ""
"class H(Object, metaclass=Type):\n"
"    'Instance variables stored in slots'\n"
"\n"
"    slot_names = ['x', 'y']\n"
"\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y"

msgid ""
"At this point, the metaclass has loaded member objects for *x* and *y*::"
msgstr ""
"Vid det här laget har metaklassen laddat medlemsobjekt för *x* och *y*::"

msgid ""
">>> from pprint import pp\n"
">>> pp(dict(vars(H)))\n"
"{'__module__': '__main__',\n"
" '__doc__': 'Instance variables stored in slots',\n"
" 'slot_names': ['x', 'y'],\n"
" '__init__': <function H.__init__ at 0x7fb5d302f9d0>,\n"
" 'x': <Member 'x' of 'H'>,\n"
" 'y': <Member 'y' of 'H'>}"
msgstr ""
">>> from pprint import pp\n"
">>> pp(dict(vars(H)))\n"
"{'__module__': '__main__',\n"
" '__doc__': 'Instance variables stored in slots',\n"
" 'slot_names': ['x', 'y'],\n"
" '__init__': <function H.__init__ at 0x7fb5d302f9d0>,\n"
" 'x': <Member 'x' of 'H'>,\n"
" 'y': <Member 'y' of 'H'>}"

msgid ""
"When instances are created, they have a ``slot_values`` list where the "
"attributes are stored:"
msgstr ""
"När instanser skapas har de en lista med ``slot_values`` där attributen "
"lagras:"

msgid ""
">>> h = H(10, 20)\n"
">>> vars(h)\n"
"{'_slotvalues': [10, 20]}\n"
">>> h.x = 55\n"
">>> vars(h)\n"
"{'_slotvalues': [55, 20]}"
msgstr ""
">>> h = H(10, 20)\n"
">>> vars(h)\n"
"{'_slotvalues': [10, 20]}\n"
">>> h.x = 55\n"
">>> vars(h)\n"
"{'_slotvalues': [55, 20]}"

msgid "Misspelled or unassigned attributes will raise an exception:"
msgstr ""
"Felstavade eller icke tilldelade attribut kommer att leda till ett undantag:"

msgid ""
">>> h.xz\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'H' object has no attribute 'xz'"
msgstr ""
">>> h.xz\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AttributeError: 'H' object has no attribute 'xz'"
