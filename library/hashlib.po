# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!hashlib` --- Secure hashes and message digests"
msgstr ":mod:`!hashlib` --- Säkra hashar och meddelandesammanställningar"

msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**Källkod:** :source:`Lib/hashlib.py`"

msgid ""
"This module implements a common interface to many different hash algorithms. "
"Included are the FIPS secure hash algorithms SHA224, SHA256, SHA384, SHA512, "
"(defined in `the FIPS 180-4 standard`_), the SHA-3 series (defined in `the "
"FIPS 202 standard`_) as well as the legacy algorithms SHA1 (`formerly part "
"of FIPS`_) and the MD5 algorithm (defined in internet :rfc:`1321`)."
msgstr ""
"Denna modul implementerar ett gemensamt gränssnitt för många olika "
"hashalgoritmer. Här ingår de säkra FIPS-hashalgoritmerna SHA224, SHA256, "
"SHA384, SHA512, (definierade i `the FIPS 180-4 standard`_), SHA-3-serien "
"(definierad i `the FIPS 202 standard`_) samt de äldre algoritmerna SHA1 "
"(`formerly part of FIPS`_) och MD5-algoritmen (definierad i internet :rfc:"
"`1321`)."

msgid ""
"If you want the adler32 or crc32 hash functions, they are available in the :"
"mod:`zlib` module."
msgstr ""
"Om du vill ha hashfunktionerna adler32 eller crc32 finns de tillgängliga i "
"modulen :mod:`zlib`."

msgid "Hash algorithms"
msgstr "Hash-algoritmer"

msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All "
"return a hash object with the same simple interface. For example: use :func:"
"`sha256` to create a SHA-256 hash object. You can now feed this object with :"
"term:`bytes-like objects <bytes-like object>` (normally :class:`bytes`) "
"using the :meth:`update<hash.update>` method.  At any point you can ask it "
"for the :dfn:`digest` of the concatenation of the data fed to it so far "
"using the :meth:`digest()<hash.digest>` or :meth:`hexdigest()<hash."
"hexdigest>` methods."
msgstr ""
"Det finns en konstruktörsmetod för varje typ av :dfn:`hash`.  Alla "
"returnerar ett hash-objekt med samma enkla gränssnitt. Till exempel: använd :"
"func:`sha256` för att skapa ett SHA-256 hash-objekt. Du kan nu mata detta "
"objekt med :term:`bytes-liknande objekt <bytes-like object>` (normalt :class:"
"`bytes`) med hjälp av metoden :meth:`update<hash.update>`.  När som helst "
"kan du be den om :dfn:`digest` av sammankopplingen av de data som hittills "
"matats till den med hjälp av metoderna :meth:`digest()<hash.digest>` eller :"
"meth:`hexdigest()<hash.hexdigest>`."

msgid ""
"To allow multithreading, the Python :term:`GIL` is released while computing "
"a hash supplied more than 2047 bytes of data at once in its constructor or :"
"meth:`.update<hash.update>` method."
msgstr ""
"För att möjliggöra multithreading släpps Python :term:`GIL` när en hash "
"beräknas som levererar mer än 2047 byte data samtidigt i sin konstruktor "
"eller :meth:`.update<hash.update>`-metod."

msgid ""
"Constructors for hash algorithms that are always present in this module are :"
"func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:"
"`sha3_512`, :func:`shake_128`, :func:`shake_256`, :func:`blake2b`, and :func:"
"`blake2s`. :func:`md5` is normally available as well, though it may be "
"missing or blocked if you are using a rare \"FIPS compliant\" build of "
"Python. These correspond to :data:`algorithms_guaranteed`."
msgstr ""
"Konstruktörer för hashalgoritmer som alltid finns i denna modul är :func:"
"`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:`sha512`, :"
"func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:`sha3_512`, :func:"
"`shake_128`, :func:`shake_256`, :func:`blake2b`, och :func:`blake2s`. :func:"
"`md5` är normalt också tillgänglig, men den kan saknas eller vara blockerad "
"om du använder en sällsynt \"FIPS-kompatibel\" version av Python. Dessa "
"motsvarar :data:`algorithms_guaranteed`."

msgid ""
"Additional algorithms may also be available if your Python distribution's :"
"mod:`hashlib` was linked against a build of OpenSSL that provides others. "
"Others *are not guaranteed available* on all installations and will only be "
"accessible by name via :func:`new`.  See :data:`algorithms_available`."
msgstr ""
"Ytterligare algoritmer kan också vara tillgängliga om din Python-"
"distributions :mod:`hashlib` länkades mot en version av OpenSSL som "
"tillhandahåller andra. Andra *är inte garanterat tillgängliga* på alla "
"installationer och kommer endast att vara tillgängliga med namn via :func:"
"`new`.  Se :data:`algorithms_available`."

msgid ""
"Some algorithms have known hash collision weaknesses (including MD5 and "
"SHA1). Refer to `Attacks on cryptographic hash algorithms`_ and the `hashlib-"
"seealso`_ section at the end of this document."
msgstr ""
"Vissa algoritmer har kända svagheter när det gäller hashkollisioner (bland "
"annat MD5 och SHA1). Se `Attacker mot kryptografiska hashalgoritmer`_ och "
"avsnittet `hashlib-seealso`_ i slutet av det här dokumentet."

msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, :"
"func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` were "
"added. :func:`blake2b` and :func:`blake2s` were added."
msgstr ""
"SHA3 (Keccak) och SHAKE-konstruktörerna :func:`sha3_224`, :func:`sha3_256`, :"
"func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` "
"lades till. :func:`blake2b` och :func:`blake2s` lades till."

msgid ""
"All hashlib constructors take a keyword-only argument *usedforsecurity* with "
"default value ``True``. A false value allows the use of insecure and blocked "
"hashing algorithms in restricted environments. ``False`` indicates that the "
"hashing algorithm is not used in a security context, e.g. as a non-"
"cryptographic one-way compression function."
msgstr ""
"Alla hashlib-konstruktörer tar ett nyckelordsargument *usedforsecurity* med "
"standardvärdet ``True``. Ett falskt värde gör det möjligt att använda osäkra "
"och blockerade hashalgoritmer i begränsade miljöer. ``False`` anger att "
"hashingalgoritmen inte används i säkerhetssammanhang, t.ex. som en icke-"
"kryptografisk envägskomprimeringsfunktion."

msgid "Hashlib now uses SHA3 and SHAKE from OpenSSL if it provides it."
msgstr ""
"Hashlib använder nu SHA3 och SHAKE från OpenSSL om det finns tillgängligt."

msgid ""
"For any of the MD5, SHA1, SHA2, or SHA3 algorithms that the linked OpenSSL "
"does not provide we fall back to a verified implementation from the `HACL\\* "
"project`_."
msgstr ""
"För någon av algoritmerna MD5, SHA1, SHA2 eller SHA3 som den länkade OpenSSL "
"inte tillhandahåller faller vi tillbaka på en verifierad implementering från "
"`HACL\\*-projektet`_."

msgid "Usage"
msgstr "Användning"

msgid ""
"To obtain the digest of the byte string ``b\"Nobody inspects the spammish "
"repetition\"``::"
msgstr ""
"För att erhålla digest av bytesträngen ``b\"Ingen inspekterar den spammiga "
"upprepningen\"``::"

msgid ""
">>> import hashlib\n"
">>> m = hashlib.sha256()\n"
">>> m.update(b\"Nobody inspects\")\n"
">>> m.update(b\" the spammish repetition\")\n"
">>> m.digest()\n"
"b'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\"
"\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:"
"\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'\n"
">>> m.hexdigest()\n"
"'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'"
msgstr ""
">>> import hashlib\n"
">>> m = hashlib.sha256()\n"
">>> m.update(b\"Nobody inspects\")\n"
">>> m.update(b\" the spammish repetition\")\n"
">>> m.digest()\n"
"b'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\"
"\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:"
"\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'\n"
">>> m.hexdigest()\n"
"'031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'"

msgid "More condensed:"
msgstr "Mer komprimerad:"

msgid "Constructors"
msgstr "Konstruktörer"

msgid ""
"Is a generic constructor that takes the string *name* of the desired "
"algorithm as its first parameter.  It also exists to allow access to the "
"above listed hashes as well as any other algorithms that your OpenSSL "
"library may offer."
msgstr ""
"Är en generisk konstruktör som tar strängen *namn* för den önskade "
"algoritmen som sin första parameter.  Den finns också för att ge tillgång "
"till de ovan listade hasharna samt alla andra algoritmer som ditt OpenSSL-"
"bibliotek kan erbjuda."

msgid "Using :func:`new` with an algorithm name:"
msgstr "Använda :func:`new` med ett algoritmnamn:"

msgid ""
"Named constructors such as these are faster than passing an algorithm name "
"to :func:`new`."
msgstr ""
"Namngivna konstruktörer som dessa är snabbare än att skicka ett algoritmnamn "
"till :func:`new`."

msgid "Attributes"
msgstr "Attribut"

msgid "Hashlib provides the following constant module attributes:"
msgstr "Hashlib tillhandahåller följande attribut för konstanta moduler:"

msgid ""
"A set containing the names of the hash algorithms guaranteed to be supported "
"by this module on all platforms.  Note that 'md5' is in this list despite "
"some upstream vendors offering an odd \"FIPS compliant\" Python build that "
"excludes it."
msgstr ""
"En uppsättning som innehåller namnen på de hashalgoritmer som garanterat "
"stöds av denna modul på alla plattformar.  Observera att 'md5' finns med i "
"denna lista trots att vissa uppströmsleverantörer erbjuder en udda \"FIPS-"
"kompatibel\" Python-byggnad som utesluter den."

msgid ""
"A set containing the names of the hash algorithms that are available in the "
"running Python interpreter.  These names will be recognized when passed to :"
"func:`new`.  :attr:`algorithms_guaranteed` will always be a subset.  The "
"same algorithm may appear multiple times in this set under different names "
"(thanks to OpenSSL)."
msgstr ""
"En uppsättning som innehåller namnen på de hashalgoritmer som är "
"tillgängliga i den Python-tolk som körs.  Dessa namn kommer att kännas igen "
"när de skickas till :func:`new`. :attr:`algorithms_guaranteed` kommer alltid "
"att vara en delmängd.  Samma algoritm kan förekomma flera gånger i denna "
"uppsättning under olika namn (tack vare OpenSSL)."

msgid "Hash Objects"
msgstr "Hash-objekt"

msgid ""
"The following values are provided as constant attributes of the hash objects "
"returned by the constructors:"
msgstr ""
"Följande värden tillhandahålls som konstanta attribut för de hash-objekt som "
"returneras av konstruktörerna:"

msgid "The size of the resulting hash in bytes."
msgstr "Storleken på den resulterande hashen i bytes."

msgid "The internal block size of the hash algorithm in bytes."
msgstr "Den interna blockstorleken för hashalgoritmen i bytes."

msgid "A hash object has the following attributes:"
msgstr "Ett hash-objekt har följande attribut:"

msgid ""
"The canonical name of this hash, always lowercase and always suitable as a "
"parameter to :func:`new` to create another hash of this type."
msgstr ""
"Det kanoniska namnet på denna hash, alltid gemener och alltid lämpligt som "
"parameter till :func:`new` för att skapa en annan hash av denna typ."

msgid ""
"The name attribute has been present in CPython since its inception, but "
"until Python 3.4 was not formally specified, so may not exist on some "
"platforms."
msgstr ""
"Namnattributet har funnits i CPython sedan starten, men fram till Python 3.4 "
"var det inte formellt specificerat, så det kanske inte finns på vissa "
"plattformar."

msgid "A hash object has the following methods:"
msgstr "Ett hash-objekt har följande metoder:"

msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls "
"are equivalent to a single call with the concatenation of all the arguments: "
"``m.update(a); m.update(b)`` is equivalent to ``m.update(a+b)``."
msgstr ""
"Uppdaterar hash-objektet med :term:`bytesliknande objekt`. Upprepade anrop "
"är likvärdiga med ett enda anrop med en sammankoppling av alla argument: ``m."
"update(a); m.update(b)`` är likvärdigt med ``m.update(a+b)``."

msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size :attr:`digest_size` which may contain bytes "
"in the whole range from 0 to 255."
msgstr ""
"Returnerar sammanfattningen av de data som hittills skickats till :meth:"
"`update`-metoden. Detta är ett bytesobjekt av storleken :attr:`digest_size` "
"som kan innehålla bytes i hela intervallet 0 till 255."

msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value safely in email or other non-binary environments."
msgstr ""
"Som :meth:`digest` förutom att digestet returneras som ett strängobjekt med "
"dubbel längd, som endast innehåller hexadecimala siffror.  Detta kan "
"användas för att utbyta värdet på ett säkert sätt i e-post eller andra icke-"
"binära miljöer."

msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to "
"efficiently compute the digests of data sharing a common initial substring."
msgstr ""
"Returnerar en kopia (\"klon\") av hash-objektet.  Detta kan användas för att "
"effektivt beräkna digests av data som delar en gemensam initial substring."

msgid "SHAKE variable length digests"
msgstr "SHAKE-digitaliseringar med variabel längd"

msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable "
"length digests with length_in_bits//2 up to 128 or 256 bits of security. As "
"such, their digest methods require a length. Maximum length is not limited "
"by the SHAKE algorithm."
msgstr ""
"Algoritmerna :func:`shake_128` och :func:`shake_256` ger digests av "
"varierande längd med length_in_bits//2 upp till 128 eller 256 bitars "
"säkerhet. Därför kräver deras digest-metoder en längd. Den maximala längden "
"begränsas inte av SHAKE-algoritmen."

msgid ""
"Return the digest of the data passed to the :meth:`~hash.update` method so "
"far. This is a bytes object of size *length* which may contain bytes in the "
"whole range from 0 to 255."
msgstr ""
"Returnerar sammanfattningen av de data som hittills skickats till metoden :"
"meth:`~hash.update`. Detta är ett bytesobjekt av storleken *length* som kan "
"innehålla bytes i hela intervallet från 0 till 255."

msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value in email or other non-binary environments."
msgstr ""
"Som :meth:`digest` förutom att digestet returneras som ett strängobjekt med "
"dubbel längd, som endast innehåller hexadecimala siffror.  Detta kan "
"användas för att utbyta värdet i e-post eller andra icke-binära miljöer."

msgid "Example use:"
msgstr "Exempel på användning:"

msgid "File hashing"
msgstr "Hashning av filer"

msgid ""
"The hashlib module provides a helper function for efficient hashing of a "
"file or file-like object."
msgstr ""
"Modulen hashlib tillhandahåller en hjälpfunktion för effektiv hashing av en "
"fil eller ett filliknande objekt."

msgid ""
"Return a digest object that has been updated with contents of file object."
msgstr ""
"Returnerar ett digest-objekt som har uppdaterats med innehållet i "
"filobjektet."

msgid ""
"*fileobj* must be a file-like object opened for reading in binary mode. It "
"accepts file objects from  builtin :func:`open`, :class:`~io.BytesIO` "
"instances, SocketIO objects from :meth:`socket.socket.makefile`, and "
"similar. *fileobj* must be opened in blocking mode, otherwise a :exc:"
"`BlockingIOError` may be raised."
msgstr ""
"*fileobj* måste vara ett filliknande objekt som öppnas för läsning i binärt "
"läge. Den accepterar filobjekt från inbyggda :func:`open`, :class:`~io."
"BytesIO`-instanser, SocketIO-objekt från :meth:`socket.socket.makefile` och "
"liknande. *fileobj* måste öppnas i blockeringsläge, annars kan ett :exc:"
"`BlockingIOError` uppstå."

msgid ""
"The function may bypass Python's I/O and use the file descriptor from :meth:"
"`~io.IOBase.fileno` directly. *fileobj* must be assumed to be in an unknown "
"state after this function returns or raises. It is up to the caller to close "
"*fileobj*."
msgstr ""
"Funktionen kan förbigå Pythons I/O och använda filbeskrivaren från :meth:"
"`~io.IOBase.fileno` direkt. *fileobj* måste antas vara i ett okänt tillstånd "
"efter att denna funktion returneras eller höjs. Det är upp till den som "
"anropar att stänga *fileobj*."

msgid ""
"*digest* must either be a hash algorithm name as a *str*, a hash "
"constructor, or a callable that returns a hash object."
msgstr ""
"*digest* måste antingen vara ett namn på en hashalgoritm som en *str*, en "
"hashkonstruktör eller en callable som returnerar ett hashobjekt."

msgid "Example:"
msgstr "Exempel:"

msgid ""
"Now raises a :exc:`BlockingIOError` if the file is opened in blocking mode. "
"Previously, spurious null bytes were added to the digest."
msgstr ""
"Ger nu upphov till ett :exc:`BlockingIOError` om filen öppnas i "
"blockeringsläge. Tidigare lades falska nollbytes till i sammanfattningen."

msgid "Key derivation"
msgstr "Härledning av nycklar"

msgid ""
"Key derivation and key stretching algorithms are designed for secure "
"password hashing. Naive algorithms such as ``sha1(password)`` are not "
"resistant against brute-force attacks. A good password hashing function must "
"be tunable, slow, and include a `salt <https://en.wikipedia.org/wiki/"
"Salt_%28cryptography%29>`_."
msgstr ""
"Algoritmer för nyckelderivation och nyckelsträckning är utformade för säker "
"hashing av lösenord. Naiva algoritmer som ``sha1(lösenord)`` är inte "
"motståndskraftiga mot brute-force-attacker. En bra hashfunktion för lösenord "
"måste vara inställbar, långsam och innehålla en `salt <https://en.wikipedia."
"org/wiki/Salt_%28cryptography%29>`_."

msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It "
"uses HMAC as pseudorandom function."
msgstr ""
"Funktionen tillhandahåller PKCS#5 lösenordsbaserad nyckelavledningsfunktion "
"2. Den använder HMAC som pseudorandomfunktion."

msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm for "
"HMAC, e.g. 'sha1' or 'sha256'. *password* and *salt* are interpreted as "
"buffers of bytes. Applications and libraries should limit *password* to a "
"sensible length (e.g. 1024). *salt* should be about 16 or more bytes from a "
"proper source, e.g. :func:`os.urandom`."
msgstr ""
"Strängen *hash_name* är det önskade namnet på hashdigestalgoritmen för HMAC, "
"t.ex. \"sha1\" eller \"sha256\". *password* och *salt* tolkas som buffertar "
"av bytes. Program och bibliotek bör begränsa *password* till en vettig längd "
"(t.ex. 1024). *salt* bör vara cirka 16 eller fler byte från en lämplig "
"källa, t.ex. :func:`os.urandom`."

msgid ""
"The number of *iterations* should be chosen based on the hash algorithm and "
"computing power. As of 2022, hundreds of thousands of iterations of SHA-256 "
"are suggested. For rationale as to why and how to choose what is best for "
"your application, read *Appendix A.2.2* of NIST-SP-800-132_. The answers on "
"the `stackexchange pbkdf2 iterations question`_ explain in detail."
msgstr ""
"Antalet *iterationer* bör väljas baserat på hashalgoritmen och datorkraften. "
"Från och med 2022 föreslås hundratusentals iterationer av SHA-256. För "
"motivering till varför och hur man väljer vad som är bäst för din "
"applikation, läs *Appendix A.2.2* i NIST-SP-800-132_. Svaren på "
"`stackexchange pbkdf2 iterations question`_ förklarar i detalj."

msgid ""
"*dklen* is the length of the derived key in bytes. If *dklen* is ``None`` "
"then the digest size of the hash algorithm *hash_name* is used, e.g. 64 for "
"SHA-512."
msgstr ""
"*dklen* är längden på den härledda nyckeln i byte. Om *dklen* är ``None`` "
"används digeststorleken för hashalgoritmen *hash_name*, t.ex. 64 för SHA-512."

msgid "Function only available when Python is compiled with OpenSSL."
msgstr "Funktionen är endast tillgänglig när Python är kompilerad med OpenSSL."

msgid ""
"Function now only available when Python is built with OpenSSL. The slow pure "
"Python implementation has been removed."
msgstr ""
"Funktionen är nu endast tillgänglig när Python är byggt med OpenSSL. Den "
"långsamma rena Python-implementationen har tagits bort."

msgid ""
"The function provides scrypt password-based key derivation function as "
"defined in :rfc:`7914`."
msgstr ""
"Funktionen tillhandahåller en lösenordsbaserad nyckelavledningsfunktion för "
"scrypt enligt definitionen i :rfc:`7914`."

msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like "
"object>`.  Applications and libraries should limit *password* to a sensible "
"length (e.g. 1024).  *salt* should be about 16 or more bytes from a proper "
"source, e.g. :func:`os.urandom`."
msgstr ""
"*password* och *salt* måste vara :term:`bytesliknande objekt <bytes-like "
"object>`.  Program och bibliotek bör begränsa *password* till en rimlig "
"längd (t.ex. 1024).  *salt* bör vara cirka 16 eller fler byte från en "
"lämplig källa, t.ex. :func:`os.urandom`."

msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* parallelization "
"factor and *maxmem* limits memory (OpenSSL 1.1.0 defaults to 32 MiB). "
"*dklen* is the length of the derived key in bytes."
msgstr ""
"*n* är kostnadsfaktorn för CPU/minne, *r* blockstorleken, *p* "
"parallelliseringsfaktorn och *maxmem* begränsar minnet (OpenSSL 1.1.0 är 32 "
"MiB som standard). *dklen* är längden på den härledda nyckeln i byte."

msgid "BLAKE2"
msgstr "BLAKE2"

msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that comes "
"in two flavors:"
msgstr ""
"BLAKE2_ är en kryptografisk hashfunktion som definieras i :rfc:`7693` och "
"finns i två varianter:"

msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any size "
"between 1 and 64 bytes,"
msgstr ""
"**BLAKE2b**, optimerad för 64-bitars plattformar och producerar digests i "
"alla storlekar mellan 1 och 64 byte,"

msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of "
"any size between 1 and 32 bytes."
msgstr ""
"**BLAKE2s**, optimerad för 8- till 32-bitars plattformar och producerar "
"digests i alla storlekar mellan 1 och 32 byte."

msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for HMAC_), "
"**salted hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2 stöder **keyed mode** (en snabbare och enklare ersättning för HMAC_), "
"**salted hashing**, **personalization** och **tree hashing**."

msgid ""
"Hash objects from this module follow the API of standard library's :mod:"
"`hashlib` objects."
msgstr ""
"Hash-objekt från den här modulen följer API:et för standardbibliotekets :mod:"
"`hashlib`-objekt."

msgid "Creating hash objects"
msgstr "Skapa hash-objekt"

msgid "New hash objects are created by calling constructor functions:"
msgstr "Nya hash-objekt skapas genom att anropa konstruktörsfunktioner:"

msgid ""
"These functions return the corresponding hash objects for calculating "
"BLAKE2b or BLAKE2s. They optionally take these general parameters:"
msgstr ""
"Dessa funktioner returnerar motsvarande hash-objekt för beräkning av BLAKE2b "
"eller BLAKE2s. De tar valfritt dessa allmänna parametrar:"

msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like "
"object`.  It can be passed only as positional argument."
msgstr ""
"*data*: den första delen av data som ska hashas, som måste vara :term:"
"`bytesliknande objekt`.  Det kan endast skickas som ett positionellt "
"argument."

msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size*: storlek på utmatad digest i byte."

msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for "
"BLAKE2s)."
msgstr ""
"*key*: nyckel för hashing med nyckel (upp till 64 byte för BLAKE2b, upp till "
"32 byte för BLAKE2s)."

msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr ""
"*salt*: salt för randomiserad hashing (upp till 16 byte för BLAKE2b, upp "
"till 8 byte för BLAKE2s)."

msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes "
"for BLAKE2s)."
msgstr ""
"*person*: personaliseringssträng (upp till 16 byte för BLAKE2b, upp till 8 "
"byte för BLAKE2s)."

msgid "The following table shows limits for general parameters (in bytes):"
msgstr "I följande tabell visas gränser för allmänna parametrar (i byte):"

msgid "Hash"
msgstr "Hash"

msgid "digest_size"
msgstr "digest_size"

msgid "len(key)"
msgstr "len(key)"

msgid "len(salt)"
msgstr "len(salt)"

msgid "len(person)"
msgstr "len(person)"

msgid "BLAKE2b"
msgstr "BLAKE2b"

msgid "64"
msgstr "64"

msgid "16"
msgstr "16"

msgid "BLAKE2s"
msgstr "BLAKE2s"

msgid "32"
msgstr "32"

msgid "8"
msgstr "8"

msgid ""
"BLAKE2 specification defines constant lengths for salt and personalization "
"parameters, however, for convenience, this implementation accepts byte "
"strings of any size up to the specified length. If the length of the "
"parameter is less than specified, it is padded with zeros, thus, for "
"example, ``b'salt'`` and ``b'salt\\x00'`` is the same value. (This is not "
"the case for *key*.)"
msgstr ""
"BLAKE2-specifikationen definierar konstanta längder för salt- och "
"personaliseringsparametrar, men för enkelhetens skull accepterar den här "
"implementationen bytesträngar av valfri storlek upp till den angivna "
"längden. Om parameterns längd är mindre än den angivna fylls den på med "
"nollor, vilket innebär att till exempel ``b'salt'`` och ``b'salt\\x00'`` är "
"samma värde. (Detta är inte fallet för *key*.)"

msgid "These sizes are available as module `constants`_ described below."
msgstr ""
"Dessa storlekar finns tillgängliga som modul `konstanter`_ som beskrivs "
"nedan."

msgid ""
"Constructor functions also accept the following tree hashing parameters:"
msgstr ""
"Konstruktörsfunktionerna accepterar även följande parametrar för "
"trädhashning:"

msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr "*fanout*: fanout (0 till 255, 0 om obegränsad, 1 i sekventiellt läge)."

msgid ""
"*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential "
"mode)."
msgstr ""
"*depth*: trädets maximala djup (1 till 255, 255 om det är obegränsat, 1 i "
"sekventiellt läge)."

msgid ""
"*leaf_size*: maximal byte length of leaf (0 to ``2**32-1``, 0 if unlimited "
"or in sequential mode)."
msgstr ""
"*leaf_size*: maximal byte-längd för bladet (0 till ``2**32-1``, 0 om "
"obegränsat eller i sekventiellt läge)."

msgid ""
"*node_offset*: node offset (0 to ``2**64-1`` for BLAKE2b, 0 to ``2**48-1`` "
"for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode)."
msgstr ""
"*node_offset*: nodoffset (0 till ``2**64-1`` för BLAKE2b, 0 till ``2**48-1`` "
"för BLAKE2s, 0 för den första, längst till vänster, blad eller i "
"sekventiellt läge)."

msgid ""
"*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr ""
"*node_depth*: noddjup (0 till 255, 0 för blad eller i sekventiellt läge)."

msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 "
"in sequential mode)."
msgstr ""
"*inner_size*: inner digest size (0 till 64 för BLAKE2b, 0 till 32 för "
"BLAKE2s, 0 i sekventiellt läge)."

msgid ""
"*last_node*: boolean indicating whether the processed node is the last one "
"(``False`` for sequential mode)."
msgstr ""
"*last_node*: boolean som anger om den bearbetade noden är den sista "
"(``False`` för sekventiellt läge)."

msgid "Explanation of tree mode parameters."
msgstr "Förklaring av parametrar för trädläge."

msgid ""
"See section 2.10 in `BLAKE2 specification <https://www.blake2.net/"
"blake2_20130129.pdf>`_ for comprehensive review of tree hashing."
msgstr ""
"Se avsnitt 2.10 i `BLAKE2-specifikationen <https://www.blake2.net/"
"blake2_20130129.pdf>`_ för en omfattande genomgång av trädhashing."

msgid "Constants"
msgstr "Konstanter"

msgid "Salt length (maximum length accepted by constructors)."
msgstr "Saltlängd (maximal längd som accepteras av konstruktörer)."

msgid ""
"Personalization string length (maximum length accepted by constructors)."
msgstr ""
"Längd på personaliseringssträngen (maximal längd som accepteras av "
"konstruktörerna)."

msgid "Maximum key size."
msgstr "Maximal nyckelstorlek."

msgid "Maximum digest size that the hash function can output."
msgstr "Maximal digest-storlek som hashfunktionen kan mata ut."

msgid "Examples"
msgstr "Exempel"

msgid "Simple hashing"
msgstr "Enkel hashing"

msgid ""
"To calculate hash of some data, you should first construct a hash object by "
"calling the appropriate constructor function (:func:`blake2b` or :func:"
"`blake2s`), then update it with the data by calling :meth:`~hash.update` on "
"the object, and, finally, get the digest out of the object by calling :meth:"
"`~hash.digest` (or :meth:`~hash.hexdigest` for hex-encoded string)."
msgstr ""
"För att beräkna hash för vissa data bör du först konstruera ett hashobjekt "
"genom att anropa lämplig konstruktörsfunktion (:func:`blake2b` eller :func:"
"`blake2s`), sedan uppdatera det med data genom att anropa :meth:`~hash."
"update` på objektet och slutligen få ut digest från objektet genom att "
"anropa :meth:`~hash.digest` (eller :meth:`~hash.hexdigest` för hex-kodad "
"sträng)."

msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to "
"the constructor as the positional argument:"
msgstr ""
"Som en genväg kan du skicka den första delen av data som ska uppdateras "
"direkt till konstruktören som positionsargument:"

msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively "
"update the hash:"
msgstr ""
"Du kan anropa :meth:`hash.update` så många gånger som du behöver för att "
"iterativt uppdatera hashen:"

msgid "Using different digest sizes"
msgstr "Använda olika digest-storlekar"

msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to "
"32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without "
"changing the size of output, we can tell BLAKE2b to produce 20-byte digests:"
msgstr ""
"BLAKE2 har konfigurerbar storlek på sammanställningar upp till 64 byte för "
"BLAKE2b och upp till 32 byte för BLAKE2s. Om vi till exempel vill ersätta "
"SHA-1 med BLAKE2b utan att ändra storleken på utdata kan vi säga till "
"BLAKE2b att producera 20-byte-sammanställningar:"

msgid ""
"Hash objects with different digest sizes have completely different outputs "
"(shorter hashes are *not* prefixes of longer hashes); BLAKE2b and BLAKE2s "
"produce different outputs even if the output length is the same:"
msgstr ""
"Hashobjekt med olika digeststorlekar har helt olika utdata (kortare hash är "
"*inte* prefix av längre hash); BLAKE2b och BLAKE2s ger olika utdata även om "
"utdatalängden är densamma:"

msgid "Keyed hashing"
msgstr "Hashtagning med nyckel"

msgid ""
"Keyed hashing can be used for authentication as a faster and simpler "
"replacement for `Hash-based message authentication code <https://en."
"wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 can be securely used in prefix-MAC "
"mode thanks to the indifferentiability property inherited from BLAKE."
msgstr ""
"Keyed hashing kan användas för autentisering som en snabbare och enklare "
"ersättning för `Hash-based message authentication code <https://en.wikipedia."
"org/wiki/HMAC>`_ (HMAC). BLAKE2 kan användas på ett säkert sätt i prefix-MAC-"
"läge tack vare egenskapen indifferentiability som ärvs från BLAKE."

msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code "
"for message ``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"Detta exempel visar hur man får en (hex-kodad) 128-bitars autentiseringskod "
"för meddelande ``b'meddelandedata'`` med nyckel ``b'pseudorandomnyckel'``::"

msgid ""
">>> from hashlib import blake2b\n"
">>> h = blake2b(key=b'pseudorandom key', digest_size=16)\n"
">>> h.update(b'message data')\n"
">>> h.hexdigest()\n"
"'3d363ff7401e02026f4a4687d4863ced'"
msgstr ""
">>> from hashlib import blake2b\n"
">>> h = blake2b(key=b'pseudorandom key', digest_size=16)\n"
">>> h.update(b'message data')\n"
">>> h.hexdigest()\n"
"'3d363ff7401e02026f4a4687d4863ced'"

msgid ""
"As a practical example, a web application can symmetrically sign cookies "
"sent to users and later verify them to make sure they weren't tampered with::"
msgstr ""
"Som ett praktiskt exempel kan en webbapplikation symmetriskt signera cookies "
"som skickas till användare och senare verifiera dem för att säkerställa att "
"de inte har manipulerats:"

msgid ""
">>> from hashlib import blake2b\n"
">>> from hmac import compare_digest\n"
">>>\n"
">>> SECRET_KEY = b'pseudorandomly generated server secret key'\n"
">>> AUTH_SIZE = 16\n"
">>>\n"
">>> def sign(cookie):\n"
"...     h = blake2b(digest_size=AUTH_SIZE, key=SECRET_KEY)\n"
"...     h.update(cookie)\n"
"...     return h.hexdigest().encode('utf-8')\n"
">>>\n"
">>> def verify(cookie, sig):\n"
"...     good_sig = sign(cookie)\n"
"...     return compare_digest(good_sig, sig)\n"
">>>\n"
">>> cookie = b'user-alice'\n"
">>> sig = sign(cookie)\n"
">>> print(\"{0},{1}\".format(cookie.decode('utf-8'), sig))\n"
"user-alice,b'43b3c982cf697e0c5ab22172d1ca7421'\n"
">>> verify(cookie, sig)\n"
"True\n"
">>> verify(b'user-bob', sig)\n"
"False\n"
">>> verify(cookie, b'0102030405060708090a0b0c0d0e0f00')\n"
"False"
msgstr ""
">>> from hashlib import blake2b\n"
">>> from hmac import compare_digest\n"
">>>\n"
">>> SECRET_KEY = b'pseudorandomly generated server secret key'\n"
">>> AUTH_SIZE = 16\n"
">>>\n"
">>> def sign(cookie):\n"
"...     h = blake2b(digest_size=AUTH_SIZE, key=SECRET_KEY)\n"
"...     h.update(cookie)\n"
"...     return h.hexdigest().encode('utf-8')\n"
">>>\n"
">>> def verify(cookie, sig):\n"
"...     good_sig = sign(cookie)\n"
"...     return compare_digest(good_sig, sig)\n"
">>>\n"
">>> cookie = b'user-alice'\n"
">>> sig = sign(cookie)\n"
">>> print(\"{0},{1}\".format(cookie.decode('utf-8'), sig))\n"
"user-alice,b'43b3c982cf697e0c5ab22172d1ca7421'\n"
">>> verify(cookie, sig)\n"
"True\n"
">>> verify(b'user-bob', sig)\n"
"False\n"
">>> verify(cookie, b'0102030405060708090a0b0c0d0e0f00')\n"
"False"

msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, be "
"used in HMAC construction with :mod:`hmac` module::"
msgstr ""
"Även om det finns ett inbyggt hashningsläge med nyckel kan BLAKE2 "
"naturligtvis användas i HMAC-konstruktion med :mod:`hmac` module::"

msgid ""
">>> import hmac, hashlib\n"
">>> m = hmac.new(b'secret key', digestmod=hashlib.blake2s)\n"
">>> m.update(b'message')\n"
">>> m.hexdigest()\n"
"'e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142'"
msgstr ""
">>> import hmac, hashlib\n"
">>> m = hmac.new(b'secret key', digestmod=hashlib.blake2s)\n"
">>> m.update(b'message')\n"
">>> m.hexdigest()\n"
"'e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142'"

msgid "Randomized hashing"
msgstr "Slumpmässig hashing"

msgid ""
"By setting *salt* parameter users can introduce randomization to the hash "
"function. Randomized hashing is useful for protecting against collision "
"attacks on the hash function used in digital signatures."
msgstr ""
"Genom att ställa in parametern *salt* kan användare införa randomisering i "
"hashfunktionen. Randomiserad hashfunktion är användbar för att skydda mot "
"kollisionsattacker på den hashfunktion som används i digitala signaturer."

msgid ""
"Randomized hashing is designed for situations where one party, the message "
"preparer, generates all or part of a message to be signed by a second party, "
"the message signer. If the message preparer is able to find cryptographic "
"hash function collisions (i.e., two messages producing the same hash value), "
"then they might prepare meaningful versions of the message that would "
"produce the same hash value and digital signature, but with different "
"results (e.g., transferring $1,000,000 to an account, rather than $10). "
"Cryptographic hash functions have been designed with collision resistance as "
"a major goal, but the current concentration on attacking cryptographic hash "
"functions may result in a given cryptographic hash function providing less "
"collision resistance than expected. Randomized hashing offers the signer "
"additional protection by reducing the likelihood that a preparer can "
"generate two or more messages that ultimately yield the same hash value "
"during the digital signature generation process --- even if it is practical "
"to find collisions for the hash function. However, the use of randomized "
"hashing may reduce the amount of security provided by a digital signature "
"when all portions of the message are prepared by the signer."
msgstr ""
"Slumpmässig hashfunktion är avsedd för situationer där en part, den som "
"förbereder meddelandet, genererar hela eller delar av ett meddelande som ska "
"signeras av en annan part, den som signerar meddelandet. Om den som "
"förbereder meddelandet kan hitta kollisioner mellan kryptografiska "
"hashfunktioner (dvs. två meddelanden som ger samma hashvärde) kan han eller "
"hon förbereda meningsfulla versioner av meddelandet som ger samma hashvärde "
"och digitala signatur, men med olika resultat (t.ex. överföring av 1 000 000 "
"USD till ett konto i stället för 10 USD). Kryptografiska hashfunktioner har "
"utformats med kollisionsmotstånd som ett huvudmål, men den nuvarande "
"koncentrationen på att attackera kryptografiska hashfunktioner kan leda till "
"att en viss kryptografisk hashfunktion ger mindre kollisionsmotstånd än "
"förväntat. Slumpmässig hashning ger undertecknaren ytterligare skydd genom "
"att minska sannolikheten för att en förberedare kan generera två eller flera "
"meddelanden som i slutändan ger samma hashvärde under processen för "
"generering av digitala signaturer --- även om det är praktiskt att hitta "
"kollisioner för hashfunktionen. Användningen av randomiserad hashning kan "
"dock minska den säkerhet som en digital signatur ger när alla delar av "
"meddelandet förbereds av undertecknaren."

msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/pubs/sp/800/106/final>`_)"
msgstr ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/pubs/sp/800/106/final>`_)"

msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function "
"during initialization, rather than as an input to each compression function."
msgstr ""
"I BLAKE2 behandlas saltet som en engångsingång till hashfunktionen under "
"initialiseringen, i stället för som en ingång till varje "
"komprimeringsfunktion."

msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-purpose "
"cryptographic hash function, such as SHA-256, is not suitable for hashing "
"passwords.  See `BLAKE2 FAQ <https://www.blake2.net/#qa>`_ for more "
"information."
msgstr ""
"*Salted hashing* (eller bara hashing) med BLAKE2 eller någon annan "
"kryptografisk hashfunktion för allmänt bruk, t.ex. SHA-256, är inte lämplig "
"för hashing av lösenord.  Se `BLAKE2 FAQ <https://www.blake2.net/#qa>`_ för "
"mer information."

msgid "Personalization"
msgstr "Anpassning"

msgid ""
"Sometimes it is useful to force hash function to produce different digests "
"for the same input for different purposes. Quoting the authors of the Skein "
"hash function:"
msgstr ""
"Ibland är det användbart att tvinga hashfunktionen att producera olika "
"sammanställningar för samma indata för olika ändamål. Citerar författarna "
"till Skein-hashfunktionen:"

msgid ""
"We recommend that all application designers seriously consider doing this; "
"we have seen many protocols where a hash that is computed in one part of the "
"protocol can be used in an entirely different part because two hash "
"computations were done on similar or related data, and the attacker can "
"force the application to make the hash inputs the same. Personalizing each "
"hash function used in the protocol summarily stops this type of attack."
msgstr ""
"Vi rekommenderar att alla applikationsdesigners allvarligt överväger att "
"göra detta; vi har sett många protokoll där en hash som beräknas i en del av "
"protokollet kan användas i en helt annan del eftersom två hashberäkningar "
"gjordes på liknande eller relaterade data, och angriparen kan tvinga "
"applikationen att göra hashingångarna desamma. Genom att anpassa varje "
"hashfunktion som används i protokollet stoppas den här typen av angrepp."

msgid ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-content/"
"uploads/2016/02/skein.pdf>`_, p. 21)"
msgstr ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-content/"
"uploads/2016/02/skein.pdf>`_, p. 21)"

msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr "BLAKE2 kan anpassas genom att skicka bytes till *person*-argumentet::"

msgid ""
">>> from hashlib import blake2b\n"
">>> FILES_HASH_PERSON = b'MyApp Files Hash'\n"
">>> BLOCK_HASH_PERSON = b'MyApp Block Hash'\n"
">>> h = blake2b(digest_size=32, person=FILES_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4'\n"
">>> h = blake2b(digest_size=32, person=BLOCK_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3'"
msgstr ""
">>> from hashlib import blake2b\n"
">>> FILES_HASH_PERSON = b'MyApp Files Hash'\n"
">>> BLOCK_HASH_PERSON = b'MyApp Block Hash'\n"
">>> h = blake2b(digest_size=32, person=FILES_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4'\n"
">>> h = blake2b(digest_size=32, person=BLOCK_HASH_PERSON)\n"
">>> h.update(b'the same content')\n"
">>> h.hexdigest()\n"
"'cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3'"

msgid ""
"Personalization together with the keyed mode can also be used to derive "
"different keys from a single one."
msgstr ""
"Personalisering tillsammans med keyed mode kan också användas för att "
"härleda olika nycklar från en enda."

msgid "Tree mode"
msgstr "Trädläge"

msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr "Här är ett exempel på hashing av ett minimalt träd med två bladnoder::"

msgid ""
"  10\n"
" /  \\\n"
"00  01"
msgstr ""
"  10\n"
" /  \\\n"
"00  01"

msgid ""
"This example uses 64-byte internal digests, and returns the 32-byte final "
"digest::"
msgstr ""
"I det här exemplet används 64-bytes interna sammanställningar och den "
"slutliga sammanställningen på 32 byte returneras::"

msgid ""
">>> from hashlib import blake2b\n"
">>>\n"
">>> FANOUT = 2\n"
">>> DEPTH = 2\n"
">>> LEAF_SIZE = 4096\n"
">>> INNER_SIZE = 64\n"
">>>\n"
">>> buf = bytearray(6000)\n"
">>>\n"
">>> # Left leaf\n"
"... h00 = blake2b(buf[0:LEAF_SIZE], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=0, last_node=False)\n"
">>> # Right leaf\n"
"... h01 = blake2b(buf[LEAF_SIZE:], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=1, node_depth=0, last_node=True)\n"
">>> # Root node\n"
"... h10 = blake2b(digest_size=32, fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=1, last_node=True)\n"
">>> h10.update(h00.digest())\n"
">>> h10.update(h01.digest())\n"
">>> h10.hexdigest()\n"
"'3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa'"
msgstr ""
">>> from hashlib import blake2b\n"
">>>\n"
">>> FANOUT = 2\n"
">>> DEPTH = 2\n"
">>> LEAF_SIZE = 4096\n"
">>> INNER_SIZE = 64\n"
">>>\n"
">>> buf = bytearray(6000)\n"
">>>\n"
">>> # Left leaf\n"
"... h00 = blake2b(buf[0:LEAF_SIZE], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=0, last_node=False)\n"
">>> # Right leaf\n"
"... h01 = blake2b(buf[LEAF_SIZE:], fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=1, node_depth=0, last_node=True)\n"
">>> # Root node\n"
"... h10 = blake2b(digest_size=32, fanout=FANOUT, depth=DEPTH,\n"
"...               leaf_size=LEAF_SIZE, inner_size=INNER_SIZE,\n"
"...               node_offset=0, node_depth=1, last_node=True)\n"
">>> h10.update(h00.digest())\n"
">>> h10.update(h01.digest())\n"
">>> h10.hexdigest()\n"
"'3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa'"

msgid "Credits"
msgstr "Tack till"

msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist BLAKE_ "
"created by *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, and "
"*Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_ designades av *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn* och *Christian Winnerlein* baserat på SHA-3_-finalisten "
"BLAKE_ skapad av *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier* och "
"*Raphael C.-W. Phan*."

msgid ""
"It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  "
"Bernstein*."
msgstr ""
"Den använder kärnalgoritmen från ChaCha_-chiffer som designats av *Daniel J. "
"Bernstein*."

msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by "
"*Dmitry Chestnykh* based on C implementation written by *Samuel Neves*. The "
"documentation was copied from pyblake2_ and written by *Dmitry Chestnykh*."
msgstr ""
"Stdlib-implementeringen är baserad på modulen pyblake2_. Den skrevs av "
"*Dmitry Chestnykh* baserat på C-implementering skriven av *Samuel Neves*. "
"Dokumentationen kopierades från pyblake2_ och skrevs av *Dmitry Chestnykh*."

msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr "C-koden har delvis skrivits om för Python av *Christian Heimes*."

msgid ""
"The following public domain dedication applies for both C hash function "
"implementation, extension code, and this documentation:"
msgstr ""
"Följande public domain-dedikation gäller för både implementeringen av C-"
"hashfunktionen, tilläggskoden och denna dokumentation:"

msgid ""
"To the extent possible under law, the author(s) have dedicated all copyright "
"and related and neighboring rights to this software to the public domain "
"worldwide. This software is distributed without any warranty."
msgstr ""
"I den utsträckning det är möjligt enligt lag har författaren/författarna "
"tillägnat all upphovsrätt och alla närstående rättigheter till denna "
"programvara till den offentliga domänen över hela världen. Denna programvara "
"distribueras utan någon garanti."

msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along "
"with this software. If not, see https://creativecommons.org/publicdomain/"
"zero/1.0/."
msgstr ""
"Du bör ha fått en kopia av CC0 Public Domain Dedication tillsammans med den "
"här programvaran. Om inte, se https://creativecommons.org/publicdomain/"
"zero/1.0/."

msgid ""
"The following people have helped with development or contributed their "
"changes to the project and the public domain according to the Creative "
"Commons Public Domain Dedication 1.0 Universal:"
msgstr ""
"Följande personer har hjälpt till med utvecklingen eller bidragit med sina "
"ändringar till projektet och den offentliga domänen enligt Creative Commons "
"Public Domain Dedication 1.0 Universal:"

msgid "*Alexandr Sokolovskiy*"
msgstr "*Alexandr Sokolovskiy*"

msgid "Module :mod:`hmac`"
msgstr "Modul :mod:`hmac`"

msgid "A module to generate message authentication codes using hashes."
msgstr ""
"En modul för att generera autentiseringskoder för meddelanden med hjälp av "
"hash."

msgid "Module :mod:`base64`"
msgstr "Modul :mod:`base64`"

msgid "Another way to encode binary hashes for non-binary environments."
msgstr "Ett annat sätt att koda binära hashar för icke-binära miljöer."

msgid "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"
msgstr "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"

msgid "The FIPS 180-4 publication on Secure Hash Algorithms."
msgstr "FIPS 180-4-publikationen om säkra hashalgoritmer."

msgid "https://csrc.nist.gov/pubs/fips/202/final"
msgstr "https://csrc.nist.gov/pubs/fips/202/final"

msgid "The FIPS 202 publication on the SHA-3 Standard."
msgstr "FIPS 202-publikationen om SHA-3-standarden."

msgid "https://www.blake2.net/"
msgstr "https://www.blake2.net/"

msgid "Official BLAKE2 website."
msgstr "Officiell webbplats för BLAKE2."

msgid "https://en.wikipedia.org/wiki/Cryptographic_hash_function"
msgstr "https://en.wikipedia.org/wiki/Cryptographic_hash_function"

msgid ""
"Wikipedia article with information on which algorithms have known issues and "
"what that means regarding their use."
msgstr ""
"Wikipedia-artikel med information om vilka algoritmer som har kända problem "
"och vad det innebär för användningen av dem."

msgid "https://www.ietf.org/rfc/rfc8018.txt"
msgstr "https://www.ietf.org/rfc/rfc8018.txt"

msgid "PKCS #5: Password-Based Cryptography Specification Version 2.1"
msgstr "PKCS #5: Specifikation för lösenordsbaserad kryptografi version 2.1"

msgid ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"
msgstr ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"

msgid "NIST Recommendation for Password-Based Key Derivation."
msgstr "NIST:s rekommendation för lösenordsbaserad nyckelavledning."

msgid "message digest, MD5"
msgstr "sammandragning av meddelanden, MD5"

msgid ""
"secure hash algorithm, SHA1, SHA2, SHA224, SHA256, SHA384, SHA512, SHA3, "
"Shake, Blake2"
msgstr ""
"säker hashalgoritm, SHA1, SHA2, SHA224, SHA256, SHA384, SHA512, SHA3, Shake, "
"Blake2"

msgid "OpenSSL"
msgstr "OpenSSL"

msgid "(use in module hashlib)"
msgstr "(användning i modulen hashlib)"

msgid "blake2b, blake2s"
msgstr "blake2b, blake2s"
