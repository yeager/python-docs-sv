# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!graphlib` --- Functionality to operate with graph-like structures"
msgstr ""
":mod:`!graphlib` --- Funktionalitet för att arbeta med graf-liknande "
"strukturer"

msgid "**Source code:** :source:`Lib/graphlib.py`"
msgstr "**Källkod:** :source:`Lib/graphlib.py`"

msgid ""
"Provides functionality to topologically sort a graph of :term:`hashable` "
"nodes."
msgstr ""
"Tillhandahåller funktionalitet för att topologiskt sortera en graf med :term:"
"`hashable`-noder."

msgid ""
"A topological order is a linear ordering of the vertices in a graph such "
"that for every directed edge u -> v from vertex u to vertex v, vertex u "
"comes before vertex v in the ordering. For instance, the vertices of the "
"graph may represent tasks to be performed, and the edges may represent "
"constraints that one task must be performed before another; in this example, "
"a topological ordering is just a valid sequence for the tasks. A complete "
"topological ordering is possible if and only if the graph has no directed "
"cycles, that is, if it is a directed acyclic graph."
msgstr ""
"En topologisk ordning är en linjär ordning av hörnen i en graf så att för "
"varje riktad kant u -> v från hörn u till hörn v kommer hörn u före hörn v i "
"ordningen. Exempelvis kan topparna i grafen representera uppgifter som ska "
"utföras och kanterna kan representera begränsningar som innebär att en "
"uppgift måste utföras före en annan; i det här exemplet är en topologisk "
"ordning bara en giltig sekvens för uppgifterna. En fullständig topologisk "
"ordning är möjlig om och endast om grafen inte har några riktade cykler, det "
"vill säga om den är en riktad acyklisk graf."

msgid ""
"If the optional *graph* argument is provided it must be a dictionary "
"representing a directed acyclic graph where the keys are nodes and the "
"values are iterables of all predecessors of that node in the graph (the "
"nodes that have edges that point to the value in the key). Additional nodes "
"can be added to the graph using the :meth:`~TopologicalSorter.add` method."
msgstr ""
"Om det valfria argumentet *graph* anges måste det vara en ordbok som "
"representerar en riktad acyklisk graf där nycklarna är noder och värdena är "
"iterabler av alla föregångare till den noden i grafen (de noder som har "
"kanter som pekar på värdet i nyckeln). Ytterligare noder kan läggas till i "
"grafen med hjälp av metoden :meth:`~TopologicalSorter.add`."

msgid ""
"In the general case, the steps required to perform the sorting of a given "
"graph are as follows:"
msgstr ""
"I det allmänna fallet är de steg som krävs för att utföra sorteringen av en "
"given graf följande:"

msgid ""
"Create an instance of the :class:`TopologicalSorter` with an optional "
"initial graph."
msgstr ""
"Skapa en instans av :class:`TopologicalSorter` med en valfri initial graf."

msgid "Add additional nodes to the graph."
msgstr "Lägg till ytterligare noder i grafen."

msgid "Call :meth:`~TopologicalSorter.prepare` on the graph."
msgstr "Anropa :meth:`~TopologicalSorter.prepare` på grafen."

msgid ""
"While :meth:`~TopologicalSorter.is_active` is ``True``, iterate over the "
"nodes returned by :meth:`~TopologicalSorter.get_ready` and process them. "
"Call :meth:`~TopologicalSorter.done` on each node as it finishes processing."
msgstr ""
"Medan :meth:`~TopologicalSorter.is_active` är ``True``, iterera över de "
"noder som returneras av :meth:`~TopologicalSorter.get_ready` och bearbeta "
"dem. Anropa :meth:`~TopologicalSorter.done` på varje nod när den är "
"färdigbehandlad."

msgid ""
"In case just an immediate sorting of the nodes in the graph is required and "
"no parallelism is involved, the convenience method :meth:`TopologicalSorter."
"static_order` can be used directly:"
msgstr ""
"Om det bara krävs en omedelbar sortering av noderna i grafen och ingen "
"parallellism är inblandad, kan bekvämlighetsmetoden :meth:`TopologicalSorter."
"static_order` användas direkt:"

msgid ""
">>> graph = {\"D\": {\"B\", \"C\"}, \"C\": {\"A\"}, \"B\": {\"A\"}}\n"
">>> ts = TopologicalSorter(graph)\n"
">>> tuple(ts.static_order())\n"
"('A', 'C', 'B', 'D')"
msgstr ""
">>> graph = {\"D\": {\"B\", \"C\"}, \"C\": {\"A\"}, \"B\": {\"A\"}}\n"
">>> ts = TopologicalSorter(graph)\n"
">>> tuple(ts.static_order())\n"
"('A', 'C', 'B', 'D')"

msgid ""
"The class is designed to easily support parallel processing of the nodes as "
"they become ready. For instance::"
msgstr ""
"Klassen är utformad för att enkelt stödja parallell bearbetning av noderna "
"när de blir klara. Till exempel::"

msgid ""
"topological_sorter = TopologicalSorter()\n"
"\n"
"# Add nodes to 'topological_sorter'...\n"
"\n"
"topological_sorter.prepare()\n"
"while topological_sorter.is_active():\n"
"    for node in topological_sorter.get_ready():\n"
"        # Worker threads or processes take nodes to work on off the\n"
"        # 'task_queue' queue.\n"
"        task_queue.put(node)\n"
"\n"
"    # When the work for a node is done, workers put the node in\n"
"    # 'finalized_tasks_queue' so we can get more nodes to work on.\n"
"    # The definition of 'is_active()' guarantees that, at this point, at\n"
"    # least one node has been placed on 'task_queue' that hasn't yet\n"
"    # been passed to 'done()', so this blocking 'get()' must (eventually)\n"
"    # succeed.  After calling 'done()', we loop back to call 'get_ready()'\n"
"    # again, so put newly freed nodes on 'task_queue' as soon as\n"
"    # logically possible.\n"
"    node = finalized_tasks_queue.get()\n"
"    topological_sorter.done(node)"
msgstr ""
"topological_sorter = TopologicalSorter()\n"
"\n"
"# Add nodes to 'topological_sorter'...\n"
"\n"
"topological_sorter.prepare()\n"
"while topological_sorter.is_active():\n"
"    for node in topological_sorter.get_ready():\n"
"        # Worker threads or processes take nodes to work on off the\n"
"        # 'task_queue' queue.\n"
"        task_queue.put(node)\n"
"\n"
"    # When the work for a node is done, workers put the node in\n"
"    # 'finalized_tasks_queue' so we can get more nodes to work on.\n"
"    # The definition of 'is_active()' guarantees that, at this point, at\n"
"    # least one node has been placed on 'task_queue' that hasn't yet\n"
"    # been passed to 'done()', so this blocking 'get()' must (eventually)\n"
"    # succeed.  After calling 'done()', we loop back to call 'get_ready()'\n"
"    # again, so put newly freed nodes on 'task_queue' as soon as\n"
"    # logically possible.\n"
"    node = finalized_tasks_queue.get()\n"
"    topological_sorter.done(node)"

msgid ""
"Add a new node and its predecessors to the graph. Both the *node* and all "
"elements in *predecessors* must be :term:`hashable`."
msgstr ""
"Lägger till en ny nod och dess föregångare i grafen. Både *node* och alla "
"element i *predecessors* måste vara :term:`hashable`."

msgid ""
"If called multiple times with the same node argument, the set of "
"dependencies will be the union of all dependencies passed in."
msgstr ""
"Om den anropas flera gånger med samma nodargument kommer uppsättningen "
"beroenden att vara en sammanslagning av alla beroenden som skickats in."

msgid ""
"It is possible to add a node with no dependencies (*predecessors* is not "
"provided) or to provide a dependency twice. If a node that has not been "
"provided before is included among *predecessors* it will be automatically "
"added to the graph with no predecessors of its own."
msgstr ""
"Det är möjligt att lägga till en nod utan beroenden (*predecessors* anges "
"inte) eller att ange ett beroende två gånger. Om en nod som inte har "
"tillhandahållits tidigare ingår bland *predecessors* kommer den automatiskt "
"att läggas till i grafen utan egna predecessors."

msgid ""
"Raises :exc:`ValueError` if called after :meth:`~TopologicalSorter.prepare`."
msgstr ""
"Utlöser :exc:`ValueError` om den anropas efter :meth:`~TopologicalSorter."
"prepare`."

msgid ""
"Mark the graph as finished and check for cycles in the graph. If any cycle "
"is detected, :exc:`CycleError` will be raised, but :meth:`~TopologicalSorter."
"get_ready` can still be used to obtain as many nodes as possible until "
"cycles block more progress. After a call to this function, the graph cannot "
"be modified, and therefore no more nodes can be added using :meth:"
"`~TopologicalSorter.add`."
msgstr ""
"Markera grafen som färdig och kontrollera om det finns cykler i grafen. Om "
"någon cykel upptäcks kommer :exc:`CycleError` att anges, men :meth:"
"`~TopologicalSorter.get_ready` kan fortfarande användas för att få så många "
"noder som möjligt tills cyklerna blockerar mer framsteg. Efter ett anrop "
"till denna funktion kan grafen inte modifieras och därför kan inga fler "
"noder läggas till med :meth:`~TopologicalSorter.add`."

msgid ""
"A :exc:`ValueError` will be raised if the sort has been started by :meth:`~."
"static_order` or :meth:`~.get_ready`."
msgstr ""
"Ett :exc:`ValueError` kommer att uppstå om sorteringen har startats av :meth:"
"`~.static_order` eller :meth:`~.get_ready`."

msgid ""
"``prepare()`` can now be called more than once as long as the sort has not "
"started. Previously this raised :exc:`ValueError`."
msgstr ""
"``prepare()`` kan nu anropas mer än en gång så länge som sorteringen inte "
"har startat. Tidigare gav detta upphov till :exc:`ValueError`."

msgid ""
"Returns ``True`` if more progress can be made and ``False`` otherwise. "
"Progress can be made if cycles do not block the resolution and either there "
"are still nodes ready that haven't yet been returned by :meth:"
"`TopologicalSorter.get_ready` or the number of nodes marked :meth:"
"`TopologicalSorter.done` is less than the number that have been returned by :"
"meth:`TopologicalSorter.get_ready`."
msgstr ""
"Returnerar ``True`` om fler framsteg kan göras och ``False`` annars. "
"Framsteg kan göras om cykler inte blockerar upplösningen och antingen finns "
"det fortfarande noder redo som ännu inte har returnerats av :meth:"
"`TopologicalSorter.get_ready` eller så är antalet noder som markerats med :"
"meth:`TopologicalSorter.done` mindre än antalet som har returnerats av :meth:"
"`TopologicalSorter.get_ready`."

msgid ""
"The :meth:`~object.__bool__` method of this class defers to this function, "
"so instead of::"
msgstr ""
"Metoden :meth:`~object.__bool__` i denna klass defererar till denna "
"funktion, så istället för::"

msgid ""
"if ts.is_active():\n"
"    ..."
msgstr ""
"om ts.is_active():\n"
"    ..."

msgid "it is possible to simply do::"
msgstr "är det möjligt att helt enkelt göra::"

msgid ""
"if ts:\n"
"    ..."
msgstr ""
"om ts:\n"
"    ..."

msgid ""
"Raises :exc:`ValueError` if called without calling :meth:`~TopologicalSorter."
"prepare` previously."
msgstr ""
"Utlöser :exc:`ValueError` om den anropas utan att tidigare ha anropat :meth:"
"`~TopologicalSorter.prepare`."

msgid ""
"Marks a set of nodes returned by :meth:`TopologicalSorter.get_ready` as "
"processed, unblocking any successor of each node in *nodes* for being "
"returned in the future by a call to :meth:`TopologicalSorter.get_ready`."
msgstr ""
"Markerar en uppsättning noder som returnerats av :meth:`TopologicalSorter."
"get_ready` som bearbetade, vilket frigör eventuella efterföljare till varje "
"nod i *nodes* för att returneras i framtiden genom ett anrop till :meth:"
"`TopologicalSorter.get_ready`."

msgid ""
"Raises :exc:`ValueError` if any node in *nodes* has already been marked as "
"processed by a previous call to this method or if a node was not added to "
"the graph by using :meth:`TopologicalSorter.add`, if called without calling :"
"meth:`~TopologicalSorter.prepare` or if node has not yet been returned by :"
"meth:`~TopologicalSorter.get_ready`."
msgstr ""
"Utlöser :exc:`ValueError` om någon nod i *nodes* redan har markerats som "
"bearbetad av ett tidigare anrop till denna metod eller om en nod inte lades "
"till i grafen med hjälp av :meth:`TopologicalSorter.add`, om den anropades "
"utan anrop till :meth:`~TopologicalSorter.prepare` eller om noden ännu inte "
"har returnerats av :meth:`~TopologicalSorter.get_ready`."

msgid ""
"Returns a ``tuple`` with all the nodes that are ready. Initially it returns "
"all nodes with no predecessors, and once those are marked as processed by "
"calling :meth:`TopologicalSorter.done`, further calls will return all new "
"nodes that have all their predecessors already processed. Once no more "
"progress can be made, empty tuples are returned."
msgstr ""
"Returnerar en ``tuple`` med alla noder som är klara. Initialt returneras "
"alla noder utan föregångare, och när dessa har markerats som bearbetade "
"genom att anropa :meth:`TopologicalSorter.done`, kommer ytterligare anrop "
"att returnera alla nya noder som har alla sina föregångare redan bearbetade. "
"När inga fler framsteg kan göras returneras tomma tupler."

msgid ""
"Returns an iterator object which will iterate over nodes in a topological "
"order. When using this method, :meth:`~TopologicalSorter.prepare` and :meth:"
"`~TopologicalSorter.done` should not be called. This method is equivalent "
"to::"
msgstr ""
"Returnerar ett iteratorobjekt som itererar över noder i en topologisk "
"ordning. När denna metod används ska :meth:`~TopologicalSorter.prepare` och :"
"meth:`~TopologicalSorter.done` inte anropas. Denna metod är likvärdig med::"

msgid ""
"def static_order(self):\n"
"    self.prepare()\n"
"    while self.is_active():\n"
"        node_group = self.get_ready()\n"
"        yield from node_group\n"
"        self.done(*node_group)"
msgstr ""
"def static_order(self):\n"
"    self.prepare()\n"
"    while self.is_active():\n"
"        node_group = self.get_ready()\n"
"        yield from node_group\n"
"        self.done(*node_group)"

msgid ""
"The particular order that is returned may depend on the specific order in "
"which the items were inserted in the graph. For example:"
msgstr ""
"Den särskilda ordning som returneras kan bero på den särskilda ordning i "
"vilken posterna infogades i grafen. Till exempel:"

msgid ""
">>> ts = TopologicalSorter()\n"
">>> ts.add(3, 2, 1)\n"
">>> ts.add(1, 0)\n"
">>> print([*ts.static_order()])\n"
"[2, 0, 1, 3]\n"
"\n"
">>> ts2 = TopologicalSorter()\n"
">>> ts2.add(1, 0)\n"
">>> ts2.add(3, 2, 1)\n"
">>> print([*ts2.static_order()])\n"
"[0, 2, 1, 3]"
msgstr ""
">>> ts = TopologicalSorter()\n"
">>> ts.add(3, 2, 1)\n"
">>> ts.add(1, 0)\n"
">>> print([*ts.static_order()])\n"
"[2, 0, 1, 3]\n"
"\n"
">>> ts2 = TopologicalSorter()\n"
">>> ts2.add(1, 0)\n"
">>> ts2.add(3, 2, 1)\n"
">>> print([*ts2.static_order()])\n"
"[0, 2, 1, 3]"

msgid ""
"This is due to the fact that \"0\" and \"2\" are in the same level in the "
"graph (they would have been returned in the same call to :meth:"
"`~TopologicalSorter.get_ready`) and the order between them is determined by "
"the order of insertion."
msgstr ""
"Detta beror på att \"0\" och \"2\" befinner sig på samma nivå i grafen (de "
"skulle ha returnerats i samma anrop till :meth:`~TopologicalSorter."
"get_ready`) och ordningen mellan dem bestäms av den ordning i vilken de "
"infogades."

msgid "If any cycle is detected, :exc:`CycleError` will be raised."
msgstr "Om någon cykel upptäcks kommer :exc:`CycleError` att tas upp."

msgid "Exceptions"
msgstr "Undantag"

msgid "The :mod:`graphlib` module defines the following exception classes:"
msgstr "Modulen :mod:`graphlib` definierar följande undantagsklasser:"

msgid ""
"Subclass of :exc:`ValueError` raised by :meth:`TopologicalSorter.prepare` if "
"cycles exist in the working graph. If multiple cycles exist, only one "
"undefined choice among them will be reported and included in the exception."
msgstr ""
"Underklass till :exc:`ValueError` som orsakas av :meth:`TopologicalSorter."
"prepare` om det finns cykler i arbetsgrafen. Om flera cykler finns, kommer "
"endast ett odefinierat val bland dem att rapporteras och inkluderas i "
"undantaget."

msgid ""
"The detected cycle can be accessed via the second element in the :attr:"
"`~BaseException.args` attribute of the exception instance and consists in a "
"list of nodes, such that each node is, in the graph, an immediate "
"predecessor of the next node in the list. In the reported list, the first "
"and the last node will be the same, to make it clear that it is cyclic."
msgstr ""
"Den upptäckta cykeln kan nås via det andra elementet i attributet :attr:"
"`~BaseException.args` i undantagsinstansen och består av en lista med noder, "
"så att varje nod i grafen är en omedelbar föregångare till nästa nod i "
"listan. I den rapporterade listan kommer den första och den sista noden att "
"vara desamma, för att klargöra att den är cyklisk."
