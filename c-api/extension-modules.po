# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Defining extension modules"
msgstr "Definiera tilläggsmoduler"

msgid ""
"A C extension for CPython is a shared library (for example, a ``.so`` file "
"on Linux, ``.pyd`` DLL on Windows), which is loadable into the Python "
"process (for example, it is compiled with compatible compiler settings), and "
"which exports an :ref:`initialization function <extension-export-hook>`."
msgstr ""
"Ett C-tillägg för CPython är ett delat bibliotek (till exempel en ``.so``-"
"fil på Linux, ``.pyd`` DLL på Windows), som kan laddas in i Python-processen "
"(till exempel kompileras den med kompatibla kompilatorinställningar) och som "
"exporterar en :ref:`initialiseringsfunktion <extension-export-hook>`."

msgid ""
"To be importable by default (that is, by :py:class:`importlib.machinery."
"ExtensionFileLoader`), the shared library must be available on :py:attr:`sys."
"path`, and must be named after the module name plus an extension listed in :"
"py:attr:`importlib.machinery.EXTENSION_SUFFIXES`."
msgstr ""
"För att kunna importeras som standard (dvs. av :py:class:`importlib."
"machinery.ExtensionFileLoader`) måste det delade biblioteket finnas "
"tillgängligt på :py:attr:`sys.path` och ha namn efter modulnamnet plus ett "
"tillägg som anges i :py:attr:`importlib.machinery.EXTENSION_SUFFIXES`."

msgid ""
"Building, packaging and distributing extension modules is best done with "
"third-party tools, and is out of scope of this document. One suitable tool "
"is Setuptools, whose documentation can be found at https://setuptools.pypa."
"io/en/latest/setuptools.html."
msgstr ""
"Att bygga, paketera och distribuera tilläggsmoduler görs bäst med verktyg "
"från tredje part och omfattas inte av det här dokumentet. Ett lämpligt "
"verktyg är Setuptools, vars dokumentation finns på https://setuptools.pypa."
"io/en/latest/setuptools.html."

msgid ""
"Normally, the initialization function returns a module definition "
"initialized using :c:func:`PyModuleDef_Init`. This allows splitting the "
"creation process into several phases:"
msgstr ""
"Normalt returnerar initialiseringsfunktionen en moduldefinition som "
"initierats med hjälp av :c:func:`PyModuleDef_Init`. Detta gör det möjligt "
"att dela upp skapandeprocessen i flera faser:"

msgid ""
"Before any substantial code is executed, Python can determine which "
"capabilities the module supports, and it can adjust the environment or "
"refuse loading an incompatible extension."
msgstr ""
"Innan någon väsentlig kod exekveras kan Python avgöra vilka funktioner som "
"modulen stöder, och den kan anpassa miljön eller vägra att ladda ett "
"inkompatibelt tillägg."

msgid ""
"By default, Python itself creates the module object -- that is, it does the "
"equivalent of :py:meth:`object.__new__` for classes. It also sets initial "
"attributes like :attr:`~module.__package__` and :attr:`~module.__loader__`."
msgstr ""
"Som standard skapar Python själv modulobjektet - det vill säga, det gör "
"motsvarande :py:meth:`object.__new__` för klasser. Den ställer också in "
"initiala attribut som :attr:`~module.__package__` och :attr:`~module."
"__loader__`."

msgid ""
"Afterwards, the module object is initialized using extension-specific code "
"-- the equivalent of :py:meth:`~object.__init__` on classes."
msgstr ""
"Därefter initieras modulobjektet med hjälp av tilläggsspecifik kod -- "
"motsvarande :py:meth:`~object.__init__` för klasser."

msgid ""
"This is called *multi-phase initialization* to distinguish it from the "
"legacy (but still supported) *single-phase initialization* scheme, where the "
"initialization function returns a fully constructed module. See the :ref:"
"`single-phase-initialization section below <single-phase-initialization>` "
"for details."
msgstr ""
"Detta kallas *multifasinitialisering* för att skilja det från det äldre (men "
"fortfarande stödda) *enfasinitialiserings*schemat, där "
"initialiseringsfunktionen returnerar en helt konstruerad modul. Se :ref:"
"`avsnittet om enfasinitialisering under <single-phase-initialization>` för "
"mer information."

msgid "Added support for multi-phase initialization (:pep:`489`)."
msgstr "Lagt till stöd för flerfasinitialisering (:pep:`489`)."

msgid "Multiple module instances"
msgstr "Flera modulinstanser"

msgid ""
"By default, extension modules are not singletons. For example, if the :py:"
"attr:`sys.modules` entry is removed and the module is re-imported, a new "
"module object is created, and typically populated with fresh method and type "
"objects. The old module is subject to normal garbage collection. This "
"mirrors the behavior of pure-Python modules."
msgstr ""
"Som standard är tilläggsmoduler inte singletons. Om till exempel :py:attr:"
"`sys.modules`-posten tas bort och modulen importeras på nytt, skapas ett "
"nytt modulobjekt som vanligtvis fylls på med nya metod- och typobjekt. Den "
"gamla modulen är föremål för normal skräpinsamling. Detta speglar beteendet "
"hos rena Python-moduler."

msgid ""
"Additional module instances may be created in :ref:`sub-interpreters <sub-"
"interpreter-support>` or after Python runtime reinitialization (:c:func:"
"`Py_Finalize` and :c:func:`Py_Initialize`). In these cases, sharing Python "
"objects between module instances would likely cause crashes or undefined "
"behavior."
msgstr ""
"Ytterligare modulinstanser kan skapas i :ref:`sub-interpreters <sub-"
"interpreter-support>` eller efter ominitialisering av Python-körtiden (:c:"
"func:`Py_Finalize` och :c:func:`Py_Initialize`). I dessa fall skulle delning "
"av Python-objekt mellan modulinstanser sannolikt orsaka krascher eller "
"odefinierat beteende."

msgid ""
"To avoid such issues, each instance of an extension module should be "
"*isolated*: changes to one instance should not implicitly affect the others, "
"and all state owned by the module, including references to Python objects, "
"should be specific to a particular module instance. See :ref:`isolating-"
"extensions-howto` for more details and a practical guide."
msgstr ""
"För att undvika sådana problem bör varje instans av en tilläggsmodul vara "
"*isolerad*: ändringar i en instans bör inte implicit påverka de andra, och "
"allt tillstånd som ägs av modulen, inklusive referenser till Python-objekt, "
"bör vara specifikt för en viss modulinstans. Se :ref:`isolating-extensions-"
"howto` för mer information och en praktisk guide."

msgid ""
"A simpler way to avoid these issues is :ref:`raising an error on repeated "
"initialization <isolating-extensions-optout>`."
msgstr ""
"Ett enklare sätt att undvika dessa problem är :ref:`raising an error on "
"repeated initialization <isolating-extensions-optout>`."

msgid ""
"All modules are expected to support :ref:`sub-interpreters <sub-interpreter-"
"support>`, or otherwise explicitly signal a lack of support. This is usually "
"achieved by isolation or blocking repeated initialization, as above. A "
"module may also be limited to the main interpreter using the :c:data:"
"`Py_mod_multiple_interpreters` slot."
msgstr ""
"Alla moduler förväntas ha stöd för :ref:`sub-interpreters <sub-interpreter-"
"support>`, eller på annat sätt uttryckligen signalera att stöd saknas. Detta "
"uppnås vanligtvis genom isolering eller blockering av upprepad "
"initialisering, enligt ovan. En modul kan också begränsas till huvudtolken "
"med hjälp av :c:data:`Py_mod_multiple_interpreters` slot."

msgid "Initialization function"
msgstr "Initialiseringsfunktion"

msgid ""
"The initialization function defined by an extension module has the following "
"signature:"
msgstr ""
"Den initialiseringsfunktion som definieras av en tilläggsmodul har följande "
"signatur:"

msgid ""
"Its name should be :samp:`PyInit_{<name>}`, with ``<name>`` replaced by the "
"name of the module."
msgstr ""
"Dess namn bör vara :samp:`PyInit_{<name>}`, med ``<name>`` ersatt av namnet "
"på modulen."

msgid ""
"For modules with ASCII-only names, the function must instead be named :samp:"
"`PyInit_{<name>}`, with ``<name>`` replaced by the name of the module. When "
"using :ref:`multi-phase-initialization`, non-ASCII module names are allowed. "
"In this case, the initialization function name is :samp:`PyInitU_{<name>}`, "
"with ``<name>`` encoded using Python's *punycode* encoding with hyphens "
"replaced by underscores. In Python:"
msgstr ""
"För moduler med ASCII-namn måste funktionen istället heta :samp:"
"`PyInit_{<name>}`, med ``<name>`` ersatt av modulens namn. Vid användning "
"av :ref:`multi-phase-initialization` är modulnamn som inte är ASCII "
"tillåtna. I detta fall är namnet på initialiseringsfunktionen :samp:"
"`PyInitU_{<name>}`, med ``<name>`` kodat med Pythons *punycode*-kodning med "
"bindestreck ersatta av understreck. I Python:"

msgid ""
"def initfunc_name(name):\n"
"    try:\n"
"        suffix = b'_' + name.encode('ascii')\n"
"    except UnicodeEncodeError:\n"
"        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\n"
"    return b'PyInit' + suffix"
msgstr ""
"def initfunc_name(namn):\n"
"    try:\n"
"        suffix = b'_' + name.encode('ascii')\n"
"    except UnicodeEncodeError:\n"
"        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\n"
"    return b'PyInit' + suffix"

msgid ""
"It is recommended to define the initialization function using a helper macro:"
msgstr ""
"Vi rekommenderar att du definierar initialiseringsfunktionen med hjälp av "
"ett hjälpmakro:"

msgid "Declare an extension module initialization function. This macro:"
msgstr ""
"Deklarera en initialiseringsfunktion för en tilläggsmodul. Detta makro:"

msgid "specifies the :c:expr:`PyObject*` return type,"
msgstr "anger returtypen :c:expr:`PyObject*`,"

msgid "adds any special linkage declarations required by the platform, and"
msgstr ""
"lägger till eventuella speciella länkdeklarationer som krävs av plattformen, "
"och"

msgid "for C++, declares the function as ``extern \"C\"``."
msgstr "för C++, deklarerar funktionen som ``extern \"C\"``."

msgid "For example, a module called ``spam`` would be defined like this::"
msgstr ""
"Till exempel skulle en modul som heter ``spam`` definieras på följande sätt::"

msgid ""
"static struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"
msgstr ""
"static struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    ...\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"

msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple initialization functions. However, importing them requires "
"using symbolic links or a custom importer, because by default only the "
"function corresponding to the filename is found. See the `Multiple modules "
"in one library <https://peps.python.org/pep-0489/#multiple-modules-in-one-"
"library>`__ section in :pep:`489` for details."
msgstr ""
"Det är möjligt att exportera flera moduler från ett enda delat bibliotek "
"genom att definiera flera initialiseringsfunktioner. För att importera dem "
"måste man dock använda symboliska länkar eller en anpassad importör, "
"eftersom endast den funktion som motsvarar filnamnet hittas som standard. Se "
"avsnittet `Flera moduler i ett bibliotek <https://peps.python.org/pep-0489/"
"#multiple-modules-in-one-library>`__ i :pep:`489` för mer information."

msgid ""
"The initialization function is typically the only non-\\ ``static`` item "
"defined in the module's C source."
msgstr ""
"Initialiseringsfunktionen är vanligtvis det enda icke-statiska objektet som "
"definieras i modulens C-källa."

msgid "Multi-phase initialization"
msgstr "Initialisering i flera faser"

msgid ""
"Normally, the :ref:`initialization function <extension-export-hook>` "
"(``PyInit_modulename``) returns a :c:type:`PyModuleDef` instance with non-"
"``NULL`` :c:member:`~PyModuleDef.m_slots`. Before it is returned, the "
"``PyModuleDef`` instance must be initialized using the following function:"
msgstr ""
"Normalt returnerar :ref:`initialiseringsfunktionen <extension-export-hook>` "
"(``PyInit_modulename``) en :c:type:`PyModuleDef`-instans med icke-``NULL`` :"
"c:member:`~PyModuleDef.m_slots`. Innan den returneras måste ``PyModuleDef``-"
"instansen initialiseras med hjälp av följande funktion:"

msgid ""
"Ensure a module definition is a properly initialized Python object that "
"correctly reports its type and a reference count."
msgstr ""
"Säkerställ att en moduldefinition är ett korrekt initialiserat Python-objekt "
"som korrekt rapporterar sin typ och ett referensantal."

msgid "Return *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr ""
"Returnerar *def* som kastas till ``PyObject*``, eller ``NULL`` om ett fel "
"inträffade."

msgid ""
"Calling this function is required for :ref:`multi-phase-initialization`. It "
"should not be used in other contexts."
msgstr ""
"Anrop av denna funktion krävs för :ref:`multi-phase-initialization`. Den bör "
"inte användas i andra sammanhang."

msgid ""
"Note that Python assumes that ``PyModuleDef`` structures are statically "
"allocated. This function may return either a new reference or a borrowed "
"one; this reference must not be released."
msgstr ""
"Observera att Python förutsätter att ``PyModuleDef``-strukturer är statiskt "
"allokerade. Denna funktion kan returnera antingen en ny referens eller en "
"lånad; denna referens får inte släppas."

msgid "Legacy single-phase initialization"
msgstr "Legacy enfasig initialisering"

msgid ""
"Single-phase initialization is a legacy mechanism to initialize extension "
"modules, with known drawbacks and design flaws. Extension module authors are "
"encouraged to use multi-phase initialization instead."
msgstr ""
"Enfasinitialisering är en äldre mekanism för att initiera tilläggsmoduler, "
"med kända nackdelar och designfel. Författarna till tilläggsmoduler uppmanas "
"att använda flerfasinitialisering i stället."

msgid ""
"In single-phase initialization, the :ref:`initialization function <extension-"
"export-hook>` (``PyInit_modulename``) should create, populate and return a "
"module object. This is typically done using :c:func:`PyModule_Create` and "
"functions like :c:func:`PyModule_AddObjectRef`."
msgstr ""
"Vid enfasig initialisering ska :ref:`initialiseringsfunktionen <extension-"
"export-hook>` (``PyInit_modulename``) skapa, fylla på och returnera ett "
"modulobjekt. Detta görs vanligen med :c:func:`PyModule_Create` och "
"funktioner som :c:func:`PyModule_AddObjectRef`."

msgid ""
"Single-phase initialization differs from the :ref:`default <multi-phase-"
"initialization>` in the following ways:"
msgstr ""
"Enfasinitialisering skiljer sig från :ref:`default <multi-phase-"
"initialization>` på följande sätt:"

msgid "Single-phase modules are, or rather *contain*, “singletons”."
msgstr "Enfasmoduler är, eller snarare *innehåller*, \"singletons\"."

msgid ""
"When the module is first initialized, Python saves the contents of the "
"module's ``__dict__`` (that is, typically, the module's functions and types)."
msgstr ""
"När modulen initieras för första gången sparar Python innehållet i modulens "
"``__dict__`` (det vill säga, typiskt sett, modulens funktioner och typer)."

msgid ""
"For subsequent imports, Python does not call the initialization function "
"again. Instead, it creates a new module object with a new ``__dict__``, and "
"copies the saved contents to it. For example, given a single-phase module "
"``_testsinglephase`` [#testsinglephase]_ that defines a function ``sum`` and "
"an exception class ``error``:"
msgstr ""
"För efterföljande import anropar Python inte initialiseringsfunktionen igen. "
"Istället skapas ett nytt modulobjekt med en ny ``__dict__`` och det sparade "
"innehållet kopieras till det. Till exempel, givet en enfasmodul "
"``_testsinglephase`` [#testsinglephase]_ som definierar en funktion ``sum`` "
"och en undantagsklass ``error``:"

msgid ""
">>> import sys\n"
">>> import _testsinglephase as one\n"
">>> del sys.modules['_testsinglephase']\n"
">>> import _testsinglephase as two\n"
">>> one is two\n"
"False\n"
">>> one.__dict__ is two.__dict__\n"
"False\n"
">>> one.sum is two.sum\n"
"True\n"
">>> one.error is two.error\n"
"True"
msgstr ""
">>> import sys\n"
">>> import _testsinglephase as one\n"
">>> del sys.modules['_testsinglephase']\n"
">>> import _testsinglephase as two\n"
">>> one is two\n"
"False\n"
">>> one.__dict__ is two.__dict__\n"
"False\n"
">>> one.sum is two.sum\n"
"True\n"
">>> one.error is two.error\n"
"True"

msgid ""
"The exact behavior should be considered a CPython implementation detail."
msgstr ""
"Det exakta beteendet bör betraktas som en detalj i CPython-implementeringen."

msgid ""
"To work around the fact that ``PyInit_modulename`` does not take a *spec* "
"argument, some state of the import machinery is saved and applied to the "
"first suitable module created during the ``PyInit_modulename`` call. "
"Specifically, when a sub-module is imported, this mechanism prepends the "
"parent package name to the name of the module."
msgstr ""
"För att kringgå det faktum att ``PyInit_modulename`` inte tar ett *spec*-"
"argument, sparas en del av importmaskineriet och tillämpas på den första "
"lämpliga modulen som skapas under ``PyInit_modulename``-anropet. Specifikt, "
"när en undermodul importeras, preponderar denna mekanism det överordnade "
"paketnamnet till modulens namn."

msgid ""
"A single-phase ``PyInit_modulename`` function should create “its” module "
"object as soon as possible, before any other module objects can be created."
msgstr ""
"En enfasig funktion av typen ``PyInit_modulename`` bör skapa \"sitt\" "
"modulobjekt så snart som möjligt, innan några andra modulobjekt kan skapas."

msgid "Non-ASCII module names (``PyInitU_modulename``) are not supported."
msgstr "Modulnamn som inte är ASCII (``PyInitU_modulename``) stöds inte."

msgid ""
"Single-phase modules support module lookup functions like :c:func:"
"`PyState_FindModule`."
msgstr ""
"Enfasmoduler stöder funktioner för moduluppslagning som :c:func:"
"`PyState_FindModule`."

msgid ""
"``_testsinglephase`` is an internal module used in CPython's self-test "
"suite; your installation may or may not include it."
msgstr ""
"``_testsinglephase`` är en intern modul som används i CPythons "
"självtestsvit; din installation kanske eller kanske inte innehåller den."
