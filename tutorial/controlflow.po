# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "More Control Flow Tools"
msgstr "Fler verktyg för kontrollflöde"

msgid ""
"As well as the :keyword:`while` statement just introduced, Python uses a few "
"more that we will encounter in this chapter."
msgstr ""
"Förutom :keyword:`while` som just introducerades använder Python några fler "
"som vi kommer att stöta på i det här kapitlet."

msgid ":keyword:`!if` Statements"
msgstr ":keyword:`!if` Statements"

msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` statement.  "
"For example::"
msgstr ""
"Den kanske mest välkända typen av uttalande är :keyword:`if`-satsen.  Till "
"exempel::"

msgid ""
">>> x = int(input(\"Please enter an integer: \"))\n"
"Please enter an integer: 42\n"
">>> if x < 0:\n"
"...     x = 0\n"
"...     print('Negative changed to zero')\n"
"... elif x == 0:\n"
"...     print('Zero')\n"
"... elif x == 1:\n"
"...     print('Single')\n"
"... else:\n"
"...     print('More')\n"
"...\n"
"More"
msgstr ""
">>> x = int(input(\"Vänligen ange ett heltal: \"))\n"
"Vänligen ange ett heltal: 42\n"
">>> om x < 0:\n"
"... x = 0\n"
"... print('Negativt värde ändrat till noll')\n"
"... elif x == 0:\n"
"... print('Noll')\n"
"... elif x == 1:\n"
"... print('Enkel')\n"
"... annat:\n"
"... print('Fler')\n"
"...\n"
"Mer"

msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`!elif`' is short for 'else if', "
"and is useful to avoid excessive indentation.  An  :keyword:`!if` ... :"
"keyword:`!elif` ... :keyword:`!elif` ... sequence is a substitute for the "
"``switch`` or ``case`` statements found in other languages."
msgstr ""
"Det kan finnas noll eller fler :keyword:`elif`-delar, och :keyword:`else`-"
"delen är valfri.  Nyckelordet ':keyword:`!elif`' är en förkortning för 'else "
"if', och är användbart för att undvika överdriven indragning.  En :keyword:`!"
"if` ... :keyword:`!elif` ... :keyword:`!elif` ... sekvens är ett substitut "
"för ``switch`` eller ``case``-satser som finns i andra språk."

msgid ""
"If you're comparing the same value to several constants, or checking for "
"specific types or attributes, you may also find the :keyword:`!match` "
"statement useful. For more details see :ref:`tut-match`."
msgstr ""
"Om du jämför samma värde med flera konstanter, eller kontrollerar specifika "
"typer eller attribut, kan du också ha nytta av :keyword:`!match`. För mer "
"information se :ref:`tut-match`."

msgid ":keyword:`!for` Statements"
msgstr ":nyckelord:`!för` Uttalanden"

msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be "
"used to in C or Pascal.  Rather than always iterating over an arithmetic "
"progression of numbers (like in Pascal), or giving the user the ability to "
"define both the iteration step and halting condition (as C), Python's :"
"keyword:`!for` statement iterates over the items of any sequence (a list or "
"a string), in the order that they appear in the sequence.  For example (no "
"pun intended):"
msgstr ""
"Satsen :keyword:`for` i Python skiljer sig lite från vad du kanske är van "
"vid i C eller Pascal.  I stället för att alltid iterera över en aritmetisk "
"progression av tal (som i Pascal), eller ge användaren möjlighet att "
"definiera både iterationssteget och stoppvillkoret (som i C), itererar "
"Pythons :keyword:`!for`-sats över objekten i en sekvens (en lista eller en "
"sträng), i den ordning som de förekommer i sekvensen.  Till exempel (ingen "
"ordvits avsedd):"

msgid ""
">>> # Measure some strings:\n"
">>> words = ['cat', 'window', 'defenestrate']\n"
">>> for w in words:\n"
"...     print(w, len(w))\n"
"...\n"
"cat 3\n"
"window 6\n"
"defenestrate 12"
msgstr ""
">>> # Mät några strängar:\n"
">>> ord = ['katt', 'fönster', 'defenestrate'] >>> för w i ord\n"
">>> för w i ord:\n"
"... print(w, len(w))\n"
"...\n"
"katt 3\n"
"fönster 6\n"
"defenestrate 12"

msgid ""
"Code that modifies a collection while iterating over that same collection "
"can be tricky to get right.  Instead, it is usually more straight-forward to "
"loop over a copy of the collection or to create a new collection::"
msgstr ""
"Kod som ändrar en samling samtidigt som den itererar över samma samling kan "
"vara knepig att få rätt.  Istället är det oftast enklare att loopa över en "
"kopia av samlingen eller att skapa en ny samling::"

msgid ""
"# Create a sample collection\n"
"users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n"
"\n"
"# Strategy:  Iterate over a copy\n"
"for user, status in users.copy().items():\n"
"    if status == 'inactive':\n"
"        del users[user]\n"
"\n"
"# Strategy:  Create a new collection\n"
"active_users = {}\n"
"for user, status in users.items():\n"
"    if status == 'active':\n"
"        active_users[user] = status"
msgstr ""
"# Skapa en exempelsamling\n"
"users = {'Hans': \"active\", \"Éléonore\": \"inactive\", \"景太郎\": "
"\"active\"}\n"
"\n"
"# Strategi:  Iterera över en kopia\n"
"for user, status in users.copy().items():\n"
"    if status == 'inaktiv':\n"
"        del användare[användare]\n"
"\n"
"# Strategi:  Skapa en ny samling\n"
"aktiva_användare = {}\n"
"för användare, status i users.items():\n"
"    om status == \"aktiv\":\n"
"        active_users[user] = status"

msgid "The :func:`range` Function"
msgstr "Funktionen :func:`range"

msgid ""
"If you do need to iterate over a sequence of numbers, the built-in function :"
"func:`range` comes in handy.  It generates arithmetic progressions::"
msgstr ""
"Om du behöver iterera över en sekvens av tal är den inbyggda funktionen :"
"func:`range` praktisk.  Den genererar aritmetiska progressioner::"

msgid ""
">>> for i in range(5):\n"
"...     print(i)\n"
"...\n"
"0\n"
"1\n"
"2\n"
"3\n"
"4"
msgstr ""
">>> för i i intervall(5):\n"
"... print(i)\n"
"...\n"
"0\n"
"1\n"
"2\n"
"3\n"
"4"

msgid ""
"The given end point is never part of the generated sequence; ``range(10)`` "
"generates 10 values, the legal indices for items of a sequence of length "
"10.  It is possible to let the range start at another number, or to specify "
"a different increment (even negative; sometimes this is called the 'step')::"
msgstr ""
"Den angivna slutpunkten är aldrig en del av den genererade sekvensen; "
"``range(10)`` genererar 10 värden, de lagliga indexen för objekt i en "
"sekvens med längden 10.  Det är möjligt att låta intervallet börja vid ett "
"annat tal, eller att ange ett annat steg (även negativt; ibland kallas detta "
"för \"steg\")::"

msgid ""
">>> list(range(5, 10))\n"
"[5, 6, 7, 8, 9]\n"
"\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
"\n"
">>> list(range(-10, -100, -30))\n"
"[-10, -40, -70]"
msgstr ""
">>> lista(intervall(5, 10))\n"
"[5, 6, 7, 8, 9]\n"
"\n"
">>> lista(intervall(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
"\n"
">>> lista(intervall(-10, -100, -30))\n"
"[-10, -40, -70]"

msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` "
"and :func:`len` as follows::"
msgstr ""
"För att iterera över indexen i en sekvens kan du kombinera :func:`range` "
"och :func:`len` på följande sätt::"

msgid ""
">>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n"
">>> for i in range(len(a)):\n"
"...     print(i, a[i])\n"
"...\n"
"0 Mary\n"
"1 had\n"
"2 a\n"
"3 little\n"
"4 lamb"
msgstr ""
">>> a = ['Mary', 'had', 'a', 'little', 'lamb'] >>> for i range(len(a))\n"
">>> for i in range(len(a)):\n"
"... print(i, a[i])\n"
"...\n"
"0 Mary\n"
"1 hade\n"
"2 a\n"
"3 litet\n"
"4 lamm"

msgid ""
"In most such cases, however, it is convenient to use the :func:`enumerate` "
"function, see :ref:`tut-loopidioms`."
msgstr ""
"I de flesta sådana fall är det dock lämpligt att använda funktionen :func:"
"`enumerate`, se :ref:`tut-loopidioms`."

msgid "A strange thing happens if you just print a range::"
msgstr "En märklig sak händer om man bara skriver ut ett range::"

msgid ""
">>> range(10)\n"
"range(0, 10)"
msgstr ""
">>> intervall(10)\n"
"intervall(0, 10)"

msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
"På många sätt beter sig objektet som returneras av :func:`range` som om det "
"vore en lista, men det är det faktiskt inte. Det är ett objekt som "
"returnerar de successiva objekten i den önskade sekvensen när du itererar "
"över det, men det gör inte listan, vilket sparar utrymme."

msgid ""
"We say such an object is :term:`iterable`, that is, suitable as a target for "
"functions and constructs that expect something from which they can obtain "
"successive items until the supply is exhausted.  We have seen that the :"
"keyword:`for` statement is such a construct, while an example of a function "
"that takes an iterable is :func:`sum`::"
msgstr ""
"Vi säger att ett sådant objekt är :term:`iterable`, det vill säga lämpligt "
"som mål för funktioner och konstruktioner som förväntar sig något från "
"vilket de kan få successiva objekt tills tillgången är uttömd.  Vi har sett "
"att :keyword:`for`-satsen är en sådan konstruktion, medan ett exempel på en "
"funktion som tar en iterabel är :func:`sum`::"

msgid ""
">>> sum(range(4))  # 0 + 1 + 2 + 3\n"
"6"
msgstr ""
">>> summa(intervall(4))  # 0 + 1 + 2 + 3\n"
"6"

msgid ""
"Later we will see more functions that return iterables and take iterables as "
"arguments.  In chapter :ref:`tut-structures`, we will discuss in more detail "
"about :func:`list`."
msgstr ""
"Senare kommer vi att se fler funktioner som returnerar iterabler och tar "
"iterabler som argument.  I kapitel :ref:`tut-structures`, kommer vi att "
"diskutera mer i detalj om :func:`list`."

msgid ":keyword:`!break` and :keyword:`!continue` Statements"
msgstr ":keyword:`!break` och :keyword:`!continue` Uttalanden"

msgid ""
"The :keyword:`break` statement breaks out of the innermost enclosing :"
"keyword:`for` or :keyword:`while` loop::"
msgstr ""
"Satsen :keyword:`break` bryter ut ur den innersta omslutande :keyword:`for`- "
"eller :keyword:`while`-slingan::"

msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(f\"{n} equals {x} * {n//x}\")\n"
"...             break\n"
"...\n"
"4 equals 2 * 2\n"
"6 equals 2 * 3\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""
">>> for n in range(2, 10):\n"
"... för x i intervallet(2, n):\n"
"... om n % x == 0:\n"
"... print(f\"{n} är lika med {x} * {n//x}\")\n"
"... break\n"
"...\n"
"4 är lika med 2 * 2\n"
"6 är lika med 2 * 3\n"
"8 är lika med 2 * 4\n"
"9 är lika med 3 * 3"

msgid ""
"The :keyword:`continue` statement continues with the next iteration of the "
"loop::"
msgstr "Satsen :keyword:`continue` fortsätter med nästa iteration av slingan::"

msgid ""
">>> for num in range(2, 10):\n"
"...     if num % 2 == 0:\n"
"...         print(f\"Found an even number {num}\")\n"
"...         continue\n"
"...     print(f\"Found an odd number {num}\")\n"
"...\n"
"Found an even number 2\n"
"Found an odd number 3\n"
"Found an even number 4\n"
"Found an odd number 5\n"
"Found an even number 6\n"
"Found an odd number 7\n"
"Found an even number 8\n"
"Found an odd number 9"
msgstr ""
">>> för num i intervall(2, 10):\n"
"... if num % 2 == 0:\n"
"... print(f\"Hittade ett jämnt tal {num}\")\n"
"... fortsätt\n"
"... print(f\"Hittade ett udda tal {num}\")\n"
"...\n"
"Hittade ett jämnt tal 2\n"
"Hittade ett udda tal 3\n"
"Hittade ett jämnt tal 4\n"
"Hittade ett udda tal 5\n"
"Hittade ett jämnt nummer 6\n"
"Hittade ett udda nummer 7\n"
"Hittade ett jämnt nummer 8\n"
"Hittade ett udda nummer 9"

msgid ":keyword:`!else` Clauses on Loops"
msgstr ":keyword:`!else`-klausuler på loopar"

msgid ""
"In a :keyword:`!for` or :keyword:`!while` loop the :keyword:`!break` "
"statement may be paired with an :keyword:`!else` clause.  If the loop "
"finishes without executing the :keyword:`!break`, the :keyword:`!else` "
"clause executes."
msgstr ""
"I en :keyword:`!for`- eller :keyword:`!while`-slinga kan :keyword:`!break`-"
"satsen paras ihop med en :keyword:`!else`-sats.  Om slingan avslutas utan "
"att :keyword:`!break` exekveras, exekveras :keyword:`!else` klausulen."

msgid ""
"In a :keyword:`for` loop, the :keyword:`!else` clause is executed after the "
"loop finishes its final iteration, that is, if no break occurred."
msgstr ""
"I en :keyword:`for`-slinga utförs :keyword:`!else`-satsen efter att slingan "
"har avslutat sin sista iteration, dvs. om ingen paus inträffade."

msgid ""
"In a :keyword:`while` loop, it's executed after the loop's condition becomes "
"false."
msgstr ""
"I en :keyword:`while`-loop körs den efter att loopens villkor blir falskt."

msgid ""
"In either kind of loop, the :keyword:`!else` clause is **not** executed if "
"the loop was terminated by a :keyword:`break`.  Of course, other ways of "
"ending the loop early, such as a :keyword:`return` or a raised exception, "
"will also skip execution of the :keyword:`else` clause."
msgstr ""
"I båda typerna av slingor kommer :keyword:`!else`-klausulen **inte** att "
"exekveras om slingan avslutades med :keyword:`break`.  Naturligtvis kommer "
"andra sätt att avsluta slingan tidigt, till exempel ett :keyword:`return` "
"eller ett undantag, också att hoppa över exekveringen av :keyword:`else`-"
"satsen."

msgid ""
"This is exemplified in the following :keyword:`!for` loop, which searches "
"for prime numbers::"
msgstr ""
"Detta exemplifieras i följande :keyword:`!for`-slinga, som söker efter "
"primtal::"

msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(n, 'equals', x, '*', n//x)\n"
"...             break\n"
"...     else:\n"
"...         # loop fell through without finding a factor\n"
"...         print(n, 'is a prime number')\n"
"...\n"
"2 is a prime number\n"
"3 is a prime number\n"
"4 equals 2 * 2\n"
"5 is a prime number\n"
"6 equals 2 * 3\n"
"7 is a prime number\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""
">>> for n in range(2, 10):\n"
"... för x i intervallet(2, n):\n"
"... om n % x == 0:\n"
"... print(n, 'är lika med', x, '*', n//x)\n"
"... bryt\n"
"... annat:\n"
"...         # slingan föll igenom utan att hitta en faktor\n"
"... print(n, 'är ett primtal')\n"
"...\n"
"2 är ett primtal\n"
"3 är ett primtal\n"
"4 är lika med 2 * 2\n"
"5 är ett primtal\n"
"6 är lika med 2 * 3\n"
"7 är ett primtal\n"
"8 är lika med 2 * 4\n"
"9 är lika med 3 * 3"

msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause belongs "
"to the ``for`` loop, **not** the ``if`` statement.)"
msgstr ""
"(Ja, detta är den korrekta koden.  Titta noga: ``else``-klausulen hör till "
"``for``-slingan, **inte** ``if``-satsen)"

msgid ""
"One way to think of the else clause is to imagine it paired with the ``if`` "
"inside the loop.  As the loop executes, it will run a sequence like if/if/if/"
"else. The ``if`` is inside the loop, encountered a number of times. If the "
"condition is ever true, a ``break`` will happen. If the condition is never "
"true, the ``else`` clause outside the loop will execute."
msgstr ""
"Ett sätt att tänka på else-klausulen är att föreställa sig att den paras "
"ihop med ``if`` inuti slingan.  När slingan körs kommer den att köra en "
"sekvens som if/if/if/else. ``if`` är inne i slingan och påträffas ett antal "
"gånger. Om villkoret någonsin är sant, kommer ett ``break`` att ske. Om "
"villkoret aldrig är sant kommer ``else``-klausulen utanför slingan att "
"utföras."

msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does with that of "
"``if`` statements: a ``try`` statement's ``else`` clause runs when no "
"exception occurs, and a loop's ``else`` clause runs when no ``break`` "
"occurs. For more on the ``try`` statement and exceptions, see :ref:`tut-"
"handling`."
msgstr ""
"När ``else``-satsen används i en loop har den mer gemensamt med ``else``-"
"satsen i en :keyword:`try`-sats än med ``if``-satser: ``try``-satsens "
"``else``-sats körs när inget undantag inträffar, och en loops ``else``-sats "
"körs när inget ``break`` inträffar. För mer information om ``try``-satsen "
"och undantag, se :ref:`tut-handling`."

msgid ":keyword:`!pass` Statements"
msgstr ":nyckelord:`!pass` Uttalanden"

msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a statement "
"is required syntactically but the program requires no action. For example::"
msgstr ""
"Satsen :keyword:`pass` gör ingenting. Det kan användas när ett uttalande "
"krävs syntaktiskt men programmet inte kräver någon åtgärd. Till exempel::"

msgid ""
">>> while True:\n"
"...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n"
"..."
msgstr ""
">>> medan Sann:\n"
"... pass # Busy-wait för tangentbordsavbrott (Ctrl+C)\n"
"..."

msgid "This is commonly used for creating minimal classes::"
msgstr "Detta används ofta för att skapa minimala klasser::"

msgid ""
">>> class MyEmptyClass:\n"
"...     pass\n"
"..."
msgstr ""
">>> klass MyEmptyClass:\n"
"... pass\n"
"..."

msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing you "
"to keep thinking at a more abstract level.  The :keyword:`!pass` is silently "
"ignored::"
msgstr ""
"Ett annat ställe där :keyword:`pass` kan användas är som en platshållare för "
"en funktion eller en villkorlig kropp när du arbetar med ny kod, så att du "
"kan fortsätta tänka på en mer abstrakt nivå.  Nyckelordet:`!pass` ignoreras "
"i tysthet:"

msgid ""
">>> def initlog(*args):\n"
"...     pass   # Remember to implement this!\n"
"..."
msgstr ""
">>> def initlog(*args):\n"
"... pass # Kom ihåg att implementera detta!\n"
"..."

msgid ":keyword:`!match` Statements"
msgstr ":nyckelord:`!match` Uttalanden"

msgid ""
"A :keyword:`match` statement takes an expression and compares its value to "
"successive patterns given as one or more case blocks.  This is superficially "
"similar to a switch statement in C, Java or JavaScript (and many other "
"languages), but it's more similar to pattern matching in languages like Rust "
"or Haskell. Only the first pattern that matches gets executed and it can "
"also extract components (sequence elements or object attributes) from the "
"value into variables. If no case matches, none of the branches is executed."
msgstr ""
"En :keyword:`match`-sats tar ett uttryck och jämför dess värde med på "
"varandra följande mönster som anges som ett eller flera case-block.  Detta "
"är ytligt sett likt en switch-sats i C, Java eller JavaScript (och många "
"andra språk), men det är mer likt mönstermatchning i språk som Rust eller "
"Haskell. Endast det första mönstret som matchar exekveras och det kan också "
"extrahera komponenter (sekvenselement eller objektattribut) från värdet till "
"variabler. Om inget fall matchar exekveras ingen av grenarna."

msgid ""
"The simplest form compares a subject value against one or more literals::"
msgstr ""
"Den enklaste formen jämför ett ämnesvärde mot en eller flera literaler::"

msgid ""
"def http_error(status):\n"
"    match status:\n"
"        case 400:\n"
"            return \"Bad request\"\n"
"        case 404:\n"
"            return \"Not found\"\n"
"        case 418:\n"
"            return \"I'm a teapot\"\n"
"        case _:\n"
"            return \"Something's wrong with the internet\""
msgstr ""
"def http_error(status):\n"
"    matcha status:\n"
"        fall 400:\n"
"            returnera \"Dålig förfrågan\"\n"
"        fall 404:\n"
"            returnera \"Hittades inte\"\n"
"        fall 418:\n"
"            returnera \"Jag är en tekanna\"\n"
"        fall _:\n"
"            returnerar \"Något är fel med internet\""

msgid ""
"Note the last block: the \"variable name\" ``_`` acts as a *wildcard* and "
"never fails to match."
msgstr ""
"Observera det sista blocket: \"variabelnamnet\" ``_`` fungerar som ett "
"*wildcard* och misslyckas aldrig med att matcha."

msgid ""
"You can combine several literals in a single pattern using ``|`` (\"or\")::"
msgstr ""
"Du kan kombinera flera literaler i ett enda mönster med hjälp av ``|`` "
"(\"eller\")::"

msgid ""
"case 401 | 403 | 404:\n"
"    return \"Not allowed\""
msgstr ""
"fall 401 | 403 | 404:\n"
"    return \"Inte tillåtet\""

msgid ""
"Patterns can look like unpacking assignments, and can be used to bind "
"variables::"
msgstr ""
"Mönster kan se ut som uppackningsuppdrag och kan användas för att binda "
"variabler::"

msgid ""
"# point is an (x, y) tuple\n"
"match point:\n"
"    case (0, 0):\n"
"        print(\"Origin\")\n"
"    case (0, y):\n"
"        print(f\"Y={y}\")\n"
"    case (x, 0):\n"
"        print(f\"X={x}\")\n"
"    case (x, y):\n"
"        print(f\"X={x}, Y={y}\")\n"
"    case _:\n"
"        raise ValueError(\"Not a point\")"
msgstr ""
"# punkten är en (x, y) tupel\n"
"matcha punkten:\n"
"    fall (0, 0):\n"
"        print(\"Ursprung\")\n"
"    fall (0, y):\n"
"        print(f\"Y={y}\")\n"
"    fall (x, 0):\n"
"        print(f\"X={x}\")\n"
"    fall (x, y):\n"
"        print(f\"X={x}, Y={y}\")\n"
"    fall _:\n"
"        raise ValueError(\"Inte en punkt\")"

msgid ""
"Study that one carefully!  The first pattern has two literals, and can be "
"thought of as an extension of the literal pattern shown above.  But the next "
"two patterns combine a literal and a variable, and the variable *binds* a "
"value from the subject (``point``).  The fourth pattern captures two values, "
"which makes it conceptually similar to the unpacking assignment ``(x, y) = "
"point``."
msgstr ""
"Studera den här noggrant!  Det första mönstret har två literaler och kan ses "
"som en utvidgning av det literala mönstret ovan.  Men de två följande "
"mönstren kombinerar en bokstav och en variabel, och variabeln *binder* ett "
"värde från ämnet (``point``).  Det fjärde mönstret fångar två värden, vilket "
"gör att det konceptuellt liknar uppackningsuppdraget ``(x, y) = point``."

msgid ""
"If you are using classes to structure your data you can use the class name "
"followed by an argument list resembling a constructor, but with the ability "
"to capture attributes into variables::"
msgstr ""
"Om du använder klasser för att strukturera dina data kan du använda "
"klassnamnet följt av en argumentlista som liknar en konstruktor, men med "
"möjlighet att fånga attribut i variabler::"

msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"def where_is(point):\n"
"    match point:\n"
"        case Point(x=0, y=0):\n"
"            print(\"Origin\")\n"
"        case Point(x=0, y=y):\n"
"            print(f\"Y={y}\")\n"
"        case Point(x=x, y=0):\n"
"            print(f\"X={x}\")\n"
"        case Point():\n"
"            print(\"Somewhere else\")\n"
"        case _:\n"
"            print(\"Not a point\")"
msgstr ""
"klass Punkt:\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"def where_is(punkt):\n"
"    matcha punkt:\n"
"        fall Punkt(x=0, y=0):\n"
"            print(\"Ursprung\")\n"
"        fall Punkt(x=0, y=y):\n"
"            print(f\"Y={y}\")\n"
"        fall Punkt(x=x, y=0):\n"
"            print(f\"X={x}\")\n"
"        fall Punkt():\n"
"            print(\"Någon annanstans\")\n"
"        fall _:\n"
"            print(\"Inte en punkt\")"

msgid ""
"You can use positional parameters with some builtin classes that provide an "
"ordering for their attributes (e.g. dataclasses). You can also define a "
"specific position for attributes in patterns by setting the "
"``__match_args__`` special attribute in your classes. If it's set to (\"x\", "
"\"y\"), the following patterns are all equivalent (and all bind the ``y`` "
"attribute to the ``var`` variable)::"
msgstr ""
"Du kan använda positionella parametrar med vissa inbyggda klasser som ger en "
"ordning för sina attribut (t.ex. dataklasser). Du kan också definiera en "
"specifik position för attribut i mönster genom att ställa in "
"specialattributet ``__match_args__`` i dina klasser. Om det är inställt på "
"(\"x\", \"y\") är följande mönster alla likvärdiga (och alla binder "
"attributet ``y`` till variabeln ``var``)::"

msgid ""
"Point(1, var)\n"
"Point(1, y=var)\n"
"Point(x=1, y=var)\n"
"Point(y=var, x=1)"
msgstr ""
"Punkt(1, var)\n"
"Punkt(1, y=var)\n"
"Punkt(x=1, y=var)\n"
"Punkt(y=var, x=1)"

msgid ""
"A recommended way to read patterns is to look at them as an extended form of "
"what you would put on the left of an assignment, to understand which "
"variables would be set to what. Only the standalone names (like ``var`` "
"above) are assigned to by a match statement. Dotted names (like ``foo."
"bar``), attribute names (the ``x=`` and ``y=`` above) or class names "
"(recognized by the \"(...)\" next to them like ``Point`` above) are never "
"assigned to."
msgstr ""
"Ett rekommenderat sätt att läsa mönster är att se dem som en utökad form av "
"vad du skulle lägga till vänster om en tilldelning, för att förstå vilka "
"variabler som skulle sättas till vad. Endast de fristående namnen (som "
"``var`` ovan) tilldelas av en match-sats. Prickade namn (som ``foo.bar``), "
"attributnamn (``x=`` och ``y=`` ovan) eller klassnamn (som känns igen på "
"\"(...)\" bredvid dem, som ``Point`` ovan) tilldelas aldrig."

msgid ""
"Patterns can be arbitrarily nested.  For example, if we have a short list of "
"Points, with ``__match_args__`` added, we could match it like this::"
msgstr ""
"Mönster kan vara godtyckligt nästlade.  Om vi till exempel har en kort lista "
"med punkter, med ``__match_args__`` tillagt, kan vi matcha den så här::"

msgid ""
"class Point:\n"
"    __match_args__ = ('x', 'y')\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"match points:\n"
"    case []:\n"
"        print(\"No points\")\n"
"    case [Point(0, 0)]:\n"
"        print(\"The origin\")\n"
"    case [Point(x, y)]:\n"
"        print(f\"Single point {x}, {y}\")\n"
"    case [Point(0, y1), Point(0, y2)]:\n"
"        print(f\"Two on the Y axis at {y1}, {y2}\")\n"
"    case _:\n"
"        print(\"Something else\")"
msgstr ""
"klass Punkt:\n"
"    __match_args__ = ('x', 'y')\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"matchningspunkter:\n"
"    fall []:\n"
"        print(\"Inga punkter\")\n"
"    fall [Punkt(0, 0)]:\n"
"        print(\"Ursprunget\")\n"
"    fall [Punkt(x, y)]:\n"
"        print(f\"Enstaka punkt {x}, {y}\")\n"
"    fall [Punkt(0, y1), Punkt(0, y2)]:\n"
"        print(f\"Två på Y-axeln vid {y1}, {y2}\")\n"
"    fall _:\n"
"        print(\"Något annat\")"

msgid ""
"We can add an ``if`` clause to a pattern, known as a \"guard\".  If the "
"guard is false, ``match`` goes on to try the next case block.  Note that "
"value capture happens before the guard is evaluated::"
msgstr ""
"Vi kan lägga till en \"om\"-klausul i ett mönster, en s.k. \"guard\".  Om "
"guarden är falsk går ``match`` vidare till att prova nästa fallblock.  "
"Observera att värdeinfångning sker innan guarden utvärderas::"

msgid ""
"match point:\n"
"    case Point(x, y) if x == y:\n"
"        print(f\"Y=X at {x}\")\n"
"    case Point(x, y):\n"
"        print(f\"Not on the diagonal\")"
msgstr ""
"matcha punkt:\n"
"    case Point(x, y) if x == y:\n"
"        print(f\"Y=X vid {x}\")\n"
"    fall Punkt(x, y):\n"
"        print(f\"Inte på diagonalen\")"

msgid "Several other key features of this statement:"
msgstr "Flera andra viktiga egenskaper i detta uttalande:"

msgid ""
"Like unpacking assignments, tuple and list patterns have exactly the same "
"meaning and actually match arbitrary sequences.  An important exception is "
"that they don't match iterators or strings."
msgstr ""
"Precis som uppackningsuppdrag har tuple- och listmönster exakt samma "
"betydelse och matchar faktiskt godtyckliga sekvenser.  Ett viktigt undantag "
"är att de inte matchar iteratorer eller strängar."

msgid ""
"Sequence patterns support extended unpacking: ``[x, y, *rest]`` and ``(x, y, "
"*rest)`` work similar to unpacking assignments.  The name after ``*`` may "
"also be ``_``, so ``(x, y, *_)`` matches a sequence of at least two items "
"without binding the remaining items."
msgstr ""
"Sekvensmönster stöder utökad uppackning: ``[x, y, *rest]`` och ``(x, y, "
"*rest)`` fungerar på liknande sätt som uppackningsuppdrag.  Namnet efter "
"``*`` kan också vara ``_``, så ``(x, y, *_)`` matchar en sekvens med minst "
"två objekt utan att binda de återstående objekten."

msgid ""
"Mapping patterns: ``{\"bandwidth\": b, \"latency\": l}`` captures the "
"``\"bandwidth\"`` and ``\"latency\"`` values from a dictionary.  Unlike "
"sequence patterns, extra keys are ignored.  An unpacking like ``**rest`` is "
"also supported.  (But ``**_`` would be redundant, so it is not allowed.)"
msgstr ""
"Mappningsmönster: ``{\"bandwidth\": b, \"latency\": l}`` fångar värdena "
"``\"bandwidth\"`` och ``\"latency\"`` från en ordbok.  Till skillnad från "
"sekvensmönster ignoreras extra nycklar.  En uppackning som ``**rest`` stöds "
"också.  (Men ``**_`` skulle vara överflödigt, så det är inte tillåtet)"

msgid "Subpatterns may be captured using the ``as`` keyword::"
msgstr "Undermönster kan fångas upp med hjälp av nyckelordet ``as``::"

msgid "case (Point(x1, y1), Point(x2, y2) as p2): ..."
msgstr "case (Punkt(x1, y1), Punkt(x2, y2) som p2): ..."

msgid ""
"will capture the second element of the input as ``p2`` (as long as the input "
"is a sequence of two points)"
msgstr ""
"kommer att fånga det andra elementet i inmatningen som ``p2`` (så länge "
"inmatningen är en sekvens av två punkter)"

msgid ""
"Most literals are compared by equality, however the singletons ``True``, "
"``False`` and ``None`` are compared by identity."
msgstr ""
"De flesta literaler jämförs med likhet, men singletonerna ``True``, "
"``False`` och ``None`` jämförs med identitet."

msgid ""
"Patterns may use named constants.  These must be dotted names to prevent "
"them from being interpreted as capture variable::"
msgstr ""
"Mönster kan använda namngivna konstanter.  Dessa måste vara punkterade namn "
"för att förhindra att de tolkas som fångstvariabel::"

msgid ""
"from enum import Enum\n"
"class Color(Enum):\n"
"    RED = 'red'\n"
"    GREEN = 'green'\n"
"    BLUE = 'blue'\n"
"\n"
"color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\n"
"\n"
"match color:\n"
"    case Color.RED:\n"
"        print(\"I see red!\")\n"
"    case Color.GREEN:\n"
"        print(\"Grass is green\")\n"
"    case Color.BLUE:\n"
"        print(\"I'm feeling the blues :(\")"
msgstr ""
"from enum import Enum\n"
"klass Färg(Enum):\n"
"    RED = 'röd'\n"
"    GREEN = 'grön'\n"
"    BLUE = 'blå'\n"
"\n"
"color = Color(input(\"Ange ditt val av 'röd', 'blå' eller 'grön': \"))\n"
"\n"
"matcha färg:\n"
"    fall Color.RED:\n"
"        print(\"Jag ser rött!\")\n"
"    fall Färg.GRÖN:\n"
"        print(\"Gräs är grönt\")\n"
"    fall Färg.BLÅ:\n"
"        print(\"Jag känner mig bluesig :(\")"

msgid ""
"For a more detailed explanation and additional examples, you can look into :"
"pep:`636` which is written in a tutorial format."
msgstr ""
"För en mer detaljerad förklaring och ytterligare exempel kan du titta på :"
"pep:`636` som är skriven i ett handledningsformat."

msgid "Defining Functions"
msgstr "Definiera funktioner"

msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary "
"boundary::"
msgstr ""
"Vi kan skapa en funktion som skriver Fibonacci-serien till en godtycklig "
"gräns::"

msgid ""
">>> def fib(n):    # write Fibonacci series less than n\n"
"...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         print(a, end=' ')\n"
"...         a, b = b, a+b\n"
"...     print()\n"
"...\n"
">>> # Now call the function we just defined:\n"
">>> fib(2000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"
msgstr ""
">>> def fib(n):    # skriv Fibonacci-serier mindre än n\n"
"...     \"\"\"Skriv ut en Fibonacci-serie som är mindre än n.\"\"\"\n"
"... a, b = 0, 1\n"
"... medan a < n:\n"
"... print(a, end=' ')\n"
"... a, b = b, a+b\n"
"... print()\n"
"...\n"
">>> # Anropa nu den funktion vi just definierade:\n"
">>> fib(2000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"

msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must be "
"followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at the "
"next line, and must be indented."
msgstr ""
"Nyckelordet :keyword:`def` introducerar en funktions *definition*.  Det "
"måste följas av funktionsnamnet och den parentesförsedda listan med formella "
"parametrar. De satser som bildar funktionens kropp börjar på nästa rad och "
"måste vara indragna."

msgid ""
"The first statement of the function body can optionally be a string literal; "
"this string literal is the function's documentation string, or :dfn:"
"`docstring`. (More about docstrings can be found in the section :ref:`tut-"
"docstrings`.) There are tools which use docstrings to automatically produce "
"online or printed documentation, or to let the user interactively browse "
"through code; it's good practice to include docstrings in code that you "
"write, so make a habit of it."
msgstr ""
"Den första satsen i funktionens kropp kan eventuellt vara en stränglitteral; "
"denna stränglitteral är funktionens dokumentationssträng, eller :dfn:"
"`docstring`. (Mer om docstrings finns i avsnittet :ref:`tut-docstrings`.) "
"Det finns verktyg som använder docstrings för att automatiskt producera "
"dokumentation på nätet eller i tryck, eller för att låta användaren "
"interaktivt bläddra igenom kod; det är god praxis att inkludera docstrings i "
"kod som du skriver, så gör det till en vana."

msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable assignments "
"in a function store the value in the local symbol table; whereas variable "
"references first look in the local symbol table, then in the local symbol "
"tables of enclosing functions, then in the global symbol table, and finally "
"in the table of built-in names. Thus, global variables and variables of "
"enclosing functions cannot be directly assigned a value within a function "
"(unless, for global variables, named in a :keyword:`global` statement, or, "
"for variables of enclosing functions, named in a :keyword:`nonlocal` "
"statement), although they may be referenced."
msgstr ""
"När en funktion *exekveras* introduceras en ny symboltabell som används för "
"funktionens lokala variabler.  Mer exakt lagrar alla variabeltilldelningar i "
"en funktion värdet i den lokala symboltabellen, medan variabelreferenser "
"först letar i den lokala symboltabellen, sedan i de lokala symboltabellerna "
"för omslutande funktioner, sedan i den globala symboltabellen och slutligen "
"i tabellen med inbyggda namn. Globala variabler och variabler i inneslutande "
"funktioner kan alltså inte direkt tilldelas ett värde inom en funktion "
"(såvida inte globala variabler namnges i en :keyword:`global`-sats eller "
"variabler i inneslutande funktioner namnges i en :keyword:`nonlocal`-sats), "
"men de kan refereras."

msgid ""
"The actual parameters (arguments) to a function call are introduced in the "
"local symbol table of the called function when it is called; thus, arguments "
"are passed using *call by value* (where the *value* is always an object "
"*reference*, not the value of the object). [#]_ When a function calls "
"another function, or calls itself recursively, a new local symbol table is "
"created for that call."
msgstr ""
"De faktiska parametrarna (argumenten) till ett funktionsanrop introduceras i "
"den lokala symboltabellen för den anropade funktionen när den anropas; "
"argument skickas alltså med *call by value* (där *värdet* alltid är en "
"*referens* till ett objekt, inte objektets värde). [När en funktion anropar "
"en annan funktion, eller anropar sig själv rekursivt, skapas en ny lokal "
"symboltabell för det anropet."

msgid ""
"A function definition associates the function name with the function object "
"in the current symbol table.  The interpreter recognizes the object pointed "
"to by that name as a user-defined function.  Other names can also point to "
"that same function object and can also be used to access the function::"
msgstr ""
"En funktionsdefinition associerar funktionsnamnet med funktionsobjektet i "
"den aktuella symboltabellen.  Tolken känner igen det objekt som pekas ut av "
"namnet som en användardefinierad funktion.  Andra namn kan också peka på "
"samma funktionsobjekt och kan också användas för att komma åt funktionen::"

msgid ""
">>> fib\n"
"<function fib at 10042ed0>\n"
">>> f = fib\n"
">>> f(100)\n"
"0 1 1 2 3 5 8 13 21 34 55 89"
msgstr ""
"&gt;&gt;&gt; fib\n"
"<function fib at 10042ed0>\n"
"&gt;&gt;&gt; f = fib\n"
"&gt;&gt;&gt; f(100)\n"
"0 1 1 2 3 5 8 13 21 34 55 89"

msgid ""
"Coming from other languages, you might object that ``fib`` is not a function "
"but a procedure since it doesn't return a value.  In fact, even functions "
"without a :keyword:`return` statement do return a value, albeit a rather "
"boring one.  This value is called ``None`` (it's a built-in name).  Writing "
"the value ``None`` is normally suppressed by the interpreter if it would be "
"the only value written. You can see it if you really want to using :func:"
"`print`::"
msgstr ""
"Om du kommer från andra språk kanske du invänder att ``fib`` inte är en "
"funktion utan en procedur eftersom den inte returnerar något värde.  Faktum "
"är att även funktioner utan :keyword:`return`-sats returnerar ett värde, om "
"än ett ganska tråkigt sådant.  Detta värde kallas ``None`` (det är ett "
"inbyggt namn).  Att skriva värdet ``None`` undertrycks normalt av tolken om "
"det skulle vara det enda värde som skrivs. Du kan se det om du verkligen "
"vill med hjälp av :func:`print`::"

msgid ""
">>> fib(0)\n"
">>> print(fib(0))\n"
"None"
msgstr ""
">>> fib(0)\n"
">>> skriv ut(fib(0))\n"
"Ingen"

msgid ""
"It is simple to write a function that returns a list of the numbers of the "
"Fibonacci series, instead of printing it::"
msgstr ""
"Det är enkelt att skriva en funktion som returnerar en lista med siffrorna i "
"Fibonacci-serien, istället för att skriva ut den::"

msgid ""
">>> def fib2(n):  # return Fibonacci series up to n\n"
"...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n"
"...     result = []\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         result.append(a)    # see below\n"
"...         a, b = b, a+b\n"
"...     return result\n"
"...\n"
">>> f100 = fib2(100)    # call it\n"
">>> f100                # write the result\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
msgstr ""
">>> def fib2(n):  # returnera Fibonacci-serien upp till n\n"
"...     \"\"\"Returnera en lista som innehåller Fibonacci-serierna upp till "
"n.\"\"\"\"\n"
"... resultat = []\n"
"... a, b = 0, 1\n"
"... medan a < n:\n"
"... result.append(a) # se nedan\n"
"... a, b = b, a+b\n"
"... returnera resultat\n"
"...\n"
">>> f100 = fib2(100) # kalla det\n"
">>> f100 # skriv resultatet\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"

msgid "This example, as usual, demonstrates some new Python features:"
msgstr ""
"I det här exemplet demonstreras som vanligt några nya Python-funktioner:"

msgid ""
"The :keyword:`return` statement returns with a value from a function. :"
"keyword:`!return` without an expression argument returns ``None``. Falling "
"off the end of a function also returns ``None``."
msgstr ""
"Satsen :keyword:`return` returnerar med ett värde från en funktion. :keyword:"
"`!return` utan ett uttrycksargument returnerar ``None``. Att falla av i "
"slutet av en funktion returnerar också ``None``."

msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is named "
"``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined by "
"the object's type. Different types define different methods.  Methods of "
"different types may have the same name without causing ambiguity.  (It is "
"possible to define your own object types and methods, using *classes*, see :"
"ref:`tut-classes`) The method :meth:`!append` shown in the example is "
"defined for list objects; it adds a new element at the end of the list.  In "
"this example it is equivalent to ``result = result + [a]``, but more "
"efficient."
msgstr ""
"Satsen ``result.append(a)`` anropar en *metod* i listobjektet ``result``.  "
"En metod är en funktion som \"hör till\" ett objekt och som kallas ``obj."
"metodnamn``, där ``obj`` är ett objekt (det kan vara ett uttryck) och "
"``metodnamn`` är namnet på en metod som definieras av objektets typ. Olika "
"typer definierar olika metoder.  Metoder av olika typer kan ha samma namn "
"utan att det blir tvetydigt.  (Det är möjligt att definiera egna objekttyper "
"och metoder med hjälp av *classes*, se :ref:`tut-classes`) Metoden :meth:`!"
"append` i exemplet är definierad för listobjekt; den lägger till ett nytt "
"element i slutet av listan.  I det här exemplet är den likvärdig med "
"``result = result + [a]``, men mer effektiv."

msgid "More on Defining Functions"
msgstr "Mer om att definiera funktioner"

msgid ""
"It is also possible to define functions with a variable number of arguments. "
"There are three forms, which can be combined."
msgstr ""
"Det är också möjligt att definiera funktioner med ett variabelt antal "
"argument. Det finns tre former som kan kombineras."

msgid "Default Argument Values"
msgstr "Standardargumentvärden"

msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer arguments "
"than it is defined to allow.  For example::"
msgstr ""
"Den mest användbara formen är att ange ett standardvärde för ett eller flera "
"argument. Detta skapar en funktion som kan anropas med färre argument än vad "
"den är definierad att tillåta.  Till exempel::"

msgid ""
"def ask_ok(prompt, retries=4, reminder='Please try again!'):\n"
"    while True:\n"
"        reply = input(prompt)\n"
"        if reply in {'y', 'ye', 'yes'}:\n"
"            return True\n"
"        if reply in {'n', 'no', 'nop', 'nope'}:\n"
"            return False\n"
"        retries = retries - 1\n"
"        if retries < 0:\n"
"            raise ValueError('invalid user response')\n"
"        print(reminder)"
msgstr ""
"def ask_ok(prompt, retries=4, reminder='Försök igen!'):\n"
"    medan Sann:\n"
"        svar = input(prompt)\n"
"        if reply in {'y', 'ye', 'yes'}:\n"
"            returnera True\n"
"        om svaret är i {'n', 'no', 'nop', 'nope'}:\n"
"            returnera False\n"
"        retries = retries - 1\n"
"        om retries < 0:\n"
"            raise ValueError(\"ogiltigt användarsvar\")\n"
"        print(påminnelse)"

msgid "This function can be called in several ways:"
msgstr "Denna funktion kan anropas på flera olika sätt:"

msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to quit?')``"
msgstr ""
"ger bara det obligatoriska argumentet: ``ask_ok('Vill du verkligen sluta?')``"

msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the file?', "
"2)``"
msgstr ""
"som ger ett av de valfria argumenten: ``ask_ok('OK att skriva över filen?', "
"2)```"

msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, 'Come "
"on, only yes or no!')``"
msgstr ""
"eller till och med ge alla argument: ``ask_ok('OK att skriva över filen?', "
"2, 'Kom igen, bara ja eller nej!')``"

msgid ""
"This example also introduces the :keyword:`in` keyword. This tests whether "
"or not a sequence contains a certain value."
msgstr ""
"I detta exempel introduceras också nyckelordet :keyword:`in`. Detta testar "
"om en sekvens innehåller ett visst värde eller inte."

msgid ""
"The default values are evaluated at the point of function definition in the "
"*defining* scope, so that ::"
msgstr ""
"Standardvärdena utvärderas vid tidpunkten för funktionsdefinitionen i det "
"*definierande* omfånget, så att ::"

msgid ""
"i = 5\n"
"\n"
"def f(arg=i):\n"
"    print(arg)\n"
"\n"
"i = 6\n"
"f()"
msgstr ""
"i = 5\n"
"\n"
"def f(arg=i):\n"
"    print(arg)\n"
"\n"
"i = 6\n"
"f()"

msgid "will print ``5``."
msgstr "kommer att skriva ut ``5``."

msgid ""
"**Important warning:**  The default value is evaluated only once. This makes "
"a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**Viktig varning:** Standardvärdet utvärderas bara en gång. Detta gör "
"skillnad när standardvärdet är ett föränderligt objekt, t.ex. en lista, en "
"ordbok eller instanser av de flesta klasser.  Följande funktion ackumulerar "
"t.ex. de argument som skickas till den vid efterföljande anrop::"

msgid ""
"def f(a, L=[]):\n"
"    L.append(a)\n"
"    return L\n"
"\n"
"print(f(1))\n"
"print(f(2))\n"
"print(f(3))"
msgstr ""
"def f(a, L=[]):\n"
"    L.append(a)\n"
"    returnera L\n"
"\n"
"print(f(1))\n"
"print(f(2))\n"
"print(f(3))"

msgid "This will print ::"
msgstr "Detta kommer att skrivas ut ::"

msgid ""
"[1]\n"
"[1, 2]\n"
"[1, 2, 3]"
msgstr ""
"[1]\n"
"[1, 2]\n"
"[1, 2, 3]"

msgid ""
"If you don't want the default to be shared between subsequent calls, you can "
"write the function like this instead::"
msgstr ""
"Om du inte vill att standardvärdet ska delas mellan efterföljande anrop kan "
"du istället skriva funktionen så här::"

msgid ""
"def f(a, L=None):\n"
"    if L is None:\n"
"        L = []\n"
"    L.append(a)\n"
"    return L"
msgstr ""
"def f(a, L=None):\n"
"    om L är None:\n"
"        L = []\n"
"    L.append(a)\n"
"    returnerar L"

msgid "Keyword Arguments"
msgstr "Argument för nyckelord"

msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"Funktioner kan också anropas med :term:`nyckelordsargument <keyword "
"argument>` av formen ``kwarg=värde``.  Till exempel kan följande funktion::"

msgid ""
"def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\n"
"    print(\"-- This parrot wouldn't\", action, end=' ')\n"
"    print(\"if you put\", voltage, \"volts through it.\")\n"
"    print(\"-- Lovely plumage, the\", type)\n"
"    print(\"-- It's\", state, \"!\")"
msgstr ""
"def papegoja(spänning, tillstånd='en stel', åtgärd='voom', typ='norsk "
"blå'):\n"
"    print(\"-- Den här papegojan skulle inte\", action, end=' ')\n"
"    print(\"om du sätter\", spänning, \"volt genom den.\")\n"
"    print(\"-- Vacker fjäderdräkt, den\", typ)\n"
"    print(\"-- Det är\", tillstånd, \"!\")"

msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in any "
"of the following ways::"
msgstr ""
"accepterar ett obligatoriskt argument (``voltage``) och tre valfria argument "
"(``state``, ``action`` och ``type``).  Denna funktion kan anropas på något "
"av följande sätt::"

msgid ""
"parrot(1000)                                          # 1 positional "
"argument\n"
"parrot(voltage=1000)                                  # 1 keyword argument\n"
"parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\n"
"parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\n"
"parrot('a million', 'bereft of life', 'jump')         # 3 positional "
"arguments\n"
"parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 "
"keyword"
msgstr ""
"papegoja(1000) # 1 positionellt argument\n"
"parrot(voltage=1000) # 1 nyckelordsargument\n"
"parrot(voltage=1000000, action='VOOOOOM') # 2 nyckelordsargument\n"
"parrot(action='VOOOOOM', voltage=1000000) # 2 nyckelordsargument\n"
"papegoja('en miljon', 'berövad livet', 'hoppa') # 3 positionella argument\n"
"papegoja('tusen', tillstånd='skjuter upp prästkragarna') # 1 positionellt, 1 "
"nyckelord"

msgid "but all the following calls would be invalid::"
msgstr "men alla följande anrop skulle vara ogiltiga::"

msgid ""
"parrot()                     # required argument missing\n"
"parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword "
"argument\n"
"parrot(110, voltage=220)     # duplicate value for the same argument\n"
"parrot(actor='John Cleese')  # unknown keyword argument"
msgstr ""
"parrot() # nödvändigt argument saknas\n"
"parrot(voltage=5.0, 'dead') # icke-nyckelordsargument efter ett "
"nyckelordsargument\n"
"parrot(110, voltage=220) # duplicerat värde för samma argument\n"
"parrot(skådespelare='John Cleese') # okänt nyckelordsargument"

msgid ""
"In a function call, keyword arguments must follow positional arguments. All "
"the keyword arguments passed must match one of the arguments accepted by the "
"function (e.g. ``actor`` is not a valid argument for the ``parrot`` "
"function), and their order is not important.  This also includes non-"
"optional arguments (e.g. ``parrot(voltage=1000)`` is valid too). No argument "
"may receive a value more than once. Here's an example that fails due to this "
"restriction::"
msgstr ""
"I ett funktionsanrop måste nyckelordsargument följa efter positionsargument. "
"Alla nyckelordsargument som skickas måste matcha ett av de argument som "
"accepteras av funktionen (t.ex. ``actor`` är inte ett giltigt argument för "
"funktionen ``parrot``), och deras ordning är inte viktig.  Detta inkluderar "
"även icke valfria argument (t.ex. ``parrot(voltage=1000)`` är också "
"giltigt). Inget argument får ta emot ett värde mer än en gång. Här är ett "
"exempel som misslyckas på grund av denna begränsning::"

msgid ""
">>> def function(a):\n"
"...     pass\n"
"...\n"
">>> function(0, a=0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: function() got multiple values for argument 'a'"
msgstr ""
"&gt;&gt;&gt; def funktion(a):\n"
"... pass\n"
"...\n"
"&gt;&gt;&gt; funktion(0, a=0)\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: function() fick flera värden för argumentet 'a'"

msgid ""
"When a final formal parameter of the form ``**name`` is present, it receives "
"a dictionary (see :ref:`typesmapping`) containing all keyword arguments "
"except for those corresponding to a formal parameter.  This may be combined "
"with a formal parameter of the form ``*name`` (described in the next "
"subsection) which receives a :ref:`tuple <tut-tuples>` containing the "
"positional arguments beyond the formal parameter list.  (``*name`` must "
"occur before ``**name``.) For example, if we define a function like this::"
msgstr ""
"När en slutlig formell parameter av formen ``**name`` finns, får den en "
"dictionary (se :ref:`typesmapping`) som innehåller alla nyckelordsargument "
"utom de som motsvarar en formell parameter.  Detta kan kombineras med en "
"formell parameter av formen ``*name`` (beskrivs i nästa underavsnitt) som "
"tar emot en :ref:`tuple <tut-tuples>` som innehåller de positionella "
"argumenten utöver den formella parameterlistan.  (``*name`` måste förekomma "
"före ``**name``.) Om vi t.ex. definierar en funktion så här::"

msgid ""
"def cheeseshop(kind, *arguments, **keywords):\n"
"    print(\"-- Do you have any\", kind, \"?\")\n"
"    print(\"-- I'm sorry, we're all out of\", kind)\n"
"    for arg in arguments:\n"
"        print(arg)\n"
"    print(\"-\" * 40)\n"
"    for kw in keywords:\n"
"        print(kw, \":\", keywords[kw])"
msgstr ""
"def cheeseshop(typ, *argument, **nyckelord):\n"
"    print(\"-- Har ni någon\", sort, \"?\")\n"
"    print(\"-- Jag är ledsen, men vi har slut på\", sort)\n"
"    för arg i argument:\n"
"        print(arg)\n"
"    print(\"-\" * 40)\n"
"    for kw i nyckelord:\n"
"        print(kw, \":\", nyckelord[kw])"

msgid "It could be called like this::"
msgstr "Det skulle kunna kallas så här::"

msgid ""
"cheeseshop(\"Limburger\", \"It's very runny, sir.\",\n"
"           \"It's really very, VERY runny, sir.\",\n"
"           shopkeeper=\"Michael Palin\",\n"
"           client=\"John Cleese\",\n"
"           sketch=\"Cheese Shop Sketch\")"
msgstr ""
"cheeseshop(\"Limburger\",\"Den är väldigt rinnig, sir.\",\n"
"           \"Den är verkligen mycket, MYCKET rinnig, sir.\",\n"
"           butiksinnehavare=\"Michael Palin\",\n"
"           kund=\"John Cleese\",\n"
"           sketch=\"Sketch från ostbutiken\")"

msgid "and of course it would print:"
msgstr "och naturligtvis skulle det tryckas:"

msgid ""
"-- Do you have any Limburger ?\n"
"-- I'm sorry, we're all out of Limburger\n"
"It's very runny, sir.\n"
"It's really very, VERY runny, sir.\n"
"----------------------------------------\n"
"shopkeeper : Michael Palin\n"
"client : John Cleese\n"
"sketch : Cheese Shop Sketch"
msgstr ""
"-- Har ni någon Limburger?\n"
"-- Jag är ledsen, vi har slut på Limburger\n"
"Den är väldigt rinnig, sir.\n"
"Den är verkligen mycket, MYCKET rinnande, sir.\n"
"----------------------------------------\n"
"butiksinnehavare : Michael Palin\n"
"kund : John Cleese\n"
"skiss : Ostbutikens skiss"

msgid ""
"Note that the order in which the keyword arguments are printed is guaranteed "
"to match the order in which they were provided in the function call."
msgstr ""
"Observera att den ordning i vilken nyckelordsargumenten skrivs ut garanterat "
"kommer att överensstämma med den ordning i vilken de angavs i "
"funktionsanropet."

msgid "Special parameters"
msgstr "Särskilda parametrar"

msgid ""
"By default, arguments may be passed to a Python function either by position "
"or explicitly by keyword. For readability and performance, it makes sense to "
"restrict the way arguments can be passed so that a developer need only look "
"at the function definition to determine if items are passed by position, by "
"position or keyword, or by keyword."
msgstr ""
"Som standard kan argument skickas till en Python-funktion antingen genom "
"position eller uttryckligen genom nyckelord. För läsbarhet och prestanda är "
"det vettigt att begränsa hur argument kan skickas så att en utvecklare bara "
"behöver titta på funktionsdefinitionen för att avgöra om objekt skickas med "
"position, med position eller nyckelord eller med nyckelord."

msgid "A function definition may look like:"
msgstr "En funktionsdefinition kan se ut på följande sätt:"

msgid ""
"def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n"
"      -----------    ----------     ----------\n"
"        |             |                  |\n"
"        |        Positional or keyword   |\n"
"        |                                - Keyword only\n"
"         -- Positional only"
msgstr ""
"def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n"
"      ----------- ---------- ----------\n"
"        | | |\n"
"        | Position eller nyckelord | | - Endast nyckelord\n"
"        | - Endast nyckelord\n"
"         -- Endast position"

msgid ""
"where ``/`` and ``*`` are optional. If used, these symbols indicate the kind "
"of parameter by how the arguments may be passed to the function: positional-"
"only, positional-or-keyword, and keyword-only. Keyword parameters are also "
"referred to as named parameters."
msgstr ""
"där ``/`` och ``*`` är valfria. Om dessa symboler används anger de vilken "
"typ av parameter som argumenten kan skickas till funktionen med: endast "
"positionell, positionell-eller-nyckelord och endast nyckelord. "
"Nyckelordsparametrar kallas också namngivna parametrar."

msgid "Positional-or-Keyword Arguments"
msgstr "Positionerings- eller nyckelordsargument"

msgid ""
"If ``/`` and ``*`` are not present in the function definition, arguments may "
"be passed to a function by position or by keyword."
msgstr ""
"Om ``/`` och ``*`` inte finns med i funktionsdefinitionen kan argument "
"skickas till en funktion genom position eller nyckelord."

msgid "Positional-Only Parameters"
msgstr "Endast positionella parametrar"

msgid ""
"Looking at this in a bit more detail, it is possible to mark certain "
"parameters as *positional-only*. If *positional-only*, the parameters' order "
"matters, and the parameters cannot be passed by keyword. Positional-only "
"parameters are placed before a ``/`` (forward-slash). The ``/`` is used to "
"logically separate the positional-only parameters from the rest of the "
"parameters. If there is no ``/`` in the function definition, there are no "
"positional-only parameters."
msgstr ""
"Om man tittar på detta lite mer i detalj är det möjligt att markera vissa "
"parametrar som *positional-only*. Om *positional-only*, spelar parametrarnas "
"ordning roll, och parametrarna kan inte skickas med nyckelord. Positional-"
"only-parametrar placeras före ett ``/`` (framåtriktat snedstreck). ``/`` "
"används för att logiskt separera parametrar som endast är positionella från "
"resten av parametrarna. Om det inte finns någon ``/`` i "
"funktionsdefinitionen, finns det inga enbart positionella parametrar."

msgid ""
"Parameters following the ``/`` may be *positional-or-keyword* or *keyword-"
"only*."
msgstr ""
"Parametrar efter ``/`` kan vara *positionella-eller-nyckelord* eller *endast "
"nyckelord*."

msgid "Keyword-Only Arguments"
msgstr "Argument som endast innehåller nyckelord"

msgid ""
"To mark parameters as *keyword-only*, indicating the parameters must be "
"passed by keyword argument, place an ``*`` in the arguments list just before "
"the first *keyword-only* parameter."
msgstr ""
"För att markera parametrar som *keyword-only*, vilket indikerar att "
"parametrarna måste skickas med nyckelordsargument, placera en ``*`` i "
"argumentlistan precis före den första *keyword-only*-parametern."

msgid "Function Examples"
msgstr "Funktion Exempel"

msgid ""
"Consider the following example function definitions paying close attention "
"to the markers ``/`` and ``*``::"
msgstr ""
"Tänk på följande exempel på funktionsdefinitioner och var uppmärksam på "
"markörerna ``/`` och ``*``::"

msgid ""
">>> def standard_arg(arg):\n"
"...     print(arg)\n"
"...\n"
">>> def pos_only_arg(arg, /):\n"
"...     print(arg)\n"
"...\n"
">>> def kwd_only_arg(*, arg):\n"
"...     print(arg)\n"
"...\n"
">>> def combined_example(pos_only, /, standard, *, kwd_only):\n"
"...     print(pos_only, standard, kwd_only)"
msgstr ""
">>> def standard_arg(arg):\n"
"... print(arg)\n"
"...\n"
">>> def pos_only_arg(arg, /):\n"
"... print(arg)\n"
"...\n"
">>> def kwd_only_arg(*, arg):\n"
"... print(arg)\n"
"...\n"
">>> def kombinerat_exempel(pos_only, /, standard, *, kwd_only):\n"
"... print(pos_only, standard, kwd_only)"

msgid ""
"The first function definition, ``standard_arg``, the most familiar form, "
"places no restrictions on the calling convention and arguments may be passed "
"by position or keyword::"
msgstr ""
"Den första funktionsdefinitionen, ``standard_arg``, den mest bekanta formen, "
"lägger inga restriktioner på anropskonventionen och argument kan skickas med "
"position eller nyckelord::"

msgid ""
">>> standard_arg(2)\n"
"2\n"
"\n"
">>> standard_arg(arg=2)\n"
"2"
msgstr ""
">>> standard_arg(2)\n"
"2\n"
"\n"
">>> standard_arg(arg=2)\n"
"2"

msgid ""
"The second function ``pos_only_arg`` is restricted to only use positional "
"parameters as there is a ``/`` in the function definition::"
msgstr ""
"Den andra funktionen ``pos_only_arg`` är begränsad till att endast använda "
"positionella parametrar eftersom det finns en ``/`` i funktionsdefinitionen::"

msgid ""
">>> pos_only_arg(1)\n"
"1\n"
"\n"
">>> pos_only_arg(arg=1)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: pos_only_arg() got some positional-only arguments passed as "
"keyword arguments: 'arg'"
msgstr ""
"&gt;&gt;&gt; pos_only_arg(1)\n"
"1\n"
"\n"
"&gt;&gt;&gt; pos_endast_arg(arg=1)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: pos_only_arg() fick några endast positionella argument som "
"skickades som nyckelordsargument: 'arg'"

msgid ""
"The third function ``kwd_only_arg`` only allows keyword arguments as "
"indicated by a ``*`` in the function definition::"
msgstr ""
"Den tredje funktionen ``kwd_only_arg`` tillåter endast nyckelordsargument "
"som anges med en ``*`` i funktionsdefinitionen::"

msgid ""
">>> kwd_only_arg(3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n"
"\n"
">>> kwd_only_arg(arg=3)\n"
"3"
msgstr ""
"&gt;&gt;&gt; kwd_only_arg(3)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: kwd_only_arg() tar 0 positionella argument men 1 gavs\n"
"\n"
"&gt;&gt;&gt; kwd_only_arg(arg=3)\n"
"3"

msgid ""
"And the last uses all three calling conventions in the same function "
"definition::"
msgstr ""
"Och den sista använder alla tre anropskonventionerna i samma "
"funktionsdefinition::"

msgid ""
">>> combined_example(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() takes 2 positional arguments but 3 were given\n"
"\n"
">>> combined_example(1, 2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(1, standard=2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(pos_only=1, standard=2, kwd_only=3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() got some positional-only arguments passed as "
"keyword arguments: 'pos_only'"
msgstr ""
"&gt;&gt;&gt; kombinerat_exempel(1, 2, 3)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: combined_example() tar 2 positionella argument men 3 gavs\n"
"\n"
"&gt;&gt;&gt; kombinerat_exempel(1, 2, kwd_only=3)\n"
"1 2 3\n"
"\n"
"&gt;&gt;&gt; kombinerat_exempel(1, standard=2, kwd_only=3)\n"
"1 2 3\n"
"\n"
"&gt;&gt;&gt; kombinerat_exempel(pos_only=1, standard=2, kwd_only=3)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: combined_example() fick några endast positionella argument som "
"nyckelordsargument: 'pos_only'"

msgid ""
"Finally, consider this function definition which has a potential collision "
"between the positional argument ``name``  and ``**kwds`` which has ``name`` "
"as a key::"
msgstr ""
"Slutligen, betrakta denna funktionsdefinition som har en potentiell "
"kollision mellan det positionella argumentet ``name`` och ``**kwds`` som har "
"``name`` som nyckel::"

msgid ""
"def foo(name, **kwds):\n"
"    return 'name' in kwds"
msgstr ""
"def foo(namn, **kwds):\n"
"    returnerar 'namn' i kwds"

msgid ""
"There is no possible call that will make it return ``True`` as the keyword "
"``'name'`` will always bind to the first parameter. For example::"
msgstr ""
"Det finns inget möjligt anrop som får den att returnera ``True`` eftersom "
"nyckelordet ``'name'`` alltid kommer att bindas till den första parametern. "
"Till exempel::"

msgid ""
">>> foo(1, **{'name': 2})\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: foo() got multiple values for argument 'name'\n"
">>>"
msgstr ""
"&gt;&gt;&gt; foo(1, **{'namn': 2})\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: foo() fick flera värden för argumentet 'name'\n"
"&gt;&gt;&gt"

msgid ""
"But using ``/`` (positional only arguments), it is possible since it allows "
"``name`` as a positional argument and ``'name'`` as a key in the keyword "
"arguments::"
msgstr ""
"Men med ``/`` (endast positionella argument) är det möjligt eftersom det "
"tillåter ``namn`` som ett positionellt argument och ``'namn'`` som en nyckel "
"i nyckelordet arguments::"

msgid ""
">>> def foo(name, /, **kwds):\n"
"...     return 'name' in kwds\n"
"...\n"
">>> foo(1, **{'name': 2})\n"
"True"
msgstr ""
">>> def foo(namn, /, **kwds):\n"
"... return 'namn' i kwds\n"
"...\n"
">>> foo(1, **{'namn': 2})\n"
"Sant"

msgid ""
"In other words, the names of positional-only parameters can be used in "
"``**kwds`` without ambiguity."
msgstr ""
"Med andra ord kan namnen på parametrar som endast är positionella användas i "
"``**kwds`` utan tvetydighet."

msgid "Recap"
msgstr "Sammanfattning"

msgid ""
"The use case will determine which parameters to use in the function "
"definition::"
msgstr ""
"Användningsfallet avgör vilka parametrar som ska användas i "
"funktionsdefinitionen::"

msgid "def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):"
msgstr "def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):"

msgid "As guidance:"
msgstr "Som vägledning:"

msgid ""
"Use positional-only if you want the name of the parameters to not be "
"available to the user. This is useful when parameter names have no real "
"meaning, if you want to enforce the order of the arguments when the function "
"is called or if you need to take some positional parameters and arbitrary "
"keywords."
msgstr ""
"Använd positional-only om du vill att namnet på parametrarna inte ska vara "
"tillgängligt för användaren. Detta är användbart när parameternamn inte har "
"någon verklig betydelse, om du vill tvinga fram ordningen på argumenten när "
"funktionen anropas eller om du behöver ta några positionella parametrar och "
"godtyckliga nyckelord."

msgid ""
"Use keyword-only when names have meaning and the function definition is more "
"understandable by being explicit with names or you want to prevent users "
"relying on the position of the argument being passed."
msgstr ""
"Använd endast nyckelord när namnen har betydelse och funktionsdefinitionen "
"blir mer begriplig genom att vara explicit med namn eller om du vill "
"förhindra att användare förlitar sig på positionen för det argument som "
"skickas."

msgid ""
"For an API, use positional-only to prevent breaking API changes if the "
"parameter's name is modified in the future."
msgstr ""
"För ett API, använd endast positionell för att förhindra att API-ändringar "
"bryts om parameterns namn ändras i framtiden."

msgid "Arbitrary Argument Lists"
msgstr "Listor med godtyckliga argument"

msgid ""
"Finally, the least frequently used option is to specify that a function can "
"be called with an arbitrary number of arguments.  These arguments will be "
"wrapped up in a tuple (see :ref:`tut-tuples`).  Before the variable number "
"of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"Slutligen, det minst använda alternativet, är att ange att en funktion kan "
"anropas med ett godtyckligt antal argument.  Dessa argument kommer att "
"paketeras i en tupel (se :ref:`tut-tuples`).  Före det variabla antalet "
"argument kan noll eller fler normala argument förekomma. ::"

msgid ""
"def write_multiple_items(file, separator, *args):\n"
"    file.write(separator.join(args))"
msgstr ""
"def write_multiple_items(file, separator, *args):\n"
"    file.write(separator.join(args))"

msgid ""
"Normally, these *variadic* arguments will be last in the list of formal "
"parameters, because they scoop up all remaining input arguments that are "
"passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can only "
"be used as keywords rather than positional arguments. ::"
msgstr ""
"Normalt kommer dessa *variadiska* argument sist i listan över formella "
"parametrar, eftersom de samlar upp alla återstående inmatningsargument som "
"skickas till funktionen. Alla formella parametrar som förekommer efter "
"parametern ``*args`` är \"keyword-only\"-argument, vilket innebär att de "
"endast kan användas som nyckelord och inte som positionsargument. ::"

msgid ""
">>> def concat(*args, sep=\"/\"):\n"
"...     return sep.join(args)\n"
"...\n"
">>> concat(\"earth\", \"mars\", \"venus\")\n"
"'earth/mars/venus'\n"
">>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n"
"'earth.mars.venus'"
msgstr ""
">>> def concat(*args, sep=\"/\"):\n"
"... return sep.join(args)\n"
"...\n"
">>> concat(\"jorden\", \"mars\", \"venus\")\n"
"'jord/mars/venus'\n"
">>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n"
"'jord.mars.venus'"

msgid "Unpacking Argument Lists"
msgstr "Uppackning av argumentlistor"

msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available "
"separately, write the function call with the  ``*``\\ -operator to unpack "
"the arguments out of a list or tuple::"
msgstr ""
"Den omvända situationen uppstår när argumenten redan finns i en lista eller "
"tupel men måste packas upp för ett funktionsanrop som kräver separata "
"positionsargument.  Till exempel förväntar sig den inbyggda funktionen :func:"
"`range` separata *start*- och *stop*-argument.  Om de inte finns "
"tillgängliga separat, skriv funktionsanropet med ``*`` -operatorn för att "
"packa upp argumenten ur en lista eller tupel::"

msgid ""
">>> list(range(3, 6))            # normal call with separate arguments\n"
"[3, 4, 5]\n"
">>> args = [3, 6]\n"
">>> list(range(*args))            # call with arguments unpacked from a "
"list\n"
"[3, 4, 5]"
msgstr ""
">>> lista(intervall(3, 6))            # normalt anrop med separata argument\n"
"[3, 4, 5]\n"
">>> args = [3, 6]\n"
">>> lista(intervall(*args))            # anrop med argument som packats upp "
"från en lista\n"
"[3, 4, 5]"

msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr ""
"På samma sätt kan ordböcker leverera nyckelordsargument med ``**`` -"
"operatorn::"

msgid ""
">>> def parrot(voltage, state='a stiff', action='voom'):\n"
"...     print(\"-- This parrot wouldn't\", action, end=' ')\n"
"...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n"
"...     print(\"E's\", state, \"!\")\n"
"...\n"
">>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", "
"\"action\": \"VOOM\"}\n"
">>> parrot(**d)\n"
"-- This parrot wouldn't VOOM if you put four million volts through it. E's "
"bleedin' demised !"
msgstr ""
">>> def papegoja(spänning, tillstånd='en stel', åtgärd='voom'):\n"
"... print(\"-- Den här papegojan skulle inte\", action, end=' ')\n"
"... print(\"om du sätter\", spänning, \"volt genom den.\", end=' ')\n"
"... print(\"E:s\", tillstånd, \"!\")\n"
"...\n"
">>> d = {\"spänning\": \"fyra miljoner\", \"tillstånd\": \"blödande "
"demised\", \"action\": \"VOOM\"}\n"
">>> papegoja(**d)\n"
"-- Den här papegojan skulle inte VOOM:a om man satte fyra miljoner volt "
"genom den. Den är jävligt demolerad!"

msgid "Lambda Expressions"
msgstr "Lambda-uttryck"

msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` keyword. "
"This function returns the sum of its two arguments: ``lambda a, b: a+b``. "
"Lambda functions can be used wherever function objects are required.  They "
"are syntactically restricted to a single expression.  Semantically, they are "
"just syntactic sugar for a normal function definition.  Like nested function "
"definitions, lambda functions can reference variables from the containing "
"scope::"
msgstr ""
"Små anonyma funktioner kan skapas med nyckelordet :keyword:`lambda`. Denna "
"funktion returnerar summan av sina två argument: ``lambda a, b: a+b``. "
"Lambda-funktioner kan användas överallt där funktionsobjekt krävs.  De är "
"syntaktiskt begränsade till ett enda uttryck.  Semantiskt sett är de bara "
"syntaktiskt socker för en normal funktionsdefinition.  Precis som nästlade "
"funktionsdefinitioner kan lambdafunktioner referera till variabler från det "
"scope som innehåller dem::"

msgid ""
">>> def make_incrementor(n):\n"
"...     return lambda x: x + n\n"
"...\n"
">>> f = make_incrementor(42)\n"
">>> f(0)\n"
"42\n"
">>> f(1)\n"
"43"
msgstr ""
">>> def make_incrementor(n):\n"
"... return lambda x: x + n\n"
"...\n"
">>> f = make_incrementor(42)\n"
">>> f(0)\n"
"42\n"
">>> f(1)\n"
"43"

msgid ""
"The above example uses a lambda expression to return a function.  Another "
"use is to pass a small function as an argument.  For instance, :meth:`list."
"sort` takes a sorting key function *key* which can be a lambda function::"
msgstr ""
"I exemplet ovan används ett lambda-uttryck för att returnera en funktion.  "
"En annan användning är att skicka en liten funktion som ett argument.  Till "
"exempel tar :meth:`list.sort` en sorteringsnyckelfunktion *key* som kan vara "
"en lambda-funktion::"

msgid ""
">>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n"
">>> pairs.sort(key=lambda pair: pair[1])\n"
">>> pairs\n"
"[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]"
msgstr ""
">>> pairs = [(1, 'ett'), (2, 'två'), (3, 'tre'), (4, 'fyra')]\n"
">>> par.sortera(nyckel=lambda par: par[1])\n"
">>> par\n"
"[(4, 'fyra'), (1, 'ett'), (3, 'tre'), (2, 'två')]"

msgid "Documentation Strings"
msgstr "Dokumentation Strängar"

msgid ""
"Here are some conventions about the content and formatting of documentation "
"strings."
msgstr ""
"Här följer några konventioner om innehåll och formatering av "
"dokumentationssträngar."

msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name or "
"type, since these are available by other means (except if the name happens "
"to be a verb describing a function's operation).  This line should begin "
"with a capital letter and end with a period."
msgstr ""
"Den första raden bör alltid vara en kort och koncis sammanfattning av "
"objektets syfte.  För korthetens skull bör inte objektets namn eller typ "
"anges explicit, eftersom dessa finns tillgängliga på annat sätt (utom om "
"namnet råkar vara ett verb som beskriver en funktions funktion).  Denna rad "
"ska inledas med en versal och avslutas med en punkt."

msgid ""
"If there are more lines in the documentation string, the second line should "
"be blank, visually separating the summary from the rest of the description.  "
"The following lines should be one or more paragraphs describing the object's "
"calling conventions, its side effects, etc."
msgstr ""
"Om det finns fler rader i dokumentationssträngen bör den andra raden vara "
"tom, så att sammanfattningen visuellt skiljs från resten av beskrivningen.  "
"De följande raderna bör vara ett eller flera stycken som beskriver objektets "
"anropskonventioner, dess bieffekter etc."

msgid ""
"The Python parser does not strip indentation from multi-line string literals "
"in Python, so tools that process documentation have to strip indentation if "
"desired.  This is done using the following convention. The first non-blank "
"line *after* the first line of the string determines the amount of "
"indentation for the entire documentation string.  (We can't use the first "
"line since it is generally adjacent to the string's opening quotes so its "
"indentation is not apparent in the string literal.)  Whitespace "
"\"equivalent\" to this indentation is then stripped from the start of all "
"lines of the string.  Lines that are indented less should not occur, but if "
"they occur all their leading whitespace should be stripped.  Equivalence of "
"whitespace should be tested after expansion of tabs (to 8 spaces, normally)."
msgstr ""
"Python-parsern tar inte bort indrag från flerradiga stränglitteraler i "
"Python, så verktyg som bearbetar dokumentation måste ta bort indrag om så "
"önskas.  Detta görs med hjälp av följande konvention. Den första icke-tomma "
"raden *efter* den första raden i strängen avgör hur mycket indrag som ska "
"göras i hela dokumentationssträngen.  (Vi kan inte använda den första raden "
"eftersom den i allmänhet ligger intill strängens inledande citattecken och "
"dess indragning därför inte syns i strängens bokstavstext)  Whitespace som "
"\"motsvarar\" detta indrag tas sedan bort från början av alla rader i "
"strängen.  Rader som är mindre indragna ska inte förekomma, men om de "
"förekommer ska alla deras ledande blanksteg tas bort.  Ekvivalens av "
"blanksteg bör testas efter expansion av tabbar (till 8 blanksteg, normalt)."

msgid "Here is an example of a multi-line docstring::"
msgstr "Här är ett exempel på en dokumentsträng med flera rader::"

msgid ""
">>> def my_function():\n"
"...     \"\"\"Do nothing, but document it.\n"
"...\n"
"...     No, really, it doesn't do anything.\n"
"...     \"\"\"\n"
"...     pass\n"
"...\n"
">>> print(my_function.__doc__)\n"
"Do nothing, but document it.\n"
"\n"
"No, really, it doesn't do anything."
msgstr ""
">>> def min_funktion():\n"
"...     \"\"\"Gör ingenting, men dokumentera det.\n"
"...\n"
"...     Nej, egentligen gör den ingenting.\n"
"...     \"\"\"\n"
"... passera\n"
"...\n"
">>> print(min_funktion.__doc__)\n"
"Gör ingenting, men dokumentera det.\n"
"\n"
"Nej, det gör verkligen ingenting."

msgid "Function Annotations"
msgstr "Funktionskommentarer"

msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see :pep:`3107` "
"and :pep:`484` for more information)."
msgstr ""
":ref:`Function annotations <function>` är helt valfri metadatainformation om "
"de typer som används av användardefinierade funktioner (se :pep:`3107` och :"
"pep:`484` för mer information)."

msgid ""
":term:`Annotations <function annotation>` are stored in the :attr:`!"
"__annotations__` attribute of the function as a dictionary and have no "
"effect on any other part of the function.  Parameter annotations are defined "
"by a colon after the parameter name, followed by an expression evaluating to "
"the value of the annotation.  Return annotations are defined by a literal ``-"
">``, followed by an expression, between the parameter list and the colon "
"denoting the end of the :keyword:`def` statement.  The following example has "
"a required argument, an optional argument, and the return value annotated::"
msgstr ""
":term:`Annotationer <function annotation>` lagras i attributet :attr:`!"
"__annotations__` i funktionen som en ordbok och har ingen effekt på någon "
"annan del av funktionen.  Parameterannoteringar definieras av ett kolon "
"efter parameternamnet, följt av ett uttryck som utvärderas till värdet på "
"annoteringen.  Returannoteringar definieras av en bokstavlig ``-&gt;``, "
"följt av ett uttryck, mellan parameterlistan och kolon som anger slutet på :"
"keyword:`def`-satsen.  Följande exempel har ett obligatoriskt argument, ett "
"valfritt argument och returvärdet annoterat::"

msgid ""
">>> def f(ham: str, eggs: str = 'eggs') -> str:\n"
"...     print(\"Annotations:\", f.__annotations__)\n"
"...     print(\"Arguments:\", ham, eggs)\n"
"...     return ham + ' and ' + eggs\n"
"...\n"
">>> f('spam')\n"
"Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class "
"'str'>}\n"
"Arguments: spam eggs\n"
"'spam and eggs'"
msgstr ""
">>> def f(skinka: str, ägg: str = 'ägg') -> str:\n"
"... print(\"Annotationer:\", f.__annotations__)\n"
"... print(\"Argument:\", skinka, ägg)\n"
"... return skinka + ' och ' + ägg\n"
"...\n"
">>> f('spam')\n"
"Anteckningar: {'skinka': <class 'str'>, 'return': <class 'str'>, 'eggs': "
"<class 'str'>}\n"
"Argument: spam ägg\n"
"'spam och ägg'"

msgid "Intermezzo: Coding Style"
msgstr "Intermezzo: Kodningsstil"

msgid ""
"Now that you are about to write longer, more complex pieces of Python, it is "
"a good time to talk about *coding style*.  Most languages can be written (or "
"more concise, *formatted*) in different styles; some are more readable than "
"others. Making it easy for others to read your code is always a good idea, "
"and adopting a nice coding style helps tremendously for that."
msgstr ""
"Nu när du är på väg att skriva längre, mer komplexa stycken Python är det "
"ett bra tillfälle att prata om *kodningsstil*.  De flesta språk kan skrivas "
"(eller mer kortfattat, *formateras*) i olika stilar; vissa är mer läsbara än "
"andra. Att göra det lätt för andra att läsa din kod är alltid en bra idé, "
"och att använda en trevlig kodningsstil hjälper enormt mycket för det."

msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  Every "
"Python developer should read it at some point; here are the most important "
"points extracted for you:"
msgstr ""
"För Python har :pep:`8` vuxit fram som den stilguide som de flesta projekt "
"följer; den främjar en mycket läsbar och tilltalande kodningsstil.  Varje "
"Python-utvecklare bör läsa den vid något tillfälle; här är de viktigaste "
"punkterna extraherade för dig:"

msgid "Use 4-space indentation, and no tabs."
msgstr "Använd 4 spaltmeters indrag och inga tabbar."

msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"4 mellanslag är en bra kompromiss mellan litet indrag (ger större "
"häckningsdjup) och stort indrag (lättare att läsa).  Tabbar skapar "
"förvirring och är bäst att utesluta."

msgid "Wrap lines so that they don't exceed 79 characters."
msgstr "Rulla om raderna så att de inte överstiger 79 tecken."

msgid ""
"This helps users with small displays and makes it possible to have several "
"code files side-by-side on larger displays."
msgstr ""
"Detta underlättar för användare med små skärmar och gör det möjligt att ha "
"flera kodfiler sida vid sida på större skärmar."

msgid ""
"Use blank lines to separate functions and classes, and larger blocks of code "
"inside functions."
msgstr ""
"Använd tomma rader för att separera funktioner och klasser, och större "
"kodblock inuti funktioner."

msgid "When possible, put comments on a line of their own."
msgstr "När det är möjligt, placera kommentarer på en egen rad."

msgid "Use docstrings."
msgstr "Använd docstrings."

msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr ""
"Använd mellanslag runt operatorer och efter kommatecken, men inte direkt "
"inuti parenteser: ``a = f(1, 2) + g(3, 4)``."

msgid ""
"Name your classes and functions consistently; the convention is to use "
"``UpperCamelCase`` for classes and ``lowercase_with_underscores`` for "
"functions and methods.  Always use ``self`` as the name for the first method "
"argument (see :ref:`tut-firstclasses` for more on classes and methods)."
msgstr ""
"Namnge dina klasser och funktioner på ett konsekvent sätt; konventionen är "
"att använda ``UpperCamelCase`` för klasser och "
"``lowercase_with_underscores`` för funktioner och metoder.  Använd alltid "
"``self`` som namn på det första metodargumentet (se :ref:`tut-firstclasses` "
"för mer information om klasser och metoder)."

msgid ""
"Don't use fancy encodings if your code is meant to be used in international "
"environments.  Python's default, UTF-8, or even plain ASCII work best in any "
"case."
msgstr ""
"Använd inte avancerade kodningar om din kod är avsedd att användas i "
"internationella miljöer.  Pythons standard, UTF-8, eller till och med vanlig "
"ASCII fungerar bäst i alla fall."

msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only the "
"slightest chance people speaking a different language will read or maintain "
"the code."
msgstr ""
"Använd inte heller icke-ASCII-tecken i identifierare om det bara finns en "
"liten risk för att personer som talar ett annat språk kommer att läsa eller "
"underhålla koden."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"Actually, *call by object reference* would be a better description, since if "
"a mutable object is passed, the caller will see any changes the callee makes "
"to it (items inserted into a list)."
msgstr ""
"Egentligen skulle *anrop genom objektreferens* vara en bättre beskrivning, "
"eftersom om ett föränderligt objekt skickas kommer den som anropar att se "
"alla ändringar som den som anropar gör på det (objekt som infogas i en "
"lista)."

msgid "statement"
msgstr "uttalande"

msgid "for"
msgstr "för"

msgid "documentation strings"
msgstr "dokumentation strängar"

msgid "docstrings"
msgstr "dokumentsträngar"

msgid "strings, documentation"
msgstr "strängar, dokumentation"

msgid "* (asterisk)"
msgstr "* (asterisk)"

msgid "in function calls"
msgstr "i funktionsanrop"

msgid "**"
msgstr "**"

msgid "function"
msgstr "funktion"

msgid "annotations"
msgstr "anteckningar"

msgid "->"
msgstr "->"

msgid "function annotations"
msgstr "funktionskommentarer"

msgid ": (colon)"
msgstr ": (kolon)"

msgid "coding"
msgstr "kodning"

msgid "style"
msgstr "stil"
