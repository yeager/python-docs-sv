# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Runners"
msgstr "Löpare"

msgid "**Source code:** :source:`Lib/asyncio/runners.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/runners.py`"

msgid ""
"This section outlines high-level asyncio primitives to run asyncio code."
msgstr ""
"I detta avsnitt beskrivs asyncioprimitiver på hög nivå för att köra "
"asynciokod."

msgid ""
"They are built on top of an :ref:`event loop <asyncio-event-loop>` with the "
"aim to simplify async code usage for common wide-spread scenarios."
msgstr ""
"De är byggda ovanpå en :ref:`event loop <asyncio-event-loop>` med målet att "
"förenkla asynkron kodanvändning för vanliga, utbredda scenarier."

msgid "Running an asyncio Program"
msgstr "Kör ett asyncioprogram"

msgid "Execute *coro* in an asyncio event loop and return the result."
msgstr "Kör *coro* i en asynciohändelseslinga och returnera resultatet."

msgid "The argument can be any awaitable object."
msgstr "Argumentet kan vara vilket väntande objekt som helst."

msgid ""
"This function runs the awaitable, taking care of managing the asyncio event "
"loop, *finalizing asynchronous generators*, and closing the executor."
msgstr ""
"Denna funktion kör awaitable och tar hand om hanteringen av "
"asynciohändelseslingan, *finaliserar asynkrona generatorer* och stänger "
"exekutorn."

msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Denna funktion kan inte anropas när en annan asyncio-händelseslinga körs i "
"samma tråd."

msgid ""
"If *debug* is ``True``, the event loop will be run in debug mode. ``False`` "
"disables debug mode explicitly. ``None`` is used to respect the global :ref:"
"`asyncio-debug-mode` settings."
msgstr ""
"Om *debug* är ``True`` kommer händelseslingan att köras i debug-läge. "
"``False`` inaktiverar debug-läget explicit. ``None`` används för att "
"respektera de globala inställningarna för :ref:`asyncio-debug-mode`."

msgid ""
"If *loop_factory* is not ``None``, it is used to create a new event loop; "
"otherwise :func:`asyncio.new_event_loop` is used. The loop is closed at the "
"end. This function should be used as a main entry point for asyncio "
"programs, and should ideally only be called once. It is recommended to use "
"*loop_factory* to configure the event loop instead of policies. Passing :"
"class:`asyncio.EventLoop` allows running asyncio without the policy system."
msgstr ""
"Om *loop_factory* inte är ``None`` används den för att skapa en ny "
"händelseslinga; annars används :func:`asyncio.new_event_loop`. Slingan "
"stängs i slutet. Denna funktion bör användas som en huvudingångspunkt för "
"asyncioprogram och bör helst bara anropas en gång. Det rekommenderas att "
"använda *loop_factory* för att konfigurera händelseslingan i stället för "
"policies. Genom att skicka :class:`asyncio.EventLoop` kan man köra asyncio "
"utan policysystemet."

msgid ""
"The executor is given a timeout duration of 5 minutes to shutdown. If the "
"executor hasn't finished within that duration, a warning is emitted and the "
"executor is closed."
msgstr ""
"Exekveraren får en timeout på 5 minuter för att stängas av. Om exekveraren "
"inte har avslutats inom denna tid utfärdas en varning och exekveraren stängs."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    skriv ut('hello')\n"
"\n"
"asyncio.run(main())"

msgid "Updated to use :meth:`loop.shutdown_default_executor`."
msgstr "Uppdaterad för att använda :meth:`loop.shutdown_default_executor`."

msgid ""
"*debug* is ``None`` by default to respect the global debug mode settings."
msgstr ""
"*debug* är ``None`` som standard för att respektera de globala "
"inställningarna för felsökningsläget."

msgid "Added *loop_factory* parameter."
msgstr "Lagt till parametern *loop_factory*."

msgid "*coro* can be any awaitable object."
msgstr "*coro* kan vara vilket väntande objekt som helst."

msgid ""
"The :mod:`!asyncio` policy system is deprecated and will be removed in "
"Python 3.16; from there on, an explicit *loop_factory* is needed to "
"configure the event loop."
msgstr ""
"Policysystemet :mod:`!asyncio` är föråldrat och kommer att tas bort i Python "
"3.16; från och med då behövs en explicit *loop_factory* för att konfigurera "
"händelseslingan."

msgid "Runner context manager"
msgstr "Kontexthanterare för löpare"

msgid ""
"A context manager that simplifies *multiple* async function calls in the "
"same context."
msgstr ""
"En kontexthanterare som förenklar *flera* asynkrona funktionsanrop i samma "
"kontext."

msgid ""
"Sometimes several top-level async functions should be called in the same :"
"ref:`event loop <asyncio-event-loop>` and :class:`contextvars.Context`."
msgstr ""
"Ibland bör flera asynkrona funktioner på toppnivå anropas i samma :ref:"
"`event loop <asyncio-event-loop>` och :class:`contextvars.Context`."

msgid ""
"*loop_factory* could be used for overriding the loop creation. It is the "
"responsibility of the *loop_factory* to set the created loop as the current "
"one. By default :func:`asyncio.new_event_loop` is used and set as current "
"event loop with :func:`asyncio.set_event_loop` if *loop_factory* is ``None``."
msgstr ""
"*loop_factory* kan användas för att åsidosätta skapandet av slingan. Det är "
"*loop_factory*:s ansvar att ställa in den skapade loopen som den aktuella. "
"Som standard används :func:`asyncio.new_event_loop` och ställs in som "
"aktuell händelseslinga med :func:`asyncio.set_event_loop` om *loop_factory* "
"är ``None``."

msgid ""
"Basically, :func:`asyncio.run` example can be rewritten with the runner "
"usage::"
msgstr ""
"I grund och botten kan :func:`asyncio.run` -exemplet skrivas om med runner-"
"användningen::"

msgid ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    print('hello')\n"
"\n"
"with asyncio.Runner() as runner:\n"
"    runner.run(main())"
msgstr ""
"async def main():\n"
"    await asyncio.sleep(1)\n"
"    skriv ut('hello')\n"
"\n"
"med asyncio.Runner() som runner:\n"
"    runner.run(main())"

msgid "Execute *coro* in the embedded event loop."
msgstr "Exekvera *coro* i den inbäddade händelseslingan."

msgid "If the argument is a coroutine, it is wrapped in a Task."
msgstr "Om argumentet är en coroutine paketeras det in i en Task."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the code to run in. The runner's default "
"context is used if context is ``None``."
msgstr ""
"Ett valfritt argument *context* som endast innehåller nyckelord gör det "
"möjligt att ange en anpassad :class:`contextvars.Context` för koden som ska "
"köras i. Om context är ``None`` används löparens standardkontext."

msgid "Returns the awaitable's result or raises an exception."
msgstr "Returnerar awaitable-resultatet eller skapar ett undantag."

msgid "Close the runner."
msgstr "Stäng löparen."

msgid ""
"Finalize asynchronous generators, shutdown default executor, close the event "
"loop and release embedded :class:`contextvars.Context`."
msgstr ""
"Slutför asynkrona generatorer, stäng av standardutföraren, stäng "
"händelseslingan och släpp inbäddade :class:`contextvars.Context`."

msgid "Return the event loop associated with the runner instance."
msgstr "Returnerar den händelseslinga som är associerad med runner-instansen."

msgid ""
":class:`Runner` uses the lazy initialization strategy, its constructor "
"doesn't initialize underlying low-level structures."
msgstr ""
":class:`Runner` använder strategin lazy initialization, dess konstruktör "
"initierar inte underliggande strukturer på låg nivå."

msgid ""
"Embedded *loop* and *context* are created at the :keyword:`with` body "
"entering or the first call of :meth:`run` or :meth:`get_loop`."
msgstr ""
"Inbäddade *loop* och *context* skapas vid :keyword:`with` body entry eller "
"vid första anropet av :meth:`run` eller :meth:`get_loop`."

msgid "Handling Keyboard Interruption"
msgstr "Hantering av tangentbordsavbrott"

msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, :exc:"
"`KeyboardInterrupt` exception is raised in the main thread by default. "
"However this doesn't work with :mod:`asyncio` because it can interrupt "
"asyncio internals and can hang the program from exiting."
msgstr ""
"När :const:`signal.SIGINT` utlöses av :kbd:`Ctrl-C`, utlöses :exc:"
"`KeyboardInterrupt` undantag i huvudtråden som standard. Detta fungerar dock "
"inte med :mod:`asyncio` eftersom det kan avbryta asyncio-interna funktioner "
"och kan hindra programmet från att avslutas."

msgid ""
"To mitigate this issue, :mod:`asyncio` handles :const:`signal.SIGINT` as "
"follows:"
msgstr ""
"För att mildra detta problem hanterar :mod:`asyncio` :const:`signal.SIGINT` "
"på följande sätt:"

msgid ""
":meth:`asyncio.Runner.run` installs a custom :const:`signal.SIGINT` handler "
"before any user code is executed and removes it when exiting from the "
"function."
msgstr ""
":meth:`asyncio.Runner.run` installerar en anpassad :const:`signal.SIGINT`-"
"hanterare innan någon användarkod exekveras och tar bort den när funktionen "
"avslutas."

msgid ""
"The :class:`~asyncio.Runner` creates the main task for the passed coroutine "
"for its execution."
msgstr ""
"Klassen:`~asyncio.Runner` skapar en huvuduppgift för den passerade "
"coroutinen för dess exekvering."

msgid ""
"When :const:`signal.SIGINT` is raised by :kbd:`Ctrl-C`, the custom signal "
"handler cancels the main task by calling :meth:`asyncio.Task.cancel` which "
"raises :exc:`asyncio.CancelledError` inside the main task.  This causes the "
"Python stack to unwind, ``try/except`` and ``try/finally`` blocks can be "
"used for resource cleanup.  After the main task is cancelled, :meth:`asyncio."
"Runner.run` raises :exc:`KeyboardInterrupt`."
msgstr ""
"När :const:`signal.SIGINT` genereras av :kbd:`Ctrl-C`, avbryter den "
"anpassade signalhanteraren huvuduppgiften genom att anropa :meth:`asyncio."
"Task.cancel` som genererar :exc:`asyncio.CancelledError` inuti "
"huvuduppgiften.  Detta gör att Python-stacken rullas upp, ``try/except`` och "
"``try/finally`` block kan användas för resursrensning.  Efter att "
"huvuduppgiften har avbrutits ger :meth:`asyncio.Runner.run` upphov till :exc:"
"`KeyboardInterrupt`."

msgid ""
"A user could write a tight loop which cannot be interrupted by :meth:"
"`asyncio.Task.cancel`, in which case the second following :kbd:`Ctrl-C` "
"immediately raises the :exc:`KeyboardInterrupt` without cancelling the main "
"task."
msgstr ""
"En användare kan skriva en tät loop som inte kan avbrytas av :meth:`asyncio."
"Task.cancel`, i vilket fall den andra följande :kbd:`Ctrl-C` omedelbart ger "
"upphov till :exc:`KeyboardInterrupt` utan att avbryta huvuduppgiften."
