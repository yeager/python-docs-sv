# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!getopt` --- C-style parser for command line options"
msgstr ":mod:`!getopt` --- C-stilsanalysator för kommandoradsalternativ"

msgid "**Source code:** :source:`Lib/getopt.py`"
msgstr "**Källkod:** :source:`Lib/getopt.py`"

msgid ""
"This module is considered feature complete. A more declarative and "
"extensible alternative to this API is provided in the :mod:`optparse` "
"module. Further functional enhancements for command line parameter "
"processing are provided either as third party modules on PyPI, or else as "
"features in the :mod:`argparse` module."
msgstr ""
"Denna modul anses vara funktionsmässigt komplett. Ett mer deklarativt och "
"utbyggbart alternativ till detta API finns i modulen :mod:`optparse`. "
"Ytterligare funktionella förbättringar för bearbetning av "
"kommandoradsparametrar tillhandahålls antingen som tredjepartsmoduler på "
"PyPI eller som funktioner i modulen :mod:`argparse`."

msgid ""
"This module helps scripts to parse the command line arguments in ``sys."
"argv``. It supports the same conventions as the Unix :c:func:`!getopt` "
"function (including the special meanings of arguments of the form '``-``' "
"and '``--``').  Long options similar to those supported by GNU software may "
"be used as well via an optional third argument."
msgstr ""
"Denna modul hjälper skript att tolka kommandoradsargumenten i ``sys.argv``. "
"Den stöder samma konventioner som Unix :c:func:`!getopt`-funktionen "
"(inklusive de speciella betydelserna av argument av formen '``-``' och '``--"
"``').  Långa alternativ liknande dem som stöds av GNU-programvara kan också "
"användas via ett valfritt tredje argument."

msgid ""
"Users who are unfamiliar with the Unix :c:func:`!getopt` function should "
"consider using the :mod:`argparse` module instead. Users who are familiar "
"with the Unix :c:func:`!getopt` function, but would like to get equivalent "
"behavior while writing less code and getting better help and error messages "
"should consider using the :mod:`optparse` module. See :ref:`choosing-an-"
"argument-parser` for additional details."
msgstr ""
"Användare som inte är bekanta med Unix-funktionen :c:func:`!getopt` bör "
"överväga att använda modulen :mod:`argparse` i stället. Användare som är "
"bekanta med Unix :c:func:`!getopt`-funktionen, men som vill få motsvarande "
"beteende samtidigt som de skriver mindre kod och får bättre hjälp- och "
"felmeddelanden bör överväga att använda modulen :mod:`optparse`. Se :ref:"
"`choosing-an-argument-parser` för ytterligare detaljer."

msgid "This module provides two functions and an exception:"
msgstr "Denna modul innehåller två funktioner och ett undantag:"

msgid ""
"Parses command line options and parameter list.  *args* is the argument list "
"to be parsed, without the leading reference to the running program. "
"Typically, this means ``sys.argv[1:]``. *shortopts* is the string of option "
"letters that the script wants to recognize, with options that require an "
"argument followed by a colon (``':'``) and options that accept an optional "
"argument followed by two colons (``'::'``); i.e., the same format that Unix :"
"c:func:`!getopt` uses."
msgstr ""
"Analyserar kommandoradsalternativ och parameterlista.  *args* är den "
"argumentlista som ska analyseras, utan den inledande referensen till det "
"program som körs. Vanligtvis betyder detta ``sys.argv[1:]``. *shortopts* är "
"den sträng med alternativbokstäver som skriptet vill känna igen, med "
"alternativ som kräver ett argument följt av ett kolon (``':'``) och "
"alternativ som accepterar ett valfritt argument följt av två kolon "
"(``'::'``); dvs. samma format som Unix :c:func:`!getopt` använder."

msgid ""
"Unlike GNU :c:func:`!getopt`, after a non-option argument, all further "
"arguments are considered also non-options. This is similar to the way non-"
"GNU Unix systems work."
msgstr ""
"Till skillnad från GNU :c:func:`!getopt`, efter ett argument som inte är ett "
"alternativ, anses alla ytterligare argument också vara icke-alternativ. "
"Detta liknar det sätt på vilket Unix-system som inte är GNU fungerar."

msgid ""
"*longopts*, if specified, must be a list of strings with the names of the "
"long options which should be supported.  The leading ``'--'`` characters "
"should not be included in the option name.  Long options which require an "
"argument should be followed by an equal sign (``'='``). Long options which "
"accept an optional argument should be followed by an equal sign and question "
"mark (``'=?'``). To accept only long options, *shortopts* should be an empty "
"string.  Long options on the command line can be recognized so long as they "
"provide a prefix of the option name that matches exactly one of the accepted "
"options.  For example, if *longopts* is ``['foo', 'frob']``, the option ``--"
"fo`` will match as ``--foo``, but ``--f`` will not match uniquely, so :exc:"
"`GetoptError` will be raised."
msgstr ""
"*longopts*, om det anges, måste vara en lista med strängar med namnen på de "
"långa alternativ som ska stödjas.  De inledande tecknen ``'--'`` skall inte "
"ingå i alternativnamnet.  Långa alternativ som kräver ett argument skall "
"följas av ett likhetstecken (``'='``). Långa alternativ som accepterar ett "
"valfritt argument bör följas av ett likhetstecken och ett frågetecken "
"(``'=?'``). För att endast acceptera långa alternativ bör *shortopts* vara "
"en tom sträng.  Långa alternativ på kommandoraden kan identifieras så länge "
"som de innehåller ett prefix för alternativnamnet som matchar exakt ett av "
"de accepterade alternativen.  Om *longopts* till exempel är ``['foo', "
"'frob']``, kommer alternativet ``--fo`` att matcha som ``--foo``, men ``--"
"f`` kommer inte att matcha unikt, så :exc:`GetoptError` kommer att uppstå."

msgid ""
"The return value consists of two elements: the first is a list of ``(option, "
"value)`` pairs; the second is the list of program arguments left after the "
"option list was stripped (this is a trailing slice of *args*).  Each option-"
"and-value pair returned has the option as its first element, prefixed with a "
"hyphen for short options (e.g., ``'-x'``) or two hyphens for long options (e."
"g., ``'--long-option'``), and the option argument as its second element, or "
"an empty string if the option has no argument.  The options occur in the "
"list in the same order in which they were found, thus allowing multiple "
"occurrences.  Long and short options may be mixed."
msgstr ""
"Returvärdet består av två element: det första är en lista med paren "
"``(option, value)``; det andra är listan med programargument som finns kvar "
"efter att optionslistan har rensats (detta är en efterföljande del av "
"*args*).  Varje alternativ- och värdepar som returneras har alternativet som "
"sitt första element, med ett bindestreck som prefix för korta alternativ (t."
"ex. ``'-x'``) eller två bindestreck för långa alternativ (t.ex. ``'--long-"
"option'``), och alternativets argument som sitt andra element, eller en tom "
"sträng om alternativet inte har något argument.  Alternativen förekommer i "
"listan i samma ordning som de hittades, vilket innebär att de kan förekomma "
"flera gånger.  Långa och korta alternativ kan blandas."

msgid "Optional arguments are supported."
msgstr "Valfria argument stöds."

msgid ""
"This function works like :func:`getopt`, except that GNU style scanning mode "
"is used by default. This means that option and non-option arguments may be "
"intermixed. The :func:`getopt` function stops processing options as soon as "
"a non-option argument is encountered."
msgstr ""
"Den här funktionen fungerar som :func:`getopt`, förutom att GNU-stilens "
"skanningsläge används som standard. Detta innebär att alternativ- och icke-"
"alternativargument kan blandas. Funktionen :func:`getopt` slutar att "
"bearbeta alternativ så snart ett argument som inte är ett alternativ "
"påträffas."

msgid ""
"If the first character of the option string is ``'+'``, or if the "
"environment variable :envvar:`!POSIXLY_CORRECT` is set, then option "
"processing stops as soon as a non-option argument is encountered."
msgstr ""
"Om det första tecknet i alternativsträngen är ``'+'``, eller om "
"miljövariabeln :envvar:`!POSIXLY_CORRECT` är inställd, stoppas "
"alternativbehandlingen så snart ett argument som inte är ett alternativ "
"påträffas."

msgid ""
"If the first character of the option string is ``'-'``, non-option arguments "
"that are followed by options are added to the list of option-and-value pairs "
"as a pair that has ``None`` as its first element and the list of non-option "
"arguments as its second element. The second element of the :func:`!"
"gnu_getopt` result is a list of program arguments after the last option."
msgstr ""
"Om det första tecknet i optionssträngen är ``'-'`` läggs icke-"
"optionsargument som följs av optioner till i listan över options- och "
"värdepar som ett par med ``None`` som första element och listan över icke-"
"optionsargument som andra element. Det andra elementet i :func:`!gnu_getopt`-"
"resultatet är en lista över programargument efter det sista alternativet."

msgid ""
"Support for returning intermixed options and non-option arguments in order."
msgstr ""
"Stöd för att returnera blandade alternativ och icke-alternativargument i "
"ordning."

msgid ""
"This is raised when an unrecognized option is found in the argument list or "
"when an option requiring an argument is given none. The argument to the "
"exception is a string indicating the cause of the error.  For long options, "
"an argument given to an option which does not require one will also cause "
"this exception to be raised.  The attributes :attr:`!msg` and :attr:`!opt` "
"give the error message and related option; if there is no specific option to "
"which the exception relates, :attr:`!opt` is an empty string."
msgstr ""
"Detta anges när ett okänt alternativ hittas i argumentlistan eller när ett "
"alternativ som kräver ett argument inte anges. Argumentet till undantaget är "
"en sträng som anger orsaken till felet.  För långa alternativ kommer ett "
"argument som ges till ett alternativ som inte kräver något argument också "
"att leda till att detta undantag aktiveras.  Attributen :attr:`!msg` och :"
"attr:`!opt` ger felmeddelandet och det relaterade alternativet; om det inte "
"finns något specifikt alternativ som undantaget relaterar till, är :attr:`!"
"opt` en tom sträng."

msgid "Alias for :exc:`GetoptError`; for backward compatibility."
msgstr "Alias för :exc:`GetoptError`; för bakåtkompatibilitet."

msgid "An example using only Unix style options:"
msgstr "Ett exempel som endast använder Unix-alternativ:"

msgid ""
">>> import getopt\n"
">>> args = '-a -b -cfoo -d bar a1 a2'.split()\n"
">>> args\n"
"['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']\n"
">>> optlist, args = getopt.getopt(args, 'abc:d:')\n"
">>> optlist\n"
"[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]\n"
">>> args\n"
"['a1', 'a2']"
msgstr ""
">>> import getopt\n"
">>> args = '-a -b -cfoo -d bar a1 a2'.split()\n"
">>> args\n"
"['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']\n"
">>> optlist, args = getopt.getopt(args, 'abc:d:')\n"
">>> optlist\n"
"[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]\n"
">>> args\n"
"['a1', 'a2']"

msgid "Using long option names is equally easy:"
msgstr "Det är lika enkelt att använda långa optionsnamn:"

msgid ""
">>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'\n"
">>> args = s.split()\n"
">>> args\n"
"['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', "
"'a2']\n"
">>> optlist, args = getopt.getopt(args, 'x', [\n"
"...     'condition=', 'output-file=', 'testing'])\n"
">>> optlist\n"
"[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-"
"x', '')]\n"
">>> args\n"
"['a1', 'a2']"
msgstr ""
">>> s = '--villkor=foo --testning --utdatafil abc.def -x a1 a2'\n"
">>> args = s.split()\n"
">>> args\n"
"['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', "
"'a2'] >>> optlist\n"
">>> optlist, args = getopt.getopt(args, 'x', [\n"
"...     'condition=', 'output-file=', 'testing'])\n"
">>> optlist\n"
"[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-"
"x', '')]\n"
">>> args\n"
"['a1', 'a2']"

msgid "Optional arguments should be specified explicitly:"
msgstr "Valfria argument bör anges explicit:"

msgid ""
">>> s = '-Con -C --color=off --color a1 a2'\n"
">>> args = s.split()\n"
">>> args\n"
"['-Con', '-C', '--color=off', '--color', 'a1', 'a2']\n"
">>> optlist, args = getopt.getopt(args, 'C::', ['color=?'])\n"
">>> optlist\n"
"[('-C', 'on'), ('-C', ''), ('--color', 'off'), ('--color', '')]\n"
">>> args\n"
"['a1', 'a2']"
msgstr ""
">>> s = '-Con -C --färg=av --färg a1 a2'\n"
">>> args = s.split()\n"
">>> args\n"
"['-Con', '-C', '--color=off', '--color', 'a1', 'a2']\n"
">>> optlist, args = getopt.getopt(args, 'C::', ['color=?'])\n"
">>> optlist\n"
"[('-C', 'on'), ('-C', ''), ('--color', 'off'), ('--color', '')]\n"
">>> args\n"
"['a1', 'a2']"

msgid "The order of options and non-option arguments can be preserved:"
msgstr "Ordningen på alternativ och icke-alternativargument kan bevaras:"

msgid ""
">>> s = 'a1 -x a2 a3 a4 --long a5 a6'\n"
">>> args = s.split()\n"
">>> args\n"
"['a1', '-x', 'a2', 'a3', 'a4', '--long', 'a5', 'a6']\n"
">>> optlist, args = getopt.gnu_getopt(args, '-x:', ['long='])\n"
">>> optlist\n"
"[(None, ['a1']), ('-x', 'a2'), (None, ['a3', 'a4']), ('--long', 'a5')]\n"
">>> args\n"
"['a6']"
msgstr ""
">>> s = 'a1 -x a2 a3 a4 --lång a5 a6'\n"
">>> args = s.split()\n"
">>> args\n"
"['a1', '-x', 'a2', 'a3', 'a4', '--long', 'a5', 'a6']\n"
">>> optlist, args = getopt.gnu_getopt(args, '-x:', ['long='])\n"
">>> optlist\n"
"[(None, ['a1']), ('-x', 'a2'), (None, ['a3', 'a4']), ('--long', 'a5')]\n"
">>> args\n"
"['a6']"

msgid "In a script, typical usage is something like this:"
msgstr "I ett skript är den typiska användningen ungefär så här:"

msgid ""
"import getopt, sys\n"
"\n"
"def main():\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", "
"\"output=\"])\n"
"    except getopt.GetoptError as err:\n"
"        # print help information and exit:\n"
"        print(err)  # will print something like \"option -a not "
"recognized\"\n"
"        usage()\n"
"        sys.exit(2)\n"
"    output = None\n"
"    verbose = False\n"
"    for o, a in opts:\n"
"        if o == \"-v\":\n"
"            verbose = True\n"
"        elif o in (\"-h\", \"--help\"):\n"
"            usage()\n"
"            sys.exit()\n"
"        elif o in (\"-o\", \"--output\"):\n"
"            output = a\n"
"        else:\n"
"            assert False, \"unhandled option\"\n"
"    process(args, output=output, verbose=verbose)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""
"import getopt, sys\n"
"\n"
"def main():\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", "
"\"output=\"])\n"
"    except getopt.getoptError as err:\n"
"        # skriv ut hjälpinformation och avsluta:\n"
"        print(err) # kommer att skriva ut något i stil med \"option -a not "
"recognized\"\n"
"        användning()\n"
"        sys.exit(2)\n"
"    output = Ingen\n"
"    verbose = Falsk\n"
"    för o, a i opts:\n"
"        om o == \"-v\":\n"
"            verbose = Sann\n"
"        elif o i (\"-h\", \"--help\"):\n"
"            användning()\n"
"            sys.exit()\n"
"        elif o in (\"-o\", \"--output\"):\n"
"            utdata = a\n"
"        else:\n"
"            assert False, \"obehandlat alternativ\"\n"
"    process(args, output=output, verbose=verbose)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"

msgid ""
"Note that an equivalent command line interface could be produced with less "
"code and more informative help and error messages by using the :mod:"
"`optparse` module:"
msgstr ""
"Observera att ett motsvarande kommandoradsgränssnitt kan produceras med "
"mindre kod och mer informativa hjälp- och felmeddelanden genom att använda "
"modulen :mod:`optparse`:"

msgid ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"
msgstr ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"

msgid ""
"A roughly equivalent command line interface for this case can also be "
"produced by using the :mod:`argparse` module:"
msgstr ""
"Ett ungefär motsvarande kommandoradsgränssnitt för detta fall kan också "
"produceras genom att använda modulen :mod:`argparse`:"

msgid ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"
msgstr ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"

msgid ""
"See :ref:`choosing-an-argument-parser` for details on how the ``argparse`` "
"version of this code differs in behaviour from the ``optparse`` (and "
"``getopt``) version."
msgstr ""
"Se :ref:`choosing-an-argument-parser` för detaljer om hur ``argparse``-"
"versionen av denna kod skiljer sig i beteende från ``optparse`` (och "
"``getopt``)-versionen."

msgid "Module :mod:`optparse`"
msgstr "Modul :mod:`optparse`"

msgid "Declarative command line option parsing."
msgstr "Deklarativ parsning av kommandoradsalternativ."

msgid "Module :mod:`argparse`"
msgstr "Modul :mod:`argparse`"

msgid "More opinionated command line option and argument parsing library."
msgstr "Ett bibliotek som tolkar alternativ och argument på kommandoraden."
