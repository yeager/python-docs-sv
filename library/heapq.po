# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!heapq` --- Heap queue algorithm"
msgstr ":mod:`!heapq` --- Algoritm för heap-köer"

msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**Källkod:** :source:`Lib/heapq.py`"

msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr ""
"Denna modul ger en implementation av heap-köalgoritmen, även känd som "
"prioritetsköalgoritmen."

msgid ""
"Min-heaps are binary trees for which every parent node has a value less than "
"or equal to any of its children. We refer to this condition as the heap "
"invariant."
msgstr ""
"Min-heaps är binära träd där varje föräldernod har ett värde som är mindre "
"än eller lika med något av dess barn. Vi hänvisar till detta villkor som "
"heap-invariant."

msgid ""
"For min-heaps, this implementation uses lists for which ``heap[k] <= "
"heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]`` for all *k* for which the "
"compared elements exist.  Elements are counted from zero.  The interesting "
"property of a min-heap is that its smallest element is always the root, "
"``heap[0]``."
msgstr ""
"För min-heaps använder den här implementationen listor för vilka ``heap[k] "
"<= heap[2*k+1]`` och ``heap[k] <= heap[2*k+2]`` för alla *k* för vilka de "
"jämförda elementen finns.  Elementen räknas från noll.  Den intressanta "
"egenskapen hos en min-heap är att dess minsta element alltid är roten, "
"``heap[0]``."

msgid ""
"Max-heaps satisfy the reverse invariant: every parent node has a value "
"*greater* than any of its children.  These are implemented as lists for "
"which ``maxheap[2*k+1] <= maxheap[k]`` and ``maxheap[2*k+2] <= maxheap[k]`` "
"for all *k* for which the compared elements exist. The root, ``maxheap[0]``, "
"contains the *largest* element; ``heap.sort(reverse=True)`` maintains the "
"max-heap invariant."
msgstr ""
"Max-heaps uppfyller den omvända invarianten: varje överordnad nod har ett "
"värde som är *större* än något av dess barn.  Dessa implementeras som listor "
"för vilka ``maxheap[2*k+1] <= maxheap[k]`` och ``maxheap[2*k+2] <= "
"maxheap[k]`` för alla *k* för vilka de jämförda elementen finns. Roten, "
"``maxheap[0]``, innehåller det *största* elementet; ``heap."
"sort(reverse=True)`` upprätthåller max-heap-invariansen."

msgid ""
"The :mod:`!heapq` API differs from textbook heap algorithms in two aspects: "
"(a) We use zero-based indexing.  This makes the relationship between the "
"index for a node and the indexes for its children slightly less obvious, but "
"is more suitable since Python uses zero-based indexing. (b) Textbooks often "
"focus on max-heaps, due to their suitability for in-place sorting. Our "
"implementation favors min-heaps as they better correspond to Python :class:"
"`lists <list>`."
msgstr ""
"API:et :mod:`!heapq` skiljer sig från lärobokens heap-algoritmer i två "
"avseenden: (a) Vi använder nollbaserad indexering.  Detta gör förhållandet "
"mellan indexet för en nod och indexen för dess barn något mindre uppenbart, "
"men är mer lämpligt eftersom Python använder nollbaserad indexering. (b) "
"Läroböcker fokuserar ofta på max-heaps på grund av deras lämplighet för in-"
"place-sortering. Vår implementation föredrar min-heaps eftersom de bättre "
"motsvarar Python :class:`lists <list>`."

msgid ""
"These two aspects make it possible to view the heap as a regular Python list "
"without surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` "
"maintains the heap invariant!"
msgstr ""
"Dessa två aspekter gör det möjligt att se högen som en vanlig Python-lista "
"utan överraskningar: ``heap[0]`` är det minsta objektet, och ``heap.sort()`` "
"upprätthåller heap-invarianten!"

msgid ""
"Like :meth:`list.sort`, this implementation uses only the ``<`` operator for "
"comparisons, for both min-heaps and max-heaps."
msgstr ""
"Liksom :meth:`list.sort` använder denna implementation endast operatorn "
"``<`` för jämförelser, för både min-heaps och max-heaps."

msgid ""
"In the API below, and in this documentation, the unqualified term *heap* "
"generally refers to a min-heap. The API for max-heaps is named using a "
"``_max``  suffix."
msgstr ""
"I API:et nedan, och i den här dokumentationen, avser den okvalificerade "
"termen *heap* i allmänhet en min-heap. API:et för max-heaps namnges med "
"suffixet ``_max``."

msgid ""
"To create a heap, use a list initialized as ``[]``, or transform an existing "
"list into a min-heap or max-heap using the :func:`heapify` or :func:"
"`heapify_max` functions, respectively."
msgstr ""
"För att skapa en hög använder du en lista som initierats som ``[]``, eller "
"omvandlar en befintlig lista till en min- eller maxhög med hjälp av "
"funktionerna :func:`heapify` respektive :func:`heapify_max`."

msgid "The following functions are provided for min-heaps:"
msgstr "Följande funktioner finns för min-högar:"

msgid ""
"Push the value *item* onto the *heap*, maintaining the min-heap invariant."
msgstr "Skjut upp värdet *item* på *heap*, med bibehållen min-heap-invariant."

msgid ""
"Pop and return the smallest item from the *heap*, maintaining the min-heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access "
"the smallest item without popping it, use ``heap[0]``."
msgstr ""
"Plockar ut och returnerar det minsta objektet från *högen*, med bibehållen "
"min-heap-invariant.  Om högen är tom, uppstår :exc:`IndexError`.  För att "
"komma åt det minsta objektet utan att poppa det, använd ``heap[0]``."

msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr ""
"Skjut *objekt* på högen, sedan popa upp och returnera det minsta objektet "
"från *högen*.  Den kombinerade åtgärden körs mer effektivt än :func:"
"`heappush` följt av ett separat anrop till :func:`heappop`."

msgid "Transform list *x* into a min-heap, in-place, in linear time."
msgstr "Omvandla listan *x* till en min-heap, på plats, i linjär tid."

msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Popa och returnera det minsta objektet från *heapen*, och även pusha det nya "
"*objektet*. Stapelns storlek ändras inte. Om högen är tom, uppstår :exc:"
"`IndexError`."

msgid ""
"This one step operation is more efficient than a :func:`heappop` followed "
"by :func:`heappush` and can be more appropriate when using a fixed-size "
"heap. The pop/push combination always returns an element from the heap and "
"replaces it with *item*."
msgstr ""
"Denna operation i ett steg är mer effektiv än :func:`heappop` följt av :func:"
"`heappush` och kan vara mer lämplig när man använder en heap med fast "
"storlek. Kombinationen pop/push returnerar alltid ett element från högen och "
"ersätter det med *item*."

msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger value "
"on the heap."
msgstr ""
"Det returnerade värdet kan vara större än det tillagda *objektet*.  Om detta "
"inte är önskvärt kan du överväga att använda :func:`heappushpop` istället.  "
"Dess push/pop-kombination returnerar det mindre av de två värdena och lämnar "
"det större värdet på högen."

msgid "For max-heaps, the following functions are provided:"
msgstr "För max-heaps finns följande funktioner:"

msgid "Transform list *x* into a max-heap, in-place, in linear time."
msgstr "Omvandla listan *x* till en max-heap, på plats, i linjär tid."

msgid ""
"Push the value *item* onto the max-heap *heap*, maintaining the max-heap "
"invariant."
msgstr ""
"Skjut upp värdet *item* till max-heap *heap*, med bibehållen max-heap-"
"invariant."

msgid ""
"Pop and return the largest item from the max-heap *heap*, maintaining the "
"max-heap invariant.  If the max-heap is empty, :exc:`IndexError` is raised. "
"To access the largest item without popping it, use ``maxheap[0]``."
msgstr ""
"Plockar ut och returnerar det största objektet från max-heap *heap*, med "
"bibehållen max-heap-invariant.  Om max-heap är tom, uppstår :exc:"
"`IndexError`. För att komma åt det största objektet utan att poppa det, "
"använd ``maxheap[0]``."

msgid ""
"Push *item* on the max-heap *heap*, then pop and return the largest item "
"from *heap*. The combined action runs more efficiently than :func:"
"`heappush_max` followed by a separate call to :func:`heappop_max`."
msgstr ""
"Tryck *item* på max-heap *heap*, sedan popa och returnera det största "
"objektet från *heap*. Den kombinerade åtgärden körs mer effektivt än :func:"
"`heappush_max` följt av ett separat anrop till :func:`heappop_max`."

msgid ""
"Pop and return the largest item from the max-heap *heap* and also push the "
"new *item*. The max-heap size doesn't change. If the max-heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Popa och returnera det största objektet från max-heap *heap* och pusha även "
"det nya *objektet*. Storleken på max-heap ändras inte. Om max-heapen är "
"tom, :exc:`IndexError` tas upp."

msgid ""
"The value returned may be smaller than the *item* added.  Refer to the "
"analogous function :func:`heapreplace` for detailed usage notes."
msgstr ""
"Det returnerade värdet kan vara mindre än det tillagda *objektet*.  Se den "
"analoga funktionen :func:`heapreplace` för detaljerade "
"användningsanvisningar."

msgid "The module also offers three general purpose functions based on heaps."
msgstr "Modulen erbjuder också tre allmänna funktioner baserade på heaps."

msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, merge "
"timestamped entries from multiple log files).  Returns an :term:`iterator` "
"over the sorted values."
msgstr ""
"Sammanfogar flera sorterade indata till en enda sorterad utdata (t.ex. "
"sammanfogar tidsstämplade poster från flera loggfiler).  Returnerar en :term:"
"`iterator` över de sorterade värdena."

msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an iterable, "
"does not pull the data into memory all at once, and assumes that each of the "
"input streams is already sorted (smallest to largest)."
msgstr ""
"Liknar ``sorted(itertools.chain(*iterables))`` men returnerar en iterabel, "
"drar inte in data i minnet på en gång och förutsätter att var och en av "
"inmatningsströmmarna redan är sorterade (minsta till största)."

msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr "Har två valfria argument som måste anges som nyckelordsargument."

msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each input element.  The default value is "
"``None`` (compare the elements directly)."
msgstr ""
"*key* anger en :term:`key-funktion` med ett argument som används för att "
"extrahera en jämförelsenyckel från varje inmatat element.  Standardvärdet är "
"``None`` (jämför elementen direkt)."

msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the input elements "
"are merged as if each comparison were reversed. To achieve behavior similar "
"to ``sorted(itertools.chain(*iterables), reverse=True)``, all iterables must "
"be sorted from largest to smallest."
msgstr ""
"*reverse* är ett booleanskt värde.  Om värdet är satt till ``True`` slås "
"inmatningselementen samman som om varje jämförelse var omvänd. För att uppnå "
"ett beteende som liknar ``sorted(itertools.chain(*iterables), "
"reverse=True)`` måste alla iterables sorteras från största till minsta."

msgid "Added the optional *key* and *reverse* parameters."
msgstr "Lagt till de valfria parametrarna *key* och *reverse*."

msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key, "
"reverse=True)[:n]``."
msgstr ""
"Returnerar en lista med de *n* största elementen från datasetet som "
"definieras av *iterable*.  *key*, om den anges, specificerar en funktion med "
"ett argument som används för att extrahera en jämförelsenyckel från varje "
"element i *iterable* (t.ex. ``key=str.lower``).  Likvärdig med:  "
"``sorted(iterable, key=key, reverse=True)[:n]``."

msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key)[:"
"n]``."
msgstr ""
"Returnerar en lista med de *n* minsta elementen från datasetet som "
"definieras av *iterable*.  *key*, om det anges, specificerar en funktion med "
"ett argument som används för att extrahera en jämförelsenyckel från varje "
"element i *iterable* (till exempel ``key=str.lower``).  Likvärdig med:  "
"```sorted(iterable, key=key)[:n]``."

msgid ""
"The latter two functions perform best for smaller values of *n*.  For larger "
"values, it is more efficient to use the :func:`sorted` function.  Also, when "
"``n==1``, it is more efficient to use the built-in :func:`min` and :func:"
"`max` functions.  If repeated usage of these functions is required, consider "
"turning the iterable into an actual heap."
msgstr ""
"De två sistnämnda funktionerna fungerar bäst för mindre värden på *n*.  För "
"större värden är det mer effektivt att använda funktionen :func:`sorted`.  "
"När ``n==1`` är det också mer effektivt att använda de inbyggda "
"funktionerna :func:`min` och :func:`max`.  Om det krävs upprepad användning "
"av dessa funktioner bör du överväga att göra om iterabeln till en faktisk "
"hög."

msgid "Basic Examples"
msgstr "Grundläggande exempel"

msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented by "
"pushing all values onto a heap and then popping off the smallest values one "
"at a time::"
msgstr ""
"En `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ kan implementeras "
"genom att lägga alla värden på en hög och sedan plocka bort de minsta "
"värdena ett i taget::"

msgid ""
">>> def heapsort(iterable):\n"
"...     h = []\n"
"...     for value in iterable:\n"
"...         heappush(h, value)\n"
"...     return [heappop(h) for i in range(len(h))]\n"
"...\n"
">>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""
">>> def heapsort(iterable):\n"
"...     h = []\n"
"...     for value in iterable:\n"
"...         heappush(h, value)\n"
"...     return [heappop(h) for i in range(len(h))]\n"
"...\n"
">>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"

msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr ""
"Detta liknar ``sorted(iterable)``, men till skillnad från :func:`sorted` är "
"denna implementation inte stabil."

msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison values "
"(such as task priorities) alongside the main record being tracked::"
msgstr ""
"Heap-element kan vara tupler.  Detta är användbart för att tilldela "
"jämförelsevärden (t.ex. uppgiftsprioriteringar) vid sidan av den "
"huvudsakliga post som spåras::"

msgid ""
">>> h = []\n"
">>> heappush(h, (5, 'write code'))\n"
">>> heappush(h, (7, 'release product'))\n"
">>> heappush(h, (1, 'write spec'))\n"
">>> heappush(h, (3, 'create tests'))\n"
">>> heappop(h)\n"
"(1, 'write spec')"
msgstr ""
">>> h = []\n"
">>> heappush(h, (5, 'write code'))\n"
">>> heappush(h, (7, 'release product'))\n"
">>> heappush(h, (1, 'write spec'))\n"
">>> heappush(h, (3, 'create tests'))\n"
">>> heappop(h)\n"
"(1, 'write spec')"

msgid "Priority Queue Implementation Notes"
msgstr "Anvisningar för implementering av prioriterad kö"

msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is common "
"use for a heap, and it presents several implementation challenges:"
msgstr ""
"En \"prioritetskö\" <https://en.wikipedia.org/wiki/Priority_queue>`_ är en "
"vanlig användning för en hög, och den innebär flera "
"implementeringsutmaningar:"

msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr ""
"Sorteringsstabilitet: Hur får man två uppgifter med samma prioritet att "
"returneras i den ordning de ursprungligen lades till?"

msgid ""
"Tuple comparison breaks for (priority, task) pairs if the priorities are "
"equal and the tasks do not have a default comparison order."
msgstr ""
"Tupeljämförelsen bryts för (prioritet, uppgift)-par om prioriteringarna är "
"lika och uppgifterna inte har en standardjämförelseordning."

msgid ""
"If the priority of a task changes, how do you move it to a new position in "
"the heap?"
msgstr ""
"Om prioriteten för en uppgift ändras, hur flyttar du den till en ny position "
"i högen?"

msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove it "
"from the queue?"
msgstr ""
"Eller om en väntande uppgift behöver raderas, hur hittar du den och tar bort "
"den från kön?"

msgid ""
"A solution to the first two challenges is to store entries as 3-element list "
"including the priority, an entry count, and the task.  The entry count "
"serves as a tie-breaker so that two tasks with the same priority are "
"returned in the order they were added. And since no two entry counts are the "
"same, the tuple comparison will never attempt to directly compare two tasks."
msgstr ""
"En lösning på de två första utmaningarna är att lagra poster som en lista "
"med tre element, inklusive prioriteten, ett antal poster och uppgiften.  "
"Entry count fungerar som en tie-breaker så att två uppgifter med samma "
"prioritet returneras i den ordning de lades till. Och eftersom ingen "
"posträkning är den andra lik kommer tuple-jämförelsen aldrig att försöka "
"jämföra två uppgifter direkt."

msgid ""
"Another solution to the problem of non-comparable tasks is to create a "
"wrapper class that ignores the task item and only compares the priority "
"field::"
msgstr ""
"En annan lösning på problemet med icke jämförbara uppgifter är att skapa en "
"omslutande klass som ignorerar uppgiftsobjektet och endast jämför "
"prioritetsfältet::"

msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"

msgid ""
"The remaining challenges revolve around finding a pending task and making "
"changes to its priority or removing it entirely.  Finding a task can be done "
"with a dictionary pointing to an entry in the queue."
msgstr ""
"De återstående utmaningarna handlar om att hitta en väntande uppgift och "
"ändra dess prioritet eller ta bort den helt och hållet.  Att hitta en "
"uppgift kan göras med en ordbok som pekar på en post i kön."

msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to "
"mark the entry as removed and add a new entry with the revised priority::"
msgstr ""
"Att ta bort posten eller ändra dess prioritet är svårare eftersom det skulle "
"bryta mot invarianterna för heapstrukturen.  En möjlig lösning är därför att "
"markera posten som borttagen och lägga till en ny post med den reviderade "
"prioriteten::"

msgid ""
"pq = []                         # list of entries arranged in a heap\n"
"entry_finder = {}               # mapping of tasks to entries\n"
"REMOVED = '<removed-task>'      # placeholder for a removed task\n"
"counter = itertools.count()     # unique sequence count\n"
"\n"
"def add_task(task, priority=0):\n"
"    'Add a new task or update the priority of an existing task'\n"
"    if task in entry_finder:\n"
"        remove_task(task)\n"
"    count = next(counter)\n"
"    entry = [priority, count, task]\n"
"    entry_finder[task] = entry\n"
"    heappush(pq, entry)\n"
"\n"
"def remove_task(task):\n"
"    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n"
"    entry = entry_finder.pop(task)\n"
"    entry[-1] = REMOVED\n"
"\n"
"def pop_task():\n"
"    'Remove and return the lowest priority task. Raise KeyError if empty.'\n"
"    while pq:\n"
"        priority, count, task = heappop(pq)\n"
"        if task is not REMOVED:\n"
"            del entry_finder[task]\n"
"            return task\n"
"    raise KeyError('pop from an empty priority queue')"
msgstr ""
"pq = []                         # list of entries arranged in a heap\n"
"entry_finder = {}               # mapping of tasks to entries\n"
"REMOVED = '<removed-task>'      # placeholder for a removed task\n"
"counter = itertools.count()     # unique sequence count\n"
"\n"
"def add_task(task, priority=0):\n"
"    'Add a new task or update the priority of an existing task'\n"
"    if task in entry_finder:\n"
"        remove_task(task)\n"
"    count = next(counter)\n"
"    entry = [priority, count, task]\n"
"    entry_finder[task] = entry\n"
"    heappush(pq, entry)\n"
"\n"
"def remove_task(task):\n"
"    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n"
"    entry = entry_finder.pop(task)\n"
"    entry[-1] = REMOVED\n"
"\n"
"def pop_task():\n"
"    'Remove and return the lowest priority task. Raise KeyError if empty.'\n"
"    while pq:\n"
"        priority, count, task = heappop(pq)\n"
"        if task is not REMOVED:\n"
"            del entry_finder[task]\n"
"            return task\n"
"    raise KeyError('pop from an empty priority queue')"

msgid "Theory"
msgstr "Teori"

msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` for "
"all *k*, counting elements from 0.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that ``a[0]`` is always its smallest element."
msgstr ""
"Heaps är matriser för vilka ``a[k] <= a[2*k+1]`` och ``a[k] <= a[2*k+2]`` "
"för alla *k*, räknat med element från 0. För jämförelsens skull anses icke-"
"existerande element vara oändliga.  Den intressanta egenskapen hos en hög är "
"att ``a[0]`` alltid är dess minsta element."

msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not ``a[k]``::"
msgstr ""
"Den märkliga invarianten ovan är tänkt att vara en effektiv "
"minnesrepresentation för en turnering.  Siffrorna nedan är *k*, inte "
"``a[k]``::"

msgid ""
"                               0\n"
"\n"
"              1                                 2\n"
"\n"
"      3               4                5               6\n"
"\n"
"  7       8       9       10      11      12      13      14\n"
"\n"
"15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30"
msgstr ""
"                               0\n"
"\n"
"              1                                 2\n"
"\n"
"      3               4                5               6\n"
"\n"
"  7       8       9       10      11      12      13      14\n"
"\n"
"15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30"

msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a "
"usual binary tournament we see in sports, each cell is the winner over the "
"two cells it tops, and we can trace the winner down the tree to see all "
"opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the "
"two cells it tops contain three different items, but the top cell \"wins\" "
"over the two topped cells."
msgstr ""
"I trädet ovan toppar varje cell *k* ``2*k+1`` och ``2*k+2``. I en vanlig "
"binär turnering som vi ser i sport är varje cell vinnare över de två celler "
"den toppar, och vi kan spåra vinnaren nedåt i trädet för att se alla "
"motståndare han/hon hade.  I många datortillämpningar av sådana turneringar "
"behöver vi dock inte spåra en vinnares historia. För att vara mer "
"minneseffektiva försöker vi ersätta en vinnare med något annat på en lägre "
"nivå, och regeln blir att en cell och de två celler som den toppar "
"innehåller tre olika saker, men att den översta cellen \"vinner\" över de "
"två toppade cellerna."

msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly "
"logarithmic on the total number of items in the tree. By iterating over all "
"items, you get an *O*\\ (*n* log *n*) sort."
msgstr ""
"Om denna invariant i högen är skyddad hela tiden är index 0 helt klart den "
"övergripande vinnaren.  Det enklaste algoritmiska sättet att ta bort det och "
"hitta \"nästa\" vinnare är att flytta någon förlorare (låt oss säga cell 30 "
"i diagrammet ovan) till 0-positionen och sedan perkolera denna nya 0 nedåt i "
"trädet och utbyta värden tills invariansen återställs. Detta är tydligt "
"logaritmiskt på det totala antalet objekt i trädet. Genom att iterera över "
"alla objekt får du en *O*\\ (*n* log *n*) sortering."

msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not "
"\"better\" than the last 0'th element you extracted.  This is especially "
"useful in simulation contexts, where the tree holds all incoming events, and "
"the \"win\" condition means the smallest scheduled time.  When an event "
"schedules other events for execution, they are scheduled into the future, so "
"they can easily go into the heap.  So, a heap is a good structure for "
"implementing schedulers (this is what I used for my MIDI sequencer :-)."
msgstr ""
"En trevlig egenskap hos denna sortering är att du effektivt kan infoga nya "
"element medan sorteringen pågår, förutsatt att de infogade elementen inte är "
"\"bättre\" än det sista 0:e elementet du extraherade.  Detta är särskilt "
"användbart i simuleringssammanhang, där trädet innehåller alla inkommande "
"händelser och \"win\"-villkoret innebär den minsta schemalagda tiden.  När "
"en händelse schemalägger andra händelser för utförande schemaläggs de in i "
"framtiden, så att de lätt kan hamna i högen.  Så en hög är en bra struktur "
"för att implementera schemaläggare (det är vad jag använde för min MIDI-"
"sequencer :-)."

msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than the "
"average case. However, there are other representations which are more "
"efficient overall, yet the worst cases might be terrible."
msgstr ""
"Olika strukturer för att implementera schemaläggare har studerats ingående, "
"och heaps är bra för detta, eftersom de är rimligt snabba, hastigheten är "
"nästan konstant och det värsta fallet inte skiljer sig mycket från det "
"genomsnittliga fallet. Det finns dock andra representationer som är mer "
"effektiva överlag, men de värsta fallen kan vara fruktansvärda."

msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know "
"that a big sort implies producing \"runs\" (which are pre-sorted sequences, "
"whose size is usually related to the amount of CPU memory), followed by a "
"merging passes for these runs, which merging is often very cleverly "
"organised [#]_. It is very important that the initial sort produces the "
"longest runs possible.  Tournaments are a good way to achieve that.  If, "
"using all the memory available to hold a tournament, you replace and "
"percolate items that happen to fit the current run, you'll produce runs "
"which are twice the size of the memory for random input, and much better for "
"input fuzzily ordered."
msgstr ""
"Heaps är också mycket användbara i stora disksorteringar.  Du vet säkert "
"alla att en stor sortering innebär att man producerar \"körningar\" (som är "
"försorterade sekvenser, vars storlek vanligtvis är relaterad till mängden "
"CPU-minne), följt av ett sammanslagningspass för dessa körningar, vilken "
"sammanslagning ofta är mycket smart organiserad [#]_. Det är mycket viktigt "
"att den inledande sorteringen ger så långa körningar som möjligt.  "
"Turneringar är ett bra sätt att uppnå detta.  Om du använder allt minne som "
"finns tillgängligt för att hålla en turnering, ersätter och perkolerar "
"objekt som råkar passa den aktuella körningen, kommer du att producera "
"körningar som är dubbelt så stora som minnet för slumpmässig inmatning, och "
"mycket bättre för inmatning som är luddigt ordnad."

msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may not "
"fit in the current tournament (because the value \"wins\" over the last "
"output value), it cannot fit in the heap, so the size of the heap "
"decreases.  The freed memory could be cleverly reused immediately for "
"progressively building a second heap, which grows at exactly the same rate "
"the first heap is melting.  When the first heap completely vanishes, you "
"switch heaps and start a new run.  Clever and quite effective!"
msgstr ""
"Dessutom, om du matar ut det 0:e objektet på disken och får en inmatning som "
"inte får plats i den aktuella turneringen (eftersom värdet \"vinner\" över "
"det senaste utmatningsvärdet), kan det inte få plats i högen, så storleken "
"på högen minskar.  Det frigjorda minnet kan på ett smart sätt omedelbart "
"återanvändas för att successivt bygga upp en andra hög, som växer i exakt "
"samma takt som den första högen smälter.  När den första högen helt "
"försvinner byter man hög och startar en ny körning.  Smart och ganska "
"effektivt!"

msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a few "
"applications, and I think it is good to keep a 'heap' module around. :-)"
msgstr ""
"Kort sagt, heaps är användbara minnesstrukturer att känna till.  Jag "
"använder dem i några program, och jag tror att det är bra att ha en \"heap\"-"
"modul :-)"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"The disk balancing algorithms which are current, nowadays, are more annoying "
"than clever, and this is a consequence of the seeking capabilities of the "
"disks. On devices which cannot seek, like big tape drives, the story was "
"quite different, and one had to be very clever to ensure (far in advance) "
"that each tape movement will be the most effective possible (that is, will "
"best participate at \"progressing\" the merge).  Some tapes were even able "
"to read backwards, and this was also used to avoid the rewinding time. "
"Believe me, real good tape sorts were quite spectacular to watch! From all "
"times, sorting has always been a Great Art! :-)"
msgstr ""
"De algoritmer för diskbalansering som används nuförtiden är mer irriterande "
"än smarta, och detta är en följd av diskarnas sökfunktioner. På enheter som "
"inte kan söka, som stora bandstationer, var historien en helt annan, och man "
"var tvungen att vara mycket smart för att säkerställa (långt i förväg) att "
"varje bandrörelse skulle vara så effektiv som möjligt (det vill säga bäst "
"bidra till att \"föra fram\" sammanfogningen).  Vissa band kunde till och "
"med läsas baklänges, och detta användes också för att undvika "
"omspolningstiden. Tro mig, riktigt bra bandsorteringar var ganska "
"spektakulära att se! Från alla tider har sortering alltid varit en stor "
"konst! :-)"
