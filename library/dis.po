# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-09 14:17+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!dis` --- Disassembler for Python bytecode"
msgstr ":mod:`!dis` --- Disassemblerare för Python bytecode"

msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**Källkod:** :source:`Lib/dis.py`"

msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""
"Modulen :mod:`dis` stöder analys av CPython :term:`bytecode` genom att "
"demontera den. CPython-bytekoden som den här modulen tar som indata "
"definieras i filen :file:`Include/opcode.h` och används av kompilatorn och "
"tolken."

msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""
"Bytecode är en implementationsdetalj av CPython-tolken.  Det finns inga "
"garantier för att bytecode inte kommer att läggas till, tas bort eller "
"ändras mellan olika versioner av Python.  Användning av denna modul bör inte "
"anses fungera över Python VM eller Python-versioner."

msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""
"Använd 2 byte för varje instruktion. Tidigare varierade antalet byte "
"beroende på instruktion."

msgid ""
"The argument of jump, exception handling and loop instructions is now the "
"instruction offset rather than the byte offset."
msgstr ""
"Argumentet för hopp-, undantagshanterings- och loopinstruktioner är nu "
"instruktionsoffset i stället för byteoffset."

msgid ""
"Some instructions are accompanied by one or more inline cache entries, which "
"take the form of :opcode:`CACHE` instructions. These instructions are hidden "
"by default, but can be shown by passing ``show_caches=True`` to any :mod:"
"`dis` utility. Furthermore, the interpreter now adapts the bytecode to "
"specialize it for different runtime conditions. The adaptive bytecode can be "
"shown by passing ``adaptive=True``."
msgstr ""
"Vissa instruktioner åtföljs av en eller flera inline-cacheposter, som har "
"formen av :opcode:`CACHE`-instruktioner. Dessa instruktioner är dolda som "
"standard, men kan visas genom att skicka ``show_caches=True`` till valfritt :"
"mod:`dis`-verktyg. Dessutom anpassar tolken nu bytekoden för att "
"specialisera den för olika körtidsförhållanden. Den adaptiva bytekoden kan "
"visas genom att ange ``adaptive=True``."

msgid ""
"The argument of a jump is the offset of the target instruction relative to "
"the instruction that appears immediately after the jump instruction's :"
"opcode:`CACHE` entries."
msgstr ""
"Argumentet för ett hopp är målinstruktionens offset i förhållande till den "
"instruktion som visas omedelbart efter hoppinstruktionens :opcode:`CACHE`-"
"poster."

msgid ""
"As a consequence, the presence of the :opcode:`CACHE` instructions is "
"transparent for forward jumps but needs to be taken into account when "
"reasoning about backward jumps."
msgstr ""
"Följaktligen är förekomsten av instruktionerna :opcode:`CACHE` transparent "
"för hopp framåt, men måste tas med i beräkningen när man resonerar om hopp "
"bakåt."

msgid ""
"The output shows logical labels rather than instruction offsets for jump "
"targets and exception handlers. The ``-O`` command line option and the "
"``show_offsets`` argument were added."
msgstr ""
"Utdata visar logiska etiketter i stället för instruktionsoffset för hoppmål "
"och undantagshanterare. Kommandoradsalternativet ``-O`` och argumentet "
"``show_offsets`` har lagts till."

msgid ""
"The :option:`-P <dis --show-positions>` command-line option and the "
"``show_positions`` argument were added."
msgstr ""
"Kommandoradsalternativet :option:`-P <dis --show-positions>` och argumentet "
"``show_positions`` har lagts till."

msgid "The :option:`-S <dis --specialized>` command-line option is added."
msgstr ""
"Kommandoradsalternativet :option:`-S <dis --specialized>` har lagts till."

msgid "Example: Given the function :func:`!myfunc`::"
msgstr "Exempel: Givet funktionen :func:`!myfunc`::"

msgid ""
"def myfunc(alist):\n"
"    return len(alist)"
msgstr ""
"def myfunc(alist):\n"
"    returnera len(alist)"

msgid ""
"the following command can be used to display the disassembly of :func:`!"
"myfunc`:"
msgstr ""
"följande kommando kan användas för att visa demonteringen av :func:`!myfunc`:"

msgid ""
">>> dis.dis(myfunc)\n"
"  2           RESUME                   0\n"
"\n"
"  3           LOAD_GLOBAL              1 (len + NULL)\n"
"              LOAD_FAST_BORROW         0 (alist)\n"
"              CALL                     1\n"
"              RETURN_VALUE"
msgstr ""
">>> dis.dis(myfunc)\n"
"  2 ÅTERGÅ 0\n"
"\n"
"  3 LOAD_GLOBAL 1 (len + NULL)\n"
"              LOAD_FAST_BORROW 0 (alist)\n"
"              CALL 1\n"
"              RETURN_VALUE"

msgid "(The \"2\" is a line number)."
msgstr "(2\" är ett linjenummer)."

msgid "Command-line interface"
msgstr "Kommandoradsgränssnitt"

msgid "The :mod:`dis` module can be invoked as a script from the command line:"
msgstr "Modulen :mod:`dis` kan anropas som ett skript från kommandoraden:"

msgid "python -m dis [-h] [-C] [-O] [-P] [-S] [infile]"
msgstr "python -m dis [-h] [-C] [-O] [-P] [-S] [infile]"

msgid "The following options are accepted:"
msgstr "Följande alternativ accepteras:"

msgid "Display usage and exit."
msgstr "Visa användning och avsluta."

msgid "Show inline caches."
msgstr "Visa inline-cacher."

msgid "Show offsets of instructions."
msgstr "Visa offsets för instruktioner."

msgid "Show positions of instructions in the source code."
msgstr "Visa var instruktionerna finns i källkoden."

msgid "Show specialized bytecode."
msgstr "Visa specialiserad bytekod."

msgid ""
"If :file:`infile` is specified, its disassembled code will be written to "
"stdout. Otherwise, disassembly is performed on compiled source code received "
"from stdin."
msgstr ""
"Om :file:`infile` anges kommer dess demonterade kod att skrivas till stdout. "
"I annat fall utförs demonteringen på kompilerad källkod som tas emot från "
"stdin."

msgid "Bytecode analysis"
msgstr "Bytecode-analys"

msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a :"
"class:`Bytecode` object that provides easy access to details of the compiled "
"code."
msgstr ""
"API:et för bytecodeanalys gör att delar av Python-koden kan förpackas i ett :"
"class:`Bytecode`-objekt som ger enkel åtkomst till detaljer i den "
"kompilerade koden."

msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""
"Analysera bytekoden som motsvarar en funktion, generator, asynkron "
"generator, coroutine, metod, sträng med källkod eller ett kodobjekt (som "
"returneras av :func:`compile`)."

msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""
"Detta är en bekväm omslutning av många av de funktioner som anges nedan, "
"särskilt :func:`get_instructions`, eftersom iterering över en :class:"
"`Bytecode`-instans ger bytecode-operationerna som :class:`Instruction`-"
"instanser."

msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""
"Om *first_line* inte är ``None``, anges det radnummer som ska rapporteras "
"för den första källkodsraden i den demonterade koden.  I annat fall hämtas "
"informationen om källraden (om sådan finns) direkt från det demonterade "
"kodobjektet."

msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"Om *current_offset* inte är ``None``, refererar det till en "
"instruktionsoffset i den demonterade koden. Om du ställer in detta betyder "
"det att :meth:`.dis` kommer att visa en \"aktuell instruktion\"-markör mot "
"den angivna opkoden."

msgid ""
"If *show_caches* is ``True``, :meth:`.dis` will display inline cache entries "
"used by the interpreter to specialize the bytecode."
msgstr ""
"Om *show_caches* är ``True`` kommer :meth:`.dis` att visa inline-cacheposter "
"som används av tolken för att specialisera bytekoden."

msgid ""
"If *adaptive* is ``True``, :meth:`.dis` will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Om *adaptive* är ``True`` kommer :meth:`.dis` att visa specialiserad bytekod "
"som kan skilja sig från den ursprungliga bytekoden."

msgid ""
"If *show_offsets* is ``True``, :meth:`.dis` will include instruction offsets "
"in the output."
msgstr ""
"Om *show_offsets* är ``True`` kommer :meth:`.dis` att inkludera "
"instruktionsoffsets i utdata."

msgid ""
"If *show_positions* is ``True``, :meth:`.dis` will include instruction "
"source code positions in the output."
msgstr ""
"Om *show_positions* är ``True`` kommer :meth:`.dis` att inkludera positioner "
"för instruktionskällkod i utdata."

msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"Konstruera en :class:`Bytecode`-instans från den angivna tracebacken, och "
"sätt *current_offset* till den instruktion som är ansvarig för undantaget."

msgid "The compiled code object."
msgstr "Det kompilerade kodobjektet."

msgid "The first source line of the code object (if available)"
msgstr "Den första källraden i kodobjektet (om den finns tillgänglig)"

msgid ""
"Return a formatted view of the bytecode operations (the same as printed by :"
"func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"Returnerar en formaterad vy av bytecode-operationerna (samma som skrivs ut "
"av :func:`dis.dis`, men returneras som en sträng med flera rader)."

msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""
"Returnerar en formaterad sträng med flera rader med detaljerad information "
"om kodobjektet, som :func:`code_info`."

msgid "This can now handle coroutine and asynchronous generator objects."
msgstr "Detta kan nu hantera coroutine- och asynkrona generatorobjekt."

msgid "Added the *show_caches* and *adaptive* parameters."
msgstr "Parametrarna *show_caches* och *adaptive* har lagts till."

msgid "Added the *show_offsets* parameter"
msgstr "Parametern *show_offsets* har lagts till"

msgid "Added the *show_positions* parameter."
msgstr "Parametern *show_positions* har lagts till."

msgid "Example:"
msgstr "Exempel:"

msgid ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> for instr in bytecode:\n"
"...     print(instr.opname)\n"
"...\n"
"RESUME\n"
"LOAD_GLOBAL\n"
"LOAD_FAST_BORROW\n"
"CALL\n"
"RETURN_VALUE"
msgstr ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> för instr i bytecode:\n"
"... print(instr.opname)\n"
"...\n"
"ÅTERUPPTA\n"
"LADDA_GLOBAL\n"
"LADDA_SNABBT_LÅNA\n"
"RINGA\n"
"RETURN_VALUE"

msgid "Analysis functions"
msgstr "Analysfunktioner"

msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""
"Modulen :mod:`dis` definierar även följande analysfunktioner som omvandlar "
"indata direkt till önskad utdata. De kan vara användbara om endast en enda "
"operation utförs, så att det mellanliggande analysobjektet inte är "
"användbart:"

msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""
"Returnerar en formaterad flerradig sträng med detaljerad "
"kodobjektinformation för den angivna funktionen, generatorn, "
"asynkrongeneratorn, coroutinen, metoden, källkodsträngen eller kodobjektet."

msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""
"Observera att det exakta innehållet i kodinfosträngarna är mycket beroende "
"av implementationen och att det kan ändras godtyckligt mellan olika Python-"
"VM:er eller Python-utgåvor."

msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""
"Skriv ut detaljerad kodobjektinformation för den angivna funktionen, "
"metoden, källkodsträngen eller kodobjektet till *file* (eller ``sys.stdout`` "
"om *file* inte anges)."

msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"Detta är en praktisk kortform för ``print(code_info(x), file=file)``, avsedd "
"för interaktiv utforskning vid tolkens prompt."

msgid "Added *file* parameter."
msgstr "Parametern *file* har lagts till."

msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects. These can include generator "
"expressions, nested functions, the bodies of nested classes, and the code "
"objects used for :ref:`annotation scopes <annotation-scopes>`. Strings are "
"first compiled to code objects with the :func:`compile` built-in function "
"before being disassembled.  If no object is provided, this function "
"disassembles the last traceback."
msgstr ""
"Demontera *x*-objektet.  *x* kan beteckna antingen en modul, en klass, en "
"metod, en funktion, en generator, en asynkron generator, en coroutine, ett "
"kodobjekt, en sträng med källkod eller en byte-sekvens med rå bytecode. För "
"en modul demonteras alla funktioner. För en klass demonteras alla metoder "
"(inklusive klass- och statiska metoder). För ett kodobjekt eller en sekvens "
"av rå bytecode skrivs en rad per bytecode-instruktion ut. Den demonterar "
"även nästlade kodobjekt rekursivt. Dessa kan inkludera generatoruttryck, "
"nästlade funktioner, kropparna i nästlade klasser och de kodobjekt som "
"används för :ref:`annotation scopes <annotation-scopes>`. Strängar "
"kompileras först till kodobjekt med den inbyggda funktionen :func:`compile` "
"innan de plockas isär.  Om inget objekt anges, demonterar denna funktion det "
"senaste traceback."

msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""
"Demonteringen skrivs som text till det medföljande *file*-argumentet om det "
"tillhandahålls och till ``sys.stdout`` annars."

msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""
"Det maximala djupet för rekursion begränsas av *depth* om det inte är "
"``None``. ``depth=0`` innebär ingen rekursion."

msgid ""
"If *show_caches* is ``True``, this function will display inline cache "
"entries used by the interpreter to specialize the bytecode."
msgstr ""
"Om *show_caches* är ``True``, kommer denna funktion att visa inline cache-"
"poster som används av tolken för att specialisera bytekoden."

msgid ""
"If *adaptive* is ``True``, this function will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""
"Om *adaptive* är ``True``, kommer denna funktion att visa specialiserad "
"bytecode som kan skilja sig från den ursprungliga bytecoden."

msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr "Implementerade rekursiv demontering och lade till parametern *depth*."

msgid "Added the *show_offsets* parameter."
msgstr "Parametern *show_offsets* har lagts till."

msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""
"Demontera funktionen högst upp i stapeln för en spårning, med hjälp av den "
"sista spårningen om ingen har skickats.  Den instruktion som orsakade "
"undantaget anges."

msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""
"Demontera ett kodobjekt och ange den sista instruktionen om *lasti* har "
"angetts.  Utmatningen är uppdelad i följande kolumner:"

msgid ""
"the source code location of the instruction. Complete location information "
"is shown if *show_positions* is true. Otherwise (the default) only the line "
"number is displayed."
msgstr ""
"instruktionens plats i källkoden. Fullständig platsinformation visas om "
"*show_positions* är true. Annars (standard) visas endast radnumret."

msgid "the current instruction, indicated as ``-->``,"
msgstr "den aktuella instruktionen, angiven som ``-->``,"

msgid "a labelled instruction, indicated with ``>>``,"
msgstr "en märkt instruktion, markerad med ``>>``,"

msgid "the address of the instruction,"
msgstr "adressen till instruktionen,"

msgid "the operation code name,"
msgstr "operationens kodnamn,"

msgid "operation parameters, and"
msgstr "driftsparametrar, och"

msgid "interpretation of the parameters in parentheses."
msgstr "tolkning av parametrarna inom parentes."

msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""
"Parametertolkningen känner igen lokala och globala variabelnamn, "
"konstantvärden, förgreningsmål och jämförelseoperatorer."

msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""
"Returnerar en iterator över instruktionerna i den angivna funktionen, "
"metoden, källkodsträngen eller kodobjektet."

msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""
"Iteratorn genererar en serie :class:`Instruction`-namngivna tuples som ger "
"detaljerna för varje operation i den medföljande koden."

msgid "The *adaptive* parameter works as it does in :func:`dis`."
msgstr "Parametern *adaptive* fungerar som den gör i :func:`dis`."

msgid ""
"The *show_caches* parameter is deprecated and has no effect. The iterator "
"generates the :class:`Instruction` instances with the *cache_info* field "
"populated (regardless of the value of *show_caches*) and it no longer "
"generates separate items for the cache entries."
msgstr ""
"Parametern *show_caches* är föråldrad och har ingen effekt. Iteratorn "
"genererar :class:`Instruction`-instanser med fältet *cache_info* ifyllt "
"(oavsett värdet på *show_caches*) och den genererar inte längre separata "
"objekt för cache-posterna."

msgid ""
"This generator function uses the :meth:`~codeobject.co_lines` method of the :"
"ref:`code object <code-objects>` *code* to find the offsets which are starts "
"of lines in the source code.  They are generated as ``(offset, lineno)`` "
"pairs."
msgstr ""
"Denna generatorfunktion använder metoden :meth:`~codeobject.co_lines` i :ref:"
"`code object <code-objects>` *code* för att hitta de offsets som är början "
"på rader i källkoden.  De genereras som par av typen ``(offset, lineno)``."

msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr "Linjenummer kan vara minskande. Tidigare var de alltid ökande."

msgid ""
"The :pep:`626` :meth:`~codeobject.co_lines` method is used instead of the :"
"attr:`~codeobject.co_firstlineno` and :attr:`~codeobject.co_lnotab` "
"attributes of the :ref:`code object <code-objects>`."
msgstr ""
"Metoden :pep:`626` :meth:`~codeobject.co_lines` används istället för "
"attributen :attr:`~codeobject.co_firstlineno` och :attr:`~codeobject."
"co_lnotab` i :ref:`codeobjekt <code-objects>`."

msgid ""
"Line numbers can be ``None`` for bytecode that does not map to source lines."
msgstr ""
"Radnummer kan vara ``None`` för bytecode som inte mappas till källkodsrader."

msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""
"Detektera alla offsets i den råa kompilerade bytecode-strängen *code* som är "
"hoppmål och returnera en lista över dessa offsets."

msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "Beräkna stapeleffekten av *opcode* med argumentet *oparg*."

msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""
"Om koden har ett hoppmål och *jump* är ``True``, kommer :func:"
"`~stack_effect` att returnera stapeleffekten av att hoppa.  Om *jump* är "
"``False``, kommer den att returnera stapeleffekten av att inte hoppa. Och om "
"*jump* är ``None`` (standard), kommer den att returnera den maximala "
"stapeleffekten av båda fallen."

msgid "Added *jump* parameter."
msgstr "Lagt till parametern *jump*."

msgid ""
"If ``oparg`` is omitted (or ``None``), the stack effect is now returned for "
"``oparg=0``. Previously this was an error for opcodes that use their arg. It "
"is also no longer an error to pass an integer ``oparg`` when the ``opcode`` "
"does not use it; the ``oparg`` in this case is ignored."
msgstr ""
"Om ``oparg`` utelämnas (eller ``None``), returneras nu stackeffekten för "
"``oparg=0``. Tidigare var detta ett fel för opkoder som använder sitt arg. "
"Det är inte heller längre ett fel att skicka ett heltal ``oparg`` när "
"``opcode`` inte använder det; ``oparg`` ignoreras i detta fall."

msgid "Python Bytecode Instructions"
msgstr "Python Bytecode Instruktioner"

msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
"Funktionen :func:`get_instructions` och klassen :class:`Bytecode` ger "
"detaljer om bytecode-instruktioner som :class:`Instruction`-instanser:"

msgid "Details for a bytecode operation"
msgstr "Detaljer för en bytecode-operation"

msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""
"numerisk kod för operationen, som motsvarar de opcode-värden som anges nedan "
"och bytecode-värdena i :ref:`opcode_collections`."

msgid "human readable name for operation"
msgstr "mänskligt läsbart namn för operationen"

msgid ""
"numeric code for the base operation if operation is specialized; otherwise "
"equal to :data:`opcode`"
msgstr ""
"numerisk kod för basoperationen om operationen är specialiserad; annars lika "
"med :data:`opcode`"

msgid ""
"human readable name for the base operation if operation is specialized; "
"otherwise equal to :data:`opname`"
msgstr ""
"mänskligt läsbart namn för basoperationen om operationen är specialiserad; "
"annars lika med :data:`opname`"

msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr "numeriskt argument till operationen (om sådant finns), annars ``None``"

msgid "alias for :data:`arg`"
msgstr "alias för :data:`arg`"

msgid "resolved arg value (if any), otherwise ``None``"
msgstr "löst arg-värde (om sådant finns), annars ``None``"

msgid ""
"human readable description of operation argument (if any), otherwise an "
"empty string."
msgstr ""
"mänsklig läsbar beskrivning av operationsargumentet (om sådant finns), "
"annars en tom sträng."

msgid "start index of operation within bytecode sequence"
msgstr "startindex för operation inom bytecode-sekvens"

msgid ""
"start index of operation within bytecode sequence, including prefixed "
"``EXTENDED_ARG`` operations if present; otherwise equal to :data:`offset`"
msgstr ""
"startindex för operation inom bytecode-sekvens, inklusive prefixet "
"``EXTENDED_ARG`` om sådant finns; annars lika med :data:`offset`"

msgid "start index of the cache entries following the operation"
msgstr "startindex för de cacheposter som följer efter operationen"

msgid "end index of the cache entries following the operation"
msgstr "slutindex för de cacheposter som följer på operationen"

msgid "``True`` if this opcode starts a source line, otherwise ``False``"
msgstr "``True`` om denna opcode startar en källkodsrad, annars ``False``"

msgid ""
"source line number associated with this opcode (if any), otherwise ``None``"
msgstr ""
"källans radnummer associerat med denna opcode (om det finns någon), annars "
"``None``"

msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "``True`` om annan kod hoppar till här, annars ``False``"

msgid ""
"bytecode index of the jump target if this is a jump operation, otherwise "
"``None``"
msgstr ""
"bytecode-index för hoppmålet om detta är en hoppoperation, annars ``None``"

msgid ""
":class:`dis.Positions` object holding the start and end locations that are "
"covered by this instruction."
msgstr ""
":class:`dis.Positions`-objekt som innehåller de start- och slutpositioner "
"som omfattas av denna instruktion."

msgid ""
"Information about the cache entries of this instruction, as triplets of the "
"form ``(name, size, data)``, where the ``name`` and ``size`` describe the "
"cache format and data is the contents of the cache. ``cache_info`` is "
"``None`` if the instruction does not have caches."
msgstr ""
"Information om instruktionens cacheposter, som tripletter av formen ``(name, "
"size, data)``, där ``name`` och ``size`` beskriver cacheformatet och data är "
"innehållet i cachen. ``cache_info`` är ``None`` om instruktionen inte har "
"några cacheminnen."

msgid "Field ``positions`` is added."
msgstr "Fältet ``positions`` har lagts till."

msgid "Changed field ``starts_line``."
msgstr "Ändrat fält ``starts_line``."

msgid ""
"Added fields ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"and ``cache_info``."
msgstr ""
"Lagt till fälten ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"och ``cache_info``."

msgid ""
"In case the information is not available, some fields might be ``None``."
msgstr "Om informationen inte är tillgänglig kan vissa fält vara ``None``."

msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr ""
"Python-kompilatorn genererar för närvarande följande bytecode-instruktioner."

msgid "**General instructions**"
msgstr "**Allmänna instruktioner**"

msgid ""
"In the following, We will refer to the interpreter stack as ``STACK`` and "
"describe operations on it as if it was a Python list. The top of the stack "
"corresponds to ``STACK[-1]`` in this language."
msgstr ""
"I det följande kommer vi att referera till tolkens stack som ``STACK`` och "
"beskriva operationer på den som om den vore en Python-lista. Toppen av "
"stacken motsvarar ``STACK[-1]`` i detta språk."

msgid ""
"Do nothing code.  Used as a placeholder by the bytecode optimizer, and to "
"generate line tracing events."
msgstr ""
"Gör ingenting-kod.  Används som platshållare av bytekodsoptimeraren och för "
"att generera linjespårningshändelser."

msgid "Removes the top-of-stack item::"
msgstr "Tar bort det översta objektet i stapeln::"

msgid "STACK.pop()"
msgstr "STACK.pop()"

msgid ""
"Removes the top-of-stack item. Equivalent to ``POP_TOP``. Used to clean up "
"at the end of loops, hence the name."
msgstr ""
"Tar bort det översta objektet i stapeln. Motsvarar ``POP_TOP``. Används för "
"att städa upp i slutet av loopar, därav namnet."

msgid "Implements ``del STACK[-2]``. Used to clean up when a generator exits."
msgstr ""
"Implementerar ``del STACK[-2]``. Används för att städa upp när en generator "
"lämnar."

msgid ""
"Push the i-th item to the top of the stack without removing it from its "
"original location::"
msgstr ""
"Lägg det i:te föremålet överst i högen utan att ta bort det från dess "
"ursprungliga plats::"

msgid ""
"assert i > 0\n"
"STACK.append(STACK[-i])"
msgstr ""
"assert i > 0\n"
"STACK.append(STACK[-i])"

msgid "Swap the top of the stack with the i-th element::"
msgstr "Byt ut toppen av stacken mot det i:e elementet::"

msgid "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"
msgstr "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"

msgid ""
"Rather than being an actual instruction, this opcode is used to mark extra "
"space for the interpreter to cache useful data directly in the bytecode "
"itself. It is automatically hidden by all ``dis`` utilities, but can be "
"viewed with ``show_caches=True``."
msgstr ""
"I stället för att vara en faktisk instruktion används denna opcode för att "
"markera extra utrymme för tolken att cacha användbara data direkt i själva "
"bytekoden. Den döljs automatiskt av alla ``dis``-verktyg, men kan visas med "
"``show_caches=True``."

msgid ""
"Logically, this space is part of the preceding instruction. Many opcodes "
"expect to be followed by an exact number of caches, and will instruct the "
"interpreter to skip over them at runtime."
msgstr ""
"Logiskt sett är detta utrymme en del av den föregående instruktionen. Många "
"opkoder förväntar sig att följas av ett exakt antal cacher, och instruerar "
"tolken att hoppa över dem vid körning."

msgid ""
"Populated caches can look like arbitrary instructions, so great care should "
"be taken when reading or modifying raw, adaptive bytecode containing "
"quickened data."
msgstr ""
"Fyllda cacheminnen kan se ut som godtyckliga instruktioner, så stor "
"försiktighet bör iakttas vid läsning eller modifiering av rå, adaptiv "
"bytecode som innehåller quickened data."

msgid "**Unary operations**"
msgstr "**Unära operationer**"

msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""
"Unära operationer tar toppen av stapeln, tillämpar operationen och skjuter "
"tillbaka resultatet på stapeln."

msgid "Implements ``STACK[-1] = -STACK[-1]``."
msgstr "Tillämpar ``STACK[-1] = -STACK[-1]``."

msgid "Implements ``STACK[-1] = not STACK[-1]``."
msgstr "Tillämpar ``STACK[-1] = not STACK[-1]``."

msgid "This instruction now requires an exact :class:`bool` operand."
msgstr "Denna instruktion kräver nu ett exakt :class:`bool`-operand."

msgid "Implements ``STACK[-1] = ~STACK[-1]``."
msgstr "Tillämpar ``STACK[-1] = ~STACK[-1]``."

msgid "Implements ``STACK[-1] = iter(STACK[-1])``."
msgstr "Tillämpar ``STACK[-1] = iter(STACK[-1])``."

msgid ""
"If ``STACK[-1]`` is a :term:`generator iterator` or :term:`coroutine` object "
"it is left as is.  Otherwise, implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""
"Om ``STACK[-1]`` är ett :term:`generator iterator` eller :term:`coroutine` "
"objekt lämnas det som det är.  I annat fall implementeras ``STACK[-1] = "
"iter(STACK[-1])``."

msgid "Implements ``STACK[-1] = bool(STACK[-1])``."
msgstr "Tillämpar ``STACK[-1] = bool(STACK[-1])``."

msgid "**Binary and in-place operations**"
msgstr "**Binär- och platsoperationer**"

msgid ""
"Binary operations remove the top two items from the stack (``STACK[-1]`` and "
"``STACK[-2]``). They perform the operation, then put the result back on the "
"stack."
msgstr ""
"Binära operationer tar bort de två översta objekten från stacken "
"(``STACK[-1]`` och ``STACK[-2]``). De utför operationen och lägger sedan "
"tillbaka resultatet på stapeln."

msgid ""
"In-place operations are like binary operations, but the operation is done in-"
"place when ``STACK[-2]`` supports it, and the resulting ``STACK[-1]`` may be "
"(but does not have to be) the original ``STACK[-2]``."
msgstr ""
"In-place-operationer är som binära operationer, men operationen görs in-"
"place när ``STACK[-2]`` stöder det, och den resulterande ``STACK[-1]`` kan "
"vara (men behöver inte vara) den ursprungliga ``STACK[-2]``."

msgid ""
"Implements the binary and in-place operators (depending on the value of "
"*op*)::"
msgstr ""
"Implementerar binära och in-place-operatorer (beroende på värdet av *op*)::"

msgid ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"
msgstr ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"

msgid ""
"With oparg :``NB_SUBSCR``, implements binary subscript (replaces opcode "
"``BINARY_SUBSCR``)"
msgstr ""
"Med oparg :``NB_SUBSCR``, implementerar binärt subscript (ersätter opcode "
"``BINARY_SUBSCR``)"

msgid "Implements::"
msgstr "Redskap::"

msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"value = STACK.pop()\n"
"container[key] = value"
msgstr ""
"nyckel = STACK.pop()\n"
"container = STACK.pop()\n"
"värde = STACK.pop()\n"
"behållare[nyckel] = värde"

msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[key]"
msgstr ""
"nyckel = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[nyckel]"

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[start:end])"
msgstr ""
"slut = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(behållare[start:slut])"

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"values = STACK.pop()\n"
"container[start:end] = value"
msgstr ""
"slut = STACK.pop()\n"
"start = STACK.pop()\n"
"behållare = STACK.pop()\n"
"värden = STACK.pop()\n"
"behållare[start:slut] = värde"

msgid "**Coroutine opcodes**"
msgstr "**Coroutine-operationskoder**"

msgid ""
"Implements ``STACK[-1] = get_awaitable(STACK[-1])``, where "
"``get_awaitable(o)`` returns ``o`` if ``o`` is a coroutine object or a "
"generator object with the :data:`~inspect.CO_ITERABLE_COROUTINE` flag, or "
"resolves ``o.__await__``."
msgstr ""
"Implementerar ``STACK[-1] = get_awaitable(STACK[-1])``, där "
"``get_awaitable(o)`` returnerar ``o`` om ``o`` är ett coroutine-objekt eller "
"ett generatorobjekt med :data:`~inspect.CO_ITERABLE_COROUTINE`-flaggan, "
"eller löser ``o.__await__``."

msgid ""
"If the ``where`` operand is nonzero, it indicates where the instruction "
"occurs:"
msgstr ""
"Om operanden ``where`` inte är noll anger den var instruktionen inträffar:"

msgid "``1``: After a call to ``__aenter__``"
msgstr "``1``: Efter ett samtal till ``__aenter__``"

msgid "``2``: After a call to ``__aexit__``"
msgstr "``2``: Efter ett anrop till ``__aexit__``"

msgid "Previously, this instruction did not have an oparg."
msgstr "Tidigare hade denna instruktion inte någon oparg."

msgid "Implements ``STACK[-1] = STACK[-1].__aiter__()``."
msgstr "Tillämpar ``STACK[-1] = STACK[-1].__aiter__()``."

msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr "Att returnera väntande objekt från ``__aiter__`` stöds inte längre."

msgid ""
"Implement ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` to the "
"stack. See ``GET_AWAITABLE`` for details about ``get_awaitable``."
msgstr ""
"Implementera ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` till "
"stacken. Se ``GET_AWAITABLE`` för detaljer om ``get_awaitable``."

msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item. The stack contains the async iterable in ``STACK[-2]`` "
"and the raised exception in ``STACK[-1]``. Both are popped. If the exception "
"is not :exc:`StopAsyncIteration`, it is re-raised."
msgstr ""
"Avslutar en :keyword:`async for`-slinga.  Hanterar ett undantag som uppstår "
"i väntan på nästa objekt. Stapeln innehåller den asynkrona iterabeln i "
"``STACK[-2]`` och det undantag som uppstod i ``STACK[-1]``. Båda poppas. Om "
"undantaget inte är :exc:`StopAsyncIteration`, tas det upp igen."

msgid ""
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"Undantagsrepresentationen på stacken består nu av ett, inte tre, objekt."

msgid ""
"Handles an exception raised during a :meth:`~generator.throw` or :meth:"
"`~generator.close` call through the current frame.  If ``STACK[-1]`` is an "
"instance of :exc:`StopIteration`, pop three values from the stack and push "
"its ``value`` member.  Otherwise, re-raise ``STACK[-1]``."
msgstr ""
"Hanterar ett undantag som uppstår under ett anrop av :meth:`~generator."
"throw` eller :meth:`~generator.close` genom den aktuella ramen.  Om "
"``STACK[-1]`` är en instans av :exc:`StopIteration`, popa tre värden från "
"stacken och pusha dess ``value`` medlem.  I annat fall höjer du "
"``STACK[-1]`` igen."

msgid "**Miscellaneous opcodes**"
msgstr "**Diverse opkoder**"

msgid ""
"item = STACK.pop()\n"
"set.add(STACK[-i], item)"
msgstr ""
"item = STACK.pop()\n"
"set.add(STACK[-i], objekt)"

msgid "Used to implement set comprehensions."
msgstr "Används för att implementera set comprehensions."

msgid ""
"item = STACK.pop()\n"
"list.append(STACK[-i], item)"
msgstr ""
"item = STACK.pop()\n"
"list.append(STACK[-i], objekt)"

msgid "Used to implement list comprehensions."
msgstr "Används för att implementera listförståelse."

msgid ""
"value = STACK.pop()\n"
"key = STACK.pop()\n"
"dict.__setitem__(STACK[-i], key, value)"
msgstr ""
"värde = STACK.pop()\n"
"nyckel = STACK.pop()\n"
"dict.__setitem__(STACK[-i], nyckel, värde)"

msgid "Used to implement dict comprehensions."
msgstr "Används för att implementera diktförståelse."

msgid ""
"Map value is ``STACK[-1]`` and map key is ``STACK[-2]``. Before, those were "
"reversed."
msgstr ""
"Kartans värde är ``STACK[-1]`` och kartans nyckel är ``STACK[-2]``. Tidigare "
"var de omvända."

msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and :opcode:"
"`MAP_ADD` instructions, while the added value or key/value pair is popped "
"off, the container object remains on the stack so that it is available for "
"further iterations of the loop."
msgstr ""
"För alla instruktionerna :opcode:`SET_ADD`, :opcode:`LIST_APPEND` och :"
"opcode:`MAP_ADD`, medan det tillagda värdet eller nyckel/värde-paret poppas "
"ut, ligger containerobjektet kvar på stacken så att det är tillgängligt för "
"ytterligare iterationer av loopen."

msgid "Returns with ``STACK[-1]`` to the caller of the function."
msgstr "Returneras med ``STACK[-1]`` till den som anropar funktionen."

msgid "Yields ``STACK.pop()`` from a :term:`generator`."
msgstr "Ger ``STACK.pop()`` från en :term:`generator`."

msgid "oparg set to be the stack depth."
msgstr "oparg satt till att vara stackdjupet."

msgid ""
"oparg set to be the exception block depth, for efficient closing of "
"generators."
msgstr ""
"oparg satt till att vara undantagsblockets djup, för effektiv stängning av "
"generatorer."

msgid ""
"oparg is ``1`` if this instruction is part of a yield-from or await, and "
"``0`` otherwise."
msgstr ""
"oparg är ``1`` om denna instruktion är en del av en yield-from eller await, "
"och ``0`` annars."

msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"Kontrollerar om ``__annotations__`` är definierad i ``locals()``, om inte "
"sätts den upp till en tom ``dict``. Denna opcode skickas endast ut om en "
"klass eller modul innehåller :term:`variable annotations <variable "
"annotation>` statiskt."

msgid ""
"Pops a value from the stack, which is used to restore the exception state."
msgstr ""
"Plockar upp ett värde från stacken, som används för att återställa "
"undantagstillståndet."

msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"pops an additional value from the stack which is used to set :attr:`~frame."
"f_lasti` of the current frame."
msgstr ""
"Återupptar undantaget som för närvarande ligger överst på stacken. Om oparg "
"inte är noll, plockas ett ytterligare värde från stacken som används för att "
"ställa in :attr:`~frame.f_lasti` för den aktuella ramen."

msgid ""
"Pops a value from the stack. Pushes the current exception to the top of the "
"stack. Pushes the value originally popped back to the stack. Used in "
"exception handlers."
msgstr ""
"Plockar ett värde från stacken. Flyttar det aktuella undantaget till toppen "
"av stacken. Skjuter tillbaka det ursprungligen poppade värdet till stacken. "
"Används i undantagshanterare."

msgid ""
"Performs exception matching for ``except``. Tests whether the ``STACK[-2]`` "
"is an exception matching ``STACK[-1]``. Pops ``STACK[-1]`` and pushes the "
"boolean result of the test."
msgstr ""
"Utför undantagsmatchning för ``except``. Testar om ``STACK[-2]`` är ett "
"undantag som matchar ``STACK[-1]``. Plockar upp ``STACK[-1]`` och lägger "
"till det booleska resultatet av testet."

msgid ""
"Performs exception matching for ``except*``. Applies ``split(STACK[-1])`` on "
"the exception group representing ``STACK[-2]``."
msgstr ""
"Utför undantagsmatchning för ``except*``. Tillämpar ``split(STACK[-1])`` på "
"den undantagsgrupp som representerar ``STACK[-2]``."

msgid ""
"In case of a match, pops two items from the stack and pushes the non-"
"matching subgroup (``None`` in case of full match) followed by the matching "
"subgroup. When there is no match, pops one item (the match type) and pushes "
"``None``."
msgstr ""
"Vid en matchning plockas två objekt från stacken och den icke-matchande "
"undergruppen (``None`` vid fullständig matchning) skjuts upp, följt av den "
"matchande undergruppen. När det inte finns någon matchning, plockas ett "
"objekt (matchningstypen) ut och ``None`` skjuts in."

msgid ""
"Calls the function in position 4 on the stack with arguments (type, val, tb) "
"representing the exception at the top of the stack. Used to implement the "
"call ``context_manager.__exit__(*exc_info())`` when an exception has "
"occurred in a :keyword:`with` statement."
msgstr ""
"Anropar funktionen i position 4 på stacken med argument (type, val, tb) som "
"representerar undantaget högst upp på stacken. Används för att implementera "
"anropet ``context_manager.__exit__(*exc_info())`` när ett undantag har "
"inträffat i en :keyword:`with`-sats."

msgid ""
"The ``__exit__`` function is in position 4 of the stack rather than 7. "
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"Funktionen ``__exit__`` ligger på position 4 i stacken i stället för 7. "
"Undantagsrepresentationen på stacken består nu av ett objekt i stället för "
"tre."

msgid ""
"Pushes a common constant onto the stack. The interpreter contains a "
"hardcoded list of constants supported by this instruction.  Used by the :"
"keyword:`assert` statement to load :exc:`AssertionError`."
msgstr ""
"Skjuter upp en vanlig konstant på stacken. Tolken innehåller en hårdkodad "
"lista över konstanter som stöds av denna instruktion.  Används av :keyword:"
"`assert`-satsen för att ladda :exc:`AssertionError`."

msgid ""
"Pushes :func:`!builtins.__build_class__` onto the stack.  It is later called "
"to construct a class."
msgstr ""
"Lägger :func:`!builtins.__build_class__` på stacken.  Den anropas senare för "
"att konstruera en klass."

msgid ""
"Perform ``STACK.append(len(STACK[-1]))``. Used in :keyword:`match` "
"statements where comparison with structure of pattern is needed."
msgstr ""
"Utför ``STACK.append(len(STACK[-1]))``. Används i :keyword:`match`-satser "
"där jämförelse med mönstrets struktur behövs."

msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Mapping` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Om ``STACK[-1]`` är en instans av :class:`collections.abc.Mapping` (eller, "
"mer tekniskt: om den har :c:macro:`Py_TPFLAGS_MAPPING` flaggan inställd i "
"sin :c:member:`~PyTypeObject.tp_flags`), lägg ``True`` på stacken.  Annars "
"läggs ``False`` till."

msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Sequence` and is "
"*not* an instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Om ``STACK[-1]`` är en instans av :class:`collections.abc.Sequence` och "
"*inte* är en instans av :class:`str`/:class:`bytes`/:class:`bytearray` "
"(eller, mer tekniskt: om den har :c:macro:`Py_TPFLAGS_SEQUENCE` flaggan "
"inställd i sin :c:member:`~PyTypeObject.tp_flags`), lägg ``True`` på "
"stacken.  Annars läggs ``False`` till."

msgid ""
"``STACK[-1]`` is a tuple of mapping keys, and ``STACK[-2]`` is the match "
"subject. If ``STACK[-2]`` contains all of the keys in ``STACK[-1]``, push a :"
"class:`tuple` containing the corresponding values. Otherwise, push ``None``."
msgstr ""
"``STACK[-1]`` är en tupel med mappningsnycklar och ``STACK[-2]`` är "
"matchningsobjektet. Om ``STACK[-2]`` innehåller alla nycklar i "
"``STACK[-1]``, pushar du en :class:`tuple` som innehåller motsvarande "
"värden. I annat fall skickas ``None``."

msgid ""
"Previously, this instruction also pushed a boolean value indicating success "
"(``True``) or failure (``False``)."
msgstr ""
"Tidigare skickade denna instruktion också ett booleskt värde som indikerade "
"framgång (``True``) eller misslyckande (``False``)."

msgid ""
"Implements ``name = STACK.pop()``. *namei* is the index of *name* in the "
"attribute :attr:`~codeobject.co_names` of the :ref:`code object <code-"
"objects>`. The compiler tries to use :opcode:`STORE_FAST` or :opcode:"
"`STORE_GLOBAL` if possible."
msgstr ""
"Implementerar ``name = STACK.pop()``. *namei* är indexet för *name* i "
"attributet :attr:`~codeobject.co_names` i :ref:``code object <code-"
"objects>`. Kompilatorn försöker använda :opcode:`STORE_FAST` eller :opcode:"
"`STORE_GLOBAL` om möjligt."

msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`~codeobject."
"co_names` attribute of the :ref:`code object <code-objects>`."
msgstr ""
"Implementerar ``del name``, där *namei* är indexet i attributet :attr:"
"`~codeobject.co_names` i :ref:`code object <code-objects>`."

msgid ""
"Unpacks ``STACK[-1]`` into *count* individual values, which are put onto the "
"stack right-to-left. Require there to be exactly *count* values.::"
msgstr ""
"Packar upp ``STACK[-1]`` till *antal* enskilda värden, som läggs på stacken "
"från höger till vänster. Kräver att det finns exakt *antal* värden::"

msgid ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"
msgstr ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"

msgid ""
"Implements assignment with a starred target: Unpacks an iterable in "
"``STACK[-1]`` into individual values, where the total number of values can "
"be smaller than the number of items in the iterable: one of the new values "
"will be a list of all leftover items."
msgstr ""
"Implementerar assignment med ett stjärnmärkt mål: Packar upp en iterabel i "
"``STACK[-1]`` i enskilda värden, där det totala antalet värden kan vara "
"mindre än antalet objekt i iterabeln: ett av de nya värdena kommer att vara "
"en lista över alla kvarvarande objekt."

msgid "The number of values before and after the list value is limited to 255."
msgstr "Antalet värden före och efter listvärdet är begränsat till 255."

msgid ""
"The number of values before the list value is encoded in the argument of the "
"opcode. The number of values after the list if any is encoded using an "
"``EXTENDED_ARG``. As a consequence, the argument can be seen as a two bytes "
"values where the low byte of *counts* is the number of values before the "
"list value, the high byte of *counts* the number of values after it."
msgstr ""
"Antalet värden före listvärdet kodas i opkodens argument. Antalet värden "
"efter listan, om det finns några, kodas med hjälp av en ``EXTENDED_ARG``. "
"Som en följd av detta kan argumentet ses som ett värde på två byte där den "
"låga byten i *counts* är antalet värden före listvärdet, den höga byten i "
"*counts* är antalet värden efter det."

msgid ""
"The extracted values are put onto the stack right-to-left, i.e. ``a, *b, c = "
"d`` will be stored after execution as ``STACK.extend((a, b, c))``."
msgstr ""
"De extraherade värdena läggs på stacken från höger till vänster, dvs. ``a, "
"*b, c = d`` kommer efter exekvering att lagras som ``STACK.extend((a, b, "
"c))``."

msgid ""
"obj = STACK.pop()\n"
"value = STACK.pop()\n"
"obj.name = value"
msgstr ""
"obj = STACK.pop()\n"
"värde = STACK.pop()\n"
"obj.namn = värde"

msgid ""
"where *namei* is the index of name in :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"där *namei* är index för namn i :attr:`~codeobject.co_names` för :ref:`code "
"object <code-objects>`."

msgid ""
"obj = STACK.pop()\n"
"del obj.name"
msgstr ""
"obj = STACK.pop()\n"
"del obj.namn"

msgid ""
"where *namei* is the index of name into :attr:`~codeobject.co_names` of the :"
"ref:`code object <code-objects>`."
msgstr ""
"där *namei* är index för namn i :attr:`~codeobject.co_names` för :ref:`code "
"object <code-objects>`."

msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr "Fungerar som :opcode:`STORE_NAME`, men lagrar namnet som en global."

msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr "Fungerar som :opcode:`DELETE_NAME`, men raderar ett globalt namn."

msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "Lägger ``co_consts[consti]`` på stacken."

msgid ""
"Pushes the integer ``i`` onto the stack. ``i`` must be in ``range(256)``"
msgstr ""
"Skjuter upp heltalet ``i`` på stacken. ``i`` måste ligga inom "
"``intervall(256)``"

msgid ""
"Pushes the value associated with ``co_names[namei]`` onto the stack. The "
"name is looked up within the locals, then the globals, then the builtins."
msgstr ""
"Lägger det värde som associeras med ``co_names[namei]`` på stacken. Namnet "
"söks upp i de lokala, sedan i de globala och sedan i de inbyggda."

msgid ""
"Pushes a reference to the locals dictionary onto the stack.  This is used to "
"prepare namespace dictionaries for :opcode:`LOAD_FROM_DICT_OR_DEREF` and :"
"opcode:`LOAD_FROM_DICT_OR_GLOBALS`."
msgstr ""
"Lägger en referens till locals-ordlistan på stacken.  Detta används för att "
"förbereda namnrymdsordböcker för :opcode:`LOAD_FROM_DICT_OR_DEREF` och :"
"opcode:`LOAD_FROM_DICT_OR_GLOBALS`."

msgid ""
"Pops a mapping off the stack and looks up the value for ``co_names[namei]``. "
"If the name is not found there, looks it up in the globals and then the "
"builtins, similar to :opcode:`LOAD_GLOBAL`. This is used for loading global "
"variables in :ref:`annotation scopes <annotation-scopes>` within class "
"bodies."
msgstr ""
"Plockar upp en mappning från stacken och letar upp värdet för "
"``co_names[namei]``. Om namnet inte hittas där, letar det upp det i de "
"globala variablerna och sedan i de inbyggda variablerna, liknande :opcode:"
"`LOAD_GLOBAL`. Detta används för att ladda globala variabler i :ref:"
"``annotation scopes <annotation-scopes>`` inom klasskroppar."

msgid ""
"Constructs a new :class:`~string.templatelib.Template` from a tuple of "
"strings and a tuple of interpolations and pushes the resulting instance onto "
"the stack::"
msgstr ""
"Konstruerar en ny :class:`~string.templatelib.Template` från en tupel "
"strängar och en tupel interpoleringar och lägger den resulterande instansen "
"på stacken::"

msgid ""
"interpolations = STACK.pop()\n"
"strings = STACK.pop()\n"
"STACK.append(_build_template(strings, interpolations))"
msgstr ""
"interpolationer = STACK.pop()\n"
"strängar = STACK.pop()\n"
"STACK.append(_build_template(strängar, interpolationer))"

msgid ""
"Constructs a new :class:`~string.templatelib.Interpolation` from a value and "
"its source expression and pushes the resulting instance onto the stack."
msgstr ""
"Konstruerar en ny :class:`~string.templatelib.Interpolation` från ett värde "
"och dess källuttryck och lägger den resulterande instansen på stacken."

msgid ""
"If no conversion or format specification is present, ``format`` is set to "
"``2``."
msgstr ""
"Om ingen konvertering eller formatspecifikation finns, sätts ``format`` till "
"``2``."

msgid ""
"If the low bit of ``format`` is set, it indicates that the interpolation "
"contains a format specification."
msgstr ""
"Om den låga biten i ``format`` är inställd, indikerar det att "
"interpoleringen innehåller en formatspecifikation."

msgid ""
"If ``format >> 2`` is non-zero, it indicates that the interpolation contains "
"a conversion. The value of ``format >> 2`` is the conversion type (``0`` for "
"no conversion, ``1`` for ``!s``, ``2`` for ``!r``, and ``3`` for ``!a``)::"
msgstr ""
"Om ``format >> 2`` är icke-noll, indikerar det att interpoleringen "
"innehåller en konvertering. Värdet på ``format >> 2`` är konverteringstypen "
"(``0`` för ingen konvertering, ``1`` för ``!s``, ``2`` för ``!r`` och ``3`` "
"för ``!a``)::"

msgid ""
"conversion = format >> 2\n"
"if format & 1:\n"
"    format_spec = STACK.pop()\n"
"else:\n"
"    format_spec = None\n"
"expression = STACK.pop()\n"
"value = STACK.pop()\n"
"STACK.append(_build_interpolation(value, expression, conversion, "
"format_spec))"
msgstr ""
"konvertering = format >> 2\n"
"om format & 1:\n"
"    format_spec = STACK.pop()\n"
"annat:\n"
"    format_spec = Ingen\n"
"uttryck = STACK.pop()\n"
"värde = STACK.pop()\n"
"STACK.append(_build_interpolation(värde, uttryck, konvertering, format_spec))"

msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack::"
msgstr ""
"Skapar en tupel som använder *antal* objekt från stacken, och lägger den "
"resulterande tupeln på stacken::"

msgid ""
"if count == 0:\n"
"    value = ()\n"
"else:\n"
"    value = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(value)"
msgstr ""
"om count == 0:\n"
"    värde = ()\n"
"i annat fall\n"
"    värde = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(värde)"

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr "Fungerar som :opcode:`BUILD_TUPLE`, men skapar en lista."

msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr "Fungerar som :opcode:`BUILD_TUPLE`, men skapar en uppsättning."

msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."
msgstr ""
"Lägger ett nytt ordboksobjekt på stacken.  Popar upp ``2 * count`` objekt så "
"att ordboken innehåller *count* poster: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."

msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""
"Ordboken skapas från stapelobjekt istället för att skapa en tom ordbok som "
"är förstorad för att rymma *antal* objekt."

msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr ""
"Sammanfogar *antal* strängar från stacken och lägger den resulterande "
"strängen på stacken."

msgid ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"
msgstr ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"

msgid "Used to build lists."
msgstr "Används för att bygga listor."

msgid ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"
msgstr ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"

msgid "Used to build sets."
msgstr "Används för att bygga set."

msgid ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"
msgstr ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"

msgid "Used to build dicts."
msgstr "Används för att bygga dikter."

msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""
"Som :opcode:`DICT_UPDATE` men ger upphov till ett undantag för dubbla "
"nycklar."

msgid ""
"If the low bit of ``namei`` is not set, this replaces ``STACK[-1]`` with "
"``getattr(STACK[-1], co_names[namei>>1])``."
msgstr ""
"Om den låga biten i ``namei`` inte är inställd, ersätts ``STACK[-1]`` med "
"``getattr(STACK[-1], co_names[namei>>1])``."

msgid ""
"If the low bit of ``namei`` is set, this will attempt to load a method named "
"``co_names[namei>>1]`` from the ``STACK[-1]`` object. ``STACK[-1]`` is "
"popped. This bytecode distinguishes two cases: if ``STACK[-1]`` has a method "
"with the correct name, the bytecode pushes the unbound method and "
"``STACK[-1]``. ``STACK[-1]`` will be used as the first argument (``self``) "
"by :opcode:`CALL` or :opcode:`CALL_KW` when calling the unbound method. "
"Otherwise, ``NULL`` and the object returned by the attribute lookup are "
"pushed."
msgstr ""
"Om den låga biten i ``namei`` är satt, kommer detta att försöka ladda en "
"metod med namnet ``co_names[namei>>1]`` från ``STACK[-1]``-objektet. "
"``STACK[-1]`` poppas. Denna bytecode skiljer på två fall: om ``STACK[-1]`` "
"har en metod med rätt namn, pushar bytecoden den obundna metoden och "
"``STACK[-1]``. ``STACK[-1]`` kommer att användas som det första argumentet "
"(``self``) av :opcode:`CALL` eller :opcode:`CALL_KW` när den obundna metoden "
"anropas. Annars skjuts ``NULL`` och det objekt som returneras av "
"attributuppslagningen."

msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` or ``self`` is pushed to "
"the stack before the attribute or unbound method respectively."
msgstr ""
"Om den låga biten i ``namei`` är satt, läggs en ``NULL`` eller ``self`` till "
"stacken före attributet respektive den obundna metoden."

msgid ""
"This opcode implements :func:`super`, both in its zero-argument and two-"
"argument forms (e.g. ``super().method()``, ``super().attr`` and ``super(cls, "
"self).method()``, ``super(cls, self).attr``)."
msgstr ""
"Denna opcode implementerar :func:`super`, både i dess nollargument- och "
"tvåargumentform (t.ex. ``super().method()``, ``super().attr`` och "
"``super(cls, self).method()``, ``super(cls, self).attr``)."

msgid "It pops three values from the stack (from top of stack down):"
msgstr ""
"Den plockar ut tre värden från stacken (från toppen av stacken och nedåt):"

msgid "``self``: the first argument to the current method"
msgstr "``self``: det första argumentet till den aktuella metoden"

msgid "``cls``: the class within which the current method was defined"
msgstr "``cls``: den klass inom vilken den aktuella metoden definierades"

msgid "the global ``super``"
msgstr "den globala ``super``"

msgid ""
"With respect to its argument, it works similarly to :opcode:`LOAD_ATTR`, "
"except that ``namei`` is shifted left by 2 bits instead of 1."
msgstr ""
"När det gäller dess argument fungerar den på samma sätt som :opcode:"
"`LOAD_ATTR`, förutom att ``namei`` vänsterförskjuts med 2 bitar istället för "
"1."

msgid ""
"The low bit of ``namei`` signals to attempt a method load, as with :opcode:"
"`LOAD_ATTR`, which results in pushing ``NULL`` and the loaded method. When "
"it is unset a single value is pushed to the stack."
msgstr ""
"Den låga biten i ``namei`` signalerar att man ska försöka ladda en metod, "
"som med :opcode:`LOAD_ATTR`, vilket resulterar i att ``NULL`` och den "
"laddade metoden skjuts upp. När den inte är inställd flyttas ett enda värde "
"till stacken."

msgid ""
"The second-low bit of ``namei``, if set, means that this was a two-argument "
"call to :func:`super` (unset means zero-argument)."
msgstr ""
"Den näst lägsta biten i ``namei``, om den är satt, betyder att detta var ett "
"anrop med två argument till :func:`super` (om den inte är satt betyder det "
"noll argument)."

msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname >> 5]``. If the fifth-lowest bit of ``opname`` is set "
"(``opname & 16``), the result should be coerced to ``bool``."
msgstr ""
"Utför en boolesk operation.  Operationsnamnet kan hittas i ``cmp_op[opname "
">> 5]``. Om den femte lägsta biten i ``opname`` är inställd (``opname & "
"16``), bör resultatet tvingas till ``bool``."

msgid ""
"The fifth-lowest bit of the oparg now indicates a forced conversion to :"
"class:`bool`."
msgstr ""
"Den femte lägsta biten i oparget indikerar nu en tvingad konvertering till :"
"class:`bool`."

msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr "Utför jämförelse med ``is``, eller ``is not`` om ``invert`` är 1."

msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr "Utför jämförelse ``in``, eller ``not in`` om ``invert`` är 1."

msgid ""
"Imports the module ``co_names[namei]``.  ``STACK[-1]`` and ``STACK[-2]`` are "
"popped and provide the *fromlist* and *level* arguments of :func:"
"`__import__`. The module object is pushed onto the stack.  The current "
"namespace is not affected: for a proper import statement, a subsequent :"
"opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""
"Importerar modulen ``co_names[namei]``.  ``STACK[-1]`` och ``STACK[-2]`` "
"poppas och ger argumenten *fromlist* och *level* i :func:`__import__`. "
"Modulobjektet skjuts upp på stacken.  Den aktuella namnrymden påverkas inte: "
"för en korrekt importsats modifieras namnrymden av en efterföljande :opcode:"
"`STORE_FAST'-instruktion."

msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in "
"``STACK[-1]``. The resulting object is pushed onto the stack, to be "
"subsequently stored by a :opcode:`STORE_FAST` instruction."
msgstr ""
"Läser in attributet ``co_names[namei]`` från den modul som finns i "
"``STACK[-1]``. Det resulterande objektet läggs på stacken, för att sedan "
"lagras med en :opcode:`STORE_FAST` instruktion."

msgid "Increments bytecode counter by *delta*."
msgstr "Ökar bytekodsräknaren med *delta*."

msgid "Decrements bytecode counter by *delta*. Checks for interrupts."
msgstr "Minskar bytekodsräknaren med *delta*. Kontrollerar för avbrott."

msgid "Decrements bytecode counter by *delta*. Does not check for interrupts."
msgstr "Minskar bytekodsräknaren med *delta*. Kontrollerar inte för avbrott."

msgid ""
"If ``STACK[-1]`` is true, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Om ``STACK[-1]`` är true, ökas bytecode-räknaren med *delta*. om "
"``STACK[-1]`` är poppad."

msgid ""
"The oparg is now a relative delta rather than an absolute target. This "
"opcode is a pseudo-instruction, replaced in final bytecode by the directed "
"versions (forward/backward)."
msgstr ""
"Oparget är nu ett relativt delta snarare än ett absolut mål. Denna opcode är "
"en pseudo-instruktion som i den slutliga bytekoden ersätts av de riktade "
"versionerna (framåt/bakåt)."

msgid "This is no longer a pseudo-instruction."
msgstr "Detta är inte längre en pseudo-instruktion."

msgid ""
"If ``STACK[-1]`` is false, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Om ``STACK[-1]`` är false, ökas bytecode-räknaren med *delta*. ``STACK[-1]`` "
"är poppad."

msgid ""
"If ``STACK[-1]`` is not ``None``, increments the bytecode counter by "
"*delta*. ``STACK[-1]`` is popped."
msgstr ""
"Om ``STACK[-1]`` inte är ``None``, ökas bytekodräknaren med *delta*. "
"``STACK[-1]`` poppas."

msgid ""
"If ``STACK[-1]`` is ``None``, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Om ``STACK[-1]`` är ``None``, ökas bytekodsräknaren med *delta*. "
"``STACK[-1]`` är poppat."

msgid ""
"``STACK[-1]`` is an :term:`iterator`.  Call its :meth:`~iterator.__next__` "
"method. If this yields a new value, push it on the stack (leaving the "
"iterator below it).  If the iterator indicates it is exhausted then the byte "
"code counter is incremented by *delta*."
msgstr ""
"``STACK[-1]`` är en :term:`iterator`.  Anropa dess :meth:`~iterator."
"__next__`-metod. Om detta ger ett nytt värde, lägg det på stacken (och lämna "
"iteratorn under det).  Om iteratorn indikerar att den är uttömd ökas "
"bytekodsräknaren med *delta*."

msgid "Up until 3.11 the iterator was popped when it was exhausted."
msgstr "Fram till 3.11 poppades iteratorn när den var uttömd."

msgid "Loads the global named ``co_names[namei>>1]`` onto the stack."
msgstr ""
"Läser in den globala filen med namnet ``co_names[namei>>1]`` på stacken."

msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` is pushed to the stack "
"before the global variable."
msgstr ""
"Om den låga biten i ``namei`` är inställd, skjuts en ``NULL`` till stacken "
"före den globala variabeln."

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr ""
"Lägger en referens till den lokala ``co_varnames[var_num]`` på stacken."

msgid ""
"This opcode is now only used in situations where the local variable is "
"guaranteed to be initialized. It cannot raise :exc:`UnboundLocalError`."
msgstr ""
"Denna opcode används nu endast i situationer där den lokala variabeln "
"garanterat kommer att initialiseras. Den kan inte ge upphov till :exc:"
"`UnboundLocalError`."

msgid ""
"Pushes a borrowed reference to the local ``co_varnames[var_num]`` onto the "
"stack."
msgstr ""
"Lägger en lånad referens till den lokala ``co_varnames[var_num]`` på stacken."

msgid ""
"Pushes references to ``co_varnames[var_nums >> 4]`` and "
"``co_varnames[var_nums & 15]`` onto the stack."
msgstr ""
"Flyttar referenser till ``co_varnames[var_nums >> 4]`` och "
"``co_varnames[var_nums & 15]`` till stacken."

msgid ""
"Pushes borrowed references to ``co_varnames[var_nums >> 4]`` and "
"``co_varnames[var_nums & 15]`` onto the stack."
msgstr ""
"Lägger upp lånade referenser till ``co_varnames[var_nums >> 4]`` och "
"``co_varnames[var_nums & 15]`` på stacken."

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack, "
"raising an :exc:`UnboundLocalError` if the local variable has not been "
"initialized."
msgstr ""
"Lägger en referens till den lokala ``co_varnames[var_num]`` på stacken, "
"vilket ger upphov till :exc:`UnboundLocalError` om den lokala variabeln inte "
"har initialiserats."

msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack (or "
"pushes ``NULL`` onto the stack if the local variable has not been "
"initialized) and sets ``co_varnames[var_num]`` to ``NULL``."
msgstr ""
"Lägger en referens till den lokala ``co_varnames[var_num]`` på stacken "
"(eller lägger ``NULL`` på stacken om den lokala variabeln inte har "
"initialiserats) och sätter ``co_varnames[var_num]`` till ``NULL``."

msgid "Stores ``STACK.pop()`` into the local ``co_varnames[var_num]``."
msgstr "Lagrar ``STACK.pop()`` i den lokala ``co_varnames[var_num]``."

msgid ""
"Stores ``STACK[-1]`` into ``co_varnames[var_nums >> 4]`` and ``STACK[-2]`` "
"into ``co_varnames[var_nums & 15]``."
msgstr ""
"Lagrar ``STACK[-1]`` i ``co_varnames[var_nums >> 4]`` och ``STACK[-2]`` i "
"``co_varnames[var_nums & 15]``."

msgid ""
"Stores ``STACK.pop()`` into the local ``co_varnames[var_nums >> 4]`` and "
"pushes a reference to the local ``co_varnames[var_nums & 15]`` onto the "
"stack."
msgstr ""
"Lagrar ``STACK.pop()`` i den lokala ``co_varnames[var_nums >> 4]`` och "
"lägger en referens till den lokala ``co_varnames[var_nums & 15]`` på stacken."

msgid "Deletes local ``co_varnames[var_num]``."
msgstr "Raderar lokala ``co_varnames[var_num]``."

msgid ""
"Creates a new cell in slot ``i``.  If that slot is nonempty then that value "
"is stored into the new cell."
msgstr ""
"Skapar en ny cell i slot ``i``.  Om den platsen inte är tom lagras värdet i "
"den nya cellen."

msgid ""
"Loads the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""
"Laddar cellen som finns på plats ``i`` i \"fast locals\"-lagret. Lägger en "
"referens till det objekt som cellen innehåller på stacken."

msgid ""
"``i`` is no longer offset by the length of :attr:`~codeobject.co_varnames`."
msgstr ""
"``i`` kompenseras inte längre av längden på :attr:`~codeobject.co_varnames`."

msgid ""
"Pops a mapping off the stack and looks up the name associated with slot "
"``i`` of the \"fast locals\" storage in this mapping. If the name is not "
"found there, loads it from the cell contained in slot ``i``, similar to :"
"opcode:`LOAD_DEREF`. This is used for loading :term:`closure variables "
"<closure variable>` in class bodies (which previously used :opcode:`!"
"LOAD_CLASSDEREF`) and in :ref:`annotation scopes <annotation-scopes>` within "
"class bodies."
msgstr ""
"Tar en mappning från stacken och letar upp det namn som är associerat med "
"plats ``i`` i \"fast locals\"-lagret i denna mappning. Om namnet inte hittas "
"där, laddas det från cellen som finns i slot ``i``, liknande :opcode:"
"`LOAD_DEREF`. Detta används för att läsa in :term:`closure variables "
"<closure variable>` i class bodies (som tidigare använde :opcode:`!"
"LOAD_CLASSDEREF`) och i :ref:`annotation scopes <annotation-scopes>` inom "
"class bodies."

msgid ""
"Stores ``STACK.pop()`` into the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""
"Lagrar ``STACK.pop()`` i cellen som finns på plats ``i`` i \"fast locals\"-"
"lagret."

msgid ""
"Empties the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Used by the :keyword:`del` statement."
msgstr ""
"Tömmer cellen som finns i plats ``i`` i lagret för \"snabba lokala\". "
"Används av :keyword:`del`-satsen."

msgid ""
"Copies the ``n`` :term:`free (closure) variables <closure variable>` from "
"the closure into the frame. Removes the need for special code on the "
"caller's side when calling closures."
msgstr ""
"Kopierar ``n`` :term:`free (closure) variables <closure variable>` från "
"closure till frame. Tar bort behovet av specialkod på anroparens sida vid "
"anrop av closures."

msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""
"Utlöser ett undantag med hjälp av en av de tre formerna av ``raise``-satsen, "
"beroende på värdet på *argc*:"

msgid "0: ``raise`` (re-raise previous exception)"
msgstr "0: ``raise`` (åter höja tidigare undantag)"

msgid ""
"1: ``raise STACK[-1]`` (raise exception instance or type at ``STACK[-1]``)"
msgstr ""
"1: ``raise STACK[-1]`` (skapa undantag för instans eller typ vid "
"``STACK[-1]``)"

msgid ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"
msgstr ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"

msgid ""
"Calls a callable object with the number of arguments specified by ``argc``. "
"On the stack are (in ascending order):"
msgstr ""
"Anropar ett anropsbart objekt med det antal argument som anges av ``argc``. "
"På stacken finns (i stigande ordning):"

msgid "The callable"
msgstr "Den infordringsbara"

msgid "``self`` or ``NULL``"
msgstr "``själv`` eller ``NULL``"

msgid "The remaining positional arguments"
msgstr "De återstående positionella argumenten"

msgid "``argc`` is the total of the positional arguments, excluding ``self``."
msgstr "``argc`` är summan av de positionella argumenten, exklusive ``self``."

msgid ""
"``CALL`` pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value returned "
"by the callable object."
msgstr ""
"``CALL`` plockar alla argument och det anropbara objektet från stacken, "
"anropar det anropbara objektet med dessa argument och flyttar returvärdet "
"som returneras av det anropbara objektet."

msgid "The callable now always appears at the same position on the stack."
msgstr "Det anropbara objektet visas nu alltid på samma plats i stacken."

msgid "Calls with keyword arguments are now handled by :opcode:`CALL_KW`."
msgstr "Anrop med nyckelordsargument hanteras nu av :opcode:`CALL_KW`."

msgid ""
"Calls a callable object with the number of arguments specified by ``argc``, "
"including one or more named arguments. On the stack are (in ascending order):"
msgstr ""
"Anropar ett anropsbart objekt med det antal argument som anges av ``argc``, "
"inklusive ett eller flera namngivna argument. På stacken finns (i stigande "
"ordning):"

msgid "The named arguments"
msgstr "De namngivna argumenten"

msgid "A :class:`tuple` of keyword argument names"
msgstr "En :class:`tupel` av nyckelordsargumentnamn"

msgid ""
"``argc`` is the total of the positional and named arguments, excluding "
"``self``. The length of the tuple of keyword argument names is the number of "
"named arguments."
msgstr ""
"``argc`` är summan av de positionella och namngivna argumenten, exklusive "
"``self``. Längden på tupeln med nyckelordsargumentnamn är antalet namngivna "
"argument."

msgid ""
"``CALL_KW`` pops all arguments, the keyword names, and the callable object "
"off the stack, calls the callable object with those arguments, and pushes "
"the return value returned by the callable object."
msgstr ""
"``CALL_KW`` plockar alla argument, nyckelordsnamnen och det anropbara "
"objektet från stacken, anropar det anropbara objektet med dessa argument och "
"flyttar returvärdet som returneras av det anropbara objektet."

msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""
"Anropar ett anropsbart objekt med en variabel uppsättning positions- och "
"nyckelordsargument.  Om den lägsta biten i *flags* är inställd, innehåller "
"toppen av stacken ett mappningsobjekt som innehåller ytterligare "
"nyckelordsargument. Innan den anropbara funktionen anropas \"packas\" "
"mappningsobjektet och iterable-objektet upp och deras innehåll skickas in "
"som nyckelords- respektive positionsargument. ``CALL_FUNCTION_EX`` plockar "
"alla argument och det anropbara objektet från stacken, anropar det anropbara "
"objektet med dessa argument och flyttar returvärdet som returneras av det "
"anropbara objektet."

msgid ""
"Pushes a ``NULL`` to the stack. Used in the call sequence to match the "
"``NULL`` pushed by :opcode:`LOAD_METHOD` for non-method calls."
msgstr ""
"Skickar en ``NULL`` till stacken. Används i anropssekvensen för att matcha "
"den ``NULL`` som pushas av :opcode:`LOAD_METHOD` för icke-metodanrop."

msgid ""
"Pushes a new function object on the stack built from the code object at "
"``STACK[-1]``."
msgstr ""
"Lägger ett nytt funktionsobjekt på stacken som byggts upp från kodobjektet "
"på ``STACK[-1]``."

msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr "Flaggvärdet ``0x04`` är en tupel av strängar istället för en ordbok"

msgid "Qualified name at ``STACK[-1]`` was removed."
msgstr "Kvalificerat namn vid ``STACK[-1]`` togs bort."

msgid ""
"Extra function attributes on the stack, signaled by oparg flags, were "
"removed. They now use :opcode:`SET_FUNCTION_ATTRIBUTE`."
msgstr ""
"Extra funktionsattribut på stacken, som signaleras av oparg-flaggor, har "
"tagits bort. De använder nu :opcode:`SET_FUNCTION_ATTRIBUTE`."

msgid ""
"Sets an attribute on a function object. Expects the function at "
"``STACK[-1]`` and the attribute value to set at ``STACK[-2]``; consumes both "
"and leaves the function at ``STACK[-1]``. The flag determines which "
"attribute to set:"
msgstr ""
"Ställer in ett attribut på ett funktionsobjekt. Förväntar sig funktionen på "
"``STACK[-1]`` och attributvärdet som ska sättas på ``STACK[-2]``; konsumerar "
"båda och lämnar funktionen på ``STACK[-1]``. Flaggan avgör vilket attribut "
"som ska ställas in:"

msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""
"``0x01`` en tupel av standardvärden för parametrar som endast är "
"positionella och positionella eller nyckelord i positionell ordning"

msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""
"``0x02`` en ordbok med standardvärden för parametrar som endast innehåller "
"nyckelord"

msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr ""
"``0x04`` en tupel av strängar som innehåller parametrarnas anteckningar"

msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""
"``0x08`` en tupel som innehåller celler för fria variabler, vilket ger en "
"stängning"

msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"implements::"
msgstr ""
"Skjuter upp ett slice-objekt på stacken.  *argc* måste vara 2 eller 3.  Om "
"det är 2, implementeras::"

msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end))"
msgstr ""
"slut = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, slut))"

msgid "if it is 3, implements::"
msgstr "om det är 3, implementerar::"

msgid ""
"step = STACK.pop()\n"
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end, step))"
msgstr ""
"steg = STACK.pop()\n"
"slut = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, slut, steg))"

msgid "See the :func:`slice` built-in function for more information."
msgstr "Se den inbyggda funktionen :func:`slice` för mer information."

msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""
"Prefix för alla op-koder som har ett argument som är för stort för att "
"rymmas i den standardiserade en byte. *ext* innehåller ytterligare en byte "
"som fungerar som högre bitar i argumentet. För varje opcode tillåts högst "
"tre prefixala ``EXTENDED_ARG``, som bildar ett argument från två byte till "
"fyra byte."

msgid "Convert value to a string, depending on ``oparg``::"
msgstr "Konverterar värdet till en sträng, beroende på ``oparg``::"

msgid ""
"value = STACK.pop()\n"
"result = func(value)\n"
"STACK.append(result)"
msgstr ""
"värde = STACK.pop()\n"
"resultat = func(värde)\n"
"STACK.append(resultat)"

msgid "``oparg == 1``: call :func:`str` on *value*"
msgstr "``oparg == 1``: anropa :func:`str` på *värde*"

msgid "``oparg == 2``: call :func:`repr` on *value*"
msgstr "``oparg == 2``: anropa :func:`repr` på *värde*"

msgid "``oparg == 3``: call :func:`ascii` on *value*"
msgstr "``oparg == 3``: anropa :func:`ascii` på *värde*"

msgid "Used for implementing formatted string literals (f-strings)."
msgstr "Används för att implementera formaterade stränglitteraler (f-strings)."

msgid "Formats the value on top of stack::"
msgstr "Formaterar värdet på toppen av stapeln::"

msgid ""
"value = STACK.pop()\n"
"result = value.__format__(\"\")\n"
"STACK.append(result)"
msgstr ""
"värde = STACK.pop()\n"
"resultat = värde.__format__(\"\")\n"
"STACK.append(resultat)"

msgid "Formats the given value with the given format spec::"
msgstr "Formaterar det angivna värdet med det angivna formatet spec::"

msgid ""
"spec = STACK.pop()\n"
"value = STACK.pop()\n"
"result = value.__format__(spec)\n"
"STACK.append(result)"
msgstr ""
"spec = STACK.pop()\n"
"värde = STACK.pop()\n"
"resultat = värde.__format__(spec)\n"
"STACK.append(resultat)"

msgid ""
"``STACK[-1]`` is a tuple of keyword attribute names, ``STACK[-2]`` is the "
"class being matched against, and ``STACK[-3]`` is the match subject.  "
"*count* is the number of positional sub-patterns."
msgstr ""
"``STACK[-1]`` är en tupel av nyckelordsattributnamn, ``STACK[-2]`` är den "
"klass som matchningen görs mot och ``STACK[-3]`` är matchningsobjektet.  "
"*count* är antalet positionella undermönster."

msgid ""
"Pop ``STACK[-1]``, ``STACK[-2]``, and ``STACK[-3]``. If ``STACK[-3]`` is an "
"instance of ``STACK[-2]`` and has the positional and keyword attributes "
"required by *count* and ``STACK[-1]``, push a tuple of extracted attributes. "
"Otherwise, push ``None``."
msgstr ""
"Popa ``STACK[-1]``, ``STACK[-2]`` och ``STACK[-3]``. Om ``STACK[-3]`` är en "
"instans av ``STACK[-2]`` och har de positions- och nyckelordsattribut som "
"krävs av *count* och ``STACK[-1]``, pushar du en tupel av extraherade "
"attribut. I annat fall, skicka ``None``."

msgid "A no-op. Performs internal tracing, debugging and optimization checks."
msgstr ""
"Ingen funktion. Utför interna spårnings-, felsöknings- och "
"optimeringskontroller."

msgid ""
"The ``context`` operand consists of two parts. The lowest two bits indicate "
"where the ``RESUME`` occurs:"
msgstr ""
"Operanden ``context`` består av två delar. De två lägsta bitarna anger var "
"``RESUME`` sker:"

msgid ""
"``0`` The start of a function, which is neither a generator, coroutine nor "
"an async generator"
msgstr ""
"``0`` Början på en funktion, som varken är en generator, coroutine eller en "
"async-generator"

msgid "``1`` After a ``yield`` expression"
msgstr "``1`` Efter ett ``avkastande`` uttryck"

msgid "``2`` After a ``yield from`` expression"
msgstr "``2`` Efter ett ``utbyte från`` uttryck"

msgid "``3`` After an ``await`` expression"
msgstr "``3`` Efter ett ``await`` uttryck"

msgid ""
"The next bit is ``1`` if the RESUME is at except-depth ``1``, and ``0`` "
"otherwise."
msgstr ""
"Nästa bit är ``1`` om RESUME är på except-depth ``1``, och ``0`` annars."

msgid "The oparg value changed to include information about except-depth"
msgstr "Oparg-värdet ändrades för att inkludera information om except-depth"

msgid ""
"Create a generator, coroutine, or async generator from the current frame. "
"Used as first opcode of in code object for the above mentioned callables. "
"Clear the current frame and return the newly created generator."
msgstr ""
"Skapa en generator, coroutine eller async-generator från den aktuella "
"bildrutan. Används som första opcode i in code-objektet för ovan nämnda "
"callables. Rensa den aktuella ramen och returnera den nyskapade generatorn."

msgid ""
"Equivalent to ``STACK[-1] = STACK[-2].send(STACK[-1])``. Used in ``yield "
"from`` and ``await`` statements."
msgstr ""
"Motsvarar ``STACK[-1] = STACK[-2].send(STACK[-1])``. Används i ``yield "
"from`` och ``await``-satser."

msgid ""
"If the call raises :exc:`StopIteration`, pop the top value from the stack, "
"push the exception's ``value`` attribute, and increment the bytecode counter "
"by *delta*."
msgstr ""
"Om anropet ger upphov till :exc:`StopIteration`, plockas det översta värdet "
"från stacken, undantagets ``value``-attribut skjuts upp och bytekodsräknaren "
"ökas med *delta*."

msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes in the range [0,255] which don't use their argument and those that "
"do (``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""
"Detta är egentligen inte en opcode.  Den identifierar skiljelinjen mellan "
"opkoder i intervallet [0,255] som inte använder sitt argument och de som gör "
"det (``< HAVE_ARGUMENT`` respektive ``>= HAVE_ARGUMENT``)."

msgid ""
"If your application uses pseudo instructions or specialized instructions, "
"use the :data:`hasarg` collection instead."
msgstr ""
"Om ditt program använder pseudoinstruktioner eller specialinstruktioner, "
"använd :data:`hasarg`-samlingen istället."

msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""
"Nu har varje instruktion ett argument, men opkoderna ``< HAVE_ARGUMENT`` "
"ignorerar det. Tidigare hade endast opkoderna ``>= HAVE_ARGUMENT`` ett "
"argument."

msgid ""
"Pseudo instructions were added to the :mod:`dis` module, and for them it is "
"not true that comparison with ``HAVE_ARGUMENT`` indicates whether they use "
"their arg."
msgstr ""
"Pseudoinstruktioner lades till i modulen :mod:`dis`, och för dem är det inte "
"sant att jämförelse med ``HAVE_ARGUMENT`` visar om de använder sitt arg."

msgid "Use :data:`hasarg` instead."
msgstr "Använd :data:`hasarg` istället."

msgid ""
"Calls an intrinsic function with one argument. Passes ``STACK[-1]`` as the "
"argument and sets ``STACK[-1]`` to the result. Used to implement "
"functionality that is not performance critical."
msgstr ""
"Anropar en egen funktion med ett argument. Anropar ``STACK[-1]`` som "
"argument och sätter ``STACK[-1]`` till resultatet. Används för att "
"implementera funktionalitet som inte är prestandakritisk."

msgid "The operand determines which intrinsic function is called:"
msgstr "Operanden avgör vilken egen funktion som anropas:"

msgid "Operand"
msgstr "Operand"

msgid "Description"
msgstr "Beskrivning"

msgid "``INTRINSIC_1_INVALID``"
msgstr "``INTRINSIC_1_INVALID``"

msgid "Not valid"
msgstr "Ej giltig"

msgid "``INTRINSIC_PRINT``"
msgstr "``INTRINSIC_PRINT``"

msgid "Prints the argument to standard out. Used in the REPL."
msgstr "Skriver ut argumentet till standardutskrift. Används i REPL."

msgid "``INTRINSIC_IMPORT_STAR``"
msgstr "``INTRINSIC_IMPORT_STJÄRNA``"

msgid "Performs ``import *`` for the named module."
msgstr "Utför ``import *`` för den namngivna modulen."

msgid "``INTRINSIC_STOPITERATION_ERROR``"
msgstr "``INTRINSIC_STOPITERATION_ERROR``"

msgid "Extracts the return value from a ``StopIteration`` exception."
msgstr "Extraherar returvärdet från ett ``StopIteration``-undantag."

msgid "``INTRINSIC_ASYNC_GEN_WRAP``"
msgstr "``INTRINSIC_ASYNC_GEN_WRAP``"

msgid "Wraps an async generator value"
msgstr "Omsluter ett asynkront generatorvärde"

msgid "``INTRINSIC_UNARY_POSITIVE``"
msgstr "``INTRINSIC_UNARY_POSITIVE``"

msgid "Performs the unary ``+`` operation"
msgstr "Utför den unära ``+``-operationen"

msgid "``INTRINSIC_LIST_TO_TUPLE``"
msgstr "``INTRINSIC_LIST_TO_TUPLE``"

msgid "Converts a list to a tuple"
msgstr "Konverterar en lista till en tupel"

msgid "``INTRINSIC_TYPEVAR``"
msgstr "``INTRINSIC_TYPEVAR``"

msgid "Creates a :class:`typing.TypeVar`"
msgstr "Skapar en :class:`typing.TypeVar`"

msgid "``INTRINSIC_PARAMSPEC``"
msgstr "``INTRINSIC_PARAMSPEC``"

msgid "Creates a :class:`typing.ParamSpec`"
msgstr "Skapar en :class:`typing.ParamSpec`"

msgid "``INTRINSIC_TYPEVARTUPLE``"
msgstr "``INTRINSIC_TYPEVARTUPLE``"

msgid "Creates a :class:`typing.TypeVarTuple`"
msgstr "Skapar en :class:`typing.TypeVarTuple`"

msgid "``INTRINSIC_SUBSCRIPT_GENERIC``"
msgstr "``INTRINSIC_SUBSCRIPT_GENERIC``"

msgid "Returns :class:`typing.Generic` subscripted with the argument"
msgstr "Returnerar :class:`typing.Generic` subskriberad med argumentet"

msgid "``INTRINSIC_TYPEALIAS``"
msgstr "``INTRINSIC_TYPEALIAS``"

msgid ""
"Creates a :class:`typing.TypeAliasType`; used in the :keyword:`type` "
"statement. The argument is a tuple of the type alias's name, type "
"parameters, and value."
msgstr ""
"Skapar en :class:`typing.TypeAliasType`; som används i :keyword:`type`-"
"satsen. Argumentet är en tupel av typaliasets namn, typparametrar och värde."

msgid ""
"Calls an intrinsic function with two arguments. Used to implement "
"functionality that is not performance critical::"
msgstr ""
"Anropar en inneboende funktion med två argument. Används för att "
"implementera funktionalitet som inte är prestandakritisk::"

msgid ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"result = intrinsic2(arg1, arg2)\n"
"STACK.append(result)"
msgstr ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"resultat = intrinsic2(arg1, arg2)\n"
"STACK.append(resultat)"

msgid "``INTRINSIC_2_INVALID``"
msgstr "``INTRINSIC_2_INVALID``"

msgid "``INTRINSIC_PREP_RERAISE_STAR``"
msgstr "``INTRINSIC_PREP_RERAISE_STAR``"

msgid "Calculates the :exc:`ExceptionGroup` to raise from a ``try-except*``."
msgstr ""
"Beräknar den :exc:`ExceptionGroup` som ska tas fram från ett ``try-except*``."

msgid "``INTRINSIC_TYPEVAR_WITH_BOUND``"
msgstr "``INTRINSIC_TYPEVAR_MED_BOUND``"

msgid "Creates a :class:`typing.TypeVar` with a bound."
msgstr "Skapar en :class:`typing.TypeVar` med en bound."

msgid "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"
msgstr "``INTRINSIC_TYPEVAR_MED_BEGRÄNSNINGAR``"

msgid "Creates a :class:`typing.TypeVar` with constraints."
msgstr "Skapar en :class:`typing.TypeVar` med begränsningar."

msgid "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"
msgstr "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"

msgid "Sets the ``__type_params__`` attribute of a function."
msgstr "Ställer in attributet ``__type_params__`` för en funktion."

msgid ""
"Performs special method lookup on ``STACK[-1]``. If ``type(STACK[-1])."
"__xxx__`` is a method, leave ``type(STACK[-1]).__xxx__; STACK[-1]`` on the "
"stack. If ``type(STACK[-1]).__xxx__`` is not a method, leave ``STACK[-1]."
"__xxx__; NULL`` on the stack."
msgstr ""
"Utför en speciell metoduppslagning på ``STACK[-1]``. Om ``type(STACK[-1])."
"__xxx__`` är en metod, lämna ``type(STACK[-1]).__xxx__; STACK[-1]`` på "
"stacken. Om ``type(STACK[-1]).__xxx__`` inte är en metod, lämna ``STACK[-1]."
"__xxx__; NULL`` på stacken."

msgid "**Pseudo-instructions**"
msgstr "**Pseudo-instruktioner**"

msgid ""
"These opcodes do not appear in Python bytecode. They are used by the "
"compiler but are replaced by real opcodes or removed before bytecode is "
"generated."
msgstr ""
"Dessa opkoder visas inte i Python bytecode. De används av kompilatorn men "
"ersätts av riktiga opkoder eller tas bort innan bytekoden genereras."

msgid ""
"Set up an exception handler for the following code block. If an exception "
"occurs, the value stack level is restored to its current state and control "
"is transferred to the exception handler at ``target``."
msgstr ""
"Skapa en undantagshanterare för följande kodblock. Om ett undantag inträffar "
"återställs värde-stacknivån till sitt aktuella tillstånd och kontrollen "
"överförs till undantagshanteraren i ``target``."

msgid ""
"Like ``SETUP_FINALLY``, but in case of an exception also pushes the last "
"instruction (``lasti``) to the stack so that ``RERAISE`` can restore it. If "
"an exception occurs, the value stack level and the last instruction on the "
"frame are restored to their current state, and control is transferred to the "
"exception handler at ``target``."
msgstr ""
"Som ``SETUP_FINALLY``, men i händelse av ett undantag flyttas även den sista "
"instruktionen (``lasti``) till stacken så att ``RERAISE`` kan återställa "
"den. Om ett undantag inträffar återställs värdet på stacknivån och den sista "
"instruktionen på ramen till sitt nuvarande tillstånd och kontrollen överförs "
"till undantagshanteraren på ``target``."

msgid ""
"Like ``SETUP_CLEANUP``, but in case of an exception one more item is popped "
"from the stack before control is transferred to the exception handler at "
"``target``."
msgstr ""
"Som ``SETUP_CLEANUP``, men i händelse av ett undantag poppas ytterligare ett "
"objekt från stacken innan kontrollen överförs till undantagshanteraren i "
"``target``."

msgid ""
"This variant is used in :keyword:`with` and :keyword:`async with` "
"constructs, which push the return value of the context manager's :meth:"
"`~object.__enter__` or :meth:`~object.__aenter__` to the stack."
msgstr ""
"Den här varianten används i konstruktionerna :keyword:`with` och :keyword:"
"`async with`, som flyttar returvärdet för kontexthanterarens :meth:`~object."
"__enter__` eller :meth:`~object.__aenter__` till stacken."

msgid ""
"Marks the end of the code block associated with the last ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` or ``SETUP_WITH``."
msgstr ""
"Markerar slutet på det kodblock som är associerat med den senaste "
"``SETUP_FINALLY``, ``SETUP_CLEANUP`` eller ``SETUP_WITH``."

msgid ""
"Undirected relative jump instructions which are replaced by their directed "
"(forward/backward) counterparts by the assembler."
msgstr ""
"Oriktade relativa hoppinstruktioner som ersätts av sina riktade (framåt/"
"bakåt) motsvarigheter av assemblerprogrammet."

msgid ""
"Conditional jumps which do not impact the stack. Replaced by the sequence "
"``COPY 1``, ``TO_BOOL``, ``POP_JUMP_IF_TRUE/FALSE``."
msgstr ""
"Villkorliga hopp som inte påverkar stacken. Ersätts av sekvensen ``COPY 1``, "
"``TO_BOOL``, ``POP_JUMP_IF_TRUE/FALSE``."

msgid ""
"Pushes a reference to the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""
"Skickar en referens till den cell som finns på plats ``i`` i lagret \"Fast "
"Locals\"."

msgid ""
"Note that ``LOAD_CLOSURE`` is replaced with ``LOAD_FAST`` in the assembler."
msgstr "Observera att ``LOAD_CLOSURE`` ersätts med ``LOAD_FAST`` i assemblern."

msgid "This opcode is now a pseudo-instruction."
msgstr "Denna opkod är nu en pseudo-instruktion."

msgid ""
"Optimized unbound method lookup. Emitted as a ``LOAD_ATTR`` opcode with a "
"flag set in the arg."
msgstr ""
"Optimerad uppslagning av obunden metod. Utfärdas som en ``LOAD_ATTR`` opcode "
"med en flagga inställd i arg."

msgid "Opcode collections"
msgstr "Opcode-samlingar"

msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr ""
"Dessa samlingar tillhandahålls för automatisk introspektion av bytecode-"
"instruktioner:"

msgid ""
"The collections now contain pseudo instructions and instrumented "
"instructions as well. These are opcodes with values ``>= MIN_PSEUDO_OPCODE`` "
"and ``>= MIN_INSTRUMENTED_OPCODE``."
msgstr ""
"Samlingarna innehåller nu även pseudoinstruktioner och instrumenterade "
"instruktioner. Dessa är opkoder med värdena ``>= MIN_PSEUDO_OPCODE`` och "
"``>= MIN_INSTRUMENTED_OPCODE``."

msgid "Sequence of operation names, indexable using the bytecode."
msgstr "Sekvens av operationsnamn, indexerbara med hjälp av bytekoden."

msgid "Dictionary mapping operation names to bytecodes."
msgstr "Ordbok som mappar operationsnamn till bytecodes."

msgid "Sequence of all compare operation names."
msgstr "Sekvens av alla namn på jämförelseoperationer."

msgid "Sequence of bytecodes that use their argument."
msgstr "Sekvens av bytecodes som använder argumentet."

msgid "Sequence of bytecodes that access a constant."
msgstr "Sekvens av bytekoder som har tillgång till en konstant."

msgid ""
"Sequence of bytecodes that access a :term:`free (closure) variable <closure "
"variable>`. 'free' in this context refers to names in the current scope that "
"are referenced by inner scopes or names in outer scopes that are referenced "
"from this scope.  It does *not* include references to global or builtin "
"scopes."
msgstr ""
"Sekvens av bytekoder som har tillgång till en :term:`free (closure) variabel "
"<closure variable>`. \"free\" i detta sammanhang avser namn i det aktuella "
"omfånget som refereras av inre omfång eller namn i yttre omfång som "
"refereras från detta omfång.  Det inkluderar *inte* referenser till globala "
"eller inbyggda scope."

msgid "Sequence of bytecodes that access an attribute by name."
msgstr "Sekvens av bytecodes som öppnar ett attribut med namn."

msgid "Sequence of bytecodes that have a jump target. All jumps are relative."
msgstr "Sekvens av bytecodes som har ett hoppmål. Alla hopp är relativa."

msgid "Sequence of bytecodes that access a local variable."
msgstr "Sekvens av bytekoder som har åtkomst till en lokal variabel."

msgid "Sequence of bytecodes of Boolean operations."
msgstr "Sekvens av bytecodes för booleska operationer."

msgid "Sequence of bytecodes that set an exception handler."
msgstr "Sekvens av bytecodes som anger en undantagshanterare."

msgid "Sequence of bytecodes that have a relative jump target."
msgstr "Sekvens av bytecodes som har ett relativt hoppmål."

msgid "All jumps are now relative. Use :data:`hasjump`."
msgstr "Alla hopp är nu relativa. Använd :data:`hasjump`."

msgid "Sequence of bytecodes that have an absolute jump target."
msgstr "Sekvens av bytecodes som har ett absolut hoppmål."

msgid "All jumps are now relative. This list is empty."
msgstr "Alla hopp är nu relativa. Denna lista är tom."

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "slice"
msgstr "skiva"
