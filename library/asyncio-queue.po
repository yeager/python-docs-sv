# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Queues"
msgstr "Köer"

msgid "**Source code:** :source:`Lib/asyncio/queues.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/queues.py`"

msgid ""
"asyncio queues are designed to be similar to classes of the :mod:`queue` "
"module.  Although asyncio queues are not thread-safe, they are designed to "
"be used specifically in async/await code."
msgstr ""
"asyncio-köer är utformade för att likna klasser i modulen :mod:`queue`.  "
"Även om asyncio-köer inte är trådsäkra är de utformade för att användas "
"specifikt i async/await-kod."

msgid ""
"Note that methods of asyncio queues don't have a *timeout* parameter; use :"
"func:`asyncio.wait_for` function to do queue operations with a timeout."
msgstr ""
"Observera att metoder för asyncioköer inte har en *timeout*-parameter; "
"använd :func:`asyncio.wait_for`-funktionen för att göra köoperationer med en "
"timeout."

msgid "See also the `Examples`_ section below."
msgstr "Se även avsnittet `Exempel` nedan."

msgid "Queue"
msgstr "Kö"

msgid "A first in, first out (FIFO) queue."
msgstr "En FIFO-kö (först in, först ut)."

msgid ""
"If *maxsize* is less than or equal to zero, the queue size is infinite.  If "
"it is an integer greater than ``0``, then ``await put()`` blocks when the "
"queue reaches *maxsize* until an item is removed by :meth:`get`."
msgstr ""
"Om *maxsize* är mindre än eller lika med noll är köns storlek oändlig.  Om "
"det är ett heltal större än ``0``, blockerar ``await put()`` när kön når "
"*maxsize* tills ett objekt tas bort med :meth:`get`."

msgid ""
"Unlike the standard library threading :mod:`queue`, the size of the queue is "
"always known and can be returned by calling the :meth:`qsize` method."
msgstr ""
"Till skillnad från standardbibliotekets trådning :mod:`queue` är storleken "
"på kön alltid känd och kan returneras genom att anropa metoden :meth:`qsize`."

msgid "Removed the *loop* parameter."
msgstr "Parametern *loop* har tagits bort."

msgid "This class is :ref:`not thread safe <asyncio-multithreading>`."
msgstr "Den här klassen är :ref:`inte trådsäker <asyncio-multithreading>`."

msgid "Number of items allowed in the queue."
msgstr "Antal objekt som tillåts i kön."

msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Returnerar ``True`` om kön är tom, annars ``False``."

msgid "Return ``True`` if there are :attr:`maxsize` items in the queue."
msgstr "Returnerar ``True`` om det finns :attr:`maxsize` objekt i kön."

msgid ""
"If the queue was initialized with ``maxsize=0`` (the default), then :meth:"
"`full` never returns ``True``."
msgstr ""
"Om kön initialiserades med ``maxsize=0`` (standard) returnerar :meth:`full` "
"aldrig ``True``."

msgid ""
"Remove and return an item from the queue. If queue is empty, wait until an "
"item is available."
msgstr ""
"Ta bort och returnera ett objekt från kön. Om kön är tom, vänta tills ett "
"objekt är tillgängligt."

msgid ""
"Raises :exc:`QueueShutDown` if the queue has been shut down and is empty, or "
"if the queue has been shut down immediately."
msgstr ""
"Utlöser :exc:`QueueShutDown` om kön har stängts av och är tom, eller om kön "
"har stängts av omedelbart."

msgid ""
"Return an item if one is immediately available, else raise :exc:`QueueEmpty`."
msgstr ""
"Returnera ett objekt om det finns ett omedelbart tillgängligt, annars "
"uppstår :exc:`QueueEmpty`."

msgid "Block until all items in the queue have been received and processed."
msgstr "Blockera tills alla artiklar i kön har tagits emot och behandlats."

msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer coroutine calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"Antalet oavslutade uppgifter ökar varje gång ett objekt läggs till i kön. "
"Antalet sjunker när en consumer coroutine anropar :meth:`task_done` för att "
"ange att objektet har hämtats och att allt arbete med det är slutfört.  När "
"antalet oavslutade uppgifter sjunker till noll avblockeras :meth:`join`."

msgid ""
"Put an item into the queue. If the queue is full, wait until a free slot is "
"available before adding the item."
msgstr ""
"Lägg till ett objekt i kön. Om kön är full väntar du tills en ledig plats "
"finns tillgänglig innan du lägger till objektet."

msgid "Raises :exc:`QueueShutDown` if the queue has been shut down."
msgstr "Utlöser :exc:`QueueShutDown` om kön har stängts av."

msgid "Put an item into the queue without blocking."
msgstr "Lägg in ett objekt i kön utan att blockera."

msgid "If no free slot is immediately available, raise :exc:`QueueFull`."
msgstr ""
"Om ingen ledig plats finns omedelbart tillgänglig, uppstår :exc:`QueueFull`."

msgid "Return the number of items in the queue."
msgstr "Returnerar antalet objekt i kön."

msgid ""
"Shut down the queue, making :meth:`~Queue.get` and :meth:`~Queue.put` raise :"
"exc:`QueueShutDown`."
msgstr ""
"Stänger av kön, vilket gör att :meth:`~Queue.get` och :meth:`~Queue.put` ger "
"upphov till :exc:`QueueShutDown`."

msgid ""
"By default, :meth:`~Queue.get` on a shut down queue will only raise once the "
"queue is empty. Set *immediate* to true to make :meth:`~Queue.get` raise "
"immediately instead."
msgstr ""
"Som standard kommer :meth:`~Queue.get` på en avstängd kö inte att aktiveras "
"förrän kön är tom. Sätt *immediate* till true för att få :meth:`~Queue.get` "
"att starta omedelbart istället."

msgid ""
"All blocked callers of :meth:`~Queue.put` and :meth:`~Queue.get` will be "
"unblocked. If *immediate* is true, a task will be marked as done for each "
"remaining item in the queue, which may unblock callers of :meth:`~Queue."
"join`."
msgstr ""
"Alla blockerade anropare av :meth:`~Queue.put` och :meth:`~Queue.get` kommer "
"att avblockeras. Om *immediate* är true, kommer en uppgift att markeras som "
"utförd för varje återstående objekt i kön, vilket kan avblockera anropare "
"av :meth:`~Queue.join`."

msgid "Indicate that a formerly enqueued work item is complete."
msgstr "Anger att ett arbetsobjekt som tidigare var i kö är klart."

msgid ""
"Used by queue consumers. For each :meth:`~Queue.get` used to fetch a work "
"item, a subsequent call to :meth:`task_done` tells the queue that the "
"processing on the work item is complete."
msgstr ""
"Används av köanvändare. För varje :meth:`~Queue.get` som används för att "
"hämta ett arbetsobjekt, talar ett efterföljande anrop till :meth:`task_done` "
"om för kön att bearbetningen av arbetsobjektet är klar."

msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Om en :meth:`join` för närvarande blockeras, kommer den att återupptas när "
"alla objekt har bearbetats (vilket innebär att ett :meth:`task_done`-anrop "
"mottogs för varje objekt som hade :meth:`~Queue.put` i kön)."

msgid ""
"``shutdown(immediate=True)`` calls :meth:`task_done` for each remaining item "
"in the queue."
msgstr ""
"``shutdown(immediate=True)`` anropar :meth:`task_done` för varje återstående "
"objekt i kön."

msgid ""
"Raises :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Utlöser :exc:`ValueError` om den anropas fler gånger än det finns objekt i "
"kön."

msgid "Priority Queue"
msgstr "Prioriterad kö"

msgid ""
"A variant of :class:`Queue`; retrieves entries in priority order (lowest "
"first)."
msgstr ""
"En variant av :class:`Queue`; hämtar poster i prioritetsordning (lägst "
"först)."

msgid "Entries are typically tuples of the form ``(priority_number, data)``."
msgstr "Posterna är vanligtvis tupler av formen ``(priority_number, data)``."

msgid "LIFO Queue"
msgstr "LIFO-kö"

msgid ""
"A variant of :class:`Queue` that retrieves most recently added entries first "
"(last in, first out)."
msgstr ""
"En variant av :class:`Queue` som hämtar de senast tillagda posterna först "
"(sist in, först ut)."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"This exception is raised when the :meth:`~Queue.get_nowait` method is called "
"on an empty queue."
msgstr ""
"Detta undantag uppstår när metoden :meth:`~Queue.get_nowait` anropas på en "
"tom kö."

msgid ""
"Exception raised when the :meth:`~Queue.put_nowait` method is called on a "
"queue that has reached its *maxsize*."
msgstr ""
"Exception som uppstår när metoden :meth:`~Queue.put_nowait` anropas på en kö "
"som har nått sin *maxsize*."

msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a queue which has been shut down."
msgstr ""
"Exception som uppstår när :meth:`~Queue.put` eller :meth:`~Queue.get` "
"anropas på en kö som har stängts ner."

msgid "Examples"
msgstr "Exempel"

msgid ""
"Queues can be used to distribute workload between several concurrent tasks::"
msgstr ""
"Köer kan användas för att fördela arbetsbelastningen mellan flera samtidiga "
"uppgifter::"

msgid ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # Get a \"work item\" out of the queue.\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # Sleep for the \"sleep_for\" seconds.\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # Notify the queue that the \"work item\" has been processed.\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # Create a queue that we will use to store our \"workload\".\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # Generate random timings and put them into the queue.\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # Create three worker tasks to process the queue concurrently.\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # Wait until the queue is fully processed.\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # Cancel our worker tasks.\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # Wait until all worker tasks are cancelled.\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import random\n"
"import time\n"
"\n"
"\n"
"async def worker(name, queue):\n"
"    while True:\n"
"        # Get a \"work item\" out of the queue.\n"
"        sleep_for = await queue.get()\n"
"\n"
"        # Sleep for the \"sleep_for\" seconds.\n"
"        await asyncio.sleep(sleep_for)\n"
"\n"
"        # Notify the queue that the \"work item\" has been processed.\n"
"        queue.task_done()\n"
"\n"
"        print(f'{name} has slept for {sleep_for:.2f} seconds')\n"
"\n"
"\n"
"async def main():\n"
"    # Create a queue that we will use to store our \"workload\".\n"
"    queue = asyncio.Queue()\n"
"\n"
"    # Generate random timings and put them into the queue.\n"
"    total_sleep_time = 0\n"
"    for _ in range(20):\n"
"        sleep_for = random.uniform(0.05, 1.0)\n"
"        total_sleep_time += sleep_for\n"
"        queue.put_nowait(sleep_for)\n"
"\n"
"    # Create three worker tasks to process the queue concurrently.\n"
"    tasks = []\n"
"    for i in range(3):\n"
"        task = asyncio.create_task(worker(f'worker-{i}', queue))\n"
"        tasks.append(task)\n"
"\n"
"    # Wait until the queue is fully processed.\n"
"    started_at = time.monotonic()\n"
"    await queue.join()\n"
"    total_slept_for = time.monotonic() - started_at\n"
"\n"
"    # Cancel our worker tasks.\n"
"    for task in tasks:\n"
"        task.cancel()\n"
"    # Wait until all worker tasks are cancelled.\n"
"    await asyncio.gather(*tasks, return_exceptions=True)\n"
"\n"
"    print('====')\n"
"    print(f'3 workers slept in parallel for {total_slept_for:.2f} seconds')\n"
"    print(f'total expected sleep time: {total_sleep_time:.2f} seconds')\n"
"\n"
"\n"
"asyncio.run(main())"
