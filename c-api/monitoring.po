# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Monitoring C API"
msgstr "Övervakning av C API"

msgid "Added in version 3.13."
msgstr "Tillagd i version 3.13."

msgid ""
"An extension may need to interact with the event monitoring system. "
"Subscribing to events and registering callbacks can be done via the Python "
"API exposed in :mod:`sys.monitoring`."
msgstr ""
"Ett tillägg kan behöva interagera med händelseövervakningssystemet. "
"Prenumeration på händelser och registrering av callbacks kan göras via "
"Python API som exponeras i :mod:`sys.monitoring`."

msgid "Generating Execution Events"
msgstr "Generering av exekveringshändelser"

msgid ""
"The functions below make it possible for an extension to fire monitoring "
"events as it emulates the execution of Python code. Each of these functions "
"accepts a ``PyMonitoringState`` struct which contains concise information "
"about the activation state of events, as well as the event arguments, which "
"include a ``PyObject*`` representing the code object, the instruction offset "
"and sometimes additional, event-specific arguments (see :mod:`sys."
"monitoring` for details about the signatures of the different event "
"callbacks). The ``codelike`` argument should be an instance of :class:`types."
"CodeType` or of a type that emulates it."
msgstr ""
"Funktionerna nedan gör det möjligt för ett tillägg att avfyra "
"övervakningshändelser när det emulerar exekveringen av Python-kod. Var och "
"en av dessa funktioner accepterar en ``PyMonitoringState``-struktur som "
"innehåller kortfattad information om aktiveringstillståndet för händelser, "
"samt händelseargumenten, som inkluderar ett ``PyObject*`` som representerar "
"kodobjektet, instruktionsoffset och ibland ytterligare händelsespecifika "
"argument (se :mod:`sys.monitoring`` för detaljer om signaturerna för de "
"olika händelseanropen). Argumentet ``codelike`` bör vara en instans av :"
"class:`types.CodeType` eller av en typ som emulerar den."

msgid ""
"The VM disables tracing when firing an event, so there is no need for user "
"code to do that."
msgstr ""
"VM inaktiverar spårning när en händelse utlöses, så det finns inget behov av "
"användarkod för att göra det."

msgid ""
"Monitoring functions should not be called with an exception set, except "
"those listed below as working with the current exception."
msgstr ""
"Övervakningsfunktioner ska inte anropas med ett undantag inställt, förutom "
"de som listas nedan som arbetar med det aktuella undantaget."

msgid ""
"Representation of the state of an event type. It is allocated by the user "
"while its contents are maintained by the monitoring API functions described "
"below."
msgstr ""
"Representation av tillståndet för en händelsetyp. Den allokeras av "
"användaren medan dess innehåll underhålls av API-funktionerna för "
"övervakning som beskrivs nedan."

msgid ""
"All of the functions below return 0 on success and -1 (with an exception "
"set) on error."
msgstr ""
"Alla funktioner nedan returnerar 0 vid framgång och -1 (med en "
"undantagsinställning) vid fel."

msgid "See :mod:`sys.monitoring` for descriptions of the events."
msgstr "Se :mod:`sys.monitoring` för beskrivningar av händelserna."

msgid "Fire a ``PY_START`` event."
msgstr "Starta en ``PY_START``-händelse."

msgid "Fire a ``PY_RESUME`` event."
msgstr "Startar en ``PY_RESUME``-händelse."

msgid "Fire a ``PY_RETURN`` event."
msgstr "Utlösa en ``PY_RETURN``-händelse."

msgid "Fire a ``PY_YIELD`` event."
msgstr "Starta en ``PY_YIELD``-händelse."

msgid "Fire a ``CALL`` event."
msgstr "Starta en händelse av typen ``CALL``."

msgid "Fire a ``LINE`` event."
msgstr "Utlösa en ``LINE``-händelse."

msgid "Fire a ``JUMP`` event."
msgstr "Startar en ``JUMP``-händelse."

msgid "Fire a ``BRANCH_LEFT`` event."
msgstr "Startar en händelse av typen ``BRANCH_LEFT``."

msgid "Fire a ``BRANCH_RIGHT`` event."
msgstr "Startar en händelse av typen ``BRANCH_RIGHT``."

msgid "Fire a ``C_RETURN`` event."
msgstr "Utlösa en ``C_RETURN``-händelse."

msgid ""
"Fire a ``PY_THROW`` event with the current exception (as returned by :c:func:"
"`PyErr_GetRaisedException`)."
msgstr ""
"Startar en ``PY_THROW`` händelse med det aktuella undantaget (som returneras "
"av :c:func:`PyErr_GetRaisedException`)."

msgid ""
"Fire a ``RAISE`` event with the current exception (as returned by :c:func:"
"`PyErr_GetRaisedException`)."
msgstr ""
"Startar en ``RAISE``-händelse med det aktuella undantaget (som returneras "
"av :c:func:`PyErr_GetRaisedException`)."

msgid ""
"Fire a ``C_RAISE`` event with the current exception (as returned by :c:func:"
"`PyErr_GetRaisedException`)."
msgstr ""
"Startar en ``C_RAISE``-händelse med det aktuella undantaget (som returneras "
"av :c:func:`PyErr_GetRaisedException`)."

msgid ""
"Fire a ``RERAISE`` event with the current exception (as returned by :c:func:"
"`PyErr_GetRaisedException`)."
msgstr ""
"Startar en ``RERAISE``-händelse med det aktuella undantaget (som returneras "
"av :c:func:`PyErr_GetRaisedException`)."

msgid ""
"Fire an ``EXCEPTION_HANDLED`` event with the current exception (as returned "
"by :c:func:`PyErr_GetRaisedException`)."
msgstr ""
"Startar en ``EXCEPTION_HANDLED``-händelse med det aktuella undantaget (som "
"returneras av :c:func:`PyErr_GetRaisedException`)."

msgid ""
"Fire a ``PY_UNWIND`` event with the current exception (as returned by :c:"
"func:`PyErr_GetRaisedException`)."
msgstr ""
"Startar en ``PY_UNWIND``-händelse med det aktuella undantaget (som "
"returneras av :c:func:`PyErr_GetRaisedException`)."

msgid ""
"Fire a ``STOP_ITERATION`` event. If ``value`` is an instance of :exc:"
"`StopIteration`, it is used. Otherwise, a new :exc:`StopIteration` instance "
"is created with ``value`` as its argument."
msgstr ""
"Utlöser en ``STOP_ITERATION``-händelse. Om ``value`` är en instans av :exc:"
"`StopIteration`, så används den. Annars skapas en ny :exc:`StopIteration`-"
"instans med ``value`` som argument."

msgid "Managing the Monitoring State"
msgstr "Hantering av övervakningstillståndet"

msgid ""
"Monitoring states can be managed with the help of monitoring scopes. A scope "
"would typically correspond to a python function."
msgstr ""
"Övervakningstillstånd kan hanteras med hjälp av övervakningsscope. Ett scope "
"motsvarar vanligtvis en pythonfunktion."

msgid ""
"Enter a monitored scope. ``event_types`` is an array of the event IDs for "
"events that may be fired from the scope. For example, the ID of a "
"``PY_START`` event is the value ``PY_MONITORING_EVENT_PY_START``, which is "
"numerically equal to the base-2 logarithm of ``sys.monitoring.events."
"PY_START``. ``state_array`` is an array with a monitoring state entry for "
"each event in ``event_types``, it is allocated by the user but populated by :"
"c:func:`!PyMonitoring_EnterScope` with information about the activation "
"state of the event. The size of ``event_types`` (and hence also of "
"``state_array``) is given in ``length``."
msgstr ""
"Ange ett övervakat scope. ``event_types`` är en array med händelse-ID:n för "
"händelser som kan avfyras från scopet. ID:t för en händelse av typen "
"``PY_START`` är till exempel värdet ``PY_MONITORING_EVENT_PY_START``, som är "
"numeriskt lika med bas-2-logaritmen för ``sys.monitoring.events.PY_START``. "
"``state_array`` är en array med en övervakningstillståndspost för varje "
"händelse i ``event_types``, den allokeras av användaren men fylls på av :c:"
"func:`!PyMonitoring_EnterScope` med information om händelsens "
"aktiveringstillstånd. Storleken på ``event_types`` (och därmed också på "
"``state_array``) anges i ``length``."

msgid ""
"The ``version`` argument is a pointer to a value which should be allocated "
"by the user together with ``state_array`` and initialized to 0, and then set "
"only by :c:func:`!PyMonitoring_EnterScope` itself. It allows this function "
"to determine whether event states have changed since the previous call, and "
"to return quickly if they have not."
msgstr ""
"Argumentet ``version`` är en pekare till ett värde som bör allokeras av "
"användaren tillsammans med ``state_array`` och initialiseras till 0, och "
"sedan endast sättas av :c:func:`!PyMonitoring_EnterScope` själv. Det gör det "
"möjligt för denna funktion att avgöra om händelsetillstånd har ändrats sedan "
"föregående anrop och att snabbt återvända om så inte är fallet."

msgid ""
"The scopes referred to here are lexical scopes: a function, class or "
"method. :c:func:`!PyMonitoring_EnterScope` should be called whenever the "
"lexical scope is entered. Scopes can be reentered, reusing the same "
"*state_array* and *version*, in situations like when emulating a recursive "
"Python function. When a code-like's execution is paused, such as when "
"emulating a generator, the scope needs to be exited and re-entered."
msgstr ""
"De scope som avses här är lexikala scope: en funktion, klass eller metod. :c:"
"func:`!PyMonitoring_EnterScope` bör anropas varje gång det lexikala scopet "
"skrivs in. Scopes kan skrivas in på nytt, med samma *state_array* och "
"*version*, i situationer som när man emulerar en rekursiv Python-funktion. "
"När en kodliknande exekvering pausas, t.ex. vid emulering av en generator, "
"måste scopet lämnas och återinmatas."

msgid "The macros for *event_types* are:"
msgstr "Makron för *event_types* är:"

msgid "Macro"
msgstr "Makro"

msgid "Event"
msgstr "Händelse"

msgid ":monitoring-event:`BRANCH_LEFT`"
msgstr ":monitoring-event:`BRANCH_LEFT`"

msgid ":monitoring-event:`BRANCH_RIGHT`"
msgstr ":monitoring-event:`BRANCH_RIGHT`"

msgid ":monitoring-event:`CALL`"
msgstr ":monitoring-event:`CALL`"

msgid ":monitoring-event:`C_RAISE`"
msgstr ":monitoring-event:`C_RAISE`"

msgid ":monitoring-event:`C_RETURN`"
msgstr ":monitoring-event:`C_RETURN`"

msgid ":monitoring-event:`EXCEPTION_HANDLED`"
msgstr ":monitoring-event:`EXCEPTION_HANDLED`"

msgid ":monitoring-event:`INSTRUCTION`"
msgstr ":monitoring-event:`INSTRUCTION`"

msgid ":monitoring-event:`JUMP`"
msgstr ":monitoring-event:`JUMP`"

msgid ":monitoring-event:`LINE`"
msgstr ":monitoring-event:`LINE`"

msgid ":monitoring-event:`PY_RESUME`"
msgstr ":monitoring-event:`PY_RESUME`"

msgid ":monitoring-event:`PY_RETURN`"
msgstr ":monitoring-event:`PY_RETURN`"

msgid ":monitoring-event:`PY_START`"
msgstr ":monitoring-event:`PY_START`"

msgid ":monitoring-event:`PY_THROW`"
msgstr ":monitoring-event:`PY_THROW`"

msgid ":monitoring-event:`PY_UNWIND`"
msgstr ":monitoring-event:`PY_UNWIND`"

msgid ":monitoring-event:`PY_YIELD`"
msgstr ":monitoring-event:`PY_YIELD`"

msgid ":monitoring-event:`RAISE`"
msgstr ":monitoring-event:`RAISE`"

msgid ":monitoring-event:`RERAISE`"
msgstr ":monitoring-event:`RERAISE`"

msgid ":monitoring-event:`STOP_ITERATION`"
msgstr ":monitoring-event:`STOP_ITERATION`"

msgid ""
"Exit the last scope that was entered with :c:func:`!PyMonitoring_EnterScope`."
msgstr ""
"Avsluta det senaste området som angavs med :c:func:`!"
"PyMonitoring_EnterScope`."

msgid ""
"Return true if the event corresponding to the event ID *ev* is a :ref:`local "
"event <monitoring-event-local>`."
msgstr ""
"Returnerar true om händelsen som motsvarar händelse-ID:t *ev* är en :ref:"
"`lokal händelse <monitoring-event-local>`."

msgid "This function is :term:`soft deprecated`."
msgstr "Denna funktion är :term:`soft deprecated`."
