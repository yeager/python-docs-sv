# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Argparse Tutorial"
msgstr "Handledning för argparse"

msgid "author"
msgstr "författare"

msgid "Tshepang Mbambo"
msgstr "Tshepang Mbambo"

msgid ""
"This tutorial is intended to be a gentle introduction to :mod:`argparse`, "
"the recommended command-line parsing module in the Python standard library."
msgstr ""
"Denna handledning är avsedd att vara en mild introduktion till :mod:"
"`argparse`, den rekommenderade modulen för kommandoradsanalys i Pythons "
"standardbibliotek."

msgid ""
"The standard library includes two other libraries directly related to "
"command-line parameter processing: the lower level :mod:`optparse` module "
"(which may require more code to configure for a given application, but also "
"allows an application to request behaviors that ``argparse`` doesn't "
"support), and the very low level :mod:`getopt` (which specifically serves as "
"an equivalent to the :c:func:`!getopt` family of functions available to C "
"programmers). While neither of those modules is covered directly in this "
"guide, many of the core concepts in ``argparse`` first originated in "
"``optparse``, so some aspects of this tutorial will also be relevant to "
"``optparse`` users."
msgstr ""
"Standardbiblioteket innehåller två andra bibliotek som är direkt relaterade "
"till bearbetning av kommandoradsparametrar: modulen :mod:`optparse` på lägre "
"nivå (som kan kräva mer kod för att konfigureras för en viss applikation, "
"men som också gör det möjligt för en applikation att begära beteenden som "
"``argparse`` inte stöder) och modulen :mod:`getopt` på mycket låg nivå (som "
"specifikt fungerar som en motsvarighet till :c:func:`!getopt`-familjen av "
"funktioner som är tillgängliga för C-programmerare). Även om ingen av dessa "
"moduler behandlas direkt i den här guiden, har många av kärnkoncepten i "
"``argparse`` sitt ursprung i ``optparse``, så vissa aspekter av denna "
"handledning kommer också att vara relevanta för ``optparse``-användare."

msgid "Concepts"
msgstr "Koncept"

msgid ""
"Let's show the sort of functionality that we are going to explore in this "
"introductory tutorial by making use of the :command:`ls` command:"
msgstr ""
"Låt oss visa den typ av funktionalitet som vi kommer att utforska i denna "
"inledande handledning genom att använda kommandot :command:`ls`:"

msgid ""
"$ ls\n"
"cpython  devguide  prog.py  pypy  rm-unused-function.patch\n"
"$ ls pypy\n"
"ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...\n"
"$ ls -l\n"
"total 20\n"
"drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython\n"
"drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide\n"
"-rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py\n"
"drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy\n"
"-rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch\n"
"$ ls --help\n"
"Usage: ls [OPTION]... [FILE]...\n"
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
"..."
msgstr ""
"$ ls\n"
"cpython devguide prog.py pypy rm-unused-function.patch\n"
"$ ls pypy\n"
"ctypes_configure demo dotviewer include lib_pypy lib-python ...\n"
"$ ls -l\n"
"totalt 20\n"
"drwxr-xr-x 19 wena wena 4096 feb 18 18:51 cpython\n"
"drwxr-xr-x 4 wena wena 4096 8 feb 12:04 devguide\n"
"-rwxr-xr-x 1 wena wena 535 19 februari 00:05 prog.py\n"
"drwxr-xr-x 14 wena wena 4096 feb 7 00:59 pypy\n"
"-rw-r--r-- 1 wena wena 741 feb 18 01:01 rm-unused-function.patch\n"
"$ ls --hjälp\n"
"Användning: ls [OPTION]... [FIL]...\n"
"Visar information om FILEs (den aktuella katalogen som standard).\n"
"Sorterar posterna i alfabetisk ordning om varken -cftuvSUX eller --sort har "
"angetts.\n"
"..."

msgid "A few concepts we can learn from the four commands:"
msgstr "Några begrepp som vi kan lära oss av de fyra kommandona:"

msgid ""
"The :command:`ls` command is useful when run without any options at all. It "
"defaults to displaying the contents of the current directory."
msgstr ""
"Kommandot :command:`ls` är användbart när det körs utan några alternativ "
"alls. Standardinställningen är att visa innehållet i den aktuella katalogen."

msgid ""
"If we want beyond what it provides by default, we tell it a bit more. In "
"this case, we want it to display a different directory, ``pypy``. What we "
"did is specify what is known as a positional argument. It's named so because "
"the program should know what to do with the value, solely based on where it "
"appears on the command line. This concept is more relevant to a command "
"like :command:`cp`, whose most basic usage is ``cp SRC DEST``. The first "
"position is *what you want copied,* and the second position is *where you "
"want it copied to*."
msgstr ""
"Om vi vill ha mer än vad den tillhandahåller som standard, berättar vi lite "
"mer för den. I det här fallet vill vi att den ska visa en annan katalog, "
"``pypy``. Vad vi gjorde var att ange vad som kallas ett positionellt "
"argument. Det kallas så eftersom programmet ska veta vad det ska göra med "
"värdet, enbart baserat på var det visas på kommandoraden. Det här konceptet "
"är mer relevant för ett kommando som :command:`cp`, vars mest grundläggande "
"användning är ``cp SRC DEST``. Den första positionen är *det du vill "
"kopiera* och den andra positionen är *där du vill att det ska kopieras till*."

msgid ""
"Now, say we want to change behaviour of the program. In our example, we "
"display more info for each file instead of just showing the file names. The "
"``-l`` in that case is known as an optional argument."
msgstr ""
"Låt oss nu säga att vi vill ändra programmets beteende. I vårt exempel visar "
"vi mer information för varje fil i stället för att bara visa filnamnen. I "
"det fallet kallas ``-l`` för ett valfritt argument."

msgid ""
"That's a snippet of the help text. It's very useful in that you can come "
"across a program you have never used before, and can figure out how it works "
"simply by reading its help text."
msgstr ""
"Det är ett utdrag ur hjälptexten. Det är mycket användbart eftersom du kan "
"stöta på ett program som du aldrig har använt tidigare och kan ta reda på "
"hur det fungerar genom att läsa dess hjälptext."

msgid "The basics"
msgstr "Grunderna"

msgid "Let us start with a very simple example which does (almost) nothing::"
msgstr ""
"Låt oss börja med ett mycket enkelt exempel som gör (nästan) ingenting::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.parse_args()"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.parse_args()"

msgid "Following is a result of running the code:"
msgstr "Följande är ett resultat av att köra koden:"

msgid ""
"$ python prog.py\n"
"$ python prog.py --help\n"
"usage: prog.py [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"$ python prog.py --verbose\n"
"usage: prog.py [-h]\n"
"prog.py: error: unrecognized arguments: --verbose\n"
"$ python prog.py foo\n"
"usage: prog.py [-h]\n"
"prog.py: error: unrecognized arguments: foo"
msgstr ""
"$ python prog.py\n"
"$ python prog.py --hjälp\n"
"användning: prog.py [-h]\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"$ python prog.py --verbose\n"
"användning: prog.py [-h]\n"
"prog.py: fel: oigenkända argument: --verbose\n"
"$ python prog.py foo\n"
"användning: prog.py [-h]\n"
"prog.py: fel: oigenkända argument: foo"

msgid "Here is what is happening:"
msgstr "Det här är vad som händer:"

msgid ""
"Running the script without any options results in nothing displayed to "
"stdout. Not so useful."
msgstr ""
"Om du kör skriptet utan några alternativ visas ingenting i utdatan. Inte så "
"användbart."

msgid ""
"The second one starts to display the usefulness of the :mod:`argparse` "
"module. We have done almost nothing, but already we get a nice help message."
msgstr ""
"Den andra börjar visa hur användbar modulen :mod:`argparse` är. Vi har "
"nästan inte gjort någonting, men redan nu får vi ett trevligt "
"hjälpmeddelande."

msgid ""
"The ``--help`` option, which can also be shortened to ``-h``, is the only "
"option we get for free (i.e. no need to specify it). Specifying anything "
"else results in an error. But even then, we do get a useful usage message, "
"also for free."
msgstr ""
"Alternativet ``--help``, som också kan förkortas till ``-h``, är det enda "
"alternativ vi får gratis (dvs. vi behöver inte ange det). Om man anger något "
"annat resulterar det i ett fel. Men även då får vi ett användbart "
"användningsmeddelande, också det gratis."

msgid "Introducing Positional arguments"
msgstr "Introduktion till positionella argument"

msgid "An example::"
msgstr "Ett exempel::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"

msgid "And running the code:"
msgstr "Och kör koden:"

msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] echo\n"
"prog.py: error: the following arguments are required: echo\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] echo\n"
"\n"
"positional arguments:\n"
"  echo\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"$ python prog.py foo\n"
"foo"
msgstr ""
"$ python prog.py\n"
"användning: prog.py [-h] echo\n"
"prog.py: fel: följande argument krävs: echo\n"
"$ python prog.py --hjälp\n"
"användning: prog.py [-h] echo\n"
"\n"
"positionella argument:\n"
"  echo\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"$ python prog.py foo\n"
"foo"

msgid "Here is what's happening:"
msgstr "Det här är vad som händer:"

msgid ""
"We've added the :meth:`~ArgumentParser.add_argument` method, which is what "
"we use to specify which command-line options the program is willing to "
"accept. In this case, I've named it ``echo`` so that it's in line with its "
"function."
msgstr ""
"Vi har lagt till metoden :meth:`~ArgumentParser.add_argument`, som vi "
"använder för att ange vilka kommandoradsalternativ som programmet är villigt "
"att acceptera. I det här fallet har jag döpt den till ``echo`` så att den är "
"i linje med sin funktion."

msgid "Calling our program now requires us to specify an option."
msgstr "För att anropa vårt program måste vi nu ange ett alternativ."

msgid ""
"The :meth:`~ArgumentParser.parse_args` method actually returns some data "
"from the options specified, in this case, ``echo``."
msgstr ""
"Metoden :meth:`~ArgumentParser.parse_args` returnerar faktiskt data från de "
"angivna alternativen, i det här fallet ``echo``."

msgid ""
"The variable is some form of 'magic' that :mod:`argparse` performs for free "
"(i.e. no need to specify which variable that value is stored in). You will "
"also notice that its name matches the string argument given to the method, "
"``echo``."
msgstr ""
"Variabeln är någon form av \"magi\" som :mod:`argparse` utför gratis (dvs. "
"du behöver inte ange vilken variabel värdet lagras i). Du kommer också att "
"märka att dess namn matchar det strängargument som ges till metoden, "
"``echo``."

msgid ""
"Note however that, although the help display looks nice and all, it "
"currently is not as helpful as it can be. For example we see that we got "
"``echo`` as a positional argument, but we don't know what it does, other "
"than by guessing or by reading the source code. So, let's make it a bit more "
"useful::"
msgstr ""
"Observera dock att även om hjälpvisningen ser trevlig ut är den för "
"närvarande inte så hjälpsam som den skulle kunna vara. Vi ser till exempel "
"att vi har ``echo`` som ett positionellt argument, men vi vet inte vad det "
"gör, annat än genom att gissa eller läsa källkoden. Så, låt oss göra det "
"lite mer användbart::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\", help=\"echo the string you use here\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"echo\", help=\"echo the string you use here\")\n"
"args = parser.parse_args()\n"
"print(args.echo)"

msgid "And we get:"
msgstr "Och vi får..:"

msgid ""
"$ python prog.py -h\n"
"usage: prog.py [-h] echo\n"
"\n"
"positional arguments:\n"
"  echo        echo the string you use here\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""
"$ python prog.py -h\n"
"användning: prog.py [-h] echo\n"
"\n"
"positionella argument:\n"
"  echo echo echo den sträng du använder här\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta"

msgid "Now, how about doing something even more useful::"
msgstr "Nu, vad sägs om att göra något ännu mer användbart::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\")\n"
"args = parser.parse_args()\n"
"print(args.square**2)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\")\n"
"args = parser.parse_args()\n"
"print(args.square**2)"

msgid ""
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 5, in <module>\n"
"    print(args.square**2)\n"
"TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'"
msgstr ""
"$ python prog.py 4\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"prog.py\", rad 5, i <module>\n"
"    print(args.kvadrat**2)\n"
"TypeError: operandtyp(er) som inte stöds för ** eller pow(): 'str' och 'int'"

msgid ""
"That didn't go so well. That's because :mod:`argparse` treats the options we "
"give it as strings, unless we tell it otherwise. So, let's tell :mod:"
"`argparse` to treat that input as an integer::"
msgstr ""
"Det gick inte så bra. Det beror på att :mod:`argparse` behandlar de "
"alternativ vi ger den som strängar, om vi inte säger något annat. Så, låt "
"oss säga till :mod:`argparse` att behandla den inmatningen som ett heltal::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\",\n"
"                    type=int)\n"
"args = parser.parse_args()\n"
"print(args.square**2)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", help=\"display a square of a given "
"number\",\n"
"                    type=int)\n"
"args = parser.parse_args()\n"
"print(args.square**2)"

msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py four\n"
"usage: prog.py [-h] square\n"
"prog.py: error: argument square: invalid int value: 'four'"
msgstr ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py fyra\n"
"användning: prog.py [-h] kvadrat\n"
"prog.py: fel: argument square: ogiltigt int-värde: 'four'"

msgid ""
"That went well. The program now even helpfully quits on bad illegal input "
"before proceeding."
msgstr ""
"Det gick bra. Programmet avbryter nu till och med på ett hjälpsamt sätt vid "
"dålig olaglig inmatning innan det fortsätter."

msgid "Introducing Optional arguments"
msgstr "Introduktion av valfria argument"

msgid ""
"So far we have been playing with positional arguments. Let us have a look on "
"how to add optional ones::"
msgstr ""
"Hittills har vi lekt med positionella argument. Låt oss ta en titt på hur "
"man lägger till valfria argument::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbosity\", help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"if args.verbosity:\n"
"    print(\"verbosity turned on\")"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbosity\", help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"if args.verbosity:\n"
"    print(\"verbosity turned on\")"

msgid "And the output:"
msgstr "Och utmatningen:"

msgid ""
"$ python prog.py --verbosity 1\n"
"verbosity turned on\n"
"$ python prog.py\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [--verbosity VERBOSITY]\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  --verbosity VERBOSITY\n"
"                        increase output verbosity\n"
"$ python prog.py --verbosity\n"
"usage: prog.py [-h] [--verbosity VERBOSITY]\n"
"prog.py: error: argument --verbosity: expected one argument"
msgstr ""
"$ python prog.py --verbosity 1\n"
"ordrikhet aktiverad\n"
"$ python prog.py\n"
"$ python prog.py --hjälp\n"
"användning: prog.py [-h] [--verbosity VERBOSITY]\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  --verbositet VERBOSITET\n"
"                        öka utmatningens ordrikedom\n"
"$ python prog.py --verbosity\n"
"användning: prog.py [-h] [--verbosity VERBOSITY]\n"
"prog.py: fel: argument --verbosity: förväntade ett argument"

msgid ""
"The program is written so as to display something when ``--verbosity`` is "
"specified and display nothing when not."
msgstr ""
"Programmet är skrivet så att det visar något när ``--verbosity`` anges och "
"ingenting när så inte är fallet."

msgid ""
"To show that the option is actually optional, there is no error when running "
"the program without it. Note that by default, if an optional argument isn't "
"used, the relevant variable, in this case ``args.verbosity``, is given "
"``None`` as a value, which is the reason it fails the truth test of the :"
"keyword:`if` statement."
msgstr ""
"För att visa att alternativet faktiskt är valfritt, blir det inget fel när "
"programmet körs utan det. Observera att som standard, om ett valfritt "
"argument inte används, får den relevanta variabeln, i det här fallet ``args."
"verbosity``, ``None`` som värde, vilket är anledningen till att den inte "
"klarar sanningstestet i :keyword:`if`-satsen."

msgid "The help message is a bit different."
msgstr "Hjälpmeddelandet är lite annorlunda."

msgid ""
"When using the ``--verbosity`` option, one must also specify some value, any "
"value."
msgstr ""
"När man använder alternativet ``--verbosity`` måste man också ange ett "
"värde, vilket som helst."

msgid ""
"The above example accepts arbitrary integer values for ``--verbosity``, but "
"for our simple program, only two values are actually useful, ``True`` or "
"``False``. Let's modify the code accordingly::"
msgstr ""
"Exemplet ovan accepterar godtyckliga heltalsvärden för ``--verbosity``, men "
"för vårt enkla program är det bara två värden som är användbara, ``True`` "
"eller ``False``. Låt oss modifiera koden i enlighet med detta::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbose\", help=\"increase output verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"--verbose\", help=\"increase output verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"

msgid ""
"$ python prog.py --verbose\n"
"verbosity turned on\n"
"$ python prog.py --verbose 1\n"
"usage: prog.py [-h] [--verbose]\n"
"prog.py: error: unrecognized arguments: 1\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [--verbose]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --verbose   increase output verbosity"
msgstr ""
"$ python prog.py --verbose\n"
"ordrikhet aktiverad\n"
"$ python prog.py --verbose 1\n"
"användning: prog.py [-h] [--verbose]\n"
"prog.py: fel: oigenkända argument: 1\n"
"$ python prog.py --hjälp\n"
"användning: prog.py [-h] [--verbose]\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  --verbose ökar utmatningens ordrikedom"

msgid ""
"The option is now more of a flag than something that requires a value. We "
"even changed the name of the option to match that idea. Note that we now "
"specify a new keyword, ``action``, and give it the value ``\"store_true\"``. "
"This means that, if the option is specified, assign the value ``True`` to "
"``args.verbose``. Not specifying it implies ``False``."
msgstr ""
"Alternativet är nu mer av en flagga än något som kräver ett värde. Vi har "
"även ändrat namnet på alternativet för att matcha den idén. Observera att vi "
"nu anger ett nytt nyckelord, ``action``, och ger det värdet "
"``\"store_true\"``. Detta innebär att, om alternativet är specificerat, "
"tilldela värdet ``True`` till ``args.verbose``. Om det inte specificeras "
"innebär det ``False``."

msgid ""
"It complains when you specify a value, in true spirit of what flags actually "
"are."
msgstr ""
"Den klagar när du anger ett värde, i sann anda av vad flaggor faktiskt är."

msgid "Notice the different help text."
msgstr "Lägg märke till de olika hjälptexterna."

msgid "Short options"
msgstr "Korta alternativ"

msgid ""
"If you are familiar with command line usage, you will notice that I haven't "
"yet touched on the topic of short versions of the options. It's quite "
"simple::"
msgstr ""
"Om du är bekant med kommandoradsanvändning kommer du att märka att jag ännu "
"inte har berört ämnet kortversioner av alternativen. Det är ganska enkelt::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"-v\", \"--verbose\", help=\"increase output "
"verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"-v\", \"--verbose\", help=\"increase output "
"verbosity\",\n"
"                    action=\"store_true\")\n"
"args = parser.parse_args()\n"
"if args.verbose:\n"
"    print(\"verbosity turned on\")"

msgid "And here goes:"
msgstr "Och här kommer det:"

msgid ""
"$ python prog.py -v\n"
"verbosity turned on\n"
"$ python prog.py --help\n"
"usage: prog.py [-h] [-v]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  -v, --verbose  increase output verbosity"
msgstr ""
"$ python prog.py -v\n"
"ordrikedom aktiverad\n"
"$ python prog.py --hjälp\n"
"användning: prog.py [-h] [-v]\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --verbose öka utmatningens ordrikedom"

msgid "Note that the new ability is also reflected in the help text."
msgstr "Observera att den nya förmågan också återspeglas i hjälptexten."

msgid "Combining Positional and Optional arguments"
msgstr "Kombination av positionella och valfria argument"

msgid "Our program keeps growing in complexity::"
msgstr "Vårt program blir alltmer komplext::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbose:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbose:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"else:\n"
"    print(answer)"

msgid "And now the output:"
msgstr "Och nu till resultatet:"

msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] [-v] square\n"
"prog.py: error: the following arguments are required: square\n"
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 --verbose\n"
"the square of 4 equals 16\n"
"$ python prog.py --verbose 4\n"
"the square of 4 equals 16"
msgstr ""
"$ python prog.py\n"
"användning: prog.py [-h] [-v] kvadrat\n"
"prog.py: fel: följande argument krävs: square\n"
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 --verbose\n"
"kvadraten av 4 är lika med 16\n"
"$ python prog.py --verbose 4\n"
"kvadraten på 4 är lika med 16"

msgid "We've brought back a positional argument, hence the complaint."
msgstr "Vi har återinfört ett positionsargument, därav klagomålet."

msgid "Note that the order does not matter."
msgstr "Observera att ordningen inte spelar någon roll."

msgid ""
"How about we give this program of ours back the ability to have multiple "
"verbosity values, and actually get to use them::"
msgstr ""
"Vad sägs om att vi ger vårt program tillbaka möjligheten att ha flera "
"verbosity-värden, och faktiskt får använda dem::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int,\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int,\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"usage: prog.py [-h] [-v VERBOSITY] square\n"
"prog.py: error: argument -v/--verbosity: expected one argument\n"
"$ python prog.py 4 -v 1\n"
"4^2 == 16\n"
"$ python prog.py 4 -v 2\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -v 3\n"
"16"
msgstr ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"användning: prog.py [-h] [-v VERBOSITY] kvadrat\n"
"prog.py: fel: argument -v/--verbosity: förväntade ett argument\n"
"$ python prog.py 4 -v 1\n"
"4^2 == 16\n"
"$ python prog.py 4 -v 2\n"
"kvadraten på 4 är lika med 16\n"
"$ python prog.py 4 -v 3\n"
"16"

msgid ""
"These all look good except the last one, which exposes a bug in our program. "
"Let's fix it by restricting the values the ``--verbosity`` option can "
"accept::"
msgstr ""
"Alla dessa ser bra ut utom den sista, som avslöjar en bugg i vårt program. "
"Låt oss åtgärda det genom att begränsa de värden som alternativet ``--"
"verbosity`` kan acceptera::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int, choices=[0, 1, 2],\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", type=int, choices=[0, 1, 2],\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"$ python prog.py 4 -v 3\n"
"usage: prog.py [-h] [-v {0,1,2}] square\n"
"prog.py: error: argument -v/--verbosity: invalid choice: 3 (choose from 0, "
"1, 2)\n"
"$ python prog.py 4 -h\n"
"usage: prog.py [-h] [-v {0,1,2}] square\n"
"\n"
"positional arguments:\n"
"  square                display a square of a given number\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbosity {0,1,2}\n"
"                        increase output verbosity"
msgstr ""
"$ python prog.py 4 -v 3\n"
"användning: prog.py [-h] [-v {0,1,2}] kvadrat\n"
"prog.py: fel: argument -v/--verbosity: ogiltigt val: 3 (välj mellan 0, 1, "
"2)\n"
"$ python prog.py 4 -h\n"
"användning: prog.py [-h] [-v {0,1,2}] kvadrat\n"
"\n"
"positionella argument:\n"
"  square visa en kvadrat av ett givet tal\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --förtydligande {0,1,2}\n"
"                        öka utmatningens ordrikedom"

msgid ""
"Note that the change also reflects both in the error message as well as the "
"help string."
msgstr ""
"Observera att ändringen också återspeglas både i felmeddelandet och i "
"hjälpsträngen."

msgid ""
"Now, let's use a different approach of playing with verbosity, which is "
"pretty common. It also matches the way the CPython executable handles its "
"own verbosity argument (check the output of ``python --help``)::"
msgstr ""
"Låt oss nu använda ett annat tillvägagångssätt för att leka med verbosity, "
"vilket är ganska vanligt. Det stämmer också överens med hur den körbara "
"CPython-filen hanterar sitt eget verbosity-argument (kontrollera utdata från "
"``python --help``)::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display the square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display the square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity == 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity == 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"We have introduced another action, \"count\", to count the number of "
"occurrences of specific options."
msgstr ""
"Vi har infört en annan åtgärd, \"count\", för att räkna antalet förekomster "
"av specifika alternativ."

msgid ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 -vv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 --verbosity --verbosity\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -v 1\n"
"usage: prog.py [-h] [-v] square\n"
"prog.py: error: unrecognized arguments: 1\n"
"$ python prog.py 4 -h\n"
"usage: prog.py [-h] [-v] square\n"
"\n"
"positional arguments:\n"
"  square           display a square of a given number\n"
"\n"
"options:\n"
"  -h, --help       show this help message and exit\n"
"  -v, --verbosity  increase output verbosity\n"
"$ python prog.py 4 -vvv\n"
"16"
msgstr ""
"$ python prog.py 4\n"
"16\n"
"$ python prog.py 4 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 -vv\n"
"kvadraten på 4 är lika med 16\n"
"$ python prog.py 4 --verbosity --verbosity\n"
"kvadraten på 4 är lika med 16\n"
"$ python prog.py 4 -v 1\n"
"användning: prog.py [-h] [-v] kvadrat\n"
"prog.py: fel: oigenkända argument: 1\n"
"$ python prog.py 4 -h\n"
"användning: prog.py [-h] [-v] kvadrat\n"
"\n"
"positionella argument:\n"
"  square visar en kvadrat av ett givet tal\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --verbosity öka utmatningens verbosity\n"
"$ python prog.py 4 -vvv\n"
"16"

msgid ""
"Yes, it's now more of a flag (similar to ``action=\"store_true\"``) in the "
"previous version of our script. That should explain the complaint."
msgstr ""
"Ja, det är nu mer av en flagga (liknande ``action=\"store_true\"``) i den "
"tidigare versionen av vårt skript. Det borde förklara klagomålet."

msgid "It also behaves similar to \"store_true\" action."
msgstr "Den beter sig också på liknande sätt som åtgärden \"store_true\"."

msgid ""
"Now here's a demonstration of what the \"count\" action gives. You've "
"probably seen this sort of usage before."
msgstr ""
"Här är nu en demonstration av vad \"count\"-åtgärden ger. Du har förmodligen "
"sett den här typen av användning tidigare."

msgid ""
"And if you don't specify the ``-v`` flag, that flag is considered to have "
"``None`` value."
msgstr ""
"Och om du inte anger flaggan ``-v``, anses den flaggan ha värdet ``None``."

msgid ""
"As should be expected, specifying the long form of the flag, we should get "
"the same output."
msgstr ""
"Som väntat skulle vi få samma resultat om vi angav den långa formen av "
"flaggan."

msgid ""
"Sadly, our help output isn't very informative on the new ability our script "
"has acquired, but that can always be fixed by improving the documentation "
"for our script (e.g. via the ``help`` keyword argument)."
msgstr ""
"Tyvärr är vår hjälputskrift inte särskilt informativ om den nya förmåga som "
"vårt skript har fått, men det kan alltid åtgärdas genom att förbättra "
"dokumentationen för vårt skript (t.ex. via nyckelordsargumentet ``help``)."

msgid "That last output exposes a bug in our program."
msgstr "Den sista utmatningen avslöjar en bugg i vårt program."

msgid "Let's fix::"
msgstr "Låt oss fixa::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"\n"
"# bugfix: replace == with >=\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\",\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"\n"
"# bugfix: replace == with >=\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid "And this is what it gives:"
msgstr "Och det här är vad det ger:"

msgid ""
"$ python prog.py 4 -vvv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4 -vvvv\n"
"the square of 4 equals 16\n"
"$ python prog.py 4\n"
"Traceback (most recent call last):\n"
"  File \"prog.py\", line 11, in <module>\n"
"    if args.verbosity >= 2:\n"
"TypeError: '>=' not supported between instances of 'NoneType' and 'int'"
msgstr ""
"$ python prog.py 4 -vvv\n"
"kvadraten på 4 är lika med 16\n"
"$ python prog.py 4 -vvvvv\n"
"kvadraten på 4 är lika med 16\n"
"$ python prog.py 4\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"prog.py\", rad 11, i <module>\n"
"    if args.verbosity &gt;= 2:\n"
"TypeError: '&gt;=' stöds inte mellan instanser av 'NoneType' och 'int'"

msgid ""
"First output went well, and fixes the bug we had before. That is, we want "
"any value >= 2 to be as verbose as possible."
msgstr ""
"Första utmatningen gick bra, och fixar buggen vi hade tidigare. Det vill "
"säga att vi vill att alla värden >= 2 ska vara så utförliga som möjligt."

msgid "Third output not so good."
msgstr "Tredje utgången inte så bra."

msgid "Let's fix that bug::"
msgstr "Låt oss fixa det felet::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0,\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"square\", type=int,\n"
"                    help=\"display a square of a given number\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0,\n"
"                    help=\"increase output verbosity\")\n"
"args = parser.parse_args()\n"
"answer = args.square**2\n"
"if args.verbosity >= 2:\n"
"    print(f\"the square of {args.square} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.square}^2 == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid ""
"We've just introduced yet another keyword, ``default``. We've set it to "
"``0`` in order to make it comparable to the other int values. Remember that "
"by default, if an optional argument isn't specified, it gets the ``None`` "
"value, and that cannot be compared to an int value (hence the :exc:"
"`TypeError` exception)."
msgstr ""
"Vi har just introducerat ännu ett nyckelord, ``default``. Vi har satt det "
"till ``0`` för att göra det jämförbart med de andra int-värdena. Kom ihåg "
"att som standard, om ett valfritt argument inte anges, får det värdet "
"``None``, och det kan inte jämföras med ett int-värde (därav :exc:"
"`TypeError`-undantaget)."

msgid "And:"
msgstr "Och..:"

msgid ""
"$ python prog.py 4\n"
"16"
msgstr ""
"$ python prog.py 4\n"
"16"

msgid ""
"You can go quite far just with what we've learned so far, and we have only "
"scratched the surface. The :mod:`argparse` module is very powerful, and "
"we'll explore a bit more of it before we end this tutorial."
msgstr ""
"Du kan komma ganska långt bara med det vi har lärt oss hittills, och vi har "
"bara skrapat på ytan. Modulen :mod:`argparse` är mycket kraftfull, och vi "
"ska utforska lite mer av den innan vi avslutar den här handledningen."

msgid "Getting a little more advanced"
msgstr "Blir lite mer avancerad"

msgid ""
"What if we wanted to expand our tiny program to perform other powers, not "
"just squares::"
msgstr ""
"Tänk om vi ville utöka vårt lilla program till att utföra andra krafter, "
"inte bara rutor::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")\n"
"else:\n"
"    print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"elif args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")\n"
"else:\n"
"    print(answer)"

msgid "Output:"
msgstr "Utdata:"

msgid ""
"$ python prog.py\n"
"usage: prog.py [-h] [-v] x y\n"
"prog.py: error: the following arguments are required: x, y\n"
"$ python prog.py -h\n"
"usage: prog.py [-h] [-v] x y\n"
"\n"
"positional arguments:\n"
"  x                the base\n"
"  y                the exponent\n"
"\n"
"options:\n"
"  -h, --help       show this help message and exit\n"
"  -v, --verbosity\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16"
msgstr ""
"$ python prog.py\n"
"användning: prog.py [-h] [-v] x y\n"
"prog.py: fel: följande argument krävs: x, y\n"
"$ python prog.py -h\n"
"användning: prog.py [-h] [-v] x y\n"
"\n"
"positionella argument:\n"
"  x basen\n"
"  y exponenten\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --verbositet\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16"

msgid ""
"Notice that so far we've been using verbosity level to *change* the text "
"that gets displayed. The following example instead uses verbosity level to "
"display *more* text instead::"
msgstr ""
"Observera att vi hittills har använt verbosity level för att *ändra* den "
"text som visas. I följande exempel används istället verbosity level för att "
"visa *mer* text istället::"

msgid ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"Running '{__file__}'\")\n"
"if args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == \", end=\"\")\n"
"print(answer)"
msgstr ""
"import argparse\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"parser.add_argument(\"-v\", \"--verbosity\", action=\"count\", default=0)\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"if args.verbosity >= 2:\n"
"    print(f\"Running '{__file__}'\")\n"
"if args.verbosity >= 1:\n"
"    print(f\"{args.x}^{args.y} == \", end=\"\")\n"
"print(answer)"

msgid ""
"$ python prog.py 4 2\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -vv\n"
"Running 'prog.py'\n"
"4^2 == 16"
msgstr ""
"$ python prog.py 4 2\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -vv\n"
"Kör 'prog.py'\n"
"4^2 == 16"

msgid "Specifying ambiguous arguments"
msgstr "Specificering av tvetydiga argument"

msgid ""
"When there is ambiguity in deciding whether an argument is positional or for "
"an argument, ``--`` can be used to tell :meth:`~ArgumentParser.parse_args` "
"that everything after that is a positional argument::"
msgstr ""
"När det är svårt att avgöra om ett argument är positionellt eller för ett "
"argument, kan ``--`` användas för att tala om för :meth:`~ArgumentParser."
"parse_args` att allt efter det är ett positionellt argument::"

msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-n', nargs='+')\n"
">>> parser.add_argument('args', nargs='*')\n"
"\n"
">>> # ambiguous, so parse_args assumes it's an option\n"
">>> parser.parse_args(['-f'])\n"
"usage: PROG [-h] [-n N [N ...]] [args ...]\n"
"PROG: error: unrecognized arguments: -f\n"
"\n"
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(args=['-f'], n=None)\n"
"\n"
">>> # ambiguous, so the -n option greedily accepts arguments\n"
">>> parser.parse_args(['-n', '1', '2', '3'])\n"
"Namespace(args=[], n=['1', '2', '3'])\n"
"\n"
">>> parser.parse_args(['-n', '1', '--', '2', '3'])\n"
"Namespace(args=['2', '3'], n=['1'])"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-n', nargs='+')\n"
">>> parser.add_argument('args', nargs='*')\n"
"\n"
">>> # tvetydigt, så parse_args antar att det är ett alternativ\n"
">>> parser.parse_args(['-f'])\n"
"användning: PROG [-h] [-n N [N ...]] [args ...]\n"
"PROG: fel: oigenkända argument: -f\n"
"\n"
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(args=['-f'], n=None)\n"
"\n"
">>> # tvetydigt, så alternativet -n accepterar girigt argument\n"
">>> parser.parse_args(['-n', '1', '2', '3'])\n"
"Namespace(args=[], n=['1', '2', '3'])\n"
"\n"
">>> parser.parse_args(['-n', '1', '--', '2', '3'])\n"
"Namespace(args=['2', '3'], n=['1'])"

msgid "Conflicting options"
msgstr "Motstridiga alternativ"

msgid ""
"So far, we have been working with two methods of an :class:`argparse."
"ArgumentParser` instance. Let's introduce a third one, :meth:"
"`~ArgumentParser.add_mutually_exclusive_group`. It allows for us to specify "
"options that conflict with each other. Let's also change the rest of the "
"program so that the new functionality makes more sense: we'll introduce the "
"``--quiet`` option, which will be the opposite of the ``--verbose`` one::"
msgstr ""
"Hittills har vi arbetat med två metoder i en instans av :class:`argparse."
"ArgumentParser`. Låt oss introducera en tredje, :meth:`~ArgumentParser."
"add_mutually_exclusive_group`. Den gör det möjligt för oss att ange "
"alternativ som står i konflikt med varandra. Låt oss också ändra resten av "
"programmet så att den nya funktionaliteten blir mer begriplig: vi inför "
"alternativet ``--quiet``, som kommer att vara motsatsen till ``--verbose``::"

msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"
msgstr ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"

msgid ""
"Our program is now simpler, and we've lost some functionality for the sake "
"of demonstration. Anyways, here's the output:"
msgstr ""
"Vårt program är nu enklare, och vi har förlorat en del funktionalitet för "
"demonstrationens skull. Hur som helst, här är utdata:"

msgid ""
"$ python prog.py 4 2\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -q\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4 to the power 2 equals 16\n"
"$ python prog.py 4 2 -vq\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose\n"
"$ python prog.py 4 2 -v --quiet\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose"
msgstr ""
"$ python prog.py 4 2\n"
"4^2 == 16\n"
"$ python prog.py 4 2 -q\n"
"16\n"
"$ python prog.py 4 2 -v\n"
"4 till potensen 2 är lika med 16\n"
"$ python prog.py 4 2 -vq\n"
"användning: prog.py [-h] [-v | -q] x y\n"
"prog.py: fel: argument -q/--quiet: inte tillåtet med argument -v/--verbose\n"
"$ python prog.py 4 2 -v --quiet\n"
"användning: prog.py [-h] [-v | -q] x y\n"
"prog.py: fel: argument -q/--quiet: inte tillåtet med argument -v/--verbose"

msgid ""
"That should be easy to follow. I've added that last output so you can see "
"the sort of flexibility you get, i.e. mixing long form options with short "
"form ones."
msgstr ""
"Det borde vara lätt att följa. Jag har lagt till den sista utmatningen så "
"att du kan se vilken typ av flexibilitet du får, dvs. blanda alternativ med "
"lång form med kort form."

msgid ""
"Before we conclude, you probably want to tell your users the main purpose of "
"your program, just in case they don't know::"
msgstr ""
"Innan vi avslutar vill du förmodligen berätta för dina användare huvudsyftet "
"med ditt program, bara om de inte vet::"

msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(description=\"calculate X to the power of "
"Y\")\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"
msgstr ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(description=\"calculate X to the power of "
"Y\")\n"
"group = parser.add_mutually_exclusive_group()\n"
"group.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n"
"group.add_argument(\"-q\", \"--quiet\", action=\"store_true\")\n"
"parser.add_argument(\"x\", type=int, help=\"the base\")\n"
"parser.add_argument(\"y\", type=int, help=\"the exponent\")\n"
"args = parser.parse_args()\n"
"answer = args.x**args.y\n"
"\n"
"if args.quiet:\n"
"    print(answer)\n"
"elif args.verbose:\n"
"    print(f\"{args.x} to the power {args.y} equals {answer}\")\n"
"else:\n"
"    print(f\"{args.x}^{args.y} == {answer}\")"

msgid ""
"Note that slight difference in the usage text. Note the ``[-v | -q]``, which "
"tells us that we can either use ``-v`` or ``-q``, but not both at the same "
"time:"
msgstr ""
"Notera den lilla skillnaden i användningstexten. Notera ``[-v | -q]``, som "
"säger oss att vi antingen kan använda ``-v`` eller ``-q``, men inte båda "
"samtidigt:"

msgid ""
"$ python prog.py --help\n"
"usage: prog.py [-h] [-v | -q] x y\n"
"\n"
"calculate X to the power of Y\n"
"\n"
"positional arguments:\n"
"  x              the base\n"
"  y              the exponent\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  -v, --verbose\n"
"  -q, --quiet"
msgstr ""
"$ python prog.py --hjälp\n"
"användning: prog.py [-h] [-v | -q] x y\n"
"\n"
"beräkna X till potensen av Y\n"
"\n"
"positionella argument:\n"
"  x basen\n"
"  y exponenten\n"
"\n"
"alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --överskådlig\n"
"  -q, --tyst"

msgid "How to translate the argparse output"
msgstr "Hur man översätter argparse-utdata"

msgid ""
"The output of the :mod:`argparse` module such as its help text and error "
"messages are all made translatable using the :mod:`gettext` module. This "
"allows applications to easily localize messages produced by :mod:`argparse`. "
"See also :ref:`i18n-howto`."
msgstr ""
"Utdata från modulen :mod:`argparse`, t.ex. hjälptext och felmeddelanden, "
"görs översättningsbara med modulen :mod:`gettext`. Detta gör att program "
"enkelt kan lokalisera meddelanden som produceras av :mod:`argparse`. Se "
"även :ref:`i18n-howto`."

msgid "For instance, in this :mod:`argparse` output:"
msgstr "Till exempel i detta :mod:`argparse`-utdata:"

msgid ""
"The strings ``usage:``, ``positional arguments:``, ``options:`` and ``show "
"this help message and exit`` are all translatable."
msgstr ""
"Strängarna ``usage:``, ``positional arguments:``, ``options:`` och ``show "
"this help message and exit`` är alla översättningsbara."

msgid ""
"In order to translate these strings, they must first be extracted into a ``."
"po`` file. For example, using `Babel <https://babel.pocoo.org/>`__, run this "
"command:"
msgstr ""
"För att kunna översätta dessa strängar måste de först extraheras till en ``."
"po``-fil. Om du till exempel använder `Babel <https://babel.pocoo.org/>`__, "
"kör det här kommandot:"

msgid "$ pybabel extract -o messages.po /usr/lib/python3.12/argparse.py"
msgstr "$ pybabel extract -o messages.po /usr/lib/python3.12/argparse.py"

msgid ""
"This command will extract all translatable strings from the :mod:`argparse` "
"module and output them into a file named ``messages.po``. This command "
"assumes that your Python installation is in ``/usr/lib``."
msgstr ""
"Detta kommando extraherar alla översättningsbara strängar från modulen :mod:"
"`argparse` och skriver ut dem i en fil med namnet ``messages.po``. Det här "
"kommandot förutsätter att din Python-installation finns i ``/usr/lib``."

msgid ""
"You can find out the location of the :mod:`argparse` module on your system "
"using this script::"
msgstr ""
"Du kan ta reda på var modulen :mod:`argparse` finns i ditt system med hjälp "
"av detta skript::"

msgid ""
"import argparse\n"
"print(argparse.__file__)"
msgstr ""
"import argparse\n"
"print(argparse.__file__)"

msgid ""
"Once the messages in the ``.po`` file are translated and the translations "
"are installed using :mod:`gettext`, :mod:`argparse` will be able to display "
"the translated messages."
msgstr ""
"När meddelandena i filen ``.po`` har översatts och översättningarna har "
"installerats med hjälp av :mod:`gettext`, kommer :mod:`argparse`` att kunna "
"visa de översatta meddelandena."

msgid ""
"To translate your own strings in the :mod:`argparse` output, use :mod:"
"`gettext`."
msgstr ""
"Om du vill översätta dina egna strängar i :mod:`argparse`-utdata använder "
"du :mod:`gettext`."

msgid "Custom type converters"
msgstr "Anpassade typomvandlare"

msgid ""
"The :mod:`argparse` module allows you to specify custom type converters for "
"your command-line arguments. This allows you to modify user input before "
"it's stored in the :class:`argparse.Namespace`. This can be useful when you "
"need to pre-process the input before it is used in your program."
msgstr ""
"Med modulen :mod:`argparse` kan du ange anpassade typkonverterare för dina "
"kommandoradsargument. Detta gör att du kan modifiera användarinmatning innan "
"den lagras i :class:`argparse.Namespace`. Detta kan vara användbart när du "
"behöver förbehandla inmatningen innan den används i ditt program."

msgid ""
"When using a custom type converter, you can use any callable that takes a "
"single string argument (the argument value) and returns the converted value. "
"However, if you need to handle more complex scenarios, you can use a custom "
"action class with the **action** parameter instead."
msgstr ""
"När du använder en anpassad typomvandlare kan du använda valfri callable som "
"tar ett enda strängargument (argumentvärdet) och returnerar det konverterade "
"värdet. Men om du behöver hantera mer komplexa scenarier kan du i stället "
"använda en anpassad åtgärdsklass med parametern **action**."

msgid ""
"For example, let's say you want to handle arguments with different prefixes "
"and process them accordingly::"
msgstr ""
"Låt oss till exempel säga att du vill hantera argument med olika prefix och "
"bearbeta dem i enlighet med detta::"

msgid ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(prefix_chars='-+')\n"
"\n"
"parser.add_argument('-a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('-', x))\n"
"parser.add_argument('+a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('+', x))\n"
"\n"
"args = parser.parse_args()\n"
"print(args)"
msgstr ""
"import argparse\n"
"\n"
"parser = argparse.ArgumentParser(prefix_chars='-+')\n"
"\n"
"parser.add_argument('-a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('-', x))\n"
"parser.add_argument('+a', metavar='<value>', action='append',\n"
"                    type=lambda x: ('+', x))\n"
"\n"
"args = parser.parse_args()\n"
"print(args)"

msgid ""
"$ python prog.py -a value1 +a value2\n"
"Namespace(a=[('-', 'value1'), ('+', 'value2')])"
msgstr ""
"$ python prog.py -a värde1 +a värde2\n"
"Namespace(a=[('-', 'värde1'), ('+', 'värde2')])"

msgid "In this example, we:"
msgstr "I detta exempel har vi:"

msgid ""
"Created a parser with custom prefix characters using the ``prefix_chars`` "
"parameter."
msgstr ""
"Skapade en parser med anpassade prefixtecken med hjälp av parametern "
"``prefix_chars``."

msgid ""
"Defined two arguments, ``-a`` and ``+a``, which used the ``type`` parameter "
"to create custom type converters to store the value in a tuple with the "
"prefix."
msgstr ""
"Definierade två argument, ``-a`` och ``+a``, som använde parametern ``type`` "
"för att skapa anpassade typomvandlare för att lagra värdet i en tupel med "
"prefixet."

msgid ""
"Without the custom type converters, the arguments would have treated the ``-"
"a`` and ``+a`` as the same argument, which would have been undesirable. By "
"using custom type converters, we were able to differentiate between the two "
"arguments."
msgstr ""
"Utan de anpassade typkonverterarna skulle argumenten ha behandlat ``-a`` och "
"``+a`` som samma argument, vilket inte skulle ha varit önskvärt. Genom att "
"använda anpassade typkonverterare kunde vi skilja mellan de två argumenten."

msgid "Conclusion"
msgstr "Slutsats"

msgid ""
"The :mod:`argparse` module offers a lot more than shown here. Its docs are "
"quite detailed and thorough, and full of examples. Having gone through this "
"tutorial, you should easily digest them without feeling overwhelmed."
msgstr ""
"Modulen :mod:`argparse` erbjuder mycket mer än vad som visas här. Dess "
"dokument är ganska detaljerade och grundliga och fulla av exempel. Efter att "
"ha gått igenom den här handledningen bör du lätt kunna tillgodogöra dig dem "
"utan att känna dig överväldigad."
