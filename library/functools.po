# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ""
":mod:`!functools` --- Funktioner av högre ordning och operationer på "
"anropsbara objekt"

msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**Källkod:** :source:`Lib/functools.py`"

msgid ""
"The :mod:`functools` module is for higher-order functions: functions that "
"act on or return other functions. In general, any callable object can be "
"treated as a function for the purposes of this module."
msgstr ""
"Modulen :mod:`functools` är avsedd för funktioner av högre ordning: "
"funktioner som agerar på eller returnerar andra funktioner. I allmänhet kan "
"alla anropsbara objekt behandlas som en funktion i den här modulen."

msgid "The :mod:`functools` module defines the following functions:"
msgstr "Modulen :mod:`functools` definierar följande funktioner:"

msgid ""
"Simple lightweight unbounded function cache.  Sometimes called `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."
msgstr ""
"Enkel lättviktig obegränsad funktionscache.  Kallas ibland för \"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."

msgid ""
"Returns the same as ``lru_cache(maxsize=None)``, creating a thin wrapper "
"around a dictionary lookup for the function arguments.  Because it never "
"needs to evict old values, this is smaller and faster than :func:`lru_cache` "
"with a size limit."
msgstr ""
"Returnerar samma sak som ``lru_cache(maxsize=None)``, vilket skapar ett tunt "
"hölje runt en ordboksuppslagning för funktionsargumenten.  Eftersom den "
"aldrig behöver evakuera gamla värden är den här mindre och snabbare än :func:"
"`lru_cache` med en storleksbegränsning."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"@cache\n"
"def factorial(n):\n"
"    return n * factorial(n-1) if n else 1\n"
"\n"
">>> factorial(10)      # no previously cached result, makes 11 recursive "
"calls\n"
"3628800\n"
">>> factorial(5)       # just looks up cached value result\n"
"120\n"
">>> factorial(12)      # makes two new recursive calls, the other 10 are "
"cached\n"
"479001600"
msgstr ""
"@cache\n"
"def faktoriell(n):\n"
"    return n * faktoriell(n-1) if n else 1\n"
"\n"
">>> factorial(10) # inget tidigare cachat resultat, gör 11 rekursiva anrop\n"
"3628800\n"
">>> factorial(5) # letar bara upp cachelagrat värde resultat\n"
"120\n"
">>> factorial(12) # gör två nya rekursiva anrop, de andra 10 är cachade\n"
"479001600"

msgid ""
"The cache is threadsafe so that the wrapped function can be used in multiple "
"threads.  This means that the underlying data structure will remain coherent "
"during concurrent updates."
msgstr ""
"Cachen är trådsäker så att den omslutna funktionen kan användas i flera "
"trådar.  Detta innebär att den underliggande datastrukturen förblir "
"sammanhängande under samtidiga uppdateringar."

msgid ""
"It is possible for the wrapped function to be called more than once if "
"another thread makes an additional call before the initial call has been "
"completed and cached."
msgstr ""
"Det är möjligt att den inkapslade funktionen anropas mer än en gång om en "
"annan tråd gör ett ytterligare anrop innan det första anropet har slutförts "
"och cachats."

msgid ""
"Transform a method of a class into a property whose value is computed once "
"and then cached as a normal attribute for the life of the instance. Similar "
"to :func:`property`, with the addition of caching. Useful for expensive "
"computed properties of instances that are otherwise effectively immutable."
msgstr ""
"Omvandlar en metod i en klass till en egenskap vars värde beräknas en gång "
"och sedan cachelagras som ett normalt attribut under instansens livstid. "
"Liknar :func:`property`, med tillägg av cachelagring. Användbar för dyra "
"beräknade egenskaper hos instanser som annars är effektivt oföränderliga."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"class DataSet:\n"
"\n"
"    def __init__(self, sequence_of_numbers):\n"
"        self._data = tuple(sequence_of_numbers)\n"
"\n"
"    @cached_property\n"
"    def stdev(self):\n"
"        return statistics.stdev(self._data)"
msgstr ""
"klass DataSet:\n"
"\n"
"    def __init__(self, sequence_of_numbers):\n"
"        self._data = tuple(sequence_of_numbers)\n"
"\n"
"    @cachad_egenskap\n"
"    def stdev(self):\n"
"        return statistik.stdev(self._data)"

msgid ""
"The mechanics of :func:`cached_property` are somewhat different from :func:"
"`property`.  A regular property blocks attribute writes unless a setter is "
"defined. In contrast, a *cached_property* allows writes."
msgstr ""
"Mekaniken i :func:`cached_property` är något annorlunda än i :func:"
"`property`.  En vanlig property blockerar skrivningar av attribut om inte en "
"setter är definierad. Däremot tillåter en *cached_property* skrivningar."

msgid ""
"The *cached_property* decorator only runs on lookups and only when an "
"attribute of the same name doesn't exist.  When it does run, the "
"*cached_property* writes to the attribute with the same name. Subsequent "
"attribute reads and writes take precedence over the *cached_property* method "
"and it works like a normal attribute."
msgstr ""
"Dekoratorn *cached_property* körs endast vid uppslagningar och endast när "
"ett attribut med samma namn inte existerar.  När den körs skriver "
"*cached_property* till attributet med samma namn. Efterföljande läsningar "
"och skrivningar av attribut har företräde framför metoden *cached_property* "
"och den fungerar som ett vanligt attribut."

msgid ""
"The cached value can be cleared by deleting the attribute.  This allows the "
"*cached_property* method to run again."
msgstr ""
"Det cachade värdet kan rensas genom att attributet tas bort.  Detta gör att "
"metoden *cached_property* kan köras igen."

msgid ""
"The *cached_property* does not prevent a possible race condition in multi-"
"threaded usage. The getter function could run more than once on the same "
"instance, with the latest run setting the cached value. If the cached "
"property is idempotent or otherwise not harmful to run more than once on an "
"instance, this is fine. If synchronization is needed, implement the "
"necessary locking inside the decorated getter function or around the cached "
"property access."
msgstr ""
"Egenskapen *cached_property* förhindrar inte ett möjligt tävlingsförhållande "
"vid användning med flera trådar. Getter-funktionen kan köras mer än en gång "
"på samma instans, där den senaste körningen ställer in det cachade värdet. "
"Om den cachade egenskapen är idempotent eller på annat sätt inte skadlig för "
"att köras mer än en gång på en instans, är detta bra. Om synkronisering "
"behövs, implementera den nödvändiga låsningen i den dekorerade getter-"
"funktionen eller runt åtkomsten till den cachade egenskapen."

msgid ""
"Note, this decorator interferes with the operation of :pep:`412` key-sharing "
"dictionaries.  This means that instance dictionaries can take more space "
"than usual."
msgstr ""
"Observera att denna dekorator stör funktionen hos :pep:`412` "
"nyckeldelningsordböcker.  Detta innebär att instansordböcker kan ta mer "
"utrymme än vanligt."

msgid ""
"Also, this decorator requires that the ``__dict__`` attribute on each "
"instance be a mutable mapping. This means it will not work with some types, "
"such as metaclasses (since the ``__dict__`` attributes on type instances are "
"read-only proxies for the class namespace), and those that specify "
"``__slots__`` without including ``__dict__`` as one of the defined slots (as "
"such classes don't provide a ``__dict__`` attribute at all)."
msgstr ""
"Den här dekoratorn kräver också att attributet ``__dict__`` på varje instans "
"är en muterbar mappning. Detta innebär att den inte kommer att fungera med "
"vissa typer, till exempel metaklasser (eftersom attributen ``__dict__`` på "
"typinstanser är skrivskyddade proxyer för klassens namnrymd) och de som "
"anger ``__slots__`` utan att inkludera ``__dict__`` som en av de definierade "
"slottarna (eftersom sådana klasser inte tillhandahåller ett attribut "
"``__dict__`` alls)."

msgid ""
"If a mutable mapping is not available or if space-efficient key sharing is "
"desired, an effect similar to :func:`cached_property` can also be achieved "
"by stacking :func:`property` on top of :func:`lru_cache`. See :ref:`faq-"
"cache-method-calls` for more details on how this differs from :func:"
"`cached_property`."
msgstr ""
"Om en mutabel mappning inte är tillgänglig eller om utrymmeseffektiv "
"nyckeldelning önskas, kan en effekt som liknar :func:`cached_property` också "
"uppnås genom att stapla :func:`property` ovanpå :func:`lru_cache`. Se :ref:"
"`faq-cache-method-calls` för mer information om hur detta skiljer sig från :"
"func:`cached_property`."

msgid ""
"Prior to Python 3.12, ``cached_property`` included an undocumented lock to "
"ensure that in multi-threaded usage the getter function was guaranteed to "
"run only once per instance. However, the lock was per-property, not per-"
"instance, which could result in unacceptably high lock contention. In Python "
"3.12+ this locking is removed."
msgstr ""
"Före Python 3.12 inkluderade ``cached_property`` ett odokumenterat lås för "
"att säkerställa att getter-funktionen garanterat bara kördes en gång per "
"instans vid flertrådig användning. Låset var dock per egenskap, inte per "
"instans, vilket kunde resultera i oacceptabelt hög låskonflikt. I Python "
"3.12+ är denna låsning borttagen."

msgid ""
"Transform an old-style comparison function to a :term:`key function`.  Used "
"with tools that accept key functions (such as :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :func:"
"`itertools.groupby`).  This function is primarily used as a transition tool "
"for programs being converted from Python 2 which supported the use of "
"comparison functions."
msgstr ""
"Omvandlar en gammaldags jämförelsefunktion till en :term:`nyckelfunktion`.  "
"Används med verktyg som accepterar nyckelfunktioner (t.ex. :func:`sorted`, :"
"func:`min`, :func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :"
"func:`itertools.groupby`).  Denna funktion används främst som ett "
"övergångsverktyg för program som konverteras från Python 2 som stödde "
"användningen av jämförelsefunktioner."

msgid ""
"A comparison function is any callable that accepts two arguments, compares "
"them, and returns a negative number for less-than, zero for equality, or a "
"positive number for greater-than.  A key function is a callable that accepts "
"one argument and returns another value to be used as the sort key."
msgstr ""
"En jämförelsefunktion är en anropsbar funktion som tar emot två argument, "
"jämför dem och returnerar ett negativt tal för mindre än, noll för likhet "
"eller ett positivt tal för större än.  En nyckelfunktion är en anropsbar "
"funktion som tar emot ett argument och returnerar ett annat värde som "
"används som sorteringsnyckel."

msgid ""
"sorted(iterable, key=cmp_to_key(locale.strcoll))  # locale-aware sort order"
msgstr ""
"sorterad(iterabel, nyckel=cmp_till_nyckel(locale.strcoll))  # lokalmedveten "
"sorteringsordning"

msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"För sorteringsexempel och en kort sorteringshandledning, se :ref:"
"`sortinghowto`."

msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to the "
"*maxsize* most recent calls.  It can save time when an expensive or I/O "
"bound function is periodically called with the same arguments."
msgstr ""
"Dekorator för att omsluta en funktion med en memoizing callable som sparar "
"upp till *maxsize* senaste anrop.  Det kan spara tid när en dyr eller I/O-"
"bunden funktion anropas med jämna mellanrum med samma argument."

msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be :term:`hashable`."
msgstr ""
"Eftersom en ordbok används för att cacha resultat måste positionella "
"argument och nyckelordsargument till funktionen vara :term:`hashable`."

msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, ``f(a=1, b=2)`` and ``f(b=2, a=1)`` "
"differ in their keyword argument order and may have two separate cache "
"entries."
msgstr ""
"Olika argumentmönster kan betraktas som olika anrop med olika cacheposter.  "
"Till exempel skiljer sig ``f(a=1, b=2)`` och ``f(b=2, a=1)`` åt i "
"ordningsföljden på nyckelordets argument och kan ha två separata cacheposter."

msgid ""
"If *user_function* is specified, it must be a callable. This allows the "
"*lru_cache* decorator to be applied directly to a user function, leaving the "
"*maxsize* at its default value of 128::"
msgstr ""
"Om *user_function* specificeras måste den vara en callable. Detta gör att "
"*lru_cache*-dekoratorn kan tillämpas direkt på en användarfunktion, och "
"*maxsize* behåller sitt standardvärde på 128::"

msgid ""
"@lru_cache\n"
"def count_vowels(sentence):\n"
"    return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')"
msgstr ""
"@lru_cache\n"
"def count_vowels(mening):\n"
"    return sum(mening.count(vokal) för vokal i 'AEIOUaeiou')"

msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the cache "
"can grow without bound."
msgstr ""
"Om *maxsize* är satt till ``None`` inaktiveras LRU-funktionen och "
"cacheminnet kan växa obegränsat."

msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  If *typed* is false, the implementation will usually "
"regard them as equivalent calls and only cache a single result. (Some types "
"such as *str* and *int* may be cached separately even when *typed* is false.)"
msgstr ""
"Om *typed* är satt till true kommer funktionsargument av olika typer att "
"cachas separat.  Om *typed* är false kommer implementationen vanligtvis att "
"betrakta dem som likvärdiga anrop och bara cacha ett enda resultat. (Vissa "
"typer som *str* och *int* kan cachelagras separat även när *typed* är false.)"

msgid ""
"Note, type specificity applies only to the function's immediate arguments "
"rather than their contents.  The scalar arguments, ``Decimal(42)`` and "
"``Fraction(42)`` are be treated as distinct calls with distinct results. In "
"contrast, the tuple arguments ``('answer', Decimal(42))`` and ``('answer', "
"Fraction(42))`` are treated as equivalent."
msgstr ""
"Observera att typspecificitet endast gäller funktionens omedelbara argument "
"och inte deras innehåll.  De skalära argumenten ``Decimal(42))`` och "
"``Fraction(42))`` behandlas som distinkta anrop med distinkta resultat. "
"Däremot behandlas tupelargumenten ``('answer', Decimal(42))`` och "
"``('answer', Fraction(42))`` som likvärdiga."

msgid ""
"The wrapped function is instrumented with a :func:`!cache_parameters` "
"function that returns a new :class:`dict` showing the values for *maxsize* "
"and *typed*.  This is for information purposes only.  Mutating the values "
"has no effect."
msgstr ""
"Den omslutna funktionen är utrustad med en :func:`!cache_parameters`-"
"funktion som returnerar en ny :class:`dict` som visar värdena för *maxsize* "
"och *typed*.  Detta är endast för informationsändamål.  Mutation av värdena "
"har ingen effekt."

msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`!cache_info` "
"function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*."
msgstr ""
"För att hjälpa till att mäta effektiviteten i cacheminnet och justera "
"parametern *maxsize* har den omslutna funktionen försetts med en :func:`!"
"cache_info`-funktion som returnerar en :term:`named tuple` med *hits*, "
"*misses*, *maxsize* och *currsize*."

msgid ""
"The decorator also provides a :func:`!cache_clear` function for clearing or "
"invalidating the cache."
msgstr ""
"Dekoratorn innehåller också en :func:`!cache_clear`-funktion för att tömma "
"eller inaktivera cachen."

msgid ""
"The original underlying function is accessible through the :attr:"
"`__wrapped__` attribute.  This is useful for introspection, for bypassing "
"the cache, or for rewrapping the function with a different cache."
msgstr ""
"Den underliggande originalfunktionen är tillgänglig via attributet :attr:"
"`__wrapped__`.  Detta är användbart för introspektion, för att kringgå "
"cacheminnet eller för att återpacka funktionen med ett annat cacheminne."

msgid ""
"The cache keeps references to the arguments and return values until they age "
"out of the cache or until the cache is cleared."
msgstr ""
"Cachen behåller referenser till argumenten och returvärdena tills de åldras "
"ut ur cachen eller tills cachen rensas."

msgid ""
"If a method is cached, the ``self`` instance argument is included in the "
"cache.  See :ref:`faq-cache-method-calls`"
msgstr ""
"Om en metod cachelagras inkluderas instansargumentet ``self`` i "
"cacheminnet.  Se :ref:`faq-cache-metod-anrop`"

msgid ""
"An `LRU (least recently used) cache <https://en.wikipedia.org/wiki/"
"Cache_replacement_policies#Least_Recently_Used_(LRU)>`_ works best when the "
"most recent calls are the best predictors of upcoming calls (for example, "
"the most popular articles on a news server tend to change each day).  The "
"cache's size limit assures that the cache does not grow without bound on "
"long-running processes such as web servers."
msgstr ""
"En `LRU-cache (least recently used) <https://en.wikipedia.org/wiki/"
"Cache_replacement_policies#Least_Recently_Used_(LRU)>`_ fungerar bäst när de "
"senaste anropen är de bästa indikatorerna på kommande anrop (t.ex. de mest "
"populära artiklarna på en nyhetsserver tenderar att ändras varje dag).  "
"Cachens storleksbegränsning säkerställer att cacheminnet inte växer "
"obegränsat i långvariga processer, t.ex. webbservrar."

msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct mutable "
"objects on each call (such as generators and async functions), or impure "
"functions such as time() or random()."
msgstr ""
"I allmänhet bör LRU-cachen endast användas när du vill återanvända tidigare "
"beräknade värden.  Följaktligen är det inte meningsfullt att cachelagra "
"funktioner med bieffekter, funktioner som måste skapa distinkta föränderliga "
"objekt vid varje anrop (t.ex. generatorer och asynkrona funktioner) eller "
"orena funktioner som time() eller random()."

msgid "Example of an LRU cache for static web content::"
msgstr "Exempel på en LRU-cache för statiskt webbinnehåll::"

msgid ""
"@lru_cache(maxsize=32)\n"
"def get_pep(num):\n"
"    'Retrieve text of a Python Enhancement Proposal'\n"
"    resource = f'https://peps.python.org/pep-{num:04d}'\n"
"    try:\n"
"        with urllib.request.urlopen(resource) as s:\n"
"            return s.read()\n"
"    except urllib.error.HTTPError:\n"
"        return 'Not Found'\n"
"\n"
">>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:\n"
"...     pep = get_pep(n)\n"
"...     print(n, len(pep))\n"
"\n"
">>> get_pep.cache_info()\n"
"CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)"
msgstr ""
"@lru_cache(maxstorlek=32)\n"
"def get_pep(num):\n"
"    \"Hämta texten i ett förslag till Python-förbättring\n"
"    resurs = f'https://peps.python.org/pep-{num:04d}'\n"
"    försök:\n"
"        med urllib.request.urlopen(resource) som s:\n"
"            return s.read()\n"
"    except urllib.error.HTTPError:\n"
"        return 'Hittades inte'\n"
"\n"
">>> för n i 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:\n"
"... pep = get_pep(n)\n"
"... print(n, len(pep))\n"
"\n"
">>> get_pep.cache_info()\n"
"CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)"

msgid ""
"Example of efficiently computing `Fibonacci numbers <https://en.wikipedia."
"org/wiki/Fibonacci_number>`_ using a cache to implement a `dynamic "
"programming <https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"Exempel på effektiv beräkning av Fibonacci-tal <https://en.wikipedia.org/"
"wiki/Fibonacci_number>`_ med hjälp av en cache för att implementera en "
"teknik för dynamisk programmering <https://en.wikipedia.org/wiki/"
"Dynamic_programming>`_::"

msgid ""
"@lru_cache(maxsize=None)\n"
"def fib(n):\n"
"    if n < 2:\n"
"        return n\n"
"    return fib(n-1) + fib(n-2)\n"
"\n"
">>> [fib(n) for n in range(16)]\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]\n"
"\n"
">>> fib.cache_info()\n"
"CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)"
msgstr ""
"@lru_cache(maxstorlek=None)\n"
"def fib(n):\n"
"    om n < 2:\n"
"        returnera n\n"
"    returnera fib(n-1) + fib(n-2)\n"
"\n"
">>> [fib(n) för n i intervall(16)]\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]\n"
"\n"
">>> fib.cache_info()\n"
"CacheInfo(träffar=28, missar=16, maxstorlek=None, aktuell storlek=16)"

msgid "Added the *typed* option."
msgstr "Alternativet *typed* har lagts till."

msgid "Added the *user_function* option."
msgstr "Lagt till alternativet *user_function*."

msgid "Added the function :func:`!cache_parameters`"
msgstr "Lagt till funktionen :func:`!cache_parameters`"

msgid ""
"Given a class defining one or more rich comparison ordering methods, this "
"class decorator supplies the rest.  This simplifies the effort involved in "
"specifying all of the possible rich comparison operations:"
msgstr ""
"Om en klass definierar en eller flera ordningsmetoder för rik jämförelse, "
"tillhandahåller denna klassdekorator resten.  Detta förenklar arbetet med "
"att specificera alla möjliga operationer för rik jämförelse:"

msgid ""
"The class must define one of :meth:`~object.__lt__`, :meth:`~object."
"__le__`, :meth:`~object.__gt__`, or :meth:`~object.__ge__`. In addition, the "
"class should supply an :meth:`~object.__eq__` method."
msgstr ""
"Klassen måste definiera en av :meth:`~object.__lt__`, :meth:`~object."
"__le__`, :meth:`~object.__gt__` eller :meth:`~object.__ge__`. Dessutom bör "
"klassen tillhandahålla en :meth:`~object.__eq__`-metod."

msgid ""
"@total_ordering\n"
"class Student:\n"
"    def _is_valid_operand(self, other):\n"
"        return (hasattr(other, \"lastname\") and\n"
"                hasattr(other, \"firstname\"))\n"
"    def __eq__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) ==\n"
"                (other.lastname.lower(), other.firstname.lower()))\n"
"    def __lt__(self, other):\n"
"        if not self._is_valid_operand(other):\n"
"            return NotImplemented\n"
"        return ((self.lastname.lower(), self.firstname.lower()) <\n"
"                (other.lastname.lower(), other.firstname.lower()))"
msgstr ""
"@total_beställning\n"
"klass Student:\n"
"    def _is_valid_operand(self, other):\n"
"        return (hasattr(other, \"efternamn\") och\n"
"                hasattr(annan, \"förnamn\"))\n"
"    def __eq__(self, annan):\n"
"        if not self._is_valid_operand(other):\n"
"            return Ej implementerad\n"
"        return ((self.efternamn.lower(), self.förnamn.lower()) == (other."
"efternamn.lower())\n"
"                (other.lastname.lower(), other.firstname.lower()))\n"
"    def __lt__(self, annan):\n"
"        if not self._is_valid_operand(other):\n"
"            return Ej implementerad\n"
"        return ((self.efternamn.lower(), self.förnamn.lower()) <\n"
"                (other.efternamn.lower(), other.förnamn.lower())))"

msgid ""
"While this decorator makes it easy to create well behaved totally ordered "
"types, it *does* come at the cost of slower execution and more complex stack "
"traces for the derived comparison methods. If performance benchmarking "
"indicates this is a bottleneck for a given application, implementing all six "
"rich comparison methods instead is likely to provide an easy speed boost."
msgstr ""
"Den här dekoratorn gör det enkelt att skapa välfungerande, helt ordnade "
"typer, men det sker på bekostnad av långsammare exekvering och mer komplexa "
"stackspår för de härledda jämförelsemetoderna. Om prestandajämförelser visar "
"att detta är en flaskhals för en viss applikation, är det troligt att det är "
"enkelt att öka hastigheten genom att implementera alla sex rika "
"jämförelsemetoderna istället."

msgid ""
"This decorator makes no attempt to override methods that have been declared "
"in the class *or its superclasses*. Meaning that if a superclass defines a "
"comparison operator, *total_ordering* will not implement it again, even if "
"the original method is abstract."
msgstr ""
"Denna dekorator gör inga försök att åsidosätta metoder som har deklarerats i "
"klassen *eller dess superklasser*. Det betyder att om en superklass "
"definierar en jämförelseoperator, kommer *total_ordering* inte att "
"implementera den igen, även om den ursprungliga metoden är abstrakt."

msgid ""
"Returning ``NotImplemented`` from the underlying comparison function for "
"unrecognised types is now supported."
msgstr ""
"Det finns nu stöd för att returnera ``NotImplemented`` från den "
"underliggande jämförelsefunktionen för okända typer."

msgid ""
"A singleton object used as a sentinel to reserve a place for positional "
"arguments when calling :func:`partial` and :func:`partialmethod`."
msgstr ""
"Ett singleton-objekt som används som en sentinel för att reservera en plats "
"för positionella argument vid anrop av :func:`partial` och :func:"
"`partialmethod`."

msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called will "
"behave like *func* called with the positional arguments *args* and keyword "
"arguments *keywords*. If more arguments are supplied to the call, they are "
"appended to *args*. If additional keyword arguments are supplied, they "
"extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"Returnerar ett nytt :ref:`partial object<partial-objects>` som när det "
"anropas kommer att bete sig som *func* anropat med de positionella "
"argumenten *args* och nyckelordsargumenten *keywords*. Om fler argument "
"anges vid anropet läggs de till *args*. Om ytterligare nyckelordsargument "
"anges utökar och åsidosätter de *keywords*. Ungefär likvärdig med::"

msgid ""
"def partial(func, /, *args, **keywords):\n"
"    def newfunc(*more_args, **more_keywords):\n"
"        return func(*args, *more_args, **(keywords | more_keywords))\n"
"    newfunc.func = func\n"
"    newfunc.args = args\n"
"    newfunc.keywords = keywords\n"
"    return newfunc"
msgstr ""
"def partial(func, /, *args, **nyckelord):\n"
"    def newfunc(*fler_args, **fler_nyckelord):\n"
"        return func(*args, *mer_args, **(nyckelord | mer_nyckelord))\n"
"    newfunc.func = func\n"
"    newfunc.args = args\n"
"    newfunc.nyckelord = nyckelord\n"
"    returnera newfunc"

msgid ""
"The :func:`!partial` function is used for partial function application which "
"\"freezes\" some portion of a function's arguments and/or keywords resulting "
"in a new object with a simplified signature.  For example, :func:`partial` "
"can be used to create a callable that behaves like the :func:`int` function "
"where the *base* argument defaults to ``2``:"
msgstr ""
"Funktionen :func:`!partial` används för partiell funktionstillämpning som "
"\"fryser\" en del av en funktions argument och/eller nyckelord, vilket "
"resulterar i ett nytt objekt med en förenklad signatur.  Till exempel kan :"
"func:`partial` användas för att skapa en anropsbar funktion som beter sig "
"som :func:`int`-funktionen där *base*-argumentet som standard är ``2``:"

msgid ""
">>> basetwo = partial(int, base=2)\n"
">>> basetwo.__doc__ = 'Convert base 2 string to an int.'\n"
">>> basetwo('10010')\n"
"18"
msgstr ""
">>> basetwo = partial(int, base=2)\n"
">>> basetwo.__doc__ = 'Konvertera bas 2-sträng till en int.'\n"
">>> basetwo('10010')\n"
"18"

msgid ""
"If :data:`Placeholder` sentinels are present in *args*, they will be filled "
"first when :func:`!partial` is called. This makes it possible to pre-fill "
"any positional argument with a call to :func:`!partial`; without :data:`!"
"Placeholder`, only the chosen number of leading positional arguments can be "
"pre-filled."
msgstr ""
"Om :data:`Placeholder` sentinels finns i *args*, kommer de att fyllas först "
"när :func:`!partial` anropas. Detta gör det möjligt att förfylla vilket "
"positionsargument som helst med ett anrop till :func:`!partial`; utan :data:"
"`!Placeholder` kan endast det valda antalet ledande positionsargument "
"förfyllas."

msgid ""
"If any :data:`!Placeholder` sentinels are present, all must be filled at "
"call time:"
msgstr ""
"Om det finns några :data:`!Placeholder` sentineller måste alla fyllas vid "
"anropstillfället:"

msgid ""
">>> say_to_world = partial(print, Placeholder, Placeholder, \"world!\")\n"
">>> say_to_world('Hello', 'dear')\n"
"Hello dear world!"
msgstr ""
">>> say_to_world = partial(print, platshållare, platshållare, \"värld!\")\n"
">>> say_to_world('Hello', 'dear')\n"
"Hej kära värld!"

msgid ""
"Calling ``say_to_world('Hello')`` raises a :exc:`TypeError`, because only "
"one positional argument is provided, but there are two placeholders that "
"must be filled in."
msgstr ""
"Anropet av ``say_to_world('Hello')`` ger upphov till ett :exc:`TypeError`, "
"eftersom endast ett positionellt argument anges, men det finns två "
"platshållare som måste fyllas i."

msgid ""
"If :func:`!partial` is applied to an existing :func:`!partial` object, :data:"
"`!Placeholder` sentinels of the input object are filled in with new "
"positional arguments. A placeholder can be retained by inserting a new :data:"
"`!Placeholder` sentinel to the place held by a previous :data:`!Placeholder`:"
msgstr ""
"Om :func:`!partial` tillämpas på ett befintligt :func:`!partial`-objekt, "
"fylls :data:`!Placeholder` sentinels i input-objektet med nya "
"positionsargument. En platshållare kan behållas genom att infoga en ny :data:"
"`!Placeholder` sentinel till den plats som innehas av en tidigare :data:`!"
"Placeholder`:"

msgid ""
">>> from functools import partial, Placeholder as _\n"
">>> remove = partial(str.replace, _, _, '')\n"
">>> message = 'Hello, dear dear world!'\n"
">>> remove(message, ' dear')\n"
"'Hello, world!'\n"
">>> remove_dear = partial(remove, _, ' dear')\n"
">>> remove_dear(message)\n"
"'Hello, world!'\n"
">>> remove_first_dear = partial(remove_dear, _, 1)\n"
">>> remove_first_dear(message)\n"
"'Hello, dear world!'"
msgstr ""
">>> from functools import partial, Platshållare som _\n"
">>> remove = partial(str.replace, _, _, '')\n"
">>> meddelande = \"Hej, kära kära värld!\n"
">>> remove(meddelande, ' kära')\n"
"\"Hej, världen!\n"
">>> remove_dear = partial(remove, _, ' kära')\n"
">>> remove_dear(meddelande)\n"
"\"Hej, världen!\n"
">>> remove_first_dear = partial(remove_dear, _, 1)\n"
">>> remove_first_dear(meddelande)\n"
"\"Hej, kära värld!"

msgid ""
":data:`!Placeholder` cannot be passed to :func:`!partial` as a keyword "
"argument."
msgstr ""
":data:`!Placeholder` kan inte skickas till :func:`!partial` som ett "
"nyckelordsargument."

msgid "Added support for :data:`Placeholder` in positional arguments."
msgstr "Lagt till stöd för :data:`Placeholder` i positionella argument."

msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like :class:"
"`partial` except that it is designed to be used as a method definition "
"rather than being directly callable."
msgstr ""
"Returnerar en ny :class:`partialmethod` deskriptor som beter sig som :class:"
"`partial` förutom att den är utformad för att användas som en "
"metoddefinition snarare än att vara direkt anropsbar."

msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are both, "
"like normal functions, are handled as descriptors)."
msgstr ""
"*func* måste vara en :term:`descriptor` eller en callable (objekt som är "
"både och, som vanliga funktioner, hanteras som descriptors)."

msgid ""
"When *func* is a descriptor (such as a normal Python function, :func:"
"`classmethod`, :func:`staticmethod`, :func:`~abc.abstractmethod` or another "
"instance of :class:`partialmethod`), calls to ``__get__`` are delegated to "
"the underlying descriptor, and an appropriate :ref:`partial object<partial-"
"objects>` returned as the result."
msgstr ""
"När *func* är en deskriptor (t.ex. en vanlig Python-funktion, :func:"
"`classmethod`, :func:`staticmethod`, :func:`~abc.abstractmethod` eller en "
"annan instans av :class:`partialmethod`), delegeras anrop till ``__get__`` "
"till den underliggande deskriptorn och ett lämpligt :ref:"
"`partialobjekt<partial-objects>` returneras som resultat."

msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used as "
"a method: the *self* argument will be inserted as the first positional "
"argument, even before the *args* and *keywords* supplied to the :class:"
"`partialmethod` constructor."
msgstr ""
"När *func* är en non-descriptor callable, skapas en lämplig bunden metod "
"dynamiskt. Detta beter sig som en vanlig Python-funktion när den används som "
"en metod: argumentet *self* kommer att infogas som det första positionella "
"argumentet, till och med före de *args* och *keywords* som anges i :class:"
"`partialmethod`-konstruktören."

msgid ""
">>> class Cell:\n"
"...     def __init__(self):\n"
"...         self._alive = False\n"
"...     @property\n"
"...     def alive(self):\n"
"...         return self._alive\n"
"...     def set_state(self, state):\n"
"...         self._alive = bool(state)\n"
"...     set_alive = partialmethod(set_state, True)\n"
"...     set_dead = partialmethod(set_state, False)\n"
"...\n"
">>> c = Cell()\n"
">>> c.alive\n"
"False\n"
">>> c.set_alive()\n"
">>> c.alive\n"
"True"
msgstr ""
">>> klass Cell:\n"
"... def __init__(self):\n"
"... self._alive = False\n"
"...     @egenskap\n"
"... def alive(self):\n"
"... return self._alive\n"
"... def set_state(self, state):\n"
"... self._alive = bool(state)\n"
"... set_alive = partialmethod(set_state, True)\n"
"... set_dead = partialmethod(set_state, False)\n"
"...\n"
">>> c = Cell()\n"
">>> c.alive\n"
"Falsk\n"
">>> c.set_alive()\n"
">>> c.alive\n"
"Sant"

msgid ""
"Apply *function* of two arguments cumulatively to the items of *iterable*, "
"from left to right, so as to reduce the iterable to a single value.  For "
"example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` calculates "
"``((((1+2)+3)+4)+5)``. The left argument, *x*, is the accumulated value and "
"the right argument, *y*, is the update value from the *iterable*.  If the "
"optional *initial* is present, it is placed before the items of the iterable "
"in the calculation, and serves as a default when the iterable is empty.  If "
"*initial* is not given and *iterable* contains only one item, the first item "
"is returned."
msgstr ""
"Tillämpa *funktion* med två argument kumulativt på objekten i *iterabel*, "
"från vänster till höger, så att iterabeln reduceras till ett enda värde.  "
"Till exempel beräknar ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` "
"``((((1+2)+3)+4)+5)``. Det vänstra argumentet, *x*, är det ackumulerade "
"värdet och det högra argumentet, *y*, är uppdateringsvärdet från "
"*iterable*.  Om det valfria *initial* finns med placeras det före iterabelns "
"objekt i beräkningen och fungerar som standard när iterabeln är tom.  Om "
"*initial* inte anges och *iterable* bara innehåller ett objekt, returneras "
"det första objektet."

msgid "Roughly equivalent to::"
msgstr "Ungefär motsvarande::"

msgid ""
"initial_missing = object()\n"
"\n"
"def reduce(function, iterable, /, initial=initial_missing):\n"
"    it = iter(iterable)\n"
"    if initial is initial_missing:\n"
"        value = next(it)\n"
"    else:\n"
"        value = initial\n"
"    for element in it:\n"
"        value = function(value, element)\n"
"    return value"
msgstr ""
"initial_missing = objekt()\n"
"\n"
"def reduce(function, iterable, /, initial=initial_missing):\n"
"    det = iter(iterabel)\n"
"    om initial är initial_missing:\n"
"        värde = nästa(det)\n"
"    i annat fall\n"
"        värde = initial\n"
"    för element i it:\n"
"        värde = funktion(värde, element)\n"
"    returnerar värde"

msgid ""
"See :func:`itertools.accumulate` for an iterator that yields all "
"intermediate values."
msgstr ""
"Se :func:`itertools.accumulate` för en iterator som ger alla mellanliggande "
"värden."

msgid "*initial* is now supported as a keyword argument."
msgstr "*initial* stöds nu som ett nyckelordsargument."

msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"Omvandla en funktion till en :term:`single-dispatch <single dispatch>` :term:"
"`generisk funktion`."

msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. When defining a function using ``@singledispatch``, note that the "
"dispatch happens on the type of the first argument::"
msgstr ""
"För att definiera en generisk funktion, dekorera den med dekoratorn "
"``@singledispatch``. När du definierar en funktion med hjälp av "
"``@singledispatch``, observera att dispatch sker på typen av det första "
"argumentet::"

msgid ""
">>> from functools import singledispatch\n"
">>> @singledispatch\n"
"... def fun(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Let me just say,\", end=\" \")\n"
"...     print(arg)"
msgstr ""
">>> from functools import singledispatch\n"
">>> @singledispatch\n"
"... def fun(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Let me just say,\", end=\" \")\n"
"...     print(arg)"

msgid ""
"To add overloaded implementations to the function, use the :func:`!register` "
"attribute of the generic function, which can be used as a decorator.  For "
"functions annotated with types, the decorator will infer the type of the "
"first argument automatically::"
msgstr ""
"För att lägga till överladdade implementationer till funktionen, använd :"
"func:`!register`-attributet för den generiska funktionen, som kan användas "
"som en dekorator.  För funktioner som är annoterade med typer kommer "
"dekoratorn automatiskt att härleda typen av det första argumentet::"

msgid ""
">>> @fun.register\n"
"... def _(arg: int, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> @fun.register\n"
"... def _(arg: list, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"
msgstr ""
">>> @fun.register\n"
"... def _(arg: int, verbose=False):\n"
"... om verbose:\n"
"... print(\"Styrka i siffror, va?\", end=\" \")\n"
"... print(arg)\n"
"...\n"
">>> @fun.register\n"
"... def _(arg: lista, verbose=False):\n"
"... om verbose:\n"
"... print(\"Räkna upp detta:\")\n"
"... för i, elem i enumerate(arg):\n"
"... print(i, elem)"

msgid ":class:`typing.Union` can also be used::"
msgstr ":class:`typing.Union` kan också användas::"

msgid ""
">>> @fun.register\n"
"... def _(arg: int | float, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Strength in numbers, eh?\", end=\" \")\n"
"...     print(arg)\n"
"...\n"
">>> from typing import Union\n"
">>> @fun.register\n"
"... def _(arg: Union[list, set], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)\n"
"..."
msgstr ""
">>> @fun.register\n"
"... def _(arg: int | float, verbose=False):\n"
"... om verbose:\n"
"... print(\"Styrka i siffror, va?\", end=\" \")\n"
"... print(arg)\n"
"...\n"
">>> från typing import Union\n"
">>> @fun.register\n"
"... def _(arg: Union[list, set], verbose=False):\n"
"... om verbose:\n"
"... print(\"Räkna upp detta:\")\n"
"... for i, elem in enumerate(arg):\n"
"... print(i, elem)\n"
"..."

msgid ""
"For code which doesn't use type annotations, the appropriate type argument "
"can be passed explicitly to the decorator itself::"
msgstr ""
"För kod som inte använder typannoteringar kan det lämpliga typargumentet "
"skickas explicit till själva dekoratorn::"

msgid ""
">>> @fun.register(complex)\n"
"... def _(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Better than complicated.\", end=\" \")\n"
"...     print(arg.real, arg.imag)\n"
"..."
msgstr ""
">>> @fun.register(komplex)\n"
"... def _(arg, verbose=False):\n"
"... om verbose:\n"
"... print(\"Bättre än komplicerat.\", end=\" \")\n"
"... print(arg.real, arg.imag)\n"
"..."

msgid ""
"For code that dispatches on a collections type (e.g., ``list``), but wants "
"to typehint the items of the collection (e.g., ``list[int]``), the dispatch "
"type should be passed explicitly to the decorator itself with the typehint "
"going into the function definition::"
msgstr ""
"För kod som skickar på en samlingstyp (t.ex. ``list``), men som vill "
"typmarkera objekten i samlingen (t.ex. ``list[int]``), bör sändningstypen "
"skickas uttryckligen till dekoratorn själv med typmarkeringen som går in i "
"funktionsdefinitionen::"

msgid ""
">>> @fun.register(list)\n"
"... def _(arg: list[int], verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Enumerate this:\")\n"
"...     for i, elem in enumerate(arg):\n"
"...         print(i, elem)"
msgstr ""
">>> @fun.register(lista)\n"
"... def _(arg: list[int], verbose=False):\n"
"... om verbose:\n"
"... print(\"Räkna upp detta:\")\n"
"... for i, elem in enumerate(arg):\n"
"... print(i, elem)"

msgid ""
"At runtime the function will dispatch on an instance of a list regardless of "
"the type contained within the list i.e. ``[1,2,3]`` will be dispatched the "
"same as ``[\"foo\", \"bar\", \"baz\"]``. The annotation provided in this "
"example is for static type checkers only and has no runtime impact."
msgstr ""
"Vid körning kommer funktionen att skickas till en instans av en lista "
"oavsett vilken typ som finns i listan, dvs. ``[1,2,3]`` kommer att skickas "
"på samma sätt som ``[\"foo\", \"bar\", \"baz\"]``. Annoteringen i det här "
"exemplet är endast avsedd för statiska typkontrollanter och har ingen "
"inverkan på körtiden."

msgid ""
"To enable registering :term:`lambdas<lambda>` and pre-existing functions, "
"the :func:`~singledispatch.register` attribute can also be used in a "
"functional form::"
msgstr ""
"För att möjliggöra registrering av :term:`lambdas<lambda>` och redan "
"existerande funktioner kan attributet :func:`~singledispatch.register` också "
"användas i en funktionell form::"

msgid ""
">>> def nothing(arg, verbose=False):\n"
"...     print(\"Nothing.\")\n"
"...\n"
">>> fun.register(type(None), nothing)"
msgstr ""
">>> def nothing(arg, verbose=False):\n"
"... print(\"Ingenting.\")\n"
"...\n"
">>> fun.register(typ(None), ingenting)"

msgid ""
"The :func:`~singledispatch.register` attribute returns the undecorated "
"function. This enables decorator stacking, :mod:`pickling<pickle>`, and the "
"creation of unit tests for each variant independently::"
msgstr ""
"Attributet :func:`~singledispatch.register` returnerar den odekorerade "
"funktionen. Detta möjliggör stapling av dekoratorer, :mod:"
"``pickling<pickle>``, och skapandet av enhetstester för varje variant "
"oberoende av varandra::"

msgid ""
">>> @fun.register(float)\n"
"... @fun.register(Decimal)\n"
"... def fun_num(arg, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Half of your number:\", end=\" \")\n"
"...     print(arg / 2)\n"
"...\n"
">>> fun_num is fun\n"
"False"
msgstr ""
">>> @fun.register(float)\n"
"... @fun.register(decimal)\n"
"... def fun_num(arg, verbose=False):\n"
"... om verbose:\n"
"... print(\"Hälften av ditt tal:\", end=\" \")\n"
"... print(arg / 2)\n"
"...\n"
">>> fun_num är fun\n"
"Falskt"

msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr ""
"När den generiska funktionen anropas dispatchas den utifrån typen av det "
"första argumentet::"

msgid ""
">>> fun(\"Hello, world.\")\n"
"Hello, world.\n"
">>> fun(\"test.\", verbose=True)\n"
"Let me just say, test.\n"
">>> fun(42, verbose=True)\n"
"Strength in numbers, eh? 42\n"
">>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)\n"
"Enumerate this:\n"
"0 spam\n"
"1 spam\n"
"2 eggs\n"
"3 spam\n"
">>> fun(None)\n"
"Nothing.\n"
">>> fun(1.23)\n"
"0.615"
msgstr ""
">>> fun(\"Hej, världen.\")\n"
"Hallå där i världen.\n"
">>> fun(\"test.\", verbose=True)\n"
"Låt mig bara säga, test.\n"
">>> fun(42, verbose=True)\n"
"Styrka i siffror, eller hur? 42\n"
">>> fun(['spam', 'spam', 'ägg', 'spam'], verbose=True)\n"
"Räkna upp detta:\n"
"0 skräppost\n"
"1 skräppost\n"
"2 ägg\n"
"3 skräppost\n"
">>> fun(Ingen)\n"
"Ingenting.\n"
">>> fun(1.23)\n"
"0.615"

msgid ""
"Where there is no registered implementation for a specific type, its method "
"resolution order is used to find a more generic implementation. The original "
"function decorated with ``@singledispatch`` is registered for the base :"
"class:`object` type, which means it is used if no better implementation is "
"found."
msgstr ""
"Om det inte finns någon registrerad implementation för en viss typ används "
"dess metodupplösningsordning för att hitta en mer generisk implementation. "
"Den ursprungliga funktionen dekorerad med ``@singledispatch`` är registrerad "
"för bastypen :class:`object`, vilket innebär att den används om ingen bättre "
"implementation hittas."

msgid ""
"If an implementation is registered to an :term:`abstract base class`, "
"virtual subclasses of the base class will be dispatched to that "
"implementation::"
msgstr ""
"Om en implementation är registrerad för en :term:`abstrakt basklass`, kommer "
"virtuella subklasser av basklassen att skickas till denna implementation::"

msgid ""
">>> from collections.abc import Mapping\n"
">>> @fun.register\n"
"... def _(arg: Mapping, verbose=False):\n"
"...     if verbose:\n"
"...         print(\"Keys & Values\")\n"
"...     for key, value in arg.items():\n"
"...         print(key, \"=>\", value)\n"
"...\n"
">>> fun({\"a\": \"b\"})\n"
"a => b"
msgstr ""
">>> från collections.abc import Mapping\n"
">>> @fun.register\n"
"... def _(arg: Mapping, verbose=False):\n"
"... om verbose:\n"
"... print(\"Nycklar och värden\")\n"
"... för nyckel, värde i arg.items():\n"
"... print(nyckel, \"=>\", värde)\n"
"...\n"
">>> fun({\"a\": \"b\"})\n"
"a => b"

msgid ""
"To check which implementation the generic function will choose for a given "
"type, use the ``dispatch()`` attribute::"
msgstr ""
"För att kontrollera vilken implementering den generiska funktionen kommer "
"att välja för en viss typ, använd attributet ``dispatch()``::"

msgid ""
">>> fun.dispatch(float)\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.dispatch(dict)    # note: default implementation\n"
"<function fun at 0x103fe0000>"
msgstr ""
"&gt;&gt;&gt; fun.dispatch(float)\n"
"<function fun_num at 0x1035a2840>\n"
"&gt;&gt;&gt; fun.dispatch(dict) # notera: standardimplementering\n"
"<function fun at 0x103fe0000>"

msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr ""
"För att få tillgång till alla registrerade implementationer, använd det "
"skrivskyddade attributet ``registry``::"

msgid ""
">>> fun.registry.keys()\n"
"dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,\n"
"          <class 'decimal.Decimal'>, <class 'list'>,\n"
"          <class 'float'>])\n"
">>> fun.registry[float]\n"
"<function fun_num at 0x1035a2840>\n"
">>> fun.registry[object]\n"
"<function fun at 0x103fe0000>"
msgstr ""
"&gt;&gt;&gt; fun.registry.keys()\n"
"dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,\n"
"         <class 'decimal.Decimal'>, <class 'list'>,\n"
"         <class 'float'>])\n"
"&gt;&gt;&gt; fun.registry[float]\n"
"<function fun_num at 0x1035a2840>\n"
"&gt;&gt;&gt; fun.registry[objekt]\n"
"<function fun at 0x103fe0000>"

msgid ""
"The :func:`~singledispatch.register` attribute now supports using type "
"annotations."
msgstr ""
"Attributet :func:`~singledispatch.register` stöder nu användning av "
"typannoteringar."

msgid ""
"The :func:`~singledispatch.register` attribute now supports :class:`typing."
"Union` as a type annotation."
msgstr ""
"Attributet :func:`~singledispatch.register` stöder nu :class:`typing.Union` "
"som typannotering."

msgid ""
"Transform a method into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"Omvandla en metod till en :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."

msgid ""
"To define a generic method, decorate it with the ``@singledispatchmethod`` "
"decorator. When defining a function using ``@singledispatchmethod``, note "
"that the dispatch happens on the type of the first non-*self* or non-*cls* "
"argument::"
msgstr ""
"För att definiera en generisk metod, dekorera den med dekoratorn "
"``@singledispatchmethod``. När du definierar en funktion med hjälp av "
"``@singledispatchmethod``, observera att dispatch sker på typen av det "
"första argumentet som inte är *self* eller *cls*::"

msgid ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    def neg(self, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: bool):\n"
"        return not arg"
msgstr ""
"klass Negator:\n"
"    @singledispatchmetod\n"
"    def neg(self, arg):\n"
"        raise NotImplementedError(\"Kan inte negera a\")\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    def _(self, arg: bool):\n"
"        returnerar inte arg"

msgid ""
"``@singledispatchmethod`` supports nesting with other decorators such as :"
"func:`@classmethod<classmethod>`. Note that to allow for ``dispatcher."
"register``, ``singledispatchmethod`` must be the *outer most* decorator. "
"Here is the ``Negator`` class with the ``neg`` methods bound to the class, "
"rather than an instance of the class::"
msgstr ""
"``@singledispatchmethod`` stöder nestning med andra dekoratorer som :func:"
"`@classmethod<classmethod>`. Notera att för att tillåta ``dispatcher."
"register`` måste ``singledispatchmethod`` vara den *yttersta* dekoratorn. "
"Här är ``Negator`` klassen med ``neg`` metoderna bundna till klassen, "
"snarare än en instans av klassen::"

msgid ""
"class Negator:\n"
"    @singledispatchmethod\n"
"    @classmethod\n"
"    def neg(cls, arg):\n"
"        raise NotImplementedError(\"Cannot negate a\")\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: int):\n"
"        return -arg\n"
"\n"
"    @neg.register\n"
"    @classmethod\n"
"    def _(cls, arg: bool):\n"
"        return not arg"
msgstr ""
"klass Negator:\n"
"    @singledispatchmetod\n"
"    @klassmetod\n"
"    def neg(cls, arg):\n"
"        raise NotImplementedError(\"Kan inte negera a\")\n"
"\n"
"    @neg.register\n"
"    @klassmetod\n"
"    def _(cls, arg: int):\n"
"        returnerar -arg\n"
"\n"
"    @neg.register\n"
"    @klassmetod\n"
"    def _(cls, arg: bool):\n"
"        returnerar inte arg"

msgid ""
"The same pattern can be used for other similar decorators: :func:"
"`@staticmethod<staticmethod>`, :func:`@abstractmethod<abc.abstractmethod>`, "
"and others."
msgstr ""
"Samma mönster kan användas för andra liknande dekoratorer: :func:"
"`@staticmethod<staticmethod>`, :func:`@abstractmethod<abc.abstractmethod>`, "
"och andra."

msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original "
"function are assigned directly to the matching attributes on the wrapper "
"function and which attributes of the wrapper function are updated with the "
"corresponding attributes from the original function. The default values for "
"these arguments are the module level constants ``WRAPPER_ASSIGNMENTS`` "
"(which assigns to the wrapper function's :attr:`~function.__module__`, :attr:"
"`~function.__name__`, :attr:`~function.__qualname__`, :attr:`~function."
"__annotations__`, :attr:`~function.__type_params__`, and :attr:`~function."
"__doc__`, the documentation string) and ``WRAPPER_UPDATES`` (which updates "
"the wrapper function's :attr:`~function.__dict__`, i.e. the instance "
"dictionary)."
msgstr ""
"Uppdaterar en *omslagsfunktion* så att den ser ut som den *omhöljda* "
"funktionen. De valfria argumenten är tupler som anger vilka attribut i "
"originalfunktionen som tilldelas direkt till de matchande attributen i "
"omslagsfunktionen och vilka attribut i omslagsfunktionen som uppdateras med "
"motsvarande attribut från originalfunktionen. Standardvärdena för dessa "
"argument är modulnivåkonstanterna ``WRAPPER_ASSIGNMENTS`` (som tilldelar "
"omslagsfunktionens :attr:`~function.__module__`, :attr:`~function."
"__name__`, :attr:`~function.__qualname__`, :attr:`~function."
"__annotations__`, :attr:`~function.__type_params__`, och :attr:`~function."
"__doc__`, dokumentationssträngen) och ``WRAPPER_UPDATES`` (som uppdaterar "
"omslagsfunktionens :attr:`~function.__dict__`, dvs. instansordboken)."

msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the wrapper "
"that refers to the function being wrapped."
msgstr ""
"För att tillåta åtkomst till originalfunktionen för introspektion och andra "
"ändamål (t.ex. kringgå en cachningsdekorator som :func:`lru_cache`), lägger "
"denna funktion automatiskt till ett ``__wrapped__``-attribut till omslaget "
"som refererar till den funktion som omslaget avser."

msgid ""
"The main intended use for this function is in :term:`decorator` functions "
"which wrap the decorated function and return the wrapper. If the wrapper "
"function is not updated, the metadata of the returned function will reflect "
"the wrapper definition rather than the original function definition, which "
"is typically less than helpful."
msgstr ""
"Den här funktionen är främst avsedd att användas i :term:`decorator`-"
"funktioner som omsluter den dekorerade funktionen och returnerar omslaget. "
"Om omslutningsfunktionen inte uppdateras kommer metadata för den returnerade "
"funktionen att återspegla omslutningsdefinitionen snarare än den "
"ursprungliga funktionsdefinitionen, vilket vanligtvis inte är till någon "
"större hjälp."

msgid ""
":func:`update_wrapper` may be used with callables other than functions. Any "
"attributes named in *assigned* or *updated* that are missing from the object "
"being wrapped are ignored (i.e. this function will not attempt to set them "
"on the wrapper function). :exc:`AttributeError` is still raised if the "
"wrapper function itself is missing any attributes named in *updated*."
msgstr ""
":func:`update_wrapper` kan användas med andra anropbara objekt än "
"funktioner. Alla attribut som namnges i *assigned* eller *updated* som "
"saknas från objektet som omsluts ignoreras (dvs. denna funktion kommer inte "
"att försöka ställa in dem på omslutningsfunktionen). :exc:`AttributeError` "
"utlöses fortfarande om omslutningsfunktionen själv saknar några attribut som "
"namnges i *updated*."

msgid ""
"The ``__wrapped__`` attribute is now automatically added. The :attr:"
"`~function.__annotations__` attribute is now copied by default. Missing "
"attributes no longer trigger an :exc:`AttributeError`."
msgstr ""
"Attributet ``__wrapped__`` läggs nu till automatiskt. Attributet :attr:"
"`~function.__annotations__` kopieras nu som standard. Saknade attribut "
"utlöser inte längre ett :exc:`AttributeError`."

msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see :issue:"
"`17482`)"
msgstr ""
"Attributet ``__wrapped__`` hänvisar nu alltid till den inkapslade "
"funktionen, även om den funktionen definierade attributet ``__wrapped__``. "
"(se :issue:`17482`)"

msgid ""
"The :attr:`~function.__type_params__` attribute is now copied by default."
msgstr "Attributet :attr:`~function.__type_params__` kopieras nu som standard."

msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"Detta är en bekvämlighetsfunktion för att anropa :func:`update_wrapper` som "
"en funktionsdekorator när man definierar en omslagsfunktion.  Den är "
"likvärdig med ``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. Till exempel::"

msgid ""
">>> from functools import wraps\n"
">>> def my_decorator(f):\n"
"...     @wraps(f)\n"
"...     def wrapper(*args, **kwds):\n"
"...         print('Calling decorated function')\n"
"...         return f(*args, **kwds)\n"
"...     return wrapper\n"
"...\n"
">>> @my_decorator\n"
"... def example():\n"
"...     \"\"\"Docstring\"\"\"\n"
"...     print('Called example function')\n"
"...\n"
">>> example()\n"
"Calling decorated function\n"
"Called example function\n"
">>> example.__name__\n"
"'example'\n"
">>> example.__doc__\n"
"'Docstring'"
msgstr ""
">>> from functools import wraps\n"
">>> def my_decorator(f):\n"
"...     @wraps(f)\n"
"...     def wrapper(*args, **kwds):\n"
"...         print('Calling decorated function')\n"
"...         return f(*args, **kwds)\n"
"...     return wrapper\n"
"...\n"
">>> @my_decorator\n"
"... def example():\n"
"...     \"\"\"Docstring\"\"\"\n"
"...     print('Called example function')\n"
"...\n"
">>> example()\n"
"Calling decorated function\n"
"Called example function\n"
">>> example.__name__\n"
"'example'\n"
">>> example.__doc__\n"
"'Docstring'"

msgid ""
"Without the use of this decorator factory, the name of the example function "
"would have been ``'wrapper'``, and the docstring of the original :func:`!"
"example` would have been lost."
msgstr ""
"Utan denna dekoratorfabrik skulle namnet på exempelfunktionen ha varit "
"``'wrapper'``, och dokumentsträngen för den ursprungliga :func:`!example` "
"skulle ha gått förlorad."

msgid ":class:`partial` Objects"
msgstr ":class:`partial` Objekt"

msgid ""
":class:`partial` objects are callable objects created by :func:`partial`. "
"They have three read-only attributes:"
msgstr ""
":class:`partial`-objekt är anropsbara objekt som skapas av :func:`partial`. "
"De har tre skrivskyddade attribut:"

msgid ""
"A callable object or function.  Calls to the :class:`partial` object will be "
"forwarded to :attr:`func` with new arguments and keywords."
msgstr ""
"Ett anropsbart objekt eller en funktion.  Anrop till objektet :class:"
"`partial` kommer att vidarebefordras till :attr:`func` med nya argument och "
"nyckelord."

msgid ""
"The leftmost positional arguments that will be prepended to the positional "
"arguments provided to a :class:`partial` object call."
msgstr ""
"De positionella argument längst till vänster som kommer att läggas till de "
"positionella argument som anges i ett :class:`partial`-objektanrop."

msgid ""
"The keyword arguments that will be supplied when the :class:`partial` object "
"is called."
msgstr ""
"De nyckelordsargument som kommer att anges när objektet :class:`partial` "
"anropas."

msgid ""
":class:`partial` objects are like :ref:`function objects <user-defined-"
"funcs>` in that they are callable, weak referenceable, and can have "
"attributes.  There are some important differences.  For instance, the :attr:"
"`~definition.__name__` and :attr:`~definition.__doc__` attributes are not "
"created automatically."
msgstr ""
":class:`partial`-objekt är som :ref:`funktionsobjekt <user-defined-funcs>` i "
"det att de är anropsbara, svagt refererbara och kan ha attribut.  Det finns "
"några viktiga skillnader.  Exempelvis skapas inte attributen :attr:"
"`~definition.__name__` och :attr:`~definition.__doc__` automatiskt."
