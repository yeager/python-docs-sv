# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Library and Extension FAQ"
msgstr "Frågor och svar om biblioteket och extension"

msgid "Contents"
msgstr "Innehåll"

msgid "General Library Questions"
msgstr "Allmänna frågor om biblioteket"

msgid "How do I find a module or application to perform task X?"
msgstr "Hur hittar jag en modul eller applikation för att utföra uppgift X?"

msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the "
"standard library and will be able to skip this step.)"
msgstr ""
"Kontrollera :ref:``the Library Reference <library-index>`` för att se om det "
"finns en relevant modul i standardbiblioteket.  (Så småningom lär du dig vad "
"som finns i standardbiblioteket och kan då hoppa över det här steget)"

msgid ""
"For third-party packages, search the `Python Package Index <https://pypi."
"org>`_ or try `Google <https://www.google.com>`_ or another web search "
"engine.  Searching for \"Python\" plus a keyword or two for your topic of "
"interest will usually find something helpful."
msgstr ""
"För tredjepartspaket, sök i `Python Package Index <https://pypi.org>`_ eller "
"prova `Google <https://www.google.com>`_ eller en annan webbsökmotor.  Om du "
"söker efter \"Python\" plus ett eller två nyckelord för det ämne du är "
"intresserad av hittar du vanligtvis något användbart."

msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr "Var är källfilen math.py (socket.py, regex.py, etc.)?"

msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled language. "
"In this case you may not have the source file or it may be something like :"
"file:`mathmodule.c`, somewhere in a C source directory (not on the Python "
"Path)."
msgstr ""
"Om du inte kan hitta en källfil för en modul kan det vara en inbyggd eller "
"dynamiskt laddad modul som implementerats i C, C++ eller annat kompilerat "
"språk. I det här fallet kanske du inte har källfilen eller så kan den vara "
"något i stil med :file:`mathmodule.c`, någonstans i en C-källkatalog (inte "
"på Python Path)."

msgid "There are (at least) three kinds of modules in Python:"
msgstr "Det finns (minst) tre olika typer av moduler i Python:"

msgid "modules written in Python (.py);"
msgstr "moduler skrivna i Python (.py);"

msgid ""
"modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr "moduler skrivna i C och dynamiskt laddade (.dll, .pyd, .so, .sl, etc);"

msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr ""
"moduler skrivna i C och länkade med tolken; för att få en lista över dessa, "
"skriv::"

msgid ""
"import sys\n"
"print(sys.builtin_module_names)"
msgstr ""
"import sys\n"
"print(sys.builtin_module_names)"

msgid "How do I make a Python script executable on Unix?"
msgstr "Hur gör jag ett Python-skript körbart på Unix?"

msgid ""
"You need to do two things: the script file's mode must be executable and the "
"first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr ""
"Du måste göra två saker: skriptfilens läge måste vara exekverbart och den "
"första raden måste börja med ``#!`` följt av sökvägen till Python-tolken."

msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod "
"755 scriptfile``."
msgstr ""
"Det första görs genom att köra ``chmod +x scriptfile`` eller kanske ``chmod "
"755 scriptfile``."

msgid ""
"The second can be done in a number of ways.  The most straightforward way is "
"to write ::"
msgstr ""
"Det andra kan göras på ett antal olika sätt.  Det mest okomplicerade sättet "
"är att skriva ::"

msgid "#!/usr/local/bin/python"
msgstr "#!/usr/local/bin/python"

msgid ""
"as the very first line of your file, using the pathname for where the Python "
"interpreter is installed on your platform."
msgstr ""
"som den allra första raden i din fil, med sökvägen till den plats där Python-"
"tolken är installerad på din plattform."

msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all Unix "
"variants support the following, assuming the Python interpreter is in a "
"directory on the user's :envvar:`PATH`::"
msgstr ""
"Om du vill att skriptet ska vara oberoende av var Python-tolken finns, kan "
"du använda programmet :program:`env`.  Nästan alla Unix-varianter stöder "
"följande, förutsatt att Python-tolken finns i en katalog på användarens :"
"envvar:`PATH`::"

msgid "#!/usr/bin/env python"
msgstr "#!/usr/bin/env python"

msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr ""
"*Gör inte* detta för CGI-skript.  Variabeln :envvar:`PATH` för CGI-skript är "
"ofta mycket minimal, så du måste använda det faktiska absoluta sökvägsnamnet "
"för tolken."

msgid ""
"Occasionally, a user's environment is so full that the :program:`/usr/bin/"
"env` program fails; or there's no env program at all.  In that case, you can "
"try the following hack (due to Alex Rezinsky):"
msgstr ""
"Ibland är en användares miljö så full att programmet :program:`/usr/bin/env` "
"misslyckas; eller så finns det inget env-program alls.  I så fall kan du "
"prova följande hack (tack vare Alex Rezinsky):"

msgid ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exec python $0 ${1+\"$@\"}\n"
"\"\"\""
msgstr ""
"#! /bin/sh\n"
"\"\"\":\"\n"
"exekvera python $0 ${1+\"$@\"}\n"
"\"\"\""

msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr ""
"Den lilla nackdelen är att detta definierar skriptets __doc__-sträng. Du kan "
"dock åtgärda det genom att lägga till ::"

msgid "__doc__ = \"\"\"...Whatever...\"\"\""
msgstr "__doc__ = \"\"\"...Vad som helst...\"\"\""

msgid "Is there a curses/termcap package for Python?"
msgstr "Finns det ett curses/termcap-paket för Python?"

msgid ""
"For Unix variants: The standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr ""
"För Unix-varianter: Standarddistributionen av Python-källkod innehåller en "
"curses-modul i underkatalogen :source:`Modules`, men den är inte kompilerad "
"som standard. (Observera att detta inte är tillgängligt i Windows-"
"distributionen - det finns ingen curses-modul för Windows)"

msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means the "
"module isn't compatible with operating systems that only have BSD curses, "
"but there don't seem to be any currently maintained OSes that fall into this "
"category."
msgstr ""
"Modulen :mod:`curses` stöder de grundläggande funktionerna i curses samt "
"många ytterligare funktioner från ncurses och SYSV curses, t.ex. färg, stöd "
"för alternativa teckenuppsättningar, block och musstöd. Detta innebär att "
"modulen inte är kompatibel med operativsystem som endast har BSD curses, men "
"det verkar inte finnas några operativsystem som för närvarande underhålls "
"som faller inom denna kategori."

msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "Finns det en motsvarighet till C:s onexit() i Python?"

msgid ""
"The :mod:`atexit` module provides a register function that is similar to "
"C's :c:func:`!onexit`."
msgstr ""
"Modulen :mod:`atexit` tillhandahåller en registerfunktion som liknar C:s :c:"
"func:`!onexit`."

msgid "Why don't my signal handlers work?"
msgstr "Varför fungerar inte mina signalhanterare?"

msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr ""
"Det vanligaste problemet är att signalhanteraren deklareras med fel "
"argumentlista.  Det kallas som ::"

msgid "handler(signum, frame)"
msgstr "handler(signum, ram)"

msgid "so it should be declared with two parameters::"
msgstr "så den bör deklareras med två parametrar::"

msgid ""
"def handler(signum, frame):\n"
"    ..."
msgstr ""
"def handler(signum, ram):\n"
"    ..."

msgid "Common tasks"
msgstr "Vanliga uppgifter"

msgid "How do I test a Python program or component?"
msgstr "Hur testar jag ett Python-program eller en Python-komponent?"

msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module finds "
"examples in the docstrings for a module and runs them, comparing the output "
"with the expected output given in the docstring."
msgstr ""
"Python levereras med två testramverk.  Modulen :mod:`doctest` hittar exempel "
"i dokumentationen för en modul, kör dem och jämför resultatet med det "
"förväntade resultatet som anges i dokumentationen."

msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on Java "
"and Smalltalk testing frameworks."
msgstr ""
"Modulen :mod:`unittest` är ett mer avancerat testramverk som bygger på "
"testramverken för Java och Smalltalk."

msgid ""
"To make testing easier, you should use good modular design in your program. "
"Your program should have almost all functionality encapsulated in either "
"functions or class methods -- and this sometimes has the surprising and "
"delightful effect of making the program run faster (because local variable "
"accesses are faster than global accesses).  Furthermore the program should "
"avoid depending on mutating global variables, since this makes testing much "
"more difficult to do."
msgstr ""
"För att göra testningen enklare bör du använda en bra modulär design i ditt "
"program. Programmet bör ha nästan all funktionalitet inkapslad i antingen "
"funktioner eller klassmetoder -- och detta har ibland den överraskande och "
"förtjusande effekten att programmet körs snabbare (eftersom lokala "
"variabelåtkomster är snabbare än globala åtkomster).  Dessutom bör "
"programmet undvika att vara beroende av muterande globala variabler, "
"eftersom detta gör testning mycket svårare att genomföra."

msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr "Den \"globala huvudlogiken\" i ditt program kan vara så enkel som ::"

msgid ""
"if __name__ == \"__main__\":\n"
"    main_logic()"
msgstr ""
"om __name__ == \"__main__\":\n"
"    main_logic()"

msgid "at the bottom of the main module of your program."
msgstr "längst ner i huvudmodulen i ditt program."

msgid ""
"Once your program is organized as a tractable collection of function and "
"class behaviours, you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make coding "
"much more pleasant and fun by writing your test functions in parallel with "
"the \"production code\", since this makes it easy to find bugs and even "
"design flaws earlier."
msgstr ""
"När ditt program är organiserat som en hanterbar samling funktions- och "
"klassbeteenden bör du skriva testfunktioner som utövar beteendena.  En "
"testsvit som automatiserar en sekvens av tester kan associeras med varje "
"modul. Det här låter som en massa arbete, men eftersom Python är så "
"kortfattat och flexibelt är det förvånansvärt enkelt.  Du kan göra kodningen "
"mycket trevligare och roligare genom att skriva dina testfunktioner "
"parallellt med \"produktionskoden\", eftersom det gör det lätt att hitta "
"buggar och till och med designfel tidigare."

msgid ""
"\"Support modules\" that are not intended to be the main module of a program "
"may include a self-test of the module. ::"
msgstr ""
"\"Stödmoduler\" som inte är avsedda att vara huvudmodulen i ett program kan "
"innehålla ett självtest av modulen:"

msgid ""
"if __name__ == \"__main__\":\n"
"    self_test()"
msgstr ""
"if __name__ == \"__main__\":\n"
"    self_test()"

msgid ""
"Even programs that interact with complex external interfaces may be tested "
"when the external interfaces are unavailable by using \"fake\" interfaces "
"implemented in Python."
msgstr ""
"Även program som interagerar med komplexa externa gränssnitt kan testas när "
"de externa gränssnitten inte är tillgängliga genom att använda \"falska\" "
"gränssnitt som implementerats i Python."

msgid "How do I create documentation from doc strings?"
msgstr "Hur skapar jag dokumentation från dokumentsträngar?"

msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your Python "
"source code.  An alternative for creating API documentation purely from "
"docstrings is `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx <https://"
"www.sphinx-doc.org>`_ can also include docstring content."
msgstr ""
"Modulen :mod:`pydoc` kan skapa HTML från doc-strängarna i din Python-"
"källkod.  Ett alternativ för att skapa API-dokumentation enbart från "
"docstrings är `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx <https://"
"www.sphinx-doc.org>`_ kan också inkludera innehåll från docstrings."

msgid "How do I get a single keypress at a time?"
msgstr "Hur får jag en enda knapptryckning i taget?"

msgid ""
"For Unix variants there are several solutions.  It's straightforward to do "
"this using curses, but curses is a fairly large module to learn."
msgstr ""
"För Unix-varianter finns det flera lösningar.  Det är enkelt att göra detta "
"med hjälp av curses, men curses är en ganska stor modul att lära sig."

msgid "Threads"
msgstr "Trådar"

msgid "How do I program using threads?"
msgstr "Hur programmerar jag med trådar?"

msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`_thread` "
"module. The :mod:`threading` module builds convenient abstractions on top of "
"the low-level primitives provided by the :mod:`_thread` module."
msgstr ""
"Var noga med att använda modulen :mod:`threading` och inte modulen :mod:"
"`_thread`. Modulen :mod:`threading` bygger praktiska abstraktioner ovanpå de "
"primitiver på låg nivå som tillhandahålls av modulen :mod:`_thread`."

msgid "None of my threads seem to run: why?"
msgstr "Ingen av mina trådar verkar köras: varför?"

msgid ""
"As soon as the main thread exits, all threads are killed.  Your main thread "
"is running too quickly, giving the threads no time to do any work."
msgstr ""
"Så snart huvudtråden avslutas dödas alla trådar.  Din huvudtråd körs för "
"snabbt, vilket gör att trådarna inte hinner göra något arbete."

msgid ""
"A simple fix is to add a sleep to the end of the program that's long enough "
"for all the threads to finish::"
msgstr ""
"En enkel lösning är att lägga till en sleep i slutet av programmet som är "
"tillräckligt lång för att alla trådar ska hinna bli klara:"

msgid ""
"import threading, time\n"
"\n"
"def thread_task(name, n):\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)  # <---------------------------!"
msgstr ""
"import gängning, tid\n"
"\n"
"def thread_task(namn, n):\n"
"    för i i intervall(n):\n"
"        print(namn, i)\n"
"\n"
"för i inom intervallet(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10) # <---------------------------!"

msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear to "
"run sequentially, one at a time!  The reason is that the OS thread scheduler "
"doesn't start a new thread until the previous thread is blocked."
msgstr ""
"Men nu (på många plattformar) körs trådarna inte parallellt, utan verkar "
"köras sekventiellt, en i taget!  Anledningen är att OS:ets trådschemaläggare "
"inte startar en ny tråd förrän den föregående tråden har blockerats."

msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr ""
"En enkel lösning är att lägga till en liten sömn i början av körfunktionen::"

msgid ""
"def thread_task(name, n):\n"
"    time.sleep(0.001)  # <--------------------!\n"
"    for i in range(n):\n"
"        print(name, i)\n"
"\n"
"for i in range(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"time.sleep(10)"
msgstr ""
"def thread_task(namn, n):\n"
"    time.sleep(0.001) # <--------------------!\n"
"    för i i intervallet(n):\n"
"        print(namn, i)\n"
"\n"
"för i i intervallet(10):\n"
"    T = threading.Thread(target=thread_task, args=(str(i), i))\n"
"    T.start()\n"
"\n"
"tid.sömn(10)"

msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, it's "
"better to use some kind of semaphore mechanism.  One idea is to use the :mod:"
"`queue` module to create a queue object, let each thread append a token to "
"the queue when it finishes, and let the main thread read as many tokens from "
"the queue as there are threads."
msgstr ""
"Istället för att försöka gissa ett bra fördröjningsvärde för :func:`time."
"sleep` är det bättre att använda någon form av semaformekanism.  En idé är "
"att använda modulen :mod:`queue` för att skapa ett köobjekt, låta varje tråd "
"lägga till en token till kön när den är klar och låta huvudtråden läsa så "
"många tokens från kön som det finns trådar."

msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "Hur delar jag upp arbetet mellan ett antal arbetstrådar?"

msgid ""
"The easiest way is to use the :mod:`concurrent.futures` module, especially "
"the :mod:`~concurrent.futures.ThreadPoolExecutor` class."
msgstr ""
"Det enklaste sättet är att använda modulen :mod:`concurrent.futures`, "
"särskilt klassen :mod:`~concurrent.futures.ThreadPoolExecutor`."

msgid ""
"Or, if you want fine control over the dispatching algorithm, you can write "
"your own logic manually.  Use the :mod:`queue` module to create a queue "
"containing a list of jobs.  The :class:`~queue.Queue` class maintains a list "
"of objects and has a ``.put(obj)`` method that adds items to the queue and a "
"``.get()`` method to return them.  The class will take care of the locking "
"necessary to ensure that each job is handed out exactly once."
msgstr ""
"Eller, om du vill ha fin kontroll över dispatching-algoritmen, kan du skriva "
"din egen logik manuellt.  Använd modulen :mod:`queue` för att skapa en kö "
"som innehåller en lista med jobb.  Klassen :class:`~queue.Queue` underhåller "
"en lista med objekt och har en metod ``.put(obj)`` som lägger till objekt i "
"kön och en metod ``.get()`` som returnerar dem.  Klassen tar hand om den "
"låsning som krävs för att säkerställa att varje jobb delas ut exakt en gång."

msgid "Here's a trivial example::"
msgstr "Här är ett trivialt exempel::"

msgid ""
"import threading, queue, time\n"
"\n"
"# The worker thread gets jobs off the queue.  When the queue is empty, it\n"
"# assumes there will be no more work and exits.\n"
"# (Realistically workers will run until terminated.)\n"
"def worker():\n"
"    print('Running worker')\n"
"    time.sleep(0.1)\n"
"    while True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('queue empty')\n"
"            break\n"
"        else:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('running with argument', arg)\n"
"            time.sleep(0.5)\n"
"\n"
"# Create queue\n"
"q = queue.Queue()\n"
"\n"
"# Start a pool of 5 workers\n"
"for i in range(5):\n"
"    t = threading.Thread(target=worker, name='worker %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# Begin adding work to the queue\n"
"for i in range(50):\n"
"    q.put(i)\n"
"\n"
"# Give threads time to run\n"
"print('Main thread sleeping')\n"
"time.sleep(5)"
msgstr ""
"import trådning, kö, tid\n"
"\n"
"# Arbetartråden tar bort jobb från kön.  När kön är tom antar den\n"
"# antar den att det inte kommer att finnas mer arbete och avslutas.\n"
"# (Realistiskt sett körs arbetare tills de avslutas.)\n"
"def arbetare():\n"
"    print('Kör arbetare')\n"
"    time.sleep(0.1)\n"
"    medan True:\n"
"        try:\n"
"            arg = q.get(block=False)\n"
"        except queue.Empty:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('kö tom')\n"
"            break\n"
"        annars:\n"
"            print('Worker', threading.current_thread(), end=' ')\n"
"            print('kör med argument', arg)\n"
"            tid.sömn(0.5)\n"
"\n"
"# Skapa kö\n"
"q = queue.Queue()\n"
"\n"
"# Starta en pool med 5 arbetare\n"
"för i i intervallet(5):\n"
"    t = threading.Thread(target=arbetare, name='arbetare %i' % (i+1))\n"
"    t.start()\n"
"\n"
"# Börja lägga till arbete i kön\n"
"för i i intervallet(50):\n"
"    q.put(i)\n"
"\n"
"# Ge trådarna tid att köra\n"
"print('Huvudtråden sover')\n"
"time.sleep(5)"

msgid "When run, this will produce the following output:"
msgstr "När detta körs kommer det att ge följande resultat:"

msgid ""
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Running worker\n"
"Main thread sleeping\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 0\n"
"Worker <Thread(worker 2, started 130283824404752)> running with argument 1\n"
"Worker <Thread(worker 3, started 130283816012048)> running with argument 2\n"
"Worker <Thread(worker 4, started 130283807619344)> running with argument 3\n"
"Worker <Thread(worker 5, started 130283799226640)> running with argument 4\n"
"Worker <Thread(worker 1, started 130283832797456)> running with argument 5\n"
"..."
msgstr ""
"Löpande arbetare\n"
"Löpande arbetare\n"
"Löpande arbetare\n"
"Löpande arbetare\n"
"Löpande arbetare\n"
"Huvudtråden sover\n"
"Arbetare <Tråd(arbetare 1, startade 130283832797456)> körs med argument 0\n"
"Arbetare <Tråd (arbetare 2, startade 130283824404752)> körs med argument 1\n"
"Arbetare <Tråd (arbetare 3, startad 130283816012048)> körs med argument 2\n"
"Arbetare <Tråd (arbetare 4, startad 130283807619344)> körs med argument 3\n"
"Arbetare <Tråd (arbetare 5, startad 130283799226640)> körs med argument 4\n"
"Worker <Thread(worker 1, startad 130283832797456)> körs med argument 5\n"
"..."

msgid ""
"Consult the module's documentation for more details; the :class:`~queue."
"Queue` class provides a featureful interface."
msgstr ""
"Läs modulens dokumentation för mer information; klassen :class:`~queue."
"Queue` ger ett användbart gränssnitt."

msgid "What kinds of global value mutation are thread-safe?"
msgstr "Vilka typer av mutation av globala värden är tråd-säkra?"

msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that "
"only one thread runs in the Python VM at a time.  In general, Python offers "
"to switch among threads only between bytecode instructions; how frequently "
"it switches can be set via :func:`sys.setswitchinterval`.  Each bytecode "
"instruction and therefore all the C implementation code reached from each "
"instruction is therefore atomic from the point of view of a Python program."
msgstr ""
"En :term:``global interpreter lock`` (GIL) används internt för att "
"säkerställa att endast en tråd körs i Python VM åt gången.  I allmänhet "
"erbjuder Python att växla mellan trådar endast mellan bytecode-"
"instruktioner; hur ofta den växlar kan ställas in via :func:`sys."
"setswitchinterval`.  Varje bytecode-instruktion och därmed all C-"
"implementeringskod som nås från varje instruktion är därför atomisk ur ett "
"Python-programs synvinkel."

msgid ""
"In theory, this means an exact accounting requires an exact understanding of "
"the PVM bytecode implementation.  In practice, it means that operations on "
"shared variables of built-in data types (ints, lists, dicts, etc) that "
"\"look atomic\" really are."
msgstr ""
"I teorin innebär detta att en exakt redovisning kräver en exakt förståelse "
"av PVM:s bytecode-implementering.  I praktiken innebär det att operationer "
"på delade variabler av inbyggda datatyper (ints, lists, dicts, etc) som "
"\"ser atomiska ut\" verkligen är det."

msgid ""
"For example, the following operations are all atomic (L, L1, L2 are lists, "
"D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr ""
"Till exempel är följande operationer alla atomära (L, L1, L2 är listor, D, "
"D1, D2 är dikter, x, y är objekt, i, j är ints)::"

msgid ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.field = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.keys()"
msgstr ""
"L.append(x)\n"
"L1.extend(L2)\n"
"x = L[i]\n"
"x = L.pop()\n"
"L1[i:j] = L2\n"
"L.sort()\n"
"x = y\n"
"x.fält = y\n"
"D[x] = y\n"
"D1.update(D2)\n"
"D.nycklar()"

msgid "These aren't::"
msgstr "De här är inte::"

msgid ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"
msgstr ""
"i = i+1\n"
"L.append(L[-1])\n"
"L[i] = L[j]\n"
"D[x] = D[x] + 1"

msgid ""
"Operations that replace other objects may invoke those other objects' :meth:"
"`~object.__del__` method when their reference count reaches zero, and that "
"can affect things.  This is especially true for the mass updates to "
"dictionaries and lists.  When in doubt, use a mutex!"
msgstr ""
"Operationer som ersätter andra objekt kan åberopa dessa andra objekts :meth:"
"`~object.__del__`-metod när deras referensantal når noll, och det kan "
"påverka saker och ting.  Detta gäller särskilt för massuppdateringar av "
"lexikon och listor.  När du är osäker, använd en mutex!"

msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr "Kan vi inte bli av med det globala tolklåset?"

msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to "
"Python's deployment on high-end multiprocessor server machines, because a "
"multi-threaded Python program effectively only uses one CPU, due to the "
"insistence that (almost) all Python code can only run while the GIL is held."
msgstr ""
"Den :term:`global interpreter lock` (GIL) ses ofta som ett hinder för "
"Pythons användning på avancerade servermaskiner med flera processorer, "
"eftersom ett flertrådat Python-program i praktiken bara använder en CPU, på "
"grund av att (nästan) all Python-kod bara kan köras medan GIL hålls."

msgid ""
"With the approval of :pep:`703` work is now underway to remove the GIL from "
"the CPython implementation of Python.  Initially it will be implemented as "
"an optional compiler flag when building the interpreter, and so separate "
"builds will be available with and without the GIL.  Long-term, the hope is "
"to settle on a single build, once the performance implications of removing "
"the GIL are fully understood.  Python 3.13 is likely to be the first release "
"containing this work, although it may not be completely functional in this "
"release."
msgstr ""
"Med godkännande av :pep:`703` pågår nu arbetet med att ta bort GIL från "
"CPython-implementeringen av Python.  Inledningsvis kommer det att "
"implementeras som en valfri kompilatorflagga när tolken byggs, och därför "
"kommer separata byggen att finnas tillgängliga med och utan GIL.  På lång "
"sikt är förhoppningen att man ska kunna nöja sig med en enda version, när "
"man väl har förstått prestandakonsekvenserna av att ta bort GIL.  Python "
"3.13 kommer sannolikt att vara den första utgåvan som innehåller detta "
"arbete, även om det kanske inte är helt funktionellt i den här utgåvan."

msgid ""
"The current work to remove the GIL is based on a `fork of Python 3.9 with "
"the GIL removed <https://github.com/colesbury/nogil>`_ by Sam Gross. Prior "
"to that, in the days of Python 1.5, Greg Stein actually implemented a "
"comprehensive patch set (the \"free threading\" patches) that removed the "
"GIL and replaced it with fine-grained locking.  Adam Olsen did a similar "
"experiment in his `python-safethread <https://code.google.com/archive/p/"
"python-safethread>`_ project.  Unfortunately, both of these earlier "
"experiments exhibited a sharp drop in single-thread performance (at least "
"30% slower), due to the amount of fine-grained locking necessary to "
"compensate for the removal of the GIL.  The Python 3.9 fork is the first "
"attempt at removing the GIL with an acceptable performance impact."
msgstr ""
"Det nuvarande arbetet med att ta bort GIL är baserat på en `fork av Python "
"3.9 med GIL borttagen <https://github.com/colesbury/nogil>`_ av Sam Gross. "
"Dessförinnan, under Python 1.5, implementerade Greg Stein faktiskt en "
"omfattande patchuppsättning (\"free threading\"-patcherna) som tog bort GIL "
"och ersatte den med finkornig låsning.  Adam Olsen gjorde ett liknande "
"experiment i sitt `python-safethread <https://code.google.com/archive/p/"
"python-safethread>`_-projekt.  Tyvärr uppvisade båda dessa tidigare "
"experiment en kraftig minskning av prestandan för en tråd (minst 30% slägre) "
"på grund av mängden finkornig låsning som krävs för att kompensera för "
"borttagningen av GIL.  Python 3.9-gaffeln är det första försöket att ta bort "
"GIL med en acceptabel prestandapåverkan."

msgid ""
"The presence of the GIL in current Python releases doesn't mean that you "
"can't make good use of Python on multi-CPU machines! You just have to be "
"creative with dividing the work up between multiple *processes* rather than "
"multiple *threads*.  The :class:`~concurrent.futures.ProcessPoolExecutor` "
"class in the new :mod:`concurrent.futures` module provides an easy way of "
"doing so; the :mod:`multiprocessing` module provides a lower-level API in "
"case you want more control over dispatching of tasks."
msgstr ""
"Närvaron av GIL i nuvarande Python-utgåvor betyder inte att du inte kan "
"använda Python bra på multi-CPU-maskiner! Du måste bara vara kreativ när det "
"gäller att dela upp arbetet mellan flera *processer* snarare än flera "
"*trådar*.  Klassen :class:`~concurrent.futures.ProcessPoolExecutor` i den "
"nya :mod:`concurrent.futures`-modulen ger ett enkelt sätt att göra det; :mod:"
"`multiprocessing`-modulen ger ett API på lägre nivå om du vill ha mer "
"kontroll över utskick av uppgifter."

msgid ""
"Judicious use of C extensions will also help; if you use a C extension to "
"perform a time-consuming task, the extension can release the GIL while the "
"thread of execution is in the C code and allow other threads to get some "
"work done.  Some standard library modules such as :mod:`zlib` and :mod:"
"`hashlib` already do this."
msgstr ""
"Om du använder ett C-tillägg för att utföra en tidskrävande uppgift kan "
"tillägget släppa GIL medan exekveringstråden befinner sig i C-koden och låta "
"andra trådar få lite arbete gjort.  Vissa standardbiblioteksmoduler som :mod:"
"`zlib` och :mod:`hashlib` gör redan detta."

msgid ""
"An alternative approach to reducing the impact of the GIL is to make the GIL "
"a per-interpreter-state lock rather than truly global. This was :ref:`first "
"implemented in Python 3.12 <whatsnew312-pep684>` and is available in the C "
"API. A Python interface to it is expected in Python 3.13. The main "
"limitation to it at the moment is likely to be 3rd party extension modules, "
"since these must be written with multiple interpreters in mind in order to "
"be usable, so many older extension modules will not be usable."
msgstr ""
"En alternativ metod för att minska effekten av GIL är att göra GIL till ett "
"lås per tolkningsstatus i stället för ett globalt lås. Detta "
"implementerades :ref:`först i Python 3.12 <whatsnew312-pep684>` och finns "
"tillgängligt i C API. Ett Python-gränssnitt för det förväntas i Python 3.13. "
"Den största begränsningen för det just nu är sannolikt tilläggsmoduler från "
"tredje part, eftersom dessa måste skrivas med flera tolkar i åtanke för att "
"vara användbara, så många äldre tilläggsmoduler kommer inte att kunna "
"användas."

msgid "Input and Output"
msgstr "Inmatning och utmatning"

msgid "How do I delete a file? (And other file questions...)"
msgstr "Hur tar jag bort en fil? (Och andra frågor om filer...)"

msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for documentation, "
"see the :mod:`os` module.  The two functions are identical; :func:`~os."
"unlink` is simply the name of the Unix system call for this function."
msgstr ""
"Använd ``os.remove(filnamn)`` eller ``os.unlink(filnamn)``; för "
"dokumentation, se modulen :mod:`os`.  De två funktionerna är identiska; :"
"func:`~os.unlink` är helt enkelt namnet på Unix systemanrop för den här "
"funktionen."

msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to create "
"one. ``os.makedirs(path)`` will create any intermediate directories in "
"``path`` that don't exist. ``os.removedirs(path)`` will remove intermediate "
"directories as long as they're empty; if you want to delete an entire "
"directory tree and its contents, use :func:`shutil.rmtree`."
msgstr ""
"För att ta bort en katalog, använd :func:`os.rmdir`; använd :func:`os.mkdir` "
"för att skapa en. ``os.makedirs(path)`` skapar alla mellanliggande kataloger "
"i ``path`` som inte finns. ``os.removedirs(path)`` tar bort mellanliggande "
"kataloger så länge de är tomma; om du vill ta bort ett helt katalogträd och "
"dess innehåll, använd :func:`shutil.rmtree`."

msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr ""
"Om du vill byta namn på en fil använder du ``os.rename(old_path, new_path)``."

msgid ""
"To truncate a file, open it using ``f = open(filename, \"rb+\")``, and use "
"``f.truncate(offset)``; offset defaults to the current seek position.  "
"There's also ``os.ftruncate(fd, offset)`` for files opened with :func:`os."
"open`, where *fd* is the file descriptor (a small integer)."
msgstr ""
"För att trunkera en fil öppnar du den med ``f = open(filnamn, \"rb+\")`` och "
"använder ``f.truncate(offset)``; offset är standardvärdet för den aktuella "
"sökpositionen.  Det finns också ``os.ftruncate(fd, offset)`` för filer som "
"öppnas med :func:`os.open`, där *fd* är filbeskrivaren (ett litet heltal)."

msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and :"
"func:`~shutil.rmtree`."
msgstr ""
"Modulen :mod:`shutil` innehåller också ett antal funktioner för att arbeta "
"med filer, bland annat :func:`~shutil.copyfile`, :func:`~shutil.copytree` "
"och :func:`~shutil.rmtree`."

msgid "How do I copy a file?"
msgstr "Hur kopierar jag en fil?"

msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function. Note "
"that on Windows NTFS volumes, it does not copy `alternate data streams "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nor "
"`resource forks <https://en.wikipedia.org/wiki/Resource_fork>`__ on macOS "
"HFS+ volumes, though both are now rarely used. It also doesn't copy file "
"permissions and metadata, though using :func:`shutil.copy2` instead will "
"preserve most (though not all) of it."
msgstr ""
"Modulen :mod:`shutil` innehåller en :func:`~shutil.copyfile`-funktion. "
"Observera att på Windows NTFS-volymer kopieras inte `alternativa "
"dataströmmar <https://en.wikipedia.org/wiki/"
"NTFS#Alternate_data_stream_(ADS)>`_ eller `resursförgreningar <https://en."
"wikipedia.org/wiki/Resource_fork>`__ på macOS HFS+-volymer, även om båda nu "
"sällan används. Den kopierar inte heller filbehörigheter och metadata, men "
"om du använder :func:`shutil.copy2` istället bevaras det mesta (men inte "
"allt)."

msgid "How do I read (or write) binary data?"
msgstr "Hur läser (eller skriver) jag binära data?"

msgid ""
"To read or write complex binary data formats, it's best to use the :mod:"
"`struct` module.  It allows you to take a string containing binary data "
"(usually numbers) and convert it to Python objects; and vice versa."
msgstr ""
"För att läsa eller skriva komplexa binära dataformat är det bäst att använda "
"modulen :mod:`struct`.  Den låter dig ta en sträng som innehåller binära "
"data (vanligtvis siffror) och konvertera den till Python-objekt; och vice "
"versa."

msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr ""
"Följande kod läser till exempel två 2-bytes heltal och ett 4-bytes heltal i "
"big-endian-format från en fil::"

msgid ""
"import struct\n"
"\n"
"with open(filename, \"rb\") as f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"
msgstr ""
"import struct\n"
"\n"
"with open(filename, \"rb\") as f:\n"
"    s = f.read(8)\n"
"    x, y, z = struct.unpack(\">hhl\", s)"

msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads "
"one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr ""
"Bokstaven \">\" i formatsträngen tvingar fram big-endian-data; bokstaven "
"\"h\" läser ett \"kort heltal\" (2 byte) och \"l\" läser ett \"långt "
"heltal\" (4 byte) från strängen."

msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or floats), "
"you can also use the :mod:`array` module."
msgstr ""
"För data som är mer regelbundna (t.ex. en homogen lista med ints eller "
"floats) kan du också använda modulen :mod:`array`."

msgid ""
"To read and write binary data, it is mandatory to open the file in binary "
"mode (here, passing ``\"rb\"`` to :func:`open`).  If you use ``\"r\"`` "
"instead (the default), the file will be open in text mode and ``f.read()`` "
"will return :class:`str` objects rather than :class:`bytes` objects."
msgstr ""
"För att läsa och skriva binära data är det obligatoriskt att öppna filen i "
"binärt läge (här genom att skicka ``\"rb\"`` till :func:`open`).  Om du "
"istället använder ``\"r\"`` (standard) kommer filen att öppnas i textläge "
"och ``f.read()`` kommer att returnera :class:`str`-objekt istället för :"
"class:`bytes`-objekt."

msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr ""
"Jag verkar inte kunna använda os.read() på en pipe som skapats med os."
"popen(); varför?"

msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a high-"
"level file object, the same type returned by the built-in :func:`open` "
"function. Thus, to read *n* bytes from a pipe *p* created with :func:`os."
"popen`, you need to use ``p.read(n)``."
msgstr ""
":func:`os.read` är en lågnivåfunktion som tar en filbeskrivare, ett litet "
"heltal som representerar den öppnade filen. :func:`os.popen` skapar ett "
"filobjekt på hög nivå, samma typ som returneras av den inbyggda funktionen :"
"func:`open`. För att läsa *n* byte från en pipe *p* som skapats med :func:"
"`os.popen` måste du alltså använda ``p.read(n)``."

msgid "How do I access the serial (RS232) port?"
msgstr "Hur kommer jag åt den seriella (RS232) porten?"

msgid "For Win32, OSX, Linux, BSD, Jython, IronPython:"
msgstr "För Win32, OSX, Linux, BSD, Jython, IronPython:"

msgid ":pypi:`pyserial`"
msgstr ":pypi:`pyserial`"

msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "För Unix, se ett Usenet-inlägg av Mitch Chapman:"

msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr "Varför stänger inte sys.stdout (stdin, stderr) verkligen sys.stdout?"

msgid ""
"Python :term:`file objects <file object>` are a high-level layer of "
"abstraction on low-level C file descriptors."
msgstr ""
"Python :term:`filobjekt <file object>` är ett abstraktionslager på hög nivå "
"för C-filbeskrivare på låg nivå."

msgid ""
"For most file objects you create in Python via the built-in :func:`open` "
"function, ``f.close()`` marks the Python file object as being closed from "
"Python's point of view, and also arranges to close the underlying C file "
"descriptor.  This also happens automatically in ``f``'s destructor, when "
"``f`` becomes garbage."
msgstr ""
"För de flesta filobjekt som du skapar i Python via den inbyggda :func:`open`-"
"funktionen, markerar ``f.close()`` Python-filobjektet som stängt ur Pythons "
"synvinkel, och ser också till att stänga den underliggande C-"
"filbeskrivaren.  Detta sker också automatiskt i ``f``'s destruktor, när "
"``f`` blir skräp."

msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of the "
"special status also given to them by C.  Running ``sys.stdout.close()`` "
"marks the Python-level file object as being closed, but does *not* close the "
"associated C file descriptor."
msgstr ""
"Men stdin, stdout och stderr behandlas speciellt av Python, på grund av den "
"speciella status som de också har i C. Att köra ``sys.stdout.close()`` "
"markerar filobjektet på Python-nivå som stängt, men stänger *inte* den "
"associerade C-filbeskrivaren."

msgid ""
"To close the underlying C file descriptor for one of these three, you should "
"first be sure that's what you really want to do (e.g., you may confuse "
"extension modules trying to do I/O).  If it is, use :func:`os.close`::"
msgstr ""
"För att stänga den underliggande C-filbeskrivaren för en av dessa tre bör du "
"först vara säker på att det är vad du verkligen vill göra (t.ex. kan du "
"förvirra tilläggsmoduler som försöker göra I/O).  Om det är det, använd :"
"func:`os.close`::"

msgid ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"
msgstr ""
"os.close(stdin.fileno())\n"
"os.close(stdout.fileno())\n"
"os.close(stderr.fileno())"

msgid "Or you can use the numeric constants 0, 1 and 2, respectively."
msgstr "Eller så kan du använda de numeriska konstanterna 0, 1 respektive 2."

msgid "Network/Internet Programming"
msgstr "Programmering av nätverk/internet"

msgid "What WWW tools are there for Python?"
msgstr "Vilka WWW-verktyg finns det för Python?"

msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library "
"Reference Manual.  Python has many modules that will help you build server-"
"side and client-side web systems."
msgstr ""
"Se kapitlen :ref:`internet` och :ref:`netdata` i bibliotekets "
"referensmanual.  Python har många moduler som hjälper dig att bygga "
"webbsystem på server- och klientsidan."

msgid ""
"A summary of available frameworks is maintained by Paul Boddie at https://"
"wiki.python.org/moin/WebProgramming\\ ."
msgstr ""
"En sammanfattning av tillgängliga ramverk upprätthålls av Paul Boddie på "
"https://wiki.python.org/moin/WebProgramming ."

msgid "What module should I use to help with generating HTML?"
msgstr "Vilken modul ska jag använda för att generera HTML?"

msgid ""
"You can find a collection of useful links on the `Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_."
msgstr ""
"Du kan hitta en samling användbara länkar på wikisidan för webbprogrammering "
"<https://wiki.python.org/moin/WebProgramming>`_."

msgid "How do I send mail from a Python script?"
msgstr "Hur skickar jag e-post från ett Python-skript?"

msgid "Use the standard library module :mod:`smtplib`."
msgstr "Använd standardbiblioteksmodulen :mod:`smtplib`."

msgid ""
"Here's a very simple interactive mail sender that uses it.  This method will "
"work on any host that supports an SMTP listener. ::"
msgstr ""
"Här är en mycket enkel interaktiv e-postavsändare som använder den.  Den här "
"metoden fungerar på alla värdar som har stöd för en SMTP-lyssnare:"

msgid ""
"import sys, smtplib\n"
"\n"
"fromaddr = input(\"From: \")\n"
"toaddrs  = input(\"To: \").split(',')\n"
"print(\"Enter message, end with ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    line = sys.stdin.readline()\n"
"    if not line:\n"
"        break\n"
"    msg += line\n"
"\n"
"# The actual mail send\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"
msgstr ""
"import sys, smtplib\n"
"\n"
"fromaddr = input(\"From: \")\n"
"toaddrs  = input(\"To: \").split(',')\n"
"print(\"Enter message, end with ^D:\")\n"
"msg = ''\n"
"while True:\n"
"    line = sys.stdin.readline()\n"
"    if not line:\n"
"        break\n"
"    msg += line\n"
"\n"
"# The actual mail send\n"
"server = smtplib.SMTP('localhost')\n"
"server.sendmail(fromaddr, toaddrs, msg)\n"
"server.quit()"

msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail program "
"varies between systems; sometimes it is ``/usr/lib/sendmail``, sometimes ``/"
"usr/sbin/sendmail``.  The sendmail manual page will help you out.  Here's "
"some sample code::"
msgstr ""
"Ett alternativ för Unix använder sendmail.  Platsen för sendmail-programmet "
"varierar mellan olika system; ibland är det ``/usr/lib/sendmail``, ibland ``/"
"usr/sbin/sendmail``.  Manualsidan för sendmail hjälper dig.  Här är några "
"exempel på kod::"

msgid ""
"import os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\"  # sendmail location\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"To: receiver@example.com\\n\")\n"
"p.write(\"Subject: test\\n\")\n"
"p.write(\"\\n\")  # blank line separating headers from body\n"
"p.write(\"Some text\\n\")\n"
"p.write(\"some more text\\n\")\n"
"sts = p.close()\n"
"if sts != 0:\n"
"    print(\"Sendmail exit status\", sts)"
msgstr ""
"import os\n"
"\n"
"SENDMAIL = \"/usr/sbin/sendmail\"  # sendmail location\n"
"p = os.popen(\"%s -t -i\" % SENDMAIL, \"w\")\n"
"p.write(\"To: receiver@example.com\\n\")\n"
"p.write(\"Subject: test\\n\")\n"
"p.write(\"\\n\")  # blank line separating headers from body\n"
"p.write(\"Some text\\n\")\n"
"p.write(\"some more text\\n\")\n"
"sts = p.close()\n"
"if sts != 0:\n"
"    print(\"Sendmail exit status\", sts)"

msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr "Hur undviker jag blockering i connect()-metoden för ett uttag?"

msgid ""
"The :mod:`select` module is commonly used to help with asynchronous I/O on "
"sockets."
msgstr ""
"Modulen :mod:`select` används ofta för att hjälpa till med asynkron I/O på "
"socklar."

msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the :meth:`~socket.socket.connect`, you "
"will either connect immediately (unlikely) or get an exception that contains "
"the error number as ``.errno``. ``errno.EINPROGRESS`` indicates that the "
"connection is in progress, but hasn't finished yet.  Different OSes will "
"return different values, so you're going to have to check what's returned on "
"your system."
msgstr ""
"För att förhindra att TCP-anslutningen blockeras kan du ställa in uttaget "
"till icke-blockerande läge.  När du sedan gör :meth:`~socket.socket.connect` "
"kommer du antingen att ansluta omedelbart (osannolikt) eller få ett undantag "
"som innehåller felnumret som ``.errno``. ``errno.EINPROGRESS`` indikerar att "
"anslutningen pågår, men inte har avslutats ännu.  Olika operativsystem "
"kommer att returnera olika värden, så du måste kontrollera vad som "
"returneras på ditt system."

msgid ""
"You can use the :meth:`~socket.socket.connect_ex` method to avoid creating "
"an exception. It will just return the errno value. To poll, you can call :"
"meth:`~socket.socket.connect_ex` again later -- ``0`` or ``errno.EISCONN`` "
"indicate that you're connected -- or you can pass this socket to :meth:"
"`select.select` to check if it's writable."
msgstr ""
"Du kan använda metoden :meth:`~socket.socket.connect_ex` för att undvika att "
"skapa ett undantag. Den kommer bara att returnera errno värdet. För att "
"polla kan du anropa :meth:`~socket.socket.connect_ex` igen senare -- ``0`` "
"eller ``errno.EISCONN`` indikerar att du är ansluten -- eller så kan du "
"skicka denna socket till :meth:`select.select` för att kontrollera om den är "
"skrivbar."

msgid ""
"The :mod:`asyncio` module provides a general purpose single-threaded and "
"concurrent asynchronous library, which can be used for writing non-blocking "
"network code. The third-party `Twisted <https://twisted.org/>`_ library is a "
"popular and feature-rich alternative."
msgstr ""
"Modulen :mod:`asyncio` tillhandahåller ett allmänt asynkront bibliotek med "
"en enda tråd och samtidiga trådar, som kan användas för att skriva icke-"
"blockerande nätverkskod. Tredjepartsbiblioteket `Twisted <https://twisted."
"org/>`_ är ett populärt och funktionsrikt alternativ."

msgid "Databases"
msgstr "Databaser"

msgid "Are there any interfaces to database packages in Python?"
msgstr "Finns det några gränssnitt till databaspaket i Python?"

msgid "Yes."
msgstr "Ja."

msgid ""
"Interfaces to disk-based hashes such as :mod:`DBM <dbm.ndbm>` and :mod:`GDBM "
"<dbm.gnu>` are also included with standard Python.  There is also the :mod:"
"`sqlite3` module, which provides a lightweight disk-based relational "
"database."
msgstr ""
"Gränssnitt för diskbaserade hashar som :mod:`DBM <dbm.ndbm>` och :mod:`GDBM "
"<dbm.gnu>` ingår också i standard Python.  Det finns också modulen :mod:"
"`sqlite3`, som tillhandahåller en lättviktig diskbaserad relationsdatabas."

msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page <https://wiki.python.org/moin/"
"DatabaseProgramming>`_ for details."
msgstr ""
"Stöd för de flesta relationsdatabaser finns tillgängligt.  Se wikisidan "
"`DatabaseProgramming <https://wiki.python.org/moin/DatabaseProgramming>`_ "
"för mer information."

msgid "How do you implement persistent objects in Python?"
msgstr "Hur implementerar man persistenta objekt i Python?"

msgid ""
"The :mod:`pickle` library module solves this in a very general way (though "
"you still can't store things like open files, sockets or windows), and the :"
"mod:`shelve` library module uses pickle and (g)dbm to create persistent "
"mappings containing arbitrary Python objects."
msgstr ""
"Biblioteksmodulen :mod:`pickle` löser detta på ett mycket allmänt sätt (även "
"om du fortfarande inte kan lagra saker som öppna filer, sockets eller "
"fönster), och biblioteksmodulen :mod:`shelve` använder pickle och (g)dbm för "
"att skapa beständiga mappningar som innehåller godtyckliga Python-objekt."

msgid "Mathematics and Numerics"
msgstr "Matematik och numerik"

msgid "How do I generate random numbers in Python?"
msgstr "Hur genererar jag slumpmässiga nummer i Python?"

msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr ""
"Standardmodulen :mod:`random` implementerar en slumptalsgenerator.  "
"Användningen är enkel::"

msgid ""
"import random\n"
"random.random()"
msgstr ""
"import random\n"
"random.random()"

msgid "This returns a random floating-point number in the range [0, 1)."
msgstr "Detta returnerar ett slumpmässigt flyttal i intervallet [0, 1]."

msgid ""
"There are also many other specialized generators in this module, such as:"
msgstr ""
"Det finns också många andra specialiserade generatorer i denna modul, t.ex:"

msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr "``randrange(a, b)`` väljer ett heltal i intervallet [a, b]."

msgid "``uniform(a, b)`` chooses a floating-point number in the range [a, b)."
msgstr "``uniform(a, b)`` väljer ett flyttal i intervallet [a, b]."

msgid ""
"``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr ""
"``normalvariate(mean, sdev)`` samplar den normala (gaussiska) fördelningen."

msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr "Vissa funktioner på högre nivå arbetar direkt med sekvenser, t.ex:"

msgid "``choice(S)`` chooses a random element from a given sequence."
msgstr "``choice(S)`` väljer ett slumpmässigt element från en given sekvens."

msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly."
msgstr ""
"``shuffle(L)`` blandar en lista på plats, d.v.s. permuterar den slumpmässigt."

msgid ""
"There's also a ``Random`` class you can instantiate to create independent "
"multiple random number generators."
msgstr ""
"Det finns också en klass ``Random`` som du kan instansiera för att skapa "
"oberoende multipla slumptalsgeneratorer."
