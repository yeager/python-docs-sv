# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-09 14:17+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Parsing arguments and building values"
msgstr "Tolkning av argument och skapande av värden"

msgid ""
"These functions are useful when creating your own extension functions and "
"methods.  Additional information and examples are available in :ref:"
"`extending-index`."
msgstr ""
"Dessa funktioner är användbara när du skapar dina egna tilläggsfunktioner "
"och metoder.  Ytterligare information och exempel finns i :ref:`extending-"
"index`."

msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, :c:"
"func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"De tre först beskrivna funktionerna, :c:func:`PyArg_ParseTuple`, :c:func:"
"`PyArg_ParseTupleAndKeywords` och :c:func:`PyArg_Parse`, använder alla "
"*formatsträngar* som används för att tala om för funktionen vilka argument "
"som förväntas.  Formatsträngarna använder samma syntax för var och en av "
"dessa funktioner."

msgid "Parsing arguments"
msgstr "Tolkning av argument"

msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"En formatsträng består av noll eller fler \"formatenheter\"  En formatenhet "
"beskriver ett Python-objekt; det är vanligtvis ett enda tecken eller en "
"parentetisk sekvens av formatenheter.  Med några få undantag motsvarar en "
"formatenhet som inte är en parentetisk sekvens normalt ett enda "
"adressargument till dessa funktioner.  I följande beskrivning är den "
"citerade formen formatenheten; posten inom (runda) parenteser är Python-"
"objekttypen som matchar formatenheten; och posten inom [hakparenteser] är "
"typen av C-variabeln(erna) vars adress ska skickas."

msgid "Strings and buffers"
msgstr "Strängar och buffertar"

msgid ""
"On Python 3.12 and older, the macro :c:macro:`!PY_SSIZE_T_CLEAN` must be "
"defined before including :file:`Python.h` to use all ``#`` variants of "
"formats (``s#``, ``y#``, etc.) explained below. This is not necessary on "
"Python 3.13 and later."
msgstr ""
"På Python 3.12 och äldre måste makrot :c:macro:`!PY_SSIZE_T_CLEAN` "
"definieras innan :file:`Python.h` inkluderas för att använda alla ``#`` "
"varianter av format (``s#``, ``y#``, etc.) som förklaras nedan. Detta är "
"inte nödvändigt i Python 3.13 och senare."

msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You "
"don't have to provide raw storage for the returned unicode or bytes area."
msgstr ""
"Dessa format gör det möjligt att komma åt ett objekt som en sammanhängande "
"del av minnet. Du behöver inte tillhandahålla rå lagring för det returnerade "
"unicode- eller bytesområdet."

msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "Om inget annat anges är buffertar inte NUL-terminerade."

msgid "There are three ways strings and buffers can be converted to C:"
msgstr "Strängar och buffertar kan konverteras till C på tre olika sätt:"

msgid ""
"Formats such as ``y*`` and ``s*`` fill a :c:type:`Py_buffer` structure. This "
"locks the underlying buffer so that the caller can subsequently use the "
"buffer even inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk "
"of mutable data being resized or destroyed. As a result, **you have to "
"call** :c:func:`PyBuffer_Release` after you have finished processing the "
"data (or in any early abort case)."
msgstr ""
"Format som ``y*`` och ``s*`` fyller en :c:type:`Py_buffer`-struktur. Detta "
"låser den underliggande bufferten så att anroparen därefter kan använda "
"bufferten även inom ett :c:type:`Py_BEGIN_ALLOW_THREADS`-block utan att "
"riskera att muterbara data ändras i storlek eller förstörs. Som ett resultat "
"måste **du anropa** :c:func:`PyBuffer_Release` efter att du har avslutat "
"bearbetningen av data (eller i något tidigt avbrottsfall)."

msgid ""
"The ``es``, ``es#``, ``et`` and ``et#`` formats allocate the result buffer. "
"**You have to call** :c:func:`PyMem_Free` after you have finished processing "
"the data (or in any early abort case)."
msgstr ""
"Formaten ``es``, ``es#``, ``et`` och ``et#`` allokerar resultatbufferten. "
"**Du måste anropa** :c:func:`PyMem_Free` när du är klar med databehandlingen "
"(eller vid ett tidigt avbrott)."

msgid ""
"Other formats take a :class:`str` or a read-only :term:`bytes-like object`, "
"such as :class:`bytes`, and provide a ``const char *`` pointer to its "
"buffer. In this case the buffer is \"borrowed\": it is managed by the "
"corresponding Python object, and shares the lifetime of this object. You "
"won't have to release any memory yourself."
msgstr ""
"Andra format tar en :class:`str` eller en skrivskyddad :term:`bytes-liknande "
"objekt`, såsom :class:`bytes`, och tillhandahåller en ``const char *`` "
"pekare till dess buffert. I detta fall är bufferten \"lånad\": den hanteras "
"av motsvarande Python-objekt och har samma livstid som detta objekt. Du "
"kommer inte att behöva frigöra något minne själv."

msgid ""
"To ensure that the underlying buffer may be safely borrowed, the object's :c:"
"member:`PyBufferProcs.bf_releasebuffer` field must be ``NULL``. This "
"disallows common mutable objects such as :class:`bytearray`, but also some "
"read-only objects such as :class:`memoryview` of :class:`bytes`."
msgstr ""
"För att säkerställa att den underliggande bufferten kan lånas på ett säkert "
"sätt måste objektets fält :c:member:`PyBufferProcs.bf_releasebuffer` vara "
"``NULL``. Detta tillåter inte vanliga föränderliga objekt som :class:"
"`bytearray`, men även vissa skrivskyddade objekt som :class:`memoryview` av :"
"class:`bytes`."

msgid ""
"Besides this ``bf_releasebuffer`` requirement, there is no check to verify "
"whether the input object is immutable (e.g. whether it would honor a request "
"for a writable buffer, or whether another thread can mutate the data)."
msgstr ""
"Förutom detta ``bf_releasebuffer``-krav finns det ingen kontroll för att "
"verifiera om inmatningsobjektet är oföränderligt (t.ex. om det skulle "
"uppfylla en begäran om en skrivbar buffert, eller om en annan tråd kan "
"mutera data)."

msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [const char \\*]"

msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address "
"you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception "
"is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"Konverterar ett Unicode-objekt till en C-pekare till en teckensträng. En "
"pekare till en befintlig sträng lagras i den teckenpekarvariabel vars adress "
"du skickar.  C-strängen är NUL-terminerad. Python-strängen får inte "
"innehålla inbäddade nollkodpunkter; om den gör det, uppstår ett :exc:"
"`ValueError`-undantag. Unicode-objekt konverteras till C-strängar med "
"kodningen ``'utf-8'``. Om denna konvertering misslyckas, uppstår ett :exc:"
"`UnicodeError`."

msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`.  "
"If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with :c:func:"
"`PyUnicode_FSConverter` as *converter*."
msgstr ""
"Detta format accepterar inte :term:`bytesliknande objekt <bytes-like "
"object>`.  Om du vill acceptera sökvägar i filsystemet och konvertera dem "
"till C-teckensträngar är det bättre att använda formatet ``O&amp;`` med :c:"
"func:`PyUnicode_FSConverter` som *konverterare*."

msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr ""
"Tidigare gav :exc:`TypeError` upphov till fel när inbäddade nollkodpunkter "
"påträffades i Python-strängen."

msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` eller :term:`bytesliknande objekt`) [Py_buffer]"

msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"Detta format accepterar Unicode-objekt såväl som bytes-liknande objekt. Det "
"fyller en :c:type:`Py_buffer`-struktur som tillhandahålls av anroparen. I "
"detta fall kan den resulterande C-strängen innehålla inbäddade NUL-bytes. "
"Unicode-objekt konverteras till C-strängar med kodningen ``'utf-8``."

msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, :"
"c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str`, skrivskyddad :term:`bytesliknande objekt`) [const char "
"\\*, :c:type:`Py_ssize_t`]"

msgid ""
"Like ``s*``, except that it provides a :ref:`borrowed buffer <c-arg-borrowed-"
"buffer>`. The result is stored into two C variables, the first one a pointer "
"to a C string, the second one its length. The string may contain embedded "
"null bytes. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding."
msgstr ""
"Som ``s*``, förutom att den tillhandahåller en :ref:`lånad buffert <c-arg-"
"borrowed-buffer>`. Resultatet lagras i två C-variabler, den första en pekare "
"till en C-sträng, den andra dess längd. Strängen kan innehålla inbäddade "
"nollbytes. Unicode-objekt konverteras till C-strängar med kodningen "
"``'utf-8'``."

msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` eller ``None``) [const char \\*]"

msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Som ````, men Python-objektet kan också vara ``None``, i vilket fall C-"
"pekaren sätts till ``NULL``."

msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`bytesliknande objekt` eller ``None``) "
"[Py_buffer]"

msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to ``NULL``."
msgstr ""
"Som ``*``, men Python-objektet kan också vara ``None``, i vilket fall "
"``buf``-medlemmen i :c:type:`Py_buffer`-strukturen sätts till ``NULL``."

msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str`, skrivskyddad :term:`bytesliknande objekt` eller "
"``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Som ``#``, men Python-objektet kan också vara ``None``, i vilket fall C-"
"pekaren sätts till ``NULL``."

msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr "``y`` (skrivskyddad :term:`bytesliknande objekt`) [const char \\*]"

msgid ""
"This format converts a bytes-like object to a C pointer to a :ref:`borrowed "
"<c-arg-borrowed-buffer>` character string; it does not accept Unicode "
"objects.  The bytes buffer must not contain embedded null bytes; if it does, "
"a :exc:`ValueError` exception is raised."
msgstr ""
"Detta format konverterar ett bytes-liknande objekt till en C-pekare till en :"
"ref:``borrowed <c-arg-borrowed-buffer>`` teckensträng; det accepterar inte "
"Unicode-objekt.  Bytesbufferten får inte innehålla inbäddade nollbytes; om "
"den gör det, uppstår ett :exc:`ValueError`-undantag."

msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr ""
"Tidigare skapades :exc:`TypeError` när inbäddade nullbytes påträffades i "
"bytesbufferten."

msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`bytesliknande objekt`) [Py_buffer]"

msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr ""
"Den här varianten av ``s*`` accepterar inte Unicode-objekt, utan endast "
"bytesliknande objekt.  **Detta är det rekommenderade sättet att acceptera "
"binära data"

msgid ""
"``y#`` (read-only :term:`bytes-like object`) [const char \\*, :c:type:"
"`Py_ssize_t`]"
msgstr ""
"``y#`` (skrivskyddad :term:`bytesliknande objekt`) [const char \\*, :c:type:"
"`Py_ssize_t`]"

msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr ""
"Den här varianten av ``s#`` accepterar inte Unicode-objekt, utan endast "
"bytesliknande objekt."

msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [PyBytesObject \\*]"

msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"Kräver att Python-objektet är ett :class:`bytes`-objekt, utan att försöka "
"någon konvertering.  Utlöser :exc:`TypeError` om objektet inte är ett bytes-"
"objekt.  C-variabeln kan också deklareras som :c:expr:`PyObject*`."

msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"

msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a :"
"class:`bytearray` object. The C variable may also be declared as :c:expr:"
"`PyObject*`."
msgstr ""
"Kräver att Python-objektet är ett :class:`bytearray`-objekt, utan att "
"försöka någon konvertering.  Utlöser :exc:`TypeError` om objektet inte är "
"ett :class:`bytearray`-objekt. C-variabeln kan också deklareras som :c:expr:"
"`PyObject*`."

msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [PyObject \\*]"

msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  "
"The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"Kräver att Python-objektet är ett Unicode-objekt, utan att försöka någon "
"konvertering.  Utlöser :exc:`TypeError` om objektet inte är ett Unicode-"
"objekt.  C-variabeln kan också deklareras som :c:expr:`PyObject*`."

msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr "``w*`` (skrivläsning :term:`bytesliknande objekt`) [Py_buffer]"

msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call :c:func:"
"`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"Detta format accepterar alla objekt som implementerar gränssnittet för skriv-"
"läs-buffert. Det fyller en :c:type:`Py_buffer`-struktur som tillhandahålls "
"av anroparen. Bufferten kan innehålla inbäddade nollbytes. Den som anropar "
"måste anropa :c:func:`PyBuffer_Release` när den är klar med bufferten."

msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr "``es`` (:class:`str`) [const char \\*encoding, char \\*\\\\*buffer]"

msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr ""
"Denna variant av ``s`` används för att koda Unicode till en teckenbuffert. "
"Den fungerar endast för kodade data utan inbäddade NUL-bytes."

msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:expr:`const char*` which points to the name of an encoding as a "
"NUL-terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument."
msgstr ""
"Detta format kräver två argument.  Det första används endast som indata och "
"måste vara ett :c:expr:`const char*` som pekar på namnet på en kodning som "
"en NUL-terminerad sträng, eller ``NULL``, i vilket fall kodningen "
"``'utf-8'`` används. Ett undantag uppstår om den angivna kodningen inte är "
"känd av Python.  Det andra argumentet måste vara ett :c:expr:`char**`; "
"värdet på pekaren som det refererar till kommer att sättas till en buffert "
"med innehållet i argumentets text. Texten kommer att kodas i den kodning som "
"anges av det första argumentet."

msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling :c:func:"
"`PyMem_Free` to free the allocated buffer after use."
msgstr ""
":c:func:`PyArg_ParseTuple` kommer att allokera en buffert av den storlek som "
"behövs, kopiera den kodade datan till denna buffert och justera *\\*buffer* "
"för att referera till den nyligen allokerade lagringen.  Anroparen är "
"ansvarig för att anropa :c:func:`PyMem_Free` för att frigöra den allokerade "
"bufferten efter användning."

msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""
"``et`` (:class:`str`, :class:`bytes` eller :class:`bytearray`) [const char "
"\\*encoding, char \\*\\\\buffer]"

msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"Samma som ``es`` förutom att byte-strängobjekt skickas igenom utan att "
"omkoda dem.  Istället antar implementationen att byte-strängobjektet "
"använder den kodning som skickas in som parameter."

msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, :c:type:"
"`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\\\*buffer, :c:type:"
"`Py_ssize_t` \\*buffer_length]"

msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer. "
"Unlike the ``es`` format, this variant allows input data which contains NUL "
"characters."
msgstr ""
"Denna variant av ``s#`` används för att koda Unicode till en teckenbuffert. "
"Till skillnad från formatet ``es`` tillåter den här varianten indata som "
"innehåller NUL-tecken."

msgid ""
"It requires three arguments.  The first is only used as input, and must be "
"a :c:expr:`const char*` which points to the name of an encoding as a NUL-"
"terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is used. "
"An exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""
"Den kräver tre argument.  Det första används endast som indata och måste "
"vara en :c:expr:`const char*` som pekar på namnet på en kodning som en NUL-"
"terminerad sträng, eller ``NULL``, i vilket fall kodningen ``'utf-8'`` "
"används. Ett undantag uppstår om den angivna kodningen inte är känd av "
"Python.  Det andra argumentet måste vara ett :c:expr:`char**`; värdet på "
"pekaren som det refererar till kommer att sättas till en buffert med "
"innehållet i argumentets text. Texten kommer att kodas i den kodning som "
"anges av det första argumentet. Det tredje argumentet måste vara en pekare "
"till ett heltal; det refererade heltalet kommer att sättas till antalet "
"bytes i utmatningsbufferten."

msgid "There are two modes of operation:"
msgstr "Det finns två olika driftlägen:"

msgid ""
"If *\\*buffer* points a ``NULL`` pointer, the function will allocate a "
"buffer of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""
"Om *\\*buffer* pekar på en ``NULL``-pekare, kommer funktionen att allokera "
"en buffert av den storlek som behövs, kopiera de kodade data till denna "
"buffert och sätta *\\*buffer* att referera till den nyligen allokerade "
"lagringen.  Anroparen är ansvarig för att anropa :c:func:`PyMem_Free` för "
"att frigöra den allokerade bufferten efter användning."

msgid ""
"If *\\*buffer* points to a non-``NULL`` pointer (an already allocated "
"buffer), :c:func:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""
"Om *\\*buffer* pekar på en pekare som inte är ``NULL`` (en redan allokerad "
"buffert) kommer :c:func:`PyArg_ParseTuple` att använda denna plats som "
"buffert och tolka det initiala värdet för *\\*buffer_length* som "
"buffertstorleken.  Därefter kopieras de kodade data till bufferten och "
"avslutas med NUL.  Om bufferten inte är tillräckligt stor kommer ett :exc:"
"`ValueError` att anges."

msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr ""
"I båda fallen sätts *\\*buffer_length* till längden på den kodade datan utan "
"den efterföljande NUL-byten."

msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``et#`` (:class:`str`, :class:`bytes` eller :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"

msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"Samma som ``es#`` förutom att byte-strängobjekt skickas igenom utan att "
"omkoda dem. Istället antar implementationen att byte-strängobjektet använder "
"den kodning som skickas in som parameter."

msgid ""
"``u``, ``u#``, ``Z``, and ``Z#`` are removed because they used a legacy "
"``Py_UNICODE*`` representation."
msgstr ""
"``u``, ``u#``, ``Z`` och ``Z#`` tas bort eftersom de använde en äldre "
"``Py_UNICODE*``-representation."

msgid "Numbers"
msgstr "Nummer"

msgid ""
"These formats allow representing Python numbers or single characters as C "
"numbers. Formats that require :class:`int`, :class:`float` or :class:"
"`complex` can also use the corresponding special methods :meth:`~object."
"__index__`, :meth:`~object.__float__` or :meth:`~object.__complex__` to "
"convert the Python object to the required type."
msgstr ""
"Dessa format gör det möjligt att representera Python-tal eller enstaka "
"tecken som C-tal. Format som kräver :class:`int`, :class:`float` eller :"
"class:`complex` kan också använda motsvarande specialmetoder :meth:`~object."
"__index__`, :meth:`~object.__float__` eller :meth:`~object.__complex__` för "
"att konvertera Python-objektet till önskad typ."

msgid ""
"For signed integer formats, :exc:`OverflowError` is raised if the value is "
"out of range for the C type. For unsigned integer formats, no range checking "
"is done --- the most significant bits are silently truncated when the "
"receiving field is too small to receive the value."
msgstr ""
"För signerade heltalsformat :exc:`OverflowError` om värdet ligger utanför "
"intervallet för C-typen. För osignerade heltalsformat görs ingen "
"intervallkontroll --- de mest signifikanta bitarna trunkeras tyst när "
"mottagarfältet är för litet för att ta emot värdet."

msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [unsigned char]"

msgid ""
"Convert a nonnegative Python integer to an unsigned tiny integer, stored in "
"a C :c:expr:`unsigned char`."
msgstr ""
"Konverterar ett icke-negativt Python heltal till ett osignerat litet heltal, "
"lagrat i en C :c:expr:`unsigned char`."

msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [unsigned char]"

msgid ""
"Convert a Python integer to a tiny integer without overflow checking, stored "
"in a C :c:expr:`unsigned char`."
msgstr ""
"Konvertera ett Python heltal till ett litet heltal utan överflödeskontroll, "
"lagrat i en C :c:expr:`unsigned char`."

msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [kort int]"

msgid "Convert a Python integer to a C :c:expr:`short int`."
msgstr "Konvertera ett heltal i Python till ett C :c:expr:`short int`."

msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [unsigned short int]"

msgid ""
"Convert a Python integer to a C :c:expr:`unsigned short int`, without "
"overflow checking."
msgstr ""
"Konvertera ett heltal från Python till ett C :c:expr:`unsigned short int`, "
"utan kontroll av överflöd."

msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [int]"

msgid "Convert a Python integer to a plain C :c:expr:`int`."
msgstr "Konvertera ett heltal från Python till ett vanligt C :c:expr:`int`."

msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [unsigned int]"

msgid ""
"Convert a Python integer to a C :c:expr:`unsigned int`, without overflow "
"checking."
msgstr ""
"Konvertera ett heltal från Python till ett C :c:expr:`unsigned int`, utan "
"kontroll av överflöd."

msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [long int]"

msgid "Convert a Python integer to a C :c:expr:`long int`."
msgstr "Konvertera ett heltal i Python till ett C :c:expr:`long int`."

msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [unsigned long]"

msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long` without overflow "
"checking."
msgstr ""
"Konvertera ett heltal från Python till ett C :c:expr:`unsigned long` utan "
"överflödeskontroll."

msgid "Use :meth:`~object.__index__` if available."
msgstr "Använd :meth:`~object.__index__` om det finns tillgängligt."

msgid "``L`` (:class:`int`) [long long]"
msgstr "``L`` (:class:`int`) [lång lång]"

msgid "Convert a Python integer to a C :c:expr:`long long`."
msgstr "Konvertera ett heltal i Python till ett C :c:expr:`long long`."

msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr "``K`` (:class:`int`) [osignerad lång lång]"

msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long long` without "
"overflow checking."
msgstr ""
"Konvertera ett heltal från Python till ett C :c:expr:`unsigned long long` "
"utan överflödeskontroll."

msgid "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"
msgstr "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"

msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "Konvertera ett Python-heltal till en C :c:type:`Py_ssize_t`."

msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (:class:`bytes` eller :class:`bytearray` av längd 1) [char]"

msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray` "
"object of length 1, to a C :c:expr:`char`."
msgstr ""
"Konvertera en Python-byte, representerad som ett :class:`bytes` eller :class:"
"`bytearray`-objekt med längden 1, till en C :c:expr:`char`."

msgid "Allow :class:`bytearray` objects."
msgstr "Tillåt :class:`bytearray`-objekt."

msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (:class:`str` av längd 1) [int]"

msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:expr:`int`."
msgstr ""
"Konvertera ett Python-tecken, representerat som ett :class:`str`-objekt med "
"längden 1, till ett C :c:expr:`int`."

msgid "``f`` (:class:`float`) [float]"
msgstr "``f`` (:class:`float`) [float]"

msgid "Convert a Python floating-point number to a C :c:expr:`float`."
msgstr "Konverterar ett Python flyttal till ett C :c:expr:`float`."

msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [dubbel]"

msgid "Convert a Python floating-point number to a C :c:expr:`double`."
msgstr "Konverterar ett Python flyttal till ett C :c:expr:`double`."

msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [Py_complex]"

msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr ""
"Konverterar ett Python-komplext tal till en C :c:type:`Py_complex`-struktur."

msgid "Other objects"
msgstr "Övriga objekt"

msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (objekt) [PyObject \\*]"

msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C "
"program thus receives the actual object that was passed.  A new :term:"
"`strong reference` to the object is not created (i.e. its reference count is "
"not increased). The pointer stored is not ``NULL``."
msgstr ""
"Lagra ett Python-objekt (utan någon konvertering) i en C-objektpekare.  C-"
"programmet får därmed det faktiska objektet som skickades.  En ny :term:"
"`strong referens` till objektet skapas inte (d.v.s. dess referensantal ökas "
"inte). Den lagrade pekaren är inte ``NULL``."

msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (objekt) [*typeobject*, PyObject \\*]"

msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the "
"second is the address of the C variable (of type :c:expr:`PyObject*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""
"Lagra ett Python-objekt i en C-objektpekare.  Detta liknar ``O``, men tar "
"två C-argument: det första är adressen till ett objekt av Python-typ, det "
"andra är adressen till C-variabeln (av typen :c:expr:`PyObject*`) i vilken "
"objektpekaren lagras.  Om Python-objektet inte har den typ som krävs, "
"uppstår :exc:`TypeError`."

msgid "``O&`` (object) [*converter*, *address*]"
msgstr "``O&`` (objekt) [*konverterare*, *adress*]"

msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address "
"of a C variable (of arbitrary type), converted to :c:expr:`void *`.  The "
"*converter* function in turn is called as follows::"
msgstr ""
"Konvertera ett Python-objekt till en C-variabel genom en *konverter*-"
"funktion.  Denna tar två argument: det första är en funktion, det andra är "
"adressen till en C-variabel (av godtycklig typ), konverterad till :c:expr:"
"`void *`.  Funktionen *konverterare* anropas i sin tur på följande sätt::"

msgid "status = converter(object, address);"
msgstr "status = omvandlare(objekt, adress);"

msgid ""
"where *object* is the Python object to be converted and *address* is the :c:"
"expr:`void*` argument that was passed to the ``PyArg_Parse*`` function. The "
"returned *status* should be ``1`` for a successful conversion and ``0`` if "
"the conversion has failed.  When the conversion fails, the *converter* "
"function should raise an exception and leave the content of *address* "
"unmodified."
msgstr ""
"där *object* är Python-objektet som ska konverteras och *address* är :c:expr:"
"`void*`-argumentet som skickades till funktionen ``PyArg_Parse*``. Den "
"returnerade *status* bör vara ``1`` för en lyckad konvertering och ``0`` om "
"konverteringen har misslyckats.  När konverteringen misslyckas bör "
"funktionen *konverterare* ge upphov till ett undantag och lämna innehållet i "
"*adress* oförändrat."

msgid ""
"If the *converter* returns :c:macro:`!Py_CLEANUP_SUPPORTED`, it may get "
"called a second time if the argument parsing eventually fails, giving the "
"converter a chance to release any memory that it had already allocated. In "
"this second call, the *object* parameter will be ``NULL``; *address* will "
"have the same value as in the original call."
msgstr ""
"Om *omvandlaren* returnerar :c:macro:`!Py_CLEANUP_SUPPORTED`, kan den komma "
"att anropas en andra gång om argumentanalysen misslyckas, vilket ger "
"omvandlaren en chans att frigöra minne som den redan har allokerat. I detta "
"andra anrop kommer parametern *object* att vara ``NULL``; *address* kommer "
"att ha samma värde som i det ursprungliga anropet."

msgid ""
"Examples of converters: :c:func:`PyUnicode_FSConverter` and :c:func:"
"`PyUnicode_FSDecoder`."
msgstr ""
"Exempel på omvandlare: :c:func:`PyUnicode_FSConverter` och :c:func:"
"`PyUnicode_FSDecoder`."

msgid ":c:macro:`!Py_CLEANUP_SUPPORTED` was added."
msgstr ":c:macro:`!Py_CLEANUP_SUPPORTED` lades till."

msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [int]"

msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about "
"how Python tests values for truth."
msgstr ""
"Testar det värde som skickas in för sanning (en boolean **p**\\ redicate) "
"och konverterar resultatet till dess motsvarande C true/false heltalsvärde. "
"Sätter int till ``1`` om uttrycket var sant och ``0`` om det var falskt. "
"Detta accepterar alla giltiga Python-värden.  Se :ref:`truth` för mer "
"information om hur Python testar värden för sanning."

msgid "``(items)`` (sequence) [*matching-items*]"
msgstr "``(items)`` (sekvens) [*matchande-items*]"

msgid ""
"The object must be a Python sequence (except :class:`str`, :class:`bytes` "
"or :class:`bytearray`) whose length is the number of format units in "
"*items*.  The C arguments must correspond to the individual format units in "
"*items*.  Format units for sequences may be nested."
msgstr ""
"Objektet måste vara en Python-sekvens (utom :class:`str`, :class:`bytes` "
"eller :class:`bytearray`) vars längd är antalet formatenheter i *items*.  C-"
"argumenten måste motsvara de enskilda formatenheterna i *items*.  "
"Formatenheter för sekvenser kan vara nästlade."

msgid ""
"If *items* contains format units which store a :ref:`borrowed buffer <c-arg-"
"borrowed-buffer>` (``s``, ``s#``, ``z``, ``z#``, ``y``, or ``y#``) or a :"
"term:`borrowed reference` (``S``, ``Y``, ``U``, ``O``, or ``O!``), the "
"object must be a Python tuple. The *converter* for the ``O&`` format unit in "
"*items* must not store a borrowed buffer or a borrowed reference."
msgstr ""
"Om *artiklar* innehåller formatenheter som lagrar en :ref:``lånad buffert <c-"
"arg-borrowed-buffer>`` (``s``, ``s#``, ``z``, ``z#``, ``y``, eller ``y#``) "
"eller en :term:`lånad referens` (``S``, ``Y``, ``U``, ``O``, eller ``O!``), "
"måste objektet vara en Python-tupel. *omvandlaren* för formatenheten ``O&amp;"
"`` i *objekt* får inte lagra en lånad buffert eller en lånad referens."

msgid ""
":class:`str` and :class:`bytearray` objects no longer accepted as a sequence."
msgstr ""
"objekten :class:`str` och :class:`bytearray` accepteras inte längre som en "
"sekvens."

msgid ""
"Non-tuple sequences are deprecated if *items* contains format units which "
"store a borrowed buffer or a borrowed reference."
msgstr ""
"Sekvenser som inte är tupler är inte längre aktuella om *items* innehåller "
"formatenheter som lagrar en lånad buffert eller en lånad referens."

msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr ""
"Några andra tecken har en betydelse i en formatsträng.  Dessa får inte "
"förekomma inom klamrade parenteser.  De är följande:"

msgid "``|``"
msgstr "``|``"

msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""
"Anger att de återstående argumenten i Pythons argumentlista är valfria. C-"
"variablerna som motsvarar valfria argument bör initialiseras till sitt "
"standardvärde --- när ett valfritt argument inte anges rör :c:func:"
"`PyArg_ParseTuple` inte innehållet i motsvarande C-variabel(er)."

msgid "``$``"
msgstr "``$``"

msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always "
"be specified before ``$`` in the format string."
msgstr ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Anger att de återstående "
"argumenten i Pythons argumentlista endast är nyckelord.  För närvarande "
"måste alla argument som endast innehåller nyckelord också vara valfria "
"argument, så ``|`` måste alltid anges före ``$`` i formatsträngen."

msgid "``:``"
msgstr "``:``"

msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""
"Listan över formatenheter slutar här; strängen efter kolon används som "
"funktionsnamn i felmeddelanden (det \"associerade värdet\" för det undantag "
"som :c:func:`PyArg_ParseTuple` ger upphov till)."

msgid "``;``"
msgstr "``;``"

msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and ``;"
"`` mutually exclude each other."
msgstr ""
"Listan med formatenheter slutar här; strängen efter semikolon används som "
"felmeddelande *i stället för* standardfelmeddelandet.  ``:`` och ``;`` "
"utesluter varandra ömsesidigt."

msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not release them (i.e. do not decrement their "
"reference count)!"
msgstr ""
"Observera att alla Python-objektreferenser som tillhandahålls till den "
"anropande är *lånade* referenser; släpp dem inte (dvs. minska inte deras "
"referensantal)"

msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"Ytterligare argument som skickas till dessa funktioner måste vara adresser "
"till variabler vars typ bestäms av formatsträngen; dessa används för att "
"lagra värden från input-tupeln.  Det finns några fall, som beskrivs i listan "
"över formatenheter ovan, där dessa parametrar används som indatavärden; de "
"ska då matcha vad som anges för motsvarande formatenhet."

msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the ``PyArg_Parse*`` functions "
"return true, otherwise they return false and raise an appropriate exception. "
"When the ``PyArg_Parse*`` functions fail due to conversion failure in one of "
"the format units, the variables at the addresses corresponding to that and "
"the following format units are left untouched."
msgstr ""
"För att konverteringen ska lyckas måste *arg*-objektet matcha formatet och "
"formatet måste vara uttömt.  Vid framgång returnerar funktionerna "
"``PyArg_Parse*`` true, annars returnerar de false och ger upphov till ett "
"lämpligt undantag. När funktionerna ``PyArg_Parse*`` misslyckas på grund av "
"att konverteringen misslyckas i en av formatenheterna, lämnas variablerna på "
"de adresser som motsvarar den och de följande formatenheterna orörda."

msgid "API Functions"
msgstr "API-funktioner"

msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false "
"and raises the appropriate exception."
msgstr ""
"Analyserar parametrarna för en funktion som endast tar in positionella "
"parametrar i lokala variabler.  Returnerar true om funktionen lyckas; om den "
"misslyckas returneras false och ett lämpligt undantag tas upp."

msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Identisk med :c:func:`PyArg_ParseTuple`, förutom att den accepterar en "
"va_list i stället för ett variabelt antal argument."

msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables. The *keywords* argument is a ``NULL``-"
"terminated array of keyword parameter names specified as null-terminated "
"ASCII or UTF-8 encoded C strings. Empty names denote :ref:`positional-only "
"parameters <positional-only_parameter>`. Returns true on success; on "
"failure, it returns false and raises the appropriate exception."
msgstr ""
"Analyserar parametrarna för en funktion som tar in både positions- och "
"nyckelordsparametrar i lokala variabler. Argumentet *keywords* är en "
"``NULL``-avslutad array av nyckelordsparameternamn som anges som "
"nollavslutade ASCII- eller UTF-8-kodade C-strängar. Tomma namn betecknar :"
"ref:``endast positionsparametrar <endast positionsparameter>`. Returnerar "
"true vid framgång; vid misslyckande returnerar den false och ger upphov till "
"lämpligt undantag."

msgid ""
"The *keywords* parameter declaration is :c:expr:`char * const *` in C and :c:"
"expr:`const char * const *` in C++. This can be overridden with the :c:macro:"
"`PY_CXX_CONST` macro."
msgstr ""
"Parameterdeklarationen *keywords* är :c:expr:`char * const *` i C och :c:"
"expr:`const char * const *` i C++. Detta kan åsidosättas med makrot :c:macro:"
"`PY_CXX_CONST`."

msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ""
"Lagt till stöd för :ref:``positionella parametrar <positionella_parameter>`."

msgid ""
"The *keywords* parameter has now type :c:expr:`char * const *` in C and :c:"
"expr:`const char * const *` in C++, instead of :c:expr:`char **`. Added "
"support for non-ASCII keyword parameter names."
msgstr ""
"Parametern *keywords* har nu typen :c:expr:`char * const *` i C och :c:expr:"
"`const char * const *` i C++, istället för :c:expr:`char **`. Stöd för "
"parameternamn med nyckelord som inte är ASCII har lagts till."

msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a "
"va_list rather than a variable number of arguments."
msgstr ""
"Identisk med :c:func:`PyArg_ParseTupleAndKeywords`, förutom att den "
"accepterar en va_list i stället för ett variabelt antal argument."

msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""
"Säkerställer att nycklarna i argumentordlistan för nyckelord är strängar.  "
"Detta behövs bara om :c:func:`PyArg_ParseTupleAndKeywords` inte används, "
"eftersom den senare redan gör denna kontroll."

msgid ""
"Parse the parameter of a function that takes a single positional parameter "
"into a local variable.  Returns true on success; on failure, it returns "
"false and raises the appropriate exception."
msgstr ""
"Analyserar parametern för en funktion som tar en enda positionell parameter "
"till en lokal variabel.  Returnerar true om funktionen lyckas; om den "
"misslyckas returneras false och ett lämpligt undantag tas upp."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"// Function using METH_O calling convention\n"
"static PyObject*\n"
"my_function(PyObject *module, PyObject *arg)\n"
"{\n"
"    int value;\n"
"    if (!PyArg_Parse(arg, \"i:my_function\", &value)) {\n"
"        return NULL;\n"
"    }\n"
"    // ... use value ...\n"
"}"
msgstr ""
"// Funktion som använder METH_O anropskonvention\n"
"statiskt PyObject*\n"
"my_function(PyObject *modul, PyObject *argument)\n"
"{\n"
"    int värde;\n"
"    if (!PyArg_Parse(arg, \"i:my_function\", &value)) {\n"
"        returneras NULL;\n"
"    }\n"
"    // ... använd värde ...\n"
"}"

msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :c:macro:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:expr:`PyObject*` variable; these will be filled "
"in with the values from *args*; they will contain :term:`borrowed references "
"<borrowed reference>`. The variables which correspond to optional parameters "
"not given by *args* will not be filled in; these should be initialized by "
"the caller. This function returns true on success and false if *args* is not "
"a tuple or contains the wrong number of elements; an exception will be set "
"if there was a failure."
msgstr ""
"En enklare form av parameterhämtning som inte använder en formatsträng för "
"att ange typen av argument.  Funktioner som använder denna metod för att "
"hämta sina parametrar bör deklareras som :c:macro:`METH_VARARGS` i "
"funktions- eller metodtabeller.  Den tupel som innehåller de faktiska "
"parametrarna bör skickas som *args*; den måste faktiskt vara en tupel.  "
"Längden på tupeln måste vara minst *min* och inte mer än *max*; *min* och "
"*max* kan vara lika.  Ytterligare argument måste skickas till funktionen, "
"var och en av dem bör vara en pekare till en :c:expr:`PyObject*`-variabel; "
"dessa kommer att fyllas i med värdena från *args*; de kommer att innehålla :"
"term:`lånade referenser <borrowed reference>`. Variablerna som motsvarar "
"valfria parametrar som inte anges av *args* kommer inte att fyllas i; dessa "
"bör initialiseras av den som anropar. Denna funktion returnerar true vid "
"framgång och false om *args* inte är en tupel eller innehåller fel antal "
"element; ett undantag kommer att ställas in om det blev ett misslyckande."

msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`!_weakref` helper module for weak references::"
msgstr ""
"Detta är ett exempel på användningen av denna funktion, hämtad från källorna "
"till :mod:`!_weakref` hjälpmodul för svaga referenser::"

msgid ""
"static PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *result = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        result = PyWeakref_NewRef(object, callback);\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *resultat = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        resultat = PyWeakref_NewRef(objekt, återuppringning);\n"
"    }\n"
"    return resultat;\n"
"}"

msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""
"Anropet till :c:func:`PyArg_UnpackTuple` i detta exempel är helt likvärdigt "
"med detta anrop till :c:func:`PyArg_ParseTuple`::"

msgid "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"
msgstr "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"

msgid ""
"The value to be inserted, if any, before :c:expr:`char * const *` in the "
"*keywords* parameter declaration of :c:func:`PyArg_ParseTupleAndKeywords` "
"and :c:func:`PyArg_VaParseTupleAndKeywords`. Default empty for C and "
"``const`` for C++ (:c:expr:`const char * const *`). To override, define it "
"to the desired value before including :file:`Python.h`."
msgstr ""
"Det värde som ska infogas, om något, före :c:expr:`char * const *` i "
"parameterdeklarationen *keywords* för :c:func:`PyArg_ParseTupleAndKeywords` "
"och :c:func:`PyArg_VaParseTupleAndKeywords`. Standard tom för C och "
"``const`` för C++ (:c:expr:`const char * const *`). För att åsidosätta, "
"definiera det till önskat värde innan du inkluderar :file:`Python.h`."

msgid "Building values"
msgstr "Bygga värden"

msgid ""
"Create a new value based on a format string similar to those accepted by the "
"``PyArg_Parse*`` family of functions and a sequence of values.  Returns the "
"value or ``NULL`` in the case of an error; an exception will be raised if "
"``NULL`` is returned."
msgstr ""
"Skapar ett nytt värde baserat på en formatsträng liknande de som accepteras "
"av ``PyArg_Parse*``-familjen av funktioner och en sekvens av värden.  "
"Returnerar värdet eller ``NULL`` i händelse av ett fel; ett undantag kommer "
"att tas upp om ``NULL`` returneras."

msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force "
"it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`Py_BuildValue` bygger inte alltid en tupel.  Den bygger en tupel "
"endast om dess formatsträng innehåller två eller fler formatenheter.  Om "
"formatsträngen är tom returnerar den ``None``; om den innehåller exakt en "
"formatenhet returnerar den det objekt som beskrivs av den formatenheten.  Om "
"du vill tvinga den att returnera en tupel av storlek 0 eller ett, sätter du "
"formatsträngen i parentes."

msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes :c:func:"
"`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`, your "
"code is responsible for calling :c:func:`free` for that memory once :c:func:"
"`Py_BuildValue` returns."
msgstr ""
"När minnesbuffertar skickas som parametrar för att leverera data till "
"byggobjekt, som för formaten ``s`` och ``s#``, kopieras de data som krävs.  "
"Buffertar som tillhandahålls av anroparen refereras aldrig av de objekt som "
"skapas av :c:func:`Py_BuildValue`.  Med andra ord, om din kod anropar :c:"
"func:`malloc` och skickar det allokerade minnet till :c:func:"
"`Py_BuildValue`, är din kod ansvarig för att anropa :c:func:`free` för det "
"minnet när :c:func:`Py_BuildValue` återkommer."

msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""
"I följande beskrivning är den citerade formen formatenheten; posten inom "
"(runda) parenteser är Python-objekttypen som formatenheten kommer att "
"returnera; och posten inom [hakparenteser] är typen av C-värde(n) som ska "
"skickas."

msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long "
"format strings a tad more readable."
msgstr ""
"Tecknen mellanslag, tabb, kolon och kommatecken ignoreras i formatsträngar "
"(men inte inom formatenheter som ``s#``).  Detta kan användas för att göra "
"långa formatsträngar en aning mer läsbara."

msgid "``s`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``s`` (:class:`str` eller ``None``) [const char \\*]"

msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, ``None`` is used."
msgstr ""
"Konverterar en nollavslutad C-sträng till ett Python :class:`str`-objekt med "
"kodningen ``'utf-8'``. Om C-strängpekaren är ``NULL`` används ``None``."

msgid ""
"``s#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Konverterar en C-sträng och dess längd till ett Python :class:`str`-objekt "
"med kodningen ``'utf-8'``. Om C-strängpekaren är ``NULL`` ignoreras längden "
"och ``None`` returneras."

msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr "``y`` (:class:`bytes`) [const char \\*]"

msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string "
"pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Detta konverterar en C-sträng till ett Python :class:`bytes`-objekt.  Om C-"
"strängpekaren är ``NULL`` returneras ``None``."

msgid "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"

msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Detta konverterar en C-sträng och dess längder till ett Python-objekt.  Om C-"
"strängpekaren är ``NULL`` returneras ``None``."

msgid "Same as ``s``."
msgstr "Samma som ````."

msgid ""
"``z#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str` eller ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid "Same as ``s#``."
msgstr "Samma som ``s#``."

msgid "``u`` (:class:`str`) [const wchar_t \\*]"
msgstr "``u`` (:class:`str`) [const wchar_t \\*]"

msgid ""
"Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or "
"UCS-4) data to a Python Unicode object.  If the Unicode buffer pointer is "
"``NULL``, ``None`` is returned."
msgstr ""
"Konverterar en nollavslutad :c:type:`wchar_t`-buffert med Unicode-data "
"(UTF-16 eller UCS-4) till ett Python Unicode-objekt.  Om Unicode-"
"buffertpekaren är ``NULL`` returneras ``None``."

msgid "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"
msgstr "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"

msgid ""
"Convert a Unicode (UTF-16 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Konverterar en Unicode (UTF-16 eller UCS-4) databuffert och dess längd till "
"ett Python Unicode-objekt.   Om Unicode-buffertpekaren är ``NULL`` ignoreras "
"längden och ``None`` returneras."

msgid "``U`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``U`` (:class:`str` eller ``None``) [const char \\*]"

msgid ""
"``U#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``U#`` (:class:`str` eller ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

msgid "Convert a plain C :c:expr:`int` to a Python integer object."
msgstr ""
"Konverterar ett vanligt C :c:expr:`int` till ett Python-objekt med heltal."

msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [char]"

msgid "Convert a plain C :c:expr:`char` to a Python integer object."
msgstr ""
"Konvertera en vanlig C :c:expr:`char` till ett Python-objekt med heltal."

msgid "Convert a plain C :c:expr:`short int` to a Python integer object."
msgstr ""
"Konverterar ett vanligt C :c:expr:`short int` till ett Python integer-objekt."

msgid "Convert a C :c:expr:`long int` to a Python integer object."
msgstr "Konverterar ett C :c:expr:`long int` till ett Python integer-objekt."

msgid "Convert a C :c:expr:`unsigned char` to a Python integer object."
msgstr ""
"Konverterar ett C :c:expr:`unsigned char` till ett Python integer-objekt."

msgid "Convert a C :c:expr:`unsigned short int` to a Python integer object."
msgstr ""
"Konverterar ett C :c:expr:`unsigned short int` till ett Python integer-"
"objekt."

msgid "Convert a C :c:expr:`unsigned int` to a Python integer object."
msgstr ""
"Konverterar ett C :c:expr:`unsigned int` till ett Python integer-objekt."

msgid "Convert a C :c:expr:`unsigned long` to a Python integer object."
msgstr ""
"Konverterar ett C :c:expr:`unsigned long` till ett Python integer-objekt."

msgid "Convert a C :c:expr:`long long` to a Python integer object."
msgstr "Konverterar ett C :c:expr:`long long` till ett Python integer-objekt."

msgid "Convert a C :c:expr:`unsigned long long` to a Python integer object."
msgstr ""
"Konverterar ett C :c:expr:`unsigned long long` till ett Python integer-"
"objekt."

msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr "Konverterar en C :c:type:`Py_ssize_t` till ett Python heltal."

msgid "Convert a C :c:expr:`int` to a Python :class:`bool` object."
msgstr "Konverterar ett C :c:expr:`int` till ett Python :class:`bool`-objekt."

msgid ""
"Be aware that this format requires an ``int`` argument. Unlike most other "
"contexts in C, variadic arguments are not coerced to a suitable type "
"automatically. You can convert another type (for example, a pointer or a "
"float) to a suitable ``int`` value using ``(x) ? 1 : 0`` or ``!!x``."
msgstr ""
"Tänk på att detta format kräver ett ``int``-argument. Till skillnad från de "
"flesta andra sammanhang i C, tvingas inte variadiska argument automatiskt "
"till en lämplig typ. Du kan konvertera en annan typ (till exempel en pekare "
"eller en float) till ett lämpligt ``int``-värde med hjälp av ``(x) ? 1 : 0`` "
"eller ``!!x``."

msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (:class:`bytes` av längd 1) [char]"

msgid ""
"Convert a C :c:expr:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr ""
"Konvertera ett C :c:expr:`int` som representerar en byte till ett Python :"
"class:`bytes`-objekt med längden 1."

msgid ""
"Convert a C :c:expr:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr ""
"Konvertera ett C :c:expr:`int` som representerar ett tecken till Python :"
"class:`str`-objekt med längden 1."

msgid "Convert a C :c:expr:`double` to a Python floating-point number."
msgstr "Konvertera ett C :c:expr:`double` till ett Python flyttal."

msgid "Convert a C :c:expr:`float` to a Python floating-point number."
msgstr "Konverterar ett C :c:expr:`float` till ett Python flyttal."

msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`complex`) [Py_complex \\*]"

msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr ""
"Konvertera en C :c:type:`Py_complex`-struktur till ett komplext Python-tal."

msgid ""
"Pass a Python object untouched but create a new :term:`strong reference` to "
"it (i.e. its reference count is incremented by one). If the object passed in "
"is a ``NULL`` pointer, it is assumed that this was caused because the call "
"producing the argument found an error and set an exception. Therefore, :c:"
"func:`Py_BuildValue` will return ``NULL`` but won't raise an exception.  If "
"no exception has been raised yet, :exc:`SystemError` is set."
msgstr ""
"Skicka ett Python-objekt orört men skapa en ny :term:`strong-referens` till "
"det (dvs. dess referensantal ökas med ett). Om objektet som skickas in är en "
"``NULL``-pekare, antas det att detta orsakades av att anropet som "
"producerade argumentet hittade ett fel och satte ett undantag. Därför "
"kommer :c:func:`Py_BuildValue` att returnera ``NULL`` men inte skapa ett "
"undantag.  Om inget undantag har skapats ännu, sätts :exc:`SystemError`."

msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (objekt) [PyObject \\*]"

msgid "Same as ``O``."
msgstr "Samma som ``O``."

msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (objekt) [PyObject \\*]"

msgid ""
"Same as ``O``, except it doesn't create a new :term:`strong reference`. "
"Useful when the object is created by a call to an object constructor in the "
"argument list."
msgstr ""
"Samma som ``O``, förutom att det inte skapar en ny :term:`strong referens`. "
"Användbart när objektet skapas genom ett anrop till en objektkonstruktör i "
"argumentlistan."

msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (objekt) [*konverterare*, *något*]"

msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with :c:expr:"
"`void*`) as its argument and should return a \"new\" Python object, or "
"``NULL`` if an error occurred."
msgstr ""
"Konvertera *något* till ett Python-objekt genom en *konverter*-funktion.  "
"Funktionen anropas med *anything* (som bör vara kompatibel med :c:expr:"
"`void*`) som sitt argument och bör returnera ett \"nytt\" Python-objekt, "
"eller ``NULL`` om ett fel inträffade."

msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matchande-items*]"

msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr ""
"Konvertera en sekvens av C-värden till en Python-tupel med samma antal "
"objekt."

msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*matchande-items*]"

msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr ""
"Konvertera en sekvens av C-värden till en Python-lista med samma antal "
"objekt."

msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*matchande-objekt*]"

msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr ""
"Konverterar en sekvens av C-värden till en Python-ordbok.  Varje par av på "
"varandra följande C-värden lägger till ett objekt i ordlistan och fungerar "
"som nyckel respektive värde."

msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and ``NULL`` returned."
msgstr ""
"Om det finns ett fel i formatsträngen sätts undantaget :exc:`SystemError` "
"och ``NULL`` returneras."

msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Identisk med :c:func:`Py_BuildValue`, förutom att den accepterar en va_list "
"i stället för ett variabelt antal argument."
