# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Buffer Protocol"
msgstr "Buffertprotokoll"

msgid ""
"Certain objects available in Python wrap access to an underlying memory "
"array or *buffer*.  Such objects include the built-in :class:`bytes` and :"
"class:`bytearray`, and some extension types like :class:`array.array`. Third-"
"party libraries may define their own types for special purposes, such as "
"image processing or numeric analysis."
msgstr ""
"Vissa objekt som finns i Python ger tillgång till en underliggande "
"minnesarray eller *buffer*.  Sådana objekt inkluderar de inbyggda :class:"
"`bytes` och :class:`bytearray`, och vissa tilläggstyper som :class:`array."
"array`. Tredjepartsbibliotek kan definiera sina egna typer för speciella "
"ändamål, t.ex. bildbehandling eller numerisk analys."

msgid ""
"While each of these types have their own semantics, they share the common "
"characteristic of being backed by a possibly large memory buffer.  It is "
"then desirable, in some situations, to access that buffer directly and "
"without intermediate copying."
msgstr ""
"Även om var och en av dessa typer har sin egen semantik, har de den "
"gemensamma egenskapen att de backas upp av en eventuellt stor "
"minnesbuffert.  I vissa situationer är det då önskvärt att komma åt den "
"bufferten direkt och utan mellanliggande kopiering."

msgid ""
"Python provides such a facility at the C and Python level in the form of "
"the :ref:`buffer protocol <bufferobjects>`.  This protocol has two sides:"
msgstr ""
"Python tillhandahåller en sådan möjlighet på C- och Python-nivå i form av :"
"ref:`buffer protocol <bufferobjects>`.  Detta protokoll har två sidor:"

msgid ""
"on the producer side, a type can export a \"buffer interface\" which allows "
"objects of that type to expose information about their underlying buffer. "
"This interface is described in the section :ref:`buffer-structs`; for Python "
"see :ref:`python-buffer-protocol`."
msgstr ""
"på producentsidan kan en typ exportera ett \"buffertgränssnitt\" som "
"tillåter objekt av den typen att exponera information om sin underliggande "
"buffert. Detta gränssnitt beskrivs i avsnittet :ref:`buffer-structs`; för "
"Python se :ref:`python-buffer-protocol`."

msgid ""
"on the consumer side, several means are available to obtain a pointer to the "
"raw underlying data of an object (for example a method parameter). For "
"Python see :class:`memoryview`."
msgstr ""
"på konsumentsidan finns det flera sätt att få en pekare till de "
"underliggande rådata för ett objekt (t.ex. en metodparameter). För Python "
"se :class:`memoryview`."

msgid ""
"Simple objects such as :class:`bytes` and :class:`bytearray` expose their "
"underlying buffer in byte-oriented form.  Other forms are possible; for "
"example, the elements exposed by an :class:`array.array` can be multi-byte "
"values."
msgstr ""
"Enkla objekt som :class:`bytes` och :class:`bytearray` exponerar sin "
"underliggande buffert i byteorienterad form.  Andra former är möjliga; till "
"exempel kan elementen som exponeras av en :class:`array.array` vara "
"multibyte-värden."

msgid ""
"An example consumer of the buffer interface is the :meth:`~io.BufferedIOBase."
"write` method of file objects: any object that can export a series of bytes "
"through the buffer interface can be written to a file.  While :meth:`!write` "
"only needs read-only access to the internal contents of the object passed to "
"it, other methods such as :meth:`~io.BufferedIOBase.readinto` need write "
"access to the contents of their argument.  The buffer interface allows "
"objects to selectively allow or reject exporting of read-write and read-only "
"buffers."
msgstr ""
"Ett exempel på en användare av buffertgränssnittet är metoden :meth:`~io."
"BufferedIOBase.write` för filobjekt: alla objekt som kan exportera en serie "
"byte genom buffertgränssnittet kan skrivas till en fil.  Medan :meth:`!"
"write` endast behöver skrivskyddad åtkomst till det interna innehållet i det "
"objekt som skickas till den, behöver andra metoder som :meth:`~io."
"BufferedIOBase.readinto` skrivåtkomst till innehållet i sitt argument.  "
"Buffertgränssnittet gör det möjligt för objekt att selektivt tillåta eller "
"avvisa export av skrivläsningsbuffertar och skrivskyddade buffertar."

msgid ""
"There are two ways for a consumer of the buffer interface to acquire a "
"buffer over a target object:"
msgstr ""
"Det finns två sätt för en användare av buffertgränssnittet att skaffa en "
"buffert över ett målobjekt:"

msgid "call :c:func:`PyObject_GetBuffer` with the right parameters;"
msgstr "anropa :c:func:`PyObject_GetBuffer` med rätt parametrar;"

msgid ""
"call :c:func:`PyArg_ParseTuple` (or one of its siblings) with one of the "
"``y*``, ``w*`` or ``s*`` :ref:`format codes <arg-parsing>`."
msgstr ""
"anropa :c:func:`PyArg_ParseTuple` (eller ett av dess syskon) med en av "
"``y*``, ``w*`` eller ``s*`` :ref:`formatkoder <arg-parsing>`."

msgid ""
"In both cases, :c:func:`PyBuffer_Release` must be called when the buffer "
"isn't needed anymore.  Failure to do so could lead to various issues such as "
"resource leaks."
msgstr ""
"I båda fallen måste :c:func:`PyBuffer_Release` anropas när bufferten inte "
"längre behövs.  Om detta inte görs kan det leda till olika problem, t.ex. "
"resursläckage."

msgid ""
"The buffer protocol is now accessible in Python, see :ref:`python-buffer-"
"protocol` and :class:`memoryview`."
msgstr ""
"Buffertprotokollet är nu tillgängligt i Python, se :ref:`python-buffer-"
"protocol` och :class:`memoryview`."

msgid "Buffer structure"
msgstr "Buffertstruktur"

msgid ""
"Buffer structures (or simply \"buffers\") are useful as a way to expose the "
"binary data from another object to the Python programmer.  They can also be "
"used as a zero-copy slicing mechanism.  Using their ability to reference a "
"block of memory, it is possible to expose any data to the Python programmer "
"quite easily.  The memory could be a large, constant array in a C extension, "
"it could be a raw block of memory for manipulation before passing to an "
"operating system library, or it could be used to pass around structured data "
"in its native, in-memory format."
msgstr ""
"Buffertstrukturer (eller helt enkelt \"buffertar\") är användbara som ett "
"sätt att exponera binärdata från ett annat objekt till Python-"
"programmeraren.  De kan också användas som en nollkopieringsmekanism.  Genom "
"att använda deras förmåga att referera till ett minnesblock är det möjligt "
"att exponera vilken data som helst för Python-programmeraren ganska enkelt.  "
"Minnet kan vara en stor, konstant array i ett C-tillägg, det kan vara ett "
"råminnesblock för manipulation innan det skickas till ett "
"operativsystembibliotek, eller det kan användas för att skicka runt "
"strukturerade data i sitt ursprungliga format i minnet."

msgid ""
"Contrary to most data types exposed by the Python interpreter, buffers are "
"not :c:type:`PyObject` pointers but rather simple C structures.  This allows "
"them to be created and copied very simply.  When a generic wrapper around a "
"buffer is needed, a :ref:`memoryview <memoryview-objects>` object can be "
"created."
msgstr ""
"Till skillnad från de flesta datatyper som exponeras av Python-tolken är "
"buffertar inte :c:type:`PyObject`-pekare utan snarare enkla C-strukturer.  "
"Detta gör att de kan skapas och kopieras mycket enkelt.  När ett generiskt "
"omslag runt en buffert behövs kan ett :ref:`memoryview <memoryview-objects>`-"
"objekt skapas."

msgid ""
"For short instructions how to write an exporting object, see :ref:`Buffer "
"Object Structures <buffer-structs>`. For obtaining a buffer, see :c:func:"
"`PyObject_GetBuffer`."
msgstr ""
"För korta instruktioner om hur man skriver ett exporterande objekt, se :ref:"
"`Buffer Object Structures <buffer-structs>`. För att hämta en buffert, se :c:"
"func:`PyObject_GetBuffer`."

msgid ""
"A pointer to the start of the logical structure described by the buffer "
"fields. This can be any location within the underlying physical memory block "
"of the exporter. For example, with negative :c:member:`~Py_buffer.strides` "
"the value may point to the end of the memory block."
msgstr ""
"En pekare till början av den logiska struktur som beskrivs av buffertfälten. "
"Detta kan vara vilken plats som helst inom det underliggande fysiska "
"minnesblocket hos exportören. Till exempel, med negativ :c:member:"
"`~Py_buffer.strides` kan värdet peka till slutet av minnesblocket."

msgid ""
"For :term:`contiguous` arrays, the value points to the beginning of the "
"memory block."
msgstr "För :term:`contiguous` arrays pekar värdet på början av minnesblocket."

msgid ""
"A new reference to the exporting object. The reference is owned by the "
"consumer and automatically released (i.e. reference count decremented) and "
"set to ``NULL`` by :c:func:`PyBuffer_Release`. The field is the equivalent "
"of the return value of any standard C-API function."
msgstr ""
"En ny referens till det exporterande objektet. Referensen ägs av konsumenten "
"och frigörs automatiskt (d.v.s. referensantalet minskas) och sätts till "
"``NULL`` av :c:func:`PyBuffer_Release`. Fältet motsvarar returvärdet för "
"vilken standard C-API-funktion som helst."

msgid ""
"As a special case, for *temporary* buffers that are wrapped by :c:func:"
"`PyMemoryView_FromBuffer` or :c:func:`PyBuffer_FillInfo` this field is "
"``NULL``. In general, exporting objects MUST NOT use this scheme."
msgstr ""
"Som ett specialfall, för *temporära* buffertar som är omslutna av :c:func:"
"`PyMemoryView_FromBuffer` eller :c:func:`PyBuffer_FillInfo` är detta fält "
"``NULL``. Generellt gäller att exporterande objekt INTE får använda detta "
"schema."

msgid ""
"``product(shape) * itemsize``. For contiguous arrays, this is the length of "
"the underlying memory block. For non-contiguous arrays, it is the length "
"that the logical structure would have if it were copied to a contiguous "
"representation."
msgstr ""
"``produkt(form) * artikelstorlek``. För sammanhängande arrayer är detta "
"längden på det underliggande minnesblocket. För icke sammanhängande matriser "
"är det den längd som den logiska strukturen skulle ha om den kopierades till "
"en sammanhängande representation."

msgid ""
"Accessing ``((char *)buf)[0] up to ((char *)buf)[len-1]`` is only valid if "
"the buffer has been obtained by a request that guarantees contiguity. In "
"most cases such a request will be :c:macro:`PyBUF_SIMPLE` or :c:macro:"
"`PyBUF_WRITABLE`."
msgstr ""
"Att komma åt ``((char *)buf)[0] upp till ((char *)buf)[len-1]`` är bara "
"giltigt om bufferten har erhållits genom en begäran som garanterar "
"sammanhängande. I de flesta fall kommer en sådan begäran att vara :c:macro:"
"`PyBUF_SIMPLE` eller :c:macro:`PyBUF_WRITABLE`."

msgid ""
"An indicator of whether the buffer is read-only. This field is controlled by "
"the :c:macro:`PyBUF_WRITABLE` flag."
msgstr ""
"En indikator på om bufferten är skrivskyddad. Detta fält styrs av :c:macro:"
"`PyBUF_WRITABLE` flaggan."

msgid ""
"Item size in bytes of a single element. Same as the value of :func:`struct."
"calcsize` called on non-``NULL`` :c:member:`~Py_buffer.format` values."
msgstr ""
"Elementstorlek i bytes för ett enda element. Samma som värdet av :func:"
"`struct.calcsize` som anropas på icke-``NULL`` :c:member:`~Py_buffer.format`-"
"värden."

msgid ""
"Important exception: If a consumer requests a buffer without the :c:macro:"
"`PyBUF_FORMAT` flag, :c:member:`~Py_buffer.format` will be set to  "
"``NULL``,  but :c:member:`~Py_buffer.itemsize` still has the value for the "
"original format."
msgstr ""
"Viktigt undantag: Om en konsument begär en buffert utan :c:macro:"
"`PyBUF_FORMAT` flaggan, kommer :c:member:`~Py_buffer.format` att sättas till "
"``NULL``, men :c:member:`~Py_buffer.itemsize` har fortfarande värdet för det "
"ursprungliga formatet."

msgid ""
"If :c:member:`~Py_buffer.shape` is present, the equality ``product(shape) * "
"itemsize == len`` still holds and the consumer can use :c:member:`~Py_buffer."
"itemsize` to navigate the buffer."
msgstr ""
"Om :c:member:`~Py_buffer.shape` är närvarande gäller fortfarande likheten "
"``product(shape) * itemsize == len`` och konsumenten kan använda :c:member:"
"`~Py_buffer.itemsize` för att navigera i bufferten."

msgid ""
"If :c:member:`~Py_buffer.shape` is ``NULL`` as a result of a :c:macro:"
"`PyBUF_SIMPLE` or a :c:macro:`PyBUF_WRITABLE` request, the consumer must "
"disregard :c:member:`~Py_buffer.itemsize` and assume ``itemsize == 1``."
msgstr ""
"Om :c:member:`~Py_buffer.shape` är ``NULL`` som ett resultat av en :c:macro:"
"`PyBUF_SIMPLE` eller en :c:macro:`PyBUF_WRITABLE` begäran, måste konsumenten "
"bortse från :c:member:`~Py_buffer.itemsize` och anta ``itemsize == 1``."

msgid ""
"A *NULL* terminated string in :mod:`struct` module style syntax describing "
"the contents of a single item. If this is ``NULL``, ``\"B\"`` (unsigned "
"bytes) is assumed."
msgstr ""
"En *NULL*-terminerad sträng i :mod:`struct`-modulstilssyntax som beskriver "
"innehållet i ett enda objekt. Om detta är ``NULL``, antas ``\"B\"`` "
"(osignerade bytes)."

msgid "This field is controlled by the :c:macro:`PyBUF_FORMAT` flag."
msgstr "Detta fält styrs av flaggan :c:macro:`PyBUF_FORMAT`."

msgid ""
"The number of dimensions the memory represents as an n-dimensional array. If "
"it is ``0``, :c:member:`~Py_buffer.buf` points to a single item representing "
"a scalar. In this case, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides` and :c:member:`~Py_buffer.suboffsets` MUST be ``NULL``. The maximum "
"number of dimensions is given by :c:macro:`PyBUF_MAX_NDIM`."
msgstr ""
"Antalet dimensioner som minnet representerar som en n-dimensionell array. Om "
"det är ``0`` pekar :c:member:`~Py_buffer.buf` på ett enda objekt som "
"representerar en skalär. I detta fall MÅSTE :c:member:`~Py_buffer.shape`, :c:"
"member:`~Py_buffer.strides` och :c:member:`~Py_buffer.suboffsets` vara "
"``NULL``. Det maximala antalet dimensioner anges av :c:macro:"
"`PyBUF_MAX_NDIM`."

msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"indicating the shape of the memory as an n-dimensional array. Note that "
"``shape[0] * ... * shape[ndim-1] * itemsize`` MUST be equal to :c:member:"
"`~Py_buffer.len`."
msgstr ""
"En array av :c:type:`Py_ssize_t` med längden :c:member:`~Py_buffer.ndim` som "
"anger formen på minnet som en n-dimensionell array. Observera att ``shape[0] "
"* ... * shape[ndim-1] * itemsize`` MÅSTE vara lika med :c:member:`~Py_buffer."
"len`."

msgid ""
"Shape values are restricted to ``shape[n] >= 0``. The case ``shape[n] == 0`` "
"requires special attention. See `complex arrays`_ for further information."
msgstr ""
"Shape-värden är begränsade till ``shape[n] >= 0``. Fallet ``shape[n] == 0`` "
"kräver särskild uppmärksamhet. Se `komplexa matriser`_ för ytterligare "
"information."

msgid "The shape array is read-only for the consumer."
msgstr "Shape-arrayen är skrivskyddad för konsumenten."

msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"giving the number of bytes to skip to get to a new element in each dimension."
msgstr ""
"En array av :c:type:`Py_ssize_t` med längden :c:member:`~Py_buffer.ndim` som "
"anger antalet bytes som ska hoppas över för att komma till ett nytt element "
"i varje dimension."

msgid ""
"Stride values can be any integer. For regular arrays, strides are usually "
"positive, but a consumer MUST be able to handle the case ``strides[n] <= "
"0``. See `complex arrays`_ for further information."
msgstr ""
"Stride-värden kan vara valfritt heltal. För vanliga arrayer är strides "
"vanligtvis positiva, men en konsument MÅSTE kunna hantera fallet "
"``strides[n] <= 0``. Se `komplexa arrayer`_ för mer information."

msgid "The strides array is read-only for the consumer."
msgstr "Strides-arrayen är skrivskyddad för konsumenten."

msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim`. If "
"``suboffsets[n] >= 0``, the values stored along the nth dimension are "
"pointers and the suboffset value dictates how many bytes to add to each "
"pointer after de-referencing. A suboffset value that is negative indicates "
"that no de-referencing should occur (striding in a contiguous memory block)."
msgstr ""
"En array av :c:type:`Py_ssize_t` med längden :c:member:`~Py_buffer.ndim`. Om "
"``suboffsets[n] >= 0`` är värdena som lagras längs den n:te dimensionen "
"pekare och suboffset-värdet anger hur många byte som ska läggas till varje "
"pekare efter de-referering. Ett negativt suboffset-värde anger att ingen de-"
"referensering ska ske (striding i ett sammanhängande minnesblock)."

msgid ""
"If all suboffsets are negative (i.e. no de-referencing is needed), then this "
"field must be ``NULL`` (the default value)."
msgstr ""
"Om alla suboffsets är negativa (dvs. ingen de-referensering behövs), måste "
"detta fält vara ``NULL`` (standardvärdet)."

msgid ""
"This type of array representation is used by the Python Imaging Library "
"(PIL). See `complex arrays`_ for further information how to access elements "
"of such an array."
msgstr ""
"Denna typ av matrisrepresentation används av Python Imaging Library (PIL). "
"Se `komplexa arrayer`_ för mer information om hur du får tillgång till "
"element i en sådan array."

msgid "The suboffsets array is read-only for the consumer."
msgstr "Suboffsets-arrayen är skrivskyddad för konsumenten."

msgid ""
"This is for use internally by the exporting object. For example, this might "
"be re-cast as an integer by the exporter and used to store flags about "
"whether or not the shape, strides, and suboffsets arrays must be freed when "
"the buffer is released. The consumer MUST NOT alter this value."
msgstr ""
"Detta är för intern användning av det exporterande objektet. Det kan t.ex. "
"omformas till ett heltal av exportören och användas för att lagra flaggor om "
"huruvida arrayer med shape, strides och suboffsets måste frigöras när "
"bufferten släpps. Konsumenten MÅSTE INTE ändra detta värde."

msgid "Constants:"
msgstr "Konstanter:"

msgid ""
"The maximum number of dimensions the memory represents. Exporters MUST "
"respect this limit, consumers of multi-dimensional buffers SHOULD be able to "
"handle up to :c:macro:`!PyBUF_MAX_NDIM` dimensions. Currently set to 64."
msgstr ""
"Det maximala antalet dimensioner som minnet representerar. Exportörer MÅSTE "
"respektera denna gräns, konsumenter av flerdimensionella buffertar BÖR kunna "
"hantera upp till :c:macro:`!PyBUF_MAX_NDIM` dimensioner. För närvarande satt "
"till 64."

msgid "Buffer request types"
msgstr "Typer av buffertförfrågningar"

msgid ""
"Buffers are usually obtained by sending a buffer request to an exporting "
"object via :c:func:`PyObject_GetBuffer`. Since the complexity of the logical "
"structure of the memory can vary drastically, the consumer uses the *flags* "
"argument to specify the exact buffer type it can handle."
msgstr ""
"Buffertar erhålls vanligtvis genom att skicka en buffertförfrågan till ett "
"exporterande objekt via :c:func:`PyObject_GetBuffer`. Eftersom komplexiteten "
"i minnets logiska struktur kan variera drastiskt använder konsumenten "
"argumentet *flags* för att ange den exakta bufferttyp som den kan hantera."

msgid ""
"All :c:type:`Py_buffer` fields are unambiguously defined by the request type."
msgstr ""
"Alla fält i :c:type:`Py_buffer` definieras otvetydigt av typen av begäran."

msgid "request-independent fields"
msgstr "fält oberoende av begäran"

msgid ""
"The following fields are not influenced by *flags* and must always be filled "
"in with the correct values: :c:member:`~Py_buffer.obj`, :c:member:"
"`~Py_buffer.buf`, :c:member:`~Py_buffer.len`, :c:member:`~Py_buffer."
"itemsize`, :c:member:`~Py_buffer.ndim`."
msgstr ""
"Följande fält påverkas inte av *flags* och måste alltid fyllas i med "
"korrekta värden: :c:member:`~Py_buffer.obj`, :c:member:`~Py_buffer.buf`, :c:"
"member:`~Py_buffer.len`, :c:member:`~Py_buffer.itemsize`, :c:member:"
"`~Py_buffer.ndim`."

msgid "readonly, format"
msgstr "skrivskyddad, format"

msgid ""
"Controls the :c:member:`~Py_buffer.readonly` field. If set, the exporter "
"MUST provide a writable buffer or else report failure. Otherwise, the "
"exporter MAY provide either a read-only or writable buffer, but the choice "
"MUST be consistent for all consumers. For example, :c:expr:`PyBUF_SIMPLE | "
"PyBUF_WRITABLE` can be used to request a simple writable buffer."
msgstr ""
"Kontrollerar fältet :c:member:`~Py_buffer.readonly`. Om det är inställt "
"MÅSTE exportören tillhandahålla en skrivbar buffert, annars rapporteras fel. "
"I annat fall KAN exportören tillhandahålla antingen en skrivskyddad eller "
"skrivbar buffert, men valet MÅSTE vara konsekvent för alla konsumenter. Till "
"exempel kan :c:expr:`PyBUF_SIMPLE | PyBUF_WRITABLE` användas för att begära "
"en enkel skrivbar buffert."

msgid ""
"Controls the :c:member:`~Py_buffer.format` field. If set, this field MUST be "
"filled in correctly. Otherwise, this field MUST be ``NULL``."
msgstr ""
"Kontrollerar fältet :c:member:`~Py_buffer.format`. Om det är inställt MÅSTE "
"fältet fyllas i korrekt. Annars MÅSTE detta fält vara ``NULL``."

msgid ""
":c:macro:`PyBUF_WRITABLE` can be \\|'d to any of the flags in the next "
"section. Since :c:macro:`PyBUF_SIMPLE` is defined as 0, :c:macro:"
"`PyBUF_WRITABLE` can be used as a stand-alone flag to request a simple "
"writable buffer."
msgstr ""
":c:macro:`PyBUF_WRITABLE` kan kopplas till någon av flaggorna i nästa "
"avsnitt. Eftersom :c:macro:`PyBUF_SIMPLE` är definierad som 0, kan :c:macro:"
"`PyBUF_WRITABLE` användas som en fristående flagga för att begära en enkel "
"skrivbar buffert."

msgid ""
":c:macro:`PyBUF_FORMAT` must be \\|'d to any of the flags except :c:macro:"
"`PyBUF_SIMPLE`, because the latter already implies format ``B`` (unsigned "
"bytes). :c:macro:`!PyBUF_FORMAT` cannot be used on its own."
msgstr ""
":c:macro:`PyBUF_FORMAT` måste vara \\|'d till någon av flaggorna utom :c:"
"macro:`PyBUF_SIMPLE`, eftersom den senare redan implicerar format ``B`` "
"(osignerade byte). :c:macro:`!PyBUF_FORMAT` kan inte användas på egen hand."

msgid "shape, strides, suboffsets"
msgstr "form, strides, suboffsets"

msgid ""
"The flags that control the logical structure of the memory are listed in "
"decreasing order of complexity. Note that each flag contains all bits of the "
"flags below it."
msgstr ""
"Flaggorna som styr minnets logiska struktur är listade i fallande ordning "
"efter komplexitet. Observera att varje flagga innehåller alla bitar i "
"flaggorna under den."

msgid "Request"
msgstr "Förfrågan"

msgid "shape"
msgstr "form"

msgid "strides"
msgstr "steg"

msgid "suboffsets"
msgstr "delmängder"

msgid "yes"
msgstr "ja"

msgid "if needed"
msgstr "om det behövs"

msgid "NULL"
msgstr "NULL"

msgid "contiguity requests"
msgstr "begäran om angränsning"

msgid ""
"C or Fortran :term:`contiguity <contiguous>` can be explicitly requested, "
"with and without stride information. Without stride information, the buffer "
"must be C-contiguous."
msgstr ""
"C eller Fortran :term:`contiguity <contiguous>` kan uttryckligen begäras, "
"med eller utan stride-information. Utan stride-information måste bufferten "
"vara C-kontigu."

msgid "contig"
msgstr "kontigent"

msgid "C"
msgstr "C"

msgid "F"
msgstr "F"

msgid "C or F"
msgstr "C eller F"

msgid ":c:macro:`PyBUF_ND`"
msgstr ":c:makro:`PyBUF_ND`"

msgid "compound requests"
msgstr "sammansatta förfrågningar"

msgid ""
"All possible requests are fully defined by some combination of the flags in "
"the previous section. For convenience, the buffer protocol provides "
"frequently used combinations as single flags."
msgstr ""
"Alla möjliga förfrågningar definieras fullt ut av någon kombination av "
"flaggorna i föregående avsnitt. För enkelhetens skull tillhandahåller "
"buffertprotokollet ofta använda kombinationer som enskilda flaggor."

msgid ""
"In the following table *U* stands for undefined contiguity. The consumer "
"would have to call :c:func:`PyBuffer_IsContiguous` to determine contiguity."
msgstr ""
"I följande tabell står *U* för undefined contiguity (odefinierad "
"sammanhängande). Konsumenten måste anropa :c:func:`PyBuffer_IsContiguous` "
"för att avgöra sammanhängande."

msgid "readonly"
msgstr "skrivskyddad"

msgid "format"
msgstr "format"

msgid "U"
msgstr "U"

msgid "0"
msgstr "0"

msgid "1 or 0"
msgstr "1 eller 0"

msgid "Complex arrays"
msgstr "Komplexa matriser"

msgid "NumPy-style: shape and strides"
msgstr "NumPy-stil: form och strides"

msgid ""
"The logical structure of NumPy-style arrays is defined by :c:member:"
"`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer."
"shape` and :c:member:`~Py_buffer.strides`."
msgstr ""
"Den logiska strukturen för matriser i NumPy-stil definieras av :c:member:"
"`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer."
"shape` och :c:member:`~Py_buffer.strides`."

msgid ""
"If ``ndim == 0``, the memory location pointed to by :c:member:`~Py_buffer."
"buf` is interpreted as a scalar of size :c:member:`~Py_buffer.itemsize`. In "
"that case, both :c:member:`~Py_buffer.shape` and :c:member:`~Py_buffer."
"strides` are ``NULL``."
msgstr ""
"Om ``ndim == 0``, tolkas minnesplatsen som pekas ut av :c:member:`~Py_buffer."
"buf` som en skalär av storleken :c:member:`~Py_buffer.itemsize`. I det "
"fallet är både :c:member:`~Py_buffer.shape` och :c:member:`~Py_buffer."
"strides` ``NULL``."

msgid ""
"If :c:member:`~Py_buffer.strides` is ``NULL``, the array is interpreted as a "
"standard n-dimensional C-array. Otherwise, the consumer must access an n-"
"dimensional array as follows:"
msgstr ""
"Om :c:member:`~Py_buffer.strides` är ``NULL`` tolkas matrisen som en "
"standard n-dimensionell C-array. Annars måste konsumenten komma åt en n-"
"dimensionell array på följande sätt:"

msgid ""
"ptr = (char *)buf + indices[0] * strides[0] + ... + indices[n-1] * "
"strides[n-1];\n"
"item = *((typeof(item) *)ptr);"
msgstr ""
"ptr = (char *)buf + index[0] * strides[0] + ... + index[n-1] * "
"strides[n-1];\n"
"objekt = *((typeof(objekt) *)ptr);"

msgid ""
"As noted above, :c:member:`~Py_buffer.buf` can point to any location within "
"the actual memory block. An exporter can check the validity of a buffer with "
"this function:"
msgstr ""
"Som nämnts ovan kan :c:member:`~Py_buffer.buf` peka på vilken plats som "
"helst inom det faktiska minnesblocket. En exportör kan kontrollera "
"giltigheten av en buffert med denna funktion:"

msgid ""
"def verify_structure(memlen, itemsize, ndim, shape, strides, offset):\n"
"    \"\"\"Verify that the parameters represent a valid array within\n"
"       the bounds of the allocated memory:\n"
"           char *mem: start of the physical memory block\n"
"           memlen: length of the physical memory block\n"
"           offset: (char *)buf - mem\n"
"    \"\"\"\n"
"    if offset % itemsize:\n"
"        return False\n"
"    if offset < 0 or offset+itemsize > memlen:\n"
"        return False\n"
"    if any(v % itemsize for v in strides):\n"
"        return False\n"
"\n"
"    if ndim <= 0:\n"
"        return ndim == 0 and not shape and not strides\n"
"    if 0 in shape:\n"
"        return True\n"
"\n"
"    imin = sum(strides[j]*(shape[j]-1) for j in range(ndim)\n"
"               if strides[j] <= 0)\n"
"    imax = sum(strides[j]*(shape[j]-1) for j in range(ndim)\n"
"               if strides[j] > 0)\n"
"\n"
"    return 0 <= offset+imin and offset+imax+itemsize <= memlen"
msgstr ""
"def verify_structure(memlen, itemsize, ndim, shape, strides, offset):\n"
"    \"\"\"Verifiera att parametrarna representerar en giltig array inom\n"
"       gränserna för det allokerade minnet:\n"
"           char *mem: början på det fysiska minnesblocket\n"
"           memlen: längden på det fysiska minnesblocket\n"
"           offset: (char *)buf - mem\n"
"    \"\"\"\n"
"    om offset % itemsize:\n"
"        returnera False\n"
"    om offset < 0 eller offset+itemsize > memlen:\n"
"        returnera False\n"
"    if any(v % itemsize för v i strides):\n"
"        returnera False\n"
"\n"
"    om ndim <= 0:\n"
"        return ndim == 0 och inte shape och inte strides\n"
"    om 0 i shape:\n"
"        returnera True\n"
"\n"
"    imin = sum(strides[j]*(shape[j]-1) for j in range(ndim)\n"
"               om strides[j] <= 0)\n"
"    imax = summa(strides[j]*(shape[j]-1) for j in range(ndim)\n"
"               om strides[j] > 0)\n"
"\n"
"    return 0 <= offset+imin och offset+imax+itemsize <= memlen"

msgid "PIL-style: shape, strides and suboffsets"
msgstr "PIL-stil: form, strides och suboffsets"

msgid ""
"In addition to the regular items, PIL-style arrays can contain pointers that "
"must be followed in order to get to the next element in a dimension. For "
"example, the regular three-dimensional C-array ``char v[2][2][3]`` can also "
"be viewed as an array of 2 pointers to 2 two-dimensional arrays: ``char "
"(*v[2])[2][3]``. In suboffsets representation, those two pointers can be "
"embedded at the start of :c:member:`~Py_buffer.buf`, pointing to two ``char "
"x[2][3]`` arrays that can be located anywhere in memory."
msgstr ""
"Förutom de vanliga elementen kan matriser i PIL-stil innehålla pekare som "
"måste följas för att komma till nästa element i en dimension. Till exempel "
"kan den vanliga tredimensionella C-arrayen ``char v[2][2][3]`` också ses som "
"en array med 2 pekare till 2 tvådimensionella arrayer: ``char (*v[2])[2]"
"[3]``. I suboffsets-representationen kan dessa två pekare bäddas in i början "
"av :c:member:`~Py_buffer.buf` och peka på två ``char x[2][3]``-arrayer som "
"kan placeras var som helst i minnet."

msgid ""
"Here is a function that returns a pointer to the element in an N-D array "
"pointed to by an N-dimensional index when there are both non-``NULL`` "
"strides and suboffsets::"
msgstr ""
"Här är en funktion som returnerar en pekare till elementet i en N-D-array "
"som pekas ut av ett N-dimensionellt index när det finns både icke-``NULL`` "
"strides och suboffsets::"

msgid ""
"void *get_item_pointer(int ndim, void *buf, Py_ssize_t *strides,\n"
"                       Py_ssize_t *suboffsets, Py_ssize_t *indices) {\n"
"    char *pointer = (char*)buf;\n"
"    int i;\n"
"    for (i = 0; i < ndim; i++) {\n"
"        pointer += strides[i] * indices[i];\n"
"        if (suboffsets[i] >=0 ) {\n"
"            pointer = *((char**)pointer) + suboffsets[i];\n"
"        }\n"
"    }\n"
"    return (void*)pointer;\n"
"}"
msgstr ""
"void *get_item_pointer(int ndim, void *buf, Py_ssize_t *strides,\n"
"                       Py_ssize_t *strides, Py_ssize_t *suboffsets, "
"Py_ssize_t *indices) {\n"
"    char *pointer = (char*)buf;\n"
"    int i;\n"
"    for (i = 0; i < ndim; i++) {\n"
"        pekare += strides[i] * index[i];\n"
"        om (suboffsets[i] >=0 ) {\n"
"            pekare = *((char**)pekare) + suboffsets[i];\n"
"        }\n"
"    }\n"
"    return (void*)pekare;\n"
"}"

msgid "Buffer-related functions"
msgstr "Buffertrelaterade funktioner"

msgid ""
"Return ``1`` if *obj* supports the buffer interface otherwise ``0``.  When "
"``1`` is returned, it doesn't guarantee that :c:func:`PyObject_GetBuffer` "
"will succeed.  This function always succeeds."
msgstr ""
"Returnerar ``1`` om *obj* stöder buffertgränssnittet annars ``0``.  När "
"``1`` returneras, garanterar det inte att :c:func:`PyObject_GetBuffer` "
"kommer att lyckas.  Denna funktion lyckas alltid."

msgid ""
"Send a request to *exporter* to fill in *view* as specified by  *flags*. If "
"the exporter cannot provide a buffer of the exact type, it MUST raise :exc:"
"`BufferError`, set ``view->obj`` to ``NULL`` and return ``-1``."
msgstr ""
"Skicka en begäran till *exportör* om att fylla i *view* enligt "
"specifikationen i *flags*. Om exportören inte kan tillhandahålla en buffert "
"av exakt typ, MÅSTE den ge upphov till :exc:`BufferError`, sätta ``view-"
">obj`` till ``NULL`` och returnera ``-1``."

msgid ""
"On success, fill in *view*, set ``view->obj`` to a new reference to "
"*exporter* and return 0. In the case of chained buffer providers that "
"redirect requests to a single object, ``view->obj`` MAY refer to this object "
"instead of *exporter* (See :ref:`Buffer Object Structures <buffer-structs>`)."
msgstr ""
"Vid framgång, fyll i *view*, sätt ``view-&gt;obj`` till en ny referens till "
"*exporter* och returnera 0. När det gäller kedjade buffertleverantörer som "
"omdirigerar förfrågningar till ett enda objekt, KAN ``view-&gt;obj`` "
"referera till detta objekt istället för *exporter* (Se :ref:"
"``Buffertobjektstrukturer <buffer-structs>``)."

msgid ""
"Successful calls to :c:func:`PyObject_GetBuffer` must be paired with calls "
"to :c:func:`PyBuffer_Release`, similar to :c:func:`malloc` and :c:func:"
"`free`. Thus, after the consumer is done with the buffer, :c:func:"
"`PyBuffer_Release` must be called exactly once."
msgstr ""
"Lyckade anrop till :c:func:`PyObject_GetBuffer` måste paras ihop med anrop "
"till :c:func:`PyBuffer_Release`, på samma sätt som :c:func:`malloc` och :c:"
"func:`free`. Efter att konsumenten är klar med bufferten måste alltså :c:"
"func:`PyBuffer_Release` anropas exakt en gång."

msgid ""
"Release the buffer *view* and release the :term:`strong reference` (i.e. "
"decrement the reference count) to the view's supporting object, ``view-"
">obj``. This function MUST be called when the buffer is no longer being "
"used, otherwise reference leaks may occur."
msgstr ""
"Frigör bufferten *view* och frigör :term:`strong-referensen` (dvs. decimera "
"referensantalet) till vyns stödobjekt, ``view->obj``. Denna funktion MÅSTE "
"anropas när bufferten inte längre används, annars kan referensläckor uppstå."

msgid ""
"It is an error to call this function on a buffer that was not obtained via :"
"c:func:`PyObject_GetBuffer`."
msgstr ""
"Det är ett fel att anropa denna funktion på en buffert som inte erhölls via :"
"c:func:`PyObject_GetBuffer`."

msgid ""
"Return the implied :c:member:`~Py_buffer.itemsize` from :c:member:"
"`~Py_buffer.format`. On error, raise an exception and return -1."
msgstr ""
"Returnerar den underförstådda :c:member:`~Py_buffer.itemsize` från :c:member:"
"`~Py_buffer.format`. Vid fel, skapa ett undantag och returnera -1."

msgid ""
"Return ``1`` if the memory defined by the *view* is C-style (*order* is "
"``'C'``) or Fortran-style (*order* is ``'F'``) :term:`contiguous` or either "
"one (*order* is ``'A'``).  Return ``0`` otherwise.  This function always "
"succeeds."
msgstr ""
"Returnerar ``1`` om minnet som definieras av *vyn* är C-stil (*ordning* är "
"``'C'``) eller Fortran-stil (*ordning* är ``'F'``) :term:`contiguous` eller "
"endera (*ordning* är ``'A'``).  Returnerar ``0`` annars.  Denna funktion "
"lyckas alltid."

msgid ""
"Get the memory area pointed to by the *indices* inside the given *view*. "
"*indices* must point to an array of ``view->ndim`` indices."
msgstr ""
"Hämta minnesområdet som pekas ut av *indices* i den givna *view*. *indices* "
"måste peka på en array av ``view->ndim`` index."

msgid ""
"Copy contiguous *len* bytes from *buf* to *view*. *fort* can be ``'C'`` or "
"``'F'`` (for C-style or Fortran-style ordering). ``0`` is returned on "
"success, ``-1`` on error."
msgstr ""
"Kopiera sammanhängande *len* byte från *buf* till *view*. *fort* kan vara "
"``'C'`` eller ``'F'`` (för C-stil eller Fortran-stil ordning). ``0`` "
"returneras vid framgång, ``-1`` vid fel."

msgid ""
"Copy *len* bytes from *src* to its contiguous representation in *buf*. "
"*order* can be ``'C'`` or ``'F'`` or ``'A'`` (for C-style or Fortran-style "
"ordering or either one). ``0`` is returned on success, ``-1`` on error."
msgstr ""
"Kopiera *len* bytes från *src* till dess sammanhängande representation i "
"*buf*. *order* kan vara ``'C'`` eller ``'F'`` eller ``'A'`` (för C-stil "
"eller Fortran-stil eller endera). ``0`` returneras vid framgång, ``-1`` vid "
"fel."

msgid "This function fails if *len* != *src->len*."
msgstr "Denna funktion misslyckas om *len* != *src->len*."

msgid ""
"Copy data from *src* to *dest* buffer. Can convert between C-style and or "
"Fortran-style buffers."
msgstr ""
"Kopiera data från *src* till *dest* buffert. Kan konvertera mellan buffertar "
"i C-stil eller Fortran-stil."

msgid "``0`` is returned on success, ``-1`` on error."
msgstr "``0`` returneras vid framgång, ``-1`` vid fel."

msgid ""
"Fill the *strides* array with byte-strides of a :term:`contiguous` (C-style "
"if *order* is ``'C'`` or Fortran-style if *order* is ``'F'``) array of the "
"given shape with the given number of bytes per element."
msgstr ""
"Fyll *strides*-arrayen med byte-strides av en :term:`kontiguous` (C-style om "
"*order* är ``'C'`` eller Fortran-style om *order* är ``'F'``) array av den "
"givna formen med det givna antalet bytes per element."

msgid ""
"Handle buffer requests for an exporter that wants to expose *buf* of size "
"*len* with writability set according to *readonly*. *buf* is interpreted as "
"a sequence of unsigned bytes."
msgstr ""
"Hantera buffertförfrågningar för en exportör som vill exponera *buf* av "
"storlek *len* med skrivbarhet inställd enligt *readonly*. *buf* tolkas som "
"en sekvens av osignerade bytes."

msgid ""
"The *flags* argument indicates the request type. This function always fills "
"in *view* as specified by flags, unless *buf* has been designated as read-"
"only and :c:macro:`PyBUF_WRITABLE` is set in *flags*."
msgstr ""
"Argumentet *flags* anger typen av begäran. Den här funktionen fyller alltid "
"i *view* enligt flaggorna, såvida inte *buf* har angetts som skrivskyddad "
"och :c:macro:`PyBUF_WRITABLE` har angetts i *flags*."

msgid ""
"On success, set ``view->obj`` to a new reference to *exporter* and return 0. "
"Otherwise, raise :exc:`BufferError`, set ``view->obj`` to ``NULL`` and "
"return ``-1``;"
msgstr ""
"Vid framgång, sätt ``view->obj`` till en ny referens till *exporter* och "
"returnera 0. Annars, raise :exc:`BufferError`, set ``view->obj`` to ``NULL`` "
"and return ``-1``;"

msgid ""
"If this function is used as part of a :ref:`getbufferproc <buffer-structs>`, "
"*exporter* MUST be set to the exporting object and *flags* must be passed "
"unmodified. Otherwise, *exporter* MUST be ``NULL``."
msgstr ""
"Om denna funktion används som en del av en :ref:`getbufferproc <buffer-"
"structs>`, MÅSTE *exporter* sättas till det exporterande objektet och "
"*flags* måste skickas oförändrat. Annars MÅSTE *exporter* vara ``NULL``."

msgid "buffer protocol"
msgstr "buffertprotokoll"

msgid "buffer interface"
msgstr "buffertgränssnitt"

msgid "(see buffer protocol)"
msgstr "(se buffertprotokoll)"

msgid "buffer object"
msgstr "buffertobjekt"

msgid "PyBufferProcs (C type)"
msgstr "PyBufferProcs (C-typ)"

msgid "contiguous"
msgstr "angränsande"

msgid "C-contiguous"
msgstr "C-slutande"

msgid "Fortran contiguous"
msgstr "Fortran sammanhängande"
