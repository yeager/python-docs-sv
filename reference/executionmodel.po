# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Execution model"
msgstr "Exekveringsmodell"

msgid "Structure of a program"
msgstr "Uppbyggnad av ett program"

msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a :"
"option:`-m` argument is also a code block. The string argument passed to the "
"built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Ett Python-program är uppbyggt av kodblock. Ett :dfn:`block` är en bit "
"Python-programtext som exekveras som en enhet. Följande är block: en modul, "
"en funktionskropp och en klassdefinition. Varje kommando som skrivs "
"interaktivt är ett block.  En skriptfil (en fil som ges som "
"standardinmatning till tolken eller som anges som ett kommandoradsargument "
"till tolken) är ett kodblock.  Ett skriptkommando (ett kommando som anges på "
"tolkens kommandorad med alternativet :option:`-c`) är ett kodblock. En modul "
"som körs som ett toppnivåskript (som modul ``__main__``) från kommandoraden "
"med :option:`-m`-argumentet är också ett kodblock. Strängargumentet som "
"skickas till de inbyggda funktionerna :func:`eval` och :func:`exec` är ett "
"kodblock."

msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""
"Ett kodblock exekveras i en :dfn:`exekveringsram`.  En frame innehåller viss "
"administrativ information (används för felsökning) och bestämmer var och hur "
"exekveringen fortsätter efter att kodblockets exekvering har slutförts."

msgid "Naming and binding"
msgstr "Namngivning och bindning"

msgid "Binding of names"
msgstr "Bindning av namn"

msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
":dfn:`Namn` refererar till objekt.  Namn introduceras genom "
"namnbindningsoperationer."

msgid "The following constructs bind names:"
msgstr "Följande konstruktioner binder namn:"

msgid "formal parameters to functions,"
msgstr "formella parametrar till funktioner,"

msgid "class definitions,"
msgstr "klassdefinitioner,"

msgid "function definitions,"
msgstr "funktionsdefinitioner,"

msgid "assignment expressions,"
msgstr "uppdragsuttryck,"

msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr ""
":ref:`targets <assignment>` som är identifierare om de förekommer i ett "
"uppdrag:"

msgid ":keyword:`for` loop header,"
msgstr ":nyckelord:`for` loop header,"

msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""
"efter :keyword:`!as` i en :keyword:`with`-sats, :keyword:`except`-klausul, :"
"keyword:`except* <except_star>`-klausul eller i as-mönstret vid strukturell "
"mönstermatchning,"

msgid "in a capture pattern in structural pattern matching"
msgstr "i ett fångstmönster i strukturell mönstermatchning"

msgid ":keyword:`import` statements."
msgstr ":nyckelord:`import` uttalanden."

msgid ":keyword:`type` statements."
msgstr ":nyckelord:`typ` uttalanden."

msgid ":ref:`type parameter lists <type-params>`."
msgstr ":ref:`typ parameter listar <type-params>`."

msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all "
"names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"Satsen :keyword:`!import` av formen ``from ... import *`` binder alla namn "
"som definieras i den importerade modulen, utom de som börjar med ett "
"understreck. Denna form får endast användas på modulnivå."

msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"Ett mål som förekommer i en :keyword:`del`-sats anses också vara bundet för "
"detta ändamål (även om den faktiska semantiken är att avbinda namnet)."

msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"Varje assignment- eller importsats sker inom ett block som definieras av en "
"klass- eller funktionsdefinition eller på modulnivå (kodblocket på högsta "
"nivån)."

msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :term:`free variable`."
msgstr ""
"Om ett namn är bundet i ett block är det en lokal variabel i det blocket, "
"såvida det inte deklarerats som :keyword:`nonlocal` eller :keyword:"
"`global`.  Om ett namn är bundet på modulnivå är det en global variabel.  "
"(Variablerna i modulens kodblock är lokala och globala.) Om en variabel "
"används i ett kodblock men inte definieras där, är den en :term:`fri "
"variabel`."

msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"Varje förekomst av ett namn i programtexten hänvisar till den :dfn:"
"`bindning` av namnet som fastställs genom följande regler för namnupplösning."

msgid "Resolution of names"
msgstr "Upplösning av namn"

msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
"En :dfn:`scope` definierar synligheten för ett namn inom ett block.  Om en "
"lokal variabel definieras i ett block, omfattar dess scope det blocket.  Om "
"definitionen sker i ett funktionsblock, sträcker sig räckvidden till alla "
"block som ingår i det definierande blocket, såvida inte ett block som ingår "
"i blocket inför en annan bindning för namnet."

msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"När ett namn används i ett kodblock löses det upp med hjälp av det närmast "
"omgivande scopet.  Uppsättningen av alla sådana scopes som är synliga för "
"ett kodblock kallas blockets :dfn:`environment`."

msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Om ett namn inte hittas alls, uppstår ett :exc:`NameError` undantag. Om det "
"aktuella omfånget är ett funktionsomfång och namnet hänvisar till en lokal "
"variabel som ännu inte har bundits till ett värde vid den punkt där namnet "
"används, kommer ett :exc:`UnboundLocalError` undantag att uppstå. :exc:"
"`UnboundLocalError` är en subklass av :exc:`NameError`."

msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations. See :ref:`the FAQ entry on "
"UnboundLocalError <faq-unboundlocalerror>` for examples."
msgstr ""
"Om en namnbindningsoperation sker var som helst inom ett kodblock, behandlas "
"alla användningar av namnet inom blocket som referenser till det aktuella "
"blocket.  Detta kan leda till fel när ett namn används inom ett block innan "
"det är bundet.  Denna regel är subtil.  Python saknar deklarationer och "
"tillåter att namnbindning sker var som helst inom ett kodblock.  De lokala "
"variablerna i ett kodblock kan bestämmas genom att skanna hela texten i "
"blocket för namnbindningsoperationer. Se :ref:`` FAQ-posten om "
"UnboundLocalError <faq-unboundlocalerror>` för exempel."

msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the names are not "
"found there, the builtins namespace is searched next. If the names are also "
"not found in the builtins namespace, new variables are created in the global "
"namespace. The global statement must precede all uses of the listed names."
msgstr ""
"Om :keyword:`global`-satsen förekommer i ett block, hänvisar alla "
"användningar av de namn som anges i satsen till bindningarna av dessa namn i "
"namnrymden på översta nivån.  Namn löses i namnrymden på översta nivån genom "
"att söka i den globala namnrymden, dvs. namnrymden för den modul som "
"innehåller kodblocket, och namnrymden för inbyggda program, namnrymden för "
"modulen :mod:`builtins`.  Den globala namnrymden genomsöks först.  Om namnen "
"inte hittas där, söks därefter i builtins-namnrymden. Om namnen inte heller "
"hittas i namnrymden för builtins skapas nya variabler i den globala "
"namnrymden. Global-satsen måste föregå alla användningar av de listade "
"namnen."

msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
"Satsen :keyword:`global` har samma omfattning som en namnbindningsoperation "
"i samma block.  Om det närmaste omslutande området för en fri variabel "
"innehåller en global-sats, behandlas den fria variabeln som en global."

msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope. :ref:`Type parameters <type-params>` cannot be "
"rebound with the :keyword:`!nonlocal` statement."
msgstr ""
"Satsen :keyword:`nonlocal` gör att motsvarande namn refererar till tidigare "
"bundna variabler i närmaste omslutande funktionsområde. :exc:`SyntaxError` "
"tas upp vid kompilering om det angivna namnet inte finns i något omslutande "
"funktionsområde. :ref:`Type parameters <type-params>` kan inte återbindas "
"med satsen :keyword:`!nonlocal`."

msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"Namnrymden för en modul skapas automatiskt första gången en modul "
"importeras.  Huvudmodulen för ett skript kallas alltid :mod:`__main__`."

msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods. This includes comprehensions and generator "
"expressions, but it does not include :ref:`annotation scopes <annotation-"
"scopes>`, which have access to their enclosing class scopes. This means that "
"the following will fail::"
msgstr ""
"Klassdefinitionsblock och argument till :func:`exec` och :func:`eval` är "
"speciella i samband med namnupplösning. En klassdefinition är en körbar sats "
"som kan använda och definiera namn. Dessa referenser följer de normala "
"reglerna för namnupplösning med undantaget att obundna lokala variabler söks "
"upp i den globala namnrymden. Namnrymden för klassdefinitionen blir klassens "
"attributordbok. Omfattningen av namn som definieras i ett klassblock är "
"begränsad till klassblocket; den omfattar inte metodernas kodblock. Detta "
"inkluderar förståelser och generatoruttryck, men det inkluderar inte :ref:"
"`annotation scopes <annotation-scopes>`, som har tillgång till sina "
"omslutande klassomfång. Detta innebär att följande kommer att misslyckas::"

msgid ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"
msgstr ""
"klass A:\n"
"    a = 42\n"
"    b = list(a + i för i i intervall(10))"

msgid "However, the following will succeed::"
msgstr "Följande kommer dock att lyckas::"

msgid ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"
msgstr ""
"klass A:\n"
"    typ Alias = Nested\n"
"    klass Nested: pass\n"
"\n"
"print(A.Alias.__value__) # <typ 'A.Nested'>"

msgid "Annotation scopes"
msgstr "Omfattningar av anteckningar"

msgid ""
":term:`Annotations <annotation>`, :ref:`type parameter lists <type-params>` "
"and :keyword:`type` statements introduce *annotation scopes*, which behave "
"mostly like function scopes, but with some exceptions discussed below."
msgstr ""
":term:`Annotations <annotation>`, :ref:`type parameter lists <type-params>` "
"och :keyword:`type` introducerar *annotation scopes*, som mestadels beter "
"sig som funktion scopes, men med några undantag som diskuteras nedan."

msgid "Annotation scopes are used in the following contexts:"
msgstr "Annotationsscopes används i följande sammanhang:"

msgid ":term:`Function annotations <function annotation>`."
msgstr ":term:`Funktionsannoteringar <function annotation>`."

msgid ":term:`Variable annotations <variable annotation>`."
msgstr ":term:`Variabelanteckningar <variable annotation>`."

msgid ""
"Type parameter lists for :ref:`generic type aliases <generic-type-aliases>`."
msgstr ""
"Typ-parameterlistor för :ref:`generiska typalias <generic-type-aliases>`."

msgid ""
"Type parameter lists for :ref:`generic functions <generic-functions>`. A "
"generic function's annotations are executed within the annotation scope, but "
"its defaults and decorators are not."
msgstr ""
"Typ parameterlistor för :ref:`generiska funktioner <generic-functions>`. En "
"generisk funktions annotationer exekveras inom annotationens scope, men dess "
"standardvärden och dekoratorer gör det inte."

msgid ""
"Type parameter lists for :ref:`generic classes <generic-classes>`. A generic "
"class's base classes and keyword arguments are executed within the "
"annotation scope, but its decorators are not."
msgstr ""
"Typ parameterlistor för :ref:`generiska klasser <generic-classes>`. En "
"generisk klass basklasser och nyckelordsargument exekveras inom "
"annotationens scope, men dess dekoratorer gör det inte."

msgid ""
"The bounds, constraints, and default values for type parameters (:ref:"
"`lazily evaluated <lazy-evaluation>`)."
msgstr ""
"Gränser, begränsningar och standardvärden för typparametrar (:ref:`slently "
"evaluated <lazy-evaluation>`)."

msgid "The value of type aliases (:ref:`lazily evaluated <lazy-evaluation>`)."
msgstr ""
"Värdet av typalias (:ref:`slentrianmässigt utvärderad <lazy-evaluation>`)."

msgid "Annotation scopes differ from function scopes in the following ways:"
msgstr "Annotationsscopes skiljer sig från funktionsscopes på följande sätt:"

msgid ""
"Annotation scopes have access to their enclosing class namespace. If an "
"annotation scope is immediately within a class scope, or within another "
"annotation scope that is immediately within a class scope, the code in the "
"annotation scope can use names defined in the class scope as if it were "
"executed directly within the class body. This contrasts with regular "
"functions defined within classes, which cannot access names defined in the "
"class scope."
msgstr ""
"Annotationsscopes har tillgång till sitt omslutande klassnamnrum. Om ett "
"annotationsscope ligger omedelbart inom ett klass-scope, eller inom ett "
"annat annotationsscope som ligger omedelbart inom ett klass-scope, kan koden "
"i annotationsscopet använda namn som definieras i klass-scopet som om den "
"exekverades direkt i klassens kropp. Detta står i kontrast till vanliga "
"funktioner som definieras inom klasser, vilka inte kan komma åt namn som "
"definieras i klassens scope."

msgid ""
"Expressions in annotation scopes cannot contain :keyword:`yield`, ``yield "
"from``, :keyword:`await`, or :token:`:= <python-grammar:"
"assignment_expression>` expressions. (These expressions are allowed in other "
"scopes contained within the annotation scope.)"
msgstr ""
"Uttryck i annotationsscopes kan inte innehålla :keyword:`yield`, ``yield "
"from``, :keyword:`await`, eller :token:`:= <python-grammar:"
"assignment_expression>` uttryck. (Dessa uttryck är tillåtna i andra scopes "
"som ingår i annotationsscopet)"

msgid ""
"Names defined in annotation scopes cannot be rebound with :keyword:"
"`nonlocal` statements in inner scopes. This includes only type parameters, "
"as no other syntactic elements that can appear within annotation scopes can "
"introduce new names."
msgstr ""
"Namn som definieras i annotationsscopes kan inte reboundas med :keyword:"
"`nonlocal`-satser i inner scopes. Detta gäller endast typparametrar, "
"eftersom inga andra syntaktiska element som kan förekomma inom "
"annotationsscopes kan introducera nya namn."

msgid ""
"While annotation scopes have an internal name, that name is not reflected in "
"the :term:`qualified name` of objects defined within the scope. Instead, "
"the :attr:`~definition.__qualname__` of such objects is as if the object "
"were defined in the enclosing scope."
msgstr ""
"Även om annotationsscopes har ett internt namn, återspeglas inte detta namn "
"i :term:`kvalificerat namn` för objekt som definieras inom scopet. Istället "
"är :attr:`~definition.__qualname__` för sådana objekt som om objektet "
"definierades i det omslutande scopet."

msgid "Annotation scopes were introduced in Python 3.12 as part of :pep:`695`."
msgstr ""
"Annotation scopes introducerades i Python 3.12 som en del av :pep:`695`."

msgid ""
"Annotation scopes are also used for type parameter defaults, as introduced "
"by :pep:`696`."
msgstr ""
"Annotation scopes används också för standardvärden för typparametrar, vilket "
"introducerades av :pep:`696`."

msgid ""
"Annotation scopes are now also used for annotations, as specified in :pep:"
"`649` and :pep:`749`."
msgstr ""
"Annotation scopes används nu även för annotationer, enligt specifikationerna "
"i :pep:`649` och :pep:`749`."

msgid "Lazy evaluation"
msgstr "Ledig utvärdering"

msgid ""
"Most annotation scopes are *lazily evaluated*. This includes annotations, "
"the values of type aliases created through the :keyword:`type` statement, "
"and the bounds, constraints, and default values of type variables created "
"through the :ref:`type parameter syntax <type-params>`. This means that they "
"are not evaluated when the type alias or type variable is created, or when "
"the object carrying annotations is created. Instead, they are only evaluated "
"when necessary, for example when the ``__value__`` attribute on a type alias "
"is accessed."
msgstr ""
"De flesta annotationsscope utvärderas *slentrianmässigt*. Detta inkluderar "
"annoteringar, värdena för typalias som skapats genom :keyword:`type`-satsen "
"och gränser, begränsningar och standardvärden för typvariabler som skapats "
"genom :ref:`type parameter syntax <type-params>`. Detta innebär att de inte "
"utvärderas när typaliaset eller typvariabeln skapas, eller när objektet med "
"annoteringar skapas. Istället utvärderas de bara när det är nödvändigt, till "
"exempel när attributet ``__value__`` på ett typalias används."

msgid "Example:"
msgstr "Exempel:"

msgid ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"
msgstr ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"

msgid ""
"Here the exception is raised only when the ``__value__`` attribute of the "
"type alias or the ``__bound__`` attribute of the type variable is accessed."
msgstr ""
"Här utlöses undantaget endast när attributet ``__value__`` för typaliaset "
"eller attributet ``__bound__`` för typvariabeln används."

msgid ""
"This behavior is primarily useful for references to types that have not yet "
"been defined when the type alias or type variable is created. For example, "
"lazy evaluation enables creation of mutually recursive type aliases::"
msgstr ""
"Detta beteende är främst användbart för referenser till typer som ännu inte "
"har definierats när typaliaset eller typvariabeln skapas. Latent utvärdering "
"gör det till exempel möjligt att skapa ömsesidigt rekursiva typalias::"

msgid ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"
msgstr ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"

msgid ""
"Lazily evaluated values are evaluated in :ref:`annotation scope <annotation-"
"scopes>`, which means that names that appear inside the lazily evaluated "
"value are looked up as if they were used in the immediately enclosing scope."
msgstr ""
"Latent utvärderade värden utvärderas i :ref:`annotation scope <annotation-"
"scopes>`, vilket innebär att namn som förekommer inuti det latent "
"utvärderade värdet slås upp som om de användes i det omedelbart omgivande "
"scopet."

msgid "Builtins and restricted execution"
msgstr "Inbyggnader och begränsat utförande"

msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"Användare bör inte röra ``__builtins__``; det är enbart en "
"implementationsdetalj.  Användare som vill åsidosätta värden i namnrymden "
"för builtins bör :keyword:`importera` modulen :mod:`builtins` och ändra dess "
"attribut på lämpligt sätt."

msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"Namnrymden för inbyggda program som är associerad med exekveringen av ett "
"kodblock hittas genom att slå upp namnet ``__builtins__`` i dess globala "
"namnrymd; detta bör vara en ordbok eller en modul (i det senare fallet "
"används modulens ordbok).  Som standard är ``__builtins__`` den inbyggda "
"modulen :mod:`builtins` när den finns i modulen :mod:`__main__`; när den "
"finns i någon annan modul är ``__builtins__`` ett alias för ordlistan i "
"själva modulen :mod:`builtins`."

msgid "Interaction with dynamic features"
msgstr "Interaktion med dynamiska funktioner"

msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"Namnupplösning av fria variabler sker vid körning, inte vid kompilering. "
"Detta innebär att följande kod kommer att skriva ut 42::"

msgid ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"
msgstr ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"

msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
"Funktionerna :func:`eval` och :func:`exec` har inte tillgång till hela "
"miljön för att lösa namn.  Namn kan lösas i anroparens lokala och globala "
"namnrymder.  Fria variabler löses inte i den närmast omgivande namnrymden, "
"utan i den globala namnrymden.  [Funktionerna :func:`exec` och :func:`eval` "
"har valfria argument för att åsidosätta det globala och det lokala "
"namnområdet.  Om bara ett namnområde anges används det för båda."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"Undantag är ett sätt att bryta sig ur det normala kontrollflödet i ett "
"kodblock för att hantera fel eller andra exceptionella förhållanden.  Ett "
"undantag *utlöses* vid den punkt där felet upptäcks; det kan *hanteras* av "
"det omgivande kodblocket eller av något kodblock som direkt eller indirekt "
"åberopade det kodblock där felet inträffade."

msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Python-tolken skapar ett undantag när den upptäcker ett körtidsfel (t.ex. "
"division med noll).  Ett Python-program kan också uttryckligen skapa ett "
"undantag med :keyword:`raise`-satsen. Undantagshanterare specificeras med :"
"keyword:`try` ... :keyword:`except`-satsen.  Klausulen :keyword:`finally` i "
"en sådan sats kan användas för att specificera upprensningskod som inte "
"hanterar undantaget, men som exekveras oavsett om ett undantag inträffade "
"eller inte i den föregående koden."

msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Python använder \"termineringsmodellen\" för felhantering: en "
"undantagshanterare kan ta reda på vad som hände och fortsätta exekveringen "
"på en yttre nivå, men den kan inte reparera orsaken till felet och försöka "
"igen (förutom genom att skriva in den felande kodbiten från början)."

msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"När ett undantag inte hanteras alls, avslutar tolken exekveringen av "
"programmet eller återgår till sin interaktiva huvudslinga.  I båda fallen "
"skrivs en stack traceback ut, utom när undantaget är :exc:`SystemExit`."

msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"Undantag identifieras av klassinstanser.  Klausulen :keyword:`except` väljs "
"beroende på klassen i instansen: den måste referera till klassen i instansen "
"eller en :term:`icke-virtuell basklass <abstract base class>` därav. "
"Instansen kan tas emot av hanteraren och kan innehålla ytterligare "
"information om det exceptionella tillståndet."

msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"Undantagsmeddelanden är inte en del av Python API.  Deras innehåll kan "
"ändras från en version av Python till nästa utan förvarning och bör inte "
"användas av kod som körs under flera versioner av tolken."

msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Se även beskrivningen av :keyword:`try`-satsen i avsnitt :ref:`try` och :"
"keyword:`raise`-satsen i avsnitt :ref:`raise`."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""
"Denna begränsning uppstår eftersom koden som exekveras av dessa operationer "
"inte är tillgänglig när modulen kompileras."

msgid "execution model"
msgstr "exekveringsmodell"

msgid "code"
msgstr "kod"

msgid "block"
msgstr "block"

msgid "execution"
msgstr "exekvering"

msgid "frame"
msgstr "ram"

msgid "namespace"
msgstr "namnrymd"

msgid "scope"
msgstr "omfattning"

msgid "name"
msgstr "namn"

msgid "binding"
msgstr "bindning"

msgid "from"
msgstr "från"

msgid "import statement"
msgstr "importdeklaration"

msgid "free"
msgstr "gratis"

msgid "variable"
msgstr "variabel"

msgid "environment"
msgstr "miljö"

msgid "NameError (built-in exception)"
msgstr "NameError (inbyggt undantag)"

msgid "UnboundLocalError"
msgstr "ObundetLokaltFel"

msgid "module"
msgstr "modul"

msgid "__main__"
msgstr "__main__"

msgid "restricted"
msgstr "begränsad"

msgid "exception"
msgstr "undantag"

msgid "raise an exception"
msgstr "skapa ett undantag"

msgid "handle an exception"
msgstr "hantera ett undantag"

msgid "exception handler"
msgstr "hantering av undantag"

msgid "errors"
msgstr "fel"

msgid "error handling"
msgstr "felhantering"

msgid "termination model"
msgstr "termineringsmodell"

msgid "SystemExit (built-in exception)"
msgstr "SystemExit (inbyggt undantag)"
