# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!contextlib` --- Utilities for :keyword:`!with`\\ -statement contexts"
msgstr ":mod:`!contextlib` --- Verktyg för :keyword:`!with` -satskontexter"

msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**Källkod:** :source:`Lib/contextlib.py`"

msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""
"Denna modul tillhandahåller verktyg för vanliga uppgifter som involverar :"
"keyword:`with`-satsen. För mer information se även :ref:`typecontextmanager` "
"och :ref:`context-managers`."

msgid "Utilities"
msgstr "Verktyg"

msgid "Functions and classes provided:"
msgstr "Funktioner och klasser som tillhandahålls:"

msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__enter__` and :meth:`object.__exit__`. A default implementation for :meth:"
"`object.__enter__` is provided which returns ``self`` while :meth:`object."
"__exit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`typecontextmanager`."
msgstr ""
"En :term:`abstrakt basklass` för klasser som implementerar :meth:`object."
"__enter__` och :meth:`object.__exit__`. En standard implementation för :meth:"
"`object.__enter__` tillhandahålls som returnerar ``self`` medan :meth:"
"`object.__exit__` är en abstrakt metod som som standard returnerar ``None``. "
"Se även definitionen av :ref:`typecontextmanager`."

msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__aenter__` and :meth:`object.__aexit__`. A default implementation for :meth:"
"`object.__aenter__` is provided which returns ``self`` while :meth:`object."
"__aexit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`async-context-managers`."
msgstr ""
"En :term:`abstrakt basklass` för klasser som implementerar :meth:`object."
"__aenter__` och :meth:`object.__aexit__`. En standard implementation för :"
"meth:`object.__aenter__` tillhandahålls som returnerar ``self`` medan :meth:"
"`object.__aexit__` är en abstrakt metod som som standard returnerar "
"``None``. Se även definitionen av :ref:`async-context-managers`."

msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`~object.__enter__` and :meth:`~object."
"__exit__` methods."
msgstr ""
"Denna funktion är en :term:`decorator` som kan användas för att definiera en "
"fabriksfunktion för :keyword:`with` statement context managers, utan att "
"behöva skapa en klass eller separata :meth:`~object.__enter__` och :meth:"
"`~object.__exit__` metoder."

msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with ``contextlib."
"closing``."
msgstr ""
"Många objekt har inbyggt stöd för användning i with-satser, men ibland måste "
"en resurs hanteras som inte är en egen kontexthanterare och som inte "
"implementerar en ``close()``-metod för användning med ``contextlib.closing``."

msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr ""
"Ett abstrakt exempel skulle kunna vara följande för att säkerställa korrekt "
"resurshantering::"

msgid ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def managed_resource(*args, **kwds):\n"
"    # Code to acquire resource, e.g.:\n"
"    resource = acquire_resource(*args, **kwds)\n"
"    try:\n"
"        yield resource\n"
"    finally:\n"
"        # Code to release resource, e.g.:\n"
"        release_resource(resource)"
msgstr ""
"från contextlib import contextmanager\n"
"\n"
"@kontexthanterare\n"
"def managed_resource(*args, **kwds):\n"
"    # Kod för att förvärva resurs, t.ex:\n"
"    resurs = förvärva_resurs(*args, **kwds)\n"
"    försök:\n"
"        ge resurs\n"
"    slutligen:\n"
"        # Kod för att frigöra en resurs, t.ex:\n"
"        release_resource(resurs)"

msgid "The function can then be used like this::"
msgstr "Funktionen kan sedan användas på följande sätt::"

msgid ""
">>> with managed_resource(timeout=3600) as resource:\n"
"...     # Resource is released at the end of this block,\n"
"...     # even if code in the block raises an exception"
msgstr ""
">>> med managed_resource(timeout=3600) som resurs:\n"
"...     # Resursen frigörs i slutet av detta block,\n"
"...     # även om koden i blocket utlöser ett undantag"

msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`!as` clause, if any."
msgstr ""
"Den funktion som dekoreras måste returnera en :term:`generator`-iterator när "
"den anropas. Denna iterator måste ge exakt ett värde, som kommer att bindas "
"till målen i :keyword:`with`-satsens :keyword:`!as`-klausul, om någon."

msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`!with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`!with` statement."
msgstr ""
"Vid den punkt där generatorn ger upp, körs det block som är inbäddat i :"
"keyword:`with`-satsen.  Generatorn återupptas sedan efter att blocket har "
"avslutats. Om ett ohanterat undantag inträffar i blocket, återupprepas det "
"inuti generatorn vid den punkt där yield inträffade.  Du kan alltså använda "
"en :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally`-sats för "
"att fånga upp felet (om det finns något) eller se till att en viss "
"upprensning sker. Om ett undantag fångas enbart för att logga det eller för "
"att utföra någon åtgärd (snarare än att undertrycka det helt), måste "
"generatorn göra om undantaget. I annat fall kommer generatorns "
"kontexthanterare att indikera för :keyword:`!with`-satsen att undantaget har "
"hanterats, och exekveringen kommer att återupptas med den sats som följer "
"omedelbart efter :keyword:`!with`-satsen."

msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
":func:`contextmanager` använder :class:`ContextDecorator` så att de "
"kontexthanterare som skapas kan användas som dekoratorer såväl som i :"
"keyword:`with`-satser. När den används som en dekorator skapas en ny "
"generatorinstans implicit vid varje funktionsanrop (detta gör att de annars "
"\"enstaka\" kontexthanterare som skapas av :func:`contextmanager` uppfyller "
"kravet på att kontexthanterare stöder flera anrop för att kunna användas som "
"dekoratorer)."

msgid "Use of :class:`ContextDecorator`."
msgstr "Användning av :class:`ContextDecorator`."

msgid ""
"Similar to :func:`~contextlib.contextmanager`, but creates an :ref:"
"`asynchronous context manager <async-context-managers>`."
msgstr ""
"Liknar :func:`~contextlib.contextmanager`, men skapar en :ref:``asynkron "
"kontexthanterare <async-context-managers>`."

msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`async with` statement asynchronous context managers, "
"without needing to create a class or separate :meth:`~object.__aenter__` "
"and :meth:`~object.__aexit__` methods. It must be applied to an :term:"
"`asynchronous generator` function."
msgstr ""
"Denna funktion är en :term:`decorator` som kan användas för att definiera en "
"fabriksfunktion för :keyword:`async with` statement asynchronous context "
"managers, utan att behöva skapa en klass eller separata :meth:`~object."
"__aenter__` och :meth:`~object.__aexit__` metoder. Den måste tillämpas på "
"en :term:`asynchronous generator`-funktion."

msgid "A simple example::"
msgstr "Ett enkelt exempel::"

msgid ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def get_connection():\n"
"    conn = await acquire_db_connection()\n"
"    try:\n"
"        yield conn\n"
"    finally:\n"
"        await release_db_connection(conn)\n"
"\n"
"async def get_all_users():\n"
"    async with get_connection() as conn:\n"
"        return conn.query('SELECT ...')"
msgstr ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontexthanterare\n"
"async def get_connection():\n"
"    conn = await acquire_db_connection()\n"
"    try:\n"
"        ge conn\n"
"    slutligen:\n"
"        await release_db_connection(conn)\n"
"\n"
"async def get_all_users():\n"
"    async med get_connection() som conn:\n"
"        return conn.query('SELECT ...')"

msgid ""
"Context managers defined with :func:`asynccontextmanager` can be used either "
"as decorators or with :keyword:`async with` statements::"
msgstr ""
"Kontexthanterare som definieras med :func:`asynccontextmanager` kan användas "
"antingen som dekoratorer eller med :keyword:`async with`-satser::"

msgid ""
"import time\n"
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def timeit():\n"
"    now = time.monotonic()\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        print(f'it took {time.monotonic() - now}s to run')\n"
"\n"
"@timeit()\n"
"async def main():\n"
"    # ... async code ..."
msgstr ""
"import time\n"
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def timeit():\n"
"    now = time.monotonic()\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        print(f'it took {time.monotonic() - now}s to run')\n"
"\n"
"@timeit()\n"
"async def main():\n"
"    # ... async code ..."

msgid ""
"When used as a decorator, a new generator instance is implicitly created on "
"each function call. This allows the otherwise \"one-shot\" context managers "
"created by :func:`asynccontextmanager` to meet the requirement that context "
"managers support multiple invocations in order to be used as decorators."
msgstr ""
"När den används som en dekorator skapas en ny generatorinstans implicit vid "
"varje funktionsanrop. Detta gör att de annars \"one-shot\" kontexthanterare "
"som skapas av :func:`asynccontextmanager` uppfyller kravet på att "
"kontexthanterare stöder flera anrop för att kunna användas som dekoratorer."

msgid ""
"Async context managers created with :func:`asynccontextmanager` can be used "
"as decorators."
msgstr ""
"Asynkrona kontexthanterare som skapats med :func:`asynccontextmanager` kan "
"användas som dekoratorer."

msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr ""
"Returnerar en kontexthanterare som stänger *något* när blocket har "
"slutförts.  Detta är i princip likvärdigt med::"

msgid ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def closing(thing):\n"
"    try:\n"
"        yield thing\n"
"    finally:\n"
"        thing.close()"
msgstr ""
"från contextlib import contextmanager\n"
"\n"
"@kontexthanterare\n"
"def stängning(sak):\n"
"    försök:\n"
"        ge sak\n"
"    slutligen:\n"
"        thing.close()"

msgid "And lets you write code like this::"
msgstr "Och låter dig skriva kod så här::"

msgid ""
"from contextlib import closing\n"
"from urllib.request import urlopen\n"
"\n"
"with closing(urlopen('https://www.python.org')) as page:\n"
"    for line in page:\n"
"        print(line)"
msgstr ""
"from contextlib import closing\n"
"from urllib.request import urlopen\n"
"\n"
"with closing(urlopen('https://www.python.org')) as page:\n"
"    for line in page:\n"
"        print(line)"

msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""
"utan att uttryckligen behöva stänga ``page``.  Även om ett fel inträffar "
"kommer ``page.close()`` att anropas när :keyword:`with`-blocket avslutas."

msgid ""
"Most types managing resources support the :term:`context manager` protocol, "
"which closes *thing* on leaving the :keyword:`with` statement. As such, :"
"func:`!closing` is most useful for third party types that don't support "
"context managers. This example is purely for illustration purposes, as :func:"
"`~urllib.request.urlopen` would normally be used in a context manager."
msgstr ""
"De flesta typer som hanterar resurser stöder :term:`context manager`-"
"protokollet, som stänger *ting* när det lämnar :keyword:`with`-satsen. Som "
"sådan är :func:`!closing` mest användbar för tredjepartstyper som inte "
"stöder kontexthanterare. Detta exempel är enbart för illustrationsändamål, "
"eftersom :func:`~urllib.request.urlopen` normalt skulle användas i en "
"kontexthanterare."

msgid ""
"Return an async context manager that calls the ``aclose()`` method of "
"*thing* upon completion of the block.  This is basically equivalent to::"
msgstr ""
"Returnerar en asynkron kontexthanterare som anropar ``aclose()``-metoden för "
"*ting* när blocket har slutförts.  Detta är i princip likvärdigt med::"

msgid ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def aclosing(thing):\n"
"    try:\n"
"        yield thing\n"
"    finally:\n"
"        await thing.aclose()"
msgstr ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontexthanterare\n"
"async def aclosing(sak):\n"
"    try:\n"
"        avkastning sak\n"
"    slutligen:\n"
"        await thing.aclose()"

msgid ""
"Significantly, ``aclosing()`` supports deterministic cleanup of async "
"generators when they happen to exit early by :keyword:`break` or an "
"exception.  For example::"
msgstr ""
"Det är viktigt att ``aclosing()`` stöder deterministisk rensning av async-"
"generatorer när de råkar avslutas tidigt genom :keyword:`break` eller ett "
"undantag.  Till exempel::"

msgid ""
"from contextlib import aclosing\n"
"\n"
"async with aclosing(my_generator()) as values:\n"
"    async for value in values:\n"
"        if value == 42:\n"
"            break"
msgstr ""
"from contextlib import aclosing\n"
"\n"
"async med aclosing(my_generator()) som värden:\n"
"    async för värde i värden:\n"
"        if värde == 42:\n"
"            break"

msgid ""
"This pattern ensures that the generator's async exit code is executed in the "
"same context as its iterations (so that exceptions and context variables "
"work as expected, and the exit code isn't run after the lifetime of some "
"task it depends on)."
msgstr ""
"Detta mönster säkerställer att generatorns asynkrona exitkod exekveras i "
"samma kontext som dess iterationer (så att undantag och kontextvariabler "
"fungerar som förväntat och exitkoden inte körs efter livstiden för någon "
"uppgift som den är beroende av)."

msgid ""
"Return a context manager that returns *enter_result* from ``__enter__``, but "
"otherwise does nothing. It is intended to be used as a stand-in for an "
"optional context manager, for example::"
msgstr ""
"Returnerar en kontexthanterare som returnerar *enter_result* från "
"``__enter__``, men som i övrigt inte gör någonting. Den är avsedd att "
"användas som en ersättare för en valfri kontexthanterare, till exempel::"

msgid ""
"def myfunction(arg, ignore_exceptions=False):\n"
"    if ignore_exceptions:\n"
"        # Use suppress to ignore all exceptions.\n"
"        cm = contextlib.suppress(Exception)\n"
"    else:\n"
"        # Do not ignore any exceptions, cm has no effect.\n"
"        cm = contextlib.nullcontext()\n"
"    with cm:\n"
"        # Do something"
msgstr ""
"def myfunction(arg, ignore_exceptions=False):\n"
"    if ignore_exceptions:\n"
"        # Använd suppress för att ignorera alla undantag.\n"
"        cm = contextlib.suppress(Undantag)\n"
"    else:\n"
"        # Ignorera inte några undantag, cm har ingen effekt.\n"
"        cm = contextlib.nullcontext()\n"
"    med cm:\n"
"        # Gör något"

msgid "An example using *enter_result*::"
msgstr "Ett exempel på användning av *enter_result*::"

msgid ""
"def process_file(file_or_path):\n"
"    if isinstance(file_or_path, str):\n"
"        # If string, open file\n"
"        cm = open(file_or_path)\n"
"    else:\n"
"        # Caller is responsible for closing file\n"
"        cm = nullcontext(file_or_path)\n"
"\n"
"    with cm as file:\n"
"        # Perform processing on the file"
msgstr ""
"def process_file(file_or_path):\n"
"    if isinstance(file_or_path, str):\n"
"        # If string, open file\n"
"        cm = open(file_or_path)\n"
"    else:\n"
"        # Caller is responsible for closing file\n"
"        cm = nullcontext(file_or_path)\n"
"\n"
"    with cm as file:\n"
"        # Perform processing on the file"

msgid ""
"It can also be used as a stand-in for :ref:`asynchronous context managers "
"<async-context-managers>`::"
msgstr ""
"Det kan också användas som en ersättare för :ref:``asynkrona "
"kontexthanterare <async-context-managers>`::"

msgid ""
"async def send_http(session=None):\n"
"    if not session:\n"
"        # If no http session, create it with aiohttp\n"
"        cm = aiohttp.ClientSession()\n"
"    else:\n"
"        # Caller is responsible for closing the session\n"
"        cm = nullcontext(session)\n"
"\n"
"    async with cm as session:\n"
"        # Send http requests with session"
msgstr ""
"async def send_http(session=None):\n"
"    if not session:\n"
"        # If no http session, create it with aiohttp\n"
"        cm = aiohttp.ClientSession()\n"
"    else:\n"
"        # Caller is responsible for closing the session\n"
"        cm = nullcontext(session)\n"
"\n"
"    async with cm as session:\n"
"        # Send http requests with session"

msgid ":term:`asynchronous context manager` support was added."
msgstr ":term:``asynkron kontexthanterare`` stöd har lagts till."

msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a :keyword:`!with` statement and then resumes "
"execution with the first statement following the end of the :keyword:`!with` "
"statement."
msgstr ""
"Returnerar en kontexthanterare som undertrycker något av de angivna "
"undantagen om de förekommer i en :keyword:`!with`-sats och sedan återupptar "
"exekveringen med den första satsen efter slutet av :keyword:`!with`-satsen."

msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to "
"do."
msgstr ""
"Som med alla andra mekanismer som helt undertrycker undantag, bör denna "
"kontexthanterare endast användas för att täcka mycket specifika fel där det "
"är känt att det är rätt att fortsätta att exekvera programmet i tysthet."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"from contextlib import suppress\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('somefile.tmp')\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('someotherfile.tmp')"
msgstr ""
"from contextlib import suppress\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('somefile.tmp')\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('someotherfile.tmp')"

msgid "This code is equivalent to::"
msgstr "Denna kod är likvärdig med::"

msgid ""
"try:\n"
"    os.remove('somefile.tmp')\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"try:\n"
"    os.remove('someotherfile.tmp')\n"
"except FileNotFoundError:\n"
"    pass"
msgstr ""
"try:\n"
"    os.remove('somefile.tmp')\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"try:\n"
"    os.remove('someotherfile.tmp')\n"
"except FileNotFoundError:\n"
"    pass"

msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr "Denna kontexthanterare är :ref:`reentrant <reentrant-cms>`."

msgid ""
"If the code within the :keyword:`!with` block raises a :exc:"
"`BaseExceptionGroup`, suppressed exceptions are removed from the group.  Any "
"exceptions of the group which are not suppressed are re-raised in a new "
"group which is created using the original group's :meth:`~BaseExceptionGroup."
"derive` method."
msgstr ""
"Om koden inom :keyword:`!with`-blocket ger upphov till en :exc:"
"`BaseExceptionGroup`, tas undertryckta undantag bort från gruppen.  Alla "
"undantag i gruppen som inte undertryckts tas upp igen i en ny grupp som "
"skapas med hjälp av den ursprungliga gruppens :meth:`~BaseExceptionGroup."
"derive`-metod."

msgid ""
"``suppress`` now supports suppressing exceptions raised as part of a :exc:"
"`BaseExceptionGroup`."
msgstr ""
"``suppress`` stöder nu undertryckande av undantag som tagits upp som en del "
"av en :exc:`BaseExceptionGroup`."

msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr ""
"Kontexthanterare för tillfällig omdirigering av :data:`sys.stdout` till en "
"annan fil eller ett annat filliknande objekt."

msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr ""
"Detta verktyg ger flexibilitet till befintliga funktioner eller klasser vars "
"utdata är kopplad till stdout."

msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an :"
"class:`io.StringIO` object. The replacement stream is returned from the "
"``__enter__`` method and so is available as the target of the :keyword:"
"`with` statement::"
msgstr ""
"Till exempel skickas utdata från :func:`help` normalt till *sys.stdout*. Du "
"kan fånga utdata i en sträng genom att omdirigera utdata till ett :class:`io."
"StringIO`-objekt. Ersättningsströmmen returneras från metoden ``__enter__`` "
"och är därför tillgänglig som mål för :keyword:`with`-satsen::"

msgid ""
"with redirect_stdout(io.StringIO()) as f:\n"
"    help(pow)\n"
"s = f.getvalue()"
msgstr ""
"with redirect_stdout(io.StringIO()) as f:\n"
"    help(pow)\n"
"s = f.getvalue()"

msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to "
"a regular file::"
msgstr ""
"För att skicka utdata från :func:`help` till en fil på disken, omdirigera "
"utdata till en vanlig fil::"

msgid ""
"with open('help.txt', 'w') as f:\n"
"    with redirect_stdout(f):\n"
"        help(pow)"
msgstr ""
"with open('help.txt', 'w') as f:\n"
"    with redirect_stdout(f):\n"
"        help(pow)"

msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr "För att skicka utdata från :func:`help` till *sys.stderr*::"

msgid ""
"with redirect_stdout(sys.stderr):\n"
"    help(pow)"
msgstr ""
"with redirect_stdout(sys.stderr):\n"
"    help(pow)"

msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""
"Observera att den globala bieffekten på :data:`sys.stdout` innebär att denna "
"kontexthanterare inte är lämplig att använda i bibliotekskod och de flesta "
"trådade applikationer. Den har inte heller någon effekt på utdata från "
"underprocesser. Det är dock fortfarande ett användbart tillvägagångssätt för "
"många verktygsskript."

msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting :data:`sys."
"stderr` to another file or file-like object."
msgstr ""
"Liknar :func:`~contextlib.redirect_stdout` men omdirigerar :data:`sys."
"stderr` till en annan fil eller ett annat filliknande objekt."

msgid ""
"Non parallel-safe context manager to change the current working directory. "
"As this changes a global state, the working directory, it is not suitable "
"for use in most threaded or async contexts. It is also not suitable for most "
"non-linear code execution, like generators, where the program execution is "
"temporarily relinquished -- unless explicitly desired, you should not yield "
"when this context manager is active."
msgstr ""
"Icke parallell-säker kontexthanterare för att ändra den aktuella "
"arbetskatalogen. Eftersom detta ändrar ett globalt tillstånd, "
"arbetskatalogen, är det inte lämpligt att använda i de flesta trådade eller "
"asynkrona sammanhang. Det är inte heller lämpligt för de flesta icke-linjära "
"kodkörningar, som generatorer, där programkörningen tillfälligt överlåts - "
"om det inte uttryckligen önskas bör du inte överlåta när denna "
"kontexthanterare är aktiv."

msgid ""
"This is a simple wrapper around :func:`~os.chdir`, it changes the current "
"working directory upon entering and restores the old one on exit."
msgstr ""
"Detta är ett enkelt omslag runt :func:`~os.chdir`, det ändrar den aktuella "
"arbetskatalogen vid inmatning och återställer den gamla vid utmatning."

msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr ""
"En basklass som gör att en kontexthanterare också kan användas som dekorator."

msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"Kontexthanterare som ärver från ``ContextDecorator`` måste implementera "
"``__enter__`` och ``__exit__`` som vanligt. ``__exit__`` behåller sin "
"valfria undantagshantering även när den används som en dekorator."

msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""
"``ContextDecorator`` används av :func:`contextmanager`, så du får denna "
"funktionalitet automatiskt."

msgid "Example of ``ContextDecorator``::"
msgstr "Exempel på ``ContextDecorator``::"

msgid ""
"from contextlib import ContextDecorator\n"
"\n"
"class mycontext(ContextDecorator):\n"
"    def __enter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"
msgstr ""
"from contextlib import ContextDecorator\n"
"\n"
"class mycontext(ContextDecorator):\n"
"    def __enter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"

msgid "The class can then be used like this::"
msgstr "Klassen kan sedan användas på följande sätt::"

msgid ""
">>> @mycontext()\n"
"... def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> function()\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> with mycontext():\n"
"...     print('The bit in the middle')\n"
"...\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"
msgstr ""
">>> @mycontext()\n"
"... def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> function()\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> with mycontext():\n"
"...     print('The bit in the middle')\n"
"...\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"

msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr ""
"Denna ändring är bara syntaktiskt socker för alla konstruktioner av följande "
"form::"

msgid ""
"def f():\n"
"    with cm():\n"
"        # Do stuff"
msgstr ""
"def f():\n"
"    with cm():\n"
"        # Gör saker"

msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` låter dig istället skriva::"

msgid ""
"@cm()\n"
"def f():\n"
"    # Do stuff"
msgstr ""
"@cm()\n"
"def f():\n"
"    # Gör saker"

msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr ""
"Det gör det tydligt att ``cm`` gäller hela funktionen, snarare än bara en "
"del av den (och att spara en indragningsnivå är också trevligt)."

msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""
"Befintliga kontexthanterare som redan har en basklass kan utökas genom att "
"använda ``ContextDecorator`` som en mixin-klass::"

msgid ""
"from contextlib import ContextDecorator\n"
"\n"
"class mycontext(ContextBaseClass, ContextDecorator):\n"
"    def __enter__(self):\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        return False"
msgstr ""
"från contextlib import ContextDecorator\n"
"\n"
"klass mycontext(ContextBaseClass, ContextDecorator):\n"
"    def __enter__(self):\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        return False"

msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`!with` statement inside the function should be used."
msgstr ""
"Eftersom den dekorerade funktionen måste kunna anropas flera gånger måste "
"den underliggande kontexthanteraren stödja användning i flera :keyword:"
"`with`-satser. Om så inte är fallet ska den ursprungliga konstruktionen med "
"den explicita :keyword:`!with`-satsen inuti funktionen användas."

msgid ""
"Similar to :class:`ContextDecorator` but only for asynchronous functions."
msgstr "Liknar :class:`ContextDecorator` men endast för asynkrona funktioner."

msgid "Example of ``AsyncContextDecorator``::"
msgstr "Exempel på ``AsyncContextDecorator``::"

msgid ""
"from asyncio import run\n"
"from contextlib import AsyncContextDecorator\n"
"\n"
"class mycontext(AsyncContextDecorator):\n"
"    async def __aenter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    async def __aexit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"
msgstr ""
"from asyncio import run\n"
"from contextlib import AsyncContextDecorator\n"
"\n"
"class mycontext(AsyncContextDecorator):\n"
"    async def __aenter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    async def __aexit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"

msgid ""
">>> @mycontext()\n"
"... async def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> async def function():\n"
"...    async with mycontext():\n"
"...         print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"
msgstr ""
">>> @mycontext()\n"
"... async def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> async def function():\n"
"...    async with mycontext():\n"
"...         print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"

msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""
"En kontexthanterare som är utformad för att göra det enkelt att "
"programmatiskt kombinera andra kontexthanterare och rensningsfunktioner, "
"särskilt sådana som är valfria eller på annat sätt styrs av indata."

msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr ""
"En uppsättning filer kan t.ex. enkelt hanteras i en enda with-sats enligt "
"följande::"

msgid ""
"with ExitStack() as stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filenames]\n"
"    # All opened files will automatically be closed at the end of\n"
"    # the with statement, even if attempts to open files later\n"
"    # in the list raise an exception"
msgstr ""
"med ExitStack() som stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filnamn]\n"
"    # Alla öppnade filer kommer automatiskt att stängas i slutet av\n"
"    # with-satsen, även om försök att öppna filer senare i listan\n"
"    # i listan ger upphov till ett undantag"

msgid ""
"The :meth:`~object.__enter__` method returns the :class:`ExitStack` "
"instance, and performs no additional operations."
msgstr ""
"Metoden :meth:`~object.__enter__` returnerar :class:`ExitStack`-instansen "
"och utför inga ytterligare åtgärder."

msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"Varje instans upprätthåller en stack med registrerade callbacks som anropas "
"i omvänd ordning när instansen stängs (antingen explicit eller implicit i "
"slutet av en :keyword:`with`-sats). Observera att återanrop *inte* anropas "
"implicit när context stack-instansen garbage collected."

msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr ""
"Denna stackmodell används för att kontexthanterare som förvärvar sina "
"resurser i metoden ``__init__`` (t.ex. filobjekt) ska kunna hanteras korrekt."

msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"Eftersom registrerade återuppringningar anropas i omvänd ordning efter "
"registreringen, fungerar det som om flera nästlade :keyword:`with`-satser "
"hade använts med den registrerade uppsättningen återuppringningar. Detta "
"gäller även undantagshantering - om en inre anropssignal undertrycker eller "
"ersätter ett undantag, kommer yttre anropssignaler att få argument baserade "
"på det uppdaterade tillståndet."

msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"Detta är ett API på relativt låg nivå som tar hand om detaljerna kring "
"korrekt avrullning av stacken med exit callbacks. Det utgör en lämplig grund "
"för kontexthanterare på högre nivå som manipulerar exitstacken på "
"applikationsspecifika sätt."

msgid ""
"Enters a new context manager and adds its :meth:`~object.__exit__` method to "
"the callback stack. The return value is the result of the context manager's "
"own :meth:`~object.__enter__` method."
msgstr ""
"Ansluter en ny kontexthanterare och lägger till dess :meth:`~object."
"__exit__`-metod i callback-stacken. Returvärdet är resultatet av "
"kontexthanterarens egen metod :meth:`~object.__enter__`."

msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr ""
"Dessa kontexthanterare kan undertrycka undantag precis som de normalt skulle "
"göra om de användes direkt som en del av en :keyword:`with`-sats."

msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not a "
"context manager."
msgstr ""
"Utlöser :exc:`TypeError` istället för :exc:`AttributeError` om *cm* inte är "
"en kontexthanterare."

msgid ""
"Adds a context manager's :meth:`~object.__exit__` method to the callback "
"stack."
msgstr ""
"Lägger till en kontexthanterares :meth:`~object.__exit__`-metod till "
"återkallelsestacken."

msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`~object.__enter__` implementation with a context manager's own :"
"meth:`~object.__exit__` method."
msgstr ""
"Eftersom ``__enter__`` *inte* åberopas kan denna metod användas för att "
"täcka en del av en :meth:`~object.__enter__`-implementering med en "
"kontexthanterares egen :meth:`~object.__exit__`-metod."

msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`~object."
"__exit__` method and adds it directly to the callback stack."
msgstr ""
"Om ett objekt som inte är en kontexthanterare skickas, antar metoden att det "
"är en återuppringning med samma signatur som en kontexthanterares :meth:"
"`~object.__exit__`-metod och lägger till den direkt i "
"återuppringningsstacken."

msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`~object.__exit__` methods can."
msgstr ""
"Genom att returnera sanna värden kan dessa callbacks undertrycka undantag på "
"samma sätt som context manager :meth:`~object.__exit__`-metoder kan."

msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr ""
"Det objekt som skickas in returneras från funktionen, vilket gör att denna "
"metod kan användas som en funktionsdekorator."

msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr ""
"Accepterar en godtycklig återuppringningsfunktion och argument och lägger "
"till den i återuppringningsstacken."

msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr ""
"Till skillnad från de andra metoderna kan callbacks som läggs till på det "
"här sättet inte undertrycka undantag (eftersom de aldrig får information om "
"undantaget)."

msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr ""
"Den överlämnade återkallelsen returneras från funktionen, vilket gör att den "
"här metoden kan användas som en funktionsdekorator."

msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""
"Överför återkallelsestacken till en ny :class:`ExitStack`-instans och "
"returnerar den. Inga återuppringningar anropas av denna operation - istället "
"kommer de nu att anropas när den nya stacken stängs (antingen explicit eller "
"implicit i slutet av en :keyword:`with`-sats)."

msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr ""
"En grupp filer kan t.ex. öppnas som en \"allt eller inget\"-operation på "
"följande sätt::"

msgid ""
"with ExitStack() as stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filenames]\n"
"    # Hold onto the close method, but don't call it yet.\n"
"    close_files = stack.pop_all().close\n"
"    # If opening any file fails, all previously opened files will be\n"
"    # closed automatically. If all files are opened successfully,\n"
"    # they will remain open even after the with statement ends.\n"
"    # close_files() can then be invoked explicitly to close them all."
msgstr ""
"med ExitStack() som stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filnamn]\n"
"    # Håll fast vid close-metoden, men anropa den inte än.\n"
"    close_files = stack.pop_all().close\n"
"    # Om det inte går att öppna någon fil kommer alla tidigare öppnade filer "
"att\n"
"    # stängas automatiskt. Om alla filer öppnas framgångsrikt,\n"
"    # kommer de att förbli öppna även efter att with-satsen har avslutats.\n"
"    # close_files() kan då åberopas explicit för att stänga dem alla."

msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr ""
"Avvecklar omedelbart återkallelsestacken och anropar återkallelser i omvänd "
"registreringsordning. För alla kontexthanterare och exit callbacks som "
"registrerats, kommer de argument som skickas in att ange att inget undantag "
"inträffade."

msgid ""
"An :ref:`asynchronous context manager <async-context-managers>`, similar to :"
"class:`ExitStack`, that supports combining both synchronous and asynchronous "
"context managers, as well as having coroutines for cleanup logic."
msgstr ""
"En :ref:`asynkron kontexthanterare <async-context-managers>`, liknande :"
"class:`ExitStack`, som stöder kombination av både synkrona och asynkrona "
"kontexthanterare, samt har coroutines för rensningslogik."

msgid ""
"The :meth:`~ExitStack.close` method is not implemented; :meth:`aclose` must "
"be used instead."
msgstr ""
"Metoden :meth:`~ExitStack.close` är inte implementerad; :meth:`aclose` måste "
"användas istället."

msgid ""
"Similar to :meth:`ExitStack.enter_context` but expects an asynchronous "
"context manager."
msgstr ""
"Liknar :meth:`ExitStack.enter_context` men förväntar sig en asynkron "
"kontexthanterare."

msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not an "
"asynchronous context manager."
msgstr ""
"Utlöser :exc:`TypeError` istället för :exc:`AttributeError` om *cm* inte är "
"en asynkron kontexthanterare."

msgid ""
"Similar to :meth:`ExitStack.push` but expects either an asynchronous context "
"manager or a coroutine function."
msgstr ""
"Liknar :meth:`ExitStack.push` men förväntar sig antingen en asynkron "
"kontexthanterare eller en coroutine-funktion."

msgid "Similar to :meth:`ExitStack.callback` but expects a coroutine function."
msgstr ""
"Liknar :meth:`ExitStack.callback` men förväntar sig en coroutine-funktion."

msgid "Similar to :meth:`ExitStack.close` but properly handles awaitables."
msgstr "Liknar :meth:`ExitStack.close` men hanterar awaitables korrekt."

msgid "Continuing the example for :func:`asynccontextmanager`::"
msgstr "Fortsätter exemplet för :func:`asynccontextmanager`::"

msgid ""
"async with AsyncExitStack() as stack:\n"
"    connections = [await stack.enter_async_context(get_connection())\n"
"        for i in range(5)]\n"
"    # All opened connections will automatically be released at the end of\n"
"    # the async with statement, even if attempts to open a connection\n"
"    # later in the list raise an exception."
msgstr ""
"async med AsyncExitStack() som stack:\n"
"    anslutningar = [await stack.enter_async_context(get_connection())\n"
"        för i i intervall(5)]\n"
"    # Alla öppnade anslutningar kommer automatiskt att släppas i slutet av\n"
"    # async with-satsen, även om försök att öppna en anslutning senare i "
"listan\n"
"    # senare i listan ger upphov till ett undantag."

msgid "Examples and Recipes"
msgstr "Exempel och recept"

msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr ""
"I det här avsnittet beskrivs några exempel och recept på hur du effektivt "
"kan använda de verktyg som tillhandahålls av :mod:`contextlib`."

msgid "Supporting a variable number of context managers"
msgstr "Stöd för ett varierande antal kontextansvariga"

msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
"Det primära användningsområdet för :class:`ExitStack` är det som anges i "
"klassdokumentationen: att stödja ett varierande antal kontexthanterare och "
"andra rensningsoperationer i en enda :keyword:`with`-sats. Variationen kan "
"bero på att antalet kontexthanterare som behövs styrs av användarens indata "
"(t.ex. att öppna en användardefinierad samling filer) eller att vissa av "
"kontexthanterarna är valfria:"

msgid ""
"with ExitStack() as stack:\n"
"    for resource in resources:\n"
"        stack.enter_context(resource)\n"
"    if need_special_resource():\n"
"        special = acquire_special_resource()\n"
"        stack.callback(release_special_resource, special)\n"
"    # Perform operations that use the acquired resources"
msgstr ""
"med ExitStack() som stack:\n"
"    för resurs i resurser:\n"
"        stack.enter_context(resurs)\n"
"    if need_special_resource():\n"
"        special = förvärva_special_resurs()\n"
"        stack.callback(release_special_resource, special)\n"
"    # Utför operationer som använder de förvärvade resurserna"

msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"Som framgår gör :class:`ExitStack` det också ganska enkelt att använda :"
"keyword:`with`-satser för att hantera godtyckliga resurser som inte har "
"inbyggt stöd för kontexthanteringsprotokollet."

msgid "Catching exceptions from ``__enter__`` methods"
msgstr "Fånga upp undantag från ``__enter__``-metoder"

msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""
"Det är ibland önskvärt att fånga upp undantag från en metodimplementation av "
"``__enter__``, *utan* att oavsiktligt fånga upp undantag från :keyword:"
"`with`-satsens kropp eller kontexthanterarens ``__exit__``-metod. Genom att "
"använda :class:`ExitStack` kan stegen i protokollet för kontexthantering "
"separeras något för att möjliggöra detta::"

msgid ""
"stack = ExitStack()\n"
"try:\n"
"    x = stack.enter_context(cm)\n"
"except Exception:\n"
"    # handle __enter__ exception\n"
"else:\n"
"    with stack:\n"
"        # Handle normal case"
msgstr ""
"stack = ExitStack()\n"
"försök:\n"
"    x = stack.enter_context(cm)\n"
"except Exception:\n"
"    # hantera __enter__ undantag\n"
"else:\n"
"    med stack:\n"
"        # Hantera normalfallet"

msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""
"Att faktiskt behöva göra det här tyder sannolikt på att det underliggande "
"API:et borde tillhandahålla ett direkt resurshanteringsgränssnitt för "
"användning med :keyword:`try`/:keyword:`except`/:keyword:`finally`-satser, "
"men inte alla API:er är väl utformade i det avseendet. När en "
"kontexthanterare är det enda API för resurshantering som tillhandahålls kan :"
"class:`ExitStack` göra det lättare att hantera olika situationer som inte "
"kan hanteras direkt i en :keyword:`with`-sats."

msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "Städa upp i en ``__enter__``-implementering"

msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`~object.__enter__` implementation fail."
msgstr ""
"Som framgår av dokumentationen av :meth:`ExitStack.push` kan den här metoden "
"vara användbar för att rensa upp en redan tilldelad resurs om senare steg i :"
"meth:`~object.__enter__`-implementeringen misslyckas."

msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""
"Här är ett exempel på hur man gör detta för en kontexthanterare som "
"accepterar funktioner för resursförvärv och frigöring, tillsammans med en "
"valfri valideringsfunktion, och mappar dem till "
"kontexthanteringsprotokollet::"

msgid ""
"from contextlib import contextmanager, AbstractContextManager, ExitStack\n"
"\n"
"class ResourceManager(AbstractContextManager):\n"
"\n"
"    def __init__(self, acquire_resource, release_resource, "
"check_resource_ok=None):\n"
"        self.acquire_resource = acquire_resource\n"
"        self.release_resource = release_resource\n"
"        if check_resource_ok is None:\n"
"            def check_resource_ok(resource):\n"
"                return True\n"
"        self.check_resource_ok = check_resource_ok\n"
"\n"
"    @contextmanager\n"
"    def _cleanup_on_error(self):\n"
"        with ExitStack() as stack:\n"
"            stack.push(self)\n"
"            yield\n"
"            # The validation check passed and didn't raise an exception\n"
"            # Accordingly, we want to keep the resource, and pass it\n"
"            # back to our caller\n"
"            stack.pop_all()\n"
"\n"
"    def __enter__(self):\n"
"        resource = self.acquire_resource()\n"
"        with self._cleanup_on_error():\n"
"            if not self.check_resource_ok(resource):\n"
"                msg = \"Failed validation for {!r}\"\n"
"                raise RuntimeError(msg.format(resource))\n"
"        return resource\n"
"\n"
"    def __exit__(self, *exc_details):\n"
"        # We don't need to duplicate any of our resource release logic\n"
"        self.release_resource()"
msgstr ""
"from contextlib import contextmanager, AbstractContextManager, ExitStack\n"
"\n"
"klass ResourceManager(AbstractContextManager):\n"
"\n"
"    def __init__(self, acquire_resource, release_resource, "
"check_resource_ok=None):\n"
"        self.acquire_resource = förvärva_resurs\n"
"        self.release_resource = release_resource\n"
"        om check_resource_ok är None:\n"
"            def check_resource_ok(resurs):\n"
"                return True\n"
"        self.check_resource_ok = check_resource_ok\n"
"\n"
"    @kontexthanterare\n"
"    def _cleanup_on_error(self):\n"
"        med ExitStack() som stack:\n"
"            stack.push(self)\n"
"            avkastning\n"
"            # Valideringskontrollen godkändes och ledde inte till något "
"undantag\n"
"            # Följaktligen vill vi behålla resursen och skicka den\n"
"            # tillbaka till vår anropare\n"
"            stack.pop_all()\n"
"\n"
"    def __enter__(self):\n"
"        resurs = self.acquire_resource()\n"
"        med self._cleanup_on_error():\n"
"            if not self.check_resource_ok(resource):\n"
"                msg = \"Misslyckades med validering för {!r}\"\n"
"                raise RuntimeError(msg.format(resurs))\n"
"        returnera resurs\n"
"\n"
"    def __exit__(self, *exc_details):\n"
"        # Vi behöver inte duplicera någon av våra logiker för "
"resursfrisättning\n"
"        self.release_resource()"

msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "Ersätter all användning av ``try-finally`` och flaggvariabler"

msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"Ett mönster som du ibland kommer att se är en ``try-finally``-sats med en "
"flaggvariabel för att ange om kroppen i ``finally``-satsen ska utföras eller "
"inte. I sin enklaste form (som inte redan kan hanteras bara genom att "
"använda en ``except``-sats istället) ser det ut ungefär så här::"

msgid ""
"cleanup_needed = True\n"
"try:\n"
"    result = perform_operation()\n"
"    if result:\n"
"        cleanup_needed = False\n"
"finally:\n"
"    if cleanup_needed:\n"
"        cleanup_resources()"
msgstr ""
"cleanup_needed = True\n"
"försök:\n"
"    resultat = utföra_operation()\n"
"    om resultat:\n"
"        cleanup_needed = False\n"
"slutligen\n"
"    if cleanup_need:\n"
"        cleanup_resources()"

msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""
"Som med all kod som bygger på ``försök``-satser kan detta orsaka problem vid "
"utveckling och granskning, eftersom installationskoden och upprensningskoden "
"kan komma att separeras av godtyckligt långa kodavsnitt."

msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""
":class:`ExitStack` gör det möjligt att istället registrera en callback för "
"exekvering i slutet av en ``with``-sats, och sedan senare bestämma sig för "
"att hoppa över att exekvera den callbacken::"

msgid ""
"from contextlib import ExitStack\n"
"\n"
"with ExitStack() as stack:\n"
"    stack.callback(cleanup_resources)\n"
"    result = perform_operation()\n"
"    if result:\n"
"        stack.pop_all()"
msgstr ""
"from contextlib import ExitStack\n"
"\n"
"med ExitStack() som stack:\n"
"    stack.callback(cleanup_resources)\n"
"    resultat = utföra_operation()\n"
"    om resultat:\n"
"        stack.pop_all()"

msgid ""
"This allows the intended cleanup behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr ""
"Detta gör att det avsedda uppstädningsbeteendet kan göras tydligt redan från "
"början, i stället för att kräva en separat flaggvariabel."

msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr ""
"Om en viss applikation använder detta mönster ofta kan det förenklas "
"ytterligare med hjälp av en liten hjälpklass::"

msgid ""
"from contextlib import ExitStack\n"
"\n"
"class Callback(ExitStack):\n"
"    def __init__(self, callback, /, *args, **kwds):\n"
"        super().__init__()\n"
"        self.callback(callback, *args, **kwds)\n"
"\n"
"    def cancel(self):\n"
"        self.pop_all()\n"
"\n"
"with Callback(cleanup_resources) as cb:\n"
"    result = perform_operation()\n"
"    if result:\n"
"        cb.cancel()"
msgstr ""
"from contextlib import ExitStack\n"
"\n"
"klass Återkallelse(ExitStack):\n"
"    def __init__(self, callback, /, *args, **kwds):\n"
"        super().__init__()\n"
"        self.callback(återuppringning, *args, **kwds)\n"
"\n"
"    def cancel(self):\n"
"        self.pop_all()\n"
"\n"
"med Callback(cleanup_resources) som cb:\n"
"    resultat = utföra_operation()\n"
"    om resultat:\n"
"        cb.cancel()"

msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""
"Om resursrensningen inte redan har paketerats i en fristående funktion är "
"det fortfarande möjligt att använda dekoratorformen av :meth:`ExitStack."
"callback` för att deklarera resursrensningen i förväg::"

msgid ""
"from contextlib import ExitStack\n"
"\n"
"with ExitStack() as stack:\n"
"    @stack.callback\n"
"    def cleanup_resources():\n"
"        ...\n"
"    result = perform_operation()\n"
"    if result:\n"
"        stack.pop_all()"
msgstr ""
"from contextlib import ExitStack\n"
"\n"
"med ExitStack() som stack:\n"
"    @stack.återuppringning\n"
"    def cleanup_resources():\n"
"        ...\n"
"    resultat = utföra_operation()\n"
"    om resultat:\n"
"        stack.pop_all()"

msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr ""
"På grund av hur dekoratorprotokollet fungerar kan en callback-funktion som "
"deklareras på detta sätt inte ta emot några parametrar. Istället måste alla "
"resurser som ska frigöras nås som stängningsvariabler."

msgid "Using a context manager as a function decorator"
msgstr "Använda en kontexthanterare som funktionsdekorator"

msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ""
":class:`ContextDecorator` gör det möjligt att använda en kontexthanterare "
"både i en vanlig ``with``-sats och som en funktionsdekorator."

msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""
"Till exempel är det ibland användbart att paketera funktioner eller grupper "
"av satser med en logger som kan spåra tidpunkten för inmatning och "
"tidpunkten för avslutning.  I stället för att skriva både en "
"funktionsdekorator och en kontexthanterare för uppgiften, ger ett arv från :"
"class:`ContextDecorator` båda funktionerna i en enda definition::"

msgid ""
"from contextlib import ContextDecorator\n"
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class track_entry_and_exit(ContextDecorator):\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def __enter__(self):\n"
"        logging.info('Entering: %s', self.name)\n"
"\n"
"    def __exit__(self, exc_type, exc, exc_tb):\n"
"        logging.info('Exiting: %s', self.name)"
msgstr ""
"from contextlib import ContextDecorator\n"
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class track_entry_and_exit(ContextDecorator):\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def __enter__(self):\n"
"        logging.info('Entering: %s', self.name)\n"
"\n"
"    def __exit__(self, exc_type, exc, exc_tb):\n"
"        logging.info('Exiting: %s', self.name)"

msgid "Instances of this class can be used as both a context manager::"
msgstr "Instanser av denna klass kan användas som både en kontexthanterare::"

msgid ""
"with track_entry_and_exit('widget loader'):\n"
"    print('Some time consuming activity goes here')\n"
"    load_widget()"
msgstr ""
"med track_entry_and_exit('widget loader'):\n"
"    print('En tidskrävande aktivitet sker här')\n"
"    ladda_widget()"

msgid "And also as a function decorator::"
msgstr "Och även som funktionsinredare::"

msgid ""
"@track_entry_and_exit('widget loader')\n"
"def activity():\n"
"    print('Some time consuming activity goes here')\n"
"    load_widget()"
msgstr ""
"@track_entry_and_exit('widgetladdare')\n"
"def aktivitet():\n"
"    print('Någon tidskrävande aktivitet sker här')\n"
"    ladda_widget()"

msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`~object.__enter__`. If that value is needed, then it is still necessary to "
"use an explicit ``with`` statement."
msgstr ""
"Observera att det finns ytterligare en begränsning när man använder "
"kontexthanterare som funktionsdekoratorer: det finns inget sätt att komma åt "
"returvärdet för :meth:`~object.__enter__`. Om det värdet behövs är det "
"fortfarande nödvändigt att använda en explicit ``with``-sats."

msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Statement “with”"

msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Specifikation, bakgrund och exempel för Pythons :keyword:`with`-sats."

msgid "Single use, reusable and reentrant context managers"
msgstr "Kontexthanterare för engångsbruk, återanvändbara och återcentrerade"

msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work correctly."
msgstr ""
"De flesta kontexthanterare är skrivna på ett sätt som innebär att de bara "
"kan användas effektivt i en :keyword:`with`-sats en gång. Dessa "
"kontexthanterare för engångsbruk måste skapas på nytt varje gång de används "
"- om du försöker använda dem en andra gång kommer de att utlösa ett undantag "
"eller på annat sätt inte fungera korrekt."

msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr ""
"Denna vanliga begränsning innebär att det i allmänhet är tillrådligt att "
"skapa kontexthanterare direkt i rubriken till :keyword:`with`-satsen där de "
"används (som visas i alla användningsexempel ovan)."

msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""
"Filer är ett exempel på kontexthanterare med effektiv engångsanvändning, "
"eftersom den första :keyword:`with`-satsen stänger filen och förhindrar "
"ytterligare IO-operationer med det filobjektet."

msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""
"Kontexthanterare som skapas med :func:`contextmanager` är också "
"kontexthanterare för engångsbruk och kommer att klaga på att den "
"underliggande generatorn inte ger något om man försöker använda dem en andra "
"gång::"

msgid ""
">>> from contextlib import contextmanager\n"
">>> @contextmanager\n"
"... def singleuse():\n"
"...     print(\"Before\")\n"
"...     yield\n"
"...     print(\"After\")\n"
"...\n"
">>> cm = singleuse()\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Before\n"
"After\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Traceback (most recent call last):\n"
"    ...\n"
"RuntimeError: generator didn't yield"
msgstr ""
">>> from contextlib import contextmanager\n"
">>> @contextmanager\n"
"... def singleuse():\n"
"...     print(\"Before\")\n"
"...     yield\n"
"...     print(\"After\")\n"
"...\n"
">>> cm = singleuse()\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Before\n"
"After\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Traceback (most recent call last):\n"
"    ...\n"
"RuntimeError: generator didn't yield"

msgid "Reentrant context managers"
msgstr "Reentranta kontexthanterare"

msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`!with` statement that is already using "
"the same context manager."
msgstr ""
"Mer sofistikerade kontexthanterare kan vara \"reentranta\". Dessa "
"kontexthanterare kan inte bara användas i flera :keyword:`with`-satser, utan "
"kan också användas *inom* en :keyword:`!with`-sats som redan använder samma "
"kontexthanterare."

msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress`, :func:`redirect_stdout`, and :func:`chdir`. Here's a "
"very simple example of reentrant use::"
msgstr ""
":class:`threading.RLock` är ett exempel på en reentrant kontexthanterare, "
"liksom :func:`suppress`, :func:`redirect_stdout` och :func:`chdir`. Här är "
"ett mycket enkelt exempel på reentrant användning::"

msgid ""
">>> from contextlib import redirect_stdout\n"
">>> from io import StringIO\n"
">>> stream = StringIO()\n"
">>> write_to_stream = redirect_stdout(stream)\n"
">>> with write_to_stream:\n"
"...     print(\"This is written to the stream rather than stdout\")\n"
"...     with write_to_stream:\n"
"...         print(\"This is also written to the stream\")\n"
"...\n"
">>> print(\"This is written directly to stdout\")\n"
"This is written directly to stdout\n"
">>> print(stream.getvalue())\n"
"This is written to the stream rather than stdout\n"
"This is also written to the stream"
msgstr ""
">>> from contextlib import redirect_stdout\n"
">>> from io import StringIO\n"
">>> stream = StringIO()\n"
">>> write_to_stream = redirect_stdout(stream)\n"
">>> with write_to_stream:\n"
"...     print(\"This is written to the stream rather than stdout\")\n"
"...     with write_to_stream:\n"
"...         print(\"This is also written to the stream\")\n"
"...\n"
">>> print(\"This is written directly to stdout\")\n"
"This is written directly to stdout\n"
">>> print(stream.getvalue())\n"
"This is written to the stream rather than stdout\n"
"This is also written to the stream"

msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr ""
"Verkliga exempel på reentrancy är mer benägna att involvera flera funktioner "
"som anropar varandra och är därför mycket mer komplicerade än det här "
"exemplet."

msgid ""
"Note also that being reentrant is *not* the same thing as being thread "
"safe. :func:`redirect_stdout`, for example, is definitely not thread safe, "
"as it makes a global modification to the system state by binding :data:`sys."
"stdout` to a different stream."
msgstr ""
"Observera också att reentrant *inte* är samma sak som trådsäkert. :func:"
"`redirect_stdout` är till exempel definitivt inte trådsäkert, eftersom det "
"gör en global ändring av systemtillståndet genom att binda :data:`sys."
"stdout` till en annan ström."

msgid "Reusable context managers"
msgstr "Återanvändbara kontexthanterare"

msgid ""
"Distinct from both single use and reentrant context managers are "
"\"reusable\" context managers (or, to be completely explicit, \"reusable, "
"but not reentrant\" context managers, since reentrant context managers are "
"also reusable). These context managers support being used multiple times, "
"but will fail (or otherwise not work correctly) if the specific context "
"manager instance has already been used in a containing with statement."
msgstr ""
"Till skillnad från både engångs- och återcentrerande kontexthanterare finns "
"det \"återanvändbara\" kontexthanterare (eller, för att vara helt tydlig, "
"\"återanvändbara, men inte återcentrerande\" kontexthanterare, eftersom "
"återcentrerande kontexthanterare också är återanvändbara). Dessa "
"kontexthanterare kan användas flera gånger, men kommer att misslyckas (eller "
"på annat sätt inte fungera korrekt) om den specifika kontexthanteraren redan "
"har använts i en containing with-sats."

msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use :class:"
"`threading.RLock` instead)."
msgstr ""
":class:`threading.Lock` är ett exempel på en återanvändbar, men inte "
"reentrant, kontexthanterare (för ett reentrant lås är det nödvändigt att "
"använda :class:`threading.RLock` istället)."

msgid ""
"Another example of a reusable, but not reentrant, context manager is :class:"
"`ExitStack`, as it invokes *all* currently registered callbacks when leaving "
"any with statement, regardless of where those callbacks were added::"
msgstr ""
"Ett annat exempel på en återanvändbar, men inte reentrant, kontexthanterare "
"är :class:`ExitStack`, eftersom den anropar *alla* för närvarande "
"registrerade anrop när man lämnar en with-sats, oavsett var dessa anrop "
"lades till::"

msgid ""
">>> from contextlib import ExitStack\n"
">>> stack = ExitStack()\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from first context\")\n"
"...     print(\"Leaving first context\")\n"
"...\n"
"Leaving first context\n"
"Callback: from first context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from second context\")\n"
"...     print(\"Leaving second context\")\n"
"...\n"
"Leaving second context\n"
"Callback: from second context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from outer context\")\n"
"...     with stack:\n"
"...         stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Callback: from outer context\n"
"Leaving outer context"
msgstr ""
">>> from contextlib import ExitStack\n"
">>> stack = ExitStack()\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from first context\")\n"
"...     print(\"Leaving first context\")\n"
"...\n"
"Leaving first context\n"
"Callback: from first context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from second context\")\n"
"...     print(\"Leaving second context\")\n"
"...\n"
"Leaving second context\n"
"Callback: from second context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from outer context\")\n"
"...     with stack:\n"
"...         stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Callback: from outer context\n"
"Leaving outer context"

msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""
"Som framgår av exemplet fungerar det korrekt att återanvända ett enda "
"stackobjekt i flera with-satser, men om man försöker nesta dem kommer "
"stacken att rensas i slutet av den innersta with-satsen, vilket sannolikt "
"inte är ett önskvärt beteende."

msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr ""
"Genom att använda separata :class:`ExitStack`-instanser istället för att "
"återanvända en enda instans undviker man det problemet::"

msgid ""
">>> from contextlib import ExitStack\n"
">>> with ExitStack() as outer_stack:\n"
"...     outer_stack.callback(print, \"Callback: from outer context\")\n"
"...     with ExitStack() as inner_stack:\n"
"...         inner_stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Leaving outer context\n"
"Callback: from outer context"
msgstr ""
">>> from contextlib import ExitStack\n"
">>> with ExitStack() as outer_stack:\n"
"...     outer_stack.callback(print, \"Callback: from outer context\")\n"
"...     with ExitStack() as inner_stack:\n"
"...         inner_stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Leaving outer context\n"
"Callback: from outer context"
