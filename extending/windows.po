# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Building C and C++ Extensions on Windows"
msgstr "Bygga C- och C++-tillägg i Windows"

msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background "
"information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"Detta kapitel förklarar kortfattat hur man skapar en Windows-tilläggsmodul "
"för Python med hjälp av Microsoft Visual C++ och följer sedan upp med mer "
"detaljerad bakgrundsinformation om hur det fungerar.  Förklaringsmaterialet "
"är användbart för både Windows-programmerare som lär sig att bygga Python-"
"tillägg och Unix-programmerare som är intresserade av att producera "
"programvara som kan byggas på både Unix och Windows."

msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft "
"Visual C++."
msgstr ""
"Modulförfattare uppmuntras att använda distutils metod för att bygga "
"tilläggsmoduler, istället för den som beskrivs i detta avsnitt. Du kommer "
"fortfarande att behöva den C-kompilator som användes för att bygga Python, "
"vanligtvis Microsoft Visual C++."

msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"I det här kapitlet nämns ett antal filnamn som innehåller ett kodat Python-"
"versionsnummer.  Dessa filnamn representeras med versionsnumret som visas "
"som ``XY``; i praktiken kommer ``'X`` att vara huvudversionsnumret och "
"``'Y`` kommer att vara det mindre versionsnumret för den Python-version du "
"arbetar med.  Om du till exempel använder Python 2.2.1 kommer ``XY`` "
"faktiskt att vara ``22``."

msgid "A Cookbook Approach"
msgstr "Ett tillvägagångssätt med kokbok"

msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the ``setuptools`` package to control the build "
"process, or do things manually.  The setuptools approach works well for most "
"extensions; documentation on using ``setuptools`` to build and package "
"extension modules is available in :ref:`setuptools-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"Det finns två sätt att bygga tilläggsmoduler på Windows, precis som på Unix: "
"använd paketet ``setuptools`` för att styra byggprocessen, eller gör saker "
"manuellt.  Setuptools-metoden fungerar bra för de flesta tillägg; "
"dokumentation om hur du använder ``setuptools`` för att bygga och paketera "
"tilläggsmoduler finns i :ref:`setuptools-index`.  Om du verkligen behöver "
"göra saker manuellt kan det vara lärorikt att studera projektfilen för "
"standardbiblioteksmodulen :source:`winsound <PCbuild/winsound.vcxproj>`."

msgid "Differences Between Unix and Windows"
msgstr "Skillnader mellan Unix och Windows"

msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"Unix och Windows använder helt olika paradigm för laddning av kod i körtid.  "
"Innan du försöker bygga en modul som kan laddas dynamiskt bör du vara "
"medveten om hur ditt system fungerar."

msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in "
"the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"I Unix innehåller en shared object (:file:`.so`)-fil kod som ska användas av "
"programmet, och även namnen på funktioner och data som den förväntar sig att "
"hitta i programmet.  När filen länkas till programmet ändras alla referenser "
"till dessa funktioner och data i filens kod så att de pekar på de faktiska "
"platserna i programmet där funktionerna och datan placeras i minnet. Detta "
"är i princip en länkoperation."

msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table, "
"and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"I Windows har en fil från ett dynamiskt länkbibliotek (:file:`.dll`) inga "
"hängande referenser.  Istället går en åtkomst till funktioner eller data via "
"en uppslagstabell.  DLL-koden behöver alltså inte fixas till vid körning för "
"att referera till programmets minne, utan koden använder redan DLL:ns "
"uppslagstabell och uppslagstabellen modifieras vid körning för att peka på "
"funktioner och data."

msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create "
"a shared object file (:file:`.so`), the linker may find that it doesn't know "
"where an identifier is defined.  The linker will look for it in the object "
"files in the libraries; if it finds it, it will include all the code from "
"that object file."
msgstr ""
"I Unix finns det bara en typ av biblioteksfil (:file:`.a`) som innehåller "
"kod från flera objektfiler (:file:`.o`).  Under länkningssteget för att "
"skapa en delad objektfil (:file:`.so`) kan det hända att länkaren inte vet "
"var en identifierare är definierad.  Länkaren letar efter den i "
"objektfilerna i biblioteken och om den hittar den inkluderas all kod från "
"den objektfilen."

msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix :file:`."
"a` file; it contains code to be included as necessary. An import library is "
"basically used only to reassure the linker that a certain identifier is "
"legal, and will be present in the program when the DLL is loaded.  So the "
"linker uses the information from the import library to build the lookup "
"table for using identifiers that are not included in the DLL.  When an "
"application or a DLL is linked, an import library may be generated, which "
"will need to be used for all future DLLs that depend on the symbols in the "
"application or DLL."
msgstr ""
"I Windows finns det två typer av bibliotek, ett statiskt bibliotek och ett "
"importbibliotek (båda kallas :file:`.lib`).  Ett statiskt bibliotek är som "
"en Unix-fil :file:`.a`; det innehåller kod som kan inkluderas efter behov. "
"Ett importbibliotek används i princip bara för att försäkra länkaren om att "
"en viss identifierare är laglig och kommer att finnas med i programmet när "
"DLL:en laddas.  Länkaren använder informationen från importbiblioteket för "
"att bygga upp en uppslagstabell för att använda identifierare som inte ingår "
"i DLL-filen.  När ett program eller en DLL länkas kan ett importbibliotek "
"genereras, som måste användas för alla framtida DLL:er som är beroende av "
"symbolerna i programmet eller DLL:en."

msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to "
"the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows, "
"building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:"
"`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it "
"just contains information which will be used at runtime to access A's code."
msgstr ""
"Anta att du bygger två moduler med dynamisk laddning, B och C, som ska dela "
"ett annat kodblock A.  På Unix skulle du *inte* skicka :file:`A.a` till "
"länkaren för :file:`B.so` och :file:`C.so`; det skulle leda till att den "
"inkluderades två gånger, så att B och C skulle få var sin kopia.  I Windows "
"kommer byggandet av :file:`A.dll` också att bygga :file:`A.lib`.  Du "
"*överlämnar* :file:`A.lib` till länkaren för B och C. :file:`A.lib` "
"innehåller inte kod, utan bara information som kommer att användas vid "
"körning för att komma åt A:s kod."

msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does "
"create a separate copy."
msgstr ""
"I Windows är det ungefär som att använda ``import spam`` att använda ett "
"importbibliotek; det ger dig tillgång till spams namn, men skapar inte en "
"separat kopia.  På Unix är länkning med ett bibliotek mer som ``from spam "
"import *``; det skapar en separat kopia."

msgid ""
"Turn off the implicit, ``#pragma``-based linkage with the Python library, "
"performed inside CPython header files."
msgstr ""
"Stäng av den implicita, ``#pragma``-baserade länkningen med Python-"
"biblioteket, som utförs i CPython-huvudfiler."

msgid "Using DLLs in Practice"
msgstr "Användning av DLL:er i praktiken"

msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work.  The rest of this section is MSVC++ specific."
msgstr ""
"Windows Python är byggt i Microsoft Visual C++; att använda andra "
"kompilatorer kan fungera eller inte.  Resten av detta avsnitt är MSVC++-"
"specifikt."

msgid ""
"When creating DLLs in Windows, you can use the CPython library in two ways:"
msgstr ""
"När du skapar DLL:er i Windows kan du använda CPython-biblioteket på två "
"sätt:"

msgid ""
"By default, inclusion of :file:`PC/pyconfig.h` directly or via :file:`Python."
"h` triggers an implicit, configure-aware link with the library.  The header "
"file chooses :file:`pythonXY_d.lib` for Debug, :file:`pythonXY.lib` for "
"Release, and :file:`pythonX.lib` for Release with the :ref:`Limited API "
"<stable-application-binary-interface>` enabled."
msgstr ""
"Som standard utlöser inkludering av :file:`PC/pyconfig.h` direkt eller via :"
"file:`Python.h` en implicit, konfigurationsmedveten länk till biblioteket.  "
"Huvudfilen väljer :file:`pythonXY_d.lib` för Debug, :file:`pythonXY.lib` för "
"Release och :file:`pythonX.lib` för Release med :ref:`Limited API <stable-"
"application-binary-interface>` aktiverat."

msgid ""
"To build two DLLs, spam and ni (which uses C functions found in spam), you "
"could use these commands::"
msgstr ""
"Om du vill skapa två DLL-filer, spam och ni (som använder C-funktioner som "
"finns i spam), kan du använda följande kommandon::"

msgid ""
"cl /LD /I/python/include spam.c\n"
"cl /LD /I/python/include ni.c spam.lib"
msgstr ""
"cl /LD /I/python/include spam.c\n"
"cl /LD /I/python/include ni.c spam.lib"

msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to the implicitly linked :file:`pythonXY.lib`."
msgstr ""
"Det första kommandot skapade tre filer: :file:`spam.obj`, :file:`spam.dll` "
"och :file:`spam.lib`. :file:`Spam.dll` innehåller inga Python-funktioner (t."
"ex. :c:func:`PyArg_ParseTuple`), men den vet hur man hittar Python-koden "
"tack vare den implicit länkade :file:`pythonXY.lib`."

msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and :file:`."
"lib`), which knows how to find the necessary functions from spam, and also "
"from the Python executable."
msgstr ""
"Det andra kommandot skapade :file:`ni.dll` (och :file:`.obj` och :file:`."
"lib`), som vet hur man hittar de nödvändiga funktionerna från spam och även "
"från den körbara Python-filen."

msgid ""
"Manually by defining :c:macro:`Py_NO_LINK_LIB` macro before including :file:"
"`Python.h`. You must pass :file:`pythonXY.lib` to the linker."
msgstr ""
"Manuellt genom att definiera makrot :c:macro:`Py_NO_LINK_LIB` innan du "
"inkluderar :file:`Python.h`. Du måste skicka :file:`pythonXY.lib` till "
"länkaren."

msgid ""
"cl /LD /DPy_NO_LINK_LIB /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /DPy_NO_LINK_LIB /I/python/include ni.c spam.lib ../libs/pythonXY.lib"
msgstr ""
"cl /LD /DPy_NO_LINK_LIB /I/python/include spam.c ../libs/pythonXY.lib\n"
"cl /LD /DPy_NO_LINK_LIB /I/python/include ni.c spam.lib ../libs/pythonXY.lib"

msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"Det första kommandot skapade tre filer: :file:`spam.obj`, :file:`spam.dll` "
"och :file:`spam.lib`. :file:`Spam.dll` innehåller inga Python-funktioner (t."
"ex. :c:func:`PyArg_ParseTuple`), men den vet hur man hittar Python-koden "
"tack vare :file:`pythonXY.lib`."

msgid ""
"Not every identifier is exported to the lookup table.  If you want any other "
"modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"Inte alla identifierare exporteras till uppslagstabellen.  Om du vill att "
"andra moduler (inklusive Python) ska kunna se dina identifierare måste du "
"säga ``_declspec(dllexport)``, som i ``void _declspec(dllexport) "
"initspam(void)`` eller ``PyObject _declspec(dllexport) "
"*NiGetSpamData(void)``."

msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrt{xx}.lib` to the list of libraries."
msgstr ""
"Developer Studio slänger in en massa importbibliotek som du egentligen inte "
"behöver och som lägger till ca 100K till din körbara fil.  För att bli av "
"med dem, använd dialogrutan Projektinställningar, fliken Länk, för att ange "
"*ignorera standardbibliotek*.  Lägg till rätt :file:`msvcrt{xx}.lib` i "
"listan över bibliotek."
