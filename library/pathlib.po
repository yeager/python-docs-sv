# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-19 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!pathlib` --- Object-oriented filesystem paths"
msgstr ""

msgid "**Source code:** :source:`Lib/pathlib/`"
msgstr ""

msgid ""
"This module offers classes representing filesystem paths with semantics "
"appropriate for different operating systems.  Path classes are divided "
"between :ref:`pure paths <pure-paths>`, which provide purely computational "
"operations without I/O, and :ref:`concrete paths <concrete-paths>`, which "
"inherit from pure paths but also provide I/O operations."
msgstr ""

msgid ""
"Inheritance diagram showing the classes available in pathlib. The\n"
"most basic class is PurePath, which has three direct subclasses:\n"
"PurePosixPath, PureWindowsPath, and Path. Further to these four\n"
"classes, there are two classes that use multiple inheritance:\n"
"PosixPath subclasses PurePosixPath and Path, and WindowsPath\n"
"subclasses PureWindowsPath and Path."
msgstr ""

msgid ""
"If you've never used this module before or just aren't sure which class is "
"right for your task, :class:`Path` is most likely what you need. It "
"instantiates a :ref:`concrete path <concrete-paths>` for the platform the "
"code is running on."
msgstr ""

msgid "Pure paths are useful in some special cases; for example:"
msgstr ""

msgid ""
"If you want to manipulate Windows paths on a Unix machine (or vice versa). "
"You cannot instantiate a :class:`WindowsPath` when running on Unix, but you "
"can instantiate :class:`PureWindowsPath`."
msgstr ""

msgid ""
"You want to make sure that your code only manipulates paths without actually "
"accessing the OS. In this case, instantiating one of the pure classes may be "
"useful since those simply don't have any OS-accessing operations."
msgstr ""

msgid ":pep:`428`: The pathlib module -- object-oriented filesystem paths."
msgstr ""

msgid ""
"For low-level path manipulation on strings, you can also use the :mod:`os."
"path` module."
msgstr ""

msgid "Basic use"
msgstr ""

msgid "Importing the main class::"
msgstr ""

msgid ">>> from pathlib import Path"
msgstr ""

msgid "Listing subdirectories::"
msgstr ""

msgid ""
">>> p = Path('.')\n"
">>> [x for x in p.iterdir() if x.is_dir()]\n"
"[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),\n"
" PosixPath('__pycache__'), PosixPath('build')]"
msgstr ""

msgid "Listing Python source files in this directory tree::"
msgstr ""

msgid ""
">>> list(p.glob('**/*.py'))\n"
"[PosixPath('test_pathlib.py'), PosixPath('setup.py'),\n"
" PosixPath('pathlib.py'), PosixPath('docs/conf.py'),\n"
" PosixPath('build/lib/pathlib.py')]"
msgstr ""

msgid "Navigating inside a directory tree::"
msgstr ""

msgid ""
">>> p = Path('/etc')\n"
">>> q = p / 'init.d' / 'reboot'\n"
">>> q\n"
"PosixPath('/etc/init.d/reboot')\n"
">>> q.resolve()\n"
"PosixPath('/etc/rc.d/init.d/halt')"
msgstr ""

msgid "Querying path properties::"
msgstr ""

msgid ""
">>> q.exists()\n"
"True\n"
">>> q.is_dir()\n"
"False"
msgstr ""

msgid "Opening a file::"
msgstr ""

msgid ""
">>> with q.open() as f: f.readline()\n"
"...\n"
"'#!/bin/bash\\n'"
msgstr ""

msgid "Exceptions"
msgstr ""

msgid ""
"An exception inheriting :exc:`NotImplementedError` that is raised when an "
"unsupported operation is called on a path object."
msgstr ""

msgid "Pure paths"
msgstr ""

msgid ""
"Pure path objects provide path-handling operations which don't actually "
"access a filesystem.  There are three ways to access these classes, which we "
"also call *flavours*:"
msgstr ""

msgid ""
"A generic class that represents the system's path flavour (instantiating it "
"creates either a :class:`PurePosixPath` or a :class:`PureWindowsPath`)::"
msgstr ""

msgid ""
">>> PurePath('setup.py')      # Running on a Unix machine\n"
"PurePosixPath('setup.py')"
msgstr ""

msgid ""
"Each element of *pathsegments* can be either a string representing a path "
"segment, or an object implementing the :class:`os.PathLike` interface where "
"the :meth:`~os.PathLike.__fspath__` method returns a string, such as another "
"path object::"
msgstr ""

msgid ""
">>> PurePath('foo', 'some/path', 'bar')\n"
"PurePosixPath('foo/some/path/bar')\n"
">>> PurePath(Path('foo'), Path('bar'))\n"
"PurePosixPath('foo/bar')"
msgstr ""

msgid "When *pathsegments* is empty, the current directory is assumed::"
msgstr ""

msgid ""
">>> PurePath()\n"
"PurePosixPath('.')"
msgstr ""

msgid ""
"If a segment is an absolute path, all previous segments are ignored (like :"
"func:`os.path.join`)::"
msgstr ""

msgid ""
">>> PurePath('/etc', '/usr', 'lib64')\n"
"PurePosixPath('/usr/lib64')\n"
">>> PureWindowsPath('c:/Windows', 'd:bar')\n"
"PureWindowsPath('d:bar')"
msgstr ""

msgid ""
"On Windows, the drive is not reset when a rooted relative path segment (e."
"g., ``r'\\foo'``) is encountered::"
msgstr ""

msgid ""
">>> PureWindowsPath('c:/Windows', '/Program Files')\n"
"PureWindowsPath('c:/Program Files')"
msgstr ""

msgid ""
"Spurious slashes and single dots are collapsed, but double dots (``'..'``) "
"and leading double slashes (``'//'``) are not, since this would change the "
"meaning of a path for various reasons (e.g. symbolic links, UNC paths)::"
msgstr ""

msgid ""
">>> PurePath('foo//bar')\n"
"PurePosixPath('foo/bar')\n"
">>> PurePath('//foo/bar')\n"
"PurePosixPath('//foo/bar')\n"
">>> PurePath('foo/./bar')\n"
"PurePosixPath('foo/bar')\n"
">>> PurePath('foo/../bar')\n"
"PurePosixPath('foo/../bar')"
msgstr ""

msgid ""
"(a naïve approach would make ``PurePosixPath('foo/../bar')`` equivalent to "
"``PurePosixPath('bar')``, which is wrong if ``foo`` is a symbolic link to "
"another directory)"
msgstr ""

msgid ""
"Pure path objects implement the :class:`os.PathLike` interface, allowing "
"them to be used anywhere the interface is accepted."
msgstr ""

msgid "Added support for the :class:`os.PathLike` interface."
msgstr ""

msgid ""
"A subclass of :class:`PurePath`, this path flavour represents non-Windows "
"filesystem paths::"
msgstr ""

msgid ""
">>> PurePosixPath('/etc/hosts')\n"
"PurePosixPath('/etc/hosts')"
msgstr ""

msgid "*pathsegments* is specified similarly to :class:`PurePath`."
msgstr ""

msgid ""
"A subclass of :class:`PurePath`, this path flavour represents Windows "
"filesystem paths, including `UNC paths`_::"
msgstr ""

msgid ""
">>> PureWindowsPath('c:/', 'Users', 'Ximénez')\n"
"PureWindowsPath('c:/Users/Ximénez')\n"
">>> PureWindowsPath('//server/share/file')\n"
"PureWindowsPath('//server/share/file')"
msgstr ""

msgid ""
"Regardless of the system you're running on, you can instantiate all of these "
"classes, since they don't provide any operation that does system calls."
msgstr ""

msgid "General properties"
msgstr ""

msgid ""
"Paths are immutable and :term:`hashable`.  Paths of a same flavour are "
"comparable and orderable.  These properties respect the flavour's case-"
"folding semantics::"
msgstr ""

msgid ""
">>> PurePosixPath('foo') == PurePosixPath('FOO')\n"
"False\n"
">>> PureWindowsPath('foo') == PureWindowsPath('FOO')\n"
"True\n"
">>> PureWindowsPath('FOO') in { PureWindowsPath('foo') }\n"
"True\n"
">>> PureWindowsPath('C:') < PureWindowsPath('d:')\n"
"True"
msgstr ""

msgid "Paths of a different flavour compare unequal and cannot be ordered::"
msgstr ""

msgid ""
">>> PureWindowsPath('foo') == PurePosixPath('foo')\n"
"False\n"
">>> PureWindowsPath('foo') < PurePosixPath('foo')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'PureWindowsPath' and "
"'PurePosixPath'"
msgstr ""

msgid "Operators"
msgstr ""

msgid ""
"The slash operator helps create child paths, like :func:`os.path.join`. If "
"the argument is an absolute path, the previous path is ignored. On Windows, "
"the drive is not reset when the argument is a rooted relative path (e.g., "
"``r'\\foo'``)::"
msgstr ""

msgid ""
">>> p = PurePath('/etc')\n"
">>> p\n"
"PurePosixPath('/etc')\n"
">>> p / 'init.d' / 'apache2'\n"
"PurePosixPath('/etc/init.d/apache2')\n"
">>> q = PurePath('bin')\n"
">>> '/usr' / q\n"
"PurePosixPath('/usr/bin')\n"
">>> p / '/an_absolute_path'\n"
"PurePosixPath('/an_absolute_path')\n"
">>> PureWindowsPath('c:/Windows', '/Program Files')\n"
"PureWindowsPath('c:/Program Files')"
msgstr ""

msgid ""
"A path object can be used anywhere an object implementing :class:`os."
"PathLike` is accepted::"
msgstr ""

msgid ""
">>> import os\n"
">>> p = PurePath('/etc')\n"
">>> os.fspath(p)\n"
"'/etc'"
msgstr ""

msgid ""
"The string representation of a path is the raw filesystem path itself (in "
"native form, e.g. with backslashes under Windows), which you can pass to any "
"function taking a file path as a string::"
msgstr ""

msgid ""
">>> p = PurePath('/etc')\n"
">>> str(p)\n"
"'/etc'\n"
">>> p = PureWindowsPath('c:/Program Files')\n"
">>> str(p)\n"
"'c:\\\\Program Files'"
msgstr ""

msgid ""
"Similarly, calling :class:`bytes` on a path gives the raw filesystem path as "
"a bytes object, as encoded by :func:`os.fsencode`::"
msgstr ""

msgid ""
">>> bytes(p)\n"
"b'/etc'"
msgstr ""

msgid ""
"Calling :class:`bytes` is only recommended under Unix.  Under Windows, the "
"unicode form is the canonical representation of filesystem paths."
msgstr ""

msgid "Accessing individual parts"
msgstr ""

msgid ""
"To access the individual \"parts\" (components) of a path, use the following "
"property:"
msgstr ""

msgid "A tuple giving access to the path's various components::"
msgstr ""

msgid ""
">>> p = PurePath('/usr/bin/python3')\n"
">>> p.parts\n"
"('/', 'usr', 'bin', 'python3')\n"
"\n"
">>> p = PureWindowsPath('c:/Program Files/PSF')\n"
">>> p.parts\n"
"('c:\\\\', 'Program Files', 'PSF')"
msgstr ""

msgid "(note how the drive and local root are regrouped in a single part)"
msgstr ""

msgid "Methods and properties"
msgstr ""

msgid "Pure paths provide the following methods and properties:"
msgstr ""

msgid ""
"The implementation of the :mod:`os.path` module used for low-level path "
"parsing and joining: either :mod:`posixpath` or :mod:`ntpath`."
msgstr ""

msgid "A string representing the drive letter or name, if any::"
msgstr ""

msgid ""
">>> PureWindowsPath('c:/Program Files/').drive\n"
"'c:'\n"
">>> PureWindowsPath('/Program Files/').drive\n"
"''\n"
">>> PurePosixPath('/etc').drive\n"
"''"
msgstr ""

msgid "UNC shares are also considered drives::"
msgstr ""

msgid ""
">>> PureWindowsPath('//host/share/foo.txt').drive\n"
"'\\\\\\\\host\\\\share'"
msgstr ""

msgid "A string representing the (local or global) root, if any::"
msgstr ""

msgid ""
">>> PureWindowsPath('c:/Program Files/').root\n"
"'\\\\'\n"
">>> PureWindowsPath('c:Program Files/').root\n"
"''\n"
">>> PurePosixPath('/etc').root\n"
"'/'"
msgstr ""

msgid "UNC shares always have a root::"
msgstr ""

msgid ""
">>> PureWindowsPath('//host/share').root\n"
"'\\\\'"
msgstr ""

msgid ""
"If the path starts with more than two successive slashes, :class:`~pathlib."
"PurePosixPath` collapses them::"
msgstr ""

msgid ""
">>> PurePosixPath('//etc').root\n"
"'//'\n"
">>> PurePosixPath('///etc').root\n"
"'/'\n"
">>> PurePosixPath('////etc').root\n"
"'/'"
msgstr ""

msgid ""
"This behavior conforms to *The Open Group Base Specifications Issue 6*, "
"paragraph `4.11 Pathname Resolution <https://pubs.opengroup.org/"
"onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11>`_:"
msgstr ""

msgid ""
"*\"A pathname that begins with two successive slashes may be interpreted in "
"an implementation-defined manner, although more than two leading slashes "
"shall be treated as a single slash.\"*"
msgstr ""

msgid "The concatenation of the drive and root::"
msgstr ""

msgid ""
">>> PureWindowsPath('c:/Program Files/').anchor\n"
"'c:\\\\'\n"
">>> PureWindowsPath('c:Program Files/').anchor\n"
"'c:'\n"
">>> PurePosixPath('/etc').anchor\n"
"'/'\n"
">>> PureWindowsPath('//host/share').anchor\n"
"'\\\\\\\\host\\\\share\\\\'"
msgstr ""

msgid ""
"An immutable sequence providing access to the logical ancestors of the path::"
msgstr ""

msgid ""
">>> p = PureWindowsPath('c:/foo/bar/setup.py')\n"
">>> p.parents[0]\n"
"PureWindowsPath('c:/foo/bar')\n"
">>> p.parents[1]\n"
"PureWindowsPath('c:/foo')\n"
">>> p.parents[2]\n"
"PureWindowsPath('c:/')"
msgstr ""

msgid ""
"The parents sequence now supports :term:`slices <slice>` and negative index "
"values."
msgstr ""

msgid "The logical parent of the path::"
msgstr ""

msgid ""
">>> p = PurePosixPath('/a/b/c/d')\n"
">>> p.parent\n"
"PurePosixPath('/a/b/c')"
msgstr ""

msgid "You cannot go past an anchor, or empty path::"
msgstr ""

msgid ""
">>> p = PurePosixPath('/')\n"
">>> p.parent\n"
"PurePosixPath('/')\n"
">>> p = PurePosixPath('.')\n"
">>> p.parent\n"
"PurePosixPath('.')"
msgstr ""

msgid "This is a purely lexical operation, hence the following behaviour::"
msgstr ""

msgid ""
">>> p = PurePosixPath('foo/..')\n"
">>> p.parent\n"
"PurePosixPath('foo')"
msgstr ""

msgid ""
"If you want to walk an arbitrary filesystem path upwards, it is recommended "
"to first call :meth:`Path.resolve` so as to resolve symlinks and eliminate "
"``\"..\"`` components."
msgstr ""

msgid ""
"A string representing the final path component, excluding the drive and "
"root, if any::"
msgstr ""

msgid ""
">>> PurePosixPath('my/library/setup.py').name\n"
"'setup.py'"
msgstr ""

msgid "UNC drive names are not considered::"
msgstr ""

msgid ""
">>> PureWindowsPath('//some/share/setup.py').name\n"
"'setup.py'\n"
">>> PureWindowsPath('//some/share').name\n"
"''"
msgstr ""

msgid "The last dot-separated portion of the final component, if any::"
msgstr ""

msgid ""
">>> PurePosixPath('my/library/setup.py').suffix\n"
"'.py'\n"
">>> PurePosixPath('my/library.tar.gz').suffix\n"
"'.gz'\n"
">>> PurePosixPath('my/library').suffix\n"
"''"
msgstr ""

msgid "This is commonly called the file extension."
msgstr ""

msgid "A single dot (\"``.``\") is considered a valid suffix."
msgstr ""

msgid "A list of the path's suffixes, often called file extensions::"
msgstr ""

msgid ""
">>> PurePosixPath('my/library.tar.gar').suffixes\n"
"['.tar', '.gar']\n"
">>> PurePosixPath('my/library.tar.gz').suffixes\n"
"['.tar', '.gz']\n"
">>> PurePosixPath('my/library').suffixes\n"
"[]"
msgstr ""

msgid "The final path component, without its suffix::"
msgstr ""

msgid ""
">>> PurePosixPath('my/library.tar.gz').stem\n"
"'library.tar'\n"
">>> PurePosixPath('my/library.tar').stem\n"
"'library'\n"
">>> PurePosixPath('my/library').stem\n"
"'library'"
msgstr ""

msgid ""
"Return a string representation of the path with forward slashes (``/``)::"
msgstr ""

msgid ""
">>> p = PureWindowsPath('c:\\\\windows')\n"
">>> str(p)\n"
"'c:\\\\windows'\n"
">>> p.as_posix()\n"
"'c:/windows'"
msgstr ""

msgid ""
"Return whether the path is absolute or not.  A path is considered absolute "
"if it has both a root and (if the flavour allows) a drive::"
msgstr ""

msgid ""
">>> PurePosixPath('/a/b').is_absolute()\n"
"True\n"
">>> PurePosixPath('a/b').is_absolute()\n"
"False\n"
"\n"
">>> PureWindowsPath('c:/a/b').is_absolute()\n"
"True\n"
">>> PureWindowsPath('/a/b').is_absolute()\n"
"False\n"
">>> PureWindowsPath('c:').is_absolute()\n"
"False\n"
">>> PureWindowsPath('//some/share').is_absolute()\n"
"True"
msgstr ""

msgid "Return whether or not this path is relative to the *other* path."
msgstr ""

msgid ""
"This method is string-based; it neither accesses the filesystem nor treats "
"\"``..``\" segments specially. The following code is equivalent:"
msgstr ""

msgid ""
"Passing additional arguments is deprecated; if supplied, they are joined "
"with *other*."
msgstr ""

msgid ""
"With :class:`PureWindowsPath`, return ``True`` if the path is considered "
"reserved under Windows, ``False`` otherwise.  With :class:`PurePosixPath`, "
"``False`` is always returned."
msgstr ""

msgid ""
"Windows path names that contain a colon, or end with a dot or a space, are "
"considered reserved. UNC paths may be reserved."
msgstr ""

msgid ""
"This method is deprecated; use :func:`os.path.isreserved` to detect reserved "
"paths on Windows."
msgstr ""

msgid ""
"Calling this method is equivalent to combining the path with each of the "
"given *pathsegments* in turn::"
msgstr ""

msgid ""
">>> PurePosixPath('/etc').joinpath('passwd')\n"
"PurePosixPath('/etc/passwd')\n"
">>> PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))\n"
"PurePosixPath('/etc/passwd')\n"
">>> PurePosixPath('/etc').joinpath('init.d', 'apache2')\n"
"PurePosixPath('/etc/init.d/apache2')\n"
">>> PureWindowsPath('c:').joinpath('/Program Files')\n"
"PureWindowsPath('c:/Program Files')"
msgstr ""

msgid ""
"Match this path against the provided glob-style pattern.  Return ``True`` if "
"matching is successful, ``False`` otherwise.  For example::"
msgstr ""

msgid ""
">>> PurePath('a/b.py').full_match('a/*.py')\n"
"True\n"
">>> PurePath('a/b.py').full_match('*.py')\n"
"False\n"
">>> PurePath('/a/b/c.py').full_match('/a/**')\n"
"True\n"
">>> PurePath('/a/b/c.py').full_match('**/*.py')\n"
"True"
msgstr ""

msgid ":ref:`pathlib-pattern-language` documentation."
msgstr ""

msgid "As with other methods, case-sensitivity follows platform defaults::"
msgstr ""

msgid ""
">>> PurePosixPath('b.py').full_match('*.PY')\n"
"False\n"
">>> PureWindowsPath('b.py').full_match('*.PY')\n"
"True"
msgstr ""

msgid ""
"Set *case_sensitive* to ``True`` or ``False`` to override this behaviour."
msgstr ""

msgid ""
"Match this path against the provided non-recursive glob-style pattern. "
"Return ``True`` if matching is successful, ``False`` otherwise."
msgstr ""

msgid ""
"This method is similar to :meth:`~PurePath.full_match`, but empty patterns "
"aren't allowed (:exc:`ValueError` is raised), the recursive wildcard "
"\"``**``\" isn't supported (it acts like non-recursive \"``*``\"), and if a "
"relative pattern is provided, then matching is done from the right::"
msgstr ""

msgid ""
">>> PurePath('a/b.py').match('*.py')\n"
"True\n"
">>> PurePath('/a/b/c.py').match('b/*.py')\n"
"True\n"
">>> PurePath('/a/b/c.py').match('a/*.py')\n"
"False"
msgstr ""

msgid "The *pattern* parameter accepts a :term:`path-like object`."
msgstr ""

msgid "The *case_sensitive* parameter was added."
msgstr ""

msgid ""
"Compute a version of this path relative to the path represented by *other*.  "
"If it's impossible, :exc:`ValueError` is raised::"
msgstr ""

msgid ""
">>> p = PurePosixPath('/etc/passwd')\n"
">>> p.relative_to('/')\n"
"PurePosixPath('etc/passwd')\n"
">>> p.relative_to('/etc')\n"
"PurePosixPath('passwd')\n"
">>> p.relative_to('/usr')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"pathlib.py\", line 941, in relative_to\n"
"    raise ValueError(error_message.format(str(self), str(formatted)))\n"
"ValueError: '/etc/passwd' is not in the subpath of '/usr' OR one path is "
"relative and the other is absolute."
msgstr ""

msgid ""
"When *walk_up* is false (the default), the path must start with *other*. "
"When the argument is true, ``..`` entries may be added to form the relative "
"path. In all other cases, such as the paths referencing different drives, :"
"exc:`ValueError` is raised.::"
msgstr ""

msgid ""
">>> p.relative_to('/usr', walk_up=True)\n"
"PurePosixPath('../etc/passwd')\n"
">>> p.relative_to('foo', walk_up=True)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"pathlib.py\", line 941, in relative_to\n"
"    raise ValueError(error_message.format(str(self), str(formatted)))\n"
"ValueError: '/etc/passwd' is not on the same drive as 'foo' OR one path is "
"relative and the other is absolute."
msgstr ""

msgid ""
"This function is part of :class:`PurePath` and works with strings. It does "
"not check or access the underlying file structure. This can impact the "
"*walk_up* option as it assumes that no symlinks are present in the path; "
"call :meth:`~Path.resolve` first if necessary to resolve symlinks."
msgstr ""

msgid ""
"The *walk_up* parameter was added (old behavior is the same as "
"``walk_up=False``)."
msgstr ""

msgid ""
"Passing additional positional arguments is deprecated; if supplied, they are "
"joined with *other*."
msgstr ""

msgid ""
"Return a new path with the :attr:`name` changed.  If the original path "
"doesn't have a name, ValueError is raised::"
msgstr ""

msgid ""
">>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
">>> p.with_name('setup.py')\n"
"PureWindowsPath('c:/Downloads/setup.py')\n"
">>> p = PureWindowsPath('c:/')\n"
">>> p.with_name('setup.py')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"/home/antoine/cpython/default/Lib/pathlib.py\", line 751, in "
"with_name\n"
"    raise ValueError(\"%r has an empty name\" % (self,))\n"
"ValueError: PureWindowsPath('c:/') has an empty name"
msgstr ""

msgid ""
"Return a new path with the :attr:`stem` changed.  If the original path "
"doesn't have a name, ValueError is raised::"
msgstr ""

msgid ""
">>> p = PureWindowsPath('c:/Downloads/draft.txt')\n"
">>> p.with_stem('final')\n"
"PureWindowsPath('c:/Downloads/final.txt')\n"
">>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
">>> p.with_stem('lib')\n"
"PureWindowsPath('c:/Downloads/lib.gz')\n"
">>> p = PureWindowsPath('c:/')\n"
">>> p.with_stem('')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"/home/antoine/cpython/default/Lib/pathlib.py\", line 861, in "
"with_stem\n"
"    return self.with_name(stem + self.suffix)\n"
"  File \"/home/antoine/cpython/default/Lib/pathlib.py\", line 851, in "
"with_name\n"
"    raise ValueError(\"%r has an empty name\" % (self,))\n"
"ValueError: PureWindowsPath('c:/') has an empty name"
msgstr ""

msgid ""
"Return a new path with the :attr:`suffix` changed.  If the original path "
"doesn't have a suffix, the new *suffix* is appended instead.  If the "
"*suffix* is an empty string, the original suffix is removed::"
msgstr ""

msgid ""
">>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
">>> p.with_suffix('.bz2')\n"
"PureWindowsPath('c:/Downloads/pathlib.tar.bz2')\n"
">>> p = PureWindowsPath('README')\n"
">>> p.with_suffix('.txt')\n"
"PureWindowsPath('README.txt')\n"
">>> p = PureWindowsPath('README.txt')\n"
">>> p.with_suffix('')\n"
"PureWindowsPath('README')"
msgstr ""

msgid ""
"A single dot (\"``.``\") is considered a valid suffix. In previous "
"versions, :exc:`ValueError` is raised if a single dot is supplied."
msgstr ""

msgid ""
"Create a new path object of the same type by combining the given "
"*pathsegments*. This method is called whenever a derivative path is created, "
"such as from :attr:`parent` and :meth:`relative_to`. Subclasses may override "
"this method to pass information to derivative paths, for example::"
msgstr ""

msgid ""
"from pathlib import PurePosixPath\n"
"\n"
"class MyPath(PurePosixPath):\n"
"    def __init__(self, *pathsegments, session_id):\n"
"        super().__init__(*pathsegments)\n"
"        self.session_id = session_id\n"
"\n"
"    def with_segments(self, *pathsegments):\n"
"        return type(self)(*pathsegments, session_id=self.session_id)\n"
"\n"
"etc = MyPath('/etc', session_id=42)\n"
"hosts = etc / 'hosts'\n"
"print(hosts.session_id)  # 42"
msgstr ""

msgid "Concrete paths"
msgstr ""

msgid ""
"Concrete paths are subclasses of the pure path classes.  In addition to "
"operations provided by the latter, they also provide methods to do system "
"calls on path objects.  There are three ways to instantiate concrete paths:"
msgstr ""

msgid ""
"A subclass of :class:`PurePath`, this class represents concrete paths of the "
"system's path flavour (instantiating it creates either a :class:`PosixPath` "
"or a :class:`WindowsPath`)::"
msgstr ""

msgid ""
">>> Path('setup.py')\n"
"PosixPath('setup.py')"
msgstr ""

msgid ""
"A subclass of :class:`Path` and :class:`PurePosixPath`, this class "
"represents concrete non-Windows filesystem paths::"
msgstr ""

msgid ""
">>> PosixPath('/etc/hosts')\n"
"PosixPath('/etc/hosts')"
msgstr ""

msgid ""
"Raises :exc:`UnsupportedOperation` on Windows. In previous versions, :exc:"
"`NotImplementedError` was raised instead."
msgstr ""

msgid ""
"A subclass of :class:`Path` and :class:`PureWindowsPath`, this class "
"represents concrete Windows filesystem paths::"
msgstr ""

msgid ""
">>> WindowsPath('c:/', 'Users', 'Ximénez')\n"
"WindowsPath('c:/Users/Ximénez')"
msgstr ""

msgid ""
"Raises :exc:`UnsupportedOperation` on non-Windows platforms. In previous "
"versions, :exc:`NotImplementedError` was raised instead."
msgstr ""

msgid ""
"You can only instantiate the class flavour that corresponds to your system "
"(allowing system calls on non-compatible path flavours could lead to bugs or "
"failures in your application)::"
msgstr ""

msgid ""
">>> import os\n"
">>> os.name\n"
"'posix'\n"
">>> Path('setup.py')\n"
"PosixPath('setup.py')\n"
">>> PosixPath('setup.py')\n"
"PosixPath('setup.py')\n"
">>> WindowsPath('setup.py')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"pathlib.py\", line 798, in __new__\n"
"    % (cls.__name__,))\n"
"UnsupportedOperation: cannot instantiate 'WindowsPath' on your system"
msgstr ""

msgid ""
"Some concrete path methods can raise an :exc:`OSError` if a system call "
"fails (for example because the path doesn't exist)."
msgstr ""

msgid "Parsing and generating URIs"
msgstr ""

msgid ""
"Concrete path objects can be created from, and represented as, 'file' URIs "
"conforming to :rfc:`8089`."
msgstr ""

msgid ""
"File URIs are not portable across machines with different :ref:`filesystem "
"encodings <filesystem-encoding>`."
msgstr ""

msgid "Return a new path object from parsing a 'file' URI. For example::"
msgstr ""

msgid ""
">>> p = Path.from_uri('file:///etc/hosts')\n"
"PosixPath('/etc/hosts')"
msgstr ""

msgid "On Windows, DOS device and UNC paths may be parsed from URIs::"
msgstr ""

msgid ""
">>> p = Path.from_uri('file:///c:/windows')\n"
"WindowsPath('c:/windows')\n"
">>> p = Path.from_uri('file://server/share')\n"
"WindowsPath('//server/share')"
msgstr ""

msgid "Several variant forms are supported::"
msgstr ""

msgid ""
">>> p = Path.from_uri('file:////server/share')\n"
"WindowsPath('//server/share')\n"
">>> p = Path.from_uri('file://///server/share')\n"
"WindowsPath('//server/share')\n"
">>> p = Path.from_uri('file:c:/windows')\n"
"WindowsPath('c:/windows')\n"
">>> p = Path.from_uri('file:/c|/windows')\n"
"WindowsPath('c:/windows')"
msgstr ""

msgid ""
":exc:`ValueError` is raised if the URI does not start with ``file:``, or the "
"parsed path isn't absolute."
msgstr ""

msgid ""
"The URL authority is discarded if it matches the local hostname. Otherwise, "
"if the authority isn't empty or ``localhost``, then on Windows a UNC path is "
"returned (as before), and on other platforms a :exc:`ValueError` is raised."
msgstr ""

msgid ""
"Represent the path as a 'file' URI.  :exc:`ValueError` is raised if the path "
"isn't absolute."
msgstr ""

msgid ""
">>> p = PosixPath('/etc/passwd')\n"
">>> p.as_uri()\n"
"'file:///etc/passwd'\n"
">>> p = WindowsPath('c:/Windows')\n"
">>> p.as_uri()\n"
"'file:///c:/Windows'"
msgstr ""

msgid ""
"Calling this method from :class:`PurePath` rather than :class:`Path` is "
"possible but deprecated. The method's use of :func:`os.fsencode` makes it "
"strictly impure."
msgstr ""

msgid "Expanding and resolving paths"
msgstr ""

msgid ""
"Return a new path object representing the user's home directory (as returned "
"by :func:`os.path.expanduser` with ``~`` construct). If the home directory "
"can't be resolved, :exc:`RuntimeError` is raised."
msgstr ""

msgid ""
">>> Path.home()\n"
"PosixPath('/home/antoine')"
msgstr ""

msgid ""
"Return a new path with expanded ``~`` and ``~user`` constructs, as returned "
"by :meth:`os.path.expanduser`. If a home directory can't be resolved, :exc:"
"`RuntimeError` is raised."
msgstr ""

msgid ""
">>> p = PosixPath('~/films/Monty Python')\n"
">>> p.expanduser()\n"
"PosixPath('/home/eric/films/Monty Python')"
msgstr ""

msgid ""
"Return a new path object representing the current directory (as returned by :"
"func:`os.getcwd`)::"
msgstr ""

msgid ""
">>> Path.cwd()\n"
"PosixPath('/home/antoine/pathlib')"
msgstr ""

msgid ""
"Make the path absolute, without normalization or resolving symlinks. Returns "
"a new path object::"
msgstr ""

msgid ""
">>> p = Path('tests')\n"
">>> p\n"
"PosixPath('tests')\n"
">>> p.absolute()\n"
"PosixPath('/home/antoine/pathlib/tests')"
msgstr ""

msgid ""
"Make the path absolute, resolving any symlinks.  A new path object is "
"returned::"
msgstr ""

msgid ""
">>> p = Path()\n"
">>> p\n"
"PosixPath('.')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib')"
msgstr ""

msgid ""
"\"``..``\" components are also eliminated (this is the only method to do "
"so)::"
msgstr ""

msgid ""
">>> p = Path('docs/../setup.py')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib/setup.py')"
msgstr ""

msgid ""
"If a path doesn't exist or a symlink loop is encountered, and *strict* is "
"``True``, :exc:`OSError` is raised.  If *strict* is ``False``, the path is "
"resolved as far as possible and any remainder is appended without checking "
"whether it exists."
msgstr ""

msgid "The *strict* parameter was added (pre-3.6 behavior is strict)."
msgstr ""

msgid ""
"Symlink loops are treated like other errors: :exc:`OSError` is raised in "
"strict mode, and no exception is raised in non-strict mode. In previous "
"versions, :exc:`RuntimeError` is raised no matter the value of *strict*."
msgstr ""

msgid ""
"Return the path to which the symbolic link points (as returned by :func:`os."
"readlink`)::"
msgstr ""

msgid ""
">>> p = Path('mylink')\n"
">>> p.symlink_to('setup.py')\n"
">>> p.readlink()\n"
"PosixPath('setup.py')"
msgstr ""

msgid ""
"Raises :exc:`UnsupportedOperation` if :func:`os.readlink` is not available. "
"In previous versions, :exc:`NotImplementedError` was raised."
msgstr ""

msgid "Querying file type and status"
msgstr ""

msgid ""
":meth:`~Path.exists`, :meth:`~Path.is_dir`, :meth:`~Path.is_file`, :meth:"
"`~Path.is_mount`, :meth:`~Path.is_symlink`, :meth:`~Path.is_block_device`, :"
"meth:`~Path.is_char_device`, :meth:`~Path.is_fifo`, :meth:`~Path.is_socket` "
"now return ``False`` instead of raising an exception for paths that contain "
"characters unrepresentable at the OS level."
msgstr ""

msgid ""
"The methods given above now return ``False`` instead of raising any :exc:"
"`OSError` exception from the operating system. In previous versions, some "
"kinds of :exc:`OSError` exception are raised, and others suppressed. The new "
"behaviour is consistent with :func:`os.path.exists`, :func:`os.path.isdir`, "
"etc. Use :meth:`~Path.stat` to retrieve the file status without suppressing "
"exceptions."
msgstr ""

msgid ""
"Return an :class:`os.stat_result` object containing information about this "
"path, like :func:`os.stat`. The result is looked up at each call to this "
"method."
msgstr ""

msgid ""
"This method normally follows symlinks; to stat a symlink add the argument "
"``follow_symlinks=False``, or use :meth:`~Path.lstat`."
msgstr ""

msgid ""
">>> p = Path('setup.py')\n"
">>> p.stat().st_size\n"
"956\n"
">>> p.stat().st_mtime\n"
"1327883547.852554"
msgstr ""

msgid "The *follow_symlinks* parameter was added."
msgstr ""

msgid ""
"Like :meth:`Path.stat` but, if the path points to a symbolic link, return "
"the symbolic link's information rather than its target's."
msgstr ""

msgid ""
"Return ``True`` if the path points to an existing file or directory. "
"``False`` will be returned if the path is invalid, inaccessible or missing. "
"Use :meth:`Path.stat` to distinguish between these cases."
msgstr ""

msgid ""
"This method normally follows symlinks; to check if a symlink exists, add the "
"argument ``follow_symlinks=False``."
msgstr ""

msgid ""
">>> Path('.').exists()\n"
"True\n"
">>> Path('setup.py').exists()\n"
"True\n"
">>> Path('/etc').exists()\n"
"True\n"
">>> Path('nonexistentfile').exists()\n"
"False"
msgstr ""

msgid ""
"Return ``True`` if the path points to a regular file. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a regular file. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""

msgid ""
"This method normally follows symlinks; to exclude symlinks, add the argument "
"``follow_symlinks=False``."
msgstr ""

msgid ""
"Return ``True`` if the path points to a directory. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a directory. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""

msgid ""
"This method normally follows symlinks; to exclude symlinks to directories, "
"add the argument ``follow_symlinks=False``."
msgstr ""

msgid ""
"Return ``True`` if the path points to a symbolic link, even if that symlink "
"is broken. ``False`` will be returned if the path is invalid, inaccessible "
"or missing, or if it points to something other than a symbolic link. Use :"
"meth:`Path.stat` to distinguish between these cases."
msgstr ""

msgid ""
"Return ``True`` if the path points to a junction, and ``False`` for any "
"other type of file. Currently only Windows supports junctions."
msgstr ""

msgid ""
"Return ``True`` if the path is a :dfn:`mount point`: a point in a file "
"system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`path/..`, is on a different "
"device than *path*, or whether :file:`path/..` and *path* point to the same "
"i-node on the same device --- this should detect mount points for all Unix "
"and POSIX variants.  On Windows, a mount point is considered to be a drive "
"letter root (e.g. ``c:\\``), a UNC share (e.g. ``\\\\server\\share``), or a "
"mounted filesystem directory."
msgstr ""

msgid "Windows support was added."
msgstr ""

msgid ""
"Return ``True`` if the path points to a Unix socket. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a Unix socket. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""

msgid ""
"Return ``True`` if the path points to a FIFO. ``False`` will be returned if "
"the path is invalid, inaccessible or missing, or if it points to something "
"other than a FIFO. Use :meth:`Path.stat` to distinguish between these cases."
msgstr ""

msgid ""
"Return ``True`` if the path points to a block device. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a block device. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""

msgid ""
"Return ``True`` if the path points to a character device. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a character device. Use :meth:`Path.stat` to "
"distinguish between these cases."
msgstr ""

msgid ""
"Return whether this path points to the same file as *other_path*, which can "
"be either a Path object, or a string.  The semantics are similar to :func:"
"`os.path.samefile` and :func:`os.path.samestat`."
msgstr ""

msgid ""
"An :exc:`OSError` can be raised if either file cannot be accessed for some "
"reason."
msgstr ""

msgid ""
">>> p = Path('spam')\n"
">>> q = Path('eggs')\n"
">>> p.samefile(q)\n"
"False\n"
">>> p.samefile('spam')\n"
"True"
msgstr ""

msgid ""
"A :class:`~pathlib.types.PathInfo` object that supports querying file type "
"information. The object exposes methods that cache their results, which can "
"help reduce the number of system calls needed when switching on file type. "
"For example::"
msgstr ""

msgid ""
">>> p = Path('src')\n"
">>> if p.info.is_symlink():\n"
"...     print('symlink')\n"
"... elif p.info.is_dir():\n"
"...     print('directory')\n"
"... elif p.info.exists():\n"
"...     print('something else')\n"
"... else:\n"
"...     print('not found')\n"
"...\n"
"directory"
msgstr ""

msgid ""
"If the path was generated from :meth:`Path.iterdir` then this attribute is "
"initialized with some information about the file type gleaned from scanning "
"the parent directory. Merely accessing :attr:`Path.info` does not perform "
"any filesystem queries."
msgstr ""

msgid ""
"To fetch up-to-date information, it's best to call :meth:`Path.is_dir`, :"
"meth:`~Path.is_file` and :meth:`~Path.is_symlink` rather than methods of "
"this attribute. There is no way to reset the cache; instead you can create a "
"new path object with an empty info cache via ``p = Path(p)``."
msgstr ""

msgid "Reading and writing files"
msgstr ""

msgid ""
"Open the file pointed to by the path, like the built-in :func:`open` "
"function does::"
msgstr ""

msgid ""
">>> p = Path('setup.py')\n"
">>> with p.open() as f:\n"
"...     f.readline()\n"
"...\n"
"'#!/usr/bin/env python3\\n'"
msgstr ""

msgid "Return the decoded contents of the pointed-to file as a string::"
msgstr ""

msgid ""
">>> p = Path('my_text_file')\n"
">>> p.write_text('Text file contents')\n"
"18\n"
">>> p.read_text()\n"
"'Text file contents'"
msgstr ""

msgid ""
"The file is opened and then closed. The optional parameters have the same "
"meaning as in :func:`open`."
msgstr ""

msgid "The *newline* parameter was added."
msgstr ""

msgid "Return the binary contents of the pointed-to file as a bytes object::"
msgstr ""

msgid ""
">>> p = Path('my_binary_file')\n"
">>> p.write_bytes(b'Binary file contents')\n"
"20\n"
">>> p.read_bytes()\n"
"b'Binary file contents'"
msgstr ""

msgid ""
"Open the file pointed to in text mode, write *data* to it, and close the "
"file::"
msgstr ""

msgid ""
"An existing file of the same name is overwritten. The optional parameters "
"have the same meaning as in :func:`open`."
msgstr ""

msgid ""
"Open the file pointed to in bytes mode, write *data* to it, and close the "
"file::"
msgstr ""

msgid "An existing file of the same name is overwritten."
msgstr ""

msgid "Reading directories"
msgstr ""

msgid ""
"When the path points to a directory, yield path objects of the directory "
"contents::"
msgstr ""

msgid ""
">>> p = Path('docs')\n"
">>> for child in p.iterdir(): child\n"
"...\n"
"PosixPath('docs/conf.py')\n"
"PosixPath('docs/_templates')\n"
"PosixPath('docs/make.bat')\n"
"PosixPath('docs/index.rst')\n"
"PosixPath('docs/_build')\n"
"PosixPath('docs/_static')\n"
"PosixPath('docs/Makefile')"
msgstr ""

msgid ""
"The children are yielded in arbitrary order, and the special entries ``'.'`` "
"and ``'..'`` are not included.  If a file is removed from or added to the "
"directory after creating the iterator, it is unspecified whether a path "
"object for that file is included."
msgstr ""

msgid ""
"If the path is not a directory or otherwise inaccessible, :exc:`OSError` is "
"raised."
msgstr ""

msgid ""
"Glob the given relative *pattern* in the directory represented by this path, "
"yielding all matching files (of any kind)::"
msgstr ""

msgid ""
">>> sorted(Path('.').glob('*.py'))\n"
"[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib."
"py')]\n"
">>> sorted(Path('.').glob('*/*.py'))\n"
"[PosixPath('docs/conf.py')]\n"
">>> sorted(Path('.').glob('**/*.py'))\n"
"[PosixPath('build/lib/pathlib.py'),\n"
" PosixPath('docs/conf.py'),\n"
" PosixPath('pathlib.py'),\n"
" PosixPath('setup.py'),\n"
" PosixPath('test_pathlib.py')]"
msgstr ""

msgid ""
"By default, or when the *case_sensitive* keyword-only argument is set to "
"``None``, this method matches paths using platform-specific casing rules: "
"typically, case-sensitive on POSIX, and case-insensitive on Windows. Set "
"*case_sensitive* to ``True`` or ``False`` to override this behaviour."
msgstr ""

msgid ""
"By default, or when the *recurse_symlinks* keyword-only argument is set to "
"``False``, this method follows symlinks except when expanding \"``**``\" "
"wildcards. Set *recurse_symlinks* to ``True`` to always follow symlinks."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``pathlib.Path.glob`` with "
"arguments ``self``, ``pattern``."
msgstr ""

msgid "The *recurse_symlinks* parameter was added."
msgstr ""

msgid ""
"Any :exc:`OSError` exceptions raised from scanning the filesystem are "
"suppressed. In previous versions, such exceptions are suppressed in many "
"cases, but not all."
msgstr ""

msgid ""
"Glob the given relative *pattern* recursively.  This is like calling :func:"
"`Path.glob` with \"``**/``\" added in front of the *pattern*."
msgstr ""

msgid ":ref:`pathlib-pattern-language` and :meth:`Path.glob` documentation."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``pathlib.Path.rglob`` with "
"arguments ``self``, ``pattern``."
msgstr ""

msgid ""
"Generate the file names in a directory tree by walking the tree either top-"
"down or bottom-up."
msgstr ""

msgid ""
"For each directory in the directory tree rooted at *self* (including *self* "
"but excluding '.' and '..'), the method yields a 3-tuple of ``(dirpath, "
"dirnames, filenames)``."
msgstr ""

msgid ""
"*dirpath* is a :class:`Path` to the directory currently being walked, "
"*dirnames* is a list of strings for the names of subdirectories in *dirpath* "
"(excluding ``'.'`` and ``'..'``), and *filenames* is a list of strings for "
"the names of the non-directory files in *dirpath*. To get a full path (which "
"begins with *self*) to a file or directory in *dirpath*, do ``dirpath / "
"name``. Whether or not the lists are sorted is file system-dependent."
msgstr ""

msgid ""
"If the optional argument *top_down* is true (which is the default), the "
"triple for a directory is generated before the triples for any of its "
"subdirectories (directories are walked top-down).  If *top_down* is false, "
"the triple for a directory is generated after the triples for all of its "
"subdirectories (directories are walked bottom-up). No matter the value of "
"*top_down*, the list of subdirectories is retrieved before the triples for "
"the directory and its subdirectories are walked."
msgstr ""

msgid ""
"When *top_down* is true, the caller can modify the *dirnames* list in-place "
"(for example, using :keyword:`del` or slice assignment), and :meth:`Path."
"walk` will only recurse into the subdirectories whose names remain in "
"*dirnames*. This can be used to prune the search, or to impose a specific "
"order of visiting, or even to inform :meth:`Path.walk` about directories the "
"caller creates or renames before it resumes :meth:`Path.walk` again. "
"Modifying *dirnames* when *top_down* is false has no effect on the behavior "
"of :meth:`Path.walk` since the directories in *dirnames* have already been "
"generated by the time *dirnames* is yielded to the caller."
msgstr ""

msgid ""
"By default, errors from :func:`os.scandir` are ignored.  If the optional "
"argument *on_error* is specified, it should be a callable; it will be called "
"with one argument, an :exc:`OSError` instance. The callable can handle the "
"error to continue the walk or re-raise it to stop the walk. Note that the "
"filename is available as the ``filename`` attribute of the exception object."
msgstr ""

msgid ""
"By default, :meth:`Path.walk` does not follow symbolic links, and instead "
"adds them to the *filenames* list. Set *follow_symlinks* to true to resolve "
"symlinks and place them in *dirnames* and *filenames* as appropriate for "
"their targets, and consequently visit directories pointed to by symlinks "
"(where supported)."
msgstr ""

msgid ""
"Be aware that setting *follow_symlinks* to true can lead to infinite "
"recursion if a link points to a parent directory of itself. :meth:`Path."
"walk` does not keep track of the directories it has already visited."
msgstr ""

msgid ""
":meth:`Path.walk` assumes the directories it walks are not modified during "
"execution. For example, if a directory from *dirnames* has been replaced "
"with a symlink and *follow_symlinks* is false, :meth:`Path.walk` will still "
"try to descend into it. To prevent such behavior, remove directories from "
"*dirnames* as appropriate."
msgstr ""

msgid ""
"Unlike :func:`os.walk`, :meth:`Path.walk` lists symlinks to directories in "
"*filenames* if *follow_symlinks* is false."
msgstr ""

msgid ""
"This example displays the number of bytes used by all files in each "
"directory, while ignoring ``__pycache__`` directories::"
msgstr ""

msgid ""
"from pathlib import Path\n"
"for root, dirs, files in Path(\"cpython/Lib/concurrent\")."
"walk(on_error=print):\n"
"  print(\n"
"      root,\n"
"      \"consumes\",\n"
"      sum((root / file).stat().st_size for file in files),\n"
"      \"bytes in\",\n"
"      len(files),\n"
"      \"non-directory files\"\n"
"  )\n"
"  if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')"
msgstr ""

msgid ""
"This next example is a simple implementation of :func:`shutil.rmtree`. "
"Walking the tree bottom-up is essential as :func:`rmdir` doesn't allow "
"deleting a directory before it is empty::"
msgstr ""

msgid ""
"# Delete everything reachable from the directory \"top\".\n"
"# CAUTION:  This is dangerous! For example, if top == Path('/'),\n"
"# it could delete all of your files.\n"
"for root, dirs, files in top.walk(top_down=False):\n"
"    for name in files:\n"
"        (root / name).unlink()\n"
"    for name in dirs:\n"
"        (root / name).rmdir()"
msgstr ""

msgid "Creating files and directories"
msgstr ""

msgid ""
"Create a file at this given path.  If *mode* is given, it is combined with "
"the process's ``umask`` value to determine the file mode and access flags.  "
"If the file already exists, the function succeeds when *exist_ok* is true "
"(and its modification time is updated to the current time), otherwise :exc:"
"`FileExistsError` is raised."
msgstr ""

msgid ""
"The :meth:`~Path.open`, :meth:`~Path.write_text` and :meth:`~Path."
"write_bytes` methods are often used to create files."
msgstr ""

msgid ""
"Create a new directory at this given path.  If *mode* is given, it is "
"combined with the process's ``umask`` value to determine the file mode and "
"access flags.  If the path already exists, :exc:`FileExistsError` is raised."
msgstr ""

msgid ""
"If *parents* is true, any missing parents of this path are created as "
"needed; they are created with the default permissions without taking *mode* "
"into account (mimicking the POSIX ``mkdir -p`` command)."
msgstr ""

msgid ""
"If *parents* is false (the default), a missing parent raises :exc:"
"`FileNotFoundError`."
msgstr ""

msgid ""
"If *exist_ok* is false (the default), :exc:`FileExistsError` is raised if "
"the target directory already exists."
msgstr ""

msgid ""
"If *exist_ok* is true, :exc:`FileExistsError` will not be raised unless the "
"given path already exists in the file system and is not a directory (same "
"behavior as the POSIX ``mkdir -p`` command)."
msgstr ""

msgid "The *exist_ok* parameter was added."
msgstr ""

msgid "Make this path a symbolic link pointing to *target*."
msgstr ""

msgid ""
"On Windows, a symlink represents either a file or a directory, and does not "
"morph to the target dynamically.  If the target is present, the type of the "
"symlink will be created to match. Otherwise, the symlink will be created as "
"a directory if *target_is_directory* is true or a file symlink (the default) "
"otherwise.  On non-Windows platforms, *target_is_directory* is ignored."
msgstr ""

msgid ""
">>> p = Path('mylink')\n"
">>> p.symlink_to('setup.py')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib/setup.py')\n"
">>> p.stat().st_size\n"
"956\n"
">>> p.lstat().st_size\n"
"8"
msgstr ""

msgid ""
"The order of arguments (link, target) is the reverse of :func:`os.symlink`'s."
msgstr ""

msgid ""
"Raises :exc:`UnsupportedOperation` if :func:`os.symlink` is not available. "
"In previous versions, :exc:`NotImplementedError` was raised."
msgstr ""

msgid "Make this path a hard link to the same file as *target*."
msgstr ""

msgid ""
"The order of arguments (link, target) is the reverse of :func:`os.link`'s."
msgstr ""

msgid ""
"Raises :exc:`UnsupportedOperation` if :func:`os.link` is not available. In "
"previous versions, :exc:`NotImplementedError` was raised."
msgstr ""

msgid "Copying, moving and deleting"
msgstr ""

msgid ""
"Copy this file or directory tree to the given *target*, and return a new :"
"class:`!Path` instance pointing to *target*."
msgstr ""

msgid ""
"If the source is a file, the target will be replaced if it is an existing "
"file. If the source is a symlink and *follow_symlinks* is true (the "
"default), the symlink's target is copied. Otherwise, the symlink is "
"recreated at the destination."
msgstr ""

msgid ""
"If *preserve_metadata* is false (the default), only directory structures and "
"file data are guaranteed to be copied. Set *preserve_metadata* to true to "
"ensure that file and directory permissions, flags, last access and "
"modification times, and extended attributes are copied where supported. This "
"argument has no effect when copying files on Windows (where metadata is "
"always preserved)."
msgstr ""

msgid ""
"Where supported by the operating system and file system, this method "
"performs a lightweight copy, where data blocks are only copied when "
"modified. This is known as copy-on-write."
msgstr ""

msgid ""
"Copy this file or directory tree into the given *target_dir*, which should "
"be an existing directory. Other arguments are handled identically to :meth:"
"`Path.copy`. Returns a new :class:`!Path` instance pointing to the copy."
msgstr ""

msgid ""
"Rename this file or directory to the given *target*, and return a new :class:"
"`!Path` instance pointing to *target*.  On Unix, if *target* exists and is a "
"file, it will be replaced silently if the user has permission. On Windows, "
"if *target* exists, :exc:`FileExistsError` will be raised. *target* can be "
"either a string or another path object::"
msgstr ""

msgid ""
">>> p = Path('foo')\n"
">>> p.open('w').write('some text')\n"
"9\n"
">>> target = Path('bar')\n"
">>> p.rename(target)\n"
"PosixPath('bar')\n"
">>> target.open().read()\n"
"'some text'"
msgstr ""

msgid ""
"The target path may be absolute or relative. Relative paths are interpreted "
"relative to the current working directory, *not* the directory of the :class:"
"`!Path` object."
msgstr ""

msgid ""
"It is implemented in terms of :func:`os.rename` and gives the same "
"guarantees."
msgstr ""

msgid "Added return value, return the new :class:`!Path` instance."
msgstr ""

msgid ""
"Rename this file or directory to the given *target*, and return a new :class:"
"`!Path` instance pointing to *target*.  If *target* points to an existing "
"file or empty directory, it will be unconditionally replaced."
msgstr ""

msgid ""
"Move this file or directory tree to the given *target*, and return a new :"
"class:`!Path` instance pointing to *target*."
msgstr ""

msgid ""
"If the *target* doesn't exist it will be created. If both this path and the "
"*target* are existing files, then the target is overwritten. If both paths "
"point to the same file or directory, or the *target* is a non-empty "
"directory, then :exc:`OSError` is raised."
msgstr ""

msgid ""
"If both paths are on the same filesystem, the move is performed with :func:"
"`os.replace`. Otherwise, this path is copied (preserving metadata and "
"symlinks) and then deleted."
msgstr ""

msgid ""
"Move this file or directory tree into the given *target_dir*, which should "
"be an existing directory. Returns a new :class:`!Path` instance pointing to "
"the moved path."
msgstr ""

msgid ""
"Remove this file or symbolic link.  If the path points to a directory, use :"
"func:`Path.rmdir` instead."
msgstr ""

msgid ""
"If *missing_ok* is false (the default), :exc:`FileNotFoundError` is raised "
"if the path does not exist."
msgstr ""

msgid ""
"If *missing_ok* is true, :exc:`FileNotFoundError` exceptions will be ignored "
"(same behavior as the POSIX ``rm -f`` command)."
msgstr ""

msgid "The *missing_ok* parameter was added."
msgstr ""

msgid "Remove this directory.  The directory must be empty."
msgstr ""

msgid "Permissions and ownership"
msgstr ""

msgid ""
"Return the name of the user owning the file. :exc:`KeyError` is raised if "
"the file's user identifier (UID) isn't found in the system database."
msgstr ""

msgid ""
"This method normally follows symlinks; to get the owner of the symlink, add "
"the argument ``follow_symlinks=False``."
msgstr ""

msgid ""
"Raises :exc:`UnsupportedOperation` if the :mod:`pwd` module is not "
"available. In earlier versions, :exc:`NotImplementedError` was raised."
msgstr ""

msgid ""
"Return the name of the group owning the file. :exc:`KeyError` is raised if "
"the file's group identifier (GID) isn't found in the system database."
msgstr ""

msgid ""
"This method normally follows symlinks; to get the group of the symlink, add "
"the argument ``follow_symlinks=False``."
msgstr ""

msgid ""
"Raises :exc:`UnsupportedOperation` if the :mod:`grp` module is not "
"available. In earlier versions, :exc:`NotImplementedError` was raised."
msgstr ""

msgid "Change the file mode and permissions, like :func:`os.chmod`."
msgstr ""

msgid ""
"This method normally follows symlinks. Some Unix flavours support changing "
"permissions on the symlink itself; on these platforms you may add the "
"argument ``follow_symlinks=False``, or use :meth:`~Path.lchmod`."
msgstr ""

msgid ""
">>> p = Path('setup.py')\n"
">>> p.stat().st_mode\n"
"33277\n"
">>> p.chmod(0o444)\n"
">>> p.stat().st_mode\n"
"33060"
msgstr ""

msgid ""
"Like :meth:`Path.chmod` but, if the path points to a symbolic link, the "
"symbolic link's mode is changed rather than its target's."
msgstr ""

msgid "Pattern language"
msgstr ""

msgid ""
"The following wildcards are supported in patterns for :meth:`~PurePath."
"full_match`, :meth:`~Path.glob` and :meth:`~Path.rglob`:"
msgstr ""

msgid "``**`` (entire segment)"
msgstr ""

msgid "Matches any number of file or directory segments, including zero."
msgstr ""

msgid "``*`` (entire segment)"
msgstr ""

msgid "Matches one file or directory segment."
msgstr ""

msgid "``*`` (part of a segment)"
msgstr ""

msgid "Matches any number of non-separator characters, including zero."
msgstr ""

msgid "``?``"
msgstr ""

msgid "Matches one non-separator character."
msgstr ""

msgid "``[seq]``"
msgstr ""

msgid ""
"Matches one character in *seq*, where *seq* is a sequence of characters. "
"Range expressions are supported; for example, ``[a-z]`` matches any "
"lowercase ASCII letter. Multiple ranges can be combined: ``[a-zA-Z0-9_]`` "
"matches any ASCII letter, digit, or underscore."
msgstr ""

msgid "``[!seq]``"
msgstr ""

msgid ""
"Matches one character not in *seq*, where *seq* follows the same rules as "
"above."
msgstr ""

msgid ""
"For a literal match, wrap the meta-characters in brackets. For example, "
"``\"[?]\"`` matches the character ``\"?\"``."
msgstr ""

msgid "The \"``**``\" wildcard enables recursive globbing. A few examples:"
msgstr ""

msgid "Pattern"
msgstr ""

msgid "Meaning"
msgstr ""

msgid "\"``**/*``\""
msgstr ""

msgid "Any path with at least one segment."
msgstr ""

msgid "\"``**/*.py``\""
msgstr ""

msgid "Any path with a final segment ending \"``.py``\"."
msgstr ""

msgid "\"``assets/**``\""
msgstr ""

msgid "Any path starting with \"``assets/``\"."
msgstr ""

msgid "\"``assets/**/*``\""
msgstr ""

msgid ""
"Any path starting with \"``assets/``\", excluding \"``assets/``\" itself."
msgstr ""

msgid ""
"Globbing with the \"``**``\" wildcard visits every directory in the tree. "
"Large directory trees may take a long time to search."
msgstr ""

msgid ""
"Globbing with a pattern that ends with \"``**``\" returns both files and "
"directories. In previous versions, only directories were returned."
msgstr ""

msgid ""
"In :meth:`Path.glob` and :meth:`~Path.rglob`, a trailing slash may be added "
"to the pattern to match only directories."
msgstr ""

msgid ""
"Globbing with a pattern that ends with a pathname components separator (:"
"data:`~os.sep` or :data:`~os.altsep`) returns only directories."
msgstr ""

msgid "Comparison to the :mod:`glob` module"
msgstr ""

msgid ""
"The patterns accepted and results generated by :meth:`Path.glob` and :meth:"
"`Path.rglob` differ slightly from those by the :mod:`glob` module:"
msgstr ""

msgid ""
"Files beginning with a dot are not special in pathlib. This is like passing "
"``include_hidden=True`` to :func:`glob.glob`."
msgstr ""

msgid ""
"\"``**``\" pattern components are always recursive in pathlib. This is like "
"passing ``recursive=True`` to :func:`glob.glob`."
msgstr ""

msgid ""
"\"``**``\" pattern components do not follow symlinks by default in pathlib. "
"This behaviour has no equivalent in :func:`glob.glob`, but you can pass "
"``recurse_symlinks=True`` to :meth:`Path.glob` for compatible behaviour."
msgstr ""

msgid ""
"Like all :class:`PurePath` and :class:`Path` objects, the values returned "
"from :meth:`Path.glob` and :meth:`Path.rglob` don't include trailing slashes."
msgstr ""

msgid ""
"The values returned from pathlib's ``path.glob()`` and ``path.rglob()`` "
"include the *path* as a prefix, unlike the results of ``glob."
"glob(root_dir=path)``."
msgstr ""

msgid ""
"The values returned from pathlib's ``path.glob()`` and ``path.rglob()`` may "
"include *path* itself, for example when globbing \"``**``\", whereas the "
"results of ``glob.glob(root_dir=path)`` never include an empty string that "
"would correspond to *path*."
msgstr ""

msgid "Comparison to the :mod:`os` and :mod:`os.path` modules"
msgstr ""

msgid ""
"pathlib implements path operations using :class:`PurePath` and :class:`Path` "
"objects, and so it's said to be *object-oriented*. On the other hand, the :"
"mod:`os` and :mod:`os.path` modules supply functions that work with low-"
"level ``str`` and ``bytes`` objects, which is a more *procedural* approach. "
"Some users consider the object-oriented style to be more readable."
msgstr ""

msgid ""
"Many functions in :mod:`os` and :mod:`os.path` support ``bytes`` paths and :"
"ref:`paths relative to directory descriptors <dir_fd>`. These features "
"aren't available in pathlib."
msgstr ""

msgid ""
"Python's ``str`` and ``bytes`` types, and portions of the :mod:`os` and :mod:"
"`os.path` modules, are written in C and are very speedy. pathlib is written "
"in pure Python and is often slower, but rarely slow enough to matter."
msgstr ""

msgid ""
"pathlib's path normalization is slightly more opinionated and consistent "
"than :mod:`os.path`. For example, whereas :func:`os.path.abspath` eliminates "
"\"``..``\" segments from a path, which may change its meaning if symlinks "
"are involved, :meth:`Path.absolute` preserves these segments for greater "
"safety."
msgstr ""

msgid ""
"pathlib's path normalization may render it unsuitable for some applications:"
msgstr ""

msgid ""
"pathlib normalizes ``Path(\"my_folder/\")`` to ``Path(\"my_folder\")``, "
"which changes a path's meaning when supplied to various operating system "
"APIs and command-line utilities. Specifically, the absence of a trailing "
"separator may allow the path to be resolved as either a file or directory, "
"rather than a directory only."
msgstr ""

msgid ""
"pathlib normalizes ``Path(\"./my_program\")`` to ``Path(\"my_program\")``, "
"which changes a path's meaning when used as an executable search path, such "
"as in a shell or when spawning a child process. Specifically, the absence of "
"a separator in the path may force it to be looked up in :envvar:`PATH` "
"rather than the current directory."
msgstr ""

msgid ""
"As a consequence of these differences, pathlib is not a drop-in replacement "
"for :mod:`os.path`."
msgstr ""

msgid "Corresponding tools"
msgstr ""

msgid ""
"Below is a table mapping various :mod:`os` functions to their corresponding :"
"class:`PurePath`/:class:`Path` equivalent."
msgstr ""

msgid ":mod:`os` and :mod:`os.path`"
msgstr ""

msgid ":mod:`pathlib`"
msgstr ""

msgid ":func:`os.path.dirname`"
msgstr ""

msgid ":attr:`PurePath.parent`"
msgstr ""

msgid ":func:`os.path.basename`"
msgstr ""

msgid ":attr:`PurePath.name`"
msgstr ""

msgid ":func:`os.path.splitext`"
msgstr ""

msgid ":attr:`PurePath.stem`, :attr:`PurePath.suffix`"
msgstr ""

msgid ":func:`os.path.join`"
msgstr ""

msgid ":meth:`PurePath.joinpath`"
msgstr ""

msgid ":func:`os.path.isabs`"
msgstr ""

msgid ":meth:`PurePath.is_absolute`"
msgstr ""

msgid ":func:`os.path.relpath`"
msgstr ""

msgid ":meth:`PurePath.relative_to` [1]_"
msgstr ""

msgid ":func:`os.path.expanduser`"
msgstr ""

msgid ":meth:`Path.expanduser` [2]_"
msgstr ""

msgid ":func:`os.path.realpath`"
msgstr ""

msgid ":meth:`Path.resolve`"
msgstr ""

msgid ":func:`os.path.abspath`"
msgstr ""

msgid ":meth:`Path.absolute` [3]_"
msgstr ""

msgid ":func:`os.path.exists`"
msgstr ""

msgid ":meth:`Path.exists`"
msgstr ""

msgid ":func:`os.path.isfile`"
msgstr ""

msgid ":meth:`Path.is_file`"
msgstr ""

msgid ":func:`os.path.isdir`"
msgstr ""

msgid ":meth:`Path.is_dir`"
msgstr ""

msgid ":func:`os.path.islink`"
msgstr ""

msgid ":meth:`Path.is_symlink`"
msgstr ""

msgid ":func:`os.path.isjunction`"
msgstr ""

msgid ":meth:`Path.is_junction`"
msgstr ""

msgid ":func:`os.path.ismount`"
msgstr ""

msgid ":meth:`Path.is_mount`"
msgstr ""

msgid ":func:`os.path.samefile`"
msgstr ""

msgid ":meth:`Path.samefile`"
msgstr ""

msgid ":func:`os.getcwd`"
msgstr ""

msgid ":meth:`Path.cwd`"
msgstr ""

msgid ":func:`os.stat`"
msgstr ""

msgid ":meth:`Path.stat`"
msgstr ""

msgid ":func:`os.lstat`"
msgstr ""

msgid ":meth:`Path.lstat`"
msgstr ""

msgid ":func:`os.listdir`"
msgstr ""

msgid ":meth:`Path.iterdir`"
msgstr ""

msgid ":func:`os.walk`"
msgstr ""

msgid ":meth:`Path.walk` [4]_"
msgstr ""

msgid ":func:`os.mkdir`, :func:`os.makedirs`"
msgstr ""

msgid ":meth:`Path.mkdir`"
msgstr ""

msgid ":func:`os.link`"
msgstr ""

msgid ":meth:`Path.hardlink_to`"
msgstr ""

msgid ":func:`os.symlink`"
msgstr ""

msgid ":meth:`Path.symlink_to`"
msgstr ""

msgid ":func:`os.readlink`"
msgstr ""

msgid ":meth:`Path.readlink`"
msgstr ""

msgid ":func:`os.rename`"
msgstr ""

msgid ":meth:`Path.rename`"
msgstr ""

msgid ":func:`os.replace`"
msgstr ""

msgid ":meth:`Path.replace`"
msgstr ""

msgid ":func:`os.remove`, :func:`os.unlink`"
msgstr ""

msgid ":meth:`Path.unlink`"
msgstr ""

msgid ":func:`os.rmdir`"
msgstr ""

msgid ":meth:`Path.rmdir`"
msgstr ""

msgid ":func:`os.chmod`"
msgstr ""

msgid ":meth:`Path.chmod`"
msgstr ""

msgid ":func:`os.lchmod`"
msgstr ""

msgid ":meth:`Path.lchmod`"
msgstr ""

msgid "Footnotes"
msgstr ""

msgid ""
":func:`os.path.relpath` calls :func:`~os.path.abspath` to make paths "
"absolute and remove \"``..``\" parts, whereas :meth:`PurePath.relative_to` "
"is a lexical operation that raises :exc:`ValueError` when its inputs' "
"anchors differ (e.g. if one path is absolute and the other relative.)"
msgstr ""

msgid ""
":func:`os.path.expanduser` returns the path unchanged if the home directory "
"can't be resolved, whereas :meth:`Path.expanduser` raises :exc:"
"`RuntimeError`."
msgstr ""

msgid ""
":func:`os.path.abspath` removes \"``..``\" components without resolving "
"symlinks, which may change the meaning of the path, whereas :meth:`Path."
"absolute` leaves any \"``..``\" components in the path."
msgstr ""

msgid ""
":func:`os.walk` always follows symlinks when categorizing paths into "
"*dirnames* and *filenames*, whereas :meth:`Path.walk` categorizes all "
"symlinks into *filenames* when *follow_symlinks* is false (the default.)"
msgstr ""

msgid "Protocols"
msgstr ""

msgid ""
"The :mod:`pathlib.types` module provides types for static type checking."
msgstr ""

msgid ""
"A :class:`typing.Protocol` describing the :attr:`Path.info <pathlib.Path."
"info>` attribute. Implementations may return cached results from their "
"methods."
msgstr ""

msgid ""
"Return ``True`` if the path is an existing file or directory, or any other "
"kind of file; return ``False`` if the path doesn't exist."
msgstr ""

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` for symlinks without "
"checking if their targets exist."
msgstr ""

msgid ""
"Return ``True`` if the path is a directory, or a symbolic link pointing to a "
"directory; return ``False`` if the path is (or points to) any other kind of "
"file, or if it doesn't exist."
msgstr ""

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if the path is a "
"directory (without following symlinks); return ``False`` if the path is any "
"other kind of file, or if it doesn't exist."
msgstr ""

msgid ""
"Return ``True`` if the path is a file, or a symbolic link pointing to a "
"file; return ``False`` if the path is (or points to) a directory or other "
"non-file, or if it doesn't exist."
msgstr ""

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if the path is a "
"file (without following symlinks); return ``False`` if the path is a "
"directory or other non-file, or if it doesn't exist."
msgstr ""

msgid ""
"Return ``True`` if the path is a symbolic link (even if broken); return "
"``False`` if the path is a directory or any kind of file, or if it doesn't "
"exist."
msgstr ""

msgid "path"
msgstr ""

msgid "operations"
msgstr ""
