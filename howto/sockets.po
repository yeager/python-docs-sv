# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Socket Programming HOWTO"
msgstr "HOWTO för programmering av socket"

msgid "Author"
msgstr "Författare"

msgid "Gordon McMillan"
msgstr "Gordon McMillan"

msgid "Abstract"
msgstr "Abstrakt"

msgid ""
"Sockets are used nearly everywhere, but are one of the most severely "
"misunderstood technologies around. This is a 10,000 foot overview of "
"sockets. It's not really a tutorial - you'll still have work to do in "
"getting things operational. It doesn't cover the fine points (and there are "
"a lot of them), but I hope it will give you enough background to begin using "
"them decently."
msgstr ""
"Socklar används nästan överallt, men är en av de mest missförstådda "
"teknikerna som finns. Detta är en 10 000 fot översikt över socklar. Det är "
"inte riktigt en handledning - du kommer fortfarande att ha arbete att göra "
"för att få saker att fungera. Det täcker inte de fina punkterna (och det "
"finns många av dem), men jag hoppas att det kommer att ge dig tillräckligt "
"med bakgrund för att börja använda dem anständigt."

msgid "Sockets"
msgstr "Uttag"

msgid ""
"I'm only going to talk about INET (i.e. IPv4) sockets, but they account for "
"at least 99% of the sockets in use. And I'll only talk about STREAM (i.e. "
"TCP) sockets - unless you really know what you're doing (in which case this "
"HOWTO isn't for you!), you'll get better behavior and performance from a "
"STREAM socket than anything else. I will try to clear up the mystery of what "
"a socket is, as well as some hints on how to work with blocking and non-"
"blocking sockets. But I'll start by talking about blocking sockets. You'll "
"need to know how they work before dealing with non-blocking sockets."
msgstr ""
"Jag kommer bara att prata om INET-socket (dvs. IPv4), men de står för minst "
"99% of av de socket som används. Och jag kommer bara att prata om STREAM-"
"socket (dvs. TCP) - såvida du inte verkligen vet vad du gör (i vilket fall "
"denna HOWTO inte är för dig!), Kommer du att få bättre beteende och "
"prestanda från ett STREAM-socket än något annat. Jag ska försöka reda ut "
"mysteriet med vad en socket är, samt ge några tips om hur man arbetar med "
"blockerande och icke-blockerande sockets. Men jag börjar med att prata om "
"blockerande socklar. Du måste veta hur de fungerar innan du kan ta itu med "
"icke-blockerande socklar."

msgid ""
"Part of the trouble with understanding these things is that \"socket\" can "
"mean a number of subtly different things, depending on context. So first, "
"let's make a distinction between a \"client\" socket - an endpoint of a "
"conversation, and a \"server\" socket, which is more like a switchboard "
"operator. The client application (your browser, for example) uses \"client\" "
"sockets exclusively; the web server it's talking to uses both \"server\" "
"sockets and \"client\" sockets."
msgstr ""
"En del av problemet med att förstå dessa saker är att \"socket\" kan betyda "
"ett antal subtilt olika saker, beroende på sammanhang. Så låt oss först "
"skilja mellan ett \"klient\" -socket - en slutpunkt för en konversation och "
"ett \"server\" -socket, som är mer som en växeloperator. Klientapplikationen "
"(till exempel din webbläsare) använder uteslutande \"klient\" -socket; "
"webbservern som den pratar med använder både \"server\" -socket och "
"\"klient\" -socket."

msgid "History"
msgstr "Historik"

msgid ""
"Of the various forms of :abbr:`IPC (Inter Process Communication)`, sockets "
"are by far the most popular.  On any given platform, there are likely to be "
"other forms of IPC that are faster, but for cross-platform communication, "
"sockets are about the only game in town."
msgstr ""
"Av de olika formerna av :abbr:`IPC (Inter Process Communication)` är sockets "
"de överlägset mest populära.  På en viss plattform finns det sannolikt andra "
"former av IPC som är snabbare, men för plattformsoberoende kommunikation är "
"sockets i stort sett det enda som gäller."

msgid ""
"They were invented in Berkeley as part of the BSD flavor of Unix. They "
"spread like wildfire with the internet. With good reason --- the combination "
"of sockets with INET makes talking to arbitrary machines around the world "
"unbelievably easy (at least compared to other schemes)."
msgstr ""
"De uppfanns i Berkeley som en del av BSD-varianten av Unix. De spred sig som "
"en löpeld med internet. Med goda skäl --- kombinationen av sockets med INET "
"gör det otroligt enkelt att prata med godtyckliga maskiner runt om i världen "
"(åtminstone jämfört med andra system)."

msgid "Creating a Socket"
msgstr "Skapa en socket"

msgid ""
"Roughly speaking, when you clicked on the link that brought you to this "
"page, your browser did something like the following::"
msgstr ""
"När du klickade på länken som förde dig till den här sidan gjorde din "
"webbläsare ungefär följande::"

msgid ""
"# create an INET, STREAMing socket\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# now connect to the web server on port 80 - the normal http port\n"
"s.connect((\"www.python.org\", 80))"
msgstr ""
"# skapa ett INET, STREAMing-socket\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# anslut nu till webbservern på port 80 - den normala http-porten\n"
"s.connect((\"www.python.org\", 80))"

msgid ""
"When the ``connect`` completes, the socket ``s`` can be used to send in a "
"request for the text of the page. The same socket will read the reply, and "
"then be destroyed. That's right, destroyed. Client sockets are normally only "
"used for one exchange (or a small set of sequential exchanges)."
msgstr ""
"När ``connect`` är klar kan sockeln ``s`` användas för att skicka en begäran "
"om texten på sidan. Samma socket kommer att läsa svaret och sedan förstöras. "
"Just det, förstörs. Klientsocklar används normalt bara för ett utbyte (eller "
"en liten uppsättning sekventiella utbyten)."

msgid ""
"What happens in the web server is a bit more complex. First, the web server "
"creates a \"server socket\"::"
msgstr ""
"Vad som händer i webbservern är lite mer komplicerat. Först skapar "
"webbservern ett \"serversocket\"::"

msgid ""
"# create an INET, STREAMing socket\n"
"serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# bind the socket to a public host, and a well-known port\n"
"serversocket.bind((socket.gethostname(), 80))\n"
"# become a server socket\n"
"serversocket.listen(5)"
msgstr ""
"# skapa ett INET, STREAMing-socket\n"
"serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# binda socketet till en offentlig värd och en välkänd port\n"
"serversocket.bind((socket.gethostname(), 80))\n"
"# bli ett serversocket\n"
"serversocket.lyssna(5)"

msgid ""
"A couple things to notice: we used ``socket.gethostname()`` so that the "
"socket would be visible to the outside world.  If we had used ``s."
"bind(('localhost', 80))`` or ``s.bind(('127.0.0.1', 80))`` we would still "
"have a \"server\" socket, but one that was only visible within the same "
"machine.  ``s.bind(('', 80))`` specifies that the socket is reachable by any "
"address the machine happens to have."
msgstr ""
"Ett par saker att notera: vi använde ``socket.gethostname()`` så att "
"socketet skulle vara synligt för omvärlden.  Om vi hade använt ``s."
"bind(('localhost', 80))`` eller ``s.bind(('127.0.0.1', 80))`` skulle vi "
"fortfarande ha ett \"server\"-socket, men ett som bara var synligt inom "
"samma maskin.  ``s.bind(('', 80))`` anger att socketet är nåbart med vilken "
"adress som helst som maskinen råkar ha."

msgid ""
"A second thing to note: low number ports are usually reserved for \"well "
"known\" services (HTTP, SNMP etc). If you're playing around, use a nice high "
"number (4 digits)."
msgstr ""
"En annan sak att notera: portar med låga nummer är vanligtvis reserverade "
"för \"välkända\" tjänster (HTTP, SNMP etc). Om du vill leka lite, använd ett "
"högt nummer (4 siffror)."

msgid ""
"Finally, the argument to ``listen`` tells the socket library that we want it "
"to queue up as many as 5 connect requests (the normal max) before refusing "
"outside connections. If the rest of the code is written properly, that "
"should be plenty."
msgstr ""
"Slutligen talar argumentet till ``listen`` om för socket-biblioteket att vi "
"vill att det ska köa upp till 5 anslutningsbegäranden (det normala "
"maxantalet) innan det nekar anslutningar utifrån. Om resten av koden är "
"korrekt skriven borde det räcka."

msgid ""
"Now that we have a \"server\" socket, listening on port 80, we can enter the "
"mainloop of the web server::"
msgstr ""
"Nu när vi har ett \"server\"-socket som lyssnar på port 80 kan vi gå in i "
"webbserverns huvudloop::"

msgid ""
"while True:\n"
"    # accept connections from outside\n"
"    (clientsocket, address) = serversocket.accept()\n"
"    # now do something with the clientsocket\n"
"    # in this case, we'll pretend this is a threaded server\n"
"    ct = make_client_thread(clientsocket)\n"
"    ct.start()"
msgstr ""
"while True:\n"
"    # accept connections from outside\n"
"    (clientsocket, address) = serversocket.accept()\n"
"    # now do something with the clientsocket\n"
"    # in this case, we'll pretend this is a threaded server\n"
"    ct = make_client_thread(clientsocket)\n"
"    ct.start()"

msgid ""
"There's actually 3 general ways in which this loop could work - dispatching "
"a thread to handle ``clientsocket``, create a new process to handle "
"``clientsocket``, or restructure this app to use non-blocking sockets, and "
"multiplex between our \"server\" socket and any active ``clientsocket``\\ s "
"using ``select``. More about that later. The important thing to understand "
"now is this: this is *all* a \"server\" socket does. It doesn't send any "
"data. It doesn't receive any data. It just produces \"client\" sockets. Each "
"``clientsocket`` is created in response to some *other* \"client\" socket "
"doing a ``connect()`` to the host and port we're bound to. As soon as we've "
"created that ``clientsocket``, we go back to listening for more connections. "
"The two \"clients\" are free to chat it up - they are using some dynamically "
"allocated port which will be recycled when the conversation ends."
msgstr ""
"Det finns faktiskt tre allmänna sätt på vilka den här slingan kan fungera - "
"skicka en tråd för att hantera ``clientsocket``, skapa en ny process för att "
"hantera ``clientsocket``, eller omstrukturera den här appen för att använda "
"icke-blockerande socket och multiplexera mellan vårt \"server\" -socket och "
"alla aktiva ``clientsocket`` med ``select``. Mer om det senare. Det viktiga "
"att förstå nu är detta: det här är * allt * ett \"server\" -socket gör. Den "
"skickar inte någon data. Den tar inte emot några data. Den producerar bara "
"\"klient\"-socket. Varje ``clientsocket`` skapas som svar på att någon "
"*annan* \"client\" socket gör en ``connect()`` till den host och port vi är "
"bundna till. Så snart vi har skapat det ``clientsocket``, går vi tillbaka "
"till att lyssna efter fler anslutningar. De två \"klienterna\" är fria att "
"chatta - de använder en dynamiskt allokerad port som kommer att återvinnas "
"när konversationen avslutas."

msgid "IPC"
msgstr "IPC"

msgid ""
"If you need fast IPC between two processes on one machine, you should look "
"into pipes or shared memory.  If you do decide to use AF_INET sockets, bind "
"the \"server\" socket to ``'localhost'``. On most platforms, this will take "
"a shortcut around a couple of layers of network code and be quite a bit "
"faster."
msgstr ""
"Om du behöver snabb IPC mellan två processer på en maskin bör du titta på "
"pipes eller delat minne.  Om du bestämmer dig för att använda AF_INET-"
"sockets, bind \"server\"-socketen till ``'localhost``. På de flesta "
"plattformar kommer detta att ta en genväg runt ett par lager av nätverkskod "
"och vara ganska mycket snabbare."

msgid ""
"The :mod:`multiprocessing` integrates cross-platform IPC into a higher-level "
"API."
msgstr ""
":mod:`multiprocessing` integrerar plattformsoberoende IPC i ett API på högre "
"nivå."

msgid "Using a Socket"
msgstr "Använda ett socket"

msgid ""
"The first thing to note, is that the web browser's \"client\" socket and the "
"web server's \"client\" socket are identical beasts. That is, this is a "
"\"peer to peer\" conversation. Or to put it another way, *as the designer, "
"you will have to decide what the rules of etiquette are for a conversation*. "
"Normally, the ``connect``\\ ing socket starts the conversation, by sending "
"in a request, or perhaps a signon. But that's a design decision - it's not a "
"rule of sockets."
msgstr ""
"Det första man bör notera är att webbläsarens \"klient\"-socket och "
"webbserverns \"klient\"-socket är identiska. Det vill säga, det här är en "
"\"peer to peer\"-konversation. Eller för att uttrycka det på ett annat sätt, "
"*som designer måste du bestämma vilka etikettregler som gäller för en "
"konversation*. Normalt startar ``connect`` ing-socketet konversationen genom "
"att skicka in en begäran eller kanske en signon. Men det är ett designbeslut "
"- det är inte en regel för sockets."

msgid ""
"Now there are two sets of verbs to use for communication. You can use "
"``send`` and ``recv``, or you can transform your client socket into a file-"
"like beast and use ``read`` and ``write``. The latter is the way Java "
"presents its sockets. I'm not going to talk about it here, except to warn "
"you that you need to use ``flush`` on sockets. These are buffered \"files\", "
"and a common mistake is to ``write`` something, and then ``read`` for a "
"reply. Without a ``flush`` in there, you may wait forever for the reply, "
"because the request may still be in your output buffer."
msgstr ""
"Nu finns det två uppsättningar verb att använda för kommunikation. Du kan "
"använda ```end`` och ``recv``, eller så kan du omvandla din klientsocket "
"till ett filliknande djur och använda ``read`` och ``write``. Det senare är "
"det sätt som Java presenterar sina socket. Jag kommer inte att prata om det "
"här, förutom att varna dig för att du måste använda ``flush`` på sockets. "
"Dessa är buffrade \"filer\", och ett vanligt misstag är att ``skriva`` "
"något, och sedan ``läsa`` för ett svar. Utan en ``flush`` där kan du vänta "
"för evigt på svaret, eftersom begäran fortfarande kan finnas i din "
"utmatningsbuffert."

msgid ""
"Now we come to the major stumbling block of sockets - ``send`` and ``recv`` "
"operate on the network buffers. They do not necessarily handle all the bytes "
"you hand them (or expect from them), because their major focus is handling "
"the network buffers. In general, they return when the associated network "
"buffers have been filled (``send``) or emptied (``recv``). They then tell "
"you how many bytes they handled. It is *your* responsibility to call them "
"again until your message has been completely dealt with."
msgstr ""
"Nu kommer vi till den stora stötestenen för sockets - ``end`` och ``recv`` "
"arbetar med nätverksbuffertarna. De hanterar inte nödvändigtvis alla bytes "
"du ger dem (eller förväntar dig av dem), eftersom deras huvudfokus är att "
"hantera nätverksbuffertarna. I allmänhet återkommer de när de associerade "
"nätverksbuffertarna har fyllts (``end``) eller tömts (``recv``). De berättar "
"sedan hur många byte de hanterade. Det är *ditt* ansvar att anropa dem igen "
"tills ditt meddelande har behandlats fullständigt."

msgid ""
"When a ``recv`` returns 0 bytes, it means the other side has closed (or is "
"in the process of closing) the connection.  You will not receive any more "
"data on this connection. Ever.  You may be able to send data successfully; "
"I'll talk more about this later."
msgstr ""
"När en ``recv`` returnerar 0 byte betyder det att den andra sidan har stängt "
"(eller håller på att stänga) anslutningen.  Du kommer inte att få några fler "
"data på den här anslutningen. Alltid.  Du kanske kan skicka data "
"framgångsrikt; jag kommer att prata mer om detta senare."

msgid ""
"A protocol like HTTP uses a socket for only one transfer. The client sends a "
"request, then reads a reply.  That's it. The socket is discarded. This means "
"that a client can detect the end of the reply by receiving 0 bytes."
msgstr ""
"Ett protokoll som HTTP använder en socket för endast en överföring. Klienten "
"skickar en begäran och läser sedan ett svar.  Sedan är det slut. Uttaget "
"kasseras. Detta innebär att en klient kan upptäcka slutet på svaret genom "
"att ta emot 0 byte."

msgid ""
"But if you plan to reuse your socket for further transfers, you need to "
"realize that *there is no* :abbr:`EOT (End of Transfer)` *on a socket.* I "
"repeat: if a socket ``send`` or ``recv`` returns after handling 0 bytes, the "
"connection has been broken.  If the connection has *not* been broken, you "
"may wait on a ``recv`` forever, because the socket will *not* tell you that "
"there's nothing more to read (for now).  Now if you think about that a bit, "
"you'll come to realize a fundamental truth of sockets: *messages must either "
"be fixed length* (yuck), *or be delimited* (shrug), *or indicate how long "
"they are* (much better), *or end by shutting down the connection*. The "
"choice is entirely yours, (but some ways are righter than others)."
msgstr ""
"Men om du planerar att återanvända din socket för ytterligare överföringar "
"måste du inse att *det inte finns någon* :abbr:`EOT (End of Transfer)` *på "
"en socket.* Jag upprepar: om en socket ``send`` eller ``recv`` returnerar "
"efter att ha hanterat 0 byte har anslutningen brutits.  Om anslutningen "
"*inte* har brutits kan du vänta på en ``recv`` för alltid, eftersom socketet "
"*inte* kommer att berätta att det inte finns något mer att läsa (för "
"tillfället).  Om du nu tänker lite på det kommer du att inse en "
"grundläggande sanning om socket: *meddelanden måste antingen ha en fast "
"längd* (usch), *eller vara avgränsade* (axelryckning), *eller ange hur långa "
"de är* (mycket bättre), *eller avslutas med att anslutningen stängs*. Valet "
"är helt och hållet ditt, (men vissa sätt är mer rätt än andra)."

msgid ""
"Assuming you don't want to end the connection, the simplest solution is a "
"fixed length message::"
msgstr ""
"Förutsatt att du inte vill avsluta anslutningen är den enklaste lösningen "
"ett meddelande med fast längd::"

msgid ""
"class MySocket:\n"
"    \"\"\"demonstration class only\n"
"      - coded for clarity, not efficiency\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, sock=None):\n"
"        if sock is None:\n"
"            self.sock = socket.socket(\n"
"                            socket.AF_INET, socket.SOCK_STREAM)\n"
"        else:\n"
"            self.sock = sock\n"
"\n"
"    def connect(self, host, port):\n"
"        self.sock.connect((host, port))\n"
"\n"
"    def mysend(self, msg):\n"
"        totalsent = 0\n"
"        while totalsent < MSGLEN:\n"
"            sent = self.sock.send(msg[totalsent:])\n"
"            if sent == 0:\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            totalsent = totalsent + sent\n"
"\n"
"    def myreceive(self):\n"
"        chunks = []\n"
"        bytes_recd = 0\n"
"        while bytes_recd < MSGLEN:\n"
"            chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))\n"
"            if chunk == b'':\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            chunks.append(chunk)\n"
"            bytes_recd = bytes_recd + len(chunk)\n"
"        return b''.join(chunks)"
msgstr ""
"class MySocket:\n"
"    \"\"\"demonstration class only\n"
"      - coded for clarity, not efficiency\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, sock=None):\n"
"        if sock is None:\n"
"            self.sock = socket.socket(\n"
"                            socket.AF_INET, socket.SOCK_STREAM)\n"
"        else:\n"
"            self.sock = sock\n"
"\n"
"    def connect(self, host, port):\n"
"        self.sock.connect((host, port))\n"
"\n"
"    def mysend(self, msg):\n"
"        totalsent = 0\n"
"        while totalsent < MSGLEN:\n"
"            sent = self.sock.send(msg[totalsent:])\n"
"            if sent == 0:\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            totalsent = totalsent + sent\n"
"\n"
"    def myreceive(self):\n"
"        chunks = []\n"
"        bytes_recd = 0\n"
"        while bytes_recd < MSGLEN:\n"
"            chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))\n"
"            if chunk == b'':\n"
"                raise RuntimeError(\"socket connection broken\")\n"
"            chunks.append(chunk)\n"
"            bytes_recd = bytes_recd + len(chunk)\n"
"        return b''.join(chunks)"

msgid ""
"The sending code here is usable for almost any messaging scheme - in Python "
"you send strings, and you can use ``len()`` to determine its length (even if "
"it has embedded ``\\0`` characters). It's mostly the receiving code that "
"gets more complex. (And in C, it's not much worse, except you can't use "
"``strlen`` if the message has embedded ``\\0``\\ s.)"
msgstr ""
"Sändningskoden här är användbar för nästan alla meddelandesystem - i Python "
"skickar du strängar, och du kan använda ``len()`` för att bestämma dess "
"längd (även om den har inbäddade ``\\0``-tecken). Det är mest den mottagande "
"koden som blir mer komplex. (Och i C är det inte mycket värre, förutom att "
"du inte kan använda ``strlen`` om meddelandet har inbäddade ``0`` s.)"

msgid ""
"The easiest enhancement is to make the first character of the message an "
"indicator of message type, and have the type determine the length. Now you "
"have two ``recv``\\ s - the first to get (at least) that first character so "
"you can look up the length, and the second in a loop to get the rest. If you "
"decide to go the delimited route, you'll be receiving in some arbitrary "
"chunk size, (4096 or 8192 is frequently a good match for network buffer "
"sizes), and scanning what you've received for a delimiter."
msgstr ""
"Den enklaste förbättringen är att göra det första tecknet i meddelandet till "
"en indikator på meddelandetyp och låta typen bestämma längden. Nu har du två "
"``recv`` - den första för att få (åtminstone) det första tecknet så att du "
"kan slå upp längden, och den andra i en slinga för att få resten. Om du "
"väljer den avgränsade vägen tar du emot i någon godtycklig storlek (4096 "
"eller 8192 är ofta en bra matchning för nätverkets buffertstorlekar) och "
"skannar det du har fått efter en avgränsare."

msgid ""
"One complication to be aware of: if your conversational protocol allows "
"multiple messages to be sent back to back (without some kind of reply), and "
"you pass ``recv`` an arbitrary chunk size, you may end up reading the start "
"of a following message. You'll need to put that aside and hold onto it, "
"until it's needed."
msgstr ""
"En komplikation att vara medveten om: om ditt konversationsprotokoll "
"tillåter att flera meddelanden skickas rygg mot rygg (utan någon form av "
"svar), och du skickar ``recv`` en godtycklig bitstorlek, kan det hända att "
"du läser början på ett följande meddelande. Du måste lägga det åt sidan och "
"hålla fast vid det tills det behövs."

msgid ""
"Prefixing the message with its length (say, as 5 numeric characters) gets "
"more complex, because (believe it or not), you may not get all 5 characters "
"in one ``recv``. In playing around, you'll get away with it; but in high "
"network loads, your code will very quickly break unless you use two ``recv`` "
"loops - the first to determine the length, the second to get the data part "
"of the message. Nasty. This is also when you'll discover that ``send`` does "
"not always manage to get rid of everything in one pass. And despite having "
"read this, you will eventually get bit by it!"
msgstr ""
"Att prefixa meddelandet med dess längd (säg, som 5 numeriska tecken) blir "
"mer komplext, för (tro det eller ej), du kanske inte får alla 5 tecken i en "
"``recv``. När du leker kommer du undan med det; men i höga "
"nätverksbelastningar kommer din kod mycket snabbt att brytas om du inte "
"använder två ``recv``-loopar - den första för att bestämma längden, den "
"andra för att få datadelen av meddelandet. Otäckt. Det är också då du "
"upptäcker att ``end`` inte alltid lyckas bli av med allt i ett svep. Och "
"trots att du har läst detta kommer du så småningom att bli biten av det!"

msgid ""
"In the interests of space, building your character, (and preserving my "
"competitive position), these enhancements are left as an exercise for the "
"reader. Lets move on to cleaning up."
msgstr ""
"Av utrymmesskäl, för att bygga upp din karaktär (och för att bevara min "
"konkurrensposition) lämnas dessa förbättringar som en övning för läsaren. "
"Låt oss gå vidare till att städa upp."

msgid "Binary Data"
msgstr "Binär data"

msgid ""
"It is perfectly possible to send binary data over a socket. The major "
"problem is that not all machines use the same formats for binary data. For "
"example, `network byte order <https://en.wikipedia.org/wiki/"
"Endianness#Networking>`_ is big-endian, with the most significant byte "
"first, so a 16 bit integer with the value ``1`` would be the two hex bytes "
"``00 01``. However, most common processors (x86/AMD64, ARM, RISC-V), are "
"little-endian, with the least significant byte first - that same ``1`` would "
"be ``01 00``."
msgstr ""
"Det är fullt möjligt att skicka binära data via en socket. Det stora "
"problemet är att inte alla maskiner använder samma format för binära data. "
"Till exempel är \"byteordning i nätverk <https://en.wikipedia.org/wiki/"
"Endianness#Networking>`_ big-endian, med den mest signifikanta byten först, "
"så ett 16-bitars heltal med värdet \"1\" skulle vara de två hexbytena \"00 "
"01\". De flesta vanliga processorer (x86/AMD64, ARM, RISC-V) är dock little-"
"endian, med den minst signifikanta byten först - samma ``1`` skulle vara "
"``01 00``."

msgid ""
"Socket libraries have calls for converting 16 and 32 bit integers - ``ntohl, "
"htonl, ntohs, htons`` where \"n\" means *network* and \"h\" means *host*, "
"\"s\" means *short* and \"l\" means *long*. Where network order is host "
"order, these do nothing, but where the machine is byte-reversed, these swap "
"the bytes around appropriately."
msgstr ""
"Socket-bibliotek har anrop för att konvertera 16- och 32-bitars heltal - "
"``ntohl, htonl, ntohs, htons`` där \"n\" betyder *nätverk* och \"h\" betyder "
"*värd*, \"s\" betyder *kort* och \"l\" betyder *lång*. Om nätverksordningen "
"är värdordningen gör dessa ingenting, men om maskinen är byte-reverserad "
"byter dessa byte på lämpligt sätt."

msgid ""
"In these days of 64-bit machines, the ASCII representation of binary data is "
"frequently smaller than the binary representation. That's because a "
"surprising amount of the time, most integers have the value 0, or maybe 1. "
"The string ``\"0\"`` would be two bytes, while a full 64-bit integer would "
"be 8. Of course, this doesn't fit well with fixed-length messages. "
"Decisions, decisions."
msgstr ""
"I dessa dagar med 64-bitars maskiner är ASCII-representationen av binära "
"data ofta mindre än den binära representationen. Det beror på att de flesta "
"heltal förvånansvärt ofta har värdet 0, eller kanske 1. Strängen ``\"0\"`` "
"skulle vara två byte, medan ett helt 64-bitars heltal skulle vara 8. "
"Naturligtvis passar detta inte bra med meddelanden med fast längd. Beslut, "
"beslut."

msgid "Disconnecting"
msgstr "Kopplar bort"

msgid ""
"Strictly speaking, you're supposed to use ``shutdown`` on a socket before "
"you ``close`` it.  The ``shutdown`` is an advisory to the socket at the "
"other end. Depending on the argument you pass it, it can mean \"I'm not "
"going to send anymore, but I'll still listen\", or \"I'm not listening, good "
"riddance!\".  Most socket libraries, however, are so used to programmers "
"neglecting to use this piece of etiquette that normally a ``close`` is the "
"same as ``shutdown(); close()``.  So in most situations, an explicit "
"``shutdown`` is not needed."
msgstr ""
"Strängt taget är det meningen att du ska använda ``shutdown`` på ett socket "
"innan du ``stänger`` det.  ``shutdown`` är ett råd till socketet i andra "
"änden. Beroende på vilket argument du ger det kan det betyda \"Jag tänker "
"inte skicka mer, men jag lyssnar fortfarande\", eller \"Jag lyssnar inte, "
"bra att slippa!\".  De flesta socket-bibliotek är dock så vana vid att "
"programmerare struntar i att använda denna etikett att en ``close`` normalt "
"är detsamma som ``shutdown(); close()``.  Så i de flesta situationer behövs "
"inte en explicit ``shutdown``."

msgid ""
"One way to use ``shutdown`` effectively is in an HTTP-like exchange. The "
"client sends a request and then does a ``shutdown(1)``. This tells the "
"server \"This client is done sending, but can still receive.\"  The server "
"can detect \"EOF\" by a receive of 0 bytes. It can assume it has the "
"complete request.  The server sends a reply. If the ``send`` completes "
"successfully then, indeed, the client was still receiving."
msgstr ""
"Ett sätt att använda ``shutdown`` effektivt är i en HTTP-liknande utväxling. "
"Klienten skickar en begäran och gör sedan en ``shutdown(1)``. Detta säger "
"till servern \"Den här klienten är klar med att skicka, men kan fortfarande "
"ta emot.\"  Servern kan upptäcka \"EOF\" genom en mottagning av 0 byte. Den "
"kan anta att den har hela begäran.  Servern skickar ett svar. Om ``send`` "
"avslutas framgångsrikt så var klienten faktiskt fortfarande mottagande."

msgid ""
"Python takes the automatic shutdown a step further, and says that when a "
"socket is garbage collected, it will automatically do a ``close`` if it's "
"needed. But relying on this is a very bad habit. If your socket just "
"disappears without doing a ``close``, the socket at the other end may hang "
"indefinitely, thinking you're just being slow. *Please* ``close`` your "
"sockets when you're done."
msgstr ""
"Python tar den automatiska avstängningen ett steg längre och säger att när "
"ett socket är garbage collected, kommer det automatiskt att göra en "
"``close`` om det behövs. Men att förlita sig på detta är en mycket dålig "
"vana. Om ditt socket bara försvinner utan att göra en ``close``, kan "
"socketet i andra änden hänga på obestämd tid och tro att du bara är långsam. "
"*Snälla* ``close`` dina socket när du är klar."

msgid "When Sockets Die"
msgstr "När socklar dör"

msgid ""
"Probably the worst thing about using blocking sockets is what happens when "
"the other side comes down hard (without doing a ``close``). Your socket is "
"likely to hang. TCP is a reliable protocol, and it will wait a long, long "
"time before giving up on a connection. If you're using threads, the entire "
"thread is essentially dead. There's not much you can do about it. As long as "
"you aren't doing something dumb, like holding a lock while doing a blocking "
"read, the thread isn't really consuming much in the way of resources. Do "
"*not* try to kill the thread - part of the reason that threads are more "
"efficient than processes is that they avoid the overhead associated with the "
"automatic recycling of resources. In other words, if you do manage to kill "
"the thread, your whole process is likely to be screwed up."
msgstr ""
"Det värsta med att använda blockerande socklar är förmodligen vad som händer "
"när den andra sidan går ner hårt (utan att göra en ``close``). Ditt socket "
"kommer sannolikt att hänga. TCP är ett pålitligt protokoll, och det kommer "
"att vänta länge, länge innan det ger upp en anslutning. Om du använder "
"trådar är hela tråden i princip död. Det finns inte mycket du kan göra åt "
"det. Så länge du inte gör något dumt, som att hålla ett lås medan du gör en "
"blockerande läsning, förbrukar tråden egentligen inte mycket resurser. "
"Försök *inte* att döda tråden - en del av anledningen till att trådar är mer "
"effektiva än processer är att de undviker den overhead som är förknippad med "
"automatisk återvinning av resurser. Med andra ord, om du lyckas döda tråden "
"är det troligt att hela din process kommer att gå åt skogen."

msgid "Non-blocking Sockets"
msgstr "Icke-blockerande socklar"

msgid ""
"If you've understood the preceding, you already know most of what you need "
"to know about the mechanics of using sockets. You'll still use the same "
"calls, in much the same ways. It's just that, if you do it right, your app "
"will be almost inside-out."
msgstr ""
"Om du har förstått det föregående vet du redan det mesta du behöver veta om "
"hur man använder sockets. Du kommer fortfarande att använda samma samtal, på "
"ungefär samma sätt. Det är bara det att om du gör det rätt kommer din app "
"att vara nästan inifrån och ut."

msgid ""
"In Python, you use ``socket.setblocking(False)`` to make it non-blocking. In "
"C, it's more complex, (for one thing, you'll need to choose between the BSD "
"flavor ``O_NONBLOCK`` and the almost indistinguishable POSIX flavor "
"``O_NDELAY``, which is completely different from ``TCP_NODELAY``), but it's "
"the exact same idea. You do this after creating the socket, but before using "
"it. (Actually, if you're nuts, you can switch back and forth.)"
msgstr ""
"I Python använder du ``socket.setblocking(False)`` för att göra det icke-"
"blockerande. I C är det mer komplext, (för det första måste du välja mellan "
"BSD-smaken ``O_NONBLOCK`` och den nästan oskiljaktiga POSIX-smaken "
"``O_NDELAY``, som är helt annorlunda än ``TCP_NODELAY``), men det är exakt "
"samma idé. Du gör detta efter att du har skapat socketet, men innan du "
"använder det. (Om du är galen kan du faktiskt växla fram och tillbaka)"

msgid ""
"The major mechanical difference is that ``send``, ``recv``, ``connect`` and "
"``accept`` can return without having done anything. You have (of course) a "
"number of choices. You can check return code and error codes and generally "
"drive yourself crazy. If you don't believe me, try it sometime. Your app "
"will grow large, buggy and suck CPU. So let's skip the brain-dead solutions "
"and do it right."
msgstr ""
"Den stora mekaniska skillnaden är att ```end``, ``recv``, ``connect`` och "
"``accept`` kan återvända utan att ha gjort någonting. Du har (naturligtvis) "
"ett antal valmöjligheter. Du kan kontrollera returkod och felkoder och i "
"allmänhet driva dig själv till vansinne. Om du inte tror mig, prova det "
"någon gång. Din app kommer att växa sig stor, buggig och suga CPU. Så låt "
"oss hoppa över de hjärndöda lösningarna och göra det rätt."

msgid "Use ``select``."
msgstr "Använd ``select``."

msgid ""
"In C, coding ``select`` is fairly complex. In Python, it's a piece of cake, "
"but it's close enough to the C version that if you understand ``select`` in "
"Python, you'll have little trouble with it in C::"
msgstr ""
"I C är det ganska komplicerat att koda ``select``. I Python är det en bit "
"kaka, men det är tillräckligt nära C-versionen att om du förstår ``select`` "
"i Python, kommer du att ha lite problem med det i C::"

msgid ""
"ready_to_read, ready_to_write, in_error = \\\n"
"               select.select(\n"
"                  potential_readers,\n"
"                  potential_writers,\n"
"                  potential_errs,\n"
"                  timeout)"
msgstr ""
"ready_to_read, ready_to_write, in_error = \\\n"
"               select.select(\n"
"                  potential_readers,\n"
"                  potential_writers,\n"
"                  potential_errs,\n"
"                  timeout)"

msgid ""
"You pass ``select`` three lists: the first contains all sockets that you "
"might want to try reading; the second all the sockets you might want to try "
"writing to, and the last (normally left empty) those that you want to check "
"for errors. You should note that a socket can go into more than one list. "
"The ``select`` call is blocking, but you can give it a timeout. This is "
"generally a sensible thing to do - give it a nice long timeout (say a "
"minute) unless you have good reason to do otherwise."
msgstr ""
"Du skickar ``select`` tre listor: den första innehåller alla socket som du "
"kanske vill försöka läsa; den andra alla socket som du kanske vill försöka "
"skriva till och den sista (lämnas normalt tom) de som du vill kontrollera "
"för fel. Observera att ett socket kan ingå i mer än en lista. Anropet "
"``select`` är blockerande, men du kan ge det en timeout. Detta är i "
"allmänhet en förnuftig sak att göra - ge det en lång timeout (säg en minut) "
"om du inte har goda skäl att göra något annat."

msgid ""
"In return, you will get three lists. They contain the sockets that are "
"actually readable, writable and in error. Each of these lists is a subset "
"(possibly empty) of the corresponding list you passed in."
msgstr ""
"I gengäld får du tre listor. De innehåller de socket som faktiskt är "
"läsbara, skrivbara och felaktiga. Var och en av dessa listor är en delmängd "
"(eventuellt tom) av motsvarande lista som du skickade in."

msgid ""
"If a socket is in the output readable list, you can be as-close-to-certain-"
"as-we-ever-get-in-this-business that a ``recv`` on that socket will return "
"*something*. Same idea for the writable list. You'll be able to send "
"*something*. Maybe not all you want to, but *something* is better than "
"nothing.  (Actually, any reasonably healthy socket will return as writable - "
"it just means outbound network buffer space is available.)"
msgstr ""
"Om ett socket finns i den läsbara listan för utdata kan du vara så nära "
"säker som vi någonsin kan vara i den här branschen på att en ``recv`` på det "
"socketet kommer att returnera *något*. Samma idé för den skrivbara listan. "
"Du kommer att kunna skicka *något*. Kanske inte allt du vill, men *något* är "
"bättre än ingenting.  (Egentligen kommer alla rimligt friska socket att "
"returnera som skrivbara - det betyder bara att buffertutrymme för utgående "
"nätverk är tillgängligt)"

msgid ""
"If you have a \"server\" socket, put it in the potential_readers list. If it "
"comes out in the readable list, your ``accept`` will (almost certainly) "
"work. If you have created a new socket to ``connect`` to someone else, put "
"it in the potential_writers list. If it shows up in the writable list, you "
"have a decent chance that it has connected."
msgstr ""
"Om du har ett \"server\"-socket, lägg till det i listan potential_readers. "
"Om den hamnar i den läsbara listan kommer din ``accept`` (nästan säkert) att "
"fungera. Om du har skapat en ny socket för att ``ansluta`` till någon annan, "
"lägg den i listan potential_writers. Om den dyker upp i den skrivbara listan "
"har du en hyfsad chans att den har anslutit."

msgid ""
"Actually, ``select`` can be handy even with blocking sockets. It's one way "
"of determining whether you will block - the socket returns as readable when "
"there's something in the buffers.  However, this still doesn't help with the "
"problem of determining whether the other end is done, or just busy with "
"something else."
msgstr ""
"Egentligen kan ``select`` vara praktiskt även med blockerande socket. Det är "
"ett sätt att avgöra om du kommer att blockera - socketet returneras som "
"läsbart när det finns något i buffertarna.  Detta hjälper dock fortfarande "
"inte med problemet att avgöra om den andra änden är klar, eller bara "
"upptagen med något annat."

msgid ""
"**Portability alert**: On Unix, ``select`` works both with the sockets and "
"files. Don't try this on Windows. On Windows, ``select`` works with sockets "
"only. Also note that in C, many of the more advanced socket options are done "
"differently on Windows. In fact, on Windows I usually use threads (which "
"work very, very well) with my sockets."
msgstr ""
"**Portabilitetsvarning**: På Unix fungerar ``select`` både med sockets och "
"filer. Försök inte detta på Windows. På Windows fungerar ``select`` endast "
"med socket. Observera också att i C görs många av de mer avancerade "
"sockelalternativen annorlunda på Windows. Faktum är att jag på Windows "
"brukar använda trådar (som fungerar mycket, mycket bra) med mina socket."
