# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!multiprocessing` --- Process-based parallelism"
msgstr ":mod:`!multiprocessing` --- Processbaserad parallellism"

msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Källkod:** :source:`Lib/multiprocessing/`"

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""
"Denna modul stöds inte på :ref:`mobile platforms <mobile-availability>` "
"eller :ref:`WebAssembly platforms <wasm-availability>`."

msgid "Introduction"
msgstr "Introduktion"

msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both POSIX and Windows."
msgstr ""
":mod:`multiprocessing` är ett paket med stöd för att skapa processer med "
"hjälp av ett API som liknar modulen :mod:`threading`.  Paketet :mod:"
"`multiprocessing` erbjuder både lokal och fjärransluten samtidighet, vilket "
"effektivt kringgår :term:`Global Interpreter Lock <global interpreter lock>` "
"genom att använda underprocesser istället för trådar.  På grund av detta "
"tillåter :mod:`multiprocessing`-modulen programmeraren att fullt ut utnyttja "
"flera processorer på en given maskin.  Den körs på både POSIX och Windows."

msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
"Modulen :mod:`multiprocessing` introducerar också API:er som inte har någon "
"motsvarighet i modulen :mod:`threading`.  Ett utmärkt exempel på detta är :"
"class:`~multiprocessing.pool.Pool`-objektet som erbjuder ett bekvämt sätt "
"att parallellisera exekveringen av en funktion över flera indatavärden genom "
"att distribuera indata över processer (dataparallellism).  Följande exempel "
"visar hur det är vanligt att definiera sådana funktioner i en modul så att "
"underordnade processer kan importera den modulen.  Detta grundläggande "
"exempel på dataparallellism använder :class:`~multiprocessing.pool.Pool`, ::"

msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"
msgstr ""
"från multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    returnerar x*x\n"
"\n"
"om __name__ == '__main__':\n"
"    med Pool(5) som p:\n"
"        print(p.map(f, [1, 2, 3]))"

msgid "will print to standard output ::"
msgstr "kommer att skrivas ut till standardutmatningen ::"

msgid "[1, 4, 9]"
msgstr "[1, 4, 9]"

msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the :class:`~multiprocessing.pool."
"Pool` interface directly, the :mod:`concurrent.futures` API more readily "
"allows the submission of work to the underlying process pool to be separated "
"from waiting for the results."
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor` erbjuder ett gränssnitt på "
"högre nivå för att flytta uppgifter till en bakgrundsprocess utan att "
"blockera körningen av den anropande processen. Jämfört med att använda "
"gränssnittet :class:`~multiprocessing.pool.Pool` direkt, gör API:t :mod:"
"`concurrent.futures` det lättare att separera inlämning av arbete till den "
"underliggande processpoolen från väntan på resultat."

msgid "The :class:`Process` class"
msgstr "Klassen :class:`Process"

msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"I :mod:`multiprocessing` startas processer genom att skapa ett :class:"
"`Process`-objekt och sedan anropa dess :meth:`~Process.start`-metod. :class:"
"`Process` följer API:et för :class:`threading.Thread`.  Ett trivialt exempel "
"på ett multiprocessprogram är ::"

msgid ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"från multiprocessing import Process\n"
"\n"
"def f(namn):\n"
"    print('hallå', namn)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(mål=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"För att visa de enskilda process-ID:n som är inblandade följer här ett "
"utökat exempel::"

msgid ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"För en förklaring till varför ``if __name__ == '__main__'``-delen är "
"nödvändig, se :ref:`multiprocessing-programming`."

msgid ""
"The arguments to :class:`Process` usually need to be unpickleable from "
"within the child process. If you tried typing the above example directly "
"into a REPL it could lead to an :exc:`AttributeError` in the child process "
"trying to locate the *f* function in the ``__main__`` module."
msgstr ""
"Argumenten till :class:`Process` måste vanligtvis vara omöjliga att plocka "
"upp från barnprocessen. Om du försökte skriva in ovanstående exempel direkt "
"i en REPL skulle det kunna leda till ett :exc:`AttributeError` i "
"barnprocessen som försöker hitta funktionen *f* i modulen ``__main__``."

msgid "Contexts and start methods"
msgstr "Sammanhang och startmetoder"

msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"Beroende på plattform har :mod:`multiprocessing` stöd för tre sätt att "
"starta en process.  Dessa *startmetoder* är"

msgid "*spawn*"
msgstr "*spawn*"

msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"Den överordnade processen startar en ny Python-tolkprocess.  Barnprocessen "
"kommer endast att ärva de resurser som krävs för att köra processobjektets :"
"meth:`~Process.run`-metod.  I synnerhet kommer onödiga filbeskrivare och "
"handtag från den överordnade processen inte att ärvas.  Att starta en "
"process med den här metoden är ganska långsamt jämfört med att använda "
"*fork* eller *forkserver*."

msgid ""
"Available on POSIX and Windows platforms.  The default on Windows and macOS."
msgstr ""
"Finns på POSIX- och Windows-plattformar.  Standard på Windows och macOS."

msgid "*fork*"
msgstr "*gaffel*"

msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"Den överordnade processen använder :func:`os.fork` för att förgrena Python-"
"tolken.  När barnprocessen startar är den i praktiken identisk med den "
"överordnade processen.  Alla resurser från den överordnade processen ärvs av "
"barnprocessen.  Observera att det är problematiskt att på ett säkert sätt "
"forka en flertrådad process."

msgid "Available on POSIX systems."
msgstr "Tillgänglig på POSIX-system."

msgid ""
"This is no longer the default start method on any platform. Code that "
"requires *fork* must explicitly specify that via :func:`get_context` or :"
"func:`set_start_method`."
msgstr ""
"Detta är inte längre standardstartmetoden på någon plattform. Kod som kräver "
"*fork* måste uttryckligen ange det via :func:`get_context` eller :func:"
"`set_start_method`."

msgid ""
"If Python is able to detect that your process has multiple threads, the :"
"func:`os.fork` function that this start method calls internally will raise "
"a :exc:`DeprecationWarning`. Use a different start method. See the :func:`os."
"fork` documentation for further explanation."
msgstr ""
"Om Python kan upptäcka att din process har flera trådar, kommer funktionen :"
"func:`os.fork` som denna startmetod anropar internt att ge upphov till en :"
"exc:`DeprecationWarning`. Använd en annan startmetod. Se dokumentationen "
"för :func:`os.fork` för ytterligare förklaringar."

msgid "*forkserver*"
msgstr "*forkserver*"

msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is spawned.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded unless system libraries "
"or preloaded imports spawn threads as a side-effect so it is generally safe "
"for it to use :func:`os.fork`. No unnecessary resources are inherited."
msgstr ""
"När programmet startas och startmetoden *forkserver* väljs, skapas en "
"serverprocess.  Från och med då, när en ny process behövs, ansluter den "
"överordnade processen till servern och begär att den forkar en ny process.  "
"Fork-serverprocessen är enkeltrådad om inte systembibliotek eller "
"förinstallerade importer skapar trådar som en bieffekt, så det är i "
"allmänhet säkert för den att använda :func:`os.fork`. Inga onödiga resurser "
"ärvs."

msgid ""
"Available on POSIX platforms which support passing file descriptors over "
"Unix pipes such as Linux.  The default on those."
msgstr ""
"Finns på POSIX-plattformar som stöder överföring av filbeskrivare via Unix "
"pipes, t.ex. Linux.  Standard på dessa."

msgid "This became the default start method on POSIX platforms."
msgstr "Detta blev standardstartmetoden på POSIX-plattformar."

msgid ""
"*spawn* added on all POSIX platforms, and *forkserver* added for some POSIX "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"*spawn* har lagts till på alla POSIX-plattformar och *forkserver* har lagts "
"till på vissa POSIX-plattformar. Barnprocesser ärver inte längre alla "
"föräldrarnas ärftliga handtag i Windows."

msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See :issue:`33725`."
msgstr ""
"På macOS är startmetoden *spawn* nu standard.  Startmetoden *fork* bör "
"betraktas som osäker eftersom den kan leda till att underprocessen kraschar "
"eftersom systembiblioteken i macOS kan starta trådar. Se :issue:`33725`."

msgid ""
"On POSIX platforms the default start method was changed from *fork* to "
"*forkserver* to retain the performance but avoid common multithreaded "
"process incompatibilities. See :gh:`84559`."
msgstr ""
"På POSIX-plattformar ändrades standardstartmetoden från *fork* till "
"*forkserver* för att bibehålla prestandan men undvika vanliga "
"inkompatibiliteter med flertrådade processer. Se :gh:`84559`."

msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""
"På POSIX startar startmetoderna *spawn* eller *forkserver* även en *resource "
"tracker*-process som spårar de olänkade namngivna systemresurser (t.ex. "
"namngivna semaforer eller :class:`~multiprocessing.shared_memory."
"SharedMemory`-objekt) som skapas av processer i programmet.  När alla "
"processer har avslutats kopplar resursspåraren bort eventuella kvarvarande "
"spårningsobjekt. Vanligtvis bör det inte finnas några, men om en process "
"dödades av en signal kan det finnas några \"läckta\" resurser.  (Varken "
"läckta semaforer eller delade minnessegment kommer automatiskt att avlänkas "
"förrän vid nästa omstart. Detta är problematiskt för båda objekten eftersom "
"systemet endast tillåter ett begränsat antal namngivna semaforer, och delade "
"minnessegment upptar en del utrymme i huvudminnet)"

msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"För att välja en startmetod använder du :func:`set_start_method` i ``if "
"__name__ == '__main__'`` i huvudmodulens klausul.  Till exempel::"

msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
":func:`set_start_method` bör inte användas mer än en gång i programmet."

msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Alternativt kan du använda :func:`get_context` för att hämta ett "
"kontextobjekt.  Context-objekt har samma API som multiprocessing-modulen och "
"gör att man kan använda flera startmetoder i samma program. ::"

msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Observera att objekt som är relaterade till en kontext kanske inte är "
"kompatibla med processer för en annan kontext.  I synnerhet kan lås som "
"skapats med kontexten *fork* inte skickas till processer som startats med "
"startmetoderna *spawn* eller *forkserver*."

msgid ""
"Libraries using :mod:`multiprocessing` or :class:`~concurrent.futures."
"ProcessPoolExecutor` should be designed to allow their users to provide "
"their own multiprocessing context.  Using a specific context of your own "
"within a library can lead to incompatibilities with the rest of the library "
"user's application.  Always document if your library requires a specific "
"start method."
msgstr ""
"Bibliotek som använder :mod:`multiprocessing` eller :class:`~concurrent."
"futures.ProcessPoolExecutor` bör utformas så att de tillåter sina användare "
"att tillhandahålla sin egen multiprocessing-kontext.  Om du använder en egen "
"specifik kontext i ett bibliotek kan det leda till inkompatibilitet med "
"resten av biblioteksanvändarens applikation.  Dokumentera alltid om ditt "
"bibliotek kräver en specifik startmetod."

msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods generally cannot be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on POSIX systems. The ``'fork'`` start "
"method may work if code does not use threads."
msgstr ""
"Startmetoderna ``'spawn'`` och ``'forkserver'`` kan i allmänhet inte "
"användas med \"frysta\" körbara filer (dvs. binära filer som produceras av "
"paket som **PyInstaller** och **cx_Freeze**) på POSIX-system. Startmetoden "
"``'fork'`` kan fungera om koden inte använder trådar."

msgid "Exchanging objects between processes"
msgstr "Utbyte av objekt mellan processer"

msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` stöder två typer av kommunikationskanaler mellan "
"processer:"

msgid "**Queues**"
msgstr "**Köer**"

msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
"Klassen :class:`Queue` är en nära klon av :class:`queue.Queue`.  Till "
"exempel::"

msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"från multiprocessing import Process, Kö\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hallå'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = kö()\n"
"    p = Process(mål=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get()) # skriver ut \"[42, None, 'hello']\"\n"
"    p.join()"

msgid ""
"Queues are thread and process safe. Any object put into a :mod:"
"`~multiprocessing` queue will be serialized."
msgstr ""
"Köer är tråd- och processäkra. Alla objekt som sätts in i en :mod:"
"`~multiprocessing`-kö kommer att serialiseras."

msgid "**Pipes**"
msgstr "**Pipor**"

msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"Funktionen :func:`Pipe` returnerar ett par anslutningsobjekt som är anslutna "
"med en pipe som standard är duplex (tvåvägs).  Till exempel::"

msgid ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"från multiprocessing import Process, Rör\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hallå'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(mål=f, args=(barn_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv()) # skriver ut \"[42, None, 'hello']\"\n"
"    p.join()"

msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"De två anslutningsobjekt som returneras av :func:`Pipe` representerar rörets "
"två ändar.  Varje anslutningsobjekt har metoderna :meth:`~Connection.send` "
"och :meth:`~Connection.recv` (bland andra).  Observera att data i en pipe "
"kan bli korrumperade om två processer (eller trådar) försöker läsa från "
"eller skriva till *samma* ände av pipen samtidigt.  Naturligtvis finns det "
"ingen risk för korruption från processer som använder olika ändar av pipen "
"samtidigt."

msgid ""
"The :meth:`~Connection.send` method serializes the object and :meth:"
"`~Connection.recv` re-creates the object."
msgstr ""
"Metoden :meth:`~Connection.send` serialiserar objektet och :meth:"
"`~Connection.recv` återskapar objektet."

msgid "Synchronization between processes"
msgstr "Synkronisering mellan processer"

msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` innehåller motsvarigheter till alla "
"synkroniseringsprimitiver från :mod:`threading`.  Till exempel kan man "
"använda ett lås för att säkerställa att endast en process skriver ut till "
"standardutdata åt gången::"

msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('hello world', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"
msgstr ""
"från multiprocessing import Process, Lås\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    försök:\n"
"        print('hello world', i)\n"
"    slutligen:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    för num i intervall(10):\n"
"        Process(mål=f, args=(lock, num)).start()"

msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Om man inte använder låset kan utdata från de olika processerna blandas ihop."

msgid "Sharing state between processes"
msgstr "Delning av tillstånd mellan processer"

msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Som nämnts ovan är det vid samtidig programmering oftast bäst att undvika "
"att använda delat tillstånd så långt det är möjligt.  Detta gäller särskilt "
"när man använder flera processer."

msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"Men om du verkligen behöver använda delade data finns det ett par sätt att "
"göra det på :mod:`multiprocessing`."

msgid "**Shared memory**"
msgstr "**Gemensamt minne**"

msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Data kan lagras i en delad minneskarta med hjälp av :class:`Value` eller :"
"class:`Array`.  Till exempel följande kod ::"

msgid ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"
msgstr ""
"från multiprocessing import Process, Värde, Array\n"
"\n"
"def f(n, a):\n"
"    n.värde = 3,1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Värde('d', 0.0)\n"
"    arr = Array('i', intervall(10))\n"
"\n"
"    p = Process(mål=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.värde)\n"
"    print(arr[:])"

msgid "will print ::"
msgstr "kommer att skriva ut ::"

msgid ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"
msgstr ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"

msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Argumenten ``'d'`` och ``'i'`` som används när ``num`` och ``arr`` skapas är "
"typkoder av den typ som används av modulen :mod:`array`: ``'d'`` anger en "
"flottör med dubbel precision och ``'i'`` anger ett signerat heltal.  Dessa "
"delade objekt kommer att vara process- och trådsäkra."

msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"För mer flexibilitet vid användning av delat minne kan man använda modulen :"
"mod:`multiprocessing.sharedctypes` som stöder skapandet av godtyckliga "
"ctypes-objekt som allokeras från delat minne."

msgid "**Server process**"
msgstr "**Serverprocess**"

msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Ett manager-objekt som returneras av :func:`Manager` styr en serverprocess "
"som håller Python-objekt och tillåter andra processer att manipulera dem med "
"hjälp av proxies."

msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`set`, :class:`~managers.Namespace`, :class:`Lock`, :"
"class:`RLock`, :class:`Semaphore`, :class:`BoundedSemaphore`, :class:"
"`Condition`, :class:`Event`, :class:`Barrier`, :class:`Queue`, :class:"
"`Value` and :class:`Array`.  For example, ::"
msgstr ""
"En manager som returneras av :func:`Manager` kommer att stödja typerna :"
"class:`list`, :class:`dict`, :class:`set`, :class:`~managers.Namespace`, :"
"class:`Lock`, :class:`RLock`, :class:`Semaphore`, :class:"
"`BoundedSemaphore`, :class:`Condition`, :class:`Event`, :class:`Barrier`, :"
"class:`Queue`, :class:`Value` och :class:`Array`.  Till exempel ::"

msgid ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l, s):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"    s.add('a')\n"
"    s.add('b')\n"
"\n"
"if __name__ == '__main__':\n"
"    with Manager() as manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(range(10))\n"
"        s = manager.set()\n"
"\n"
"        p = Process(target=f, args=(d, l, s))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)\n"
"        print(s)"
msgstr ""
"från multiprocessing import Process, Manager\n"
"\n"
"def f(d, l, s):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0,25] = Ingen\n"
"    l.reverse()\n"
"    s.add('a')\n"
"    s.add('b')\n"
"\n"
"if __name__ == '__main__':\n"
"    med Manager() som manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(intervall(10))\n"
"        s = manager.set()\n"
"\n"
"        p = Process(mål=f, args=(d, l, s))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)\n"
"        skriv ut(s)"

msgid ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n"
"{'a', 'b'}"
msgstr ""
"{0,25: Ingen, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n"
"{'a', 'b'}"

msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Serverprocesshanterare är mer flexibla än delade minnesobjekt eftersom de "
"kan göras så att de stöder godtyckliga objekttyper.  Dessutom kan en enda "
"hanterare delas av processer på olika datorer över ett nätverk. De är dock "
"långsammare än om man använder delat minne."

msgid "Using a pool of workers"
msgstr "Använda en pool av arbetstagare"

msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"Klassen :class:`~multiprocessing.pool.Pool` representerar en pool av "
"arbetsprocesser.  Den har metoder som gör det möjligt att avlasta uppgifter "
"till arbetsprocesserna på några olika sätt."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # start 4 worker processes\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # print same numbers in arbitrary order\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # evaluate \"f(20)\" asynchronously\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # evaluate \"os.getpid()\" asynchronously\n"
"        res = pool.apply_async(os.getpid, ()) # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints the PID of that "
"process\n"
"\n"
"        # launching multiple evaluations asynchronously *may* use more "
"processes\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # make a single worker sleep for 10 seconds\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a multiprocessing."
"TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more work\")\n"
"\n"
"    # exiting the 'with'-block has stopped the pool\n"
"    print(\"Now the pool is closed and no longer available\")"
msgstr ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # start 4 worker processes\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # print same numbers in arbitrary order\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # evaluate \"f(20)\" asynchronously\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # evaluate \"os.getpid()\" asynchronously\n"
"        res = pool.apply_async(os.getpid, ()) # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints the PID of that "
"process\n"
"\n"
"        # launching multiple evaluations asynchronously *may* use more "
"processes\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # make a single worker sleep for 10 seconds\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a multiprocessing."
"TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more work\")\n"
"\n"
"    # exiting the 'with'-block has stopped the pool\n"
"    print(\"Now the pool is closed and no longer available\")"

msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Observera att metoderna i en pool endast ska användas av den process som "
"skapade den."

msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"Funktionalitet inom detta paket kräver att modulen ``__main__`` kan "
"importeras av underordnade program. Detta behandlas i :ref:`multiprocessing-"
"programming` men det är värt att påpeka här. Detta innebär att vissa "
"exempel, såsom :class:`multiprocessing.pool.Pool` exemplen inte kommer att "
"fungera i den interaktiva tolken. Till exempel::"

msgid ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>"
msgstr ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"... returnera x*x\n"
"...\n"
">>> med p:\n"
"... p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (senaste anropet senast):\n"
"Traceback (senaste anropet senast):\n"
"Traceback (senaste anropet senast):\n"
"AttributeError: Kan inte hämta attributet 'f' på <modulen "
"'__main__' (<klassen '_frozen_importlib.BuiltinImporter'>)>\n"
"AttributFel: Kan inte få attributet 'f' på <modul '__main__' (<klass "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributFel: Kan inte hämta attributet 'f' på <modul '__main__' (<klass "
"'_frozen_importlib.BuiltinImporter'>)>"

msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(Om du försöker detta kommer det faktiskt att matas ut tre fullständiga "
"spårningar som är sammanflätade på ett halvt slumpmässigt sätt, och då "
"kanske du måste stoppa den överordnade processen på något sätt)"

msgid "Reference"
msgstr "Referens"

msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"Paketet :mod:`multiprocessing` replikerar till största delen API:et för "
"modulen :mod:`threading`."

msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` och undantag"

msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Processobjekt representerar aktivitet som körs i en separat process. "
"Klassen :class:`Process` har motsvarigheter till alla metoder i :class:"
"`threading.Thread`."

msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""
"Konstruktorn ska alltid anropas med nyckelordsargument. *group* bör alltid "
"vara ``None``; den existerar enbart för kompatibilitet med :class:`threading."
"Thread`.  *target* är det anropsbara objekt som skall anropas av :meth:`run`-"
"metoden.  Standardvärdet är ``None``, vilket betyder att ingenting anropas. "
"*name* är processnamnet (se :attr:`name` för mer information). *args* är "
"argumenttupeln för målinkallningen.  *kwargs* är en ordbok med "
"nyckelordsargument för målanropet.  Om det tillhandahålls sätter det enda "
"nyckelordsargumentet *daemon* processens flagga :attr:`daemon` till ``True`` "
"eller ``False``.  Om ``None`` (standard), kommer denna flagga att ärvas från "
"den skapande processen."

msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"Som standard skickas inga argument till *target*. Argumentet *args*, som som "
"standard är ``()``, kan användas för att ange en lista eller tupel av de "
"argument som ska skickas till *target*."

msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (``super().__init__()``) before doing anything else "
"to the process."
msgstr ""
"Om en subklass åsidosätter konstruktorn måste den se till att den anropar "
"basklassens konstruktor (``super().__init__()``) innan den gör något annat "
"med processen."

msgid ""
"In general, all arguments to :class:`Process` must be picklable.  This is "
"frequently observed when trying to create a :class:`Process` or use a :class:"
"`concurrent.futures.ProcessPoolExecutor` from a REPL with a locally defined "
"*target* function."
msgstr ""
"I allmänhet måste alla argument till :class:`Process` vara plockbara.  Detta "
"observeras ofta när man försöker skapa en :class:`Process` eller använda en :"
"class:`concurrent.futures.ProcessPoolExecutor` från en REPL med en lokalt "
"definierad *target*-funktion."

msgid ""
"Passing a callable object defined in the current REPL session causes the "
"child process to die via an uncaught :exc:`AttributeError` exception when "
"starting as *target* must have been defined within an importable module in "
"order to be loaded during unpickling."
msgstr ""
"Att skicka ett anropsbart objekt som definierats i den aktuella REPL-"
"sessionen gör att barnprocessen dör via ett icke fångat :exc:"
"`AttributeError`-undantag när den startas eftersom *target* måste ha "
"definierats i en importerbar modul för att kunna laddas under unpickling."

msgid "Example of this uncatchable error from the child::"
msgstr "Exempel på detta oavhjälpliga fel från barnet::"

msgid ""
">>> import multiprocessing as mp\n"
">>> def knigit():\n"
"...     print(\"Ni!\")\n"
"...\n"
">>> process = mp.Process(target=knigit)\n"
">>> process.start()\n"
">>> Traceback (most recent call last):\n"
"  File \".../multiprocessing/spawn.py\", line ..., in spawn_main\n"
"  File \".../multiprocessing/spawn.py\", line ..., in _main\n"
"AttributeError: module '__main__' has no attribute 'knigit'\n"
">>> process\n"
"<SpawnProcess name='SpawnProcess-1' pid=379473 parent=378707 stopped "
"exitcode=1>"
msgstr ""
">>> import multiprocessing as mp\n"
">>> def knigit():\n"
"...     print(\"Ni!\")\n"
"...\n"
">>> process = mp.Process(target=knigit)\n"
">>> process.start()\n"
">>> Traceback (most recent call last):\n"
"  File \".../multiprocessing/spawn.py\", line ..., in spawn_main\n"
"  File \".../multiprocessing/spawn.py\", line ..., in _main\n"
"AttributeError: module '__main__' has no attribute 'knigit'\n"
">>> process\n"
"<SpawnProcess name='SpawnProcess-1' pid=379473 parent=378707 stopped "
"exitcode=1>"

msgid ""
"See :ref:`multiprocessing-programming-spawn`.  While this restriction is not "
"true if using the ``\"fork\"`` start method, as of Python ``3.14`` that is "
"no longer the default on any platform.  See :ref:`multiprocessing-start-"
"methods`. See also :gh:`132898`."
msgstr ""
"Se :ref:`multiprocessing-programming-spawn`.  Även om denna begränsning inte "
"är sann om man använder startmetoden ``\"fork\"``, så är den inte längre "
"standard på någon plattform från och med Python ``3.14``.  Se :ref:"
"``multiprocessing-start-methods``. Se även :gh:`132898`."

msgid "Added the *daemon* parameter."
msgstr "Parametern *daemon* har lagts till."

msgid "Method representing the process's activity."
msgstr "Metod som representerar processens aktivitet."

msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Du kan åsidosätta denna metod i en subklass.  Standardmetoden :meth:`run` "
"anropar det anropsbara objekt som skickats till objektets konstruktör som "
"målargument, om något, med sekventiella argument och nyckelordsargument som "
"hämtas från argumenten *args* respektive *kwargs*."

msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr ""
"Samma effekt uppnås genom att använda en lista eller tupel som *args*-"
"argument i :class:`Process`."

msgid "Example::"
msgstr "Exempel::"

msgid ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"
msgstr ""
">>> från multiprocessing import Process\n"
">>> p = Process(mål=utskrift, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(mål=utskrift, args=(1,))\n"
">>> p.run()\n"
"1"

msgid "Start the process's activity."
msgstr "Starta processens aktivitet."

msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Detta måste anropas högst en gång per processobjekt.  Det ordnar så att "
"objektets :meth:`run`-metod anropas i en separat process."

msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Om det valfria argumentet *timeout* är ``None`` (standard) blockeras metoden "
"tills den process vars :meth:`join`-metod anropas avslutas. Om *timeout* är "
"ett positivt tal blockeras den i högst *timeout* sekunder. Observera att "
"metoden returnerar ``None`` om dess process avslutas eller om metoden "
"tidsbegränsas.  Kontrollera processens :attr:`exitcode` för att avgöra om "
"den avslutades."

msgid "A process can be joined many times."
msgstr "En process kan anslutas flera gånger."

msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"En process kan inte ansluta sig till sig själv eftersom detta skulle orsaka "
"ett dödläge.  Det är ett fel att försöka ansluta sig till en process innan "
"den har startats."

msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"Processens namn.  Namnet är en sträng som endast används i "
"identifieringssyfte.  Det har ingen semantik.  Flera processer kan ges samma "
"namn."

msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"Det initiala namnet sätts av konstruktören.  Om inget explicit namn anges "
"till konstruktören, konstrueras ett namn av formen \"Process-N\\ :sub:`1`:"
"N\\ :sub:`2`:...:N\\ :sub:`k`\", där varje N\\ :sub:`k` är det N:te barnet "
"till sin förälder."

msgid "Return whether the process is alive."
msgstr "Returnerar om processen är vid liv."

msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Ett processobjekt är i princip vid liv från det ögonblick då metoden :meth:"
"`start` returneras till dess att barnprocessen avslutas."

msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"Processens daemonflagga, ett booleanskt värde.  Detta måste anges innan :"
"meth:`start` anropas."

msgid "The initial value is inherited from the creating process."
msgstr "Det initiala värdet ärvs från skapandeprocessen."

msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"När en process avslutas försöker den avsluta alla sina daemoniska "
"underordnade processer."

msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Observera att en daemonisk process inte får skapa underordnade processer. I "
"annat fall skulle en daemonisk process lämna sina barn föräldralösa om den "
"avslutas när dess föräldraprocess avslutas. Dessutom är detta **inte** Unix "
"daemons eller tjänster, det är normala processer som kommer att avslutas "
"(och inte anslutas) om icke-daemoniska processer har avslutats."

msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"Förutom API:et :class:`threading.Thread` stöder :class:`Process`-objekten "
"även följande attribut och metoder:"

msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Returnerar processens ID.  Innan processen startas kommer detta att vara "
"``None``."

msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""
"Barnets utgångskod.  Denna kommer att vara ``None`` om processen ännu inte "
"har avslutats."

msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"Om barnets :meth:`run`-metod returnerades normalt blir utgångskoden 0. Om "
"den avslutades via :func:`sys.exit` med ett heltalsargument *N* blir "
"utgångskoden *N*."

msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"Om barnet avslutades på grund av ett undantag som inte fångades upp inom :"
"meth:`run`, kommer utgångskoden att vara 1.  Om det avslutades av signalen "
"*N* kommer utgångskoden att vara det negativa värdet *-N*."

msgid "The process's authentication key (a byte string)."
msgstr "Processens autentiseringsnyckel (en byte-sträng)."

msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"När :mod:`multiprocessing` initieras tilldelas huvudprocessen en slumpmässig "
"sträng med hjälp av :func:`os.urandom`."

msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"När ett :class:`Process`-objekt skapas kommer det att ärva "
"autentiseringsnyckeln för sin överordnade process, även om detta kan ändras "
"genom att ange :attr:`authkey` till en annan byte-sträng."

msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "Se :ref:`multiprocessing-auth-keys`."

msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Ett numeriskt handtag för ett systemobjekt som kommer att bli \"klart\" när "
"processen avslutas."

msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join` is "
"simpler."
msgstr ""
"Du kan använda det här värdet om du vill vänta på flera händelser samtidigt "
"med hjälp av :func:`multiprocessing.connection.wait`.  Annars är det enklare "
"att anropa :meth:`join`."

msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On POSIX, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"I Windows är detta ett OS-handtag som kan användas med API-anropen "
"``WaitForSingleObject`` och ``WaitForMultipleObjects``.  På POSIX är detta "
"en filbeskrivare som kan användas med primitiver från modulen :mod:`select`."

msgid ""
"Terminate the process. Works on POSIX using the :py:const:`~signal.SIGINT` "
"signal. Behavior on Windows is undefined."
msgstr ""
"Avslutar processen. Fungerar på POSIX med hjälp av signalen :py:const:"
"`~signal.SIGINT`. Beteendet på Windows är odefinierat."

msgid ""
"By default, this terminates the child process by raising :exc:"
"`KeyboardInterrupt`. This behavior can be altered by setting the respective "
"signal handler in the child process :func:`signal.signal` for :py:const:"
"`~signal.SIGINT`."
msgstr ""
"Som standard avslutas den underordnade processen genom att :exc:"
"`KeyboardInterrupt` aktiveras. Detta beteende kan ändras genom att ställa in "
"respektive signalhanterare i barnprocessen :func:`signal.signal` för :py:"
"const:`~signal.SIGINT`."

msgid ""
"Note: if the child process catches and discards :exc:`KeyboardInterrupt`, "
"the process will not be terminated."
msgstr ""
"Obs: om barnprocessen fångar upp och kastar :exc:`KeyboardInterrupt`, kommer "
"processen inte att avslutas."

msgid ""
"Note: the default behavior will also set :attr:`exitcode` to ``1`` as if an "
"uncaught exception was raised in the child process. To have a different :"
"attr:`exitcode` you may simply catch :exc:`KeyboardInterrupt` and call "
"``exit(your_code)``."
msgstr ""
"Notera: standardbeteendet kommer också att sätta :attr:`exitcode` till ``1`` "
"som om ett undantag utan åtgärd har uppstått i barnprocessen. För att ha en "
"annan :attr:`exitcode` kan du helt enkelt fånga :exc:`KeyboardInterrupt` och "
"anropa ``exit(your_code)``."

msgid ""
"Terminate the process.  On POSIX this is done using the :py:const:`~signal."
"SIGTERM` signal; on Windows :c:func:`!TerminateProcess` is used.  Note that "
"exit handlers and finally clauses, etc., will not be executed."
msgstr ""
"Avsluta processen.  På POSIX görs detta med hjälp av signalen :py:const:"
"`~signal.SIGTERM`; på Windows används :c:func:`!TerminateProcess`.  "
"Observera att exit-handlers och finally-klausuler etc. inte kommer att "
"exekveras."

msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Observera att processer som härstammar från processen *inte* kommer att "
"avslutas - de kommer helt enkelt att bli föräldralösa."

msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Om denna metod används när den associerade processen använder en pipe eller "
"en kö, kan pipen eller kön bli skadad och bli oanvändbar för andra "
"processer.  På samma sätt, om processen har förvärvat ett lås eller en "
"semafor etc., kan avslutningen av den leda till att andra processer fastnar."

msgid "Same as :meth:`terminate` but using the ``SIGKILL`` signal on POSIX."
msgstr ""
"Samma som :meth:`terminate` men använder signalen ``SIGKILL`` på POSIX."

msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"Stänger :class:`Process`-objektet och frigör alla resurser som är "
"associerade med det. :exc:`ValueError` visas om den underliggande processen "
"fortfarande körs.  När :meth:`close` har returnerats framgångsrikt kommer de "
"flesta andra metoder och attribut för :class:`Process`-objektet att ge "
"upphov till :exc:`ValueError`."

msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Observera att metoderna :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` och :attr:`exitcode` endast ska anropas av den process som "
"skapade processobjektet."

msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Exempel på användning av några av metoderna i :class:`Process`:"

msgid ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"
msgstr ""
">>> import multiprocessing, tid, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.process(mål=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> Falsk\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Processen ... startad> Sant\n"
">>> p.terminate()\n"
">>> tid.sömn(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stoppad exitcode=-SIGTERM> Falsk\n"
">>> p.exitcode == -signal.SIGTERM\n"
"Sant"

msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "Basklassen för alla :mod:`multiprocessing`-undantag."

msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into` when the supplied "
"buffer object is too small for the message read."
msgstr ""
"Exception orsakad av :meth:`Connection.recv_bytes_into` när det medföljande "
"buffertobjektet är för litet för det lästa meddelandet."

msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Om ``e`` är en instans av :exc:`BufferTooShort` så kommer ``e.args[0]``` att "
"ge meddelandet som en byte-sträng."

msgid "Raised when there is an authentication error."
msgstr "Uppstår när det finns ett autentiseringsfel."

msgid "Raised by methods with a timeout when the timeout expires."
msgstr "Utlöses av metoder med en timeout när timeouten löper ut."

msgid "Pipes and Queues"
msgstr "Pipes och köer"

msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"När man använder flera processer använder man i allmänhet meddelandepassning "
"för kommunikation mellan processerna och undviker att behöva använda "
"synkroniseringsprimitiver som lås."

msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"För att skicka meddelanden kan man använda :func:`Pipe` (för en anslutning "
"mellan två processer) eller en kö (som tillåter flera producenter och "
"konsumenter)."

msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Typerna :class:`Queue`, :class:`SimpleQueue` och :class:`JoinableQueue` är "
"köer med flera producenter och flera konsumenter :abbr:`FIFO (först in, "
"först ut)` som är modellerade efter klassen :class:`queue.Queue` i "
"standardbiblioteket.  De skiljer sig åt genom att :class:`Queue` saknar "
"metoderna :meth:`~queue.Queue.task_done` och :meth:`~queue.Queue.join` som "
"introducerades i Python 2.5:s klass :class:`queue.Queue`."

msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Om du använder :class:`JoinableQueue` så **måste** du anropa :meth:"
"`JoinableQueue.task_done` för varje uppgift som tas bort från kön, annars "
"kan semaforen som används för att räkna antalet oavslutade uppgifter så "
"småningom svämma över och orsaka ett undantag."

msgid ""
"One difference from other Python queue implementations, is that :mod:"
"`multiprocessing` queues serializes all objects that are put into them "
"using :mod:`pickle`. The object return by the get method is a re-created "
"object that does not share memory with the original object."
msgstr ""
"En skillnad från andra köimplementationer i Python är att :mod:"
"`multiprocessing`-köer serialiserar alla objekt som läggs in i dem med :mod:"
"`pickle`. Objektet som returneras av get-metoden är ett återskapat objekt "
"som inte delar minne med det ursprungliga objektet."

msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Observera att man också kan skapa en delad kö genom att använda ett manager-"
"objekt -- se :ref:`multiprocessing-managers`."

msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` använder de vanliga undantagen :exc:`queue.Empty` "
"och :exc:`queue.Full` för att signalera en timeout.  De är inte tillgängliga "
"i namnrymden :mod:`multiprocessing` så du måste importera dem från :mod:"
"`queue`."

msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"När ett objekt sätts i en kö picklas objektet och en bakgrundstråd spolar "
"senare ut den picklade datan till en underliggande pipe.  Detta har några "
"konsekvenser som är lite överraskande, men bör inte orsaka några praktiska "
"problem - om de verkligen stör dig kan du istället använda en kö som skapats "
"med en :ref:`manager <multiprocessing-managers>`."

msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"Efter att ha lagt ett objekt på en tom kö kan det bli en oändligt liten "
"fördröjning innan köns metod :meth:`~Queue.empty` returnerar :const:`False` "
"och :meth:`~Queue.get_nowait` kan returnera utan att ge upphov till :exc:"
"`queue.Empty`."

msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Om flera processer ställer objekt i kö är det möjligt att objekten tas emot "
"i den andra änden i fel ordning. Objekt som köas av samma process kommer "
"dock alltid att vara i den förväntade ordningen i förhållande till varandra."

msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Om en process dödas med :meth:`Process.terminate` eller :func:`os.kill` "
"medan den försöker använda en :class:`Queue`, är det troligt att data i kön "
"blir skadade.  Detta kan leda till att en annan process får ett undantag när "
"den försöker använda kön senare."

msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Som nämnts ovan, om en underordnad process har lagt objekt i en kö (och inte "
"har använt :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), kommer den processen inte att avslutas förrän alla "
"buffrade objekt har spolats till pipen."

msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Det innebär att om du försöker ansluta dig till den processen kan du få ett "
"dödläge om du inte är säker på att alla objekt som har ställts i kö har "
"förbrukats.  På samma sätt, om barnprocessen är icke-daemonisk, kan "
"föräldraprocessen hänga sig vid utgången när den försöker ansluta sig till "
"alla sina icke-daemoniska barn."

msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Observera att en kö som skapats med hjälp av en manager inte har detta "
"problem.  Se :ref:`multiprocessing-programming`."

msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"För ett exempel på användning av köer för kommunikation mellan processer, "
"se :ref:`multiprocessing-examples`."

msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Returnerar ett par ``(conn1, conn2)`` av :class:`~multiprocessing.connection."
"Connection`-objekt som representerar ändarna av ett rör."

msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Om *duplex* är ``True`` (standard) är röret dubbelriktat.  Om *duplex* är "
"``False`` är pipen enkelriktad: ``conn1`` kan bara användas för att ta emot "
"meddelanden och ``conn2`` kan bara användas för att skicka meddelanden."

msgid ""
"The :meth:`~multiprocessing.Connection.send` method serializes the object "
"using :mod:`pickle` and the :meth:`~multiprocessing.Connection.recv` re-"
"creates the object."
msgstr ""
"Metoden :meth:`~multiprocessing.Connection.send` serialiserar objektet med "
"hjälp av :mod:`pickle` och metoden :meth:`~multiprocessing.Connection.recv` "
"återskapar objektet."

msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Returnerar en processdelad kö som implementerats med hjälp av en pipe och "
"några lås/semaphores.  När en process först lägger ett objekt i kön startas "
"en matartråd som överför objekt från en buffert till pipen."

msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"De vanliga undantagen :exc:`queue.Empty` och :exc:`queue.Full` från "
"standardbibliotekets modul :mod:`queue` används för att signalera "
"tidsavbrott."

msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` implementerar alla metoder i :class:`queue.Queue` utom :meth:"
"`~queue.Queue.task_done` och :meth:`~queue.Queue.join`."

msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Returnerar den ungefärliga storleken på kön.  På grund av semantiken för "
"multithreading/multiprocessing är detta tal inte tillförlitligt."

msgid ""
"Note that this may raise :exc:`NotImplementedError` on platforms like macOS "
"where ``sem_getvalue()`` is not implemented."
msgstr ""
"Observera att detta kan ge upphov till :exc:`NotImplementedError` på "
"plattformar som macOS där ``sem_getvalue()`` inte är implementerad."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Returnerar ``True`` om kön är tom, annars ``False``.  På grund av semantiken "
"för multithreading/multiprocessing är detta inte tillförlitligt."

msgid "May raise an :exc:`OSError` on closed queues. (not guaranteed)"
msgstr ""
"Kan ge upphov till ett :exc:`OSError` på stängda köer. (inte garanterat)"

msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Returnerar ``True`` om kön är full, annars ``False``.  På grund av "
"semantiken för multithreading/multiprocessing är detta inte tillförlitligt."

msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Placerar obj i kön.  Om det valfria argumentet *block* är ``True`` "
"(standard) och *timeout* är ``None`` (standard), blockeras vid behov tills "
"en ledig plats finns tillgänglig.  Om *timeout* är ett positivt tal "
"blockerar den i högst *timeout* sekunder och ger upphov till :exc:`queue."
"Full`-undantaget om ingen ledig plats fanns tillgänglig inom den tiden.  I "
"annat fall (*block* är ``False``), lägg till ett objekt i kön om en ledig "
"plats omedelbart finns tillgänglig, annars utlöses undantaget :exc:`queue."
"Full` (*timeout* ignoreras i det fallet)."

msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Om kön är stängd kommer :exc:`ValueError` att uppstå istället för :exc:"
"`AssertionError`."

msgid "Equivalent to ``put(obj, False)``."
msgstr "Motsvarar ``put(obj, False)``."

msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Tar bort och returnerar ett objekt från kön.  Om de valfria argen *block* är "
"``True`` (standard) och *timeout* är ``None`` (standard), blockeras vid "
"behov tills ett objekt är tillgängligt.  Om *timeout* är ett positivt tal "
"blockerar den högst *timeout* sekunder och ger upphov till :exc:`queue."
"Empty`-undantaget om inget objekt var tillgängligt inom den tiden.  I annat "
"fall (block är ``False``) returneras ett objekt om det finns ett omedelbart "
"tillgängligt, annars uppstår undantaget :exc:`queue.Empty` (*timeout* "
"ignoreras i det fallet)."

msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr ""
"Om kön är stängd, genereras :exc:`ValueError` istället för :exc:`OSError`."

msgid "Equivalent to ``get(False)``."
msgstr "Motsvarar ``get(False)``."

msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` har några ytterligare metoder som inte finns "
"i :class:`queue.Queue`.  Dessa metoder är vanligtvis onödiga för de flesta "
"koder:"

msgid "Close the queue: release internal resources."
msgstr "Stäng kön: frigör interna resurser."

msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`~Queue.get`, :meth:`~Queue.put` and :meth:`~Queue.empty` methods must no "
"longer be called."
msgstr ""
"En kö får inte längre användas efter att den har stängts. Exempelvis får "
"metoderna :meth:`~Queue.get`, :meth:`~Queue.put` och :meth:`~Queue.empty` "
"inte längre anropas."

msgid ""
"The background thread will quit once it has flushed all buffered data to the "
"pipe.  This is called automatically when the queue is garbage collected."
msgstr ""
"Bakgrundstråden kommer att avslutas när den har spolat all buffrad data till "
"pipen.  Detta anropas automatiskt när kön samlas in (garbage collected)."

msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Gå med i bakgrundstråden.  Detta kan endast användas efter att :meth:`close` "
"har anropats.  Den blockerar tills bakgrundstråden avslutas och säkerställer "
"att all data i bufferten har spolats till röret."

msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"Om en process inte är skaparen av kön kommer den som standard att försöka "
"ansluta sig till köns bakgrundstråd när den avslutas.  Processen kan anropa :"
"meth:`cancel_join_thread` för att få :meth:`join_thread` att inte göra "
"någonting."

msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Förhindrar :meth:`join_thread` från att blockera.  I synnerhet förhindrar "
"detta att bakgrundstråden ansluts automatiskt när processen avslutas -- se :"
"meth:`join_thread`."

msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"Ett bättre namn på den här metoden skulle kunna vara "
"``allow_exit_without_flush()``.  Det är troligt att köade data går förlorade "
"och du kommer nästan aldrig att behöva använda den. Den finns egentligen "
"bara där om du vill att den aktuella processen ska avslutas omedelbart utan "
"att vänta på att spola köade data till den underliggande pipen, och du inte "
"bryr dig om förlorade data."

msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"Funktionaliteten i denna klass kräver en fungerande implementation av delade "
"semaforer i värdoperativsystemet. Utan en sådan kommer funktionaliteten i "
"denna klass att inaktiveras, och försök att instansiera en :class:`Queue` "
"kommer att resultera i ett :exc:`ImportError`. Se :issue:`3770` för "
"ytterligare information.  Detsamma gäller för någon av de specialiserade "
"kötyper som listas nedan."

msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"Det är en förenklad :class:`Queue`-typ, mycket nära en låst :class:`Pipe`."

msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""
"En kö får inte längre användas efter att den har stängts. Till exempel får "
"metoderna :meth:`get`, :meth:`put` och :meth:`empty` inte längre anropas."

msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Returnerar ``True`` om kön är tom, annars ``False``."

msgid "Always raises an :exc:`OSError` if the SimpleQueue is closed."
msgstr "Ger alltid upphov till ett :exc:`OSError` om SimpleQueue stängs."

msgid "Remove and return an item from the queue."
msgstr "Ta bort och returnera ett objekt från kön."

msgid "Put *item* into the queue."
msgstr "Lägg *objekt* i kön."

msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, en underklass till :class:`Queue`, är en kö som "
"dessutom har metoderna :meth:`task_done` och :meth:`join`."

msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Anger att en tidigare köad uppgift är slutförd. Används av köanvändare.  För "
"varje :meth:`~Queue.get` som används för att hämta en uppgift, talar ett "
"efterföljande anrop till :meth:`task_done` om för kön att bearbetningen av "
"uppgiften är klar."

msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Om en :meth:`~queue.Queue.join` för närvarande blockeras kommer den att "
"återupptas när alla objekt har bearbetats (vilket innebär att ett :meth:"
"`task_done`-anrop har mottagits för varje objekt som har :meth:`~Queue.put` "
"i kön)."

msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Utlöser ett :exc:`ValueError` om den anropas fler gånger än det finns objekt "
"i kön."

msgid "Block until all items in the queue have been gotten and processed."
msgstr "Blockera tills alla objekt i kön har hämtats och behandlats."

msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"Antalet oavslutade uppgifter ökar varje gång ett objekt läggs till i kön.  "
"Antalet sjunker när en konsument anropar :meth:`task_done` för att ange att "
"objektet hämtades och att allt arbete med det är slutfört.  När antalet "
"oavslutade uppgifter sjunker till noll avblockeras :meth:`~queue.Queue.join`."

msgid "Miscellaneous"
msgstr "Diverse"

msgid "Return list of all live children of the current process."
msgstr ""
"Returnerar en lista över alla levande barn till den aktuella processen."

msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Om du anropar detta får det bieffekten att alla processer som redan har "
"avslutats \"ansluts\"."

msgid "Return the number of CPUs in the system."
msgstr "Returnerar antalet CPU:er i systemet."

msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with :func:`os."
"process_cpu_count` (or ``len(os.sched_getaffinity(0))``)."
msgstr ""
"Detta antal motsvarar inte det antal processorer som den aktuella processen "
"kan använda.  Antalet användbara processorer kan erhållas med :func:`os."
"process_cpu_count` (eller ``len(os.sched_getaffinity(0))``)."

msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""
"När antalet CPU:er inte kan bestämmas uppstår ett :exc:`NotImplementedError`."

msgid ":func:`os.cpu_count` :func:`os.process_cpu_count`"
msgstr ":func:`os.cpu_count` :func:`os.process_cpu_count`"

msgid ""
"The return value can also be overridden using the :option:`-X cpu_count <-"
"X>` flag or :envvar:`PYTHON_CPU_COUNT` as this is merely a wrapper around "
"the :mod:`os` cpu count APIs."
msgstr ""
"Returvärdet kan också åsidosättas med flaggan :option:`-X cpu_count <-X>` "
"eller :envvar:`PYTHON_CPU_COUNT` eftersom detta bara är ett omslag runt API:"
"erna för cpu-räkning i :mod:`os`."

msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr ""
"Returnerar :class:`Process`-objektet som motsvarar den aktuella processen."

msgid "An analogue of :func:`threading.current_thread`."
msgstr "En motsvarighet till :func:`threading.current_thread`."

msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"Returnerar :class:`Process`-objektet som motsvarar den överordnade processen "
"för :func:`current_process`. För huvudprocessen kommer ``parent_process`` "
"att vara ``None``."

msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce an executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Lägg till stöd för när ett program som använder :mod:`multiprocessing` har "
"frysts för att producera en körbar fil.  (Har testats med **py2exe**, "
"**PyInstaller** och **cx_Freeze**.)"

msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"Man måste anropa den här funktionen direkt efter raden ``if __name__ == "
"'__main__'`` i huvudmodulen.  Till exempel::"

msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hello world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"
msgstr ""
"från multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hej världen!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(mål=f).start()"

msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Om raden ``freeze_support()`` utelämnas kommer försök att köra den frysta "
"körbara filen att ge upphov till :exc:`RuntimeError`."

msgid ""
"Calling ``freeze_support()`` has no effect when the start method is not "
"*spawn*. In addition, if the module is being run normally by the Python "
"interpreter (the program has not been frozen), then ``freeze_support()`` has "
"no effect."
msgstr ""
"Anrop av ``freeze_support()`` har ingen effekt när startmetoden inte är "
"*spawn*. Dessutom, om modulen körs normalt av Python-tolken (programmet har "
"inte frysts), har ``freeze_support()`` ingen effekt."

msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  Not all platforms support all methods.  See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Returnerar en lista över de startmetoder som stöds, varav den första är "
"standard.  De möjliga startmetoderna är ``'fork'``, ``'spawn'`` och "
"``'forkserver'``.  Alla plattformar stöder inte alla metoder.  Se :ref:"
"`multiprocessing-start-methods`."

msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Returnerar ett kontextobjekt som har samma attribut som modulen :mod:"
"`multiprocessing`."

msgid ""
"If *method* is ``None`` then the default context is returned. Note that if "
"the global start method has not been set, this will set it to the default "
"method. Otherwise *method* should be ``'fork'``, ``'spawn'``, "
"``'forkserver'``.  :exc:`ValueError` is raised if the specified start method "
"is not available.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"Om *method* är ``None`` returneras standardkontexten. Observera att om den "
"globala startmetoden inte har ställts in, kommer detta att ställa in den "
"till standardmetoden. Annars bör *method* vara ``'fork'``, ``'spawn'``, "
"``'forkserver'``. :exc:`ValueError` uppstår om den angivna startmetoden inte "
"är tillgänglig.  Se :ref:`multiprocessing-start-methods`."

msgid "Return the name of start method used for starting processes."
msgstr ""
"Returnerar namnet på den startmetod som används för att starta processer."

msgid ""
"If the global start method has not been set and *allow_none* is ``False``, "
"then the start method is set to the default and the name is returned. If the "
"start method has not been set and *allow_none* is ``True`` then ``None`` is "
"returned."
msgstr ""
"Om den globala startmetoden inte har ställts in och *allow_none* är "
"``False``, ställs startmetoden in på standardvärdet och namnet returneras. "
"Om startmetoden inte har ställts in och *allow_none* är ``True`` returneras "
"``None``."

msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"Returvärdet kan vara ``'fork'``, ``'spawn'``, ``'forkserver'`` eller "
"``None``.  Se :ref:`multiprocessing-start-methods`."

msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"På macOS är startmetoden *spawn* nu standard.  Startmetoden *fork* bör "
"betraktas som osäker eftersom den kan leda till att underprocessen kraschar. "
"Se :issue:`33725`."

msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"Ange sökvägen till den Python-tolk som ska användas när en underordnad "
"process startas. (Som standard används :data:`sys.executable`).  Inbäddare "
"kommer förmodligen att behöva göra något i stil med ::"

msgid "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"
msgstr "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"

msgid "before they can create child processes."
msgstr "innan de kan skapa underordnade processer."

msgid "Now supported on POSIX when the ``'spawn'`` start method is used."
msgstr "Stödjs nu på POSIX när startmetoden ``'spawn'`` används."

msgid "Accepts a :term:`path-like object`."
msgstr "Accepterar en :term:`path-liknande objekt`."

msgid ""
"Set a list of module names for the forkserver main process to attempt to "
"import so that their already imported state is inherited by forked "
"processes. Any :exc:`ImportError` when doing so is silently ignored. This "
"can be used as a performance enhancement to avoid repeated work in every "
"process."
msgstr ""
"Ange en lista med modulnamn som huvudprocessen för forkserver ska försöka "
"importera så att deras redan importerade tillstånd ärvs av förgrenade "
"processer. Alla :exc:`ImportError` när detta görs ignoreras i tysthet. Detta "
"kan användas som en prestandaförbättring för att undvika upprepat arbete i "
"varje process."

msgid ""
"For this to work, it must be called before the forkserver process has been "
"launched (before creating a :class:`Pool` or starting a :class:`Process`)."
msgstr ""
"För att detta ska fungera måste det anropas innan forkserver-processen har "
"startats (innan du skapar en :class:`Pool` eller startar en :class:"
"`Process`)."

msgid ""
"Only meaningful when using the ``'forkserver'`` start method. See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Endast meningsfullt när man använder startmetoden ``'forkserver''. Se :ref:"
"`multiprocessing-start-methods`."

msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises :exc:"
"`RuntimeError` if the start method has already been set and *force* is not "
"``True``.  If *method* is ``None`` and *force* is ``True`` then the start "
"method is set to ``None``.  If *method* is ``None`` and *force* is ``False`` "
"then the context is set to the default context."
msgstr ""
"Ange vilken metod som ska användas för att starta underordnade processer. "
"Argumentet *method* kan vara ``'fork'``, ``'spawn'`` eller ``'forkserver'``. "
"Utlöser :exc:`RuntimeError` om startmetoden redan har ställts in och *force* "
"inte är ``True``.  Om *method* är ``None`` och *force* är ``True`` så sätts "
"startmetoden till ``None``.  Om *method* är ``None`` och *force* är "
"``False`` sätts kontexten till standardkontexten."

msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Observera att detta ska anropas högst en gång och att det ska skyddas i ``if "
"__name__ == '__main__'`` i huvudmodulens klausul."

msgid "See :ref:`multiprocessing-start-methods`."
msgstr "Se :ref:`multiprocessing-start-methods`."

msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` innehåller inga motsvarigheter till :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, eller :class:"
"`threading.local`."

msgid "Connection Objects"
msgstr "Anslutningsobjekt"

msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Connection-objekt gör det möjligt att skicka och ta emot plockbara objekt "
"eller strängar.  De kan betraktas som meddelandeorienterade anslutna socklar."

msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Anslutningsobjekt skapas vanligtvis med :func:`Pipe <multiprocessing.Pipe>` "
"-- se även :ref:`multiprocessing-listeners-clients`."

msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Skicka ett objekt till den andra änden av anslutningen som ska läsas med "
"hjälp av :meth:`recv`."

msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"Objektet måste kunna picklas.  Mycket stora pickles (ungefär 32 MiB+, men "
"det beror på operativsystemet) kan ge upphov till ett :exc:`ValueError`-"
"undantag."

msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Returnerar ett objekt som skickats från den andra änden av anslutningen med :"
"meth:`send`.  Blockerar tills det finns något att ta emot.  Utlöser :exc:"
"`EOFError` om det inte finns något kvar att ta emot och den andra änden var "
"stängd."

msgid "Return the file descriptor or handle used by the connection."
msgstr "Returnerar filbeskrivaren eller handtaget som används av anslutningen."

msgid "Close the connection."
msgstr "Stäng anslutningen."

msgid "This is called automatically when the connection is garbage collected."
msgstr "Detta anropas automatiskt när anslutningen garbage collectas."

msgid "Return whether there is any data available to be read."
msgstr "Returnerar om det finns någon data tillgänglig för läsning."

msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Om *timeout* inte anges kommer den att returnera omedelbart.  Om *timeout* "
"är ett tal anger detta den maximala tiden i sekunder för blockering.  Om "
"*timeout* är ``None`` används en oändlig timeout."

msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Observera att flera anslutningsobjekt kan pollas samtidigt genom att "
"använda :func:`multiprocessing.connection.wait`."

msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Skicka byte-data från ett :term:`bytesliknande objekt` som ett komplett "
"meddelande."

msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Om *offset* anges läses data från den positionen i *buffer*.  Om *size* "
"anges kommer så många byte att läsas från bufferten.  Mycket stora buffertar "
"(ungefär 32 MiB+, men det beror på operativsystemet) kan ge upphov till ett :"
"exc:`ValueError`-undantag"

msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Returnerar ett komplett meddelande med byte-data som skickats från den andra "
"änden av anslutningen som en sträng.  Blockerar tills det finns något att ta "
"emot. Utlöser :exc:`EOFError` om det inte finns något kvar att ta emot och "
"den andra änden har stängt."

msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Om *maxlength* anges och meddelandet är längre än *maxlength* så uppstår :"
"exc:`OSError` och anslutningen kommer inte längre att vara läsbar."

msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Denna funktion gav tidigare upphov till :exc:`IOError`, som nu är ett alias "
"för :exc:`OSError`."

msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Läser in i *buffer* ett komplett meddelande med byte-data som skickas från "
"den andra änden av anslutningen och returnerar antalet byte i meddelandet.  "
"Blockerar tills det finns något att ta emot.  Utlöser :exc:`EOFError` om det "
"inte finns något kvar att ta emot och den andra änden var stängd."

msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* måste vara ett skrivbart :term:`bytesliknande objekt`.  Om *offset* "
"anges kommer meddelandet att skrivas in i bufferten från den positionen.  "
"Offset måste vara ett icke-negativt heltal som är mindre än längden på "
"*buffer* (i byte)."

msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Om bufferten är för kort uppstår ett :exc:`BufferTooShort` undantag och det "
"fullständiga meddelandet finns tillgängligt som ``e.args[0]`` där ``e`` är "
"undantagsinstansen."

msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Själva anslutningsobjekten kan nu överföras mellan processer med hjälp av :"
"meth:`Connection.send` och :meth:`Connection.recv`."

msgid ""
"Connection objects also now support the context management protocol -- see :"
"ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Anslutningsobjekt stöder nu också kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` returnerar "
"anslutningsobjektet och :meth:`~contextmanager.__exit__` anropar :meth:"
"`close`."

msgid "For example:"
msgstr "Till exempel:"

msgid ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"
msgstr ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"

msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"Metoden :meth:`Connection.recv` avplockar automatiskt de data den tar emot, "
"vilket kan vara en säkerhetsrisk om du inte kan lita på den process som "
"skickade meddelandet."

msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Om inte anslutningsobjektet producerades med :func:`Pipe` bör du därför "
"endast använda metoderna :meth:`~Connection.recv` och :meth:`~Connection."
"send` efter att ha utfört någon form av autentisering.  Se :ref:"
"`multiprocessing-auth-keys`."

msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Om en process dödas medan den försöker läsa eller skriva till en pipe kommer "
"data i pipen sannolikt att korrumperas, eftersom det kan bli omöjligt att "
"vara säker på var meddelandegränserna ligger."

msgid "Synchronization primitives"
msgstr "Synkroniseringsprimitiver"

msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"Generellt sett är synkroniseringsprimitiver inte lika nödvändiga i ett "
"multiprocessprogram som i ett flertrådat program.  Se dokumentationen för "
"modulen :mod:`threading`."

msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Observera att man också kan skapa synkroniseringsprimitiver genom att "
"använda ett manager-objekt -- se :ref:`multiprocessing-managers`."

msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Ett barriärobjekt: en klon av :class:`threading.Barrier`."

msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Ett begränsat semaforobjekt: en nära analog till :class:`threading."
"BoundedSemaphore`."

msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"En enda skillnad från dess nära analog finns: dess ``acquire``-metods första "
"argument heter *block*, vilket är i överensstämmelse med :meth:`Lock."
"acquire`."

msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"På macOS kan detta inte skiljas från :class:`Semaphore` eftersom "
"``sem_getvalue()`` inte är implementerat på den plattformen."

msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "En villkorsvariabel: ett alias för :class:`threading.Condition`."

msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Om *lock* anges bör det vara ett :class:`Lock`- eller :class:`RLock`-objekt "
"från :mod:`multiprocessing`."

msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "Metoden :meth:`~threading.Condition.wait_for` lades till."

msgid "A clone of :class:`threading.Event`."
msgstr "En klon av :class:`threading.Event`."

msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Ett icke-rekursivt låsobjekt: en nära motsvarighet till :class:`threading."
"Lock`. När en process eller tråd har förvärvat ett lås kommer efterföljande "
"försök att förvärva det från någon annan process eller tråd att blockeras "
"tills det släpps; vilken process eller tråd som helst kan släppa det.  "
"Koncepten och beteendena i :class:`threading.Lock` som gäller för trådar är "
"replikerade här i :class:`multiprocessing.Lock` som gäller för antingen "
"processer eller trådar, förutom vad som anges."

msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Observera att :class:`Lock` faktiskt är en fabriksfunktion som returnerar en "
"instans av ``multiprocessing.synchronize.Lock`` initialiserad med en "
"standardkontext."

msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` stöder protokollet :term:`context manager` och kan därför "
"användas i :keyword:`with`-satser."

msgid "Acquire a lock, blocking or non-blocking."
msgstr "Förvärva ett lås, blockerande eller icke-blockerande."

msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Med *block*-argumentet inställt på ``True`` (standard) kommer metodanropet "
"att blockera tills låset är i ett olåst tillstånd, sedan ställa in det på "
"låst och returnera ``True``.  Observera att namnet på detta första argument "
"skiljer sig från det i :meth:`threading.Lock.acquire`."

msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Om argumentet *block* är satt till ``False`` blockeras inte metodanropet.  "
"Om låset för närvarande är i låst tillstånd returneras ``False``; annars "
"sätts låset i låst tillstånd och returneras ``True``."

msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"När *timeout* anropas med ett positivt värde i flyttal, blockeras låset i "
"högst det antal sekunder som anges av *timeout* så länge låset inte kan "
"förvärvas.  Anrop med ett negativt värde för *timeout* är likvärdigt med en "
"*timeout* på noll.  Anrop med ett *timeout*-värde på ``None`` (standard) "
"sätter timeout-perioden till oändlig.  Observera att behandlingen av "
"negativa eller ``None``-värden för *timeout* skiljer sig från det "
"implementerade beteendet i :meth:`threading.Lock.acquire`.  Argumentet "
"*timeout* har inga praktiska konsekvenser om argumentet *block* är satt till "
"``False`` och ignoreras därför.  Returnerar ``True`` om låset har förvärvats "
"eller ``False`` om timeout-perioden har löpt ut."

msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Frigör ett lås.  Detta kan anropas från vilken process eller tråd som helst, "
"inte bara från den process eller tråd som ursprungligen förvärvade låset."

msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"Beteendet är detsamma som i :meth:`threading.Lock.release` förutom att ett :"
"exc:`ValueError` uppstår när det anropas på ett olåst lås."

msgid "Return a boolean indicating whether this object is locked right now."
msgstr "Returnerar en boolean som anger om detta objekt är låst just nu."

msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Ett rekursivt låsobjekt: en nära motsvarighet till :class:`threading."
"RLock`.  Ett rekursivt lås måste frigöras av den process eller tråd som "
"förvärvade det. När en process eller tråd har förvärvat ett rekursivt lås "
"kan samma process eller tråd förvärva det igen utan att blockera; den "
"processen eller tråden måste släppa det en gång för varje gång det har "
"förvärvats."

msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Observera att :class:`RLock` faktiskt är en fabriksfunktion som returnerar "
"en instans av ``multiprocessing.synchronize.RLock`` initialiserad med en "
"standardkontext."

msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` stöder protokollet :term:`context manager` och kan därför "
"användas i :keyword:`with`-satser."

msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"När den anropas med argumentet *block* inställt på ``True`` blockeras den "
"tills låset är olåst (inte ägs av någon process eller tråd) om inte låset "
"redan ägs av den aktuella processen eller tråden.  Den aktuella processen "
"eller tråden tar då över ägandet av låset (om den inte redan har ägandet) "
"och rekursionsnivån inuti låset ökar med ett, vilket resulterar i ett "
"returvärde på ``True``.  Observera att det finns flera skillnader i detta "
"första arguments beteende jämfört med implementeringen av :meth:`threading."
"RLock.acquire`, som börjar med namnet på själva argumentet."

msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"När den anropas med argumentet *block* satt till ``False``, blockeras inte. "
"Om låset redan har förvärvats (och därmed ägs) av en annan process eller "
"tråd, tar den aktuella processen eller tråden inte över ägandet och "
"rekursionsnivån i låset ändras inte, vilket resulterar i ett returvärde på "
"``False``.  Om låset är olåst tar den aktuella processen eller tråden över "
"ägandet och rekursionsnivån ökas, vilket resulterar i ett returvärde på "
"``True``."

msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"Användning och beteenden för argumentet *timeout* är desamma som i :meth:"
"`Lock.acquire`.  Observera att vissa av dessa beteenden hos *timeout* "
"skiljer sig från de implementerade beteendena i :meth:`threading.RLock."
"acquire`."

msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Frigör ett lås och dekrementera rekursionsnivån.  Om rekursionsnivån är noll "
"efter dekrementeringen, återställ låset till olåst (ägs inte av någon "
"process eller tråd) och om några andra processer eller trådar är blockerade "
"i väntan på att låset ska bli olåst, låt exakt en av dem fortsätta.  Om "
"rekursionsnivån efter dekrementeringen fortfarande inte är noll, förblir "
"låset låst och ägs av den anropande processen eller tråden."

msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"Anropa endast denna metod när den anropande processen eller tråden äger "
"låset. Ett :exc:`AssertionError` uppstår om denna metod anropas av en annan "
"process eller tråd än ägaren eller om låset är i ett olåst (oägt) "
"tillstånd.  Observera att den typ av undantag som uppstår i denna situation "
"skiljer sig från det implementerade beteendet i :meth:`threading.RLock."
"release`."

msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr ""
"Ett semaforobjekt: en nära motsvarighet till :class:`threading.Semaphore`."

msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"På macOS stöds inte ```em_timedwait``, så om du anropar ``acquire()`` med en "
"timeout kommer den funktionens beteende att emuleras med en sovande loop."

msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"En del av funktionaliteten i detta paket kräver en fungerande implementation "
"av delade semaforer i värdoperativsystemet. Utan en sådan kommer modulen :"
"mod:`multiprocessing.synchronize` att inaktiveras och försök att importera "
"den kommer att resultera i ett :exc:`ImportError`. Se :issue:`3770` för "
"ytterligare information."

msgid "Shared :mod:`ctypes` Objects"
msgstr "Delade :mod:`ctypes`-objekt"

msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"Det är möjligt att skapa delade objekt med hjälp av delat minne som kan "
"ärvas av underordnade processer."

msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Returnerar ett :mod:`ctypes`-objekt som allokerats från ett delat minne.  "
"Som standard är returvärdet faktiskt ett synkroniserat omslag för objektet.  "
"Själva objektet kan nås via *value*-attributet i en :class:`Value`."

msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* bestämmer typen av det returnerade objektet: det är "
"antingen en ctypes-typ eller en typkod med ett tecken av den typ som används "
"av modulen :mod:`array`.  *\\*args* skickas vidare till konstruktören för "
"typen."

msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Om *lock* är ``True`` (standard) skapas ett nytt rekursivt låsobjekt för att "
"synkronisera åtkomsten till värdet.  Om *lock* är ett :class:`Lock`- eller :"
"class:`RLock`-objekt kommer det att användas för att synkronisera åtkomst "
"till värdet.  Om *lock* är ``False`` kommer åtkomst till det returnerade "
"objektet inte automatiskt att skyddas av ett lås, så det kommer inte "
"nödvändigtvis att vara \"processäkert\"."

msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Operationer som ``+=`` som involverar en läsning och skrivning är inte "
"atomiska.  Så om du till exempel vill öka ett delat värde atomiskt räcker "
"det inte med att bara göra ::"

msgid "counter.value += 1"
msgstr "räknare.värde += 1"

msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"Förutsatt att det associerade låset är rekursivt (vilket det är som "
"standard) kan du istället göra ::"

msgid ""
"with counter.get_lock():\n"
"    counter.value += 1"
msgstr ""
"med counter.get_lock():\n"
"    räknare.värde += 1"

msgid "Note that *lock* is a keyword-only argument."
msgstr "Observera att *lock* är ett argument som endast gäller nyckelord."

msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Returnerar en ctypes-array som allokerats från delat minne.  Som standard är "
"returvärdet faktiskt ett synkroniserat omslag för arrayen."

msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* bestämmer typen av element i den returnerade matrisen: "
"det är antingen en ctypes-typ eller en typkod med ett tecken av den typ som "
"används av modulen :mod:`array`.  Om *size_or_initializer* är ett heltal "
"bestämmer det längden på arrayen, och arrayen nollställs initialt. I annat "
"fall är *size_or_initializer* en sekvens som används för att initiera "
"arrayen och vars längd bestämmer arrayens längd."

msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Om *lock* är ``True`` (standard) skapas ett nytt låsobjekt för att "
"synkronisera åtkomsten till värdet.  Om *lock* är ett :class:`Lock`- eller :"
"class:`RLock`-objekt kommer det att användas för att synkronisera åtkomst "
"till värdet.  Om *lock* är ``False`` kommer åtkomsten till det returnerade "
"objektet inte automatiskt att skyddas av ett lås, så det är inte "
"nödvändigtvis \"processäkert\"."

msgid "Note that *lock* is a keyword only argument."
msgstr "Observera att *lock* endast är ett nyckelordsargument."

msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Observera att en array av :data:`ctypes.c_char` har attributen *value* och "
"*raw* som gör att man kan använda den för att lagra och hämta strängar."

msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ""
"Modulen :mod:`multiprocessing.sharedctypes` (multiprocessing.sharedctypes)"

msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"Modulen :mod:`multiprocessing.sharedctypes` tillhandahåller funktioner för "
"allokering av :mod:`ctypes`-objekt från delat minne som kan ärvas av "
"underordnade processer."

msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Även om det är möjligt att lagra en pekare i ett delat minne bör man komma "
"ihåg att den kommer att referera till en plats i adressrymden för en "
"specifik process. Det är dock mycket troligt att pekaren är ogiltig i en "
"andra process och om man försöker dereferentiera pekaren från den andra "
"processen kan det leda till en krasch."

msgid "Return a ctypes array allocated from shared memory."
msgstr "Returnerar en ctypes-array som allokerats från delat minne."

msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* bestämmer typen av element i den returnerade matrisen: "
"det är antingen en ctypes-typ eller en typkod med ett tecken av den typ som "
"används av modulen :mod:`array`.  Om *size_or_initializer* är ett heltal "
"bestämmer det längden på arrayen, och arrayen nollställs initialt. Annars är "
"*size_or_initializer* en sekvens som används för att initiera arrayen och "
"vars längd bestämmer arrayens längd."

msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Observera att det kan vara icke-atomiskt att sätta och hämta ett element - "
"använd :func:`Array` istället för att se till att åtkomsten automatiskt "
"synkroniseras med hjälp av ett lås."

msgid "Return a ctypes object allocated from shared memory."
msgstr "Returnerar ett ctypes-objekt som allokerats från delat minne."

msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Observera att inställning och hämtning av värdet potentiellt är icke-"
"atomiskt -- använd :func:`Value` istället för att se till att åtkomsten "
"automatiskt synkroniseras med hjälp av ett lås."

msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Observera att en array av :data:`ctypes.c_char` har attributen ``value`` och "
"``raw`` som gör att man kan använda den för att lagra och hämta strängar -- "
"se dokumentation för :mod:`ctypes`."

msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"Samma sak som :func:`RawArray` förutom att beroende på värdet av *lock* kan "
"en processäker synkroniseringsomslag returneras istället för en rå ctypes-"
"array."

msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Om *lock* är ``True`` (standard) skapas ett nytt låsobjekt för att "
"synkronisera åtkomst till värdet.  Om *lock* är ett :class:`~multiprocessing."
"Lock`- eller :class:`~multiprocessing.RLock`-objekt kommer det att användas "
"för att synkronisera åtkomst till värdet.  Om *lock* är ``False`` kommer "
"åtkomst till det returnerade objektet inte automatiskt att skyddas av ett "
"lås, så det kommer inte nödvändigtvis att vara \"processäkert\"."

msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"Samma sak som :func:`RawValue` förutom att beroende på värdet av *lock* kan "
"en processäker synkroniseringsomslag returneras istället för ett rått ctypes-"
"objekt."

msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Returnerar ett ctypes-objekt som allokerats från delat minne och som är en "
"kopia av ctypes-objektet *obj*."

msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Returnerar ett processäkert omslagsobjekt för ett ctypes-objekt som använder "
"*lock* för att synkronisera åtkomst.  Om *lock* är ``None`` (standard) så "
"skapas ett :class:`multiprocessing.RLock`-objekt automatiskt."

msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"En synkroniserad wrapper har två metoder utöver metoderna för det objekt som "
"den omsluter: :meth:`get_obj` returnerar det omslutna objektet och :meth:"
"`get_lock` returnerar det låsobjekt som används för synkronisering."

msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"Observera att det kan vara mycket långsammare att komma åt ctypes-objektet "
"via omslaget än att komma åt det obearbetade ctypes-objektet."

msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "Synkroniserade objekt stöder protokollet :term:`context manager`."

msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"I tabellen nedan jämförs syntaxen för att skapa delade ctypes-objekt från "
"delat minne med den normala ctypes-syntaxen.  (I tabellen är ``MyStruct`` en "
"underklass till :class:`ctypes.Structure`.)"

msgid "ctypes"
msgstr "ctyper"

msgid "sharedctypes using type"
msgstr "sharedctypes använder typ"

msgid "sharedctypes using typecode"
msgstr "delade typer med hjälp av typkod"

msgid "c_double(2.4)"
msgstr "c_double(2,4)"

msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2,4)"

msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray(\"i\", (9, 2, 8))"

msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""
"Nedan följer ett exempel där ett antal ctypes-objekt ändras av en "
"underordnad process::"

msgid ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"
msgstr ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"

msgid "The results printed are ::"
msgstr "De resultat som skrivs ut är ::"

msgid ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"
msgstr ""
"49\n"
"0.1111111111111111\n"
"HALLÅ VÄRLDEN\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"

msgid "Managers"
msgstr "Ansvariga"

msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"Managers är ett sätt att skapa data som kan delas mellan olika processer, "
"inklusive delning över ett nätverk mellan processer som körs på olika "
"maskiner. Ett manager-objekt kontrollerar en serverprocess som hanterar "
"*delade objekt*.  Andra processer kan komma åt de delade objekten genom att "
"använda proxies."

msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"Returnerar ett startat :class:`~multiprocessing.managers.SyncManager`-objekt "
"som kan användas för att dela objekt mellan processer.  Det returnerade "
"manager-objektet motsvarar en skapad underordnad process och har metoder som "
"skapar delade objekt och returnerar motsvarande proxyer."

msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"Managerprocesser kommer att stängas av så snart som de är garbage collected "
"eller deras överordnade process avslutas.  Managerklasserna är definierade i "
"modulen :mod:`multiprocessing.managers`:"

msgid "Create a BaseManager object."
msgstr "Skapa ett BaseManager-objekt."

msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"När den har skapats bör man anropa :meth:`start` eller ``get_server()."
"serve_forever()`` för att säkerställa att managerobjektet refererar till en "
"startad managerprocess."

msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* är den adress på vilken manager-processen lyssnar efter nya "
"anslutningar.  Om *address* är ``None`` så väljs en godtycklig adress."

msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* är autentiseringsnyckeln som kommer att användas för att "
"kontrollera giltigheten av inkommande anslutningar till serverprocessen.  Om "
"*authkey* är ``None`` används ``current_process().authkey``. Annars används "
"*authkey* och den måste vara en byte-sträng."

msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""
"*serializer* måste vara ``'pickle'`` (använd :mod:`pickle` serialisering) "
"eller ``'xmlrpclib'`` (använd :mod:`xmlrpc.client` serialisering)."

msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the :"
"func:`get_context` function."
msgstr ""
"*ctx* är ett kontextobjekt, eller ``None`` (använd aktuell kontext). Se "
"funktionen :func:`get_context`."

msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""
"*shutdown_timeout* är en timeout i sekunder som används för att vänta tills "
"den process som används av förvaltaren avslutas i metoden :meth:`shutdown`. "
"Om tiden för nedstängning går ut avslutas processen. Om det också tar tid "
"att avsluta processen dödas processen."

msgid "Added the *shutdown_timeout* parameter."
msgstr "Parametern *shutdown_timeout* har lagts till."

msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"Starta en underprocess för att starta hanteraren.  Om *initializer* inte är "
"``None`` kommer underprocessen att anropa ``initializer(*initargs)`` när den "
"startar."

msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"Returnerar ett :class:`Server`-objekt som representerar den faktiska servern "
"under Managerns kontroll. Objektet :class:`Server` har stöd för metoden :"
"meth:`serve_forever`::"

msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(adress=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"

msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` har dessutom ett attribut :attr:`address`."

msgid "Connect a local manager object to a remote manager process::"
msgstr "Anslut ett lokalt managerobjekt till en fjärrmanagerprocess::"

msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(adress=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"

msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"Stoppar den process som används av hanteraren.  Detta är endast tillgängligt "
"om :meth:`start` har använts för att starta serverprocessen."

msgid "This can be called multiple times."
msgstr "Detta kan anropas flera gånger."

msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"En klassmetod som kan användas för att registrera en typ eller en anropsbar "
"kod hos managerklassen."

msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeid* är en \"typidentifierare\" som används för att identifiera en viss "
"typ av delat objekt.  Detta måste vara en sträng."

msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* är en callable som används för att skapa objekt för denna "
"typidentifierare.  Om en manager-instans kommer att anslutas till servern "
"med :meth:`connect`-metoden, eller om *create_method*-argumentet är "
"``False``, kan detta lämnas som ``None``."

msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* är en underklass till :class:`BaseProxy` som används för att "
"skapa proxy för delade objekt med detta *typeid*.  Om ``None`` så skapas en "
"proxyklass automatiskt."

msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* används för att ange en sekvens av metodnamn som proxyer för detta "
"typeid ska få tillgång till med hjälp av :meth:`BaseProxy._callmethod`.  (Om "
"*exposed* är ``None`` används istället :attr:`proxytype._exposed_` om den "
"finns)  Om ingen exponerad lista anges kommer alla \"offentliga metoder\" i "
"det delade objektet att vara tillgängliga.  (Här betyder en \"publik metod\" "
"alla attribut som har en :meth:`~object.__call__`-metod och vars namn inte "
"börjar med ``'_'``)"

msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* är en mappning som används för att ange returtypen för de "
"exponerade metoder som ska returnera en proxy.  Den mappar metodnamn till "
"typid-strängar.  (Om *method_to_typeid* är ``None`` används istället :attr:"
"`proxytype._method_to_typeid_` om den finns)  Om en metods namn inte är en "
"nyckel i denna mappning eller om mappningen är ``None`` kommer det objekt "
"som returneras av metoden att kopieras med värde."

msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* avgör om en metod ska skapas med namnet *typeid* som kan "
"användas för att tala om för serverprocessen att den ska skapa ett nytt "
"delat objekt och returnera en proxy för det.  Som standard är det ``True``."

msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager`-instanser har också en skrivskyddad egenskap:"

msgid "The address used by the manager."
msgstr "Den adress som används av chefen."

msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"Manager-objekt stöder kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` startar "
"serverprocessen (om den inte redan har startat) och returnerar sedan manager-"
"objektet. :meth:`~contextmanager.__exit__` anropar :meth:`shutdown`."

msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"I tidigare versioner :meth:`~contextmanager.__enter__` startade inte "
"managerns serverprocess om den inte redan var startad."

msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"En underklass till :class:`BaseManager` som kan användas för synkronisering "
"av processer.  Objekt av denna typ returneras av :func:`multiprocessing."
"Manager`."

msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"Dess metoder skapar och returnerar :ref:`multiprocessing-proxy_objects` för "
"ett antal vanligt förekommande datatyper som ska synkroniseras mellan "
"processer. Detta inkluderar särskilt delade listor och lexikon."

msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.Barrier'-objekt och returnera en proxy för "
"det."

msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.BoundedSemaphore'-objekt och returnera en "
"proxy för det."

msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"Skapa ett delat :class:`threading.Condition`-objekt och returnera en proxy "
"för det."

msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"Om *lock* anges bör det vara en proxy för ett :class:`threading.Lock`- "
"eller :class:`threading.RLock`-objekt."

msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.Event'-objekt och returnera en proxy för "
"det."

msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.Lock`-objekt och returnera en proxy för "
"det."

msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`Namespace`-objekt och returnera en proxy för det."

msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`queue.Queue'-objekt och returnera en proxy för det."

msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"Skapa ett delat :class:`threading.RLock`-objekt och returnera en proxy för "
"det."

msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"Skapa ett delat :class:`threading.Semaphore'-objekt och returnera en proxy "
"för det."

msgid "Create an array and return a proxy for it."
msgstr "Skapa en array och returnera en proxy för den."

msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""
"Skapa ett objekt med ett skrivbart ``value``-attribut och returnera en proxy "
"för det."

msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "Skapa ett delat :class:`dict`-objekt och returnera en proxy för det."

msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "Skapa ett delat :class:`list`-objekt och returnera en proxy för det."

msgid "Create a shared :class:`set` object and return a proxy for it."
msgstr "Skapa ett delat :class:`set`-objekt och returnera en proxy för det."

msgid ":class:`set` support was added."
msgstr "stöd för :class:`set` har lagts till."

msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"Delade objekt kan vara nästlade.  Ett delat containerobjekt, t.ex. en delad "
"lista, kan innehålla andra delade objekt som alla hanteras och synkroniseras "
"av :class:`SyncManager`."

msgid "A type that can register with :class:`SyncManager`."
msgstr "En typ som kan registreras med :class:`SyncManager`."

msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Ett namespace-objekt har inga publika metoder, men har skrivbara attribut. "
"Dess representation visar värdena för dess attribut."

msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"När man använder en proxy för ett namnrymdsobjekt kommer dock ett attribut "
"som börjar med ``'_'`` att vara ett attribut för proxyn och inte ett "
"attribut för referenten:"

msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # this is an attribute of the proxy\n"
">>> print(Global)\n"
"Namespace(x=10, y='hello')"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hallå'\n"
">>> Global._z = 12.3 # detta är ett attribut för proxyn\n"
">>> print(Global)\n"
"Namespace(x=10, y='hallå')"

msgid "Customized managers"
msgstr "Skräddarsydda chefer"

msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"För att skapa en egen manager skapar man en subklass av :class:`BaseManager` "
"och använder klassmetoden :meth:`~BaseManager.register` för att registrera "
"nya typer eller anropbara objekt i managerklassen.  Till exempel::"

msgid ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # prints 7\n"
"        print(maths.mul(7, 8))         # prints 56"
msgstr ""
"från multiprocessing.managers import BaseManager\n"
"\n"
"klass MathsClass:\n"
"    def add(self, x, y):\n"
"        returnerar x + y\n"
"    def mul(self, x, y):\n"
"        returnerar x * y\n"
"\n"
"klass MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    med MyManager() som manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # skriver ut 7\n"
"        print(maths.mul(7, 8))         # skriver ut 56"

msgid "Using a remote manager"
msgstr "Använda en fjärrstyrd manager"

msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"Det är möjligt att köra en manager-server på en maskin och låta klienter "
"använda den från andra maskiner (förutsatt att de berörda brandväggarna "
"tillåter det)."

msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"Om du kör följande kommandon skapas en server för en enda delad kö som "
"fjärrklienter kan komma åt::"

msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"

msgid "One client can access the server as follows::"
msgstr "En klient kan komma åt servern på följande sätt::"

msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(adress=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> kö = m.hämta_kö()\n"
">>> queue.put('hej')"

msgid "Another client can also use it::"
msgstr "En annan kund kan också använda den::"

msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(adress=('foo.bar.org', 50000), authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> kö = m.get_queue()\n"
">>> queue.get()\n"
"'hej'"

msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"Lokala processer kan också komma åt den kön genom att använda koden från "
"ovan på klienten för att komma åt den på distans::"

msgid ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"

msgid "Proxy Objects"
msgstr "Proxy-objekt"

msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"En proxy är ett objekt som *refererar* till ett delat objekt som lever "
"(förmodligen) i en annan process.  Det delade objektet sägs vara proxyns "
"*referent*.  Flera proxyobjekt kan ha samma referent."

msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"Ett proxyobjekt har metoder som anropar motsvarande metoder hos sin referent "
"(även om inte alla metoder hos referenten nödvändigtvis är tillgängliga via "
"proxyn).  På så sätt kan en proxy användas precis som dess referent kan:"

msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> Skriv ut(repr(l))\n"
"<ListProxy-objekt, typid 'list' vid 0x...> >>> l[4\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"

msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"Observera att om du använder :func:`str` på en proxy kommer representationen "
"av referenten att returneras, medan om du använder :func:`repr` kommer "
"representationen av proxyn att returneras."

msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"En viktig egenskap hos proxyobjekt är att de kan plockas upp så att de kan "
"skickas mellan processer.  Som sådan kan en referent innehålla :ref:"
"`multiprocessing-proxy_objects`.  Detta tillåter nestning av dessa hanterade "
"listor, dicts och andra :ref:`multiprocessing-proxy_objects`:"

msgid ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referent of a now contains referent of b\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hello'] ['hello']"
msgstr ""
">>> a = chef.lista()\n"
">>> b = chef.lista()\n"
">>> a.append(b) # referent av a innehåller nu referent av b\n"
">>> print(a, b)\n"
"[<ListProxy-objekt, typid 'list' vid ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hallå'] ['hallå']"

msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr "På samma sätt kan dict- och list-proxies vara inbäddade i varandra::"

msgid ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"
msgstr ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"

msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"Om standard (icke-proxy) :class:`list`- eller :class:`dict`-objekt finns i "
"en referent, kommer ändringar av dessa föränderliga värden inte att spridas "
"genom hanteraren eftersom proxyn inte har något sätt att veta när de värden "
"som finns i den ändras.  Att lagra ett värde i en containerproxy (vilket "
"utlöser en ``__setitem__`` på proxyobjektet) sprids dock genom hanteraren "
"och för att effektivt modifiera ett sådant objekt kan man därför tilldela "
"det modifierade värdet till containerproxyn igen::"

msgid ""
"# create a list proxy and append a mutable object (a dictionary)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# now mutate the dictionary\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# at this point, the changes to d are not yet synced, but by\n"
"# updating the dictionary, the proxy is notified of the change\n"
"lproxy[0] = d"
msgstr ""
"# skapa en listproxy och lägg till ett föränderligt objekt (en ordbok)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# mutera nu ordboken\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# Vid den här tidpunkten är ändringarna i d ännu inte synkroniserade, men "
"genom att\n"
"# uppdatering av ordlistan meddelas proxyn om ändringen\n"
"lproxy[0] = d"

msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"Detta tillvägagångssätt är kanske mindre bekvämt än att använda nästlade :"
"ref:`multiprocessing-proxy_objects` för de flesta användningsfall, men det "
"ger också en viss kontroll över synkroniseringen."

msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
"Proxytyperna i :mod:`multiprocessing` har inget stöd för värdejämförelser.  "
"Så, till exempel, vi har:"

msgid ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"
msgstr ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"Falsk"

msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""
"Man bör bara använda en kopia av referenten istället när man gör jämförelser."

msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "Proxyobjekt är instanser av underklasser till :class:`BaseProxy`."

msgid "Call and return the result of a method of the proxy's referent."
msgstr "Anropa och returnera resultatet av en metod i proxyns referent."

msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "Om ``proxy`` är en proxy vars referent är ``obj`` så är uttrycket ::"

msgid "proxy._callmethod(methodname, args, kwds)"
msgstr "proxy._callmethod(metodnamn, args, kwds)"

msgid "will evaluate the expression ::"
msgstr "kommer att utvärdera uttrycket ::"

msgid "getattr(obj, methodname)(*args, **kwds)"
msgstr "getattr(obj, metodnamn)(*args, **kwds)"

msgid "in the manager's process."
msgstr "i chefens process."

msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"Det returnerade värdet är en kopia av resultatet av anropet eller en proxy "
"till ett nytt delat objekt - se dokumentation för argumentet "
"*method_to_typeid* i :meth:`BaseManager.register`."

msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"Om ett undantag uppstår vid anropet, uppstår det på nytt genom :meth:"
"`_callmethod`.  Om något annat undantag uppstår i chefens process så "
"konverteras detta till ett :exc:`RemoteError` undantag och uppstår genom :"
"meth:`_callmethod`."

msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"Observera särskilt att ett undantag kommer att uppstå om *methodname* inte "
"har *exposed*."

msgid "An example of the usage of :meth:`_callmethod`:"
msgstr "Ett exempel på användning av :meth:`_callmethod`:"

msgid ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalent to l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # equivalent to l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"
msgstr ""
">>> l = manager.list(intervall(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # likvärdig med l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # motsvarar l[20]\n"
"Traceback (senaste anropet senast):\n"
"...\n"
"IndexError: listindex utanför intervallet"

msgid "Return a copy of the referent."
msgstr "Returnera en kopia av referenten."

msgid "If the referent is unpicklable then this will raise an exception."
msgstr ""
"Om referensen inte är betningsbar kommer detta att leda till ett undantag."

msgid "Return a representation of the proxy object."
msgstr "Returnerar en representation av proxyobjektet."

msgid "Return the representation of the referent."
msgstr "Returnera representationen av referenten."

msgid "Cleanup"
msgstr "Rensa upp"

msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"Ett proxyobjekt använder ett weakref-callback så att det avregistrerar sig "
"från den manager som äger dess referent när det samlas in."

msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"Ett delat objekt tas bort från managerprocessen när det inte längre finns "
"några proxyer som hänvisar till det."

msgid "Process Pools"
msgstr "Processpooler"

msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
"Med klassen :class:`Pool` kan man skapa en pool av processer som utför "
"uppgifter som skickas till den."

msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"Ett processpoolobjekt som kontrollerar en pool av arbetsprocesser till vilka "
"jobb kan skickas.  Det stöder asynkrona resultat med timeouts och callbacks "
"och har en parallell map-implementering."

msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* är antalet arbetsprocesser som ska användas.  Om *processes* är "
"``None`` används det antal som returneras av :func:`os.process_cpu_count`."

msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"Om *initializer* inte är ``None`` kommer varje arbetsprocess att anropa "
"``initializer(*initargs)`` när den startar."

msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* är antalet uppgifter som en arbetsprocess kan slutföra "
"innan den avslutas och ersätts med en ny arbetsprocess, så att oanvända "
"resurser kan frigöras. Standardvärdet för *maxtasksperchild* är ``None``, "
"vilket innebär att arbetsprocesser kommer att leva lika länge som poolen."

msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* kan användas för att ange den kontext som används för att starta "
"arbetsprocesserna.  Vanligtvis skapas en pool med hjälp av funktionen :func:"
"`multiprocessing.Pool` eller metoden :meth:`Pool` i ett context-objekt.  I "
"båda fallen anges *context* på lämpligt sätt."

msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""
"Observera att metoderna i poolobjektet endast ska anropas av den process som "
"skapade poolen."

msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""
":class:`multiprocessing.pool`-objekt har interna resurser som måste hanteras "
"korrekt (som alla andra resurser) genom att använda poolen som en "
"kontexthanterare eller genom att anropa :meth:`close` och :meth:`terminate` "
"manuellt. Om detta inte görs kan det leda till att processen hänger sig när "
"den ska slutföras."

msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"Observera att det är **inte korrekt** att förlita sig på att skräpsamlaren "
"förstör poolen eftersom CPython inte garanterar att poolens finalizer kommer "
"att anropas (se :meth:`object.__del__` för mer information)."

msgid "Added the *maxtasksperchild* parameter."
msgstr "Parametern *maxtasksperchild* har lagts till."

msgid "Added the *context* parameter."
msgstr "Parametern *context* har lagts till."

msgid ""
"*processes* uses :func:`os.process_cpu_count` by default, instead of :func:"
"`os.cpu_count`."
msgstr ""
"*processes* använder :func:`os.process_cpu_count` som standard, istället "
"för :func:`os.cpu_count`."

msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"Arbetsprocesser inom en :class:`Pool` lever normalt under hela den tid som "
"poolens arbetskö varar. Ett vanligt mönster i andra system (t.ex. Apache, "
"mod_wsgi, etc.) för att frigöra resurser som hålls av arbetare är att låta "
"en arbetare i en pool endast slutföra en viss mängd arbete innan den "
"avslutas, rensas upp och en ny process skapas för att ersätta den gamla. "
"Argumentet *maxtasksperchild* till :class:`Pool` gör denna möjlighet "
"tillgänglig för slutanvändaren."

msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"Anropa *func* med argumenten *args* och nyckelordsargumenten *kwds*.  Den "
"blockerar tills resultatet är klart. Med tanke på dessa blockeringar är :"
"meth:`apply_async` bättre lämpad för att utföra arbete parallellt. Dessutom "
"utförs *func* endast i en av poolens arbetare."

msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"En variant av metoden :meth:`apply` som returnerar ett :class:"
"`~multiprocessing.pool.AsyncResult`-objekt."

msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"Om *callback* specificeras ska det vara en callable som accepterar ett enda "
"argument.  När resultatet är klart används *callback* på det, såvida inte "
"anropet misslyckades, i vilket fall *error_callback* används i stället."

msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"Om *error_callback* anges bör det vara en callable som accepterar ett enda "
"argument.  Om målfunktionen misslyckas anropas *error_callback* med "
"undantagsinstansen."

msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"Återkallelser bör slutföras omedelbart eftersom den tråd som hanterar "
"resultaten annars blockeras."

msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
"En parallell motsvarighet till den inbyggda funktionen :func:`map` (den "
"stöder dock bara ett *iterable*-argument, för flera iterables se :meth:"
"`starmap`). Den blockerar tills resultatet är klart."

msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"Den här metoden delar upp iterabeln i ett antal bitar som den skickar till "
"processpoolen som separata uppgifter.  Den (ungefärliga) storleken på dessa "
"bitar kan anges genom att *chunksize* sätts till ett positivt heltal."

msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"Observera att det kan orsaka hög minnesanvändning för mycket långa "
"iterabler. Överväg att använda :meth:`imap` eller :meth:`imap_unordered` med "
"explicit *chunksize*-alternativ för bättre effektivitet."

msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"En variant av metoden :meth:`.map` som returnerar ett :class:"
"`~multiprocessing.pool.AsyncResult`-objekt."

msgid "A lazier version of :meth:`.map`."
msgstr "En latare version av :meth:`.map`."

msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"Argumentet *chunksize* är detsamma som det som används av metoden :meth:`."
"map`.  För mycket långa iterabler kan ett stort värde för *chunksize* göra "
"att jobbet slutförs **mycket** snabbare än om standardvärdet ``1`` används."

msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"Även om *chunksize* är ``1`` så har :meth:`!next`-metoden för iteratorn som "
"returneras av :meth:`imap`-metoden en valfri *timeout*-parameter: "
"``next(timeout)`` kommer att ge upphov till :exc:`multiprocessing."
"TimeoutError` om resultatet inte kan returneras inom *timeout* sekunder."

msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"Samma som :meth:`imap` förutom att ordningsföljden på resultaten från den "
"returnerade iteratorn bör betraktas som godtycklig.  (Endast när det bara "
"finns en arbetsprocess garanteras att ordningen är \"korrekt\")"

msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"Som :meth:`~multiprocessing.pool.Pool.map` förutom att elementen i "
"*iterable* förväntas vara iterables som packas upp som argument."

msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"Därför resulterar en *iterabel* av ``[(1,2), (3,4)]`` i ``[func(1,2), "
"func(3,4)]``."

msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"En kombination av :meth:`starmap` och :meth:`map_async` som itererar över "
"*iterable* av iterabler och anropar *func* med iterablerna uppackade. "
"Returnerar ett resultatobjekt."

msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"Förhindrar att fler uppgifter skickas till poolen.  När alla uppgifter har "
"slutförts kommer arbetsprocesserna att avslutas."

msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"Stoppar arbetsprocesserna omedelbart utan att slutföra utestående arbete.  "
"När poolobjektet skräpsamlas kommer :meth:`terminate` att anropas omedelbart."

msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"Vänta på att arbetsprocesserna ska avslutas.  Man måste anropa :meth:`close` "
"eller :meth:`terminate` innan man använder :meth:`join`."

msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Poolobjekt stöder nu kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` returnerar "
"poolobjektet, och :meth:`~contextmanager.__exit__` anropar :meth:`terminate`."

msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
"Klassen för det resultat som returneras av :meth:`Pool.apply_async` och :"
"meth:`Pool.map_async`."

msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"Returnerar resultatet när det anländer.  Om *timeout* inte är ``None`` och "
"resultatet inte anländer inom *timeout* sekunder så kommer :exc:"
"`multiprocessing.TimeoutError` att uppstå.  Om fjärranropet gav upphov till "
"ett undantag kommer detta undantag att återskapas av :meth:`get`."

msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""
"Vänta tills resultatet är tillgängligt eller tills *timeout* sekunder har "
"passerat."

msgid "Return whether the call has completed."
msgstr "Returnerar om samtalet har slutförts."

msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""
"Returnerar om anropet slutfördes utan att ett undantag uppstod.  Kommer att "
"ge :exc:`ValueError` om resultatet inte är klart."

msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Om resultatet inte är klart kommer :exc:`ValueError` att visas istället för :"
"exc:`AssertionError`."

msgid "The following example demonstrates the use of a pool::"
msgstr "Följande exempel visar hur en pool används::"

msgid ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # start 4 worker processes\n"
"        result = pool.apply_async(f, (10,)) # evaluate \"f(10)\" "
"asynchronously in a single process\n"
"        print(result.get(timeout=1))        # prints \"100\" unless your "
"computer is *very* slow\n"
"\n"
"        print(pool.map(f, range(10)))       # prints \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # prints \"0\"\n"
"        print(next(it))                     # prints \"1\"\n"
"        print(it.next(timeout=1))           # prints \"4\" unless your "
"computer is *very* slow\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # raises multiprocessing."
"TimeoutError"
msgstr ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # start 4 worker processes\n"
"        result = pool.apply_async(f, (10,)) # evaluate \"f(10)\" "
"asynchronously in a single process\n"
"        print(result.get(timeout=1))        # prints \"100\" unless your "
"computer is *very* slow\n"
"\n"
"        print(pool.map(f, range(10)))       # prints \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # prints \"0\"\n"
"        print(next(it))                     # prints \"1\"\n"
"        print(it.next(timeout=1))           # prints \"4\" unless your "
"computer is *very* slow\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # raises multiprocessing."
"TimeoutError"

msgid "Listeners and Clients"
msgstr "Lyssnare och kunder"

msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"Vanligtvis sker meddelandeöverföring mellan processer med hjälp av köer "
"eller genom att använda :class:`~Connection`-objekt som returneras av :func:"
"`~multiprocessing.Pipe`."

msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"Modulen :mod:`multiprocessing.connection` ger dock lite extra flexibilitet.  "
"Den ger i princip ett meddelandeorienterat API på hög nivå för hantering av "
"sockets eller Windows named pipes.  Den har också stöd för *digest "
"authentication* med modulen :mod:`hmac`, och för polling av flera "
"anslutningar samtidigt."

msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"Skicka ett slumpmässigt genererat meddelande till den andra änden av "
"anslutningen och vänta på svar."

msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Om svaret matchar sammanfattningen av meddelandet med *authkey* som nyckel "
"skickas ett välkomstmeddelande till den andra änden av anslutningen.  I "
"annat fall genereras :exc:`~multiprocessing.AuthenticationError`."

msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"Ta emot ett meddelande, beräkna sammanfattningen av meddelandet med "
"*authkey* som nyckel och skicka sedan tillbaka sammanfattningen."

msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"Om ett välkomstmeddelande inte tas emot kommer :exc:`~multiprocessing."
"AuthenticationError` att uppstå."

msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"Försök att upprätta en anslutning till lyssnaren som använder adressen "
"*address*, returnerar en :class:`~Connection`."

msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"Typen av anslutning bestäms av *family*-argumentet, men detta kan i "
"allmänhet utelämnas eftersom det oftast kan härledas från formatet på "
"*address*. (Se :ref:`multiprocessing-address-formats`)"

msgid ""
"If *authkey* is given and not ``None``, it should be a byte string and will "
"be used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is ``None``. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Om *authkey* anges och inte ``None``, bör den vara en bytesträng och kommer "
"att användas som hemlig nyckel för en HMAC-baserad autentiseringsutmaning. "
"Ingen autentisering görs om *authkey* är ``None``. :exc:`~multiprocessing."
"AuthenticationError` genereras om autentiseringen misslyckas. Se :ref:"
"`multiprocessing-auth-keys`."

msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"Ett omslag för en bound socket eller Windows named pipe som \"lyssnar\" på "
"anslutningar."

msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*address* är den adress som ska användas av lyssnarobjektets bundna socket "
"eller namngivna pipe."

msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"Om en adress på \"0.0.0.0\" används kommer adressen inte att vara en "
"anslutningsbar slutpunkt i Windows. Om du behöver en anslutningsbar "
"slutpunkt bör du använda \"127.0.0.1\"."

msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* är den typ av socket (eller named pipe) som ska användas.  Detta "
"kan vara en av strängarna ``'AF_INET'`` (för ett TCP-socket), ``'AF_UNIX'`` "
"(för ett Unix-domän-socket) eller ``'AF_PIPE'`` (för en Windows named "
"pipe).  Av dessa är det bara den första som garanterat är tillgänglig.  Om "
"*family* är ``None`` så härleds familjen från formatet på *address*.  Om "
"*address* också är ``None`` väljs ett standardvärde.  Denna standard är den "
"familj som antas vara den snabbaste tillgängliga.  Se :ref:`multiprocessing-"
"address-formats`.  Observera att om *family* är ``'AF_UNIX'`` och adress är "
"``None`` så kommer uttaget att skapas i en privat temporär katalog som "
"skapas med :func:`tempfile.mkstemp`."

msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"Om lyssnarobjektet använder ett uttag skickas *backlog* (1 som standard) "
"till :meth:`~socket.socket.listen`-metoden för uttaget när det har bundits."

msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Acceptera en anslutning på lyssnarobjektets bundna socket eller namngivna "
"pipe och returnera ett :class:`~Connection`-objekt. Om autentiseringsförsök "
"misslyckas genereras :exc:`~multiprocessing.AuthenticationError`."

msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"Stäng lyssnarobjektets bundna socket eller namngivna pipe.  Detta anropas "
"automatiskt när lyssnaren garbage collectas.  Det är dock tillrådligt att "
"anropa det explicit."

msgid "Listener objects have the following read-only properties:"
msgstr "Listener-objekt har följande skrivskyddade egenskaper:"

msgid "The address which is being used by the Listener object."
msgstr "Den adress som används av Listener-objektet."

msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"Den adress som den senast accepterade anslutningen kom från.  Om den inte är "
"tillgänglig är den ``None``."

msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Lyssnarobjekt stöder nu kontexthanteringsprotokollet -- se :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` returnerar "
"lyssnarobjektet, och :meth:`~contextmanager.__exit__` anropar :meth:`close`."

msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"Vänta tills ett objekt i *object_list* är klart.  Returnerar listan över de "
"objekt i *object_list* som är klara.  Om *timeout* är en float blockeras "
"anropet i högst så många sekunder.  Om *timeout* är ``None`` blockeras "
"anropet under obegränsad tid. En negativ timeout är likvärdig med en timeout "
"på noll."

msgid ""
"For both POSIX and Windows, an object can appear in *object_list* if it is"
msgstr ""
"För både POSIX och Windows kan ett objekt visas i *object_list* om det är"

msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "ett läsbart :class:`~multiprocessing.connection.Connection`-objekt;"

msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "ett anslutet och läsbart :class:`socket.socket`-objekt; eller"

msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
"attributet :attr:`~multiprocessing.Process.sentinel` för ett :class:"
"`~multiprocessing.Process`-objekt."

msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"En anslutning eller ett socketobjekt är klart när det finns data att läsa "
"från det, eller när den andra änden har stängts."

msgid ""
"**POSIX**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""
"**POSIX**: ``wait(object_list, timeout)`` nästan likvärdig ``select."
"select(object_list, [], [], timeout)``.  Skillnaden är att om :func:`select."
"select` avbryts av en signal, kan den ge upphov till :exc:`OSError` med ett "
"felnummer på ``EINTR``, medan :func:`wait` inte gör det."

msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`~io.IOBase.fileno` method which returns a socket handle or pipe "
"handle.  (Note that pipe handles and socket handles are **not** waitable "
"handles.)"
msgstr ""
"**Windows**: Ett objekt i *object_list* måste antingen vara ett "
"heltalshandtag som är väntbart (enligt den definition som används i "
"dokumentationen för Win32-funktionen ``WaitForMultipleObjects()``) eller så "
"kan det vara ett objekt med en :meth:`~io.IOBase.fileno`-metod som "
"returnerar ett socket-handtag eller pipe-handtag.  (Observera att pipe- och "
"socket-handtag **inte** är väntande handtag)"

msgid "**Examples**"
msgstr "**Exempel**"

msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"Följande serverkod skapar en lyssnare som använder ``'hemligt lösenord'`` "
"som autentiseringsnyckel.  Den väntar sedan på en anslutning och skickar "
"några data till klienten::"

msgid ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"
msgstr ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"

msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""
"Följande kod ansluter till servern och tar emot vissa data från servern::"

msgid ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"
msgstr ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"

msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"Följande kod använder :func:`~multiprocessing.connection.wait` för att vänta "
"på meddelanden från flera processer samtidigt::"

msgid ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # We close the writable end of the pipe now to be sure that\n"
"        # p is the only process which owns a handle for it.  This\n"
"        # ensures that when p closes its handle for the writable end,\n"
"        # wait() will promptly report the readable end as being ready.\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"
msgstr ""
"från multiprocessing import Process, Pipe, current_process\n"
"från multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    för i i intervall(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    läsare = []\n"
"\n"
"    för i i intervall(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(mål=foo, args=(w,))\n"
"        p.start()\n"
"        # Vi stänger den skrivbara änden av röret nu för att vara säkra på "
"att\n"
"        # p är den enda process som äger ett handtag för den.  Detta\n"
"        # säkerställer att när p stänger sitt handtag för den skrivbara "
"änden\n"
"        # kommer wait() omedelbart att rapportera att den läsbara änden är "
"klar.\n"
"        w.close()\n"
"\n"
"    medan läsare:\n"
"        for r in wait(readers):\n"
"            försök:\n"
"                msg = r.recv()\n"
"            utom EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"

msgid "Address Formats"
msgstr "Adressformat"

msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"En ``'AF_INET'``-adress är en tupel av formen ``(hostname, port)`` där "
"*hostname* är en sträng och *port* är ett heltal."

msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""
"En ``'AF_UNIX'``-adress är en sträng som representerar ett filnamn i "
"filsystemet."

msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` to connect to a named "
"pipe on a remote computer called *ServerName* one should use an address of "
"the form :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"En ``'AF_PIPE'``-adress är en sträng av formen :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  Om du vill använda :func:`Client` för att "
"ansluta till en namngiven pipe på en fjärrdator som heter *ServerName* bör "
"du använda en adress av formen :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\"
"\\pipe\\\\\\\\{PipeName}'` istället."

msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"Observera att alla strängar som börjar med två backslash antas som standard "
"vara en ``'AF_PIPE'``-adress i stället för en ``'AF_UNIX'``-adress."

msgid "Authentication keys"
msgstr "Autentiseringsnycklar"

msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"När man använder :meth:`Connection.recv <Connection.recv>`, avplockas "
"automatiskt de data som tas emot. Tyvärr är det en säkerhetsrisk att "
"avpickla data från en icke betrodd källa. Därför använder :class:`Listener` "
"och :func:`Client` modulen :mod:`hmac` för att tillhandahålla digest-"
"autentisering."

msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"En autentiseringsnyckel är en byte-sträng som kan betraktas som ett "
"lösenord: när en anslutning har upprättats kommer båda ändarna att kräva "
"bevis för att den andra känner till autentiseringsnyckeln.  (Att visa att "
"båda ändarna använder samma nyckel innebär **inte** att nyckeln skickas över "
"anslutningen)"

msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"Om autentisering begärs men ingen autentiseringsnyckel anges används "
"returvärdet för ``current_process().authkey`` (se :class:`~multiprocessing."
"Process`).  Detta värde kommer automatiskt att ärvas av alla :class:"
"`~multiprocessing.Process`-objekt som den aktuella processen skapar. Detta "
"innebär att (som standard) alla processer i ett multiprocessprogram kommer "
"att dela en enda autentiseringsnyckel som kan användas när de upprättar "
"anslutningar sinsemellan."

msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""
"Lämpliga autentiseringsnycklar kan också genereras med hjälp av :func:`os."
"urandom`."

msgid "Logging"
msgstr "Loggning"

msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"Visst stöd för loggning finns tillgängligt.  Observera dock att paketet :mod:"
"`logging` inte använder processdelade lås så det är möjligt (beroende på typ "
"av hanterare) att meddelanden från olika processer blandas ihop."

msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
"Returnerar den logger som används av :mod:`multiprocessing`.  Om det behövs "
"skapas en ny."

msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"När loggern skapas första gången har den nivån :const:`logging.NOTSET` och "
"ingen standardhanterare. Meddelanden som skickas till denna logger kommer "
"som standard inte att spridas till rotloggaren."

msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Observera att i Windows ärver barnprocesser endast nivån på den överordnade "
"processens logger - alla andra anpassningar av loggern ärvs inte."

msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"Denna funktion utför ett anrop till :func:`get_logger` men förutom att "
"returnera den logger som skapats av get_logger lägger den till en hanterare "
"som skickar utdata till :data:`sys.stderr` med formatet ``'[%(levelname)s/"
"%(processName)s] %(message)s'``. Du kan ändra ``levelname`` för loggern "
"genom att skicka ett ``level``-argument."

msgid "Below is an example session with logging turned on::"
msgstr "Nedan visas ett exempel på en session med loggning aktiverad::"

msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""
">>> import multiprocessing, loggning\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('dödsdömd')\n"
"[VARNING/MainProcess] dödsdömd\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] barnprocessen anropar self.run()\n"
"[INFO/SyncManager-...] skapade temporär katalog /.../pymp-...\n"
"[INFO/SyncManager-...] manager serveras på '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] skickar avstängningsmeddelande till manager\n"
"[INFO/SyncManager-...] chefen avslutas med exitcode 0"

msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"En fullständig tabell över loggningsnivåer finns i modulen :mod:`logging`."

msgid "The :mod:`multiprocessing.dummy` module"
msgstr "Modulen :mod:`multiprocessing.dummy"

msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` replikerar API:t för :mod:`multiprocessing` men "
"är inte mer än ett omslag runt modulen :mod:`threading`."

msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""
"I synnerhet funktionen ``Pool`` som tillhandahålls av :mod:`multiprocessing."
"dummy` returnerar en instans av :class:`ThreadPool`, som är en underklass "
"till :class:`Pool` som stöder alla samma metodanrop men använder en pool av "
"arbetartrådar i stället för arbetsprocesser."

msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""
"Ett trådpoolsobjekt som styr en pool av arbetstrådar som jobb kan skickas "
"till. :class:`ThreadPool`-instanser är helt gränssnittskompatibla med :class:"
"`Pool`-instanser och deras resurser måste också hanteras korrekt, antingen "
"genom att använda poolen som en kontexthanterare eller genom att anropa :"
"meth:`~multiprocessing.pool.Pool.close` och :meth:`~multiprocessing.pool."
"Pool.terminate` manuellt."

msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* är antalet arbetstrådar som ska användas.  Om *processes* är "
"``None`` används det antal som returneras av :func:`os.process_cpu_count`."

msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""
"Till skillnad från :class:`Pool` kan *maxtasksperchild* och *context* inte "
"anges."

msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""
"En :class:`ThreadPool` delar samma gränssnitt som :class:`Pool`, som är "
"utformad kring en pool av processer och föregår introduktionen av :class:"
"`concurrent.futures`-modulen.  Som sådan ärver den vissa operationer som "
"inte är meningsfulla för en pool som backas upp av trådar, och den har en "
"egen typ för att representera statusen för asynkrona jobb, :class:"
"`AsyncResult`, som inte förstås av några andra bibliotek."

msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""
"Användare bör i allmänhet föredra att använda :class:`concurrent.futures."
"ThreadPoolExecutor`, som har ett enklare gränssnitt som utformades kring "
"trådar från början och som returnerar :class:`concurrent.futures.Future`-"
"instanser som är kompatibla med många andra bibliotek, inklusive :mod:"
"`asyncio`."

msgid "Programming guidelines"
msgstr "Riktlinjer för programmering"

msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
"Det finns vissa riktlinjer och idiom som bör följas vid användning av :mod:"
"`multiprocessing`."

msgid "All start methods"
msgstr "Alla startmetoder"

msgid "The following applies to all start methods."
msgstr "Följande gäller för alla startmetoder."

msgid "Avoid shared state"
msgstr "Undvik delat tillstånd"

msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"Så långt det är möjligt bör man försöka undvika att flytta stora mängder "
"data mellan processer."

msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"Det är förmodligen bäst att hålla sig till att använda köer eller pipes för "
"kommunikation mellan processer snarare än att använda "
"synkroniseringsprimitiven på lägre nivå."

msgid "Picklability"
msgstr "Inläggning"

msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "Säkerställ att argumenten till metoderna för proxies är picklbara."

msgid "Thread safety of proxies"
msgstr "Trådsäkerhet för proxyer"

msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"Använd inte ett proxyobjekt från mer än en tråd om du inte skyddar det med "
"ett lås."

msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""
"(Det är aldrig något problem att olika processer använder *samma* proxy)"

msgid "Joining zombie processes"
msgstr "Ansluta sig till zombieprocesser"

msgid ""
"On POSIX when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all completed "
"processes which have not yet been joined will be joined.  Also calling a "
"finished process's :meth:`Process.is_alive <multiprocessing.Process."
"is_alive>` will join the process.  Even so it is probably good practice to "
"explicitly join all the processes that you start."
msgstr ""
"På POSIX blir en process en zombie när den är klar men inte har blivit "
"joinad. Det bör aldrig finnas särskilt många eftersom varje gång en ny "
"process startar (eller :func:`~multiprocessing.active_children` anropas) "
"kommer alla avslutade processer som ännu inte har förenats att förenas.  "
"Även anrop av en avslutad process :meth:`Process.is_alive <multiprocessing."
"Process.is_alive>` kommer att ansluta processen.  Trots detta är det "
"förmodligen god praxis att uttryckligen joina alla processer som du startar."

msgid "Better to inherit than pickle/unpickle"
msgstr "Bättre att ärva än att plocka/ta bort"

msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"När man använder startmetoderna *spawn* eller *forkserver* måste många typer "
"från :mod:`multiprocessing` vara picklable så att barnprocesser kan använda "
"dem.  Man bör dock i allmänhet undvika att skicka delade objekt till andra "
"processer med hjälp av pipes eller köer. Istället bör man arrangera "
"programmet så att en process som behöver tillgång till en delad resurs som "
"skapats någon annanstans kan ärva den från en förfadersprocess."

msgid "Avoid terminating processes"
msgstr "Undvik att avsluta processer"

msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"Om du använder metoden :meth:`Process.terminate <multiprocessing.Process."
"terminate>` för att stoppa en process kan det leda till att delade resurser "
"(t.ex. lås, semaforer, rör och köer) som för närvarande används av processen "
"blir trasiga eller otillgängliga för andra processer."

msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"Därför är det förmodligen bäst att bara överväga att använda :meth:`Process."
"terminate <multiprocessing.Process.terminate>` på processer som aldrig "
"använder några delade resurser."

msgid "Joining processes that use queues"
msgstr "Ansluta sig till processer som använder köer"

msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"Tänk på att en process som har lagt objekt i en kö kommer att vänta innan "
"den avslutas tills alla buffrade objekt har matats av \"feeder\"-tråden till "
"den underliggande pipen.  (Barnprocessen kan anropa :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>`-metoden för "
"kön för att undvika detta beteende)"

msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"Detta innebär att när du använder en kö måste du se till att alla objekt som "
"har lagts i kön så småningom kommer att tas bort innan processen ansluts.  "
"Annars kan du inte vara säker på att processer som har lagt objekt i kön "
"kommer att avslutas.  Kom också ihåg att icke-daemoniska processer kommer "
"att anslutas automatiskt."

msgid "An example which will deadlock is the following::"
msgstr "Ett exempel som kommer att låsa sig är följande::"

msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # this deadlocks\n"
"    obj = queue.get()"
msgstr ""
"från multiprocessing import Process, Kö\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(mål=f, args=(kö,))\n"
"    p.start()\n"
"    p.join() # detta leder till dödläge\n"
"    obj = kö.get()"

msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"En lösning här skulle vara att byta ut de två sista raderna (eller helt "
"enkelt ta bort raden ``p.join()``))."

msgid "Explicitly pass resources to child processes"
msgstr "Explicit skicka resurser till underordnade processer"

msgid ""
"On POSIX using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"På POSIX med startmetoden *fork* kan en underordnad process använda en delad "
"resurs som skapats i en överordnad process med hjälp av en global resurs.  "
"Det är dock bättre att skicka objektet som ett argument till konstruktören "
"för barnprocessen."

msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"Förutom att göra koden (potentiellt) kompatibel med Windows och de andra "
"startmetoderna säkerställer detta också att så länge barnprocessen "
"fortfarande är vid liv kommer objektet inte att samlas in i den överordnade "
"processen.  Detta kan vara viktigt om någon resurs frigörs när objektet "
"garbage collectas i den överordnade processen."

msgid "So for instance ::"
msgstr "Så till exempel ::"

msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... do something using \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f).start()"
msgstr ""
"från multiprocessing import Process, Lås\n"
"\n"
"def f():\n"
"    ... gör något med hjälp av \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    för i i intervall(10):\n"
"        Process(mål=f).start()"

msgid "should be rewritten as ::"
msgstr "bör skrivas om till ::"

msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... do something using \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"
msgstr ""
"från multiprocessing import Process, Lås\n"
"\n"
"def f(l):\n"
"    ... gör något med hjälp av \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    för i i intervall(10):\n"
"        Process(mål=f, args=(lock,)).start()"

msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ""
"Se upp så att du inte ersätter :data:`sys.stdin` med ett \"filliknande "
"objekt\""

msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` ursprungligen ovillkorligen anropad::"

msgid "os.close(sys.stdin.fileno())"
msgstr "os.close(sys.stdin.fileno())"

msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"i metoden :meth:`multiprocessing.Process._bootstrap` --- detta resulterade i "
"problem med processer-i-processer. Detta har ändrats till::"

msgid ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"
msgstr ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"

msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""
"Detta löser det grundläggande problemet med processer som kolliderar med "
"varandra och resulterar i ett fel med dålig filbeskrivare, men introducerar "
"en potentiell fara för applikationer som ersätter :func:`sys.stdin` med ett "
"\"filliknande objekt\" med buffring av utdata.  Denna fara är att om flera "
"processer anropar :meth:`~io.IOBase.close` på detta filliknande objekt, kan "
"det resultera i att samma data spolas till objektet flera gånger, vilket "
"resulterar i korruption."

msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"Om du skriver ett filliknande objekt och implementerar din egen cachelagring "
"kan du göra den gaffelsäker genom att lagra pid när du lägger till något i "
"cachen och kassera cachen när pid ändras. Till exempel::"

msgid ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"
msgstr ""
"@egenskap\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    returnera self._cache"

msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "För mer information, se :issue:`5155`, :issue:`5313` och :issue:`5331`"

msgid "The *spawn* and *forkserver* start methods"
msgstr "Startmetoderna *spawn* och *forkserver*"

msgid ""
"There are a few extra restrictions which don't apply to the *fork* start "
"method."
msgstr ""
"Det finns några extra begränsningar som inte gäller för startmetoden *fork*."

msgid "More picklability"
msgstr "Mer betningsbarhet"

msgid ""
"Ensure that all arguments to :class:`~multiprocessing.Process` are "
"picklable.  Also, if you subclass ``Process.__init__``, you must make sure "
"that instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr ""
"Se till att alla argument till :class:`~multiprocessing.Process` är "
"betningsbara.  Om du subklassar ``Process.__init__`` måste du också se till "
"att instanser kommer att vara betningsbara när metoden :meth:`Process.start "
"<multiprocessing.Process.start>` anropas."

msgid "Global variables"
msgstr "Globala variabler"

msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"Tänk på att om kod som körs i en underordnad process försöker komma åt en "
"global variabel, så kanske det värde som visas (om det finns något) inte är "
"detsamma som värdet i den överordnade processen vid den tidpunkt då :meth:"
"`Process.start <multiprocessing.Process.start>` anropades."

msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"Globala variabler som bara är konstanter på modulnivå orsakar dock inga "
"problem."

msgid "Safe importing of main module"
msgstr "Säker import av huvudmodul"

msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a new "
"process)."
msgstr ""
"Se till att huvudmodulen kan importeras på ett säkert sätt av en ny Python-"
"tolk utan att orsaka oavsiktliga bieffekter (t.ex. att starta en ny process)."

msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"Om du till exempel använder startmetoden *spawn* eller *forkserver* och kör "
"följande modul skulle det misslyckas med :exc:`RuntimeError`::"

msgid ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"
msgstr ""
"från multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hallå')\n"
"\n"
"p = Process(mål=foo)\n"
"p.start()"

msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"Istället bör man skydda programmets \"ingångspunkt\" genom att använda ``if "
"__name__ == '__main__':`` på följande sätt::"

msgid ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(target=foo)\n"
"    p.start()"
msgstr ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(mål=foo)\n"
"    p.start()"

msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(Raden ``freeze_support()`` kan utelämnas om programmet ska köras normalt "
"istället för att frysas)"

msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"Detta gör att den nystartade Python-tolken kan importera modulen på ett "
"säkert sätt och sedan köra modulens funktion ``foo()``."

msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"Liknande begränsningar gäller om en pool eller manager skapas i huvudmodulen."

msgid "Examples"
msgstr "Exempel"

msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""
"Demonstration av hur man skapar och använder anpassade hanterare och "
"fullmakter:"

msgid ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via "
"proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via "
"proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"

msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "Använder :class:`~multiprocessing.pool.Pool`:"

msgid ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # Tests\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till "
"complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from list(pool."
"imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from IMapIterator."
"next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testing timeouts\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"
msgstr ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # Tests\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till "
"complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from list(pool."
"imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from IMapIterator."
"next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testing timeouts\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"

msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"Ett exempel som visar hur man använder köer för att mata uppgifter till en "
"samling arbetsprocesser och samla in resultaten:"

msgid ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
