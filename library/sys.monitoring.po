# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!sys.monitoring` --- Execution event monitoring"
msgstr ":mod:`!sys.monitoring` --- Övervakning av exekveringshändelser"

msgid ""
":mod:`sys.monitoring` is a namespace within the :mod:`sys` module, not an "
"independent module, so there is no need to ``import sys.monitoring``, simply "
"``import sys`` and then use ``sys.monitoring``."
msgstr ""
":mod:`sys.monitoring` är en namnrymd inom :mod:`sys`-modulen, inte en "
"oberoende modul, så det finns inget behov av att ``importera sys."
"monitoring``, bara ``importera sys`` och sedan använda ``sys.monitoring``."

msgid ""
"This namespace provides access to the functions and constants necessary to "
"activate and control event monitoring."
msgstr ""
"Detta namnområde ger tillgång till de funktioner och konstanter som krävs "
"för att aktivera och styra händelseövervakning."

msgid ""
"As programs execute, events occur that might be of interest to tools that "
"monitor execution. The :mod:`sys.monitoring` namespace provides means to "
"receive callbacks when events of interest occur."
msgstr ""
"När program körs inträffar händelser som kan vara av intresse för verktyg "
"som övervakar körningen. Namnrymden :mod:`sys.monitoring` tillhandahåller "
"medel för att ta emot återuppringningar när intressanta händelser inträffar."

msgid "The monitoring API consists of three components:"
msgstr "API:et för övervakning består av tre komponenter:"

msgid "`Tool identifiers`_"
msgstr "`Tool identifiers`_"

msgid "`Events`_"
msgstr "`Events`_"

msgid ":ref:`Callbacks <callbacks>`"
msgstr ":ref:`Callbacks <callbacks>`"

msgid "Tool identifiers"
msgstr "Verktygsidentifierare"

msgid ""
"A tool identifier is an integer and the associated name. Tool identifiers "
"are used to discourage tools from interfering with each other and to allow "
"multiple tools to operate at the same time. Currently tools are completely "
"independent and cannot be used to monitor each other. This restriction may "
"be lifted in the future."
msgstr ""
"En verktygsidentifierare är ett heltal och det tillhörande namnet. "
"Verktygsidentifierare används för att hindra verktyg från att störa varandra "
"och för att tillåta att flera verktyg arbetar samtidigt. För närvarande är "
"verktygen helt oberoende av varandra och kan inte användas för att övervaka "
"varandra. Denna begränsning kan komma att upphävas i framtiden."

msgid ""
"Before registering or activating events, a tool should choose an identifier. "
"Identifiers are integers in the range 0 to 5 inclusive."
msgstr ""
"Innan ett verktyg registrerar eller aktiverar händelser bör det välja en "
"identifierare. Identifierare är heltal i intervallet 0 till och med 5."

msgid "Registering and using tools"
msgstr "Registrera och använda verktyg"

msgid ""
"Must be called before *tool_id* can be used. *tool_id* must be in the range "
"0 to 5 inclusive. Raises a :exc:`ValueError` if *tool_id* is in use."
msgstr ""
"Måste anropas innan *tool_id* kan användas. *tool_id* måste ligga i "
"intervallet 0 till och med 5. Utlöser ett :exc:`ValueError` om *tool_id* "
"används."

msgid "Unregister all events and callback functions associated with *tool_id*."
msgstr ""
"Avregistrera alla händelser och callback-funktioner som är kopplade till "
"*tool_id*."

msgid ""
"Should be called once a tool no longer requires *tool_id*. Will call :func:"
"`clear_tool_id` before releasing *tool_id*."
msgstr ""
"Bör anropas när ett verktyg inte längre behöver *tool_id*. Anropar :func:"
"`clear_tool_id` innan *tool_id* släpps."

msgid ""
"Returns the name of the tool if *tool_id* is in use, otherwise it returns "
"``None``. *tool_id* must be in the range 0 to 5 inclusive."
msgstr ""
"Returnerar namnet på verktyget om *tool_id* används, annars returneras "
"``None``. *tool_id* måste ligga inom intervallet 0 till och med 5."

msgid ""
"All IDs are treated the same by the VM with regard to events, but the "
"following IDs are pre-defined to make co-operation of tools easier::"
msgstr ""
"Alla ID:n behandlas på samma sätt av VM när det gäller händelser, men "
"följande ID:n är fördefinierade för att underlätta samarbetet mellan "
"verktygen::"

msgid ""
"sys.monitoring.DEBUGGER_ID = 0\n"
"sys.monitoring.COVERAGE_ID = 1\n"
"sys.monitoring.PROFILER_ID = 2\n"
"sys.monitoring.OPTIMIZER_ID = 5"
msgstr ""
"sys.monitoring.DEBUGGER_ID = 0\n"
"sys.monitoring.COVERAGE_ID = 1\n"
"sys.övervakning.PROFILER_ID = 2\n"
"sys.monitoring.OPTIMIZER_ID = 5"

msgid "Events"
msgstr "Händelser"

msgid "The following events are supported:"
msgstr "Följande händelser stöds:"

msgid "A conditional branch goes left."
msgstr "En villkorlig gren går åt vänster."

msgid ""
"It is up to the tool to determine how to present \"left\" and \"right\" "
"branches. There is no guarantee which branch is \"left\" and which is "
"\"right\", except that it will be consistent for the duration of the program."
msgstr ""
"Det är upp till verktyget att avgöra hur \"vänster\" och \"höger\" grenar "
"ska presenteras. Det finns ingen garanti för vilken gren som är \"vänster\" "
"och vilken som är \"höger\", förutom att den kommer att vara konsekvent "
"under programmets gång."

msgid "A conditional branch goes right."
msgstr "En villkorlig gren går till höger."

msgid "A call in Python code (event occurs before the call)."
msgstr "Ett anrop i Python-koden (händelsen inträffar före anropet)."

msgid ""
"An exception raised from any callable, except for Python functions (event "
"occurs after the exit)."
msgstr ""
"Ett undantag som uppstår från en anropsbar funktion, med undantag för Python-"
"funktioner (händelsen inträffar efter avslutningen)."

msgid ""
"Return from any callable, except for Python functions (event occurs after "
"the return)."
msgstr ""
"Retur från valfri anropsbar funktion, utom Python-funktioner (händelsen "
"inträffar efter returen)."

msgid "An exception is handled."
msgstr "Ett undantag hanteras."

msgid "A VM instruction is about to be executed."
msgstr "En VM-instruktion håller på att exekveras."

msgid "An unconditional jump in the control flow graph is made."
msgstr "Ett ovillkorligt hopp i kontrollflödesdiagrammet görs."

msgid ""
"An instruction is about to be executed that has a different line number from "
"the preceding instruction."
msgstr ""
"En instruktion håller på att utföras som har ett annat radnummer än den "
"föregående instruktionen."

msgid ""
"Resumption of a Python function (for generator and coroutine functions), "
"except for ``throw()`` calls."
msgstr ""
"Återupptagande av en Python-funktion (för generator- och coroutine-"
"funktioner), utom för ``throw()``-anrop."

msgid ""
"Return from a Python function (occurs immediately before the return, the "
"callee's frame will be on the stack)."
msgstr ""
"Retur från en Python-funktion (sker omedelbart före returen, den uppringdes "
"ram kommer att ligga på stacken)."

msgid ""
"Start of a Python function (occurs immediately after the call, the callee's "
"frame will be on the stack)"
msgstr ""
"Start av en Python-funktion (sker omedelbart efter anropet, den anropades "
"ram kommer att ligga på stacken)"

msgid "A Python function is resumed by a ``throw()`` call."
msgstr "En Python-funktion återupptas genom ett ``throw()``-anrop."

msgid ""
"Exit from a Python function during exception unwinding. This includes "
"exceptions raised directly within the function and that are allowed to "
"continue to propagate."
msgstr ""
"Avsluta från en Python-funktion under undantagsupprullning. Detta inkluderar "
"undantag som uppstår direkt inom funktionen och som tillåts fortsätta att "
"spridas."

msgid ""
"Yield from a Python function (occurs immediately before the yield, the "
"callee's frame will be on the stack)."
msgstr ""
"Avkastning från en Python-funktion (sker omedelbart före avkastningen, den "
"uppkallades ram kommer att ligga på stacken)."

msgid ""
"An exception is raised, except those that cause a :monitoring-event:"
"`STOP_ITERATION` event."
msgstr ""
"Ett undantag tas upp, utom de som orsakar en händelse av typen :monitoring-"
"event:`STOP_ITERATION`."

msgid ""
"An exception is re-raised, for example at the end of a :keyword:`finally` "
"block."
msgstr ""
"Ett undantag tas upp igen, t.ex. i slutet av ett :keyword:`finally`-block."

msgid ""
"An artificial :exc:`StopIteration` is raised; see `the STOP_ITERATION "
"event`_."
msgstr ""
"En artificiell :exc:`StopIteration` uppstår; se `händelsen STOP_ITERATION`_."

msgid "More events may be added in the future."
msgstr "Fler evenemang kan tillkomma i framtiden."

msgid ""
"These events are attributes of the :mod:`!sys.monitoring.events` namespace. "
"Each event is represented as a power-of-2 integer constant. To define a set "
"of events, simply bitwise OR the individual events together. For example, to "
"specify both :monitoring-event:`PY_RETURN` and :monitoring-event:`PY_START` "
"events, use the expression ``PY_RETURN | PY_START``."
msgstr ""
"Dessa händelser är attribut i namnrymden :mod:`!sys.monitoring.events`. "
"Varje händelse representeras av en heltalskonstant i potens 2. För att "
"definiera en uppsättning händelser, bitvis ELLER de enskilda händelserna "
"tillsammans. Om du till exempel vill ange både händelserna :monitoring-event:"
"`PY_RETURN` och :monitoring-event:`PY_START`, använder du uttrycket "
"``PY_RETURN | PY_START``."

msgid "An alias for ``0`` so users can do explicit comparisons like::"
msgstr ""
"Ett alias för ``0`` så att användare kan göra explicita jämförelser som::"

msgid ""
"if get_events(DEBUGGER_ID) == NO_EVENTS:\n"
"    ..."
msgstr ""
"if get_events(DEBUGGER_ID) == NO_EVENTS:\n"
"    ..."

msgid "Setting this event deactivates all events."
msgstr "Om du ställer in denna händelse avaktiveras alla händelser."

msgid "Local events"
msgstr "Lokala evenemang"

msgid ""
"Local events are associated with normal execution of the program and happen "
"at clearly defined locations. All local events can be disabled. The local "
"events are:"
msgstr ""
"Lokala händelser är förknippade med normal körning av programmet och "
"inträffar på tydligt definierade platser. Alla lokala händelser kan "
"avaktiveras. De lokala händelserna är:"

msgid ":monitoring-event:`PY_START`"
msgstr ":monitoring-event:`PY_START`"

msgid ":monitoring-event:`PY_RESUME`"
msgstr ":monitoring-event:`PY_RESUME`"

msgid ":monitoring-event:`PY_RETURN`"
msgstr ":monitoring-event:`PY_RETURN`"

msgid ":monitoring-event:`PY_YIELD`"
msgstr ":monitoring-event:`PY_YIELD`"

msgid ":monitoring-event:`CALL`"
msgstr ":monitoring-event:`CALL`"

msgid ":monitoring-event:`LINE`"
msgstr ":monitoring-event:`LINE`"

msgid ":monitoring-event:`INSTRUCTION`"
msgstr ":monitoring-event:`INSTRUCTION`"

msgid ":monitoring-event:`JUMP`"
msgstr ":monitoring-event:`JUMP`"

msgid ":monitoring-event:`BRANCH_LEFT`"
msgstr ":monitoring-event:`BRANCH_LEFT`"

msgid ":monitoring-event:`BRANCH_RIGHT`"
msgstr ":monitoring-event:`BRANCH_RIGHT`"

msgid ":monitoring-event:`STOP_ITERATION`"
msgstr ":monitoring-event:`STOP_ITERATION`"

msgid "Deprecated event"
msgstr "Föråldrad händelse"

msgid "``BRANCH``"
msgstr "``BRANCH``"

msgid ""
"The ``BRANCH`` event is deprecated in 3.14. Using :monitoring-event:"
"`BRANCH_LEFT` and :monitoring-event:`BRANCH_RIGHT` events will give much "
"better performance as they can be disabled independently."
msgstr ""
"Händelsen ``BRANCH`` är utfasad i 3.14. Att använda händelserna :monitoring-"
"event:`BRANCH_LEFT` och :monitoring-event:`BRANCH_RIGHT` ger mycket bättre "
"prestanda eftersom de kan inaktiveras oberoende av varandra."

msgid "Ancillary events"
msgstr "Kompletterande händelser"

msgid ""
"Ancillary events can be monitored like other events, but are controlled by "
"another event:"
msgstr ""
"Underordnade händelser kan övervakas på samma sätt som andra händelser, men "
"styrs av en annan händelse:"

msgid ":monitoring-event:`C_RAISE`"
msgstr ":monitoring-event:`C_RAISE`"

msgid ":monitoring-event:`C_RETURN`"
msgstr ":monitoring-event:`C_RETURN`"

msgid ""
"The :monitoring-event:`C_RETURN` and :monitoring-event:`C_RAISE` events are "
"controlled by the :monitoring-event:`CALL` event. :monitoring-event:"
"`C_RETURN` and :monitoring-event:`C_RAISE` events will only be seen if the "
"corresponding :monitoring-event:`CALL` event is being monitored."
msgstr ""
"Händelserna :monitoring-event:`C_RETURN` och :monitoring-event:`C_RAISE` "
"styrs av händelsen :monitoring-event:`CALL`. Händelserna :monitoring-event:"
"`C_RETURN` och :monitoring-event:`C_RAISE` visas endast om motsvarande "
"händelse :monitoring-event:`CALL` övervakas."

msgid "Other events"
msgstr "Andra tävlingar"

msgid ""
"Other events are not necessarily tied to a specific location in the program "
"and cannot be individually disabled."
msgstr ""
"Andra händelser är inte nödvändigtvis knutna till en viss plats i programmet "
"och kan inte avaktiveras individuellt."

msgid "The other events that can be monitored are:"
msgstr "De andra händelser som kan övervakas är:"

msgid ":monitoring-event:`PY_THROW`"
msgstr ":övervakning-händelse:`PY_THROW`"

msgid ":monitoring-event:`PY_UNWIND`"
msgstr ":övervakning-händelse:`PY_UNWIND`"

msgid ":monitoring-event:`RAISE`"
msgstr ":övervakning-händelse:`RAISE`"

msgid ":monitoring-event:`EXCEPTION_HANDLED`"
msgstr ":övervakning-händelse:`EXCEPTION_HANDLED`"

msgid "The STOP_ITERATION event"
msgstr "Händelsen STOP_ITERATION"

msgid ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` specifies that a :"
"exc:`StopIteration` exception is raised when returning a value from a "
"generator or coroutine. However, this is a very inefficient way to return a "
"value, so some Python implementations, notably CPython 3.12+, do not raise "
"an exception unless it would be visible to other code."
msgstr ""
":pep:`PEP 380 <380#användning-av-stopiteration-för-att-returnera-värden>` "
"specificerar att ett :exc:`StopIteration`-undantag höjs när ett värde "
"returneras från en generator eller coroutine. Detta är dock ett mycket "
"ineffektivt sätt att returnera ett värde, så vissa Python-implementationer, "
"särskilt CPython 3.12+, ger inte upphov till ett undantag om det inte skulle "
"vara synligt för annan kod."

msgid ""
"To allow tools to monitor for real exceptions without slowing down "
"generators and coroutines, the :monitoring-event:`STOP_ITERATION` event is "
"provided. :monitoring-event:`STOP_ITERATION` can be locally disabled, "
"unlike :monitoring-event:`RAISE`."
msgstr ""
"För att göra det möjligt för verktyg att övervaka verkliga undantag utan att "
"sakta ner generatorer och coroutines, tillhandahålls händelsen :monitoring-"
"event:`STOP_ITERATION`. :monitoring-event:`STOP_ITERATION` kan inaktiveras "
"lokalt, till skillnad från :monitoring-event:`RAISE`."

msgid ""
"Note that the :monitoring-event:`STOP_ITERATION` event and the :monitoring-"
"event:`RAISE` event for a :exc:`StopIteration` exception are equivalent, and "
"are treated as interchangeable when generating events. Implementations will "
"favor :monitoring-event:`STOP_ITERATION` for performance reasons, but may "
"generate a :monitoring-event:`RAISE` event with a :exc:`StopIteration`."
msgstr ""
"Observera att händelsen :monitoring-event:`STOP_ITERATION` och händelsen :"
"monitoring-event:`RAISE` för ett undantag från :exc:`StopIteration` är "
"likvärdiga och behandlas som utbytbara när händelser genereras. "
"Implementationer kommer att föredra :monitoring-event:`STOP_ITERATION` av "
"prestandaskäl, men kan generera en :monitoring-event:`RAISE`-händelse med "
"en :exc:`StopIteration`."

msgid "Turning events on and off"
msgstr "Slå på och av evenemang"

msgid ""
"In order to monitor an event, it must be turned on and a corresponding "
"callback must be registered. Events can be turned on or off by setting the "
"events either globally and/or for a particular code object. An event will "
"trigger only once, even if it is turned on both globally and locally."
msgstr ""
"För att kunna övervaka en händelse måste den vara aktiverad och ett "
"motsvarande callback måste vara registrerat. Händelser kan slås på eller av "
"genom att ställa in händelserna antingen globalt och/eller för ett visst "
"kodobjekt. En händelse utlöses endast en gång, även om den är aktiverad både "
"globalt och lokalt."

msgid "Setting events globally"
msgstr "Global inställning av händelser"

msgid ""
"Events can be controlled globally by modifying the set of events being "
"monitored."
msgstr ""
"Händelser kan styras globalt genom att ändra uppsättningen av händelser som "
"övervakas."

msgid "Returns the ``int`` representing all the active events."
msgstr "Returnerar ``int`` som representerar alla aktiva händelser."

msgid ""
"Activates all events which are set in *event_set*. Raises a :exc:"
"`ValueError` if *tool_id* is not in use."
msgstr ""
"Aktiverar alla händelser som anges i *event_set*. Utlöser ett :exc:"
"`ValueError` om *tool_id* inte används."

msgid "No events are active by default."
msgstr "Inga händelser är aktiva som standard."

msgid "Per code object events"
msgstr "Händelser per kodobjekt"

msgid ""
"Events can also be controlled on a per code object basis. The functions "
"defined below which accept a :class:`types.CodeType` should be prepared to "
"accept a look-alike object from functions which are not defined in Python "
"(see :ref:`c-api-monitoring`)."
msgstr ""
"Händelser kan också kontrolleras per kodobjekt. De funktioner som definieras "
"nedan och som accepterar en :class:`types.CodeType` bör vara förberedda på "
"att acceptera ett likadant objekt från funktioner som inte är definierade i "
"Python (se :ref:`c-api-monitoring`)."

msgid "Returns all the local events for *code*"
msgstr "Returnerar alla lokala händelser för *code*"

msgid ""
"Activates all the local events for *code* which are set in *event_set*. "
"Raises a :exc:`ValueError` if *tool_id* is not in use."
msgstr ""
"Aktiverar alla lokala händelser för *code* som har angetts i *event_set*. "
"Utlöser ett :exc:`ValueError` om *tool_id* inte används."

msgid "Disabling events"
msgstr "Inaktivera händelser"

msgid ""
"A special value that can be returned from a callback function to disable "
"events for the current code location."
msgstr ""
"Ett specialvärde som kan returneras från en callback-funktion för att "
"inaktivera händelser för den aktuella kodplatsen."

msgid ""
"Local events can be disabled for a specific code location by returning :data:"
"`sys.monitoring.DISABLE` from a callback function. This does not change "
"which events are set, or any other code locations for the same event."
msgstr ""
"Lokala händelser kan inaktiveras för en specifik kodplats genom att "
"returnera :data:`sys.monitoring.DISABLE` från en callback-funktion. Detta "
"ändrar inte vilka händelser som ställs in, eller några andra kodplatser för "
"samma händelse."

msgid ""
"Disabling events for specific locations is very important for high "
"performance monitoring. For example, a program can be run under a debugger "
"with no overhead if the debugger disables all monitoring except for a few "
"breakpoints."
msgstr ""
"Att inaktivera händelser för specifika platser är mycket viktigt för "
"högpresterande övervakning. Ett program kan t.ex. köras under en debugger "
"utan extra kostnader om debuggern inaktiverar all övervakning utom för ett "
"fåtal brytpunkter."

msgid ""
"Enable all the events that were disabled by :data:`sys.monitoring.DISABLE` "
"for all tools."
msgstr ""
"Aktivera alla händelser som inaktiverades med :data:`sys.monitoring.DISABLE` "
"för alla verktyg."

msgid "Registering callback functions"
msgstr "Registrering av återuppringningsfunktioner"

msgid "Registers the callable *func* for the *event* with the given *tool_id*"
msgstr ""
"Registrerar den anropsbara *funktionen* för *händelsen* med det angivna "
"*verktygs_id*"

msgid ""
"If another callback was registered for the given *tool_id* and *event*, it "
"is unregistered and returned. Otherwise :func:`register_callback` returns "
"``None``."
msgstr ""
"Om en annan återuppringning registrerats för det angivna *tool_id* och "
"*event*, avregistreras den och returneras. Annars returnerar :func:"
"`register_callback` ``None``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.monitoring."
"register_callback`` with argument ``func``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sys.monitoring."
"register_callback`` med argumentet ``func``."

msgid ""
"Functions can be unregistered by calling ``sys.monitoring."
"register_callback(tool_id, event, None)``."
msgstr ""
"Funktioner kan avregistreras genom att anropa ``sys.monitoring."
"register_callback(tool_id, event, None)``."

msgid "Callback functions can be registered and unregistered at any time."
msgstr "Callback-funktioner kan registreras och avregistreras när som helst."

msgid ""
"Callbacks are called only once regardless if the event is turned on both "
"globally and locally. As such, if an event could be turned on for both "
"global and local events by your code then the callback needs to be written "
"to handle either trigger."
msgstr ""
"Callbacks anropas endast en gång oavsett om händelsen aktiveras både globalt "
"och lokalt. Om en händelse kan aktiveras för både globala och lokala "
"händelser med din kod, måste återuppringningen skrivas så att den kan "
"hantera båda utlösarna."

msgid "Callback function arguments"
msgstr "Argument för återuppringningsfunktion"

msgid ""
"A special value that is passed to a callback function to indicate that there "
"are no arguments to the call."
msgstr ""
"Ett speciellt värde som skickas till en callback-funktion för att ange att "
"det inte finns några argument för anropet."

msgid ""
"When an active event occurs, the registered callback function is called. "
"Callback functions returning an object other than :data:`DISABLE` will have "
"no effect. Different events will provide the callback function with "
"different arguments, as follows:"
msgstr ""
"När en aktiv händelse inträffar anropas den registrerade callback-"
"funktionen. Callback-funktioner som returnerar ett annat objekt än :data:"
"`DISABLE` kommer inte att ha någon effekt. Olika händelser kommer att ge "
"callback-funktionen olika argument, enligt följande:"

msgid ":monitoring-event:`PY_START` and :monitoring-event:`PY_RESUME`::"
msgstr ":monitoring-event:`PY_START` och :monitoring-event:`PY_RESUME`::"

msgid "func(code: CodeType, instruction_offset: int) -> object"
msgstr "func(code: CodeType, instruction_offset: int) -> objekt"

msgid ":monitoring-event:`PY_RETURN` and :monitoring-event:`PY_YIELD`::"
msgstr ":monitoring-event:`PY_RETURN` och :monitoring-event:`PY_YIELD`::"

msgid "func(code: CodeType, instruction_offset: int, retval: object) -> object"
msgstr ""
"func(code: CodeType, instruction_offset: int, retval: object) -> objekt"

msgid ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` and :monitoring-event:"
"`C_RETURN` (*arg0* can be :data:`MISSING` specifically)::"
msgstr ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` och :monitoring-event:"
"`C_RETURN` (*arg0* kan vara :data:`MISSING` specifikt)::"

msgid ""
"func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object) -> object"
msgstr ""
"func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object) -> object"

msgid ""
"*code* represents the code object where the call is being made, while "
"*callable* is the object that is about to be called (and thus triggered the "
"event). If there are no arguments, *arg0* is set to :data:`sys.monitoring."
"MISSING`."
msgstr ""
"*code* representerar det kodobjekt där anropet görs, medan *callable* är det "
"objekt som är på väg att anropas (och därmed utlöste händelsen). Om det inte "
"finns några argument, sätts *arg0* till :data:`sys.monitoring.MISSING`."

msgid ""
"For instance methods, *callable* will be the function object as found on the "
"class with *arg0* set to the instance (i.e. the ``self`` argument to the "
"method)."
msgstr ""
"För instansmetoder kommer *callable* att vara funktionsobjektet som finns i "
"klassen med *arg0* satt till instansen (dvs. ``self``-argumentet till "
"metoden)."

msgid ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-event:"
"`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-event:"
"`PY_THROW` and :monitoring-event:`STOP_ITERATION`::"
msgstr ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-event:"
"`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-event:"
"`PY_THROW` och :monitoring-event:`STOP_ITERATION`::"

msgid ""
"func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"object"
msgstr ""
"func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"objekt"

msgid ":monitoring-event:`LINE`::"
msgstr ":monitoring-event:`LINE`::"

msgid "func(code: CodeType, line_number: int) -> object"
msgstr "func(code: CodeType, line_number: int) -> objekt"

msgid ""
":monitoring-event:`BRANCH_LEFT`, :monitoring-event:`BRANCH_RIGHT` and :"
"monitoring-event:`JUMP`::"
msgstr ""
":monitoring-event:`BRANCH_LEFT`, :monitoring-event:`BRANCH_RIGHT` och :"
"monitoring-event:`JUMP`::"

msgid ""
"func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"object"
msgstr ""
"func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"objekt"

msgid "Note that the *destination_offset* is where the code will next execute."
msgstr ""
"Observera att *destination_offset* är den plats där koden kommer att "
"exekveras nästa gång."

msgid ":monitoring-event:`INSTRUCTION`::"
msgstr ":monitoring-event:`INSTRUCTION`::"
