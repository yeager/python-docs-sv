# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!readline` --- GNU readline interface"
msgstr ":mod:`!readline` --- GNU:s gränssnitt för readline"

msgid ""
"The :mod:`readline` module defines a number of functions to facilitate "
"completion and reading/writing of history files from the Python interpreter. "
"This module can be used directly, or via the :mod:`rlcompleter` module, "
"which supports completion of Python identifiers at the interactive prompt.  "
"Settings made using  this module affect the behaviour of both the "
"interpreter's interactive prompt  and the prompts offered by the built-in :"
"func:`input` function."
msgstr ""
"Modulen :mod:`readline` definierar ett antal funktioner för att underlätta "
"komplettering och läsning/skrivning av historikfiler från Python-tolken. Den "
"här modulen kan användas direkt eller via modulen :mod:`rlcompleter`, som "
"stöder komplettering av Python-identifierare i den interaktiva prompten.  "
"Inställningar som görs med denna modul påverkar beteendet hos både tolkens "
"interaktiva prompt och de prompter som erbjuds av den inbyggda funktionen :"
"func:`input`."

msgid ""
"Readline keybindings may be configured via an initialization file, typically "
"``.inputrc`` in your home directory.  See `Readline Init File <https://"
"tiswww.cwru.edu/php/chet/readline/rluserman.html#Readline-Init-File>`_ in "
"the GNU Readline manual for information about the format and allowable "
"constructs of that file, and the capabilities of the Readline library in "
"general."
msgstr ""
"Readlines tangentbindningar kan konfigureras via en initialiseringsfil, "
"vanligtvis ``.inputrc`` i din hemkatalog.  Se `Readline Init File <https://"
"tiswww.cwru.edu/php/chet/readline/rluserman.html#Readline-Init-File>`_ i GNU "
"Readline-manualen för information om formatet och tillåtna konstruktioner i "
"den filen, och Readline-bibliotekets möjligheter i allmänhet."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""
"Denna modul stöds inte på :ref:`mobile platforms <mobile-availability>` "
"eller :ref:`WebAssembly platforms <wasm-availability>`."

msgid ""
"The underlying Readline library API may be implemented by the ``editline`` "
"(``libedit``) library instead of GNU readline. On macOS the :mod:`readline` "
"module detects which library is being used at run time."
msgstr ""
"Det underliggande API:et för Readline-biblioteket kan implementeras av "
"biblioteket ``editline`` (``libedit``) istället för GNU readline. På macOS "
"upptäcker modulen :mod:`readline` vilket bibliotek som används vid körning."

msgid ""
"The configuration file for ``editline`` is different from that of GNU "
"readline. If you programmatically load configuration strings you can use :"
"data:`backend` to determine which library is being used."
msgstr ""
"Konfigurationsfilen för ``editline`` skiljer sig från den för GNU readline. "
"Om du laddar konfigurationssträngar programmatiskt kan du använda :data:"
"`backend` för att avgöra vilket bibliotek som används."

msgid ""
"If you use ``editline``/``libedit`` readline emulation on macOS, the "
"initialization file located in your home directory is named ``.editrc``. For "
"example, the following content in ``~/.editrc`` will turn ON *vi* "
"keybindings and TAB completion::"
msgstr ""
"Om du använder ``editline``/`libedit`` readline-emulering på macOS, heter "
"initialiseringsfilen som finns i din hemkatalog ``.editrc``. Till exempel "
"kommer följande innehåll i ``~/.editrc`` att slå på *vi* tangentbindningar "
"och TAB-komplettering::"

msgid ""
"python:bind -v\n"
"python:bind ^I rl_complete"
msgstr ""
"python:bind -v\n"
"python:bind ^I rl_complete"

msgid ""
"Also note that different libraries may use different history file formats. "
"When switching the underlying library, existing history files may become "
"unusable."
msgstr ""
"Observera också att olika bibliotek kan använda olika format för "
"historikfiler. Vid byte av underliggande bibliotek kan befintliga "
"historikfiler bli oanvändbara."

msgid ""
"The name of the underlying Readline library being used, either "
"``\"readline\"`` or ``\"editline\"``."
msgstr ""
"Namnet på det underliggande Readline-biblioteket som används, antingen "
"``\"readline\"`` eller ``\"editline\"``."

msgid "Init file"
msgstr "Init-fil"

msgid "The following functions relate to the init file and user configuration:"
msgstr ""
"Följande funktioner är relaterade till init-filen och "
"användarkonfigurationen:"

msgid ""
"Execute the init line provided in the *string* argument. This calls :c:func:"
"`!rl_parse_and_bind` in the underlying library."
msgstr ""
"Exekverar den init-rad som anges i argumentet *string*. Detta anropar :c:"
"func:`!rl_parse_and_bind` i det underliggande biblioteket."

msgid ""
"Execute a readline initialization file. The default filename is the last "
"filename used. This calls :c:func:`!rl_read_init_file` in the underlying "
"library. It raises an :ref:`auditing event <auditing>` ``open`` with the "
"file name if given, and :code:`\"<readline_init_file>\"` otherwise, "
"regardless of which file the library resolves."
msgstr ""
"Exekverar en initialiseringsfil för readline. Standardfilnamnet är det "
"senast använda filnamnet. Detta anropar :c:func:`!rl_read_init_file` i det "
"underliggande biblioteket. Det utlöser en :ref:``auditing event "
"<auditing>``open`` med filnamnet om det anges, och :code:"
"`\"<readline_init_file>\"` annars, oavsett vilken fil biblioteket löser."

msgid "The auditing event was added."
msgstr "Evenemanget för revision lades till."

msgid "Line buffer"
msgstr "Linjebuffert"

msgid "The following functions operate on the line buffer:"
msgstr "Följande funktioner arbetar på linjebufferten:"

msgid ""
"Return the current contents of the line buffer (:c:data:`!rl_line_buffer` in "
"the underlying library)."
msgstr ""
"Returnera det aktuella innehållet i radbufferten (:c:data:`!rl_line_buffer` "
"i det underliggande biblioteket)."

msgid ""
"Insert text into the line buffer at the cursor position.  This calls :c:func:"
"`!rl_insert_text` in the underlying library, but ignores the return value."
msgstr ""
"Infoga text i radbufferten vid markörens position.  Detta anropar :c:func:`!"
"rl_insert_text` i det underliggande biblioteket, men ignorerar returvärdet."

msgid ""
"Change what's displayed on the screen to reflect the current contents of the "
"line buffer.  This calls :c:func:`!rl_redisplay` in the underlying library."
msgstr ""
"Ändra vad som visas på skärmen så att det återspeglar det aktuella "
"innehållet i radbufferten.  Detta anropar :c:func:`!rl_redisplay` i det "
"underliggande biblioteket."

msgid "History file"
msgstr "Historikfil"

msgid "The following functions operate on a history file:"
msgstr "Följande funktioner arbetar med en historikfil:"

msgid ""
"Load a readline history file, and append it to the history list. The default "
"filename is :file:`~/.history`.  This calls :c:func:`!read_history` in the "
"underlying library and raises an :ref:`auditing event <auditing>` ``open`` "
"with the file name if given and :code:`\"~/.history\"` otherwise."
msgstr ""
"Läser in en readline-historikfil och lägger till den i historiklistan. "
"Standardfilnamnet är :file:`~/.history`.  Detta anropar :c:func:`!"
"read_history` i det underliggande biblioteket och skapar en :ref:`auditing "
"event <auditing>` ``open`` med filnamnet om det är givet och :code:`\"~/."
"history\"` annars."

msgid ""
"Save the history list to a readline history file, overwriting any existing "
"file.  The default filename is :file:`~/.history`.  This calls :c:func:`!"
"write_history` in the underlying library and raises an :ref:`auditing event "
"<auditing>` ``open`` with the file name if given and :code:`\"~/.history\"` "
"otherwise."
msgstr ""
"Spara historiklistan i en historikfil för readline och skriv över en "
"eventuell befintlig fil.  Standardfilnamnet är :file:`~/.history`.  Detta "
"anropar :c:func:`!write_history` i det underliggande biblioteket och skapar "
"en :ref:`auditing event <auditing>` ``open`` med filnamnet om det anges och :"
"code:`\"~/.history\"` annars."

msgid ""
"Append the last *nelements* items of history to a file.  The default "
"filename is :file:`~/.history`.  The file must already exist.  This calls :c:"
"func:`!append_history` in the underlying library.  This function only exists "
"if Python was compiled for a version of the library that supports it. It "
"raises an :ref:`auditing event <auditing>` ``open`` with the file name if "
"given and :code:`\"~/.history\"` otherwise."
msgstr ""
"Lägg till de sista *nelements*-posterna i historiken till en fil.  "
"Standardfilnamnet är :file:`~/.history`.  Filen måste redan existera.  Detta "
"anropar :c:func:`!append_history` i det underliggande biblioteket.  Denna "
"funktion existerar endast om Python kompilerades för en version av "
"biblioteket som stödjer den. Den skapar en :ref:`auditing event <auditing>` "
"``open`` med filnamnet om det anges och :code:`\"~/.history\"` annars."

msgid ""
"Set or return the desired number of lines to save in the history file. The :"
"func:`write_history_file` function uses this value to truncate the history "
"file, by calling :c:func:`!history_truncate_file` in the underlying "
"library.  Negative values imply unlimited history file size."
msgstr ""
"Ställ in eller returnera önskat antal rader som ska sparas i historikfilen. "
"Funktionen :func:`write_history_file` använder detta värde för att trunkera "
"historikfilen genom att anropa :c:func:`!history_truncate_file` i det "
"underliggande biblioteket.  Negativa värden innebär obegränsad storlek på "
"historikfilen."

msgid "History list"
msgstr "Historisk lista"

msgid "The following functions operate on a global history list:"
msgstr "Följande funktioner arbetar med en global historiklista:"

msgid ""
"Clear the current history.  This calls :c:func:`!clear_history` in the "
"underlying library.  The Python function only exists if Python was compiled "
"for a version of the library that supports it."
msgstr ""
"Rensa den aktuella historiken.  Detta anropar :c:func:`!clear_history` i det "
"underliggande biblioteket.  Python-funktionen finns bara om Python "
"kompilerades för en version av biblioteket som stöder den."

msgid ""
"Return the number of items currently in the history.  (This is different "
"from :func:`get_history_length`, which returns the maximum number of lines "
"that will be written to a history file.)"
msgstr ""
"Returnerar antalet objekt som för närvarande finns i historiken.  (Detta "
"skiljer sig från :func:`get_history_length`, som returnerar det maximala "
"antalet rader som kommer att skrivas till en historikfil)"

msgid ""
"Return the current contents of history item at *index*.  The item index is "
"one-based.  This calls :c:func:`!history_get` in the underlying library."
msgstr ""
"Returnerar det aktuella innehållet i historikobjektet på *index*.  Objektets "
"index är ettbaserat.  Detta anropar :c:func:`!history_get` i det "
"underliggande biblioteket."

msgid ""
"Remove history item specified by its position from the history. The position "
"is zero-based.  This calls :c:func:`!remove_history` in the underlying "
"library."
msgstr ""
"Tar bort ett historiskt objekt som specificeras av dess position i "
"historiken. Positionen är nollbaserad.  Detta anropar :c:func:`!"
"remove_history` i det underliggande biblioteket."

msgid ""
"Replace history item specified by its position with *line*. The position is "
"zero-based.  This calls :c:func:`!replace_history_entry` in the underlying "
"library."
msgstr ""
"Ersätt historikobjektet som specificeras av dess position med *line*. "
"Positionen är nollbaserad.  Detta anropar :c:func:`!replace_history_entry` i "
"det underliggande biblioteket."

msgid ""
"Append *line* to the history buffer, as if it was the last line typed. This "
"calls :c:func:`!add_history` in the underlying library."
msgstr ""
"Lägger till *rad* till historiebufferten, som om det var den senast skrivna "
"raden. Detta anropar :c:func:`!add_history` i det underliggande biblioteket."

msgid ""
"Enable or disable automatic calls to :c:func:`!add_history` when reading "
"input via readline.  The *enabled* argument should be a Boolean value that "
"when true, enables auto history, and that when false, disables auto history."
msgstr ""
"Aktivera eller inaktivera automatiska anrop till :c:func:`!add_history` när "
"indata läses via readline.  Argumentet *enabled* bör vara ett booleskt värde "
"som när det är sant aktiverar automatisk historik och som när det är falskt "
"inaktiverar automatisk historik."

msgid ""
"Auto history is enabled by default, and changes to this do not persist "
"across multiple sessions."
msgstr ""
"Automatisk historik är aktiverad som standard och ändringar i denna sparas "
"inte över flera sessioner."

msgid "Startup hooks"
msgstr "Hooks för uppstart"

msgid ""
"Set or remove the function invoked by the :c:data:`!rl_startup_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments just before "
"readline prints the first prompt."
msgstr ""
"Ställ in eller ta bort den funktion som anropas av :c:data:`!"
"rl_startup_hook` callback i det underliggande biblioteket.  Om *function* "
"anges kommer den att användas som den nya hook-funktionen; om den utelämnas "
"eller ``None``, kommer alla funktioner som redan är installerade att tas "
"bort.  Kroken anropas utan argument strax innan readline skriver ut den "
"första prompten."

msgid ""
"Set or remove the function invoked by the :c:data:`!rl_pre_input_hook` "
"callback of the underlying library.  If *function* is specified, it will be "
"used as the new hook function; if omitted or ``None``, any function already "
"installed is removed.  The hook is called with no arguments after the first "
"prompt has been printed and just before readline starts reading input "
"characters.  This function only exists if Python was compiled for a version "
"of the library that supports it."
msgstr ""
"Ställ in eller ta bort den funktion som anropas av :c:data:`!"
"rl_pre_input_hook` callback i det underliggande biblioteket.  Om *function* "
"anges kommer den att användas som den nya hook-funktionen; om den utelämnas "
"eller ``None`` tas alla funktioner som redan är installerade bort.  Kroken "
"anropas utan argument efter att den första prompten har skrivits ut och "
"strax innan readline börjar läsa in tecken.  Den här funktionen finns bara "
"om Python kompilerades för en version av biblioteket som stöder den."

msgid "Completion"
msgstr "Slutfört"

msgid ""
"The following functions relate to implementing a custom word completion "
"function.  This is typically operated by the Tab key, and can suggest and "
"automatically complete a word being typed.  By default, Readline is set up "
"to be used by :mod:`rlcompleter` to complete Python identifiers for the "
"interactive interpreter.  If the :mod:`readline` module is to be used with a "
"custom completer, a different set of word delimiters should be set."
msgstr ""
"Följande funktioner handlar om att implementera en anpassad "
"ordkompletteringsfunktion.  Denna styrs vanligtvis av tabbtangenten och kan "
"föreslå och automatiskt komplettera ett ord som skrivs.  Som standard är "
"Readline inställt på att användas av :mod:`rlcompleter` för att komplettera "
"Python-identifierare för den interaktiva tolken.  Om modulen :mod:`readline` "
"ska användas med en anpassad kompletterare, bör en annan uppsättning "
"ordavgränsare anges."

msgid ""
"Set or remove the completer function.  If *function* is specified, it will "
"be used as the new completer function; if omitted or ``None``, any completer "
"function already installed is removed.  The completer function is called as "
"``function(text, state)``, for *state* in ``0``, ``1``, ``2``, ..., until it "
"returns a non-string value.  It should return the next possible completion "
"starting with *text*."
msgstr ""
"Ställ in eller ta bort kompletteringsfunktionen.  Om *function* anges kommer "
"den att användas som den nya kompletteringsfunktionen; om den utelämnas "
"eller ``None``, kommer alla kompletteringsfunktioner som redan är "
"installerade att tas bort.  Kompletteringsfunktionen anropas som "
"``function(text, state)``, för *state* i ``0``, ``1``, ``2``, ..., tills den "
"returnerar ett icke-strängvärde.  Den bör returnera nästa möjliga "
"komplettering som börjar med *text*."

msgid ""
"The installed completer function is invoked by the *entry_func* callback "
"passed to :c:func:`!rl_completion_matches` in the underlying library. The "
"*text* string comes from the first parameter to the :c:data:`!"
"rl_attempted_completion_function` callback of the underlying library."
msgstr ""
"Den installerade kompletteringsfunktionen anropas av den *entry_func* "
"callback som skickas till :c:func:`!rl_completion_matches` i det "
"underliggande biblioteket. Strängen *text* kommer från den första parametern "
"till anropet :c:data:`!rl_attempted_completion_function` i det underliggande "
"biblioteket."

msgid ""
"Get the completer function, or ``None`` if no completer function has been "
"set."
msgstr ""
"Hämta kompletteringsfunktionen, eller ``None`` om ingen "
"kompletteringsfunktion har angetts."

msgid ""
"Get the type of completion being attempted.  This returns the :c:data:`!"
"rl_completion_type` variable in the underlying library as an integer."
msgstr ""
"Hämtar den typ av avslutning som försöks.  Detta returnerar :c:data:`!"
"rl_completion_type`-variabeln i det underliggande biblioteket som ett heltal."

msgid ""
"Get the beginning or ending index of the completion scope. These indexes are "
"the *start* and *end* arguments passed to the :c:data:`!"
"rl_attempted_completion_function` callback of the underlying library.  The "
"values may be different in the same input editing scenario based on the "
"underlying C readline implementation. Ex: libedit is known to behave "
"differently than libreadline."
msgstr ""
"Hämtar start- eller slutindex för slutförandets omfattning. Dessa index är "
"de *start* och *slut* argument som skickas till :c:data:`!"
"rl_attempted_completion_function` callback i det underliggande biblioteket.  "
"Värdena kan vara olika i samma inmatningsredigeringsscenario beroende på den "
"underliggande C readline-implementeringen. Ex: libedit är känt för att bete "
"sig annorlunda än libreadline."

msgid ""
"Set or get the word delimiters for completion.  These determine the start of "
"the word to be considered for completion (the completion scope). These "
"functions access the :c:data:`!rl_completer_word_break_characters` variable "
"in the underlying library."
msgstr ""
"Ange eller hämta ordavgränsare för komplettering.  Dessa bestämmer början på "
"det ord som ska beaktas för komplettering (kompletteringens omfattning). "
"Dessa funktioner använder variabeln :c:data:`!"
"rl_completer_word_break_characters` i det underliggande biblioteket."

msgid ""
"Set or remove the completion display function.  If *function* is specified, "
"it will be used as the new completion display function; if omitted or "
"``None``, any completion display function already installed is removed.  "
"This sets or clears the :c:data:`!rl_completion_display_matches_hook` "
"callback in the underlying library.  The completion display function is "
"called as ``function(substitution, [matches], longest_match_length)`` once "
"each time matches need to be displayed."
msgstr ""
"Ställ in eller ta bort funktionen för visning av komplettering.  Om "
"*function* anges kommer den att användas som ny funktion för visning av "
"kompletteringar; om den utelämnas eller ``None`` tas alla funktioner för "
"visning av kompletteringar som redan är installerade bort.  Detta ställer in "
"eller rensar :c:data:`!rl_completion_display_matches_hook` callback i det "
"underliggande biblioteket.  Funktionen för visning av komplettering anropas "
"som ``function(substitution, [matches], longest_match_length)`` en gång "
"varje gång matchningar behöver visas."

msgid "Example"
msgstr "Exempel"

msgid ""
"The following example demonstrates how to use the :mod:`readline` module's "
"history reading and writing functions to automatically load and save a "
"history file named :file:`.python_history` from the user's home directory.  "
"The code below would normally be executed automatically during interactive "
"sessions from the user's :envvar:`PYTHONSTARTUP` file. ::"
msgstr ""
"Följande exempel visar hur man använder :mod:`readline`-modulens funktioner "
"för att läsa och skriva historik för att automatiskt ladda och spara en "
"historikfil med namnet :file:`.python_history` från användarens hemkatalog.  "
"Koden nedan skulle normalt exekveras automatiskt under interaktiva sessioner "
"från användarens :envvar:`PYTHONSTARTUP`-fil. ::"

msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # default history len is -1 (infinite), which may grow unruly\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    # default history len is -1 (infinite), which may grow unruly\n"
"    readline.set_history_length(1000)\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"atexit.register(readline.write_history_file, histfile)"

msgid ""
"This code is actually automatically run when Python is run in :ref:"
"`interactive mode <tut-interactive>` (see :ref:`rlcompleter-config`)."
msgstr ""
"Den här koden körs faktiskt automatiskt när Python körs i :ref:``interaktivt "
"läge <tut-interactive>`` (se :ref:`rlcompleter-config`)."

msgid ""
"The following example achieves the same goal but supports concurrent "
"interactive sessions, by only appending the new history. ::"
msgstr ""
"Följande exempel uppnår samma mål men stöder samtidiga interaktiva sessioner "
"genom att bara lägga till den nya historiken. ::"

msgid ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"
msgstr ""
"import atexit\n"
"import os\n"
"import readline\n"
"histfile = os.path.join(os.path.expanduser(\"~\"), \".python_history\")\n"
"\n"
"try:\n"
"    readline.read_history_file(histfile)\n"
"    h_len = readline.get_current_history_length()\n"
"except FileNotFoundError:\n"
"    open(histfile, 'wb').close()\n"
"    h_len = 0\n"
"\n"
"def save(prev_h_len, histfile):\n"
"    new_h_len = readline.get_current_history_length()\n"
"    readline.set_history_length(1000)\n"
"    readline.append_history_file(new_h_len - prev_h_len, histfile)\n"
"atexit.register(save, h_len, histfile)"

msgid ""
"The following example extends the :class:`code.InteractiveConsole` class to "
"support history save/restore. ::"
msgstr ""
"Följande exempel utökar :class:`code.InteractiveConsole`-klassen för att "
"stödja historiksparande/återställning. ::"

msgid ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"
msgstr ""
"import atexit\n"
"import code\n"
"import os\n"
"import readline\n"
"\n"
"class HistoryConsole(code.InteractiveConsole):\n"
"    def __init__(self, locals=None, filename=\"<console>\",\n"
"                 histfile=os.path.expanduser(\"~/.console-history\")):\n"
"        code.InteractiveConsole.__init__(self, locals, filename)\n"
"        self.init_history(histfile)\n"
"\n"
"    def init_history(self, histfile):\n"
"        readline.parse_and_bind(\"tab: complete\")\n"
"        if hasattr(readline, \"read_history_file\"):\n"
"            try:\n"
"                readline.read_history_file(histfile)\n"
"            except FileNotFoundError:\n"
"                pass\n"
"            atexit.register(self.save_history, histfile)\n"
"\n"
"    def save_history(self, histfile):\n"
"        readline.set_history_length(1000)\n"
"        readline.write_history_file(histfile)"
