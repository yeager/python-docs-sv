# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Pythons felsökare"

msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**Källkod:** :source:`Lib/pdb.py`"

msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python "
"programs.  It supports setting (conditional) breakpoints and single stepping "
"at the source line level, inspection of stack frames, source code listing, "
"and evaluation of arbitrary Python code in the context of any stack frame.  "
"It also supports post-mortem debugging and can be called under program "
"control."
msgstr ""
"Modulen :mod:`pdb` definierar en interaktiv källkodsdebugger för Python-"
"program.  Den stöder inställning av (villkorliga) brytpunkter och single "
"stepping på källkodsnivå, inspektion av stapelramar, källkodslistning och "
"utvärdering av godtycklig Python-kod i samband med valfri stapelram.  Den "
"stöder också felsökning efter avslutad användning och kan anropas under "
"programkontroll."

msgid ""
"The debugger is extensible -- it is actually defined as the class :class:"
"`Pdb`. This is currently undocumented but easily understood by reading the "
"source.  The extension interface uses the modules :mod:`bdb` and :mod:`cmd`."
msgstr ""
"Felsökaren är utbyggbar -- den är faktiskt definierad som klassen :class:"
"`Pdb`. Detta är för närvarande odokumenterat men lätt att förstå genom att "
"läsa källan.  Gränssnittet för utökning använder modulerna :mod:`bdb` och :"
"mod:`cmd`."

msgid "Module :mod:`faulthandler`"
msgstr "Modul :mod:`faulthandler`"

msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr ""
"Används för att dumpa Python-spårningar explicit, vid ett fel, efter en "
"timeout eller vid en användarsignal."

msgid "Module :mod:`traceback`"
msgstr "Modul :mod:`traceback`"

msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""
"Standardgränssnitt för att extrahera, formatera och skriva ut stackspår från "
"Python-program."

msgid "The typical usage to break into the debugger is to insert::"
msgstr ""
"Den typiska användningen för att bryta sig in i felsökaren är att infoga::"

msgid "import pdb; pdb.set_trace()"
msgstr "import pdb; pdb.set_trace()"

msgid "Or::"
msgstr "Eller::"

msgid "breakpoint()"
msgstr "breakpoint()"

msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"på den plats där du vill bryta dig in i debuggern och kör sedan programmet. "
"Du kan sedan gå igenom koden efter detta uttalande och fortsätta att köra "
"utan debuggern med kommandot :pdbcmd:`continue`."

msgid ""
"The built-in :func:`breakpoint`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"Den inbyggda :func:`breakpoint` kan, när den anropas med standardvärden, "
"användas istället för ``import pdb; pdb.set_trace()``."

msgid ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"
msgstr ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"

msgid ""
"The debugger's prompt is ``(Pdb)``, which is the indicator that you are in "
"debug mode::"
msgstr ""
"Felsökarens prompt är ``(Pdb)``, vilket är en indikator på att du befinner "
"dig i felsökningsläge::"

msgid ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"
msgstr ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"

msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"Tabbkomplettering via modulen :mod:`readline` är tillgänglig för kommandon "
"och kommandonas argument, t.ex. erbjuds de aktuella globala och lokala "
"namnen som argument för kommandot ``p``."

msgid ""
"You can also invoke :mod:`pdb` from the command line to debug other "
"scripts.  For example::"
msgstr ""
"Du kan också anropa :mod:`pdb` från kommandoraden för att felsöka andra "
"skript.  Till exempel::"

msgid "python -m pdb [-c command] (-m module | -p pid | pyfile) [args ...]"
msgstr "python -m pdb [-c command] (-m module | -p pid | pyfile) [args ...]"

msgid ""
"When invoked as a module, pdb will automatically enter post-mortem debugging "
"if the program being debugged exits abnormally.  After post-mortem debugging "
"(or after normal exit of the program), pdb will restart the program.  "
"Automatic restarting preserves pdb's state (such as breakpoints) and in most "
"cases is more useful than quitting the debugger upon program's exit."
msgstr ""
"När pdb anropas som en modul kommer den automatiskt att gå in i post-mortem-"
"felsökning om det program som felsöks avslutas på ett onormalt sätt.  Efter "
"post-mortem-felsökning (eller efter normal avslutning av programmet) kommer "
"pdb att starta om programmet.  Automatisk omstart bevarar pdb:s status (t."
"ex. brytpunkter) och är i de flesta fall mer användbart än att avsluta "
"felsökaren när programmet avslutas."

msgid ""
"To execute commands as if given in a :file:`.pdbrc` file; see :ref:`debugger-"
"commands`."
msgstr ""
"För att utföra kommandon som om de vore angivna i en :file:`.pdbrc`-fil; se :"
"ref:`debugger-commands`."

msgid "Added the ``-c`` option."
msgstr "Alternativet ``-c`` har lagts till."

msgid ""
"To execute modules similar to the way ``python -m`` does. As with a script, "
"the debugger will pause execution just before the first line of the module."
msgstr ""
"För att exekvera moduler på samma sätt som ``python -m`` gör. Precis som med "
"ett skript kommer felsökaren att pausa exekveringen precis före modulens "
"första rad."

msgid "Added the ``-m`` option."
msgstr "Lagt till alternativet ``-m``."

msgid "Attach to the process with the specified PID."
msgstr "Anslut till processen med angiven PID."

msgid ""
"To attach to a running Python process for remote debugging, use the ``-p`` "
"or ``--pid`` option with the target process's PID::"
msgstr ""
"Om du vill koppla till en Python-process som körs för fjärrfelsökning "
"använder du alternativet ``-p`` eller ``--pid`` med målprocessens PID::"

msgid "python -m pdb -p 1234"
msgstr "python -m pdb -p 1234"

msgid ""
"Attaching to a process that is blocked in a system call or waiting for I/O "
"will only work once the next bytecode instruction is executed or when the "
"process receives a signal."
msgstr ""
"Att ansluta till en process som är blockerad i ett systemanrop eller väntar "
"på I/O fungerar först när nästa bytecode-instruktion utförs eller när "
"processen får en signal."

msgid "Typical usage to execute a statement under control of the debugger is::"
msgstr ""
"Typisk användning för att exekvera en sats under kontroll av debuggern är::"

msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"

msgid "The typical usage to inspect a crashed program is::"
msgstr "Den typiska användningen för att inspektera ett kraschat program är::"

msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"

msgid ""
"The implementation of :pep:`667` means that name assignments made via "
"``pdb`` will immediately affect the active scope, even when running inside "
"an :term:`optimized scope`."
msgstr ""
"Implementeringen av :pep:`667` innebär att namntilldelningar som görs via "
"``pdb`` omedelbart kommer att påverka det aktiva scopet, även när det körs i "
"ett :term:`optimerat scope`."

msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr ""
"Modulen definierar följande funktioner, som alla går in i felsökaren på lite "
"olika sätt:"

msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the "
"environment in which the code is executed; by default the dictionary of the "
"module :mod:`__main__` is used.  (See the explanation of the built-in :func:"
"`exec` or :func:`eval` functions.)"
msgstr ""
"Exekverar *satsen* (angiven som en sträng eller ett kodobjekt) under "
"debuggerkontroll.  Du kan sätta brytpunkter och skriva :pdbcmd:`continue`, "
"eller så kan du stega genom satsen med :pdbcmd:`step` eller :pdbcmd:`next` "
"(alla dessa kommandon förklaras nedan).  De valfria argumenten *globals* och "
"*locals* anger den miljö i vilken koden exekveras; som standard används "
"ordlistan för modulen :mod:`__main__`.  (Se förklaringen av de inbyggda "
"funktionerna :func:`exec` eller :func:`eval`)"

msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the "
"*expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""
"Utvärdera *uttrycket* (givet som en sträng eller ett kodobjekt) under "
"debuggerkontroll.  När :func:`runeval` returnerar, returnerar den värdet av "
"*uttrycket*.  I övrigt är denna funktion lik :func:`run`."

msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function "
"is entered."
msgstr ""
"Anropar *funktionen* (ett funktions- eller metodobjekt, inte en sträng) med "
"de angivna argumenten.  När :func:`runcall` returneras, returneras det som "
"funktionsanropet returnerade.  Felsökarprompten visas så snart funktionen "
"har angetts."

msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header* "
"is printed to the console just before debugging begins. The *commands* "
"argument, if given, is a list of commands to execute when the debugger "
"starts."
msgstr ""
"Gå in i debuggern vid den anropande stackramen.  Detta är användbart för att "
"hårdkoda en brytpunkt vid en viss punkt i ett program, även om koden inte "
"felsöks på något annat sätt (t.ex. när ett påstående misslyckas).  Om "
"*header* anges skrivs den ut i konsolen precis innan felsökningen påbörjas. "
"Argumentet *commands*, om det anges, är en lista med kommandon som ska "
"utföras när felsökaren startar."

msgid "The keyword-only argument *header*."
msgstr "Argumentet *header* är endast nyckelord."

msgid ""
":func:`set_trace` will enter the debugger immediately, rather than on the "
"next line of code to be executed."
msgstr ""
":func:`set_trace` kommer att gå in i felsökaren omedelbart, snarare än på "
"nästa kodrad som ska exekveras."

msgid "The *commands* argument."
msgstr "Argumentet *kommandon*."

msgid ""
"async version of :func:`set_trace`. This function should be used inside an "
"async function with :keyword:`await`."
msgstr ""
"asynkron version av :func:`set_trace`. Denna funktion bör användas inuti en "
"asynkron funktion med :keyword:`await`."

msgid ""
"async def f():\n"
"    await pdb.set_trace_async()"
msgstr ""
"async def f():\n"
"    await pdb.set_trace_async()"

msgid ""
":keyword:`await` statements are supported if the debugger is invoked by this "
"function."
msgstr ""
":keyword:`await` statements stöds om debuggern anropas av denna funktion."

msgid ""
"Enter post-mortem debugging of the given exception or :ref:`traceback object "
"<traceback-objects>`. If no value is given, it uses the exception that is "
"currently being handled, or raises ``ValueError`` if there isn’t one."
msgstr ""
"Startar felsökning av det angivna undantaget eller :ref:`traceback-objektet "
"<traceback-objects>`. Om inget värde anges används det undantag som för "
"närvarande hanteras, eller ``ValueError`` om det inte finns något."

msgid "Support for exception objects was added."
msgstr "Stöd för undantagsobjekt har lagts till."

msgid ""
"Enter post-mortem debugging of the exception found in :data:`sys.last_exc`."
msgstr ""
"Starta felsökning efteråt av undantaget som hittades i :data:`sys.last_exc`."

msgid ""
"There are two supported backends for pdb: ``'settrace'`` and "
"``'monitoring'``. See :class:`bdb.Bdb` for details. The user can set the "
"default backend to use if none is specified when instantiating :class:`Pdb`. "
"If no backend is specified, the default is ``'settrace'``."
msgstr ""
"Det finns två backends som stöds för pdb: ``'settrace'`` och "
"``'monitoring'``. Se :class:`bdb.Bdb` för mer information. Användaren kan "
"ange vilken standardbackend som ska användas om ingen anges vid "
"instansiering av :class:`Pdb`. Om ingen backend specificeras är standard "
"``'settrace'``."

msgid ""
":func:`breakpoint` and :func:`set_trace` will not be affected by this "
"function. They always use ``'monitoring'`` backend."
msgstr ""
":func:`breakpoint` och :func:`set_trace` kommer inte att påverkas av denna "
"funktion. De använder alltid ``'monitoring'`` backend."

msgid "Returns the default backend for pdb."
msgstr "Returnerar standardbackend för pdb."

msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want "
"to access further features, you have to do this yourself:"
msgstr ""
"Funktionerna ``run*`` och :func:`set_trace`` är alias för att instansiera "
"klassen :class:`Pdb` och anropa metoden med samma namn.  Om du vill ha "
"tillgång till ytterligare funktioner måste du göra detta själv:"

msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` är klassen för felsökare."

msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"Argumenten *completekey*, *stdin* och *stdout* skickas till den "
"underliggande :class:`cmd.Cmd`-klassen; se beskrivningen där."

msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. [1]_"
msgstr ""
"Argumentet *skip*, om det anges, måste vara en iterabel av modulnamnsmönster "
"i glob-stil.  Felsökaren kommer inte att gå in i ramar som har sitt ursprung "
"i en modul som matchar något av dessa mönster. [1]_"

msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the "
"user presses :kbd:`Ctrl-C` on the console) when you give a :pdbcmd:"
"`continue` command. This allows you to break into the debugger again by "
"pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT handler, "
"set *nosigint* to true."
msgstr ""
"Som standard ställer Pdb in en hanterare för SIGINT-signalen (som skickas "
"när användaren trycker på :kbd:`Ctrl-C` på konsolen) när du ger ett :pdbcmd:"
"`continue`-kommando. Detta gör att du kan bryta dig in i felsökaren igen "
"genom att trycka på :kbd:`Ctrl-C`.  Om du vill att Pdb inte ska röra SIGINT-"
"hanteraren ska du sätta *nosigint* till true."

msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load ."
"pdbrc files from the filesystem."
msgstr ""
"Argumentet *readrc* är som standard true och styr om Pdb ska läsa in .pdbrc-"
"filer från filsystemet."

msgid ""
"The *mode* argument specifies how the debugger was invoked. It impacts the "
"workings of some debugger commands. Valid values are ``'inline'`` (used by "
"the breakpoint() builtin), ``'cli'`` (used by the command line invocation) "
"or ``None`` (for backwards compatible behaviour, as before the *mode* "
"argument was added)."
msgstr ""
"Argumentet *mode* anger hur felsökaren startades. Det påverkar hur vissa "
"kommandon i felsökaren fungerar. Giltiga värden är ``'inline'`` (används av "
"breakpoint() builtin), ``'cli'`` (används av kommandoradsinställningen) "
"eller ``None`` (för bakåtkompatibelt beteende, som innan *mode*-argumentet "
"lades till)."

msgid ""
"The *backend* argument specifies the backend to use for the debugger. If "
"``None`` is passed, the default backend will be used. See :func:"
"`set_default_backend`. Otherwise the supported backends are ``'settrace'`` "
"and ``'monitoring'``."
msgstr ""
"Argumentet *backend* anger vilken backend som ska användas för felsökaren. "
"Om ``None`` skickas, kommer standardbackend att användas. Se :func:"
"`set_default_backend`. Annars är de backends som stöds ``'settrace'`` och "
"``'monitoring'``."

msgid ""
"The *colorize* argument, if set to ``True``, will enable colorized output in "
"the debugger, if color is supported. This will highlight source code "
"displayed in pdb."
msgstr ""
"Argumentet *colorize*, om det sätts till ``True``, aktiverar färgade utdata "
"i felsökaren, om färg stöds. Detta kommer att markera källkod som visas i "
"pdb."

msgid "Example call to enable tracing with *skip*::"
msgstr "Exempel på anrop för att aktivera spårning med *skip*::"

msgid "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"
msgstr "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr "Utlöser en :ref:`auditing event <auditing>` ``pdb.Pdb`` utan argument."

msgid "Added the *skip* parameter."
msgstr "Lagt till parametern *skip*."

msgid ""
"Added the *nosigint* parameter. Previously, a SIGINT handler was never set "
"by Pdb."
msgstr ""
"Parametern *nosigint* har lagts till. Tidigare ställdes aldrig en SIGINT-"
"hanterare in av Pdb."

msgid "The *readrc* argument."
msgstr "Argumentet *readrc*."

msgid "Added the *mode* argument."
msgstr "Lagt till argumentet *mode*."

msgid "Added the *backend* argument."
msgstr "Lagt till argumentet *backend*."

msgid "Added the *colorize* argument."
msgstr "Lagt till argumentet *colorize*."

msgid ""
"Inline breakpoints like :func:`breakpoint` or :func:`pdb.set_trace` will "
"always stop the program at calling frame, ignoring the *skip* pattern (if "
"any)."
msgstr ""
"Inline breakpoints som :func:`breakpoint` eller :func:`pdb.set_trace` "
"stoppar alltid programmet vid anropande frame och ignorerar *skip*-mönstret "
"(om sådant finns)."

msgid "See the documentation for the functions explained above."
msgstr "Se dokumentationen för de funktioner som beskrivs ovan."

msgid "Debugger Commands"
msgstr "Kommandon för felsökare"

msgid ""
"The commands recognized by the debugger are listed below.  Most commands can "
"be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not "
"``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"De kommandon som debuggern känner igen listas nedan.  De flesta kommandon "
"kan förkortas till en eller två bokstäver enligt vad som anges; t.ex. "
"betyder ``h(elp)`` att antingen ``h`` eller ``help`` kan användas för att "
"ange hjälpkommandot (men inte ``he`` eller ``hel``, inte heller ``H`` eller "
"``Help`` eller ``HELP``).  Argument till kommandon måste separeras med "
"blanksteg (mellanslag eller tabbar).  Valfria argument omsluts av "
"hakparenteser (``[]``) i kommandosyntaxen; hakparenteserna får inte "
"skrivas.  Alternativ i kommandosyntaxen separeras med en vertikal stapel (``|"
"``)."

msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr ""
"Om du skriver in en tom rad upprepas det senast inskrivna kommandot.  "
"Undantag: om det senaste kommandot var ett :pdbcmd:`list`-kommando, listas "
"de kommande 11 raderna."

msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"Kommandon som debuggern inte känner igen antas vara Python-satser och körs i "
"kontexten för det program som debuggas.  Python-satser kan också inledas med "
"ett utropstecken (``!``).  Detta är ett kraftfullt sätt att inspektera det "
"program som debuggas; det är till och med möjligt att ändra en variabel "
"eller anropa en funktion.  När ett undantag inträffar i ett sådant uttalande "
"skrivs undantagsnamnet ut, men debuggarens tillstånd ändras inte."

msgid ""
"Expressions/Statements whose prefix is a pdb command are now correctly "
"identified and executed."
msgstr ""
"Uttryck/satser vars prefix är ett pdb-kommando identifieras och exekveras nu "
"korrekt."

msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr ""
"Felsökaren stöder :ref:`aliaser <debugger-aliases>`.  Aliaser kan ha "
"parametrar som ger en viss anpassningsförmåga till det sammanhang som "
"undersöks."

msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or ``\";"
"\"\";\"``."
msgstr ""
"Flera kommandon kan anges på en rad, åtskilda av ``;;``.  (En enda ``;`` "
"används inte eftersom det är separatorn för flera kommandon på en rad som "
"skickas till Python-parsern)  Ingen intelligens används för att separera "
"kommandona; indata delas upp vid det första ``;;``-paret, även om det är "
"mitt i en citerad sträng. En lösning för strängar med dubbla semikolon är "
"att använda implicit strängkonkatenering ``';'';'`` eller ``\";\"\";\"``."

msgid ""
"To set a temporary global variable, use a *convenience variable*. A "
"*convenience variable* is a variable whose name starts with ``$``.  For "
"example, ``$foo = 1`` sets a global variable ``$foo`` which you can use in "
"the debugger session.  The *convenience variables* are cleared when the "
"program resumes execution so it's less likely to interfere with your program "
"compared to using normal variables like ``foo = 1``."
msgstr ""
"Om du vill ställa in en tillfällig global variabel använder du en "
"*konveniensvariabel*. En *konvenansvariabel* är en variabel vars namn börjar "
"med ``$``.  Till exempel, ``$foo = 1`` ställer in en global variabel "
"``$foo`` som du kan använda i felsökarsessionen.  *Vänlighetsvariablerna* "
"rensas när programmet återupptas, så det är mindre troligt att de stör "
"programmet jämfört med om du använder normala variabler som ``foo = 1``."

msgid "There are four preset *convenience variables*:"
msgstr "Det finns fyra förinställda *bekvämlighetsvariabler*:"

msgid "``$_frame``: the current frame you are debugging"
msgstr "``$_frame``: den aktuella bildrutan som du felsöker"

msgid "``$_retval``: the return value if the frame is returning"
msgstr "``$_retval``: returvärdet om ramen returnerar"

msgid "``$_exception``: the exception if the frame is raising an exception"
msgstr "``$_exception``: undantaget om ramen ger upphov till ett undantag"

msgid "``$_asynctask``: the asyncio task if pdb stops in an async function"
msgstr ""
"``$_asynctask``: asyncio-uppgiften om pdb stannar i en asynkron funktion"

msgid "Added the *convenience variable* feature."
msgstr "Lagt till funktionen *convenience variable*."

msgid "Added the ``$_asynctask`` convenience variable."
msgstr "Lagt till bekvämlighetsvariabeln ``$_asynctask``."

msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read with ``'utf-8'`` encoding and executed as if "
"it had been typed at the debugger prompt, with the exception that empty "
"lines and lines starting with ``#`` are ignored.  This is particularly "
"useful for aliases.  If both files exist, the one in the home directory is "
"read first and aliases defined there can be overridden by the local file."
msgstr ""
"Om filen :file:`.pdbrc` finns i användarens hemkatalog eller i den aktuella "
"katalogen, läses den med kodningen ``'utf-8'`` och exekveras som om den hade "
"skrivits i debuggerprompten, med undantaget att tomma rader och rader som "
"börjar med ``#`` ignoreras.  Detta är särskilt användbart för alias.  Om "
"båda filerna finns läses den som finns i hemkatalogen först och alias som "
"definieras där kan åsidosättas av den lokala filen."

msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as :"
"pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` kan nu innehålla kommandon som fortsätter felsökningen, t."
"ex. :pdbcmd:`continue` eller :pdbcmd:`next`.  Tidigare hade dessa kommandon "
"ingen effekt."

msgid ""
":file:`.pdbrc` is now read with ``'utf-8'`` encoding. Previously, it was "
"read with the system locale encoding."
msgstr ""
":file:`.pdbrc` läses nu med kodningen ``'utf-8'``. Tidigare lästes den med "
"systemets lokala kodning."

msgid ""
"Without argument, print the list of available commands.  With a *command* as "
"argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command* "
"argument must be an identifier, ``help exec`` must be entered to get help on "
"the ``!`` command."
msgstr ""
"Utan argument skrivs en lista över tillgängliga kommandon ut.  Med ett "
"*kommando* som argument, skriv ut hjälp om det kommandot.  ``help pdb`` "
"visar den fullständiga dokumentationen (dokumentsträngen för modulen :mod:"
"`pdb`).  Eftersom argumentet *command* måste vara en identifierare måste "
"``help exec`` anges för att få hjälp med kommandot ``!``."

msgid ""
"Print a stack trace, with the most recent frame at the bottom.  if *count* "
"is 0, print the current frame entry. If *count* is negative, print the least "
"recent - *count* frames. If *count* is positive, print the most recent "
"*count* frames.  An arrow (``>``) indicates the current frame, which "
"determines the context of most commands."
msgstr ""
"Skriv ut en stackspårning, med den senaste ramen längst ned. om *count* är "
"0, skriv ut den aktuella ramposten. Om *count* är negativt, skriv ut de "
"senaste - *count* ramarna. Om *count* är positiv, skriv ut de senaste "
"*count* ramarna.  En pil (``>``) anger aktuell bildruta, som bestämmer "
"sammanhanget för de flesta kommandon."

msgid "*count* argument is added."
msgstr "*count*-argumentet läggs till."

msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr ""
"Flytta den aktuella ramen *antal* (standard ett) nivåer nedåt i "
"stackspårningen (till en nyare ram)."

msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr ""
"Flytta den aktuella ramen *antal* (standard ett) nivåer uppåt i "
"stackspårningen (till en äldre ram)."

msgid ""
"With a *lineno* argument, set a break at line *lineno* in the current file. "
"The line number may be prefixed with a *filename* and a colon, to specify a "
"breakpoint in another file (possibly one that hasn't been loaded yet).  The "
"file is searched on :data:`sys.path`.  Acceptable forms of *filename* are ``/"
"abspath/to/file.py``, ``relpath/file.py``, ``module`` and ``package.module``."
msgstr ""
"Med ett *lineno*-argument, sätt en brytpunkt på rad *lineno* i den aktuella "
"filen. Radnumret kan föregås av ett *filnamn* och ett kolon, för att ange en "
"brytpunkt i en annan fil (eventuellt en som inte har laddats in ännu).  "
"Filen söks på :data:`sys.path`.  Godtagbara former av *filnamn* är ``/"
"abspath/to/file.py``, ``relpath/file.py``, ``module`` och ``package.module``."

msgid ""
"With a *function* argument, set a break at the first executable statement "
"within that function. *function* can be any expression that evaluates to a "
"function in the current namespace."
msgstr ""
"Med ett *function*-argument, sätt en paus vid den första körbara satsen i "
"den funktionen. *function* kan vara vilket uttryck som helst som utvärderas "
"till en funktion i den aktuella namnrymden."

msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr ""
"Om det finns ett andra argument är det ett uttryck som måste utvärderas till "
"sant innan brytpunkten respekteras."

msgid ""
"Without argument, list all breaks, including for each breakpoint, the number "
"of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr ""
"Utan argument listas alla brytpunkter, inklusive för varje brytpunkt, "
"antalet gånger brytpunkten har träffats, aktuellt ignoreringsantal och "
"eventuellt associerat villkor."

msgid ""
"Each breakpoint is assigned a number to which all the other breakpoint "
"commands refer."
msgstr ""
"Varje brytpunkt tilldelas ett nummer som alla andra brytpunktskommandon "
"hänvisar till."

msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr ""
"Tillfällig brytpunkt, som tas bort automatiskt när den träffas första "
"gången. Argumenten är desamma som för :pdbcmd:`break`."

msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"Med ett *filnamn:lineno*-argument rensar du alla brytpunkter på denna rad. "
"Med en mellanslagsseparerad lista med brytpunktsnummer rensas dessa "
"brytpunkter. Utan argument, rensa alla brytpunkter (men be först om "
"bekräftelse)."

msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"Inaktivera brytpunkterna som anges som en blankstegssorterad lista med "
"brytpunktsnummer.  Att inaktivera en brytpunkt innebär att den inte kan "
"orsaka att programmet stoppas, men till skillnad från att rensa en brytpunkt "
"finns den kvar i listan över brytpunkter och kan (åter)aktiveras."

msgid "Enable the breakpoints specified."
msgstr "Aktivera de angivna brytpunkterna."

msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the "
"ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""
"Ställ in ignoreringsantalet för det angivna brytpunktsnumret.  Om *count* "
"utelämnas sätts ignoreringsantalet till 0. En brytpunkt blir aktiv när "
"ignoreringsantalet är noll.  Om *count* inte är noll minskas det varje gång "
"brytpunkten nås och brytpunkten inte är inaktiverad och något associerat "
"villkor utvärderas till sant."

msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"Ange ett nytt *villkor* för brytpunkten, ett uttryck som måste utvärderas "
"till sant innan brytpunkten respekteras.  Om *condition* saknas tas alla "
"befintliga villkor bort, dvs. brytpunkten görs ovillkorlig."

msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"Ange en lista med kommandon för brytpunktsnummer *bpnumber*.  Själva "
"kommandona visas på följande rader.  Skriv en rad som bara innehåller "
"``end`` för att avsluta kommandona. Ett exempel::"

msgid ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"
msgstr ""
"(Pdb) kommandon 1\n"
"(com) p någon_variabel\n"
"(com) slut\n"
"(Pdb)"

msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr ""
"För att ta bort alla kommandon från en brytpunkt, skriv ``kommandon`` och "
"följ omedelbart efter med ``slut``, dvs. ge inga kommandon."

msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr ""
"Utan argumentet *bpnumber* hänvisar ``commands`` till den senast inställda "
"brytpunkten."

msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that "
"resumes execution."
msgstr ""
"Du kan använda brytpunktskommandon för att starta upp programmet igen.  "
"Använd helt enkelt kommandot :pdbcmd:`continue`, eller :pdbcmd:`step`, eller "
"något annat kommando som återupptar exekveringen."

msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, :"
"pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`until`, :pdbcmd:"
"`jump`, :pdbcmd:`quit` and their abbreviations) terminates the command list "
"(as if that command was immediately followed by end). This is because any "
"time you resume execution (even with a simple next or step), you may "
"encounter another breakpoint—which could have its own command list, leading "
"to ambiguities about which list to execute."
msgstr ""
"Om du anger ett kommando som återupptar körningen (för närvarande :pdbcmd:"
"`continue`, :pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:"
"`until`, :pdbcmd:`jump`, :pdbcmd:`quit` och deras förkortningar) avslutas "
"kommandolistan (som om kommandot omedelbart följdes av end). Detta beror på "
"att varje gång du återupptar körningen (även med ett enkelt next eller step) "
"kan du stöta på en annan brytpunkt - som kan ha sin egen kommandolista, "
"vilket leder till tvetydigheter om vilken lista som ska köras."

msgid ""
"If the list of commands contains the ``silent`` command, or a command that "
"resumes execution, then the breakpoint message containing information about "
"the frame is not displayed."
msgstr ""
"Om listan med kommandon innehåller kommandot ``silent``, eller ett kommando "
"som återupptar körningen, visas inte brytpunktsmeddelandet med information "
"om ramen."

msgid ""
"Frame information will not be displayed if a command that resumes execution "
"is present in the command list."
msgstr ""
"Raminformation visas inte om ett kommando som återupptar körningen finns i "
"kommandolistan."

msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr ""
"Exekvera den aktuella raden, stoppa vid första möjliga tillfälle (antingen i "
"en funktion som anropas eller på nästa rad i den aktuella funktionen)."

msgid ""
"Continue execution until the next line in the current function is reached or "
"it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"Fortsätter exekveringen tills nästa rad i den aktuella funktionen nås eller "
"tills den returneras.  (Skillnaden mellan :pdbcmd:`next` och :pdbcmd:`step` "
"är att :pdbcmd:`step` stannar inuti en anropad funktion, medan :pdbcmd:"
"`next` kör anropade funktioner i (nästan) full hastighet och bara stannar "
"vid nästa rad i den aktuella funktionen)"

msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr ""
"Utan argument fortsätter exekveringen tills raden med ett nummer som är "
"större än det aktuella nås."

msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr ""
"Med *lineno* fortsätter exekveringen tills en rad med ett nummer som är "
"större än eller lika med *lineno* nås.  I båda fallen stoppas också när den "
"aktuella ramen återkommer."

msgid "Allow giving an explicit line number."
msgstr "Tillåt att ange ett explicit linjenummer."

msgid "Continue execution until the current function returns."
msgstr "Fortsätt körningen tills den aktuella funktionen återkommer."

msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr "Fortsätt exekveringen, stoppa först när en brytpunkt påträffas."

msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr ""
"Ange nästa rad som ska köras.  Endast tillgängligt i den nedersta ramen.  "
"Detta gör att du kan hoppa tillbaka och exekvera kod igen, eller hoppa "
"framåt för att hoppa över kod som du inte vill köra."

msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a :"
"keyword:`finally` clause."
msgstr ""
"Det bör noteras att inte alla hopp är tillåtna -- det är t.ex. inte möjligt "
"att hoppa in i mitten av en :keyword:`for`-loop eller ut ur en :keyword:"
"`finally`-klausul."

msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11 "
"lines around at that line.  With two arguments, list the given range; if the "
"second argument is less than the first, it is interpreted as a count."
msgstr ""
"Listar källkoden för den aktuella filen.  Utan argument, lista 11 rader runt "
"den aktuella raden eller fortsätt med föregående lista.  Med ``.`` som "
"argument listas 11 rader runt den aktuella raden.  Med ett argument listas "
"11 rader runt den raden.  Med två argument listas det angivna intervallet; "
"om det andra argumentet är mindre än det första tolkas det som en räkning."

msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr ""
"Den aktuella raden i den aktuella bildrutan anges med ``->``.  Om ett "
"undantag felsöks, anges raden där undantaget ursprungligen uppstod eller "
"spreds med ``>>``, om den skiljer sig från den aktuella raden."

msgid "Added the ``>>`` marker."
msgstr "Lade till markören ``>>``."

msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr ""
"Lista all källkod för den aktuella funktionen eller ramen.  Intressanta "
"rader markeras som för :pdbcmd:`list`."

msgid "Print the arguments of the current function and their current values."
msgstr ""
"Skriv ut argumenten för den aktuella funktionen och deras aktuella värden."

msgid "Evaluate *expression* in the current context and print its value."
msgstr ""
"Utvärdera *uttryck* i det aktuella sammanhanget och skriv ut dess värde."

msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"``print()`` kan också användas, men är inte ett debugger-kommando --- detta "
"exekverar Python :func:`print`-funktionen."

msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr ""
"Som kommandot :pdbcmd:`p`, förutom att värdet av *uttryck* skrivs ut med "
"modulen :mod:`pprint`."

msgid "Print the type of *expression*."
msgstr "Skriv ut typen av *uttryck*."

msgid "Try to get source code of *expression* and display it."
msgstr "Försök att få fram källkoden för *uttryck* och visa den."

msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr ""
"Visa värdet på *uttryck* om det har ändrats, varje gång exekveringen stoppas "
"i den aktuella bildrutan."

msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr "Utan *uttryck* listas alla displayuttryck för den aktuella bildrutan."

msgid ""
"Display evaluates *expression* and compares to the result of the previous "
"evaluation of *expression*, so when the result is mutable, display may not "
"be able to pick up the changes."
msgstr ""
"Display utvärderar *uttryck* och jämför med resultatet av den föregående "
"utvärderingen av *uttryck*, så när resultatet är föränderligt är det inte "
"säkert att displayen kan fånga upp ändringarna."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"
msgstr ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"

msgid ""
"Display won't realize ``lst`` has been changed because the result of "
"evaluation is modified in place by ``lst.append(1)`` before being compared::"
msgstr ""
"Displayen kommer inte att inse att ``lst`` har ändrats eftersom resultatet "
"av utvärderingen modifieras på plats av ``lst.append(1)`` innan det jämförs::"

msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"

msgid "You can do some tricks with copy mechanism to make it work::"
msgstr ""
"Du kan göra några trick med kopieringsmekanismen för att få den att fungera::"

msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"

msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr ""
"Visa inte *uttryck* längre i den aktuella bildrutan.  Utan *uttryck* rensas "
"alla visningsuttryck för den aktuella ramen."

msgid ""
"Start an interactive interpreter (using the :mod:`code` module) in a new "
"global namespace initialised from the local and global namespaces for the "
"current scope. Use ``exit()`` or ``quit()`` to exit the interpreter and "
"return to the debugger."
msgstr ""
"Starta en interaktiv tolk (med modulen :mod:`code`) i en ny global namnrymd "
"som initieras från de lokala och globala namnrymderna för det aktuella "
"området. Använd ``exit()`` eller ``quit()`` för att avsluta tolken och "
"återgå till felsökaren."

msgid ""
"As ``interact`` creates a new dedicated namespace for code execution, "
"assignments to variables will not affect the original namespaces. However, "
"modifications to any referenced mutable objects will be reflected in the "
"original namespaces as usual."
msgstr ""
"Eftersom ``interact`` skapar ett nytt dedikerat namnområde för exekvering av "
"kod, kommer tilldelningar till variabler inte att påverka de ursprungliga "
"namnområdena. Modifieringar av alla refererade mutabla objekt kommer dock "
"att återspeglas i de ursprungliga namnrymderna som vanligt."

msgid ""
"``exit()`` and ``quit()`` can be used to exit the :pdbcmd:`interact` command."
msgstr ""
"``exit()`` och ``quit()`` kan användas för att avsluta kommandot :pdbcmd:"
"`interact`."

msgid ""
":pdbcmd:`interact` directs its output to the debugger's output channel "
"rather than :data:`sys.stderr`."
msgstr ""
":pdbcmd:`interact` styr utdata till debuggarens utdatakanal i stället för "
"till :data:`sys.stderr`."

msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, ... and ``%9``, while ``%*`` is replaced by all the "
"parameters. If *command* is omitted, the current alias for *name* is shown. "
"If no arguments are given, all aliases are listed."
msgstr ""
"Skapa ett alias som heter *namn* och som utför *kommando*.  *kommandot* får "
"*inte* vara omslutet av citationstecken.  Ersättningsbara parametrar kan "
"anges med ``%1``, ``%2``, ... och ``%9``, medan ``%*`` ersätts av alla "
"parametrar. Om *kommando* utelämnas visas det aktuella aliaset för *namn*. "
"Om inga argument anges listas alla alias."

msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"Alias kan vara nästlade och kan innehålla vad som helst som lagligen kan "
"skrivas vid pdb-prompten.  Observera att interna pdb-kommandon *kan* "
"åsidosättas av alias.  Ett sådant kommando är då dolt tills aliaset tas "
"bort.  Alias tillämpas rekursivt på det första ordet i kommandoraden; alla "
"andra ord i raden lämnas obehandlade."

msgid ""
"As an example, here are two useful aliases (especially when placed in the :"
"file:`.pdbrc` file)::"
msgstr ""
"Som exempel kan nämnas två användbara alias (särskilt när de placeras i "
"filen :file:`.pdbrc`)::"

msgid ""
"# Print instance variables (usage \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Print instance variables in self\n"
"alias ps pi self"
msgstr ""
"# Skriv ut instansvariabler (användning \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Skriv ut instansvariabler i self\n"
"alias ps pi själv"

msgid "Delete the specified alias *name*."
msgstr "Ta bort det angivna aliaset *namn*."

msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command, e.g.:"
msgstr ""
"Exekvera (enradigt) *uttalandet* i kontexten för den aktuella stackramen. "
"Utropstecknet kan utelämnas om inte det första ordet i satsen liknar ett "
"debugger-kommando, t.ex:"

msgid ""
"(Pdb) ! n=42\n"
"(Pdb)"
msgstr ""
"(Pdb) ! n=42\n"
"(Pdb)"

msgid ""
"To set a global variable, you can prefix the assignment command with a :"
"keyword:`global` statement on the same line, e.g.:"
msgstr ""
"För att ställa in en global variabel kan du prefixera assignment-kommandot "
"med en :keyword:`global`-sats på samma rad, t.ex:"

msgid ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"
msgstr ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"

msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. :pdbcmd:"
"`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"Startar om det felsökta Python-programmet.  Om *args* anges delas den upp "
"med :mod:`shlex` och resultatet används som ny :data:`sys.argv`. Historik, "
"brytpunkter, åtgärder och debuggaralternativ bevaras. :pdbcmd:`restart` är "
"ett alias för :pdbcmd:`run`."

msgid ""
":pdbcmd:`run` and :pdbcmd:`restart` commands are disabled when the debugger "
"is invoked in ``'inline'`` mode."
msgstr ""
"kommandona :pdbcmd:`run` och :pdbcmd:`restart` inaktiveras när debuggern "
"anropas i ``'inline'``-läge."

msgid ""
"Quit from the debugger.  The program being executed is aborted. An end-of-"
"file input is equivalent to :pdbcmd:`quit`."
msgstr ""
"Avsluta från felsökaren.  Det program som körs avbryts. En inmatning vid "
"slutet av filen motsvarar :pdbcmd:`quit`."

msgid ""
"A confirmation prompt will be shown if the debugger is invoked in "
"``'inline'`` mode. Either ``y``, ``Y``, ``<Enter>`` or ``EOF`` will confirm "
"the quit."
msgstr ""
"En bekräftelseprompt visas om felsökaren anropas i ``'inline'``-läge. "
"Antingen ``y``, ``Y``, ``<Enter>`` eller ``EOF`` kommer att bekräfta "
"avslutningen."

msgid ""
"A confirmation prompt will be shown if the debugger is invoked in "
"``'inline'`` mode. After the confirmation, the debugger will call :func:`sys."
"exit` immediately, instead of raising :exc:`bdb.BdbQuit` in the next trace "
"event."
msgstr ""
"En bekräftelseprompt visas om felsökaren anropas i ``'inline'``-läge. Efter "
"bekräftelsen anropar felsökaren :func:`sys.exit` omedelbart, i stället för :"
"exc:`bdb.BdbQuit` i nästa spårningshändelse."

msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr ""
"Ange en rekursiv felsökare som går igenom *kod* (vilket är ett godtyckligt "
"uttryck eller en sats som ska utföras i den aktuella miljön)."

msgid "Print the return value for the last return of the current function."
msgstr "Skriv ut returvärdet för den sista returen i den aktuella funktionen."

msgid "List or jump between chained exceptions."
msgstr "Lista eller hoppa mellan kedjade undantag."

msgid ""
"When using ``pdb.pm()``  or ``Pdb.post_mortem(...)`` with a chained "
"exception instead of a traceback, it allows the user to move between the "
"chained exceptions using ``exceptions`` command to list exceptions, and "
"``exceptions <number>`` to switch to that exception."
msgstr ""
"När du använder ``pdb.pm()`` eller ``Pdb.post_mortem(...)`` med ett kedjat "
"undantag istället för en spårning, tillåter det användaren att flytta mellan "
"de kedjade undantagen med kommandot ``exceptions`` för att lista undantag "
"och ``exceptions <number>`` för att byta till det undantaget."

msgid ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"
msgstr ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"

msgid "calling ``pdb.pm()`` will allow to move between exceptions::"
msgstr ""
"att anropa ``pdb.pm()`` kommer att göra det möjligt att flytta mellan "
"undantag::"

msgid ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"
msgstr ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"Whether a frame is considered to originate in a certain module is determined "
"by the ``__name__`` in the frame globals."
msgstr ""
"Om en frame anses ha sitt ursprung i en viss modul avgörs av ``__name__`` i "
"frame-globalerna."

msgid "debugging"
msgstr "felsökning"

msgid "Pdb (class in pdb)"
msgstr "Pdb (klass i pdb)"

msgid "module"
msgstr "modul"

msgid "bdb"
msgstr "bdb"

msgid "cmd"
msgstr "cmd"

msgid ".pdbrc"
msgstr ".pdbrc"

msgid "file"
msgstr "fil"

msgid "debugger"
msgstr "felsökare"

msgid "configuration"
msgstr "konfiguration"
