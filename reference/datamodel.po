# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Data model"
msgstr "Datamodell"

msgid "Objects, values and types"
msgstr "Objekt, värden och typer"

msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
":dfn:`Objekt` är Pythons abstraktion för data.  Alla data i ett Python-"
"program representeras av objekt eller av relationer mellan objekt. (På sätt "
"och vis, och i enlighet med Von Neumanns modell av en \"dator med lagrade "
"program\", representeras kod också av objekt)"

msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The :keyword:`is` operator compares the identity of two "
"objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"Varje objekt har en identitet, en typ och ett värde.  Ett objekts "
"*identitet* ändras aldrig när det väl har skapats; du kan tänka på det som "
"objektets adress i minnet.  Operatorn :keyword:`is` jämför identiteten hos "
"två objekt; funktionen :func:`id` returnerar ett heltal som representerar "
"dess identitet."

msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "För CPython är ``id(x)`` den minnesadress där ``x`` lagras."

msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"Ett objekts typ avgör vilka operationer som objektet stöder (t.ex. \"har det "
"en längd?\") och definierar också de möjliga värdena för objekt av den "
"typen.  Funktionen :func:`type` returnerar ett objekts typ (som i sin tur är "
"ett objekt).  Liksom dess identitet är ett objekts :dfn:`type` också "
"oföränderlig. [#]_"

msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"Vissa objekts *värde* kan förändras.  Objekt vars värde kan ändras sägs vara "
"*mutabla*; objekt vars värde är oföränderligt när de skapas kallas "
"*immutable*. (Värdet på ett oföränderligt containerobjekt som innehåller en "
"referens till ett föränderligt objekt kan ändras när det senare objektets "
"värde ändras; containern anses dock fortfarande vara oföränderlig, eftersom "
"samlingen av objekt som den innehåller inte kan ändras.  Så oföränderlighet "
"är inte riktigt samma sak som att ha ett oföränderligt värde, det är mer "
"subtilt) Ett objekts föränderlighet bestäms av dess typ; till exempel är "
"tal, strängar och tupler oföränderliga, medan ordböcker och listor är "
"föränderliga."

msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Objekt förstörs aldrig explicit, men när de blir oåtkomliga kan de bli "
"föremål för garbage-collection.  En implementering får skjuta upp "
"skräpinsamlingen eller helt utelämna den --- det är en fråga om "
"implementeringskvalitet hur skräpinsamlingen implementeras, så länge inga "
"objekt samlas in som fortfarande är nåbara."

msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"CPython använder för närvarande ett referensräkningsschema med (valfri) "
"fördröjd upptäckt av cykliskt länkat skräp, som samlar in de flesta objekt "
"så snart de blir onåbara, men det är inte garanterat att skräp som "
"innehåller cirkulära referenser samlas in.  Se dokumentationen för modulen :"
"mod:`gc` för information om hur du kontrollerar insamlingen av cykliskt "
"skräp. Andra implementationer agerar annorlunda och CPython kan ändras. "
"Förlita dig inte på omedelbar slutbehandling av objekt när de blir "
"oåtkomliga (så du bör alltid stänga filer explicit)."

msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a :keyword:`try`...\\ :keyword:`except` statement "
"may keep objects alive."
msgstr ""
"Observera att användningen av implementationens spårnings- eller "
"felsökningsfunktioner kan hålla objekt vid liv som normalt skulle vara "
"insamlingsbara. Observera också att om du fångar ett undantag med en :"
"keyword:`try`...\\ :keyword:`except`-sats kan det hålla objekt vid liv."

msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`!close` method. Programs are strongly recommended "
"to explicitly close such objects.  The :keyword:`try`...\\ :keyword:"
"`finally` statement and the :keyword:`with` statement provide convenient "
"ways to do this."
msgstr ""
"Vissa objekt innehåller referenser till \"externa\" resurser, t.ex. öppna "
"filer eller fönster.  Det är underförstått att dessa resurser frigörs när "
"objektet garbage-collected, men eftersom garbage-collection inte garanterat "
"kommer att ske, tillhandahåller sådana objekt också ett explicit sätt att "
"frigöra den externa resursen, vanligtvis en :meth:`!close`-metod. Program "
"rekommenderas starkt att explicit stänga sådana objekt.  Satsen :keyword:"
"`try`...\\ :keyword:`finally` och :keyword:`with` är praktiska sätt att göra "
"detta."

msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Vissa objekt innehåller referenser till andra objekt, dessa kallas för "
"*containers*. Exempel på containrar är tupler, listor och lexikon.  "
"Referenserna är en del av en containers värde.  I de flesta fall, när vi "
"talar om värdet på en container, menar vi värdena, inte identiteterna på de "
"ingående objekten; men när vi talar om föränderligheten hos en container, är "
"det bara identiteterna på de omedelbart ingående objekten som avses.  Så om "
"en oföränderlig behållare (som en tupel) innehåller en referens till ett "
"föränderligt objekt, ändras dess värde om det föränderliga objektet ändras."

msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed. For example, after ``a = 1; b = 1``, *a* and *b* may or may not "
"refer to the same object with the value one, depending on the "
"implementation. This is because :class:`int` is an immutable type, so the "
"reference to ``1`` can be reused. This behaviour depends on the "
"implementation used, so should not be relied upon, but is something to be "
"aware of when making use of object identity tests. However, after ``c = []; "
"d = []``, *c* and *d* are guaranteed to refer to two different, unique, "
"newly created empty lists. (Note that ``e = f = []`` assigns the *same* "
"object to both *e* and *f*.)"
msgstr ""
"Typer påverkar nästan alla aspekter av objektets beteende.  Till och med "
"vikten av objektets identitet påverkas i någon mening: för oföränderliga "
"typer kan operationer som beräknar nya värden faktiskt returnera en referens "
"till ett befintligt objekt med samma typ och värde, medan detta inte är "
"tillåtet för föränderliga objekt. Till exempel, efter ``a = 1; b = 1``, kan "
"*a* och *b* referera till samma objekt med värdet ett eller inte, beroende "
"på implementeringen. Detta beror på att :class:`int` är en oföränderlig typ, "
"så referensen till ``1`` kan återanvändas. Detta beteende beror på vilken "
"implementation som används och bör därför inte åberopas, men det är något "
"att vara medveten om när man använder sig av objektidentitetstester. Efter "
"``c = []; d = []`` är det dock garanterat att *c* och *d* refererar till två "
"olika, unika, nyskapade tomma listor. (Observera att ``e = f = []`` "
"tilldelar *samma* objekt till både *e* och *f*)"

msgid "The standard type hierarchy"
msgstr "Standardtypens hierarki"

msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"Nedan finns en lista över de typer som är inbyggda i Python.  "
"Tilläggsmoduler (skrivna i C, Java eller andra språk, beroende på "
"implementeringen) kan definiera ytterligare typer.  Framtida versioner av "
"Python kan lägga till typer i typhierarkin (t.ex. rationella tal, effektivt "
"lagrade matriser av heltal etc.), även om sådana tillägg ofta kommer att "
"tillhandahållas via standardbiblioteket istället."

msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Vissa av typbeskrivningarna nedan innehåller ett stycke som listar "
"\"specialattribut\"  Detta är attribut som ger tillgång till "
"implementationen och som inte är avsedda för allmänt bruk.  Deras definition "
"kan komma att ändras i framtiden."

msgid "None"
msgstr "Ingen"

msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Denna typ har ett enda värde.  Det finns ett enda objekt med detta värde. "
"Detta objekt nås genom det inbyggda namnet ``None``. Det används för att "
"beteckna avsaknaden av ett värde i många situationer, t.ex. returneras det "
"från funktioner som inte uttryckligen returnerar något. Dess sanningsvärde "
"är false."

msgid "NotImplemented"
msgstr "Ej genomförd"

msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name :data:`NotImplemented`. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""
"Denna typ har ett enda värde.  Det finns ett enda objekt med detta värde. "
"Detta objekt är åtkomligt genom det inbyggda namnet :data:`NotImplemented`. "
"Numeriska metoder och rika jämförelsemetoder bör returnera detta värde om de "
"inte implementerar operationen för de operander som tillhandahålls.  (Tolken "
"kommer då att prova den reflekterade operationen, eller någon annan "
"fallback, beroende på operatorn)  Det bör inte utvärderas i en boolesk "
"kontext."

msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "Se :ref:`implementing-the-arithmetic-operations` för mer information."

msgid "Evaluating :data:`NotImplemented` in a boolean context was deprecated."
msgstr ""
"Utvärdering av :data:`NotImplemented` i en boolesk kontext var föråldrad."

msgid ""
"Evaluating :data:`NotImplemented` in a boolean context now raises a :exc:"
"`TypeError`. It previously evaluated to :const:`True` and emitted a :exc:"
"`DeprecationWarning` since Python 3.9."
msgstr ""
"Utvärdering av :data:`NotImplemented` i en booleansk kontext ger nu upphov "
"till ett :exc:`TypeError`. Det utvärderades tidigare till :const:`True` och "
"gav upphov till en :exc:`DeprecationWarning` sedan Python 3.9."

msgid "Ellipsis"
msgstr "Ellipsis"

msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"Denna typ har ett enda värde.  Det finns ett enda objekt med detta värde. "
"Detta objekt nås genom det bokstavliga ``...`` eller det inbyggda namnet "
"``Ellipsis``.  Dess sanningsvärde är true."

msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Dessa skapas av numeriska literaler och returneras som resultat av "
"aritmetiska operatorer och inbyggda aritmetiska funktioner.  Numeriska "
"objekt är oföränderliga; när de väl har skapats ändras aldrig deras värde.  "
"Pythontal är naturligtvis starkt relaterade till matematiska tal, men är "
"föremål för begränsningarna för numerisk representation i datorer."

msgid ""
"The string representations of the numeric classes, computed by :meth:"
"`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
"Strängrepresentationerna av de numeriska klasserna, beräknade med :meth:"
"`~object.__repr__` och :meth:`~object.__str__`, har följande egenskaper:"

msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""
"De är giltiga numeriska literaler som, när de skickas till sin "
"klasskonstruktör, producerar ett objekt som har värdet av den ursprungliga "
"numeriska."

msgid "The representation is in base 10, when possible."
msgstr "Representationen är i bas 10, när så är möjligt."

msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr ""
"Ledande nollor, möjligen med undantag för en enda nolla före ett "
"decimaltecken, visas inte."

msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr ""
"Efterföljande nollor, eventuellt med undantag för en enda nolla efter ett "
"decimaltecken, visas inte."

msgid "A sign is shown only when the number is negative."
msgstr "Ett tecken visas endast när talet är negativt."

msgid ""
"Python distinguishes between integers, floating-point numbers, and complex "
"numbers:"
msgstr "Python skiljer mellan heltal, flyttal och komplexa tal:"

msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"Dessa representerar element från den matematiska uppsättningen av heltal "
"(positiva och negativa)."

msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"Reglerna för representation av heltal är avsedda att ge den mest "
"meningsfulla tolkningen av skift- och maskoperationer som involverar "
"negativa heltal."

msgid "There are two types of integers:"
msgstr "Det finns två typer av heltal:"

msgid "Integers (:class:`int`)"
msgstr "Heltal (:class:`int`)"

msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Dessa representerar tal i ett obegränsat intervall, endast beroende på "
"tillgängligt (virtuellt) minne.  Vid skift- och maskoperationer förutsätts "
"en binär representation och negativa tal representeras i en variant av 2:ans "
"komplement som ger illusionen av en oändlig sträng av teckenbitar som "
"sträcker sig åt vänster."

msgid "Booleans (:class:`bool`)"
msgstr "Booleaner (:class:`bool`)"

msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"Dessa representerar sanningsvärdena False och True.  De två objekt som "
"representerar värdena ``False`` och ``True`` är de enda booleska objekten. "
"Den booleska typen är en subtyp av heltalstypen, och booleska värden beter "
"sig som värdena 0 respektive 1 i nästan alla sammanhang, med undantaget att "
"när de konverteras till en sträng returneras strängarna ``\"False\"`` "
"respektive ``\"True\"``."

msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

msgid ""
"These represent machine-level double precision floating-point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating-point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating-point numbers."
msgstr ""
"Dessa representerar flyttal med dubbel precision på maskinnivå. Du är "
"utlämnad till den underliggande maskinarkitekturen (och C- eller Java-"
"implementeringen) för det accepterade intervallet och hanteringen av "
"överflöd. Python stöder inte flyttal med enkel precision; besparingarna i "
"processor- och minnesanvändning som vanligtvis är skälet till att använda "
"dessa dvärgas av omkostnaderna för att använda objekt i Python, så det finns "
"ingen anledning att komplicera språket med två typer av flyttal."

msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating-point numbers.  The same caveats apply as for floating-point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Dessa representerar komplexa tal som ett par flyttal med dubbel precision på "
"maskinnivå.  Samma försiktighetsåtgärder gäller som för flyttal. De reella "
"och imaginära delarna av ett komplext tal ``z`` kan hämtas genom de "
"skrivskyddade attributen ``z.real`` och ``z.imag``."

msgid "Sequences"
msgstr "Sekvenser"

msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``. Some "
"sequences, including built-in sequences, interpret negative subscripts by "
"adding the sequence length. For example, ``a[-2]`` equals ``a[n-2]``, the "
"second to last item of sequence a with length ``n``."
msgstr ""
"Dessa representerar ändliga ordnade mängder indexerade med icke-negativa "
"tal. Den inbyggda funktionen :func:`len` returnerar antalet objekt i en "
"sekvens. När längden på en sekvens är *n* innehåller indexuppsättningen "
"siffrorna 0, 1, ..., *n*-1.  Objekt *i* i sekvensen *a* väljs av ``a[i]``. "
"Vissa sekvenser, inklusive inbyggda sekvenser, tolkar negativa "
"subskriptioner genom att lägga till sekvenslängden. Till exempel är "
"``a[-2]`` lika med ``a[n-2]``, det näst sista objektet i sekvensen a med "
"längden ``n``."

msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type. The comment above about negative indexes also "
"applies to negative slice positions."
msgstr ""
"Sekvenser stöder också skivning: ``a[i:j]`` väljer alla objekt med index *k* "
"så att *i* ``<=`` *k* ``<`` *j*.  När en slice används som ett uttryck är "
"den en sekvens av samma typ. Kommentaren ovan om negativa index gäller även "
"för negativa slicepositioner."

msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Vissa sekvenser stöder också \"extended slicing\" med en tredje parameter "
"\"step\": ``a[i:j:k]`` väljer alla objekt i *a* med index *x* där ``x = i + "
"n*k``, *n* ``>=`` ``0`` och *i* ``<=`` *x* ``<`` *j*."

msgid "Sequences are distinguished according to their mutability:"
msgstr "Sekvenserna skiljer sig åt beroende på hur föränderliga de är:"

msgid "Immutable sequences"
msgstr "Oföränderliga sekvenser"

msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Ett objekt av en oföränderlig sekvenstyp kan inte ändras när det väl har "
"skapats.  (Om objektet innehåller referenser till andra objekt kan dessa "
"andra objekt vara föränderliga och kan ändras, men samlingen av objekt som "
"ett oföränderligt objekt refererar direkt till kan inte ändras)"

msgid "The following types are immutable sequences:"
msgstr "Följande typer är oföränderliga sekvenser:"

msgid "Strings"
msgstr "Strängar"

msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:expr:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""
"En sträng är en sekvens av värden som representerar Unicode-kodpunkter. Alla "
"kodpunkter i intervallet ``U+0000 - U+10FFFF`` kan representeras i en "
"sträng.  Python har inte någon :c:expr:`char`-typ, utan varje kodpunkt i "
"strängen representeras som ett strängobjekt med längden ``1``.  Den inbyggda "
"funktionen :func:`ord` konverterar en kodpunkt från dess strängform till ett "
"heltal i intervallet ``0 - 10FFFF``; :func:`chr` konverterar ett heltal i "
"intervallet ``0 - 10FFFF`` till motsvarande strängobjekt med längden ``1``. :"
"meth:`str.encode` kan användas för att konvertera en :class:`str` till :"
"class:`bytes` med den givna textkodningen, och :meth:`bytes.decode` kan "
"användas för att uppnå motsatsen."

msgid "Tuples"
msgstr "Tupler"

msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Objekten i en tupel är godtyckliga Python-objekt. Tuplar med två eller flera "
"objekt bildas av kommaseparerade listor med uttryck.  En tupel med ett "
"objekt (en \"singleton\") kan bildas genom att ett uttryck förses med ett "
"kommatecken (ett uttryck i sig skapar inte en tupel, eftersom parenteser "
"måste kunna användas för gruppering av uttryck).  En tom tupel kan bildas av "
"ett tomt par parenteser."

msgid "Bytes"
msgstr "Byte"

msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes` constructor can be used to create "
"bytes objects.  Also, bytes objects can be decoded to strings via the :meth:"
"`~bytes.decode` method."
msgstr ""
"Ett bytes-objekt är en oföränderlig array.  Objekten är 8-bitars byte, "
"representerade av heltal i intervallet 0 <= x < 256.  Byteslitteraler (som "
"``b'abc'``) och den inbyggda :func:`bytes`-konstruktorn kan användas för att "
"skapa bytes-objekt.  Bytesobjekt kan också avkodas till strängar via "
"metoden :meth:`~bytes.decode`."

msgid "Mutable sequences"
msgstr "Mutabla sekvenser"

msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"Mutabla sekvenser kan ändras efter att de har skapats.  Subscriptions- och "
"slicing-notationerna kan användas som mål för assignment- och :keyword:`del` "
"(delete)-satser."

msgid ""
"The :mod:`collections` and :mod:`array` module provide additional examples "
"of mutable sequence types."
msgstr ""
"Modulerna :mod:`collections` och :mod:`array` ger ytterligare exempel på "
"föränderliga sekvenstyper."

msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Det finns för närvarande två inneboende muterbara sekvenstyper:"

msgid "Lists"
msgstr "Listor"

msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Objekten i en lista är godtyckliga Python-objekt.  Listor bildas genom att "
"placera en kommaseparerad lista med uttryck inom hakparenteser. (Observera "
"att det inte behövs några specialfall för att bilda listor med längden 0 "
"eller 1)"

msgid "Byte Arrays"
msgstr "Byte-matriser"

msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"Ett bytearray-objekt är en föränderlig array. De skapas av den inbyggda :"
"func:`bytearray`-konstruktören.  Bortsett från att bytearray är föränderliga "
"(och därmed ohashbara), har de i övrigt samma gränssnitt och funktionalitet "
"som oföränderliga :class:`bytes`-objekt."

msgid "Set types"
msgstr "Uppsättningstyper"

msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"Dessa representerar oordnade, ändliga uppsättningar av unika, oföränderliga "
"objekt. Som sådana kan de inte indexeras med något subskript. De kan dock "
"itereras över och den inbyggda funktionen :func:`len` returnerar antalet "
"objekt i en uppsättning. Vanliga användningsområden för set är snabb "
"testning av medlemskap, borttagning av dubbletter från en sekvens och "
"beräkning av matematiska operationer som intersektion, union, differens och "
"symmetrisk differens."

msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"För set-element gäller samma regler för oföränderlighet som för nycklar i "
"ordböcker. Observera att numeriska typer följer de normala reglerna för "
"numerisk jämförelse: om två tal jämförs lika (t.ex. ``1`` och ``1.0``) kan "
"endast ett av dem ingå i en uppsättning."

msgid "There are currently two intrinsic set types:"
msgstr "Det finns för närvarande två typer av intrinsic set:"

msgid "Sets"
msgstr "Uppsättningar"

msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""
"Dessa representerar en föränderlig uppsättning. De skapas av den inbyggda :"
"func:`set`-konstruktören och kan modifieras i efterhand med flera metoder, t."
"ex. :meth:`~set.add`."

msgid "Frozen sets"
msgstr "Frysta set"

msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"Dessa representerar en oföränderlig uppsättning.  De skapas av den inbyggda :"
"func:`frozenset`-konstruktören.  Eftersom en frozenset är oföränderlig och :"
"term:`hashable` kan den användas igen som ett element i en annan uppsättning "
"eller som en nyckel i en ordbok."

msgid "Mappings"
msgstr "Mappningar"

msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Dessa representerar ändliga uppsättningar av objekt indexerade med "
"godtyckliga indexuppsättningar. Subscript-notationen ``a[k]`` väljer "
"objektet indexerat med ``k`` från mappningen ``a``; detta kan användas i "
"uttryck och som mål för tilldelningar eller :keyword:`del`-satser. Den "
"inbyggda funktionen :func:`len` returnerar antalet objekt i en mappning."

msgid "There is currently a single intrinsic mapping type:"
msgstr "Det finns för närvarande en enda intrinsic mappningstyp:"

msgid "Dictionaries"
msgstr "Ordböcker"

msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Dessa representerar ändliga uppsättningar av objekt indexerade med nästan "
"godtyckliga värden.  De enda typer av värden som inte kan accepteras som "
"nycklar är värden som innehåller listor eller lexikon eller andra "
"föränderliga typer som jämförs med värde i stället för med objektets "
"identitet, eftersom en effektiv implementering av lexikon kräver att en "
"nyckels hashvärde förblir konstant. Numeriska typer som används för nycklar "
"följer de normala reglerna för numerisk jämförelse: om två tal jämförs lika "
"(t.ex. ``1`` och ``1.0``) kan de användas omväxlande för att indexera samma "
"ordbokspost."

msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"Ordböcker bevarar inmatningsordningen, vilket innebär att nycklar kommer att "
"produceras i samma ordning som de lades till sekventiellt över ordboken. Om "
"du ersätter en befintlig nyckel ändras inte ordningen, men om du tar bort en "
"nyckel och sätter in den igen läggs den till i slutet i stället för att "
"behålla sin gamla plats."

msgid ""
"Dictionaries are mutable; they can be created by the ``{}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"Dictionaries är mutabla; de kan skapas med notationen ``{}`` (se avsnitt :"
"ref:`dict`)."

msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"Tilläggsmodulerna :mod:`dbm.ndbm` och :mod:`dbm.gnu` ger ytterligare exempel "
"på mappningstyper, liksom modulen :mod:`collections`."

msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"Ordböcker bevarade inte insättningsordning i versioner av Python före 3.6. I "
"CPython 3.6 bevarades insättningsordningen, men det ansågs vara en "
"implementeringsdetalj vid den tiden snarare än en språkgaranti."

msgid "Callable types"
msgstr "Kallbara typer"

msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""
"Dessa är de typer på vilka funktionsanropsoperationen (se avsnitt :ref:"
"`calls`) kan tillämpas:"

msgid "User-defined functions"
msgstr "Användardefinierade funktioner"

msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Ett användardefinierat funktionsobjekt skapas genom en funktionsdefinition "
"(se avsnitt :ref:`function`).  Den bör anropas med en argumentlista som "
"innehåller samma antal objekt som funktionens formella parameterlista."

msgid "Special read-only attributes"
msgstr "Särskilda skrivskyddade attribut"

msgid "Attribute"
msgstr "Attribut"

msgid "Meaning"
msgstr "Betydelse"

msgid ""
"A reference to the :class:`dictionary <dict>` that holds the function's :ref:"
"`global variables <naming>` -- the global namespace of the module in which "
"the function was defined."
msgstr ""
"En referens till :class:`dictionary <dict>` som innehåller funktionens :ref:"
"`global variables <naming>` -- den globala namnrymden i den modul där "
"funktionen definierades."

msgid ""
"``None`` or a :class:`tuple` of cells that contain bindings for the names "
"specified in the :attr:`~codeobject.co_freevars` attribute of the "
"function's :attr:`code object <function.__code__>`."
msgstr ""
"``None`` eller en :class:`tuple` av celler som innehåller bindningar för de "
"namn som anges i attributet :attr:`~codeobject.co_freevars` i funktionens :"
"attr:`code object <function.__code__>`."

msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"Ett cellobjekt har attributet ``cell_contents``. Detta kan användas för att "
"hämta cellens värde och för att ställa in värdet."

msgid "Special writable attributes"
msgstr "Särskilda skrivbara attribut"

msgid "Most of these attributes check the type of the assigned value:"
msgstr ""
"De flesta av dessa attribut kontrollerar typen av det tilldelade värdet:"

msgid "The function's documentation string, or ``None`` if unavailable."
msgstr ""
"Funktionens dokumentationssträng, eller ``None`` om den inte finns "
"tillgänglig."

msgid ""
"The function's name. See also: :attr:`__name__ attributes <definition."
"__name__>`."
msgstr ""
"Funktionens namn. Se även: :attr:`__name__ attribut <definition.__name__>`."

msgid ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""
"Funktionens :term:`kvalificerade namn`. Se även: :attr:`__kvalificerat "
"namn__ attribut <definition.__kvalificeratnamn__>`."

msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"Namnet på den modul som funktionen definierades i, eller ``None`` om den "
"inte är tillgänglig."

msgid ""
"A :class:`tuple` containing default :term:`parameter` values for those "
"parameters that have defaults, or ``None`` if no parameters have a default "
"value."
msgstr ""
"En :class:`tuple` som innehåller standardvärden för :term:`parameter` för de "
"parametrar som har standardvärden, eller ``None`` om inga parametrar har ett "
"standardvärde."

msgid ""
"The :ref:`code object <code-objects>` representing the compiled function "
"body."
msgstr ""
"Den :ref:`kodobjekt <code-objects>` som representerar den kompilerade "
"funktionskroppen."

msgid ""
"The namespace supporting arbitrary function attributes. See also: :attr:"
"`__dict__ attributes <object.__dict__>`."
msgstr ""
"Namnrymden som stöder godtyckliga funktionsattribut. Se även: :attr:"
"`__dict__ attribut <object.__dict__>`."

msgid ""
"A :class:`dictionary <dict>` containing annotations of :term:`parameters "
"<parameter>`. The keys of the dictionary are the parameter names, and "
"``'return'`` for the return annotation, if provided. See also: :attr:`object."
"__annotations__`."
msgstr ""
"En :class:`dictionary <dict>` som innehåller annoteringar av :term:"
"`parameters <parameter>`. Nycklarna i dictionariet är parameternamnen och "
"``'return'`` för returannoteringen, om en sådan har angetts. Se även: :attr:"
"`object.__annotations__`."

msgid ""
"Annotations are now :ref:`lazily evaluated <lazy-evaluation>`. See :pep:"
"`649`."
msgstr ""
"Annotationer är nu :ref:``slently evaluated <lazy-evaluation>`. Se :pep:"
"`649`."

msgid ""
"The :term:`annotate function` for this function, or ``None`` if the function "
"has no annotations. See :attr:`object.__annotate__`."
msgstr ""
":term:`annotate function` för denna funktion, eller ``None`` om funktionen "
"inte har några annotationer. Se :attr:`object.__annotate__`."

msgid ""
"A :class:`dictionary <dict>` containing defaults for keyword-only :term:"
"`parameters <parameter>`."
msgstr ""
"En :class:`dictionary <dict>` som innehåller standardvärden för "
"nyckelordsspecifika :term:`parameters <parameter>`."

msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a :"
"ref:`generic function <generic-functions>`."
msgstr ""
"En :class:`tuple` som innehåller :ref:`typ-parametrarna <type-params>` för "
"en :ref:`generisk funktion <generic-functions>`."

msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes."
msgstr ""
"Funktionsobjekt stöder också hämtning och inställning av godtyckliga "
"attribut, som t.ex. kan användas för att koppla metadata till funktioner.  "
"Vanlig attributpunktnotation används för att hämta och ställa in sådana "
"attribut."

msgid ""
"CPython's current implementation only supports function attributes on user-"
"defined functions. Function attributes on :ref:`built-in functions <builtin-"
"functions>` may be supported in the future."
msgstr ""
"CPythons nuvarande implementering stöder endast funktionsattribut på "
"användardefinierade funktioner. Funktionsattribut på :ref:`inbyggda "
"funktioner <builtin-functions>` kan komma att stödjas i framtiden."

msgid ""
"Additional information about a function's definition can be retrieved from "
"its :ref:`code object <code-objects>` (accessible via the :attr:`~function."
"__code__` attribute)."
msgstr ""
"Ytterligare information om en funktions definition kan hämtas från dess :ref:"
"`code object <code-objects>` (tillgänglig via attributet :attr:`~function."
"__code__`)."

msgid "Instance methods"
msgstr "Instansmetoder"

msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"Ett instansmetodobjekt kombinerar en klass, en klassinstans och ett "
"anropsbart objekt (normalt en användardefinierad funktion)."

msgid "Special read-only attributes:"
msgstr "Särskilda skrivskyddade attribut:"

msgid ""
"Refers to the class instance object to which the method is :ref:`bound "
"<method-binding>`"
msgstr ""
"Hänvisar till klassens instansobjekt som metoden är :ref:`bunden till "
"<method-binding>`"

msgid "Refers to the original :ref:`function object <user-defined-funcs>`"
msgstr ""
"Hänvisar till det ursprungliga :ref:`funktionsobjektet <user-defined-funcs>`"

msgid ""
"The method's documentation (same as :attr:`method.__func__.__doc__ <function."
"__doc__>`). A :class:`string <str>` if the original function had a "
"docstring, else ``None``."
msgstr ""
"Metodens dokumentation (samma som :attr:`method.__func__.__doc__ <function."
"__doc__>`). En :class:`sträng <str>` om den ursprungliga funktionen hade en "
"dokumentsträng, annars ``None``."

msgid ""
"The name of the method (same as :attr:`method.__func__.__name__ <function."
"__name__>`)"
msgstr ""
"Namnet på metoden (samma som :attr:`method.__func__.__name__ <function."
"__name__>`)"

msgid ""
"The name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""
"Namnet på den modul som metoden definierades i, eller ``None`` om den inte "
"är tillgänglig."

msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying :ref:`function object <user-defined-funcs>`."
msgstr ""
"Metoderna stöder också åtkomst till (men inte inställning av) godtyckliga "
"funktionsattribut på det underliggande :ref:`funktionsobjektet <user-defined-"
"funcs>`."

msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined :ref:`function object <user-defined-funcs>` or a :class:"
"`classmethod` object."
msgstr ""
"Användardefinierade metodobjekt kan skapas när man hämtar ett attribut för "
"en klass (kanske via en instans av den klassen), om attributet är ett "
"användardefinierat :ref:`funktionsobjekt <user-defined-funcs>` eller ett :"
"class:`klassmetod`-objekt."

msgid ""
"When an instance method object is created by retrieving a user-defined :ref:"
"`function object <user-defined-funcs>` from a class via one of its "
"instances, its :attr:`~method.__self__` attribute is the instance, and the "
"method object is said to be *bound*.  The new method's :attr:`~method."
"__func__` attribute is the original function object."
msgstr ""
"När ett instansmetodobjekt skapas genom att hämta ett användardefinierat :"
"ref:`funktionsobjekt <user-defined-funcs>` från en klass via en av dess "
"instanser, är dess :attr:`~method.__self__`-attribut instansen, och "
"metodobjektet sägs vara *bundet*.  Den nya metodens attribut :attr:`~method."
"__func__` är det ursprungliga funktionsobjektet."

msgid ""
"When an instance method object is created by retrieving a :class:"
"`classmethod` object from a class or instance, its :attr:`~method.__self__` "
"attribute is the class itself, and its :attr:`~method.__func__` attribute is "
"the function object underlying the class method."
msgstr ""
"När ett instansmetodobjekt skapas genom att ett :class:`classmethod`-objekt "
"hämtas från en klass eller instans, är dess attribut :attr:`~method."
"__self__` klassen själv och dess attribut :attr:`~method.__func__` är det "
"funktionsobjekt som ligger till grund för klassmetoden."

msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`~method.__func__`) is called, inserting the class instance (:attr:`~method."
"__self__`) in front of the argument list.  For instance, when :class:`!C` is "
"a class which contains a definition for a function :meth:`!f`, and ``x`` is "
"an instance of :class:`!C`, calling ``x.f(1)`` is equivalent to calling ``C."
"f(x, 1)``."
msgstr ""
"När ett instansmetodobjekt anropas, anropas den underliggande funktionen (:"
"attr:`~method.__func__`), varvid klassinstansen (:attr:`~method.__self__`) "
"infogas framför argumentlistan.  Till exempel, när :class:`!C` är en klass "
"som innehåller en definition för en funktion :meth:`!f`, och ``x`` är en "
"instans av :class:`!C`, är anrop av ``x.f(1)`` likvärdigt med anrop av ``C."
"f(x, 1)``."

msgid ""
"When an instance method object is derived from a :class:`classmethod` "
"object, the \"class instance\" stored in :attr:`~method.__self__` will "
"actually be the class itself, so that calling either ``x.f(1)`` or ``C."
"f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying "
"function."
msgstr ""
"När ett instansmetodobjekt härleds från ett :class:`classmethod`-objekt "
"kommer den \"klassinstans\" som lagras i :attr:`~method.__self__` faktiskt "
"att vara själva klassen, så att anrop av antingen ``x.f(1)`` eller ``C."
"f(1)`` motsvarar anrop av ``f(C,1)`` där ``f`` är den underliggande "
"funktionen."

msgid ""
"It is important to note that user-defined functions which are attributes of "
"a class instance are not converted to bound methods; this *only* happens "
"when the function is an attribute of the class."
msgstr ""
"Det är viktigt att notera att användardefinierade funktioner som är attribut "
"till en klassinstans inte konverteras till bundna metoder; detta sker "
"*endast* när funktionen är ett attribut till klassen."

msgid "Generator functions"
msgstr "Generatorfunktioner"

msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an :term:`iterator` object which can be used to "
"execute the body of the function:  calling the iterator's :meth:`iterator."
"__next__` method will cause the function to execute until it provides a "
"value using the :keyword:`!yield` statement.  When the function executes a :"
"keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of "
"values to be returned."
msgstr ""
"En funktion eller metod som använder :keyword:`yield`-satsen (se avsnitt :"
"ref:`yield`) kallas en :dfn:`generatorfunktion`.  När en sådan funktion "
"anropas returnerar den alltid ett :term:`iterator`-objekt som kan användas "
"för att exekvera funktionens kropp: om iteratorns :meth:`iterator.__next__`-"
"metod anropas kommer funktionen att exekveras tills den ger ett värde med "
"hjälp av :keyword:`!yield`-satsen.  När funktionen exekverar en :keyword:"
"`return`-sats eller faller av i slutet, kommer ett :exc:`StopIteration`-"
"undantag att uppstå och iteratorn kommer att ha nått slutet av uppsättningen "
"värden som ska returneras."

msgid "Coroutine functions"
msgstr "Coroutine-funktioner"

msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns a :term:"
"`coroutine` object.  It may contain :keyword:`await` expressions, as well "
"as :keyword:`async with` and :keyword:`async for` statements. See also the :"
"ref:`coroutine-objects` section."
msgstr ""
"En funktion eller metod som definieras med hjälp av :keyword:`async def` "
"kallas en :dfn:`coroutine function`.  En sådan funktion returnerar ett :term:"
"`coroutine`-objekt när den anropas.  Det kan innehålla :keyword:`await`-"
"uttryck, samt :keyword:`async with` och :keyword:`async for`-satser. Se även "
"avsnittet :ref:`coroutine-objects`."

msgid "Asynchronous generator functions"
msgstr "Asynkrongeneratorfunktioner"

msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
"En funktion eller metod som definieras med :keyword:`async def` och som "
"använder :keyword:`yield` kallas en :dfn:`asynchronous generator function`.  "
"En sådan funktion returnerar, när den anropas, ett :term:`asynkron iterator`-"
"objekt som kan användas i en :keyword:`async for`-sats för att exekvera "
"funktionens kropp."

msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ <object."
"__anext__>` method will return an :term:`awaitable` which when awaited will "
"execute until it provides a value using the :keyword:`yield` expression.  "
"When the function executes an empty :keyword:`return` statement or falls off "
"the end, a :exc:`StopAsyncIteration` exception is raised and the "
"asynchronous iterator will have reached the end of the set of values to be "
"yielded."
msgstr ""
"Anrop av den asynkrona iteratorns metod :meth:`aiterator.__anext__ <object."
"__anext__>` returnerar en :term:`awaitable` som när den är väntad kommer att "
"exekveras tills den ger ett värde med hjälp av uttrycket :keyword:`yield`.  "
"När funktionen exekverar en tom :keyword:`return`-sats eller faller av i "
"slutet, kommer ett :exc:`StopAsyncIteration`-undantag att uppstå och den "
"asynkrona iteratorn kommer att ha nått slutet av den uppsättning värden som "
"ska ges."

msgid "Built-in functions"
msgstr "Inbyggda funktioner"

msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes:"
msgstr ""
"Ett inbyggt funktionsobjekt är ett omslag runt en C-funktion.  Exempel på "
"inbyggda funktioner är :func:`len` och :func:`math.sin` (:mod:`math` är en "
"inbyggd standardmodul). Antalet och typen av argument bestäms av C-"
"funktionen. Särskilda skrivskyddade attribut:"

msgid ""
":attr:`!__doc__` is the function's documentation string, or ``None`` if "
"unavailable. See :attr:`function.__doc__`."
msgstr ""
":attr:`!__doc__` är funktionens dokumentationssträng, eller ``None`` om den "
"inte är tillgänglig. Se :attr:`function.__doc__`."

msgid ""
":attr:`!__name__` is the function's name. See :attr:`function.__name__`."
msgstr ":attr:`!__name__` är funktionens namn. Se :attr:`function.__name__`."

msgid ":attr:`!__self__` is set to ``None`` (but see the next item)."
msgstr ":attr:`!__self__` är satt till ``None`` (men se nästa punkt)."

msgid ""
":attr:`!__module__` is the name of the module the function was defined in or "
"``None`` if unavailable. See :attr:`function.__module__`."
msgstr ""
":attr:`!__module__` är namnet på den modul som funktionen definierades i "
"eller ``None`` om den inte är tillgänglig. Se :attr:`function.__module__`."

msgid "Built-in methods"
msgstr "Inbyggda metoder"

msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`!__self__` is set to the object denoted by *alist*. (The attribute has "
"the same semantics as it does with :attr:`other instance methods <method."
"__self__>`.)"
msgstr ""
"Detta är egentligen en annan förklädnad av en inbyggd funktion, som den här "
"gången innehåller ett objekt som skickas till C-funktionen som ett implicit "
"extra argument.  Ett exempel på en inbyggd metod är ``alist.append()``, "
"förutsatt att *alist* är ett listobjekt. I detta fall sätts det speciella "
"skrivskyddade attributet :attr:`!__self__` till det objekt som betecknas av "
"*alist*. (Attributet har samma semantik som det har med :attr:`andra "
"instansmetoder <metod.__self__>`.)"

msgid "Classes"
msgstr "Klasser"

msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed to :"
"meth:`!__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""
"Klasser är anropsbara.  Dessa objekt fungerar normalt som fabriker för nya "
"instanser av sig själva, men variationer är möjliga för klasstyper som "
"åsidosätter :meth:`~object.__new__`.  Argumenten för anropet skickas till :"
"meth:`!__new__` och, i det typiska fallet, till :meth:`~object.__init__` för "
"att initiera den nya instansen."

msgid "Class Instances"
msgstr "Klassinstanser"

msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`~object.__call__` method in their class."
msgstr ""
"Instanser av godtyckliga klasser kan göras anropbara genom att definiera en :"
"meth:`~object.__call__`-metod i sin klass."

msgid "Modules"
msgstr "Moduler"

msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement, or by calling functions such as :func:`importlib."
"import_module` and built-in :func:`__import__`.  A module object has a "
"namespace implemented by a :class:`dictionary <dict>` object (this is the "
"dictionary referenced by the :attr:`~function.__globals__` attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m."
"__dict__[\"x\"]``. A module object does not contain the code object used to "
"initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr ""
"Moduler är en grundläggande organisatorisk enhet i Python-kod, och skapas "
"av :ref:`import system <importsystem>` som anropas antingen av :keyword:"
"`import`-satsen, eller genom att anropa funktioner som :func:`importlib."
"import_module` och inbyggda :func:`__import__`.  Ett modulobjekt har ett "
"namnområde som implementeras av ett :class:`dictionary <dict>`-objekt (detta "
"är den ordbok som refereras av attributet :attr:`~function.__globals__` för "
"funktioner som definieras i modulen).  Attributreferenser översätts till "
"uppslagningar i denna ordbok, t.ex. är ``m.x`` likvärdigt med ``m."
"__dict__[\"x\"]``. Ett modulobjekt innehåller inte det kodobjekt som används "
"för att initiera modulen (eftersom det inte behövs när initieringen är klar)."

msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"Attributtilldelning uppdaterar modulens namnrymdsordbok, t.ex. ``m.x = 1`` "
"är likvärdigt med ``m.__dict__[\"x\"] = 1``."

msgid "Import-related attributes on module objects"
msgstr "Importrelaterade attribut på modulobjekt"

msgid ""
"Module objects have the following attributes that relate to the :ref:`import "
"system <importsystem>`. When a module is created using the machinery "
"associated with the import system, these attributes are filled in based on "
"the module's :term:`spec <module spec>`, before the :term:`loader` executes "
"and loads the module."
msgstr ""
"Modulobjekt har följande attribut som relaterar till :ref:`importsystemet "
"<importsystem>`. När en modul skapas med hjälp av de maskiner som är "
"associerade med importsystemet fylls dessa attribut i baserat på modulens :"
"term:`spec <module spec>`, innan :term:`loader` körs och laddar modulen."

msgid ""
"To create a module dynamically rather than using the import system, it's "
"recommended to use :func:`importlib.util.module_from_spec`, which will set "
"the various import-controlled attributes to appropriate values. It's also "
"possible to use the :class:`types.ModuleType` constructor to create modules "
"directly, but this technique is more error-prone, as most attributes must be "
"manually set on the module object after it has been created when using this "
"approach."
msgstr ""
"Om du vill skapa en modul dynamiskt i stället för att använda importsystemet "
"rekommenderas att du använder :func:`importlib.util.module_from_spec`, som "
"sätter de olika importkontrollerade attributen till lämpliga värden. Det är "
"också möjligt att använda :class:`types.ModuleType`-konstruktören för att "
"skapa moduler direkt, men den här tekniken är mer felbenägen, eftersom de "
"flesta attribut måste ställas in manuellt på modulobjektet efter att det har "
"skapats med den här metoden."

msgid ""
"With the exception of :attr:`~module.__name__`, it is **strongly** "
"recommended that you rely on :attr:`~module.__spec__` and its attributes "
"instead of any of the other individual attributes listed in this subsection. "
"Note that updating an attribute on :attr:`!__spec__` will not update the "
"corresponding attribute on the module itself:"
msgstr ""
"Med undantag för :attr:`~module.__name__` rekommenderas **starkt** att du "
"förlitar dig på :attr:`~module.__spec__` och dess attribut istället för "
"något av de andra enskilda attributen som listas i detta underavsnitt. "
"Observera att uppdatering av ett attribut på :attr:`!__spec__` inte kommer "
"att uppdatera motsvarande attribut på själva modulen:"

msgid ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"
msgstr ""
">>> import typning\n"
">>> typing.__name__, typing.__spec__.namn\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'stavning'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('skrivning', 'stavning')\n"
">>> typing.__name__ = \"keyboard_smashing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'stavning')"

msgid ""
"The name used to uniquely identify the module in the import system. For a "
"directly executed module, this will be set to ``\"__main__\"``."
msgstr ""
"Det namn som används för att unikt identifiera modulen i importsystemet. För "
"en direkt exekverad modul kommer detta att sättas till ``\"__main__\"``."

msgid ""
"This attribute must be set to the fully qualified name of the module. It is "
"expected to match the value of :attr:`module.__spec__.name <importlib."
"machinery.ModuleSpec.name>`."
msgstr ""
"Detta attribut måste vara inställt på modulens fullständiga kvalificerade "
"namn. Det förväntas matcha värdet av :attr:`module.__spec__.name <importlib."
"machinery.ModuleSpec.name>`."

msgid "A record of the module's import-system-related state."
msgstr "En registrering av modulens importsystemrelaterade tillstånd."

msgid ""
"Set to the :class:`module spec <importlib.machinery.ModuleSpec>` that was "
"used when importing the module. See :ref:`module-specs` for more details."
msgstr ""
"Sätts till :class:`modulspecifikation <importlib.machinery.ModuleSpec>` som "
"användes vid import av modulen. Se :ref:`modul-specs` för mer information."

msgid "The :term:`package` a module belongs to."
msgstr "Den :term:`package` som en modul tillhör."

msgid ""
"If the module is top-level (that is, not a part of any specific package) "
"then the attribute should be set to ``''`` (the empty string). Otherwise, it "
"should be set to the name of the module's package (which can be equal to :"
"attr:`module.__name__` if the module itself is a package). See :pep:`366` "
"for further details."
msgstr ""
"Om modulen är på toppnivå (dvs. inte ingår i något specifikt paket) ska "
"attributet anges till ``''`` (den tomma strängen). Annars bör det sättas "
"till namnet på modulens paket (som kan vara lika med :attr:`module.__name__` "
"om modulen själv är ett paket). Se :pep:`366` för ytterligare detaljer."

msgid ""
"This attribute is used instead of :attr:`~module.__name__` to calculate "
"explicit relative imports for main modules. It defaults to ``None`` for "
"modules created dynamically using the :class:`types.ModuleType` constructor; "
"use :func:`importlib.util.module_from_spec` instead to ensure the attribute "
"is set to a :class:`str`."
msgstr ""
"Detta attribut används i stället för :attr:`~module.__name__` för att "
"beräkna explicit relativ import för huvudmoduler. Standardvärdet är ``None`` "
"för moduler som skapas dynamiskt med hjälp av :class:`types.ModuleType`-"
"konstruktören; använd :func:`importlib.util.module_from_spec` istället för "
"att säkerställa att attributet är inställt på en :class:`str`."

msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` instead of :attr:`!module."
"__package__`. :attr:`__package__` is now only used as a fallback if :attr:`!"
"__spec__.parent` is not set, and this fallback path is deprecated."
msgstr ""
"Det rekommenderas **starkt** att du använder :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` i stället för :attr:`!module."
"__package__`. :attr:`__package__` används nu endast som en reservväg om :"
"attr:`!__spec__.parent` inte har angetts, och denna reservväg är föråldrad."

msgid ""
"This attribute now defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor. Previously the attribute "
"was optional."
msgstr ""
"Detta attribut är nu standard för ``None`` för moduler som skapas dynamiskt "
"med hjälp av konstruktören :class:`types.ModuleType`. Tidigare var "
"attributet valfritt."

msgid ""
"The value of :attr:`!__package__` is expected to be the same as :attr:"
"`__spec__.parent <importlib.machinery.ModuleSpec.parent>`. :attr:"
"`__package__` is now only used as a fallback during import resolution if :"
"attr:`!__spec__.parent` is not defined."
msgstr ""
"Värdet på :attr:`!__package__` förväntas vara detsamma som :attr:`__spec__."
"parent <importlib.machinery.ModuleSpec.parent>`. :attr:`__package__` används "
"nu endast som en reservlösning vid importupplösning om :attr:`!__spec__."
"parent` inte är definierad."

msgid ""
":exc:`ImportWarning` is raised if an import resolution falls back to :attr:`!"
"__package__` instead of :attr:`__spec__.parent <importlib.machinery."
"ModuleSpec.parent>`."
msgstr ""
":exc:`ImportWarning` tas upp om en importresolution faller tillbaka till :"
"attr:`!__package__` istället för :attr:`__spec__.parent <importlib.machinery."
"ModuleSpec.parent>`."

msgid ""
"Raise :exc:`DeprecationWarning` instead of :exc:`ImportWarning` when falling "
"back to :attr:`!__package__` during import resolution."
msgstr ""
"Skicka :exc:`DeprecationWarning` istället för :exc:`ImportWarning` när man "
"faller tillbaka till :attr:`!__package__` under importlösning."

msgid ""
":attr:`!__package__` will cease to be set or taken into consideration by the "
"import system or standard library."
msgstr ""
":attr:`!__package__` kommer inte längre att ställas in eller tas i beaktande "
"av importsystemet eller standardbiblioteket."

msgid ""
"The :term:`loader` object that the import machinery used to load the module."
msgstr ""
"Det :term:`loader`-objekt som importmaskinen använde för att ladda modulen."

msgid ""
"This attribute is mostly useful for introspection, but can be used for "
"additional loader-specific functionality, for example getting data "
"associated with a loader."
msgstr ""
"Detta attribut är mest användbart för introspektion, men kan användas för "
"ytterligare laddningsspecifika funktioner, t.ex. för att hämta data som är "
"associerade med en laddare."

msgid ""
":attr:`!__loader__` defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor; use :func:`importlib.util."
"module_from_spec` instead to ensure the attribute is set to a :term:`loader` "
"object."
msgstr ""
":attr:`!__loader__` är som standard ``None`` för moduler som skapas "
"dynamiskt med hjälp av konstruktören :class:`types.ModuleType`; använd "
"istället :func:`importlib.util.module_from_spec` för att se till att "
"attributet sätts till ett :term:`loader`-objekt."

msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` instead of :attr:`!module."
"__loader__`."
msgstr ""
"Det rekommenderas **starkt** att du använder :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` i stället för :attr:`!module."
"__loader__`."

msgid ""
"Setting :attr:`!__loader__` on a module while failing to set :attr:`!"
"__spec__.loader` is deprecated. In Python 3.16, :attr:`!__loader__` will "
"cease to be set or taken into consideration by the import system or the "
"standard library."
msgstr ""
"Att ange :attr:`!__loader__` för en modul utan att ange :attr:`!__spec__."
"loader` är föråldrat. I Python 3.16 kommer :attr:`!__loader__` inte längre "
"att anges eller tas i beaktande av importsystemet eller standardbiblioteket."

msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations "
"where the package's submodules will be found. Non-package modules should not "
"have a :attr:`!__path__` attribute. See :ref:`package-path-rules` for more "
"details."
msgstr ""
"En (eventuellt tom) :term:`sequence` av strängar som räknar upp de platser "
"där paketets undermoduler kommer att hittas. Icke-paketmoduler bör inte ha "
"ett :attr:`!__path__`-attribut. Se :ref:`package-path-rules` för mer "
"information."

msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__."
"submodule_search_locations <importlib.machinery.ModuleSpec."
"submodule_search_locations>` instead of :attr:`!module.__path__`."
msgstr ""
"Det rekommenderas **starkt** att du använder :attr:`module.__spec__."
"submodule_search_locations <importlib.machinery.ModuleSpec."
"submodule_search_locations>` i stället för :attr:`!module.__path__`."

msgid ""
":attr:`!__file__` and :attr:`!__cached__` are both optional attributes that "
"may or may not be set. Both attributes should be a :class:`str` when they "
"are available."
msgstr ""
":attr:`!__file__` och :attr:`!__cached__` är båda valfria attribut som kan "
"eller inte kan anges. Båda attributen bör vara en :class:`str` när de är "
"tillgängliga."

msgid ""
":attr:`!__file__` indicates the pathname of the file from which the module "
"was loaded (if loaded from a file), or the pathname of the shared library "
"file for extension modules loaded dynamically from a shared library. It "
"might be missing for certain types of modules, such as C modules that are "
"statically linked into the interpreter, and the :ref:`import system "
"<importsystem>` may opt to leave it unset if it has no semantic meaning (for "
"example, a module loaded from a database)."
msgstr ""
":attr:`!__file__` anger sökvägen till den fil från vilken modulen laddades "
"(om den laddades från en fil), eller sökvägen till den delade "
"biblioteksfilen för tilläggsmoduler som laddas dynamiskt från ett delat "
"bibliotek. Det kan saknas för vissa typer av moduler, t.ex. C-moduler som "
"länkas statiskt till tolken, och :ref:``import system <importsystem>`` kan "
"välja att lämna det oinställt om det inte har någon semantisk betydelse (t."
"ex. en modul som laddas från en databas)."

msgid ""
"If :attr:`!__file__` is set then the :attr:`!__cached__` attribute might "
"also be set,  which is the path to any compiled version of the code (for "
"example, a byte-compiled file). The file does not need to exist to set this "
"attribute; the path can simply point to where the compiled file *would* "
"exist (see :pep:`3147`)."
msgstr ""
"Om :attr:`!__file__` anges kan även attributet :attr:`!__cached__` anges, "
"vilket är sökvägen till en kompilerad version av koden (t.ex. en "
"bytekompilerad fil). Filen behöver inte existera för att detta attribut ska "
"kunna anges; sökvägen kan helt enkelt peka på var den kompilerade filen "
"*skulle* finnas (se :pep:`3147`)."

msgid ""
"Note that :attr:`!__cached__` may be set even if :attr:`!__file__` is not "
"set.  However, that scenario is quite atypical.  Ultimately, the :term:"
"`loader` is what makes use of the module spec provided by the :term:`finder` "
"(from which :attr:`!__file__` and :attr:`!__cached__` are derived).  So if a "
"loader can load from a cached module but otherwise does not load from a "
"file, that atypical scenario may be appropriate."
msgstr ""
"Observera att :attr:`!__cached__` kan anges även om :attr:`!__file__` inte "
"anges.  Det scenariot är dock ganska atypiskt.  I slutändan är det :term:"
"`loader` som använder modulspecifikationen som tillhandahålls av :term:"
"`finder` (från vilken :attr:`!__file__` och :attr:`!__cached__` härleds).  "
"Så om en laddare kan ladda från en cachad modul men i övrigt inte laddar "
"från en fil, kan det atypiska scenariot vara lämpligt."

msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` instead of :attr:`!module."
"__cached__`."
msgstr ""
"Det rekommenderas **starkt** att du använder :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` i stället för :attr:`!module."
"__cached__`."

msgid ""
"Setting :attr:`!__cached__` on a module while failing to set :attr:`!"
"__spec__.cached` is deprecated. In Python 3.15, :attr:`!__cached__` will "
"cease to be set or taken into consideration by the import system or standard "
"library."
msgstr ""
"Att ställa in :attr:`!__cached__` på en modul samtidigt som man misslyckas "
"med att ställa in :attr:`!__spec__.cached` är föråldrat. I Python 3.15 "
"kommer :attr:`!__cached__` inte längre att anges eller tas i beaktande av "
"importsystemet eller standardbiblioteket."

msgid "Other writable attributes on module objects"
msgstr "Andra skrivbara attribut på modulobjekt"

msgid ""
"As well as the import-related attributes listed above, module objects also "
"have the following writable attributes:"
msgstr ""
"Förutom de importrelaterade attribut som anges ovan har modulobjekten även "
"följande skrivbara attribut:"

msgid ""
"The module's documentation string, or ``None`` if unavailable. See also: :"
"attr:`__doc__ attributes <definition.__doc__>`."
msgstr ""
"Modulens dokumentationssträng, eller ``None`` om den inte är tillgänglig. Se "
"även: :attr:`__doc__-attribut <definition.__doc__>`."

msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working with :"
"attr:`!__annotations__`, see :mod:`annotationlib`."
msgstr ""
"En ordbok som innehåller :term:`variable annotations <variable annotation>` "
"som samlats in under modulens exekvering.  För bästa praxis för att arbeta "
"med :attr:`!__annotations__`, se :mod:`annotationlib`."

msgid ""
"The :term:`annotate function` for this module, or ``None`` if the module has "
"no annotations. See also: :attr:`~object.__annotate__` attributes."
msgstr ""
":term:`annotate-funktionen` för denna modul, eller ``None`` om modulen inte "
"har några annotationer. Se även: :attr:`~object.__annotate__` attribut."

msgid "Module dictionaries"
msgstr "Modul ordböcker"

msgid "Module objects also have the following special read-only attribute:"
msgstr "Modulobjekt har också följande speciella skrivskyddade attribut:"

msgid ""
"The module's namespace as a dictionary object. Uniquely among the attributes "
"listed here, :attr:`!__dict__` cannot be accessed as a global variable from "
"within a module; it can only be accessed as an attribute on module objects."
msgstr ""
"Modulens namnrymd som ett ordboksobjekt. En unik egenskap bland de attribut "
"som listas här är att :attr:`!__dict__` inte kan nås som en global variabel "
"från en modul, utan endast som ett attribut på modulobjekt."

msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"På grund av hur CPython rensar modulordböcker kommer modulordboken att "
"rensas när modulen faller ur räckvidden även om ordboken fortfarande har "
"levande referenser.  För att undvika detta, kopiera ordlistan eller behåll "
"modulen medan du använder dess ordlista direkt."

msgid "Custom classes"
msgstr "Anpassade klasser"

msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found at :ref:`python_2.3_mro`."
msgstr ""
"Anpassade klasstyper skapas vanligen genom klassdefinitioner (se avsnitt :"
"ref:`class`).  En klass har ett namnområde som implementeras av ett "
"ordboksobjekt. Referenser till klassattribut översätts till uppslagningar i "
"denna ordbok, t.ex. översätts ``C.x`` till ``C.__dict__[\"x\"]`` (även om "
"det finns ett antal krokar som tillåter andra sätt att lokalisera attribut). "
"Om attributnamnet inte hittas där fortsätter sökningen i basklasserna. Vid "
"denna sökning i basklasserna används C3-metodens upplösningsordning som "
"fungerar korrekt även när det finns \"diamantformade\" arvsstrukturer där "
"det finns flera arvsvägar som leder tillbaka till en gemensam förfader. "
"Ytterligare detaljer om C3 MRO som används av Python finns på :ref:"
"`python_2.3_mro`."

msgid ""
"When a class attribute reference (for class :class:`!C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`~method.__self__` attribute is :class:`!C`. When it would yield a :"
"class:`staticmethod` object, it is transformed into the object wrapped by "
"the static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""
"När en referens till ett klassattribut (t.ex. för klassen :class:`!C`) "
"skulle ge ett klassmetodobjekt, omvandlas det till ett instansmetodobjekt "
"vars attribut :attr:`~method.__self__` är :class:`!C`. När det skulle ge "
"ett :class:`staticmethod`-objekt, omvandlas det till det objekt som omsluts "
"av det statiska metodobjektet. Se avsnitt :ref:`descriptors` för ett annat "
"sätt på vilket attribut som hämtas från en klass kan skilja sig från de som "
"faktiskt finns i dess :attr:`~object.__dict__`."

msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"Tilldelningar av klassattribut uppdaterar klassens ordbok, aldrig en "
"basklass ordbok."

msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Ett klassobjekt kan anropas (se ovan) för att ge en klassinstans (se nedan)."

msgid "Special attributes"
msgstr "Särskilda egenskaper"

msgid ""
"The class's name. See also: :attr:`__name__ attributes <definition."
"__name__>`."
msgstr ""
"Klassens namn. Se även: :attr:`__name__ attribut <definition.__name__>`."

msgid ""
"The class's :term:`qualified name`. See also: :attr:`__qualname__ attributes "
"<definition.__qualname__>`."
msgstr ""
"Klassens :term:`kvalificerade namn`. Se även: :attr:`__kvalificerat namn__ "
"attribut <definition.__kvalificeratnamn__>`."

msgid "The name of the module in which the class was defined."
msgstr "Namnet på den modul i vilken klassen definierades."

msgid ""
"A :class:`mapping proxy <types.MappingProxyType>` providing a read-only view "
"of the class's namespace. See also: :attr:`__dict__ attributes <object."
"__dict__>`."
msgstr ""
"En :class:`mappningsproxy <types.MappingProxyType>` som ger en skrivskyddad "
"vy av klassens namnrymd. Se även: :attr:`__dict__-attribut <object."
"__dict__>`."

msgid ""
"A :class:`tuple` containing the class's bases. In most cases, for a class "
"defined as ``class X(A, B, C)``, ``X.__bases__`` will be exactly equal to "
"``(A, B, C)``."
msgstr ""
"En :class:`tupel` som innehåller klassens baser. I de flesta fall, för en "
"klass definierad som ``class X(A, B, C)``, kommer ``X.__bases__`` att vara "
"exakt lika med ``(A, B, C)``."

msgid ""
"The class's documentation string, or ``None`` if undefined. Not inherited by "
"subclasses."
msgstr ""
"Klassens dokumentationssträng, eller ``None`` om den är odefinierad. Ärvs "
"inte av underklasser."

msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution. See also: :attr:`__annotations__ "
"attributes <object.__annotations__>`."
msgstr ""
"En ordbok som innehåller :term:`variable annotations <variable annotation>` "
"som samlats in under klassens exekvering. Se även: :attr:`__annotations__ "
"attribut <object.__annotations__>`."

msgid ""
"For best practices on working with :attr:`~object.__annotations__`, please "
"see :mod:`annotationlib`. Use :func:`annotationlib.get_annotations` instead "
"of accessing this attribute directly."
msgstr ""
"För bästa praxis för att arbeta med :attr:`~object.__annotations__`, se :mod:"
"`annotationlib`. Använd :func:`annotationlib.get_annotations` istället för "
"att komma åt detta attribut direkt."

msgid ""
"Accessing the :attr:`!__annotations__` attribute directly on a class object "
"may return annotations for the wrong class, specifically in certain cases "
"where the class, its base class, or a metaclass is defined under ``from "
"__future__ import annotations``. See :pep:`749 <749#pep749-metaclasses>` for "
"details."
msgstr ""
"Om du använder attributet :attr:`!__annotations__` direkt på ett klassobjekt "
"kan du få tillbaka annoteringar för fel klass, särskilt i vissa fall där "
"klassen, dess basklass eller en metaklass definieras under ``from __future__ "
"import annotations``. Se :pep:`749 <749#pep749-metaklasser>` för detaljer."

msgid ""
"This attribute does not exist on certain builtin classes. On user-defined "
"classes without ``__annotations__``, it is an empty dictionary."
msgstr ""
"Detta attribut finns inte i vissa inbyggda klasser. På användardefinierade "
"klasser utan ``__annotations__`` är det en tom ordbok."

msgid ""
"The :term:`annotate function` for this class, or ``None`` if the class has "
"no annotations. See also: :attr:`__annotate__ attributes <object."
"__annotate__>`."
msgstr ""
":term:`annoteringsfunktion` för denna klass, eller ``None`` om klassen inte "
"har några annoteringar. Se även: :attr:`__annotera__ attribut <object."
"__annotate__>`."

msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a :"
"ref:`generic class <generic-classes>`."
msgstr ""
"En :class:`tuple` som innehåller :ref:`type parameters <type-params>` för "
"en :ref:`generic class <generic-classes>`."

msgid ""
"A :class:`tuple` containing names of attributes of this class which are "
"assigned through ``self.X`` from any function in its body."
msgstr ""
"En :class:`tuple` som innehåller namn på attribut för denna klass som "
"tilldelas via ``self.X`` från någon funktion i dess kropp."

msgid ""
"The line number of the first line of the class definition, including "
"decorators. Setting the :attr:`__module__` attribute removes the :attr:`!"
"__firstlineno__` item from the type's dictionary."
msgstr ""
"Radnumret på den första raden i klassdefinitionen, inklusive dekoratorer. "
"Genom att ange attributet :attr:`__module__` tas objektet :attr:`!"
"__firstlineno__` bort från typens dictionary."

msgid ""
"The :class:`tuple` of classes that are considered when looking for base "
"classes during method resolution."
msgstr ""
"Den :class:`tupel` av klasser som beaktas när man letar efter basklasser "
"under metodresolution."

msgid "Special methods"
msgstr "Särskilda metoder"

msgid ""
"In addition to the special attributes described above, all Python classes "
"also have the following two methods available:"
msgstr ""
"Förutom de specialattribut som beskrivs ovan har alla Python-klasser också "
"följande två metoder tillgängliga:"

msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~type.__mro__`."
msgstr ""
"Den här metoden kan åsidosättas av en metaklass för att anpassa "
"metodupplösningsordningen för dess instanser.  Den anropas vid klassens "
"instansiering och dess resultat lagras i :attr:`~type.__mro__`."

msgid ""
"Each class keeps a list of weak references to its immediate subclasses. This "
"method returns a list of all those references still alive. The list is in "
"definition order. Example:"
msgstr ""
"Varje klass har en lista över svaga referenser till sina närmaste "
"underklasser. Denna metod returnerar en lista över alla dessa referenser som "
"fortfarande är vid liv. Listan är i definitionsordning. Ett exempel:"

msgid ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"
msgstr ""
">>> klass A: pass\n"
">>> klass B(A): pass\n"
">>> A.__subclasses__()\n"
"[<klass 'B'>]"

msgid "Class instances"
msgstr "Klassinstanser"

msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`~method.__self__` attribute is the instance.  "
"Static method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`~object."
"__getattr__` method, that is called to satisfy the lookup."
msgstr ""
"En klassinstans skapas genom att anropa ett klassobjekt (se ovan).  En "
"klassinstans har ett namnområde som är implementerat som en ordbok som är "
"det första stället där attributreferenser söks.  Om ett attribut inte hittas "
"där och instansens klass har ett attribut med samma namn, fortsätter "
"sökningen med klassattributen.  Om ett klassattribut hittas som är ett "
"användardefinierat funktionsobjekt omvandlas det till ett instansmetodobjekt "
"vars attribut :attr:`~method.__self__` är instansen.  Statiska metod- och "
"klassmetodobjekt transformeras också; se ovan under \"Klasser\".  Se "
"avsnitt :ref:`descriptors` för ett annat sätt på vilket attribut för en "
"klass som hämtas via dess instanser kan skilja sig från de objekt som "
"faktiskt lagras i klassens :attr:`~object.__dict__`.  Om inget klassattribut "
"hittas, och objektets klass har en :meth:`~object.__getattr__`-metod, "
"anropas den för att uppfylla sökningen."

msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` or :"
"meth:`~object.__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"Tilldelning och borttagning av attribut uppdaterar instansens dictionary, "
"aldrig en klass' dictionary.  Om klassen har en metod :meth:`~object."
"__setattr__` eller :meth:`~object.__delattr__` anropas denna istället för "
"att uppdatera instansens dictionary direkt."

msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"Klassinstanser kan låtsas vara tal, sekvenser eller avbildningar om de har "
"metoder med vissa speciella namn.  Se avsnitt :ref:`specialnamn`."

msgid "The class to which a class instance belongs."
msgstr "Den klass som en klassinstans tillhör."

msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes. Not all instances have a :attr:`!__dict__` attribute; see the "
"section on :ref:`slots` for more details."
msgstr ""
"En ordbok eller annat mappningsobjekt som används för att lagra ett objekts "
"(skrivbara) attribut. Inte alla instanser har ett :attr:`!__dict__`-"
"attribut; se avsnittet om :ref:`slots` för mer information."

msgid "I/O objects (also known as file objects)"
msgstr "I/O-objekt (även kända som filobjekt)"

msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""
"Ett :term:`filobjekt` representerar en öppen fil.  Olika genvägar finns "
"tillgängliga för att skapa filobjekt: den inbyggda funktionen :func:`open`, "
"och även :func:`os.popen`, :func:`os.fdopen` och metoden :meth:`~socket."
"socket.makefile` för socketobjekt (och kanske andra funktioner eller metoder "
"som tillhandahålls av tilläggsmoduler)."

msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Objekten ``sys.stdin``, ``sys.stdout`` och ``sys.stderr`` initialiseras till "
"filobjekt som motsvarar tolkens standardflöden för inmatning, utmatning och "
"fel; de är alla öppna i textläge och följer därför det gränssnitt som "
"definieras av den abstrakta klassen :class:`io.TextIOBase`."

msgid "Internal types"
msgstr "Interna typer"

msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Några typer som används internt av tolken är exponerade för användaren. "
"Deras definitioner kan komma att ändras i framtida versioner av tolken, men "
"de nämns här för fullständighetens skull."

msgid "Code objects"
msgstr "Kodobjekt"

msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"Kodobjekt representerar *byte-kompilerad* exekverbar Python-kod, eller :term:"
"`bytecode`. Skillnaden mellan ett kodobjekt och ett funktionsobjekt är att "
"funktionsobjektet innehåller en explicit referens till funktionens globaler "
"(den modul där den definierades), medan ett kodobjekt inte innehåller någon "
"kontext; även standardargumentvärdena lagras i funktionsobjektet, inte i "
"kodobjektet (eftersom de representerar värden som beräknas vid körning).  "
"Till skillnad från funktionsobjekt är kodobjekt oföränderliga och innehåller "
"inga referenser (vare sig direkt eller indirekt) till föränderliga objekt."

msgid "The function name"
msgstr "Funktionens namn"

msgid "The fully qualified function name"
msgstr "Det fullständigt kvalificerade funktionsnamnet"

msgid ""
"The total number of positional :term:`parameters <parameter>` (including "
"positional-only parameters and parameters with default values) that the "
"function has"
msgstr ""
"Det totala antalet positionella :term:`parametrar <parameter>` (inklusive "
"enbart positionella parametrar och parametrar med standardvärden) som "
"funktionen har"

msgid ""
"The number of positional-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"Antalet positionsbestämda :term:`parametrar <parameter>` (inklusive argument "
"med standardvärden) som funktionen har"

msgid ""
"The number of keyword-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"Antalet nyckelordsspecifika :term:`parametrar <parameter>` (inklusive "
"argument med standardvärden) som funktionen har"

msgid ""
"The number of :ref:`local variables <naming>` used by the function "
"(including parameters)"
msgstr ""
"Antalet :ref:`lokala variabler <naming>` som används av funktionen "
"(inklusive parametrar)"

msgid ""
"A :class:`tuple` containing the names of the local variables in the function "
"(starting with the parameter names)"
msgstr ""
"En :class:`tuple` som innehåller namnen på de lokala variablerna i "
"funktionen (börjar med parameternamnen)"

msgid ""
"A :class:`tuple` containing the names of :ref:`local variables <naming>` "
"that are referenced from at least one :term:`nested scope` inside the "
"function"
msgstr ""
"En :class:`tupel` som innehåller namnen på :ref:`lokala variabler <naming>` "
"som refereras från minst en :term:`nästlat scope` inuti funktionen"

msgid ""
"A :class:`tuple` containing the names of :term:`free (closure) variables "
"<closure variable>` that a :term:`nested scope` references in an outer "
"scope. See also :attr:`function.__closure__`."
msgstr ""
"En :class:`tupel` som innehåller namnen på :term:`free (closure) variables "
"<closure variable>` som en :term:`nested scope` refererar till i ett yttre "
"scope. Se även :attr:`function.__closure__`."

msgid "Note: references to global and builtin names are *not* included."
msgstr "Obs: referenser till globala och inbyggda namn är *inte* inkluderade."

msgid ""
"A string representing the sequence of :term:`bytecode` instructions in the "
"function"
msgstr ""
"En sträng som representerar sekvensen av :term:`bytecode`-instruktioner i "
"funktionen"

msgid ""
"A :class:`tuple` containing the literals used by the :term:`bytecode` in the "
"function"
msgstr ""
"En :class:`tuple` som innehåller de literaler som används av :term:"
"`bytecode` i funktionen"

msgid ""
"A :class:`tuple` containing the names used by the :term:`bytecode` in the "
"function"
msgstr ""
"En :class:`tuple` som innehåller de namn som används av :term:`bytecode` i "
"funktionen"

msgid "The name of the file from which the code was compiled"
msgstr "Namnet på den fil som koden kompilerades från"

msgid "The line number of the first line of the function"
msgstr "Radnumret för den första raden i funktionen"

msgid ""
"A string encoding the mapping from :term:`bytecode` offsets to line numbers. "
"For details, see the source code of the interpreter."
msgstr ""
"En sträng som kodar mappningen från :term:`bytecode`-offsets till radnummer. "
"För detaljer, se källkoden för tolken."

msgid ""
"This attribute of code objects is deprecated, and may be removed in Python "
"3.15."
msgstr ""
"Detta attribut för kodobjekt är föråldrat och kan komma att tas bort i "
"Python 3.15."

msgid "The required stack size of the code object"
msgstr "Den nödvändiga stackstorleken för kodobjektet"

msgid ""
"An :class:`integer <int>` encoding a number of flags for the interpreter."
msgstr "En :class:`integer <int>` som kodar ett antal flaggor för tolken."

msgid ""
"The following flag bits are defined for :attr:`~codeobject.co_flags`: bit "
"``0x04`` is set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator. See :ref:"
"`inspect-module-co-flags` for details on the semantics of each flags that "
"might be present."
msgstr ""
"Följande flaggbitar är definierade för :attr:`~codeobject.co_flags`: bit "
"``0x04`` sätts om funktionen använder syntaxen ``*arguments`` för att "
"acceptera ett godtyckligt antal positionella argument; bit ``0x08`` sätts om "
"funktionen använder syntaxen ``**keywords`` för att acceptera godtyckliga "
"nyckelordsargument; bit ``0x20`` sätts om funktionen är en generator. Se :"
"ref:`inspect-module-co-flags` för detaljer om semantiken för varje flagga "
"som kan förekomma."

msgid ""
"Future feature declarations (for example, ``from __future__ import "
"division``) also use bits in :attr:`~codeobject.co_flags` to indicate "
"whether a code object was compiled with a particular feature enabled. See :"
"attr:`~__future__._Feature.compiler_flag`."
msgstr ""
"Deklarationer av framtida funktioner (t.ex. ``from __future__ import "
"division``) använder också bitar i :attr:`~codeobject.co_flags` för att ange "
"om ett kodobjekt kompilerades med en viss funktion aktiverad. Se :attr:"
"`~__future__._Feature.compiler_flag`."

msgid ""
"Other bits in :attr:`~codeobject.co_flags` are reserved for internal use."
msgstr ""
"Övriga bitar i :attr:`~codeobject.co_flags` är reserverade för internt bruk."

msgid ""
"If a code object represents a function and has a docstring, the :data:"
"`~inspect.CO_HAS_DOCSTRING` bit is set in :attr:`~codeobject.co_flags` and "
"the first item in :attr:`~codeobject.co_consts` is the docstring of the "
"function."
msgstr ""
"Om ett kodobjekt representerar en funktion och har en docstring, sätts bit :"
"data:`~inspect.CO_HAS_DOCSTRING` i :attr:`~codeobject.co_flags` och det "
"första objektet i :attr:`~codeobject.co_consts` är funktionens docstring."

msgid "Methods on code objects"
msgstr "Metoder på kodobjekt"

msgid ""
"Returns an iterable over the source code positions of each :term:`bytecode` "
"instruction in the code object."
msgstr ""
"Returnerar en iterabel över källkodspositionerna för varje :term:`bytecode`-"
"instruktion i kodobjektet."

msgid ""
"The iterator returns :class:`tuple`\\s containing the ``(start_line, "
"end_line, start_column, end_column)``. The *i-th* tuple corresponds to the "
"position of the source code that compiled to the *i-th* code unit. Column "
"information is 0-indexed utf-8 byte offsets on the given source line."
msgstr ""
"Iteratorn returnerar :class:`tuple`` som innehåller ``(start_line, end_line, "
"start_column, end_column)``. Tupeln *i-th* motsvarar positionen för den "
"källkod som kompilerades till kodenheten *i-th*. Kolumninformationen är 0-"
"indexerade utf-8-byteoffset på den angivna källkodsraden."

msgid ""
"This positional information can be missing. A non-exhaustive lists of cases "
"where this may happen:"
msgstr ""
"Denna positionsinformation kan saknas. En icke uttömmande lista över fall "
"där detta kan inträffa:"

msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr "Kör tolken med :option:`-X` ``no_debug_ranges``."

msgid ""
"Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr ""
"Läser in en pyc-fil som kompilerats med :option:`-X` ``no_debug_ranges``."

msgid "Position tuples corresponding to artificial instructions."
msgstr "Positionstuplar som motsvarar artificiella instruktioner."

msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr ""
"Rad- och kolumnnummer som inte kan representeras på grund av "
"implementationsspecifika begränsningar."

msgid ""
"When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr ""
"När detta inträffar kan vissa eller alla element i tupeln vara :const:`None`."

msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the :envvar:`PYTHONNODEBUGRANGES` "
"environment variable can be used."
msgstr ""
"Den här funktionen kräver att kolumnpositioner lagras i kodobjekt, vilket "
"kan leda till en liten ökning av diskanvändningen för kompilerade Python-"
"filer eller tolkens minnesanvändning. För att undvika att lagra den extra "
"informationen och/eller avaktivera utskrift av extra spårningsinformation "
"kan kommandoradsflaggan :option:`-X` ``no_debug_ranges`` eller "
"miljövariabeln :envvar:`PYTHONNODEBUGRANGES` användas."

msgid ""
"Returns an iterator that yields information about successive ranges of :term:"
"`bytecode`\\s. Each item yielded is a ``(start, end, lineno)`` :class:"
"`tuple`:"
msgstr ""
"Returnerar en iterator som ger information om successiva intervall av :term:"
"`bytecode`-element. Varje objekt som returneras är en ``(start, end, "
"lineno)`` :class:`tuple`:"

msgid ""
"``start`` (an :class:`int`) represents the offset (inclusive) of the start "
"of the :term:`bytecode` range"
msgstr ""
"``start`` (en :class:`int`) representerar förskjutningen (inklusive) av "
"början på :term:`bytecode`-intervallet"

msgid ""
"``end`` (an :class:`int`) represents the offset (exclusive) of the end of "
"the :term:`bytecode` range"
msgstr ""
"``end`` (en :class:`int`) representerar förskjutningen (exklusiv) av slutet "
"på :term:`bytecode`-intervallet"

msgid ""
"``lineno`` is an :class:`int` representing the line number of the :term:"
"`bytecode` range, or ``None`` if the bytecodes in the given range have no "
"line number"
msgstr ""
"``lineno`` är en :class:`int` som representerar radnumret i :term:`bytecode`-"
"intervallet, eller ``None`` om bytekoderna i det angivna intervallet inte "
"har något radnummer"

msgid "The items yielded will have the following properties:"
msgstr "De produkter som erhålls kommer att ha följande egenskaper:"

msgid "The first range yielded will have a ``start`` of 0."
msgstr "Det första intervallet som genereras har ``start`` 0."

msgid ""
"The ``(start, end)`` ranges will be non-decreasing and consecutive. That is, "
"for any pair of :class:`tuple`\\s, the ``start`` of the second will be equal "
"to the ``end`` of the first."
msgstr ""
"Områdena ``(start, slut)`` kommer att vara icke avtagande och konsekutiva. "
"Det vill säga, för varje par av :class:`tuple` kommer ``start`` för det "
"andra att vara lika med ``slut`` för det första."

msgid "No range will be backwards: ``end >= start`` for all triples."
msgstr ""
"Inget intervall kommer att vara bakåtriktat: ``slut >= start`` för alla "
"tripplar."

msgid ""
"The last :class:`tuple` yielded will have ``end`` equal to the size of the :"
"term:`bytecode`."
msgstr ""
"Den sista :class:`tuple` som erhålls kommer att ha ``end`` lika med "
"storleken på :term:`bytecode`."

msgid ""
"Zero-width ranges, where ``start == end``, are allowed. Zero-width ranges "
"are used for lines that are present in the source code, but have been "
"eliminated by the :term:`bytecode` compiler."
msgstr ""
"Nollbreddsområden, där ``start == slut``, är tillåtna. Områden med nollbredd "
"används för rader som finns i källkoden, men som har eliminerats av "
"kompilatorn :term:`bytecode`."

msgid ":pep:`626` - Precise line numbers for debugging and other tools."
msgstr ":pep:`626` - Exakta radnummer för felsökning och andra verktyg."

msgid "The PEP that introduced the :meth:`!co_lines` method."
msgstr "Den PEP som introducerade metoden :meth:`!co_lines`."

msgid ""
"Return a copy of the code object with new values for the specified fields."
msgstr ""
"Returnerar en kopia av kodobjektet med nya värden för de angivna fälten."

msgid ""
"Code objects are also supported by the generic function :func:`copy.replace`."
msgstr ""
"Kodobjekt stöds också av den generiska funktionen :func:`copy.replace`."

msgid "Frame objects"
msgstr "Ramobjekt"

msgid ""
"Frame objects represent execution frames.  They may occur in :ref:`traceback "
"objects <traceback-objects>`, and are also passed to registered trace "
"functions."
msgstr ""
"Frame-objekt representerar exekveringsramar.  De kan förekomma i :ref:"
"`traceback-objekt <traceback-objects>`, och skickas också till registrerade "
"spårningsfunktioner."

msgid ""
"Points to the previous stack frame (towards the caller), or ``None`` if this "
"is the bottom stack frame"
msgstr ""
"Pekar på föregående stapelram (mot den som anropar), eller ``None`` om detta "
"är den nedersta stapelramen"

msgid ""
"The :ref:`code object <code-objects>` being executed in this frame. "
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""
"Det :ref:`code-objekt <code-objects>` som exekveras i denna frame. Åtkomst "
"till detta attribut ger upphov till en :ref:`auditing event <auditing>` "
"``object.__getattr__`` med argumenten ``obj`` och ``\"f_code\"``."

msgid ""
"The mapping used by the frame to look up :ref:`local variables <naming>`. If "
"the frame refers to an :term:`optimized scope`, this may return a write-"
"through proxy object."
msgstr ""
"Den mappning som används av ramen för att leta upp :ref:`lokala variabler "
"<naming>`. Om ramen refererar till en :term:`optimized scope`, kan detta "
"returnera ett write-through proxy-objekt."

msgid "Return a proxy for optimized scopes."
msgstr "Returnera en proxy för optimerade scopes."

msgid ""
"The dictionary used by the frame to look up :ref:`global variables <naming>`"
msgstr ""
"Den ordbok som används av ramen för att slå upp :ref:`globala variabler "
"<naming>`"

msgid ""
"The dictionary used by the frame to look up :ref:`built-in (intrinsic) names "
"<naming>`"
msgstr ""
"Den ordbok som används av ramen för att slå upp :ref:`inbyggda (intrinsic) "
"namn <naming>`"

msgid ""
"The \"precise instruction\" of the frame object (this is an index into the :"
"term:`bytecode` string of the :ref:`code object <code-objects>`)"
msgstr ""
"Den \"exakta instruktionen\" för ramobjektet (detta är ett index i :term:"
"`bytecode`-strängen i :ref:``code object <code-objects>`)"

msgid ""
"If not ``None``, this is a function called for various events during code "
"execution (this is used by debuggers). Normally an event is triggered for "
"each new source line (see :attr:`~frame.f_trace_lines`)."
msgstr ""
"Om inte ``None``, är detta en funktion som anropas för olika händelser under "
"kodkörning (detta används av debuggar). Normalt utlöses en händelse för "
"varje ny källkodsrad (se :attr:`~frame.f_trace_lines`)."

msgid ""
"Set this attribute to :const:`False` to disable triggering a tracing event "
"for each source line."
msgstr ""
"Ställ in detta attribut på :const:`False` för att inaktivera utlösningen av "
"en spårningshändelse för varje källrad."

msgid ""
"Set this attribute to :const:`True` to allow per-opcode events to be "
"requested. Note that this may lead to undefined interpreter behaviour if "
"exceptions raised by the trace function escape to the function being traced."
msgstr ""
"Sätt detta attribut till :const:`True` för att tillåta att händelser per "
"operationskod begärs. Observera att detta kan leda till ett odefinierat "
"tolkbeteende om undantag som skapas av spårningsfunktionen flyr till den "
"funktion som spåras."

msgid ""
"The current line number of the frame -- writing to this from within a trace "
"function jumps to the given line (only for the bottom-most frame).  A "
"debugger can implement a Jump command (aka Set Next Statement) by writing to "
"this attribute."
msgstr ""
"Det aktuella radnumret för ramen - om du skriver till detta från en "
"spårningsfunktion hoppar du till den angivna raden (endast för den nedersta "
"ramen).  En debugger kan implementera ett Jump-kommando (även kallat Set "
"Next Statement) genom att skriva till detta attribut."

msgid "Frame object methods"
msgstr "Metoder för ramobjekt"

msgid "Frame objects support one method:"
msgstr "Ramobjekt stöder en metod:"

msgid ""
"This method clears all references to :ref:`local variables <naming>` held by "
"the frame.  Also, if the frame belonged to a :term:`generator`, the "
"generator is finalized.  This helps break reference cycles involving frame "
"objects (for example when catching an :ref:`exception <bltin-exceptions>` "
"and storing its :ref:`traceback <traceback-objects>` for later use)."
msgstr ""
"Denna metod rensar alla referenser till :ref:`lokala variabler <naming>` som "
"finns i ramen.  Dessutom, om ramen tillhörde en :term:`generator`, slutförs "
"generatorn.  Detta hjälper till att bryta referenscykler som involverar "
"ramobjekt (till exempel när man fångar ett :ref:`exception <bltin-"
"exceptions>` och lagrar dess :ref:`traceback <traceback-objects>` för senare "
"användning)."

msgid ""
":exc:`RuntimeError` is raised if the frame is currently executing or "
"suspended."
msgstr ""
":exc:`RuntimeError` uppstår om ramen för närvarande körs eller avbryts."

msgid ""
"Attempting to clear a suspended frame raises :exc:`RuntimeError` (as has "
"always been the case for executing frames)."
msgstr ""
"Försök att rensa en suspenderad ram ger upphov till :exc:`RuntimeError` "
"(vilket alltid har varit fallet för exekverande ramar)."

msgid "Traceback objects"
msgstr "Spårningsobjekt"

msgid ""
"Traceback objects represent the stack trace of an :ref:`exception <tut-"
"errors>`. A traceback object is implicitly created when an exception occurs, "
"and may also be explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"Traceback-objekt representerar stackspårningen av ett :ref:`exception <tut-"
"errors>`. Ett traceback-objekt skapas implicit när ett undantag inträffar, "
"och kan också skapas explicit genom att anropa :class:`types.TracebackType`."

msgid "Traceback objects can now be explicitly instantiated from Python code."
msgstr "Traceback-objekt kan nu uttryckligen instansieras från Python-kod."

msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section :ref:"
"`try`.) It is accessible as the third item of the tuple returned by :func:"
"`sys.exc_info`, and as the :attr:`~BaseException.__traceback__` attribute of "
"the caught exception."
msgstr ""
"För implicit skapade spårningar, när sökningen efter en undantagshanterare "
"rullar upp exekveringsstacken, infogas ett spårningsobjekt framför den "
"aktuella spårningen på varje upprullningsnivå.  När en undantagshanterare "
"anges görs stackspårningen tillgänglig för programmet. (Se avsnitt :ref:"
"`try`.) Det är tillgängligt som det tredje objektet i den tupel som "
"returneras av :func:`sys.exc_info`, och som attributet :attr:`~BaseException."
"__traceback__` för det fångade undantaget."

msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as :data:`sys."
"last_traceback`."
msgstr ""
"När programmet inte innehåller någon lämplig hanterare skrivs stackspåret "
"(snyggt formaterat) till standardfelsflödet; om tolken är interaktiv görs "
"det också tillgängligt för användaren som :data:`sys.last_traceback`."

msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the :attr:`~traceback.tb_next` attributes should be linked "
"to form a full stack trace."
msgstr ""
"För explicit skapade spårningar är det upp till skaparen av spårningen att "
"avgöra hur :attr:`~traceback.tb_next`-attributen ska länkas för att bilda en "
"fullständig stackspårning."

msgid ""
"Points to the execution :ref:`frame <frame-objects>` of the current level."
msgstr ""
"Pekar på exekveringen :ref:`frame <frame-objects>` av den aktuella nivån."

msgid ""
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""
"Åtkomst till detta attribut ger upphov till en :ref:`auditing event "
"<auditing>` ``object.__getattr__`` med argumenten ``obj`` och "
"``\"tb_frame\"``."

msgid "Gives the line number where the exception occurred"
msgstr "Ger radnumret där undantaget inträffade"

msgid "Indicates the \"precise instruction\"."
msgstr "Anger \"exakt instruktion\"."

msgid ""
"The line number and last instruction in the traceback may differ from the "
"line number of its :ref:`frame object <frame-objects>` if the exception "
"occurred in a :keyword:`try` statement with no matching except clause or "
"with a :keyword:`finally` clause."
msgstr ""
"Radnumret och den sista instruktionen i spårningen kan skilja sig från "
"radnumret i dess :ref:`frame object <frame-objects>` om undantaget "
"inträffade i en :keyword:`try`-sats utan någon matchande except-sats eller "
"med en :keyword:`finally`-sats."

msgid ""
"The special writable attribute :attr:`!tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level."
msgstr ""
"Det speciella skrivbara attributet :attr:`!tb_next` är nästa nivå i "
"stackspårningen (mot den ram där undantaget inträffade), eller ``None`` om "
"det inte finns någon nästa nivå."

msgid "This attribute is now writable"
msgstr "Detta attribut är nu skrivbart"

msgid "Slice objects"
msgstr "Skiva objekt"

msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"Slice-objekt används för att representera slices för :meth:`~object."
"__getitem__`-metoder.  De skapas också av den inbyggda funktionen :func:"
"`slice`."

msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Särskilda skrivskyddade attribut: :attr:`~slice.start` är den nedre "
"gränsen; :attr:`~slice.stop` är den övre gränsen; :attr:`~slice.step` är "
"stegvärdet; varje attribut är ``None`` om det utelämnas.  Dessa attribut kan "
"ha vilken typ som helst."

msgid "Slice objects support one method:"
msgstr "Slice-objekt stöder en metod:"

msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"Denna metod tar ett enda heltalsargument *length* och beräknar information "
"om den del som slice-objektet skulle beskriva om det tillämpades på en "
"sekvens av *length*-objekt.  Den returnerar en tupel av tre heltal; dessa är "
"indexen *start* och *stop* respektive *step* eller stride-längden för "
"skivan. Saknade index eller index utanför gränserna hanteras på ett sätt som "
"överensstämmer med vanliga slices."

msgid "Static method objects"
msgstr "Statiska metodobjekt"

msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Statiska metodobjekt är ett sätt att motverka den omvandling av "
"funktionsobjekt till metodobjekt som beskrivs ovan. Ett statiskt metodobjekt "
"är ett omslag runt ett annat objekt, vanligtvis ett användardefinierat "
"metodobjekt. När ett statiskt metodobjekt hämtas från en klass eller en "
"klassinstans är det objekt som faktiskt returneras det omslutna objektet, "
"som inte är föremål för någon ytterligare omvandling. Statiska metodobjekt "
"är också anropsbara. Statiska metodobjekt skapas av den inbyggda :func:"
"`staticmethod`-konstruktören."

msgid "Class method objects"
msgstr "Klassmetodobjekt"

msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under :ref:`\"instance methods\" <instance-"
"methods>`. Class method objects are created by the built-in :func:"
"`classmethod` constructor."
msgstr ""
"Ett klassmetodobjekt, liksom ett statiskt metodobjekt, är ett omslag runt "
"ett annat objekt som ändrar det sätt på vilket det objektet hämtas från "
"klasser och klassinstanser. Klassmetodobjektens beteende vid sådan hämtning "
"beskrivs ovan, under :ref:`\"instansmetoder\" <instance-methods>`. "
"Klassmetodobjekt skapas av den inbyggda :func:`classmethod`-konstruktören."

msgid "Special method names"
msgstr "Särskilda metodnamn"

msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`~object.__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"En klass kan implementera vissa operationer som anropas med speciell syntax "
"(t.ex. aritmetiska operationer eller subscripting och slicing) genom att "
"definiera metoder med speciella namn. Detta är Pythons sätt att använda :dfn:"
"`operator overloading`, vilket gör det möjligt för klasser att definiera "
"sitt eget beteende med avseende på språkoperatorer.  Om en klass till "
"exempel definierar en metod med namnet :meth:`~object.__getitem__`, och "
"``x`` är en instans av denna klass, så är ``x[i]`` ungefär likvärdig med "
"``type(x).__getitem__(x, i)``.  Om inget annat anges leder försök att utföra "
"en operation till ett undantag om ingen lämplig metod är definierad "
"(typiskt :exc:`AttributeError` eller :exc:`TypeError`)."

msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`~object."
"__iter__` to ``None``, the class is not iterable, so calling :func:`iter` on "
"its instances will raise a :exc:`TypeError` (without falling back to :meth:"
"`~object.__getitem__`). [#]_"
msgstr ""
"Om en specialmetod sätts till ``None`` innebär det att motsvarande operation "
"inte är tillgänglig.  Om en klass till exempel sätter :meth:`~object."
"__iter__` till ``None`` är klassen inte iterabel, så anrop av :func:`iter` "
"på dess instanser kommer att ge upphov till ett :exc:`TypeError` (utan att "
"falla tillbaka på :meth:`~object.__getitem__`). [#]_"

msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"När man implementerar en klass som emulerar en inbyggd typ är det viktigt "
"att emuleringen endast implementeras i den utsträckning som det är "
"meningsfullt för det objekt som modelleras.  Till exempel kan vissa "
"sekvenser fungera bra för hämtning av enskilda element, men det kanske inte "
"är meningsfullt att extrahera en del.  (Ett exempel på detta är :class:`~xml."
"dom.NodeList`-gränssnittet i W3C:s Document Object Model)"

msgid "Basic customization"
msgstr "Grundläggande anpassning"

msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Anropas för att skapa en ny instans av klassen *cls*. :meth:`__new__` är en "
"statisk metod (specialklassad så att du inte behöver deklarera den som "
"sådan) som tar den klass som en instans begärdes av som sitt första "
"argument.  De återstående argumenten är de som skickas till "
"objektkonstruktörens uttryck (anropet till klassen).  Returvärdet för :meth:"
"`__new__` bör vara den nya objektinstansen (vanligtvis en instans av *cls*)."

msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly created instance as "
"necessary before returning it."
msgstr ""
"Typiska implementeringar skapar en ny instans av klassen genom att anropa "
"superklassens :meth:`__new__`-metod genom att använda ``super()."
"__new__(cls[, ...])`` med lämpliga argument och sedan modifiera den "
"nyskapade instansen efter behov innan den returneras."

msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and "
"the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"Om :meth:`__new__` anropas under objektkonstruktionen och den returnerar en "
"instans av *cls*, kommer den nya instansens :meth:`__init__`-metod att "
"anropas som ``__init__(self[, ...])``, där *self* är den nya instansen och "
"de återstående argumenten är desamma som skickades till objektkonstruktören."

msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Om :meth:`__new__` inte returnerar en instans av *cls*, kommer den nya "
"instansens :meth:`__init__`-metod inte att anropas."

msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` är främst avsedd för att tillåta underklasser av "
"oföränderliga typer (som int, str eller tuple) att anpassa skapandet av "
"instanser.  Den åsidosätts också ofta i anpassade metaklasser för att "
"anpassa skapandet av klasser."

msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"Anropas efter att instansen har skapats (av :meth:`__new__`), men innan den "
"returneras till den som anropar.  Argumenten är de som skickas till klassens "
"konstruktörsuttryck.  Om en basklass har en :meth:`__init__`-metod, måste "
"den härledda klassens :meth:`__init__`-metod, om någon, uttryckligen anropa "
"den för att säkerställa korrekt initialisering av basklassens del av "
"instansen; till exempel: ``super().__init__([args...])``."

msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Eftersom :meth:`__new__` och :meth:`__init__` arbetar tillsammans för att "
"konstruera objekt (:meth:`__new__` för att skapa det och :meth:`__init__` "
"för att anpassa det), får inget värde som inte är ``None`` returneras av :"
"meth:`__init__`; om så sker kommer ett :exc:`TypeError` att uppstå vid "
"körning."

msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a :meth:"
"`__del__` method, the derived class's :meth:`__del__` method, if any, must "
"explicitly call it to ensure proper deletion of the base class part of the "
"instance."
msgstr ""
"Anropas när instansen är på väg att förstöras.  Detta kallas också en "
"finalizer eller (felaktigt) en destructor.  Om en basklass har en :meth:"
"`__del__`-metod, måste den härledda klassens :meth:`__del__`-metod, om "
"någon, uttryckligen anropa den för att säkerställa korrekt radering av "
"basklassens del av instansen."

msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
"Det är möjligt (men inte rekommenderat!) för metoden :meth:`__del__` att "
"skjuta upp destruktionen av instansen genom att skapa en ny referens till "
"den.  Detta kallas objektets *återuppståndelse*.  Det är "
"implementationsberoende om :meth:`__del__` anropas en andra gång när ett "
"återuppstått objekt är på väg att förstöras; den nuvarande :term:`CPython`-"
"implementationen anropar den bara en gång."

msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits. :class:`weakref.finalize` "
"provides a straightforward way to register a cleanup function to be called "
"when an object is garbage collected."
msgstr ""
"Det är inte garanterat att :meth:`__del__`-metoder anropas för objekt som "
"fortfarande existerar när tolken avslutas. :class:`weakref.finalize` ger ett "
"enkelt sätt att registrera en rensningsfunktion som ska anropas när ett "
"objekt samlas in."

msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` anropar inte direkt ``x.__del__()`` --- den förra minskar "
"referensantalet för ``x`` med ett, och den senare anropas endast när ``x`` "
"referensantal når noll."

msgid ""
"It is possible for a reference cycle to prevent the reference count of an "
"object from going to zero.  In this case, the cycle will be later detected "
"and deleted by the :term:`cyclic garbage collector <garbage collection>`.  A "
"common cause of reference cycles is when an exception has been caught in a "
"local variable.  The frame's locals then reference the exception, which "
"references its own traceback, which references the locals of all frames "
"caught in the traceback."
msgstr ""
"Det är möjligt för en referenscykel att förhindra att referensantalet för "
"ett objekt går ner till noll.  I så fall kommer cykeln senare att upptäckas "
"och raderas av :term:``cyklisk skräpsamlare <garbage collection>``.  En "
"vanlig orsak till referenscykler är när ett undantag har fångats upp i en "
"lokal variabel.  Ramens lokala variabler refererar då till undantaget, som "
"refererar till sin egen traceback, som refererar till de lokala variablerna "
"i alla ramar som fångas i tracebacken."

msgid "Documentation for the :mod:`gc` module."
msgstr "Dokumentation för modulen :mod:`gc`."

msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"På grund av de prekära omständigheter under vilka :meth:`__del__`-metoderna "
"anropas, ignoreras undantag som inträffar under deras exekvering och en "
"varning skrivs ut till ``sys.stderr`` istället.  I synnerhet:"

msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute :meth:"
"`__del__`."
msgstr ""
":meth:`__del__` kan anropas när godtycklig kod körs, inklusive från en "
"godtycklig tråd.  Om :meth:`__del__` behöver ta ett lås eller anropa någon "
"annan blockerande resurs kan det leda till dödläge eftersom resursen redan "
"kan vara tagen av den kod som avbryts för att exekvera :meth:`__del__`."

msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` kan köras när tolken stängs av.  Som en följd av detta kan "
"de globala variabler som den behöver komma åt (inklusive andra moduler) "
"redan ha raderats eller satts till ``None``. Python garanterar att globaler "
"vars namn börjar med ett enda understreck raderas från sin modul innan andra "
"globaler raderas; om det inte finns några andra referenser till sådana "
"globaler kan detta hjälpa till att säkerställa att importerade moduler "
"fortfarande är tillgängliga vid den tidpunkt då metoden :meth:`__del__` "
"anropas."

msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""
"Anropas av den inbyggda funktionen :func:`repr` för att beräkna den "
"\"officiella\" strängrepresentationen av ett objekt.  Om det är möjligt bör "
"detta se ut som ett giltigt Python-uttryck som kan användas för att "
"återskapa ett objekt med samma värde (i en lämplig miljö).  Om detta inte är "
"möjligt bör en sträng av formen ``<...någon användbar beskrivning...>`` "
"returneras. Returvärdet måste vara ett strängobjekt. Om en klass definierar :"
"meth:`__repr__` men inte :meth:`__str__`, så används :meth:`__repr__` också "
"när en \"informell\" strängrepresentation av instanser av klassen krävs."

msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous. A default implementation "
"is provided by the :class:`object` class itself."
msgstr ""
"Detta används vanligtvis för felsökning, så det är viktigt att "
"representationen är informationsrik och otvetydig. En standardimplementation "
"tillhandahålls av :class:`object`-klassen själv."

msgid ""
"Called by :func:`str(object) <str>`, the default :meth:`__format__` "
"implementation, and the built-in function :func:`print`, to compute the "
"\"informal\" or nicely printable string representation of an object.  The "
"return value must be a :ref:`str <textseq>` object."
msgstr ""
"Anropas av :func:`str(object) <str>`, standardimplementeringen :meth:"
"`__format__` och den inbyggda funktionen :func:`print`, för att beräkna den "
"\"informella\" eller snyggt utskrivbara strängrepresentationen av ett "
"objekt.  Returvärdet måste vara ett :ref:`str <textseq>`-objekt."

msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"Den här metoden skiljer sig från :meth:`object.__repr__` genom att det inte "
"finns någon förväntan på att :meth:`__str__` ska returnera ett giltigt "
"Python-uttryck: en mer bekväm eller kortfattad representation kan användas."

msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"Standardimplementeringen som definieras av den inbyggda typen :class:"
"`object` anropar :meth:`object.__repr__`."

msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object. The :class:"
"`object` class itself does not provide this method."
msgstr ""
"Anropas av :ref:`bytes <func-bytes>` för att beräkna en byte-"
"strängrepresentation av ett objekt. Detta bör returnera ett :class:`bytes`-"
"objekt. Klassen :class:`object` tillhandahåller inte själv denna metod."

msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
"Anropas av den inbyggda funktionen :func:`format`, och i förlängningen "
"utvärdering av :ref:`formatted string literals <f-strings>` och metoden :"
"meth:`str.format`, för att producera en \"formaterad\" strängrepresentation "
"av ett objekt. Argumentet *format_spec* är en sträng som innehåller en "
"beskrivning av de formateringsalternativ som önskas. Tolkningen av "
"argumentet *format_spec* är upp till den typ som implementerar :meth:"
"`__format__`, men de flesta klasser kommer antingen att delegera "
"formateringen till en av de inbyggda typerna eller använda en liknande "
"syntax för formateringsalternativ."

msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"Se :ref:`formatspec` för en beskrivning av standardformateringssyntaxen."

msgid "The return value must be a string object."
msgstr "Returvärdet måste vara ett strängobjekt."

msgid ""
"The default implementation by the :class:`object` class should be given an "
"empty *format_spec* string. It delegates to :meth:`__str__`."
msgstr ""
"Standardimplementeringen av :class:`object`-klassen bör ges en tom "
"*format_spec*-sträng. Den delegerar till :meth:`__str__`."

msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"Metoden __format__ i ``object`` själv ger upphov till ett :exc:`TypeError` "
"om den skickar en icke-tom sträng."

msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` är nu likvärdigt med ``str(x)`` i stället för "
"``format(str(x), '')``."

msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""
"Dessa är de så kallade \"rich comparison\"-metoderna. Korrespondensen mellan "
"operatorsymboler och metodnamn är följande: ``x<y`` kallar ``x.__lt__(y)``, "
"``x<=y`` kallar ``x.__le__(y)``, ``x==y`` kallar ``x.__eq__(y)``, ``x!=y`` "
"kallar ``x.__ne__(y)``, ``x>y`` kallar ``x.__gt__(y)`` och ``x>=y`` kallar "
"``x.__ge__(y)``."

msgid ""
"A rich comparison method may return the singleton :data:`NotImplemented` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"En rik jämförelsemetod kan returnera singleton :data:`NotImplemented` om den "
"inte implementerar operationen för ett givet par argument. Av konvention "
"returneras ``False`` och ``True`` för en lyckad jämförelse. Dessa metoder "
"kan dock returnera vilket värde som helst, så om jämförelseoperatorn används "
"i ett booleskt sammanhang (t.ex. i villkoret för en ``if``-sats), kommer "
"Python att anropa :func:`bool` på värdet för att avgöra om resultatet är "
"sant eller falskt."

msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning :"
"data:`NotImplemented` in the case of a false comparison: ``True if x is y "
"else NotImplemented``. For :meth:`__ne__`, by default it delegates to :meth:"
"`__eq__` and inverts the result unless it is :data:`!NotImplemented`.  There "
"are no other implied relationships among the comparison operators or default "
"implementations; for example, the truth of ``(x<y or x==y)`` does not imply "
"``x<=y``. To automatically generate ordering operations from a single root "
"operation, see :func:`functools.total_ordering`."
msgstr ""
"Som standard implementerar ``object`` :meth:`__eq__` genom att använda "
"``is`` och returnerar :data:`NotImplemented`` vid en falsk jämförelse: "
"``True if x is y else NotImplemented``. För :meth:`__ne__` delegerar den som "
"standard till :meth:`__eq__` och inverterar resultatet om det inte är :data:"
"`!NotImplemented`.  Det finns inga andra underförstådda relationer mellan "
"jämförelseoperatorerna eller standardimplementeringarna; till exempel "
"innebär sanningen i ``(x<y eller x==y)`` inte ``x<=y``. För att automatiskt "
"generera ordningsoperationer från en enda rotoperation, se :func:`functools."
"total_ordering`."

msgid ""
"By default, the :class:`object` class provides implementations consistent "
"with :ref:`expressions-value-comparisons`: equality compares according to "
"object identity, and order comparisons raise :exc:`TypeError`. Each default "
"method may generate these results directly, but may also return :data:"
"`NotImplemented`."
msgstr ""
"Som standard tillhandahåller klassen :class:`object` implementeringar som "
"överensstämmer med :ref:`expressions-value-comparisons`: jämlikhet jämförs "
"enligt objektets identitet, och ordningsjämförelser ger upphov till :exc:"
"`TypeError`. Varje standardmetod kan generera dessa resultat direkt, men kan "
"också returnera :data:`NotImplemented`."

msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"Se stycket om :meth:`__hash__` för några viktiga anvisningar om hur du "
"skapar :term:`hashable`-objekt som stöder anpassade jämförelseoperationer "
"och kan användas som nycklar i ordböcker."

msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and the right operand's type is a direct or indirect "
"subclass of the left operand's type, the reflected method of the right "
"operand has priority, otherwise the left operand's method has priority.  "
"Virtual subclassing is not considered."
msgstr ""
"Det finns inga versioner med utbytta argument av dessa metoder (som ska "
"användas när det vänstra argumentet inte stöder operationen men det högra "
"argumentet gör det); istället är :meth:`__lt__` och :meth:`__gt__` varandras "
"reflektion, :meth:`__le__` och :meth:`__ge__` är varandras reflektion, och :"
"meth:`__eq__` och :meth:`__ne__` är deras egen reflektion. Om operanderna är "
"av olika typer och den högra operandens typ är en direkt eller indirekt "
"subklass av den vänstra operandens typ, har den reflekterade metoden för den "
"högra operanden prioritet, annars har den vänstra operandens metod "
"prioritet.  Virtuell subklassning beaktas inte."

msgid ""
"When no appropriate method returns any value other than :data:"
"`NotImplemented`, the ``==`` and ``!=`` operators will fall back to ``is`` "
"and ``is not``, respectively."
msgstr ""
"När ingen lämplig metod returnerar något annat värde än :data:"
"`NotImplemented`, kommer operatorerna ``==`` och ``!=`` att falla tillbaka "
"till ``is`` respektive ``is not``."

msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  The ``__hash__()`` method should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"Anropas av den inbyggda funktionen :func:`hash` och för operationer på "
"medlemmar i hashade samlingar inklusive :class:`set`, :class:`frozenset` "
"och :class:`dict`.  Metoden ``__hash__()`` bör returnera ett heltal. Den "
"enda egenskap som krävs är att objekt som jämförs lika har samma hashvärde; "
"det är lämpligt att blanda ihop hashvärdena för de komponenter i objektet "
"som också spelar en roll vid jämförelse av objekt genom att packa dem i en "
"tupel och hasha tupeln. Exempel::"

msgid ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"
msgstr ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"

msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` trunkerar värdet som returneras från ett objekts anpassade :"
"meth:`__hash__`-metod till storleken på en :c:type:`Py_ssize_t`.  Detta är "
"vanligtvis 8 byte på 64-bitarsversioner och 4 byte på 32-bitarsversioner.  "
"Om ett objekts :meth:`__hash__` måste fungera på byggsystem med olika "
"bitstorlekar, se till att kontrollera bredden på alla byggsystem som stöds.  "
"Ett enkelt sätt att göra detta är med ``python -c \"import sys; print(sys."
"hash_info.width)\"``."

msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of :term:`hashable` collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the "
"wrong hash bucket)."
msgstr ""
"Om en klass inte definierar en :meth:`__eq__`-metod bör den inte heller "
"definiera en :meth:`__hash__`-operation; om den definierar :meth:`__eq__` "
"men inte :meth:`__hash__` kommer dess instanser inte att kunna användas som "
"objekt i hashbara samlingar.  Om en klass definierar föränderliga objekt och "
"implementerar en :meth:`__eq__`-metod, bör den inte implementera :meth:"
"`__hash__`, eftersom implementeringen av :term:`hashable`-samlingar kräver "
"att en nyckels hashvärde är oföränderligt (om objektets hashvärde ändras "
"kommer det att finnas i fel hashhink)."

msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default (inherited from the :class:`object` class); with them, all objects "
"compare unequal (except with themselves) and ``x.__hash__()`` returns an "
"appropriate value such that ``x == y`` implies both that ``x is y`` and "
"``hash(x) == hash(y)``."
msgstr ""
"Användardefinierade klasser har metoderna :meth:`__eq__` och :meth:"
"`__hash__` som standard (ärvda från klassen :class:`object`); med dem "
"jämförs alla objekt olika (utom med sig själva) och ``x.__hash__()`` "
"returnerar ett lämpligt värde så att ``x == y`` innebär både att ``x är y`` "
"och ``hash(x) == hash(y)``."

msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"En klass som åsidosätter :meth:`__eq__` och inte definierar :meth:`__hash__` "
"kommer att ha sin :meth:`__hash__` implicit satt till ``None``.  När "
"metoden :meth:`__hash__` för en klass är ``None``, kommer instanser av "
"klassen att ge upphov till ett lämpligt :exc:`TypeError`` när ett program "
"försöker hämta deras hashvärde, och kommer också att identifieras korrekt "
"som unhashable när man kontrollerar ``isinstance(obj, collections.abc."
"Hashable)``."

msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"Om en klass som åsidosätter :meth:`__eq__` behöver behålla implementeringen "
"av :meth:`__hash__` från en överordnad klass, måste tolken uttryckligen få "
"veta detta genom att ange ``__hash__ = <ParentClass>.__hash__``."

msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"Om en klass som inte åsidosätter :meth:`__eq__` vill undertrycka hash-stöd, "
"bör den inkludera ``__hash__ = None`` i klassdefinitionen. En klass som "
"definierar sin egen :meth:`__hash__` som uttryckligen ger upphov till ett :"
"exc:`TypeError` skulle felaktigt identifieras som hashable av ett "
"``isinstance(obj, collections.abc.Hashable)``-anrop."

msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"Som standard är :meth:`__hash__`-värdena för str- och bytes-objekt "
"\"saltade\" med ett oförutsägbart slumpmässigt värde.  Även om de förblir "
"konstanta inom en enskild Python-process, är de inte förutsägbara mellan "
"upprepade anrop av Python."

msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully chosen inputs that exploit the worst case performance of a dict "
"insertion, *O*\\ (*n*\\ :sup:`2`) complexity.  See http://ocert.org/"
"advisories/ocert-2011-003.html for details."
msgstr ""
"Detta är avsett att ge skydd mot en överbelastningsattack som orsakas av "
"noggrant utvalda inmatningar som utnyttjar den sämsta prestandan för en "
"diktinmatning, *O*\\ (*n*\\ :sup:`2`) komplexitet.  Se http://ocert.org/"
"advisories/ocert-2011-003.html för mer information."

msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"Om du ändrar hashvärden påverkas iterationsordningen för uppsättningar. "
"Python har aldrig gett några garantier för denna ordning (och den varierar "
"vanligtvis mellan 32-bitars och 64-bitars versioner)."

msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "Se även :envvar:`PYTHONHASHSEED`."

msgid "Hash randomization is enabled by default."
msgstr "Hash-randomisering är aktiverad som standard."

msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`~object.__len__` is called, if it is defined, and the object "
"is considered true if its result is nonzero.  If a class defines neither :"
"meth:`!__len__` nor :meth:`!__bool__` (which is true of the :class:`object` "
"class itself), all its instances are considered true."
msgstr ""
"Anropas för att implementera sanningsvärdestestning och den inbyggda "
"operationen ``bool()``; bör returnera ``False`` eller ``True``.  När denna "
"metod inte är definierad anropas :meth:`~object.__len__`, om den är "
"definierad, och objektet anses vara sant om resultatet är ett annat än "
"noll.  Om en klass varken definierar :meth:`!__len__` eller :meth:`!"
"__bool__` (vilket gäller för själva klassen :class:`object`), anses alla "
"dess instanser vara sanna."

msgid "Customizing attribute access"
msgstr "Anpassning av attributåtkomst"

msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Följande metoder kan definieras för att anpassa betydelsen av "
"attributåtkomst (användning av, tilldelning till eller borttagning av ``x."
"name``) för klassinstanser."

msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises :exc:"
"`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. The :class:"
"`object` class itself does not provide this method."
msgstr ""
"Anropas när standardattributåtkomsten misslyckas med ett :exc:"
"`AttributeError` (antingen :meth:`__getattribute__` ger upphov till ett :exc:"
"`AttributeError` eftersom *namn* inte är ett instansattribut eller ett "
"attribut i klassträdet för ``self``; eller :meth:`__get__` av en *namn*-"
"egenskap ger upphov till :exc:`AttributeError`).  Denna metod bör antingen "
"returnera det (beräknade) attributvärdet eller ge upphov till ett :exc:"
"`AttributeError` undantag. Klassen :class:`object` tillhandahåller inte "
"själv denna metod."

msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can take total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"Observera att om attributet hittas genom den normala mekanismen anropas "
"inte :meth:`__getattr__`.  (Detta är en avsiktlig asymmetri mellan :meth:"
"`__getattr__` och :meth:`__setattr__`) Detta görs både av effektivitetsskäl "
"och för att :meth:`__getattr__` annars inte skulle ha något sätt att komma "
"åt andra attribut hos instansen.  Observera att åtminstone för "
"instansvariabler kan du ta total kontroll genom att inte infoga några värden "
"i instansens attributordbok (utan istället infoga dem i ett annat objekt).  "
"Se metoden :meth:`__getattribute__` nedan för ett sätt att faktiskt få total "
"kontroll över attributåtkomst."

msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"Anropas ovillkorligen för att implementera attributåtkomst för instanser av "
"klassen. Om klassen också definierar :meth:`__getattr__`, kommer den senare "
"inte att anropas om inte :meth:`__getattribute__` antingen anropar den "
"explicit eller ger upphov till ett :exc:`AttributeError`. Denna metod bör "
"returnera det (beräknade) attributvärdet eller ge upphov till ett :exc:"
"`AttributeError` undantag. För att undvika oändlig rekursion i denna metod "
"bör dess implementering alltid anropa basklassens metod med samma namn för "
"att komma åt de attribut den behöver, till exempel ``object."
"__getattribute__(self, name)``."

msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or :ref:`built-in "
"functions <builtin-functions>`. See :ref:`special-lookup`."
msgstr ""
"Denna metod kan fortfarande förbigås när man letar upp specialmetoder som "
"ett resultat av implicit anrop via språksyntax eller :ref:``inbyggda "
"funktioner <builtin-functions>``. Se :ref:``special-lookup``."

msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"För vissa känsliga attributåtkomster, väcker en :ref:`auditing event "
"<auditing>` ``object.__getattr__`` med argumenten ``obj`` och ``name``."

msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Anropas när ett försök till attributtilldelning görs.  Detta anropas i "
"stället för den normala mekanismen (dvs. lagra värdet i instansordboken). "
"*name* är attributets namn, *value* är det värde som ska tilldelas "
"attributet."

msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
"Om :meth:`__setattr__` vill tilldela ett instansattribut ska den anropa "
"basklassens metod med samma namn, t.ex. ``object.__setattr__(self, name, "
"value)``."

msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"För vissa känsliga attributtilldelningar, väcker en :ref:`auditing event "
"<auditing>` ``object.__setattr__`` med argumenten ``obj``, ``name``, "
"``value``."

msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Som :meth:`__setattr__` men för borttagning av attribut istället för "
"tilldelning.  Detta bör endast implementeras om ``del obj.name`` är "
"meningsfullt för objektet."

msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"För vissa känsliga attribut raderingar, väcker en :ref:`auditing event "
"<auditing>` ``object.__delattr__`` med argument ``obj`` och ``name``."

msgid ""
"Called when :func:`dir` is called on the object. An iterable must be "
"returned. :func:`dir` converts the returned iterable to a list and sorts it."
msgstr ""
"Anropas när :func:`dir` anropas på objektet. En iterabel måste returneras. :"
"func:`dir` konverterar den returnerade iterabeln till en lista och sorterar "
"den."

msgid "Customizing module attribute access"
msgstr "Anpassa åtkomst till modulattribut"

msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, i.e. :meth:"
"`object.__getattribute__`, then ``__getattr__`` is searched in the module "
"``__dict__`` before raising an :exc:`AttributeError`. If found, it is called "
"with the attribute name and the result is returned."
msgstr ""
"Specialnamnen ``__getattr__`` och ``__dir__`` kan också användas för att "
"anpassa åtkomsten till modulattribut. Funktionen ``__getattr__`` på "
"modulnivå bör acceptera ett argument som är namnet på ett attribut och "
"returnera det beräknade värdet eller ge upphov till ett :exc:"
"`AttributeError`. Om ett attribut inte hittas på ett modulobjekt genom den "
"normala sökningen, dvs :meth:`object.__getattribute__`, söks ``__getattr__`` "
"i modulen ``__dict__`` innan ett :exc:`AttributeError`` avges. Om det hittas "
"anropas det med attributnamnet och resultatet returneras."

msgid ""
"The ``__dir__`` function should accept no arguments, and return an iterable "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""
"Funktionen ``__dir__`` ska inte acceptera några argument och returnera en "
"iterabel av strängar som representerar de namn som är tillgängliga i "
"modulen. Om den finns, åsidosätter den här funktionen standard :func:`dir`-"
"sökningen på en modul."

msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"För en mer finkornig anpassning av modulens beteende (inställning av "
"attribut, egenskaper etc.) kan man ställa in attributet ``__class__`` för "
"ett modulobjekt till en underklass av :class:`types.ModuleType`. Till "
"exempel::"

msgid ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"
msgstr ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"

msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"Att definiera modulen ``__getattr__`` och ställa in modulen ``__class__`` "
"påverkar endast uppslagningar som görs med hjälp av syntaxen för "
"attributåtkomst - direkt åtkomst till modulens globaler (oavsett om det sker "
"med kod i modulen eller via en referens till modulens globals-ordbok) "
"påverkas inte."

msgid "``__class__`` module attribute is now writable."
msgstr "modulattributet ``__class__`` är nu skrivbart."

msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "modulattributen ``__getattr__`` och ``__dir__``."

msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - Modulerna __getattr__ och __dir__"

msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "Beskriver funktionerna ``__getattr__`` och ``__dir__`` för moduler."

msgid "Implementing Descriptors"
msgstr "Implementering av deskriptorer"

msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`.  The :class:`object` class itself "
"does not implement any of these protocols."
msgstr ""
"Följande metoder gäller endast när en instans av den klass som innehåller "
"metoden (en så kallad *descriptor*-klass) förekommer i en *owner*-klass "
"(descriptorn måste finnas i antingen ägarens klassordbok eller i "
"klassordboken för en av dess föräldrar).  I exemplen nedan syftar "
"\"attributet\" på det attribut vars namn är nyckeln till egenskapen i "
"ägarklassens :attr:`~object.__dict__`.  Klassen :class:`object` i sig "
"implementerar inte något av dessa protokoll."

msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"Anropas för att hämta attributet för ägarklassen (tillgång till "
"klassattribut) eller för en instans av den klassen (tillgång till "
"instansattribut). Det valfria argumentet *owner* är ägarklassen, medan "
"*instance* är den instans som attributet åtkom genom, eller ``None`` när "
"attributet åtkom genom *owner*."

msgid ""
"This method should return the computed attribute value or raise an :exc:"
"`AttributeError` exception."
msgstr ""
"Denna metod bör returnera det beräknade attributvärdet eller ge upphov till "
"ett :exc:`AttributeError` undantag."

msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
":PEP:`252` specificerar att :meth:`__get__` är anropsbar med ett eller två "
"argument.  Pythons egna inbyggda deskriptorer stöder denna specifikation, "
"men det är troligt att vissa tredjepartsverktyg har deskriptorer som kräver "
"båda argumenten.  Pythons egen implementation av :meth:`__getattribute__` "
"skickar alltid in båda argumenten oavsett om de krävs eller inte."

msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Anropas för att sätta attributet på en instans *instans* av ägarklassen till "
"ett nytt värde, *värde*."

msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"Observera att om du lägger till :meth:`__set__` eller :meth:`__delete__` "
"ändras typen av deskriptor till en \"data descriptor\".  Se :ref:`descriptor-"
"invocation` för mer information."

msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Anropas för att ta bort attributet på en instans *instans* av ägarklassen."

msgid ""
"Instances of descriptors may also have the :attr:`!__objclass__` attribute "
"present:"
msgstr ""
"Instanser av deskriptorer kan också ha attributet :attr:`!__objclass__` "
"närvarande:"

msgid ""
"The attribute :attr:`!__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
"Attributet :attr:`!__objclass__` tolkas av modulen :mod:`inspect` som att "
"det anger den klass där objektet definierades (om detta anges på rätt sätt "
"kan det underlätta introspektion av dynamiska klassattribut under körning). "
"För anropsbara objekt kan det indikera att en instans av den angivna typen "
"(eller en underklass) förväntas eller krävs som det första positionella "
"argumentet (CPython anger till exempel detta attribut för obundna metoder "
"som implementeras i C)."

msgid "Invoking Descriptors"
msgstr "Anropa beskrivare"

msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, and :meth:"
"`~object.__delete__`. If any of those methods are defined for an object, it "
"is said to be a descriptor."
msgstr ""
"I allmänhet är en descriptor ett objektattribut med \"bindningsbeteende\", "
"ett attribut vars attributåtkomst har åsidosatts av metoder i "
"descriptorprotokollet: :meth:`~object.__get__`, :meth:`~object.__set__` och :"
"meth:`~object.__delete__`. Om någon av dessa metoder är definierade för ett "
"objekt, sägs det vara en deskriptor."

msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"Standardbeteendet för attributåtkomst är att hämta, ställa in eller ta bort "
"attributet från ett objekts ordbok. Till exempel har ``a.x`` en "
"uppslagskedja som börjar med ``a.__dict__['x']``, sedan ``type(a)."
"__dict__['x']`` och fortsätter genom basklasserna för ``type(a)`` exklusive "
"metaklasser."

msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"Men om det sökta värdet är ett objekt som definierar en av "
"deskriptormetoderna, kan Python åsidosätta standardbeteendet och anropa "
"deskriptormetoden istället.  Var detta inträffar i prioriteringskedjan beror "
"på vilka descriptormetoder som definierades och hur de anropades."

msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"Utgångspunkten för anrop av beskrivare är en bindning, ``a.x``. Hur "
"argumenten sammanställs beror på ``a``:"

msgid "Direct Call"
msgstr "Direktsamtal"

msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"Det enklaste och minst vanliga anropet är när användarkoden direkt anropar "
"en deskriptormetod: ``x.__get__(a)``."

msgid "Instance Binding"
msgstr "Bindning av instans"

msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"Om bindning sker till en objektinstans omvandlas ``a.x`` till anropet: "
"``type(a).__dict__['x'].__get__(a, type(a))``."

msgid "Class Binding"
msgstr "Klassbindning"

msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""
"Om bindning sker till en klass omvandlas ``A.x`` till anropet: ``A."
"__dict__['x'].__get__(None, A)``."

msgid "Super Binding"
msgstr "Super bindning"

msgid ""
"A dotted lookup such as ``super(A, a).x`` searches ``a.__class__.__mro__`` "
"for a base class ``B`` following ``A`` and then returns ``B.__dict__['x']."
"__get__(a, A)``.  If not a descriptor, ``x`` is returned unchanged."
msgstr ""
"En prickad uppslagning som ``super(A, a).x`` söker i ``a.__class__.__mro__`` "
"efter en basklass ``B`` efter ``A`` och returnerar sedan ``B.__dict__['x']."
"__get__(a, A)``.  Om det inte är en deskriptor returneras ``x`` oförändrad."

msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and :meth:"
"`~object.__delete__`.  If it does not define :meth:`!__get__`, then "
"accessing the attribute will return the descriptor object itself unless "
"there is a value in the object's instance dictionary.  If the descriptor "
"defines :meth:`!__set__` and/or :meth:`!__delete__`, it is a data "
"descriptor; if it defines neither, it is a non-data descriptor.  Normally, "
"data descriptors define both :meth:`!__get__` and :meth:`!__set__`, while "
"non-data descriptors have just the :meth:`!__get__` method.  Data "
"descriptors with :meth:`!__get__` and :meth:`!__set__` (and/or :meth:`!"
"__delete__`) defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"För instansbindningar beror företrädet för anrop av deskriptorer på vilka "
"deskriptormetoder som är definierade.  En descriptor kan definiera valfri "
"kombination av :meth:`~object.__get__`, :meth:`~object.__set__` och :meth:"
"`~object.__delete__`.  Om den inte definierar :meth:`!__get__`, kommer "
"åtkomst till attributet att returnera deskriptorobjektet självt om det inte "
"finns ett värde i objektets instansordbok.  Om deskriptorn definierar :meth:"
"`!__set__` och/eller :meth:`!__delete__` är den en datadeskriptor; om den "
"inte definierar någotdera är den en icke-datadeskriptor.  Normalt definierar "
"datadescriptorer både :meth:`!__get__` och :meth:`!__set__`, medan icke-"
"datadescriptorer bara har metoden :meth:`!__get__`.  Databeskrivare med :"
"meth:`!__get__` och :meth:`!__set__` (och/eller :meth:`!__delete__`) "
"definierade åsidosätter alltid en omdefiniering i en instansordbok.  Däremot "
"kan deskriptorer som inte är data åsidosättas av instanser."

msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented as "
"non-data descriptors.  Accordingly, instances can redefine and override "
"methods.  This allows individual instances to acquire behaviors that differ "
"from other instances of the same class."
msgstr ""
"Python-metoder (inklusive de som dekoreras med :func:`@staticmethod "
"<staticmethod>` och :func:`@classmethod <classmethod>`) implementeras som "
"icke-databeskrivare.  Följaktligen kan instanser omdefiniera och åsidosätta "
"metoder.  Detta gör att enskilda instanser kan få beteenden som skiljer sig "
"från andra instanser av samma klass."

msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"Funktionen :func:`property` är implementerad som en databeskrivare. "
"Följaktligen kan instanser inte åsidosätta beteendet hos en egenskap."

msgid "__slots__"
msgstr "__slots__"

msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* tillåter oss att uttryckligen deklarera datamedlemmar (som "
"egenskaper) och neka skapandet av :attr:`~object.__dict__` och *__weakref__* "
"(om inte uttryckligen deklarerat i *__slots__* eller tillgängligt i en "
"förälder.)"

msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr ""
"Det utrymme som sparas jämfört med att använda :attr:`~object.__dict__` kan "
"vara betydande. Hastigheten för attributuppslagning kan också förbättras "
"avsevärt."

msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of :attr:"
"`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"Denna klassvariabel kan tilldelas en sträng, en iterabel eller en sekvens av "
"strängar med variabelnamn som används av instanser.  *__slots__* reserverar "
"utrymme för de deklarerade variablerna och förhindrar automatiskt skapande "
"av :attr:`~object.__dict__` och *__weakref__* för varje instans."

msgid "Notes on using *__slots__*:"
msgstr "Anvisningar för användning av *__slots__*:"

msgid ""
"When inheriting from a class without *__slots__*, the :attr:`~object."
"__dict__` and *__weakref__* attribute of the instances will always be "
"accessible."
msgstr ""
"När du ärver från en klass utan *__slots__* kommer attributen :attr:`~object."
"__dict__` och *__weakref__* för instanserna alltid att vara tillgängliga."

msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"Utan variabeln :attr:`~object.__dict__` kan instanser inte tilldelas nya "
"variabler som inte listas i *__slots__*-definitionen.  Försök att tilldela "
"ett olistat variabelnamn ger upphov till :exc:`AttributeError`. Om dynamisk "
"tilldelning av nya variabler önskas, lägg då till ``'__dict__'`` till "
"sekvensen av strängar i *__slots__*-deklarationen."

msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Utan en variabel *__weakref__* för varje instans har klasser som definierar "
"*__slots__* inte stöd för :mod:``svaga referenser <weakref>` till sina "
"instanser. Om stöd för svaga referenser behövs, lägg till ``'__weakref__'`` "
"i sekvensen av strängar i deklarationen *__slots__*."

msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors "
"<descriptors>` for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"*__slots__* implementeras på klassnivå genom att skapa :ref:`descriptors "
"<descriptors>` för varje variabelnamn.  Därför kan klassattribut inte "
"användas för att ange standardvärden för instansvariabler som definieras av "
"*__slots__*; i annat fall skulle klassattributet skriva över "
"deskriptortilldelningen."

msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, instances of a child subclass will get a :attr:`~object.__dict__` "
"and *__weakref__* unless the subclass also defines *__slots__* (which should "
"only contain names of any *additional* slots)."
msgstr ""
"Verkan av en *__slots__*-deklaration är inte begränsad till den klass där "
"den är definierad.  *__slots__* som deklareras i föräldraklasser är "
"tillgängliga i underordnade klasser. Instanser av en underordnad underklass "
"kommer dock att få en :attr:`~object.__dict__` och *__weakref__* om inte "
"underklassen också definierar *__slots__* (som bara bör innehålla namn på "
"eventuella *ytterligare* slots)."

msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"Om en klass definierar en slot som också definieras i en basklass, är den "
"instansvariabel som definieras av basklassens slot otillgänglig (utom genom "
"att hämta dess deskriptor direkt från basklassen). Detta gör programmets "
"innebörd odefinierad.  I framtiden kan en kontroll läggas till för att "
"förhindra detta."

msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a "
"class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, and :class:"
"`tuple`."
msgstr ""
":exc:`TypeError` kommer att uppstå om icke-tomma *__slots__* definieras för "
"en klass som härrör från en :c:member:`\"variabel-längd\" inbyggd typ "
"<PyTypeObject.tp_itemsize>` såsom :class:`int`, :class:`bytes` och :class:"
"`tuple`."

msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr "Alla icke-strängformade :term:`iterable` kan tilldelas *__slots__*."

msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary "
"can be used to provide per-attribute docstrings that will be recognised by :"
"func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""
"Om en :class:`dictionary <dict>` används för att tilldela *__slots__*, "
"kommer nycklarna i ordlistan att användas som slotnamn. Värdena i ordlistan "
"kan användas för att tillhandahålla dokumentsträngar per attribut som kommer "
"att identifieras av :func:`inspect.getdoc` och visas i utdata från :func:"
"`help`."

msgid ""
":attr:`~object.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ""
":attr:`~object.__class__` fungerar endast om båda klasserna har samma "
"*__slots__*."

msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations "
"raise :exc:`TypeError`."
msgstr ""
":ref:`Multiple inheritance <tut-multiple>` med flera slotted föräldraklasser "
"kan användas, men endast en förälder får ha attribut som skapats av slots "
"(de andra baserna måste ha tomma slot layouter) - överträdelser ger upphov "
"till :exc:`TypeError`."

msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"Om en :term:`iterator` används för *__slots__* skapas en :term:`descriptor` "
"för vart och ett av iteratorns värden. Attributet *__slots__* kommer dock "
"att vara en tom iterator."

msgid "Customizing class creation"
msgstr "Anpassa skapandet av klasser"

msgid ""
"Whenever a class inherits from another class, :meth:`~object."
"__init_subclass__` is called on the parent class. This way, it is possible "
"to write classes which change the behavior of subclasses. This is closely "
"related to class decorators, but where class decorators only affect the "
"specific class they're applied to, ``__init_subclass__`` solely applies to "
"future subclasses of the class defining the method."
msgstr ""
"När en klass ärver från en annan klass anropas :meth:`~object."
"__init_subclass__` på moderklassen. På så sätt är det möjligt att skriva "
"klasser som ändrar beteendet hos underklasser. Detta är nära besläktat med "
"klassdekoratorer, men där klassdekoratorer endast påverkar den specifika "
"klass som de tillämpas på, gäller ``__init_subclass__`` endast framtida "
"subklasser av den klass som definierar metoden."

msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"Denna metod anropas när den innehållande klassen underklassas. *cls* är då "
"den nya subklassen. Om den definieras som en normal instansmetod konverteras "
"denna metod implicit till en klassmetod."

msgid ""
"Keyword arguments which are given to a new class are passed to the parent "
"class's ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"Nyckelordsargument som ges till en ny klass skickas till moderklassens "
"``__init_subclass__``. För kompatibilitet med andra klasser som använder "
"``__init_subclass__``, bör man ta ut de nyckelordsargument som behövs och "
"skicka de andra till basklassen, som i::"

msgid ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"
msgstr ""
"klass Filosof:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Filosof, default_name=\"Bruce\"):\n"
"    pass"

msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"Standardimplementeringen ``object.__init_subclass__`` gör ingenting, men ger "
"upphov till ett fel om den anropas med några argument."

msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"Metaklasstipset ``metaclass`` används av resten av typmaskineriet och "
"skickas aldrig till implementationer av ``__init_subclass__``. Den faktiska "
"metaklassen (snarare än den explicita ledtråden) kan nås som ``type(cls)``."

msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""
"När en klass skapas söker :meth:`type.__new__` igenom klassvariablerna och "
"gör återkallelser till dem med en :meth:`~object.__set_name__`-krok."

msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr ""
"Anropas automatiskt när den ägande klassen *owner* skapas. Objektet har "
"tilldelats *namn* i den klassen::"

msgid ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"
msgstr ""
"klass A:\n"
"    x = C() # Anropar automatiskt: x.__set_name__(A, 'x')"

msgid ""
"If the class variable is assigned after the class is created, :meth:"
"`__set_name__` will not be called automatically. If needed, :meth:"
"`__set_name__` can be called directly::"
msgstr ""
"Om klassvariabeln tilldelas efter att klassen har skapats, kommer :meth:"
"`__set_name__` inte att anropas automatiskt. Om det behövs kan :meth:"
"`__set_name__` anropas direkt::"

msgid ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"
msgstr ""
"klass A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c # Kroken anropas inte\n"
"c.__set_name__(A, 'x') # Anropa kroken manuellt"

msgid "See :ref:`class-object-creation` for more details."
msgstr "Se :ref:`class-object-creation` för mer information."

msgid "Metaclasses"
msgstr "Metaklasser"

msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"Som standard konstrueras klasser med hjälp av :func:`type`. Klassens kropp "
"exekveras i ett nytt namnområde och klassnamnet binds lokalt till resultatet "
"av ``type(name, bases, namespace)``."

msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"Processen för att skapa klasser kan anpassas genom att skicka "
"nyckelordsargumentet ``metaclass`` i klassdefinitionsraden, eller genom att "
"ärva från en befintlig klass som innehåller ett sådant argument. I följande "
"exempel är både ``MyClass`` och ``MySubclass`` instanser av ``Meta``::"

msgid ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"
msgstr ""
"klass Meta(typ):\n"
"    pass\n"
"\n"
"klass MyClass(metaklass=Meta):\n"
"    pass\n"
"\n"
"klass MySubclass(MyClass):\n"
"    pass"

msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"Alla andra nyckelordsargument som anges i klassdefinitionen skickas vidare "
"till alla metaklassoperationer som beskrivs nedan."

msgid "When a class definition is executed, the following steps occur:"
msgstr "När en klassdefinition exekveras sker följande steg:"

msgid "MRO entries are resolved;"
msgstr "MRO-posterna är åtgärdade;"

msgid "the appropriate metaclass is determined;"
msgstr "bestäms vilken metaklass som är lämplig;"

msgid "the class namespace is prepared;"
msgstr "klassnamnrymden är förberedd;"

msgid "the class body is executed;"
msgstr "klassens kropp exekveras;"

msgid "the class object is created."
msgstr "skapas klassobjektet."

msgid "Resolving MRO entries"
msgstr "Lösning av MRO-poster"

msgid ""
"If a base that appears in a class definition is not an instance of :class:"
"`type`, then an :meth:`!__mro_entries__` method is searched on the base. If "
"an :meth:`!__mro_entries__` method is found, the base is substituted with "
"the result of a call to :meth:`!__mro_entries__` when creating the class. "
"The method is called with the original bases tuple passed to the *bases* "
"parameter, and must return a tuple of classes that will be used instead of "
"the base. The returned tuple may be empty: in these cases, the original base "
"is ignored."
msgstr ""
"Om en bas som förekommer i en klassdefinition inte är en instans av :class:"
"`type`, söks en :meth:`!__mro_entries__`-metod på basen. Om en :meth:`!"
"__mro_entries__`-metod hittas ersätts basen med resultatet av ett anrop "
"till :meth:`!__mro_entries__` när klassen skapades. Metoden anropas med den "
"ursprungliga tupeln av baser som skickas till parametern *bases* och måste "
"returnera en tupel av klasser som ska användas i stället för basen. Den "
"returnerade tupeln kan vara tom: i dessa fall ignoreras den ursprungliga "
"basen."

msgid ":func:`types.resolve_bases`"
msgstr ":func:`types.resolve_bases`"

msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr "Dynamisk upplösning av baser som inte är instanser av :class:`type`."

msgid ":func:`types.get_original_bases`"
msgstr ":func:`types.get_original_bases`"

msgid ""
"Retrieve a class's \"original bases\" prior to modifications by :meth:"
"`~object.__mro_entries__`."
msgstr ""
"Hämta en klass \"ursprungliga baser\" före modifieringar med :meth:`~object."
"__mro_entries__`."

msgid ":pep:`560`"
msgstr ":pep:`560``"

msgid "Core support for typing module and generic types."
msgstr "Kärnstöd för typningsmodul och generiska typer."

msgid "Determining the appropriate metaclass"
msgstr "Fastställande av lämplig metaklass"

msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr ""
"Vilken metaklass som är lämplig för en klassdefinition bestäms på följande "
"sätt:"

msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"om inga baser och ingen explicit metaklass anges, används :func:`type`;"

msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass;"
msgstr ""
"om en explicit metaklass anges och den *inte* är en instans av :func:`type`, "
"så används den direkt som metaklass;"

msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"om en instans av :func:`type` anges som explicit metaklass, eller om baser "
"har definierats, används den mest härledda metaklassen."

msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"Den mest härledda metaklassen väljs från den explicit angivna metaklassen "
"(om någon) och metaklasserna (dvs. ``type(cls)``) för alla angivna "
"basklasser. Den mest härledda metaklassen är en metaklass som är en subtyp "
"av *alla* dessa kandidatmetaklasser. Om ingen av kandidatmetaklasserna "
"uppfyller detta kriterium kommer klassdefinitionen att misslyckas med "
"``TypeError``."

msgid "Preparing the class namespace"
msgstr "Förbereda klassens namnrymd"

msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"När en lämplig metaklass har identifierats förbereds klassens namnrymd. Om "
"metaklassen har ett ``__prepare__``-attribut, anropas den som ``namespace = "
"metaclass.__prepare__(name, bases, **kwds)`` (där de eventuella ytterligare "
"nyckelordsargumenten kommer från klassdefinitionen). Metoden ``__prepare__`` "
"bör implementeras som en :func:`classmethod <classmethod>`. Namnrymden som "
"returneras av ``__prepare__`` skickas till ``__new__``, men när det slutliga "
"klassobjektet skapas kopieras namnrymden till en ny ``dict``."

msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"Om metaklassen inte har något ``__prepare__``-attribut initieras "
"klassnamnrymden som en tom ordnad mappning."

msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaklasser i Python 3000"

msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Införde namnrymdshaken ``__prepare__``"

msgid "Executing the class body"
msgstr "Exekvering av klassens kropp"

msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"Klassens kropp exekveras (ungefär) som ``exec(body, globals(), namespace)``. "
"Den viktigaste skillnaden mot ett normalt anrop till :func:`exec` är att "
"lexical scoping gör att klassens kropp (inklusive alla metoder) kan referera "
"till namn från det aktuella och det yttre scopet när klassdefinitionen finns "
"inuti en funktion."

msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"Men även om klassdefinitionen finns i funktionen kan metoder som definieras "
"i klassen fortfarande inte se namn som definieras i klassens scope. "
"Klassvariabler måste nås via den första parametern i instans- eller "
"klassmetoder, eller via den implicita lexikaliskt scopade ``__class__``-"
"referensen som beskrivs i nästa avsnitt."

msgid "Creating the class object"
msgstr "Skapa klassobjektet"

msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"När klassens namnrymd har fyllts genom att exekvera klassens kropp, skapas "
"klassobjektet genom att anropa ``metaclass(name, bases, namespace, **kwds)`` "
"(de ytterligare nyckelord som skickas här är desamma som de som skickas till "
"``__prepare__``)."

msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""
"Detta klassobjekt är det som kommer att refereras till av nollargumentformen "
"av :func:`super`. ``__class__`` är en implicit stängningsreferens som skapas "
"av kompilatorn om några metoder i en klass kropp refererar till antingen "
"``__class__`` eller ``super``. Detta gör att nollargumentformen av :func:"
"`super` korrekt identifierar den klass som definieras baserat på lexikal "
"scoping, medan den klass eller instans som användes för att göra det "
"aktuella anropet identifieras baserat på det första argumentet som skickas "
"till metoden."

msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"I CPython 3.6 och senare skickas cellen ``__class__`` till metaklassen som "
"en ``__classcell__``-post i klassens namnrymd. Om den finns måste den "
"propageras upp till anropet ``type.__new__`` för att klassen ska initieras "
"korrekt. Om detta inte görs kommer det att resultera i ett :exc:"
"`RuntimeError` i Python 3.8."

msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"När du använder standardmetaklassen :class:`type`, eller en metaklass som i "
"slutändan anropar ``type.__new__``, anropas följande ytterligare "
"anpassningssteg efter att klassobjektet har skapats:"

msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"Metoden ``type.__new__`` samlar in alla attribut i klassens namnrymd som "
"definierar en :meth:`~object.__set_name__`-metod;"

msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr ""
"Dessa ``__set_name__``-metoder anropas med den klass som definieras och det "
"tilldelade namnet på det specifika attributet;"

msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent "
"of the new class in its method resolution order."
msgstr ""
"Kroken :meth:`~object.__init_subclass__` anropas på den nya klassens "
"omedelbara förälder i dess metodresolutionsordning."

msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"När klassobjektet har skapats skickas det till de klassdekoratorer som ingår "
"i klassdefinitionen (om sådana finns) och det resulterande objektet binds i "
"det lokala namnområdet som den definierade klassen."

msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~type.__dict__` attribute of the class object."
msgstr ""
"När en ny klass skapas med ``type.__new__`` kopieras det objekt som anges "
"som namnrymdsparameter till en ny ordnad mappning och originalobjektet "
"kasseras. Den nya kopian förpackas i en skrivskyddad proxy, som blir "
"attributet :attr:`~type.__dict__` för klassobjektet."

msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - Ny super"

msgid "Describes the implicit ``__class__`` closure reference"
msgstr "Beskriver den implicita ``__class__`` stängningsreferensen"

msgid "Uses for metaclasses"
msgstr "Användningsområden för metaklasser"

msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"De potentiella användningsområdena för metaklasser är gränslösa. Några idéer "
"som har utforskats är enum, loggning, gränssnittskontroll, automatisk "
"delegering, automatiskt skapande av egenskaper, proxies, ramverk och "
"automatisk resurslåsning/synkronisering."

msgid "Customizing instance and subclass checks"
msgstr "Anpassa kontroller av instanser och underklasser"

msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"Följande metoder används för att åsidosätta standardbeteendet för de "
"inbyggda funktionerna :func:`isinstance` och :func:`issubclass`."

msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"I synnerhet metaklassen :class:`abc.ABCMeta` implementerar dessa metoder för "
"att göra det möjligt att lägga till abstrakta basklasser (ABC) som "
"\"virtuella basklasser\" till vilken klass eller typ som helst (inklusive "
"inbyggda typer), inklusive andra ABC."

msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"Returnerar true om *instance* ska betraktas som en (direkt eller indirekt) "
"instans av *class*. Om definierad, anropas för att implementera "
"``isinstance(instance, class)``."

msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"Returnerar true om *subclass* ska betraktas som en (direkt eller indirekt) "
"underklass till *class*.  Om definierad, anropas för att implementera "
"``issubclass(subclass, class)``."

msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"Observera att dessa metoder söks upp i typen (metaklassen) för en klass.  De "
"kan inte definieras som klassmetoder i den faktiska klassen.  Detta "
"överensstämmer med uppslagningen av specialmetoder som anropas på instanser, "
"men i det här fallet är instansen själv en klass."

msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - Introduktion av abstrakta basklasser"

msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~type.__instancecheck__` and :meth:"
"`~type.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"Innehåller specifikationen för anpassning av :func:`isinstance` och :func:"
"`issubclass` beteende genom :meth:`~type.__instancecheck__` och :meth:`~type."
"__subclasscheck__`, med motivering för denna funktionalitet i samband med "
"tillägg av abstrakta basklasser (se modulen :mod:`abc`) till språket."

msgid "Emulating generic types"
msgstr "Emulering av generiska typer"

msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify "
"a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""
"När man använder :term:`type annotations<annotation>`, är det ofta "
"användbart att *parametrisera* en :term:`generisk typ` med Pythons "
"hakparentesnotation. Till exempel kan annoteringen ``list[int]`` användas "
"för att beteckna en :class:`list` där alla element är av typen :class:`int`."

msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Tips om typ"

msgid "Introducing Python's framework for type annotations"
msgstr "Introduktion till Pythons ramverk för typannoteringar"

msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Generiska alias-typer<types-genericalias>`"

msgid "Documentation for objects representing parameterized generic classes"
msgstr ""
"Dokumentation för objekt som representerar parametriserade generiska klasser"

msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`användardefinierad generik<user-defined-generics>` "
"och :class:`typing.Generic`"

msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Dokumentation om hur man implementerar generiska klasser som kan "
"parametriseras vid körning och förstås av statiska typkontrollanter."

msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""
"En klass kan *generellt* endast parametriseras om den definierar den "
"speciella klassmetoden ``__class_getitem__()``."

msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"Returnerar ett objekt som representerar specialiseringen av en generisk "
"klass med typargument som finns i *key*."

msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated with :func:"
"`@classmethod<classmethod>` when it is defined."
msgstr ""
"När den definieras för en klass är ``__class_getitem__()`` automatiskt en "
"klassmetod. Som sådan behöver den inte dekoreras med :func:"
"`@classmethod<classmethod>` när den definieras."

msgid "The purpose of *__class_getitem__*"
msgstr "Syftet med *__class_getitem__*"

msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily "
"apply :term:`type hints<type hint>` to these classes."
msgstr ""
"Syftet med :meth:`~object.__class_getitem__` är att tillåta runtime-"
"parametrisering av generiska klasser i standardbibliotek för att lättare "
"kunna tillämpa :term:`type hints<type hint>` på dessa klasser."

msgid ""
"To implement custom generic classes that can be parameterized at runtime and "
"understood by static type-checkers, users should either inherit from a "
"standard library class that already implements :meth:`~object."
"__class_getitem__`, or inherit from :class:`typing.Generic`, which has its "
"own implementation of ``__class_getitem__()``."
msgstr ""
"För att implementera anpassade generiska klasser som kan parametriseras vid "
"körning och förstås av statiska typkontrollanter, bör användare antingen "
"ärva från en standardbiblioteksklass som redan implementerar :meth:`~object."
"__class_getitem__`, eller ärva från :class:`typing.Generic`, som har sin "
"egen implementering av ``__class_getitem__()``."

msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party "
"type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""
"Anpassade implementeringar av :meth:`~object.__class_getitem__` på klasser "
"som definieras utanför standardbiblioteket kanske inte förstås av "
"typkontrollprogram från tredje part, t.ex. mypy. Att använda "
"``__class_getitem__()`` på någon klass för andra syften än typhinting är "
"avrådande."

msgid "*__class_getitem__* versus *__getitem__*"
msgstr "*__class_getitem__* kontra *__getitem__*"

msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""
"Vanligtvis anropar :ref:` `subscription<subscriptions>` för ett objekt med "
"hakparenteser :meth:`~object.__getitem__`-instansmetoden som definieras i "
"objektets klass. Men om objektet som prenumereras i sig är en klass, kan "
"klassmetoden :meth:`~object.__class_getitem__` anropas istället. "
"``__class_getitem__()`` bör returnera ett :ref:`GenericAlias<types-"
"genericalias>` objekt om det är korrekt definierat."

msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether :meth:"
"`~object.__getitem__` or :meth:`~object.__class_getitem__` should be called::"
msgstr ""
"När :term:`uttrycket` ``obj[x]`` presenteras, följer Python-tolken ungefär "
"följande process för att avgöra om :meth:`~object.__getitem__` eller :meth:"
"`~object.__class_getitem__` ska anropas::"

msgid ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"
msgstr ""
"från inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Returnera resultatet av uttrycket 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = typ(obj)\n"
"\n"
"    # Om klassen för obj definierar __getitem__,\n"
"    # anropa class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Annars, om obj är en klass och definierar __class_getitem__,\n"
"    # anropa obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Annars, skapa ett undantag\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' objektet är inte subskriberbart\"\n"
"        )"

msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have "
"the :class:`type` class as their metaclass. :class:`type` does not define :"
"meth:`~object.__getitem__`, meaning that expressions such as ``list[int]``, "
"``dict[str, float]`` and ``tuple[str, bytes]`` all result in :meth:`~object."
"__class_getitem__` being called::"
msgstr ""
"I Python är alla klasser själva instanser av andra klasser. Klassen för en "
"klass är känd som klassens :term:`metaklass`, och de flesta klasser har "
"klassen :class:`type` som sin metaklass. :class:`type` definierar inte :meth:"
"`~object.__getitem__`, vilket innebär att uttryck som ``list[int]``, "
"``dict[str, float]`` och ``tuple[str, bytes]`` alla resulterar i att :meth:"
"`~object.__class_getitem__` anropas::"

msgid ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"
msgstr ""
">>> # list har klassen \"type\" som sin metaklass, som de flesta klasser:\n"
">>> typ(lista)\n"
"<klass 'typ'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"Sant\n"
">>> # \"list[int]\" anropar \"list.__class_getitem__(int)\"\n"
">>> lista[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returnerar ett GenericAlias-objekt:\n"
">>> type(list[int])\n"
"<class 'typer.GenericAlias'>"

msgid ""
"However, if a class has a custom metaclass that defines :meth:`~object."
"__getitem__`, subscribing the class may result in different behaviour. An "
"example of this can be found in the :mod:`enum` module::"
msgstr ""
"Men om en klass har en egen metaklass som definierar :meth:`~object."
"__getitem__`, kan en prenumeration av klassen resultera i ett annat "
"beteende. Ett exempel på detta finns i modulen :mod:`enum`::"

msgid ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"
msgstr ""
">>> from enum import Enum\n"
">>> klass Meny(Enum):\n"
"...     \"\"\"En frukostmeny\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = \"bacon\n"
"...\n"
">>> # Enumklasser har en anpassad metaklass:\n"
">>> typ(Meny)\n"
"<klass 'enum.EnumMeta'> >>> # EnumMeta definierar\n"
">>> # EnumMeta definierar __getitem__,\n"
">>> # så __class_getitem__ anropas inte,\n"
">>> # och resultatet är inte ett GenericAlias-objekt:\n"
">>> Meny['SPAM']\n"
"<Menu.SPAM: 'spam'> >>> typ(Menu['SPAM'])\n"
">>> type(Meny['SPAM'])\n"
"<enum 'Meny'>"

msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ":pep:`560` - Kärnstöd för typning av moduler och generiska typer"

msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a :ref:"
"`subscription<subscriptions>` results in ``__class_getitem__()`` being "
"called instead of :meth:`~object.__getitem__`"
msgstr ""
"Introducerar :meth:`~object.__class_getitem__`, och beskriver när en :ref:"
"`subscription<subscriptions>` resulterar i att ``__class_getitem__()`` "
"anropas istället för :meth:`~object.__getitem__`"

msgid "Emulating callable objects"
msgstr "Emulering av anropsbara objekt"

msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``. The :class:`object` class itself does not provide this method."
msgstr ""
"Anropas när instansen \"anropas\" som en funktion; om denna metod är "
"definierad översätts ``x(arg1, arg2, ...)`` ungefär till ``type(x)."
"__call__(x, arg1, ...)``. Klassen :class:`object` tillhandahåller inte själv "
"denna metod."

msgid "Emulating container types"
msgstr "Emulering av containertyper"

msgid ""
"The following methods can be defined to implement container objects. None of "
"them are provided by the :class:`object` class itself. Containers usually "
"are :term:`sequences <sequence>` (such as :class:`lists <list>` or :class:"
"`tuples <tuple>`) or :term:`mappings <mapping>` (like :term:`dictionaries "
"<dictionary>`), but can represent other containers as well.  The first set "
"of methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or :"
"class:`slice` objects, which define a range of items.  It is also "
"recommended that mappings provide the methods :meth:`!keys`, :meth:`!"
"values`, :meth:`!items`, :meth:`!get`, :meth:`!clear`, :meth:`!setdefault`, :"
"meth:`!pop`, :meth:`!popitem`, :meth:`!copy`, and :meth:`!update` behaving "
"similar to those for Python's standard :class:`dictionary <dict>` objects.  "
"The :mod:`collections.abc` module provides a :class:`~collections.abc."
"MutableMapping` :term:`abstract base class` to help create those methods "
"from a base set of :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__`, and :meth:`!keys`. Mutable "
"sequences should provide methods :meth:`!append`, :meth:`!count`, :meth:`!"
"index`, :meth:`!extend`, :meth:`!insert`, :meth:`!pop`, :meth:`!remove`, :"
"meth:`!reverse` and :meth:`!sort`, like Python standard :class:`list` "
"objects. Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`~object.__add__`, :meth:`~object.__radd__`, :meth:`~object."
"__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` and :meth:"
"`~object.__imul__` described below; they should not define other numerical "
"operators.  It is recommended that both mappings and sequences implement "
"the :meth:`~object.__contains__` method to allow efficient use of the ``in`` "
"operator; for mappings, ``in`` should search the mapping's keys; for "
"sequences, it should search through the values.  It is further recommended "
"that both mappings and sequences implement the :meth:`~object.__iter__` "
"method to allow efficient iteration through the container; for mappings, :"
"meth:`!__iter__` should iterate through the object's keys; for sequences, it "
"should iterate through the values."
msgstr ""
"Följande metoder kan definieras för att implementera containerobjekt. Ingen "
"av dem tillhandahålls av :class:`object`-klassen själv. Containers är "
"vanligtvis :term:`sequences <sequence>` (som :class:`lists <list>` eller :"
"class:`tuples <tuple>`) eller :term:`mappings <mapping>` (som :term:"
"`dictionaries <dictionary>`), men kan även representera andra containers.  "
"Den första uppsättningen metoder används antingen för att emulera en sekvens "
"eller för att emulera en mappning; skillnaden är att för en sekvens bör de "
"tillåtna nycklarna vara heltalen *k* för vilka ``0 &lt;= k &lt; N`` där *N* "
"är sekvensens längd, eller :class:`slice`-objekt, som definierar ett "
"intervall av objekt.  Det rekommenderas också att mappningar tillhandahåller "
"metoderna :meth:`!keys`, :meth:`!values`, :meth:`!items`, :meth:`!get`, :"
"meth:`!clear`, :meth:`!setdefault`, :meth:`!pop`, :meth:`!popitem`, :meth:`!"
"copy` och :meth:`!update` som beter sig på liknande sätt som Pythons "
"standardobjekt :class:`dictionary &lt;dict&gt;`.  Modulen :mod:`collections."
"abc` tillhandahåller en :class:`~collections.abc.MutableMapping` :term:"
"`abstrakt basklass` som hjälper till att skapa dessa metoder från en "
"basuppsättning av :meth:`~object.__getitem__`, :meth:`~object.__setitem__`, :"
"meth:`~object.__delitem__` och :meth:`!keys`. Mutabla sekvenser bör "
"tillhandahålla metoderna :meth:`!append`, :meth:`!count`, :meth:`!index`, :"
"meth:`!extend`, :meth:`!insert`, :meth:`!pop`, :meth:`!remove`, :meth:`!"
"reverse` och :meth:`!sort`, precis som Pythons standardobjekt :class:`list`. "
"Slutligen bör sekvenstyper implementera addition (vilket betyder "
"sammankoppling) och multiplikation (vilket betyder upprepning) genom att "
"definiera metoderna :meth:`~object.__add__`, :meth:`~object.__radd__`, :meth:"
"`~object.__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` och :"
"meth:`~object.__imul__` som beskrivs nedan; de bör inte definiera andra "
"numeriska operatorer.  Det rekommenderas att både mappningar och sekvenser "
"implementerar metoden :meth:`~object.__contains__` för att möjliggöra "
"effektiv användning av operatorn ``in``; för mappningar bör ``in`` söka "
"igenom mappningens nycklar; för sekvenser bör den söka igenom värdena.  Det "
"rekommenderas vidare att både mappningar och sekvenser implementerar "
"metoden :meth:`~object.__iter__` för att möjliggöra effektiv iteration genom "
"containern; för mappningar bör :meth:`!__iter__` iterera genom objektets "
"nycklar; för sekvenser bör den iterera genom värdena."

msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`~object.__bool__` method and whose :meth:`!__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""
"Anropas för att implementera den inbyggda funktionen :func:`len`.  Bör "
"returnera objektets längd, ett heltal ``>=`` 0. Dessutom anses ett objekt "
"som inte definierar en :meth:`~object.__bool__`-metod och vars :meth:`!"
"__len__`-metod returnerar noll vara falskt i en boolesk kontext."

msgid ""
"In CPython, the length is required to be at most :data:`sys.maxsize`. If the "
"length is larger than :data:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`~object.__bool__` method."
msgstr ""
"I CPython krävs det att längden är högst :data:`sys.maxsize`. Om längden är "
"större än :data:`!sys.maxsize` kan vissa funktioner (t.ex. :func:`len`) ge "
"upphov till :exc:`OverflowError`.  För att förhindra att :exc:`!"
"OverflowError` uppstår genom sanningsvärdestestning måste ett objekt "
"definiera en :meth:`~object.__bool__`-metod."

msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also be :data:"
"`NotImplemented`, which is treated the same as if the ``__length_hint__`` "
"method didn't exist at all. This method is purely an optimization and is "
"never required for correctness."
msgstr ""
"Anropas för att implementera :func:`operator.length_hint`. Bör returnera en "
"uppskattad längd för objektet (som kan vara större eller mindre än den "
"faktiska längden). Längden måste vara ett heltal ``>=`` 0. Returvärdet kan "
"också vara :data:`NotImplemented`, vilket behandlas på samma sätt som om "
"metoden ``__length_hint__`` inte existerade alls. Denna metod är enbart en "
"optimering och krävs aldrig för korrekthet."

msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr "Slicing görs uteslutande med följande tre metoder.  Ett anrop som ::"

msgid "a[1:2] = b"
msgstr "a[1:2] = b"

msgid "is translated to ::"
msgstr "är översatt till ::"

msgid "a[slice(1, 2, None)] = b"
msgstr "a[slice(1, 2, None)] = b"

msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "och så vidare.  Saknade slice-objekt fylls alltid i med ``None``."

msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types, "
"the accepted keys should be integers. Optionally, they may support :class:"
"`slice` objects as well.  Negative index support is also optional. If *key* "
"is of an inappropriate type, :exc:`TypeError` may be raised; if *key* is a "
"value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. For :"
"term:`mapping` types, if *key* is missing (not in the container), :exc:"
"`KeyError` should be raised."
msgstr ""
"Anropas för att implementera utvärdering av ``self[key]``. För :term:"
"`sequence`-typer bör de accepterade nycklarna vara heltal. Eventuellt kan de "
"även stödja :class:`slice`-objekt.  Stöd för negativa index är också "
"valfritt. Om *key* är av en olämplig typ kan :exc:`TypeError` visas; om "
"*key* är ett värde som ligger utanför uppsättningen index för sekvensen "
"(efter eventuell speciell tolkning av negativa värden) bör :exc:`IndexError` "
"visas. För :term:`mapping`-typer, om *key* saknas (inte i behållaren), bör :"
"exc:`KeyError` anges."

msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` loopar förväntar sig att ett :exc:`IndexError` kommer att "
"uppstå för olagliga index för att möjliggöra korrekt upptäckt av slutet av "
"sekvensen."

msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class method :"
"meth:`~object.__class_getitem__` may be called instead of ``__getitem__()``. "
"See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""
"När :ref:`subscripting<subscriptions>` en *klass*, kan den speciella "
"klassmetoden :meth:`~object.__class_getitem__` anropas istället för "
"``__getitem__()``. Se :ref:`classgetitem-versus-getitem` för mer information."

msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Anropas för att implementera tilldelning till ``self[key]``.  Samma "
"anmärkning som för :meth:`__getitem__`.  Detta bör endast implementeras för "
"mappningar om objekten stöder ändringar av värden för nycklar, eller om nya "
"nycklar kan läggas till, eller för sekvenser om element kan ersättas.  Samma "
"undantag bör göras för felaktiga *nyckel*-värden som för metoden :meth:"
"`__getitem__`."

msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"Anropas för att implementera borttagning av ``self[key]``.  Samma anmärkning "
"som för :meth:`__getitem__`.  Detta bör endast implementeras för mappningar "
"om objekten stöder borttagning av nycklar, eller för sekvenser om element "
"kan tas bort från sekvensen.  Samma undantag bör göras för felaktiga *key*-"
"värden som för metoden :meth:`__getitem__`."

msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"Anropas av :class:`dict` .\\ :meth:`__getitem__` för att implementera "
"``self[key]`` för dict-subklasser när key inte finns i ordlistan."

msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"Denna metod anropas när en :term:`iterator` krävs för en container. Denna "
"metod bör returnera ett nytt iteratorobjekt som kan iterera över alla objekt "
"i containern.  För mappningar bör den iterera över nycklarna i behållaren."

msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"Anropas (om det finns) av den inbyggda :func:`reversed` för att implementera "
"omvänd iteration.  Det bör returnera ett nytt iteratorobjekt som itererar "
"över alla objekt i behållaren i omvänd ordning."

msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
"Om metoden :meth:`__reversed__` inte tillhandahålls kommer den inbyggda :"
"func:`reversed` att falla tillbaka till att använda sekvensprotokollet (:"
"meth:`__len__` och :meth:`__getitem__`).  Objekt som stöder "
"sekvensprotokollet bör endast tillhandahålla :meth:`__reversed__` om de kan "
"tillhandahålla en implementering som är mer effektiv än den som "
"tillhandahålls av :func:`reversed`."

msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"Operatorerna för medlemskapstest (:keyword:`in` och :keyword:`not in`) "
"implementeras normalt som en iteration genom en behållare. Containerobjekt "
"kan dock förse följande specialmetod med en mer effektiv implementering, som "
"inte heller kräver att objektet är itererbart."

msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Anropas för att implementera operatorer för medlemskapstest.  Bör returnera "
"true om *item* finns i *self*, false annars.  För mappningsobjekt bör detta "
"beakta nycklarna i mappningen snarare än värdena eller paren nyckel-objekt."

msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"För objekt som inte definierar :meth:`__contains__` försöker "
"medlemskapstestet först iteration via :meth:`__iter__`, sedan det gamla "
"sekvensiterationsprotokollet via :meth:`__getitem__`, se :ref:`det här "
"avsnittet i språkreferensen <membership-test-details>`."

msgid "Emulating numeric types"
msgstr "Emulering av numeriska typer"

msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"Följande metoder kan definieras för att emulera numeriska objekt. Metoder "
"som motsvarar operationer som inte stöds av den särskilda typ av tal som "
"implementeras (t.ex. bitvisa operationer för icke-integrala tal) bör lämnas "
"odefinierade."

msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to "
"evaluate the expression ``x + y``, where *x* is an instance of a class that "
"has an :meth:`__add__` method, ``type(x).__add__(x, y)`` is called.  The :"
"meth:`__divmod__` method should be the equivalent to using :meth:"
"`__floordiv__` and :meth:`__mod__`; it should not be related to :meth:"
"`__truediv__`.  Note that :meth:`__pow__` should be defined to accept an "
"optional third argument if the three-argument version of the built-in :func:"
"`pow` function is to be supported."
msgstr ""
"Dessa metoder anropas för att implementera binära aritmetiska operationer "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  För att t.ex. "
"utvärdera uttrycket ``x + y``, där *x* är en instans av en klass som har en :"
"meth:`__add__`-metod, anropas ``type(x).__add__(x, y)``.  Metoden :meth:"
"`__divmod__` bör vara likvärdig med att använda :meth:`__floordiv__` och :"
"meth:`__mod__`; den bör inte vara relaterad till :meth:`__truediv__`.  "
"Observera att :meth:`__pow__` bör definieras så att den accepterar ett "
"valfritt tredje argument om treargumentversionen av den inbyggda funktionen :"
"func:`pow` skall stödjas."

msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return :data:`NotImplemented`."
msgstr ""
"Om en av dessa metoder inte stöder operationen med de angivna argumenten, "
"bör den returnera :data:`NotImplemented`."

msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands.  These functions are only called if the operands are of different "
"types, when the left operand does not support the corresponding operation "
"[#]_, or the right operand's class is derived from the left operand's class. "
"[#]_ For instance, to evaluate the expression ``x - y``, where *y* is an "
"instance of a class that has an :meth:`__rsub__` method, ``type(y)."
"__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)`` returns :data:"
"`NotImplemented` or ``type(y)`` is a subclass of ``type(x)``. [#]_"
msgstr ""
"Dessa metoder anropas för att implementera binära aritmetiska operationer "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) med reflekterade "
"(swappade) operander.  Dessa funktioner anropas endast om operanderna är av "
"olika typer, om den vänstra operanden inte stöder motsvarande operation [#]_ "
"eller om den högra operandens klass är härledd från den vänstra operandens "
"klass. [#]_ Till exempel, för att utvärdera uttrycket ``x - y``, där *y* är "
"en instans av en klass som har en :meth:`__rsub__` metod, anropas ``type(y)."
"__rsub__(y, x)`` om ``type(x).__sub__(x, y)`` returnerar :data:"
"`NotImplemented` eller ``type(y)`` är en subklass av ``type(x)``. [#]_"

msgid ""
"Note that :meth:`__rpow__` should be defined to accept an optional third "
"argument if the three-argument version of the built-in :func:`pow` function "
"is to be supported."
msgstr ""
"Observera att :meth:`__rpow__` bör definieras så att den accepterar ett "
"valfritt tredje argument om treargumentversionen av den inbyggda :func:`pow`-"
"funktionen skall stödjas."

msgid ""
"Three-argument :func:`pow` now try calling :meth:`~object.__rpow__` if "
"necessary. Previously it was only called in two-argument :func:`!pow` and "
"the binary power operator."
msgstr ""
"Tre-argument :func:`pow` försöker nu anropa :meth:`~object.__rpow__` om det "
"behövs. Tidigare anropades det bara i två-argument :func:`!pow` och den "
"binära potensoperatorn."

msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Om den högra operandens typ är en subklass av den vänstra operandens typ och "
"denna subklass tillhandahåller en annan implementering av den reflekterade "
"metoden för operationen, kommer denna metod att anropas före den vänstra "
"operandens icke-reflekterade metod. Detta beteende gör det möjligt för "
"subklasser att åsidosätta sina förfäders operationer."

msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, or "
"if that method returns :data:`NotImplemented`, the augmented assignment "
"falls back to the normal methods.  For instance, if *x* is an instance of a "
"class with an :meth:`__iadd__` method, ``x += y`` is equivalent to ``x = x."
"__iadd__(y)`` . If :meth:`__iadd__` does not exist, or if ``x.__iadd__(y)`` "
"returns :data:`!NotImplemented`, ``x.__add__(y)`` and ``y.__radd__(x)`` are "
"considered, as with the evaluation of ``x + y``. In certain situations, "
"augmented assignment can result in unexpected errors (see :ref:`faq-"
"augmented-assignment-tuple-error`), but this behavior is in fact part of the "
"data model."
msgstr ""
"Dessa metoder anropas för att implementera de utökade aritmetiska "
"tilldelningarna (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  Dessa metoder bör "
"försöka utföra operationen på plats (modifiera *self*) och returnera "
"resultatet (som kan vara, men inte behöver vara, *self*).  Om en specifik "
"metod inte är definierad, eller om metoden returnerar :data:"
"`NotImplemented`, faller det utökade uppdraget tillbaka på de normala "
"metoderna.  Om till exempel *x* är en instans av en klass med en :meth:"
"`__iadd__-metod, är ``x += y`` ekvivalent med ``x = x.__iadd__(y)`` . Om :"
"meth:`__iadd__` inte finns, eller om ``x.__iadd__(y)`` returnerar :data:`!"
"NotImplemented`, beaktas ``x.__add__(y)`` och ``y.__radd__(x)``, precis som "
"vid utvärderingen av ``x + y``. I vissa situationer kan augmented assignment "
"resultera i oväntade fel (se :ref:`faq-augmented-assignment-tuple-error`), "
"men detta beteende är i själva verket en del av datamodellen."

msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""
"Anropas för att implementera de unära aritmetiska operationerna (``-``, "
"``+``, :func:`abs` och ``~``)."

msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and :"
"func:`float`.  Should return a value of the appropriate type."
msgstr ""
"Anropas för att implementera de inbyggda funktionerna :func:`complex`, :func:"
"`int` och :func:`float`.  Bör returnera ett värde av lämplig typ."

msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"Anropas för att implementera :func:`operator.index`, och när Python behöver "
"konvertera det numeriska objektet till ett heltalsobjekt (t.ex. vid slicing, "
"eller i de inbyggda funktionerna :func:`bin`, :func:`hex` och :func:`oct`). "
"Närvaron av denna metod indikerar att det numeriska objektet är en "
"heltalstyp.  Måste returnera ett heltal."

msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"Om :meth:`__int__`, :meth:`__float__` och :meth:`__complex__` inte är "
"definierade faller motsvarande inbyggda funktioner :func:`int`, :func:"
"`float` och :func:`complex` tillbaka på :meth:`__index__`."

msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"Anropas för att implementera den inbyggda funktionen :func:`round` och :mod:"
"`math` funktionerna :func:`~math.trunc`, :func:`~math.floor` och :func:"
"`~math.ceil`. Om inte *ndigits* skickas till :meth:`!__round__` bör alla "
"dessa metoder returnera värdet av objektet trunkerat till en :class:"
"`~numbers.Integral` (typiskt en :class:`int`)."

msgid ""
":func:`int` no longer delegates to the :meth:`~object.__trunc__` method."
msgstr ""
":func:`int` delegerar inte längre till metoden :meth:`~object.__trunc__`."

msgid "With Statement Context Managers"
msgstr "Med uttalande från kontextansvariga"

msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
"En :dfn:`context manager` är ett objekt som definierar det körtidssammanhang "
"som skall upprättas när en :keyword:`with`-sats exekveras. Kontexthanteraren "
"hanterar inträdet i och utträdet ur den önskade körtidskontexten för "
"exekveringen av kodblocket.  Kontexthanterare anropas normalt med hjälp av :"
"keyword:`!with`-satsen (beskrivs i avsnitt :ref:`with`), men kan också "
"användas genom att direkt anropa deras metoder."

msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Typiska användningsområden för kontexthanterare är att spara och återställa "
"olika typer av globala tillstånd, låsa och låsa upp resurser, stänga öppnade "
"filer etc."

msgid ""
"For more information on context managers, see :ref:`typecontextmanager`. "
"The :class:`object` class itself does not provide the context manager "
"methods."
msgstr ""
"För mer information om kontexthanterare, se :ref:`typecontextmanager`. "
"Klassen :class:`object` i sig tillhandahåller inte "
"kontexthanteringsmetoderna."

msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"Ange den runtime-kontext som är relaterad till detta objekt. Satsen :keyword:"
"`with` kommer att binda denna metods returvärde till det eller de mål som "
"anges i satsens :keyword:`!as`-klausul, om det finns något."

msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"Avslutar runtime-kontexten som är relaterad till detta objekt. Parametrarna "
"beskriver det undantag som orsakade att kontexten avslutades. Om kontexten "
"avslutades utan ett undantag, kommer alla tre argumenten att vara :const:"
"`None`."

msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"Om ett undantag anges och metoden vill undertrycka undantaget (dvs. "
"förhindra att det sprids), ska den returnera ett sant värde. Annars kommer "
"undantaget att behandlas normalt när metoden avslutas."

msgid ""
"Note that :meth:`~object.__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
"Observera att :meth:`~object.__exit__` -metoder inte bör återskapa det "
"överlämnade undantaget; detta är anroparens ansvar."

msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Uttalandet \"med\""

msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Specifikation, bakgrund och exempel för Pythons :keyword:`with`-sats."

msgid "Customizing positional arguments in class pattern matching"
msgstr "Anpassning av positionella argument vid matchning av klassmönster"

msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid "
"without special support in ``MyClass``. To be able to use that kind of "
"pattern, the class needs to define a *__match_args__* attribute."
msgstr ""
"När ett klassnamn används i ett mönster tillåts inte positionella argument i "
"mönstret som standard, dvs. ``case MyClass(x, y)`` är typiskt ogiltigt utan "
"särskilt stöd i ``MyClass``. För att kunna använda den typen av mönster "
"måste klassen definiera ett *__match_args__*-attribut."

msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent "
"to setting it to ``()``."
msgstr ""
"Denna klassvariabel kan tilldelas en tupel av strängar. När den här klassen "
"används i ett klassmönster med positionella argument konverteras varje "
"positionellt argument till ett nyckelordsargument, med motsvarande värde i "
"*__match_args__** som nyckelord. Avsaknaden av detta attribut är likvärdigt "
"med att sätta det till ``()``."

msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a :"
"exc:`TypeError`."
msgstr ""
"Om till exempel ``MyClass.__match_args__`` är ``(\"left\", \"center\", "
"\"right\")`` betyder det att ``case MyClass(x, y)`` är likvärdigt med ``case "
"MyClass(left=x, center=y)``. Observera att antalet argument i mönstret måste "
"vara mindre än eller lika med antalet element i *__match_args__*; om det är "
"större kommer försöket att matcha mönstret att ge upphov till ett :exc:"
"`TypeError`."

msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - Matchning av strukturella mönster"

msgid "The specification for the Python ``match`` statement."
msgstr "Specifikationen för Pythons ``match``-sats."

msgid "Emulating buffer types"
msgstr "Emulering av bufferttyper"

msgid ""
"The :ref:`buffer protocol <bufferobjects>` provides a way for Python objects "
"to expose efficient access to a low-level memory array. This protocol is "
"implemented by builtin types such as :class:`bytes` and :class:`memoryview`, "
"and third-party libraries may define additional buffer types."
msgstr ""
":ref:`buffer protocol <bufferobjects>` ger Python-objekt ett sätt att "
"exponera effektiv åtkomst till en minnesmatris på låg nivå. Detta protokoll "
"implementeras av inbyggda typer som :class:`bytes` och :class:`memoryview`, "
"och tredjepartsbibliotek kan definiera ytterligare bufferttyper."

msgid ""
"While buffer types are usually implemented in C, it is also possible to "
"implement the protocol in Python."
msgstr ""
"Bufferttyper implementeras vanligtvis i C, men det är också möjligt att "
"implementera protokollet i Python."

msgid ""
"Called when a buffer is requested from *self* (for example, by the :class:"
"`memoryview` constructor). The *flags* argument is an integer representing "
"the kind of buffer requested, affecting for example whether the returned "
"buffer is read-only or writable. :class:`inspect.BufferFlags` provides a "
"convenient way to interpret the flags. The method must return a :class:"
"`memoryview` object."
msgstr ""
"Anropas när en buffert begärs från *self* (t.ex. av :class:`memoryview`-"
"konstruktören). Argumentet *flags* är ett heltal som representerar den typ "
"av buffert som begärs, vilket t.ex. påverkar om den returnerade bufferten är "
"skrivskyddad eller skrivbar. :class:`inspect.BufferFlags` ger ett bekvämt "
"sätt att tolka flaggorna. Metoden måste returnera ett :class:`memoryview`-"
"objekt."

msgid ""
"Called when a buffer is no longer needed. The *buffer* argument is a :class:"
"`memoryview` object that was previously returned by :meth:`~object."
"__buffer__`. The method must release any resources associated with the "
"buffer. This method should return ``None``. Buffer objects that do not need "
"to perform any cleanup are not required to implement this method."
msgstr ""
"Anropas när en buffert inte längre behövs. Argumentet *buffer* är ett objekt "
"av :class:`memoryview` som tidigare returnerats av :meth:`~object."
"__buffer__`. Metoden måste frigöra alla resurser som är associerade med "
"bufferten. Denna metod bör returnera ``None``. Buffertobjekt som inte "
"behöver utföra någon rensning behöver inte implementera den här metoden."

msgid ":pep:`688` - Making the buffer protocol accessible in Python"
msgstr ":pep:`688` - Att göra buffertprotokollet tillgängligt i Python"

msgid ""
"Introduces the Python ``__buffer__`` and ``__release_buffer__`` methods."
msgstr ""
"Presenterar Python-metoderna ``__buffer__`` och ``__release_buffer__``."

msgid ":class:`collections.abc.Buffer`"
msgstr ":class:`samlingar.abc.buffert`"

msgid "ABC for buffer types."
msgstr "ABC för bufferttyper."

msgid "Annotations"
msgstr "Anteckningar"

msgid ""
"Functions, classes, and modules may contain :term:`annotations "
"<annotation>`, which are a way to associate information (usually :term:`type "
"hints <type hint>`) with a symbol."
msgstr ""
"Funktioner, klasser och moduler kan innehålla :term:`annotations "
"<annotation>`, som är ett sätt att associera information (vanligtvis :term:"
"`type hints <type hint>`) med en symbol."

msgid ""
"This attribute contains the annotations for an object. It is :ref:`lazily "
"evaluated <lazy-evaluation>`, so accessing the attribute may execute "
"arbitrary code and raise exceptions. If evaluation is successful, the "
"attribute is set to a dictionary mapping from variable names to annotations."
msgstr ""
"Detta attribut innehåller annoteringarna för ett objekt. Det :ref:"
"`utvärderas slentrianmässigt <lazy-evaluation>`, så åtkomst till attributet "
"kan exekvera godtycklig kod och ge upphov till undantag. Om utvärderingen "
"lyckas sätts attributet till en dictionary-mappning från variabelnamn till "
"annotationer."

msgid "Annotations are now lazily evaluated."
msgstr "Annotationer utvärderas nu på ett lättsamt sätt."

msgid ""
"An :term:`annotate function`. Returns a new dictionary object mapping "
"attribute/parameter names to their annotation values."
msgstr ""
"En :term:`annoteringsfunktion`. Returnerar ett nytt ordboksobjekt som mappar "
"attribut-/parameternamn till deras annoteringsvärden."

msgid ""
"Takes a format parameter specifying the format in which annotations values "
"should be provided. It must be a member of the :class:`annotationlib.Format` "
"enum, or an integer with a value corresponding to a member of the enum."
msgstr ""
"Tar emot en formatparameter som anger i vilket format värden för "
"anteckningar ska anges. Den måste vara en medlem i enum :class:"
"`annotationlib.Format`, eller ett heltal med ett värde som motsvarar en "
"medlem i enum."

msgid ""
"If an annotate function doesn't support the requested format, it must raise :"
"exc:`NotImplementedError`. Annotate functions must always support :attr:"
"`~annotationlib.Format.VALUE` format; they must not raise :exc:"
"`NotImplementedError()` when called with this format."
msgstr ""
"Om en annoteringsfunktion inte stöder det begärda formatet måste den ge "
"upphov till :exc:`NotImplementedError`. Annoteringsfunktioner måste alltid "
"stödja formatet :attr:`~annotationlib.Format.VALUE`; de får inte ge upphov "
"till :exc:`NotImplementedError()` när de anropas med detta format."

msgid ""
"When called with  :attr:`~annotationlib.Format.VALUE` format, an annotate "
"function may raise :exc:`NameError`; it must not raise :exc:`!NameError` "
"when called requesting any other format."
msgstr ""
"När en annotate-funktion anropas med :attr:`~annotationlib.Format.VALUE`-"
"format kan den ge upphov till :exc:`NameError`; den får inte ge upphov till :"
"exc:`!NameError` när den anropas med något annat format."

msgid ""
"If an object does not have any annotations, :attr:`~object.__annotate__` "
"should preferably be set to ``None`` (it can’t be deleted), rather than set "
"to a function that returns an empty dict."
msgstr ""
"Om ett objekt inte har några annoteringar bör :attr:`~object.__annotate__` "
"helst sättas till ``None`` (det kan inte tas bort), snarare än att sättas "
"till en funktion som returnerar en tom dict."

msgid ":pep:`649` --- Deferred evaluation of annotation using descriptors"
msgstr ""
":pep:`649` --- Uppskjuten utvärdering av annotering med hjälp av deskriptorer"

msgid ""
"Introduces lazy evaluation of annotations and the ``__annotate__`` function."
msgstr ""
"Introducerar latent utvärdering av annoteringar och funktionen "
"``__annotate__``."

msgid "Special method lookup"
msgstr "Särskild metoduppslagning"

msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"För anpassade klasser garanteras implicita anrop av specialmetoder att "
"fungera korrekt endast om de definieras på ett objekts typ, inte i objektets "
"instansordbok.  Detta beteende är anledningen till att följande kod ger "
"upphov till ett undantag::"

msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"
msgstr ""
"&gt;&gt;&gt; klass C:\n"
"... pass\n"
"...\n"
"&gt;&gt;&gt; c = C()\n"
"&gt;&gt;&gt; c.__len__ = lambda: 5\n"
"&gt;&gt;&gt; len(c)\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: objekt av typen 'C' har ingen len()"

msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"Anledningen till detta beteende är ett antal specialmetoder som :meth:"
"`~object.__hash__` och :meth:`~object.__repr__` som implementeras av alla "
"objekt, inklusive typobjekt. Om den implicita uppslagningen av dessa metoder "
"använde den konventionella uppslagningsprocessen skulle de misslyckas när de "
"anropas på typobjektet självt::"

msgid ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""
"&gt;&gt;&gt; 1 .__hash__() == hash(1)\n"
"Sant\n"
"&gt;&gt;&gt; int.__hash__() == hash(int)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: deskriptorn '__hash__' för objektet 'int' behöver ett argument"

msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"Att felaktigt försöka anropa en obunden metod i en klass på detta sätt "
"kallas ibland \"metaklassförvirring\" och undviks genom att förbigå "
"instansen när man söker efter speciella metoder::"

msgid ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"
msgstr ""
">>> typ(1).__hash__(1) == hash(1)\n"
"Sant\n"
">>> typ(int).__hash__(int) == hash(int)\n"
"Sant"

msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"Förutom att implicit specialmetoduppslagning förbigår alla instansattribut "
"för korrekthetens skull, förbigår den i allmänhet också :meth:`~object."
"__getattribute__`-metoden, även för objektets metaklass::"

msgid ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"
msgstr ""
">>> klass Meta(typ):\n"
"... def __getattribute__(*args):\n"
"... print(\"Metaklass getattribute åberopad\")\n"
"... return typ.__getattribute__(*args)\n"
"...\n"
">>> klass C(objekt, metaklass=Meta):\n"
"... def __len__(self):\n"
"... return 10\n"
"... def __getattribute__(*args):\n"
"... print(\"Klassen getattribute anropades\")\n"
"... return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__() # Explicit uppslagning via instans\n"
"Klass getattribute åberopad\n"
"10\n"
">>> type(c).__len__(c) # Explicit uppslagning via typ\n"
"Metaklass getattribut åberopad\n"
"10\n"
">>> len(c) # Implicit uppslagning\n"
"10"

msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"Att kringgå :meth:`~object.__getattribute__`-maskineriet på detta sätt ger "
"betydande utrymme för hastighetsoptimeringar i tolken, på bekostnad av viss "
"flexibilitet i hanteringen av specialmetoder (specialmetoden *måste* ställas "
"in på själva klassobjektet för att konsekvent kunna anropas av tolken)."

msgid "Coroutines"
msgstr "Coroutines"

msgid "Awaitable Objects"
msgstr "Väntande objekt"

msgid ""
"An :term:`awaitable` object generally implements an :meth:`~object."
"__await__` method. :term:`Coroutine objects <coroutine>` returned from :"
"keyword:`async def` functions are awaitable."
msgstr ""
"Ett :term:`awaitable` objekt implementerar i allmänhet en :meth:`~object."
"__await__` metod. :term:`Coroutine objects <coroutine>` som returneras från :"
"keyword:`async def` funktioner är awaitable."

msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` are also awaitable, but they do not implement :"
"meth:`~object.__await__`."
msgstr ""
"De :term:`generator iterator`-objekt som returneras från generatorer "
"dekorerade med :func:`types.coroutine` är också awaitable, men de "
"implementerar inte :meth:`~object.__await__`."

msgid ""
"Must return an :term:`iterator`.  Should be used to implement :term:"
"`awaitable` objects.  For instance, :class:`asyncio.Future` implements this "
"method to be compatible with the :keyword:`await` expression. The :class:"
"`object` class itself is not awaitable and does not provide this method."
msgstr ""
"Måste returnera en :term:`iterator`.  Bör användas för att implementera :"
"term:`awaitable`-objekt.  Till exempel implementerar :class:`asyncio.Future` "
"den här metoden för att vara kompatibel med :keyword:`await`-uttrycket. "
"Klassen :class:`object` i sig är inte awaitable och tillhandahåller inte "
"denna metod."

msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework (e."
"g. :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""
"Språket lägger inga restriktioner på typen eller värdet av de objekt som "
"iteratorn som returneras av ``__await__`` ger, eftersom detta är specifikt "
"för implementeringen av ramverket för asynkron exekvering (t.ex. :mod:"
"`asyncio``) som kommer att hantera objektet :term:`awaitable``."

msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` för ytterligare information om awaitable-objekt."

msgid "Coroutine Objects"
msgstr "Coroutine-objekt"

msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__` "
"and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the exception's :"
"attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines "
"should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Coroutine-objekt <coroutine>`` är :term:`awaitable`-objekt. En "
"coroutines exekvering kan kontrolleras genom att anropa :meth:`~object."
"__await__` och iterera över resultatet.  När coroutinen har exekverats "
"färdigt och returnerar, ger iteratorn upphov till :exc:`StopIteration`, och "
"undantagets attribut :attr:`~StopIteration.value` innehåller returvärdet.  "
"Om coroutinen ger upphov till ett undantag sprids det vidare av iteratorn.  "
"Coroutines bör inte direkt ge upphov till ohanterade :exc:`StopIteration`-"
"undantag."

msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"Coroutines har också de metoder som anges nedan, vilka är analoga med dem "
"för generatorer (se :ref:`generator-methods`).  Till skillnad från "
"generatorer har coroutines dock inte direkt stöd för iteration."

msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr ""
"Det är ett :exc:`RuntimeError` att awaita på en coroutine mer än en gång."

msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`~object."
"__await__`.  If *value* is not ``None``, this method delegates to the :meth:"
"`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`!__await__` return "
"value, described above."
msgstr ""
"Startar eller återupptar körningen av coroutinen.  Om *värde* är ``None``, "
"motsvarar detta att flytta fram iteratorn som returneras av :meth:`~object."
"__await__`.  Om *value* inte är ``None`` delegerar denna metod till metoden :"
"meth:`~generator.send` för den iterator som orsakade att coroutinen "
"avbröts.  Resultatet (returvärde, :exc:`StopIteration` eller annat undantag) "
"är detsamma som när man itererar över returvärdet för :meth:`!__await__`, "
"som beskrivs ovan."

msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, :exc:"
"`StopIteration`, or other exception) is the same as when iterating over the :"
"meth:`~object.__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"Utlöser det angivna undantaget i coroutinen.  Denna metod delegerar till :"
"meth:`~generator.throw`-metoden för den iterator som orsakade att coroutinen "
"avbröts, om den har en sådan metod.  Annars tas undantaget upp vid "
"avbrottspunkten.  Resultatet (returvärde, :exc:`StopIteration` eller annat "
"undantag) är detsamma som när man itererar över returvärdet för :meth:"
"`~object.__await__`, som beskrivs ovan.  Om undantaget inte fångas upp i "
"coroutinen sprids det tillbaka till den som anropar."

msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""
"Den andra signaturen \\(type\\[, value\\[, traceback\\]\\]\\ \\) är "
"föråldrad och kan tas bort i en framtida version av Python."

msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"Gör att coroutinen rensar upp sig själv och avslutas.  Om coroutinen är "
"avbruten delegerar den här metoden först till :meth:`~generator.close`-"
"metoden för den iterator som fick coroutinen att avbrytas, om den har en "
"sådan metod.  Sedan utlöser den :exc:`GeneratorExit` vid avbrottspunkten, "
"vilket gör att coroutinen omedelbart rensar upp sig själv. Slutligen "
"markeras coroutinen som färdig exekverad, även om den aldrig startades."

msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr ""
"Coroutine-objekt stängs automatiskt med hjälp av ovanstående process när de "
"är på väg att förstöras."

msgid "Asynchronous Iterators"
msgstr "Asynkrona Iteratorer"

msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"En *asynkron iterator* kan anropa asynkron kod i sin metod ``__anext__``."

msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "Asynkrona iteratorer kan användas i en :keyword:`async for`-sats."

msgid "The :class:`object` class itself does not provide these methods."
msgstr "Klassen :class:`object` i sig tillhandahåller inte dessa metoder."

msgid "Must return an *asynchronous iterator* object."
msgstr "Måste returnera ett *asynkront iterator*-objekt."

msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"Måste returnera en *awaitable* som resulterar i ett nästa värde för "
"iteratorn.  Bör ge upphov till ett :exc:`StopAsyncIteration`-fel när "
"iterationen är över."

msgid "An example of an asynchronous iterable object::"
msgstr "Ett exempel på ett asynkront iterabelt objekt::"

msgid ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"
msgstr ""
"klass Läsare:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        om val == b'':\n"
"            höja StopAsyncIteration\n"
"        returnera val"

msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"Före Python 3.7 kunde :meth:`~object.__aiter__` returnera en *awaitable* som "
"skulle lösas till en :term:`asynkron iterator <asynchronous iterator>`."

msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a :exc:"
"`TypeError` error."
msgstr ""
"Från och med Python 3.7 måste :meth:`~object.__aiter__` returnera ett "
"asynkront iteratorobjekt.  Om något annat returneras kommer det att "
"resultera i ett :exc:`TypeError`-fel."

msgid "Asynchronous Context Managers"
msgstr "Asynkrona kontexthanterare"

msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"En *asynkron kontexthanterare* är en *kontexthanterare* som kan avbryta "
"exekveringen i sina metoder ``__aenter__`` och ``__aexit__``."

msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"Asynkrona kontexthanterare kan användas i en :keyword:`async with`-sats."

msgid ""
"Semantically similar to :meth:`~object.__enter__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Semantiskt lik :meth:`~object.__enter__`, den enda skillnaden är att den "
"måste returnera en *awaitable*."

msgid ""
"Semantically similar to :meth:`~object.__exit__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Semantiskt lik :meth:`~object.__exit__`, den enda skillnaden är att den "
"måste returnera en *awaitable*."

msgid "An example of an asynchronous context manager class::"
msgstr "Ett exempel på en asynkron kontexthanteringsklass::"

msgid ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"
msgstr ""
"klass AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('går in i kontext')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('lämnar kontext')"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"Det *är* möjligt att i vissa fall ändra ett objekts typ, under vissa "
"kontrollerade förhållanden. Det är dock i allmänhet ingen bra idé, eftersom "
"det kan leda till mycket konstiga beteenden om det hanteras felaktigt."

msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__`, :meth:`~object.__contains__`, :meth:`~object."
"__class_getitem__` and :meth:`~os.PathLike.__fspath__` methods have special "
"handling for this. Others will still raise a :exc:`TypeError`, but may do so "
"by relying on the behavior that ``None`` is not callable."
msgstr ""
"Metoderna :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__`, :meth:`~object.__contains__`, :meth:`~object."
"__class_getitem__` och :meth:`~os.PathLike.__fspath__` har särskild "
"hantering för detta. Andra kommer fortfarande att ge upphov till ett :exc:"
"`TypeError`, men kan göra det genom att förlita sig på beteendet att "
"``None`` inte är anropbart."

msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns :data:`NotImplemented`.  Do not set the method to ``None`` if "
"you want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"\"Stöder inte\" betyder här att klassen inte har någon sådan metod, eller "
"att metoden returnerar :data:`NotImplemented`.  Sätt inte metoden till "
"``None`` om du vill tvinga fram fallback till den högra operandens "
"reflekterade metod - det kommer istället att ha motsatt effekt att explicit "
"*blockera* sådan fallback."

msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`~object.__add__`) fails then the operation is not "
"supported, which is why the reflected method is not called."
msgstr ""
"För operander av samma typ antas det att om den icke-reflekterade metoden (t."
"ex. :meth:`~object.__add__`) misslyckas stöds inte operationen, varför den "
"reflekterade metoden inte anropas."

msgid ""
"If the right operand's type is a subclass of the left operand's type, the "
"reflected method having precedence allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Om den högra operandens typ är en subklass av den vänstra operandens typ, "
"har den reflekterade metoden företräde, vilket gör att subklasser kan "
"åsidosätta sina förfäders operationer."

msgid "object"
msgstr "objekt"

msgid "data"
msgstr "data"

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "id"
msgstr "id"

msgid "type"
msgstr "typ"

msgid "identity of an object"
msgstr "identitet för ett objekt"

msgid "value of an object"
msgstr "värdet av ett objekt"

msgid "type of an object"
msgstr "typ av ett objekt"

msgid "mutable object"
msgstr "föränderligt objekt"

msgid "immutable object"
msgstr "oföränderligt objekt"

msgid "garbage collection"
msgstr "sophämtning"

msgid "reference counting"
msgstr "referensräkning"

msgid "unreachable object"
msgstr "oåtkomligt objekt"

msgid "container"
msgstr "behållare"

msgid "hierarchy"
msgstr "hierarki"

msgid "extension"
msgstr "tillägg"

msgid "module"
msgstr "modul"

msgid "C"
msgstr "C"

msgid "language"
msgstr "språk"

msgid "attribute"
msgstr "attribut"

msgid "special"
msgstr "speciella"

msgid "generic"
msgstr "generisk"

msgid "..."
msgstr "..."

msgid "ellipsis literal"
msgstr "ellips bokstavlig"

msgid "numeric"
msgstr "numeriska"

msgid "integer"
msgstr "heltal"

msgid "representation"
msgstr "representation"

msgid "Boolean"
msgstr "Boolean"

msgid "False"
msgstr "Falskt"

msgid "True"
msgstr "Sant"

msgid "floating-point"
msgstr "flyttal"

msgid "number"
msgstr "nummer"

msgid "Java"
msgstr "Java"

msgid "complex"
msgstr "komplex"

msgid "len"
msgstr "len"

msgid "sequence"
msgstr "sekvens"

msgid "index operation"
msgstr "indexoperation"

msgid "item selection"
msgstr "val av objekt"

msgid "subscription"
msgstr "prenumeration"

msgid "slicing"
msgstr "skivning"

msgid "immutable sequence"
msgstr "oföränderlig sekvens"

msgid "immutable"
msgstr "oföränderlig"

msgid "string"
msgstr "sträng"

msgid "immutable sequences"
msgstr "oföränderliga sekvenser"

msgid "chr"
msgstr "chr"

msgid "ord"
msgstr "ord"

msgid "character"
msgstr "tecken"

msgid "Unicode"
msgstr "Unicode"

msgid "tuple"
msgstr "tupel"

msgid "singleton"
msgstr "singleton"

msgid "empty"
msgstr "tom"

msgid "bytes"
msgstr "byte"

msgid "byte"
msgstr "byte"

msgid "mutable sequence"
msgstr "muterbar sekvens"

msgid "mutable"
msgstr "föränderlig"

msgid "assignment"
msgstr "uppgift"

msgid "statement"
msgstr "uttalande"

msgid "array"
msgstr "array"

msgid "collections"
msgstr "samlingar"

msgid "list"
msgstr "lista"

msgid "bytearray"
msgstr "bytearray"

msgid "set type"
msgstr "inställd typ"

msgid "set"
msgstr "set"

msgid "frozenset"
msgstr "frozenset"

msgid "mapping"
msgstr "kartläggning"

msgid "dictionary"
msgstr "ordbok"

msgid "dbm.ndbm"
msgstr "dbm.ndbm"

msgid "dbm.gnu"
msgstr "dbm.gnu"

msgid "callable"
msgstr "anropsbar"

msgid "function"
msgstr "funktion"

msgid "call"
msgstr "ring upp"

msgid "invocation"
msgstr "påkallande"

msgid "argument"
msgstr "argument"

msgid "user-defined"
msgstr "användardefinierad"

msgid "user-defined function"
msgstr "användardefinierad funktion"

msgid "__closure__ (function attribute)"
msgstr "__closure__ (funktionsattribut)"

msgid "__globals__ (function attribute)"
msgstr "__globals__ (funktionsattribut)"

msgid "global"
msgstr "globala"

msgid "namespace"
msgstr "namnrymd"

msgid "__doc__ (function attribute)"
msgstr "__doc__ (funktionsattribut)"

msgid "__name__ (function attribute)"
msgstr "__name__ (funktionsattribut)"

msgid "__module__ (function attribute)"
msgstr "__module__ (funktionsattribut)"

msgid "__dict__ (function attribute)"
msgstr "__dict__ (funktionsattribut)"

msgid "__defaults__ (function attribute)"
msgstr "__defaults__ (funktion attribut)"

msgid "__code__ (function attribute)"
msgstr "__code__ (funktionsattribut)"

msgid "__annotations__ (function attribute)"
msgstr "__annotationer__ (funktion attribut)"

msgid "__annotate__ (function attribute)"
msgstr "__annotate__ (funktion attribut)"

msgid "__kwdefaults__ (function attribute)"
msgstr "__kwdefaults__ (funktionsattribut)"

msgid "__type_params__ (function attribute)"
msgstr "__type_params__ (funktionsattribut)"

msgid "method"
msgstr "metod"

msgid "user-defined method"
msgstr "användardefinierad metod"

msgid "__func__ (method attribute)"
msgstr "__func__ (metodattribut)"

msgid "__self__ (method attribute)"
msgstr "__self__ (metodattribut)"

msgid "__doc__ (method attribute)"
msgstr "__doc__ (metodattribut)"

msgid "__name__ (method attribute)"
msgstr "__name__ (metodattribut)"

msgid "__module__ (method attribute)"
msgstr "__module__ (metodattribut)"

msgid "generator"
msgstr "generator"

msgid "iterator"
msgstr "iterator"

msgid "coroutine"
msgstr "coroutine"

msgid "asynchronous generator"
msgstr "asynkron generator"

msgid "asynchronous iterator"
msgstr "asynkron iterator"

msgid "built-in method"
msgstr "inbyggd metod"

msgid "built-in"
msgstr "inbyggd"

msgid "import"
msgstr "importera"

msgid "__name__ (module attribute)"
msgstr "__name__ (attribut för modul)"

msgid "__spec__ (module attribute)"
msgstr "__spec__ (modulattribut)"

msgid "__package__ (module attribute)"
msgstr "__package__ (modulattribut)"

msgid "__loader__ (module attribute)"
msgstr "__loader__ (modulattribut)"

msgid "__path__ (module attribute)"
msgstr "__path__ (modulattribut)"

msgid "__file__ (module attribute)"
msgstr "__file__ (modulattribut)"

msgid "__cached__ (module attribute)"
msgstr "__cached__ (modulattribut)"

msgid "__doc__ (module attribute)"
msgstr "__doc__ (modulattribut)"

msgid "__annotations__ (module attribute)"
msgstr "__annotationer__ (modulattribut)"

msgid "__annotate__ (module attribute)"
msgstr "__annotate__ (modulattribut)"

msgid "__dict__ (module attribute)"
msgstr "__dict__ (modulattribut)"

msgid "class"
msgstr "klass"

msgid "class instance"
msgstr "klassinstans"

msgid "instance"
msgstr "instans"

msgid "class object"
msgstr "klassobjekt"

msgid "__name__ (class attribute)"
msgstr "__name__ (klassattribut)"

msgid "__module__ (class attribute)"
msgstr "__module__ (klassattribut)"

msgid "__dict__ (class attribute)"
msgstr "__dict__ (klassattribut)"

msgid "__bases__ (class attribute)"
msgstr "__bases__ (klassattribut)"

msgid "__doc__ (class attribute)"
msgstr "__doc__ (klassattribut)"

msgid "__annotations__ (class attribute)"
msgstr "__annotationer__ (klassattribut)"

msgid "__annotate__ (class attribute)"
msgstr "__annotate__ (klassattribut)"

msgid "__type_params__ (class attribute)"
msgstr "__type_params__ (klassattribut)"

msgid "__static_attributes__ (class attribute)"
msgstr "__static_attributes__ (klassattribut)"

msgid "__firstlineno__ (class attribute)"
msgstr "__firstlineno__ (klassattribut)"

msgid "__dict__ (instance attribute)"
msgstr "__dict__ (instansattribut)"

msgid "__class__ (instance attribute)"
msgstr "__class__ (instansattribut)"

msgid "open"
msgstr "öppen"

msgid "io"
msgstr "io"

msgid "popen() (in module os)"
msgstr "popen() (i modul os)"

msgid "makefile() (socket method)"
msgstr "makefile() (socket-metod)"

msgid "sys.stdin"
msgstr "sys.stdin"

msgid "sys.stdout"
msgstr "sys.stdout"

msgid "sys.stderr"
msgstr "sys.stderr"

msgid "stdio"
msgstr "stdio"

msgid "stdin (in module sys)"
msgstr "stdin (i modul sys)"

msgid "stdout (in module sys)"
msgstr "stdout (i modul sys)"

msgid "stderr (in module sys)"
msgstr "stderr (i modul sys)"

msgid "internal type"
msgstr "intern typ"

msgid "types, internal"
msgstr "typer, interna"

msgid "bytecode"
msgstr "bytekod"

msgid "code"
msgstr "kod"

msgid "code object"
msgstr "kodobjekt"

msgid "co_argcount (code object attribute)"
msgstr "co_argcount (kodobjektattribut)"

msgid "co_posonlyargcount (code object attribute)"
msgstr "co_posonlyargcount (kodobjektattribut)"

msgid "co_kwonlyargcount (code object attribute)"
msgstr "co_kwonlyargcount (kodobjektattribut)"

msgid "co_code (code object attribute)"
msgstr "co_code (attribut för kodobjekt)"

msgid "co_consts (code object attribute)"
msgstr "co_consts (attribut för kodobjekt)"

msgid "co_filename (code object attribute)"
msgstr "co_filename (kodobjektattribut)"

msgid "co_firstlineno (code object attribute)"
msgstr "co_firstlineno (kodobjektattribut)"

msgid "co_flags (code object attribute)"
msgstr "co_flags (attribut för kodobjekt)"

msgid "co_lnotab (code object attribute)"
msgstr "co_lnotab (attribut för kodobjekt)"

msgid "co_name (code object attribute)"
msgstr "co_name (kodobjektattribut)"

msgid "co_names (code object attribute)"
msgstr "co_names (kodobjektattribut)"

msgid "co_nlocals (code object attribute)"
msgstr "co_nlocals (kodobjektattribut)"

msgid "co_stacksize (code object attribute)"
msgstr "co_stacksize (kodobjektattribut)"

msgid "co_varnames (code object attribute)"
msgstr "co_varnames (kodobjektattribut)"

msgid "co_cellvars (code object attribute)"
msgstr "co_cellvars (kodobjektattribut)"

msgid "co_freevars (code object attribute)"
msgstr "co_freevars (kodobjektattribut)"

msgid "co_qualname (code object attribute)"
msgstr "co_qualname (kodobjektattribut)"

msgid "documentation string"
msgstr "dokumentationssträng"

msgid "frame"
msgstr "ram"

msgid "f_back (frame attribute)"
msgstr "f_back (ramattribut)"

msgid "f_code (frame attribute)"
msgstr "f_code (ramattribut)"

msgid "f_globals (frame attribute)"
msgstr "f_globals (ramattribut)"

msgid "f_locals (frame attribute)"
msgstr "f_locals (ramattribut)"

msgid "f_lasti (frame attribute)"
msgstr "f_lasti (ramattribut)"

msgid "f_builtins (frame attribute)"
msgstr "f_builtins (ramattribut)"

msgid "f_trace (frame attribute)"
msgstr "f_trace (ramattribut)"

msgid "f_trace_lines (frame attribute)"
msgstr "f_trace_lines (ramattribut)"

msgid "f_trace_opcodes (frame attribute)"
msgstr "f_trace_opcodes (ramattribut)"

msgid "f_lineno (frame attribute)"
msgstr "f_lineno (ramattribut)"

msgid "traceback"
msgstr "spårning"

msgid "stack"
msgstr "stack"

msgid "trace"
msgstr "spår"

msgid "exception"
msgstr "undantag"

msgid "handler"
msgstr "handläggare"

msgid "execution"
msgstr "avrättning"

msgid "exc_info (in module sys)"
msgstr "exc_info (i modul sys)"

msgid "last_traceback (in module sys)"
msgstr "last_traceback (i modul sys)"

msgid "sys.exc_info"
msgstr "sys.exc_info"

msgid "sys.exception"
msgstr "sys.undantag"

msgid "sys.last_traceback"
msgstr "sys.sista_traceback"

msgid "tb_frame (traceback attribute)"
msgstr "tb_frame (spårningsattribut)"

msgid "tb_lineno (traceback attribute)"
msgstr "tb_lineno (traceback-attribut)"

msgid "tb_lasti (traceback attribute)"
msgstr "tb_lasti (traceback-attribut)"

msgid "try"
msgstr "försök"

msgid "tb_next (traceback attribute)"
msgstr "tb_next (spårningsattribut)"

msgid "slice"
msgstr "skiva"

msgid "start (slice object attribute)"
msgstr "start (attribut för skivobjekt)"

msgid "stop (slice object attribute)"
msgstr "stopp (attribut för skivobjekt)"

msgid "step (slice object attribute)"
msgstr "steg (objektattribut för skiva)"

msgid "operator"
msgstr "operator"

msgid "overloading"
msgstr "överlastning"

msgid "__getitem__() (mapping object method)"
msgstr "__getitem__() (metod för mappningsobjekt)"

msgid "subclassing"
msgstr "underklassificering"

msgid "immutable types"
msgstr "oföränderliga typer"

msgid "constructor"
msgstr "konstruktör"

msgid "destructor"
msgstr "destruktor"

msgid "finalizer"
msgstr "slutbehandlare"

msgid "del"
msgstr "rad"

msgid "repr() (built-in function)"
msgstr "repr() (inbyggd funktion)"

msgid "__repr__() (object method)"
msgstr "__repr__() (objektmetod)"

msgid "__str__() (object method)"
msgstr "__str__() (objektmetod)"

msgid "format() (built-in function)"
msgstr "format() (inbyggd funktion)"

msgid "print() (built-in function)"
msgstr "print() (inbyggd funktion)"

msgid "__format__() (object method)"
msgstr "__format__() (objektmetod)"

msgid "conversion"
msgstr "omvandling"

msgid "print"
msgstr "skriv ut"

msgid "comparisons"
msgstr "jämförelser"

msgid "hash"
msgstr "hash"

msgid "__len__() (mapping object method)"
msgstr "__len__() (metod för mappningsobjekt)"

msgid "__getattr__ (module attribute)"
msgstr "__getattr__ (modulattribut)"

msgid "__dir__ (module attribute)"
msgstr "__dir__ (modulattribut)"

msgid "__class__ (module attribute)"
msgstr "__class__ (modulattribut)"

msgid "metaclass"
msgstr "metaklass"

msgid "= (equals)"
msgstr "= (lika med)"

msgid "class definition"
msgstr "klassdefinition"

msgid "metaclass hint"
msgstr "tips om metaklass"

msgid "__prepare__ (metaclass method)"
msgstr "__prepare__ (metaklassmetod)"

msgid "body"
msgstr "body"

msgid "__class__ (method cell)"
msgstr "__klass__ (metodcell)"

msgid "__classcell__ (class namespace entry)"
msgstr "__classcell__ (klassnamnsrymdsangivelse)"

msgid "__bool__() (object method)"
msgstr "__bool__() (objektmetod)"

msgid "divmod"
msgstr "divmod"

msgid "pow"
msgstr "kraft"

msgid "abs"
msgstr "abs"

msgid "int"
msgstr "int"

msgid "float"
msgstr "flyt"

msgid "round"
msgstr "avrundat"

msgid "with"
msgstr "med"

msgid "context manager"
msgstr "kontexthanterare"
