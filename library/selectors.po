# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!selectors` --- High-level I/O multiplexing"
msgstr ""

msgid "**Source code:** :source:`Lib/selectors.py`"
msgstr ""

msgid "Introduction"
msgstr ""

msgid ""
"This module allows high-level and efficient I/O multiplexing, built upon "
"the :mod:`select` module primitives. Users are encouraged to use this module "
"instead, unless they want precise control over the OS-level primitives used."
msgstr ""

msgid ""
"It defines a :class:`BaseSelector` abstract base class, along with several "
"concrete implementations (:class:`KqueueSelector`, :class:"
"`EpollSelector`...), that can be used to wait for I/O readiness notification "
"on multiple file objects. In the following, \"file object\" refers to any "
"object with a :meth:`~io.IOBase.fileno` method, or a raw file descriptor. "
"See :term:`file object`."
msgstr ""

msgid ""
":class:`DefaultSelector` is an alias to the most efficient implementation "
"available on the current platform: this should be the default choice for "
"most users."
msgstr ""

msgid ""
"The type of file objects supported depends on the platform: on Windows, "
"sockets are supported, but not pipes, whereas on Unix, both are supported "
"(some other types may be supported as well, such as fifos or special file "
"devices)."
msgstr ""

msgid ":mod:`select`"
msgstr ""

msgid "Low-level I/O multiplexing module."
msgstr ""

msgid "Availability"
msgstr ""

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""

msgid "Classes"
msgstr ""

msgid "Classes hierarchy::"
msgstr ""

msgid ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"
msgstr ""

msgid ""
"In the following, *events* is a bitwise mask indicating which I/O events "
"should be waited for on a given file object. It can be a combination of the "
"modules constants below:"
msgstr ""

msgid "Constant"
msgstr ""

msgid "Meaning"
msgstr ""

msgid "Available for read"
msgstr ""

msgid "Available for write"
msgstr ""

msgid ""
"A :class:`SelectorKey` is a :class:`~collections.namedtuple` used to "
"associate a file object to its underlying file descriptor, selected event "
"mask and attached data. It is returned by several :class:`BaseSelector` "
"methods."
msgstr ""

msgid "File object registered."
msgstr ""

msgid "Underlying file descriptor."
msgstr ""

msgid "Events that must be waited for on this file object."
msgstr ""

msgid ""
"Optional opaque data associated to this file object: for example, this could "
"be used to store a per-client session ID."
msgstr ""

msgid ""
"A :class:`BaseSelector` is used to wait for I/O event readiness on multiple "
"file objects. It supports file stream registration, unregistration, and a "
"method to wait for I/O events on those streams, with an optional timeout. "
"It's an abstract base class, so cannot be instantiated. Use :class:"
"`DefaultSelector` instead, or one of :class:`SelectSelector`, :class:"
"`KqueueSelector` etc. if you want to specifically use an implementation, and "
"your platform supports it. :class:`BaseSelector` and its concrete "
"implementations support the :term:`context manager` protocol."
msgstr ""

msgid "Register a file object for selection, monitoring it for I/O events."
msgstr ""

msgid ""
"*fileobj* is the file object to monitor.  It may either be an integer file "
"descriptor or an object with a ``fileno()`` method. *events* is a bitwise "
"mask of events to monitor. *data* is an opaque object."
msgstr ""

msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is already registered."
msgstr ""

msgid ""
"Unregister a file object from selection, removing it from monitoring. A file "
"object shall be unregistered prior to being closed."
msgstr ""

msgid "*fileobj* must be a file object previously registered."
msgstr ""

msgid ""
"This returns the associated :class:`SelectorKey` instance, or raises a :exc:"
"`KeyError` if *fileobj* is not registered.  It will raise :exc:`ValueError` "
"if *fileobj* is invalid (e.g. it has no ``fileno()`` method or its "
"``fileno()`` method has an invalid return value)."
msgstr ""

msgid "Change a registered file object's monitored events or attached data."
msgstr ""

msgid ""
"This is equivalent to ``BaseSelector.unregister(fileobj)`` followed by "
"``BaseSelector.register(fileobj, events, data)``, except that it can be "
"implemented more efficiently."
msgstr ""

msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is not registered."
msgstr ""

msgid ""
"Wait until some registered file objects become ready, or the timeout expires."
msgstr ""

msgid ""
"If ``timeout > 0``, this specifies the maximum wait time, in seconds. If "
"``timeout <= 0``, the call won't block, and will report the currently ready "
"file objects. If *timeout* is ``None``, the call will block until a "
"monitored file object becomes ready."
msgstr ""

msgid ""
"This returns a list of ``(key, events)`` tuples, one for each ready file "
"object."
msgstr ""

msgid ""
"*key* is the :class:`SelectorKey` instance corresponding to a ready file "
"object. *events* is a bitmask of events ready on this file object."
msgstr ""

msgid ""
"This method can return before any file object becomes ready or the timeout "
"has elapsed if the current process receives a signal: in this case, an empty "
"list will be returned."
msgstr ""

msgid ""
"The selector is now retried with a recomputed timeout when interrupted by a "
"signal if the signal handler did not raise an exception (see :pep:`475` for "
"the rationale), instead of returning an empty list of events before the "
"timeout."
msgstr ""

msgid "Close the selector."
msgstr ""

msgid ""
"This must be called to make sure that any underlying resource is freed. The "
"selector shall not be used once it has been closed."
msgstr ""

msgid "Return the key associated with a registered file object."
msgstr ""

msgid ""
"This returns the :class:`SelectorKey` instance associated to this file "
"object, or raises :exc:`KeyError` if the file object is not registered."
msgstr ""

msgid "Return a mapping of file objects to selector keys."
msgstr ""

msgid ""
"This returns a :class:`~collections.abc.Mapping` instance mapping registered "
"file objects to their associated :class:`SelectorKey` instance."
msgstr ""

msgid ""
"The default selector class, using the most efficient implementation "
"available on the current platform. This should be the default choice for "
"most users."
msgstr ""

msgid ":func:`select.select`-based selector."
msgstr ""

msgid ":func:`select.poll`-based selector."
msgstr ""

msgid ":func:`select.epoll`-based selector."
msgstr ""

msgid ""
"This returns the file descriptor used by the underlying :func:`select.epoll` "
"object."
msgstr ""

msgid ":func:`select.devpoll`-based selector."
msgstr ""

msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"devpoll` object."
msgstr ""

msgid ":func:`select.kqueue`-based selector."
msgstr ""

msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"kqueue` object."
msgstr ""

msgid "Examples"
msgstr ""

msgid "Here is a simple echo server implementation::"
msgstr ""

msgid ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
msgstr ""
