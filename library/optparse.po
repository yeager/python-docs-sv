# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!optparse` --- Parser for command line options"
msgstr ":mod:`!optparse` --- Parser för kommandoradsalternativ"

msgid "**Source code:** :source:`Lib/optparse.py`"
msgstr "**Källkod:** :source:`Lib/optparse.py`"

msgid "Choosing an argument parsing library"
msgstr "Att välja ett bibliotek för argumentparsning"

msgid "The standard library includes three argument parsing libraries:"
msgstr "Standardbiblioteket innehåller tre bibliotek för parsning av argument:"

msgid ""
":mod:`getopt`: a module that closely mirrors the procedural C ``getopt`` "
"API. Included in the standard library since before the initial Python 1.0 "
"release."
msgstr ""
":mod:`getopt`: en modul som nära speglar det procedurella C ``getopt`` API:"
"et. Ingår i standardbiblioteket sedan före den första Python 1.0-utgåvan."

msgid ""
":mod:`optparse`: a declarative replacement for ``getopt`` that provides "
"equivalent functionality without requiring each application to implement its "
"own procedural option parsing logic. Included in the standard library since "
"the Python 2.3 release."
msgstr ""
":mod:`optparse`: en deklarativ ersättning för ``getopt`` som ger likvärdig "
"funktionalitet utan att kräva att varje applikation implementerar sin egen "
"procedurella logik för att analysera alternativ. Ingår i standardbiblioteket "
"sedan Python 2.3."

msgid ""
":mod:`argparse`: a more opinionated alternative to ``optparse`` that "
"provides more functionality by default, at the expense of reduced "
"application flexibility in controlling exactly how arguments are processed. "
"Included in the standard library since the Python 2.7 and Python 3.2 "
"releases."
msgstr ""
":mod:`argparse`: ett mer självständigt alternativ till ``optparse`` som ger "
"mer funktionalitet som standard, på bekostnad av minskad flexibilitet för "
"applikationer att kontrollera exakt hur argument bearbetas. Ingår i "
"standardbiblioteket sedan Python 2.7 och Python 3.2."

msgid ""
"In the absence of more specific argument parsing design constraints, :mod:"
"`argparse` is the recommended choice for implementing command line "
"applications, as it offers the highest level of baseline functionality with "
"the least application level code."
msgstr ""
"I avsaknad av mer specifika designbegränsningar för argumentparsing är :mod:"
"`argparse` det rekommenderade valet för implementering av "
"kommandoradsapplikationer, eftersom det erbjuder den högsta nivån av "
"basfunktionalitet med minst kod på applikationsnivå."

msgid ""
":mod:`getopt` is retained almost entirely for backwards compatibility "
"reasons. However, it also serves a niche use case as a tool for prototyping "
"and testing command line argument handling in ``getopt``-based C "
"applications."
msgstr ""
":mod:`getopt` behålls nästan helt och hållet av bakåtkompatibilitetsskäl. "
"Den har dock också en nischad användning som ett verktyg för prototyper och "
"testning av kommandoradsargumenthantering i ``getopt``-baserade C-program."

msgid ""
":mod:`optparse` should be considered as an alternative to :mod:`argparse` in "
"the following cases:"
msgstr ""
":mod:`optparse` bör betraktas som ett alternativ till :mod:`argparse` i "
"följande fall:"

msgid ""
"an application is already using :mod:`optparse` and doesn't want to risk the "
"subtle behavioural changes that may arise when migrating to :mod:`argparse`"
msgstr ""
"ett program använder redan :mod:`optparse` och vill inte riskera de subtila "
"beteendeförändringar som kan uppstå när man migrerar till :mod:`argparse`"

msgid ""
"the application requires additional control over the way options and "
"positional parameters are interleaved on the command line (including the "
"ability to disable the interleaving feature completely)"
msgstr ""
"applikationen kräver ytterligare kontroll över hur alternativ och "
"positionsparametrar interfolieras på kommandoraden (inklusive möjligheten "
"att inaktivera interfolieringsfunktionen helt)"

msgid ""
"the application requires additional control over the incremental parsing of "
"command line elements (while ``argparse`` does support this, the exact way "
"it works in practice is undesirable for some use cases)"
msgstr ""
"applikationen kräver ytterligare kontroll över den stegvisa tolkningen av "
"kommandoradselement (även om ``argparse`` stöder detta, är det exakta sättet "
"det fungerar i praktiken inte önskvärt för vissa användningsfall)"

msgid ""
"the application requires additional control over the handling of options "
"which accept parameter values that may start with ``-`` (such as delegated "
"options to be passed to invoked subprocesses)"
msgstr ""
"programmet kräver ytterligare kontroll över hanteringen av alternativ som "
"accepterar parametervärden som kan börja med ``-`` (t.ex. delegerade "
"alternativ som ska skickas till anropade underprocesser)"

msgid ""
"the application requires some other command line parameter processing "
"behavior which ``argparse`` does not support, but which can be implemented "
"in terms of the lower level interface offered by ``optparse``"
msgstr ""
"programmet kräver något annat beteende för bearbetning av "
"kommandoradsparametrar som ``argparse`` inte stöder, men som kan "
"implementeras i form av det gränssnitt på lägre nivå som erbjuds av "
"``optparse``"

msgid ""
"These considerations also mean that :mod:`optparse` is likely to provide a "
"better foundation for library authors writing third party command line "
"argument processing libraries."
msgstr ""
"Dessa överväganden innebär också att :mod:`optparse` sannolikt kommer att ge "
"en bättre grund för biblioteksförfattare som skriver tredjeparts "
"kommandoradsargumentbehandlingsbibliotek."

msgid ""
"As a concrete example, consider the following two command line argument "
"parsing configurations, the first using ``optparse``, and the second using "
"``argparse``:"
msgstr ""
"Ett konkret exempel är följande två konfigurationer för analys av argument "
"på kommandoraden, där den första använder ``optparse`` och den andra "
"``argparse``:"

msgid ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"
msgstr ""
"import optparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = optparse.OptionParser()\n"
"    parser.add_option('-o', '--output')\n"
"    parser.add_option('-v', dest='verbose', action='store_true')\n"
"    opts, args = parser.parse_args()\n"
"    process(args, output=opts.output, verbose=opts.verbose)"

msgid ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"
msgstr ""
"import argparse\n"
"\n"
"if __name__ == '__main__':\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-o', '--output')\n"
"    parser.add_argument('-v', dest='verbose', action='store_true')\n"
"    parser.add_argument('rest', nargs='*')\n"
"    args = parser.parse_args()\n"
"    process(args.rest, output=args.output, verbose=args.verbose)"

msgid ""
"The most obvious difference is that in the ``optparse`` version, the non-"
"option arguments are processed separately by the application after the "
"option processing is complete. In the ``argparse`` version, positional "
"arguments are declared and processed in the same way as the named options."
msgstr ""
"Den mest uppenbara skillnaden är att i ``optparse``-versionen bearbetas "
"argumenten som inte är alternativ separat av programmet efter att "
"alternativbearbetningen är klar. I ``argparse``-versionen deklareras och "
"bearbetas positionella argument på samma sätt som de namngivna alternativen."

msgid ""
"However, the ``argparse`` version will also handle some parameter "
"combination differently from the way the ``optparse`` version would handle "
"them. For example (amongst other differences):"
msgstr ""
"Men ``argparse``-versionen kommer också att hantera vissa "
"parameterkombinationer på ett annat sätt än ``optparse``-versionen skulle "
"hantera dem. Till exempel (bland andra skillnader):"

msgid ""
"supplying ``-o -v`` gives ``output=\"-v\"`` and ``verbose=False`` when using "
"``optparse``, but a usage error with ``argparse`` (complaining that no value "
"has been supplied for ``-o/--output``, since ``-v`` is interpreted as "
"meaning the verbosity flag)"
msgstr ""
"att tillhandahålla ``-o -v`` ger ``output=\"-v\"`` och ``verbose=False`` när "
"du använder ``optparse``, men ett användningsfel med ``argparse`` (klagar på "
"att inget värde har tillhandahållits för ``-o/--output``, eftersom ``-v`` "
"tolkas som att betyda verbosity-flaggan)"

msgid ""
"similarly, supplying ``-o --`` gives ``output=\"--\"`` and ``args=()`` when "
"using ``optparse``, but a usage error with ``argparse`` (also complaining "
"that no value has been supplied for ``-o/--output``, since ``--`` is "
"interpreted as terminating the option processing and treating all remaining "
"values as positional arguments)"
msgstr ""
"på samma sätt ger ``-o --`` ``output=\"--\"`` och ``args=()`` när du "
"använder ``optparse``, men ett användningsfel med ``argparse`` (klagar också "
"på att inget värde har levererats för ``-o/--output``, eftersom ``--`` "
"tolkas som att avsluta alternativbehandlingen och behandla alla återstående "
"värden som positionella argument)"

msgid ""
"supplying ``-o=foo`` gives ``output=\"=foo\"`` when using ``optparse``, but "
"gives ``output=\"foo\"`` with ``argparse`` (since ``=`` is special cased as "
"an alternative separator for option parameter values)"
msgstr ""
"att leverera ``-o=foo`` ger ``output=\"=foo\"`` när man använder "
"``optparse``, men ger ``output=\"foo\"`` med ``argparse`` (eftersom ``=`` är "
"special cased som en alternativ separator för alternativparametervärden)"

msgid ""
"Whether these differing behaviors in the ``argparse`` version are considered "
"desirable or a problem will depend on the specific command line application "
"use case."
msgstr ""
"Huruvida dessa olika beteenden i ``argparse``-versionen anses vara önskvärda "
"eller ett problem beror på det specifika användningsfallet för "
"kommandoradsapplikationen."

msgid ""
":pypi:`click` is a third party argument processing library (originally based "
"on ``optparse``), which allows command line applications to be developed as "
"a set of decorated command implementation functions."
msgstr ""
":pypi:`click` är ett tredjepartsbibliotek för argumentbehandling "
"(ursprungligen baserat på ``optparse``), som gör det möjligt att utveckla "
"kommandoradsapplikationer som en uppsättning dekorerade funktioner för "
"implementering av kommandon."

msgid ""
"Other third party libraries, such as :pypi:`typer` or :pypi:`msgspec-click`, "
"allow command line interfaces to be specified in ways that more effectively "
"integrate with static checking of Python type annotations."
msgstr ""
"Andra tredjepartsbibliotek, som :pypi:`typer` eller :pypi:`msgspec-click`, "
"gör det möjligt att specificera kommandoradsgränssnitt på sätt som mer "
"effektivt integrerar med statisk kontroll av Python-typannoteringar."

msgid "Introduction"
msgstr "Introduktion"

msgid ""
":mod:`optparse` is a more convenient, flexible, and powerful library for "
"parsing command-line options than the minimalist :mod:`getopt` module. :mod:"
"`optparse` uses a more declarative style of command-line parsing: you create "
"an instance of :class:`OptionParser`, populate it with options, and parse "
"the command line. :mod:`optparse` allows users to specify options in the "
"conventional GNU/POSIX syntax, and additionally generates usage and help "
"messages for you."
msgstr ""
":mod:`optparse` är ett mer bekvämt, flexibelt och kraftfullt bibliotek för "
"att analysera kommandoradsalternativ än den minimalistiska modulen :mod:"
"`getopt`. :mod:`optparse` använder en mer deklarativ stil för "
"kommandoradsanalys: du skapar en instans av :class:`OptionParser`, fyller "
"den med alternativ och analyserar kommandoraden. :mod:`optparse` låter "
"användare ange alternativ i den konventionella GNU/POSIX-syntaxen och "
"genererar dessutom användnings- och hjälpmeddelanden åt dig."

msgid "Here's an example of using :mod:`optparse` in a simple script::"
msgstr ""
"Här är ett exempel på användning av :mod:`optparse` i ett enkelt skript::"

msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                  help=\"write report to FILE\", metavar=\"FILE\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,\n"
"                  help=\"don't print status messages to stdout\")\n"
"\n"
"(options, args) = parser.parse_args()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()\n"
"parser.add_option(\"-f\", \"--file\", dest=\"filnamn\",\n"
"                  help=\"skriv rapport till FILE\", metavar=\"FILE\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\", default=True,\n"
"                  help=\"skriv inte ut statusmeddelanden till stdout\")\n"
"\n"
"(alternativ, args) = parser.parse_args()"

msgid ""
"With these few lines of code, users of your script can now do the \"usual "
"thing\" on the command-line, for example::"
msgstr ""
"Med dessa få rader kod kan användare av ditt skript nu göra det \"vanliga\" "
"på kommandoraden, till exempel::"

msgid "<yourscript> --file=outfile -q"
msgstr "<yourscript> --file=outfile -q"

msgid ""
"As it parses the command line, :mod:`optparse` sets attributes of the "
"``options`` object returned by :meth:`~OptionParser.parse_args` based on "
"user-supplied command-line values.  When :meth:`~OptionParser.parse_args` "
"returns from parsing this command line, ``options.filename`` will be "
"``\"outfile\"`` and ``options.verbose`` will be ``False``.  :mod:`optparse` "
"supports both long and short options, allows short options to be merged "
"together, and allows options to be associated with their arguments in a "
"variety of ways.  Thus, the following command lines are all equivalent to "
"the above example::"
msgstr ""
"När den analyserar kommandoraden ställer :mod:`optparse` in attribut för "
"objektet ``options`` som returneras av :meth:`~OptionParser.parse_args` "
"baserat på de kommandoradsvärden som användaren angett.  När :meth:"
"`~OptionParser.parse_args` återkommer efter att ha analyserat den här "
"kommandoraden, kommer ``options.filename`` att vara ``\"outfile\"`` och "
"``options.verbose`` kommer att vara ``False``. :mod:`optparse` stöder både "
"långa och korta alternativ, tillåter att korta alternativ slås samman och "
"tillåter att alternativ associeras med sina argument på en mängd olika "
"sätt.  Följande kommandorader är således alla likvärdiga med ovanstående "
"exempel::"

msgid ""
"<yourscript> -f outfile --quiet\n"
"<yourscript> --quiet --file outfile\n"
"<yourscript> -q -foutfile\n"
"<yourscript> -qfoutfile"
msgstr ""
"<yourscript> -f utfil --tyst\n"
"<yourscript> --tyst --fil utfil\n"
"<yourscript> -q -foutfile\n"
"<yourscript> -qfoutfile"

msgid "Additionally, users can run one of the following ::"
msgstr "Dessutom kan användare köra en av följande ::"

msgid ""
"<yourscript> -h\n"
"<yourscript> --help"
msgstr ""
"<yourscript> -h\n"
"<yourscript> --hjälp"

msgid ""
"and :mod:`optparse` will print out a brief summary of your script's options:"
msgstr ""
"och :mod:`optparse` skriver ut en kort sammanfattning av skriptets "
"alternativ:"

msgid ""
"Usage: <yourscript> [options]\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -f FILE, --file=FILE  write report to FILE\n"
"  -q, --quiet           don't print status messages to stdout"
msgstr ""
"Användning: <yourscript> [alternativ]\n"
"\n"
"Alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -f FILE, --file=FILE skriva rapport till FILE\n"
"  -q, --quiet skriver inte ut statusmeddelanden till stdout"

msgid ""
"where the value of *yourscript* is determined at runtime (normally from "
"``sys.argv[0]``)."
msgstr ""
"där värdet på *yourscript* bestäms vid körning (normalt från ``sys."
"argv[0]``)."

msgid "Background"
msgstr "Bakgrund"

msgid ""
":mod:`optparse` was explicitly designed to encourage the creation of "
"programs with straightforward command-line interfaces that follow the "
"conventions established by the :c:func:`!getopt` family of functions "
"available to C developers. To that end, it supports only the most common "
"command-line syntax and semantics conventionally used under Unix.  If you "
"are unfamiliar with these conventions, reading this section will allow you "
"to acquaint yourself with them."
msgstr ""
":mod:`optparse` har uttryckligen utformats för att uppmuntra skapandet av "
"program med enkla kommandoradsgränssnitt som följer de konventioner som "
"etablerats av :c:func:`!getopt`-familjen av funktioner som är tillgängliga "
"för C-utvecklare. I detta syfte stöder programmet endast den vanligaste "
"kommandoradssyntaxen och semantiken som används under Unix.  Om du inte är "
"bekant med dessa konventioner kan du läsa detta avsnitt för att bekanta dig "
"med dem."

msgid "Terminology"
msgstr "Terminologi"

msgid "argument"
msgstr "argument"

msgid ""
"a string entered on the command-line, and passed by the shell to ``execl()`` "
"or ``execv()``.  In Python, arguments are elements of ``sys.argv[1:]`` "
"(``sys.argv[0]`` is the name of the program being executed).  Unix shells "
"also use the term \"word\"."
msgstr ""
"en sträng som anges på kommandoraden och som skickas av skalet till "
"``execl()`` eller ``execv()``.  I Python är argument element i ```sys."
"argv[1:]`` (```sys.argv[0]`` är namnet på det program som körs).  Unix-skal "
"använder också termen \"word\"."

msgid ""
"It is occasionally desirable to substitute an argument list other than ``sys."
"argv[1:]``, so you should read \"argument\" as \"an element of ``sys."
"argv[1:]``, or of some other list provided as a substitute for ``sys."
"argv[1:]``\"."
msgstr ""
"Det är ibland önskvärt att ersätta en annan argumentlista än ``sys."
"argv[1:]``, så du bör läsa \"argument\" som \"ett element i ``sys."
"argv[1:]``, eller i någon annan lista som tillhandahålls som ett substitut "
"för ``sys.argv[1:]``\"."

msgid "option"
msgstr "alternativ"

msgid ""
"an argument used to supply extra information to guide or customize the "
"execution of a program.  There are many different syntaxes for options; the "
"traditional Unix syntax is a hyphen (\"-\") followed by a single letter, e."
"g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows multiple options "
"to be merged into a single argument, e.g. ``-x -F`` is equivalent to ``-"
"xF``.  The GNU project introduced ``--`` followed by a series of hyphen-"
"separated words, e.g. ``--file`` or ``--dry-run``.  These are the only two "
"option syntaxes provided by :mod:`optparse`."
msgstr ""
"ett argument som används för att ge extra information för att styra eller "
"anpassa körningen av ett program.  Det finns många olika syntaxer för "
"alternativ; den traditionella Unix-syntaxen är ett bindestreck (\"-\") följt "
"av en enda bokstav, t.ex. ``-x`` eller ``-F``.  Den traditionella Unix-"
"syntaxen tillåter också att flera alternativ slås samman till ett enda "
"argument, t.ex. ``-x -F`` är likvärdigt med ``-xF``.  GNU-projektet "
"introducerade ``--`` följt av en serie bindestrecksseparerade ord, t.ex. ``--"
"file`` eller ``--dry-run``.  Detta är de enda två syntaxerna för alternativ "
"som tillhandahålls av :mod:`optparse`."

msgid "Some other option syntaxes that the world has seen include:"
msgstr "Några andra syntaxer för alternativ som världen har sett inkluderar:"

msgid ""
"a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same as "
"multiple options merged into a single argument)"
msgstr ""
"ett bindestreck följt av några bokstäver, t.ex. ``-pf`` (detta är *inte* "
"samma sak som flera alternativ som slås samman till ett enda argument)"

msgid ""
"a hyphen followed by a whole word, e.g. ``-file`` (this is technically "
"equivalent to the previous syntax, but they aren't usually seen in the same "
"program)"
msgstr ""
"ett bindestreck följt av ett helt ord, t.ex. ``-fil`` (detta är tekniskt "
"sett likvärdigt med föregående syntax, men de förekommer vanligtvis inte i "
"samma program)"

msgid ""
"a plus sign followed by a single letter, or a few letters, or a word, e.g. "
"``+f``, ``+rgb``"
msgstr ""
"ett plustecken följt av en eller flera bokstäver eller ett ord, t.ex. "
"``+f``, ``+rgb``"

msgid ""
"a slash followed by a letter, or a few letters, or a word, e.g. ``/f``, ``/"
"file``"
msgstr ""
"ett snedstreck följt av en bokstav, några bokstäver eller ett ord, t.ex. ``/"
"f``, ``/file``"

msgid ""
"These option syntaxes are not supported by :mod:`optparse`, and they never "
"will be.  This is deliberate: the first three are non-standard on any "
"environment, and the last only makes sense if you're exclusively targeting "
"Windows or certain legacy platforms (e.g. VMS, MS-DOS)."
msgstr ""
"Dessa alternativsyntaxer stöds inte av :mod:`optparse`, och kommer aldrig "
"att göra det.  Detta är avsiktligt: de tre första är inte standard i någon "
"miljö, och det sista är bara meningsfullt om du uteslutande riktar dig till "
"Windows eller vissa äldre plattformar (t.ex. VMS, MS-DOS)."

msgid "option argument"
msgstr "alternativ argument"

msgid ""
"an argument that follows an option, is closely associated with that option, "
"and is consumed from the argument list when that option is. With :mod:"
"`optparse`, option arguments may either be in a separate argument from their "
"option:"
msgstr ""
"ett argument som följer ett alternativ, är nära förknippat med det "
"alternativet och konsumeras från argumentlistan när det alternativet är. "
"Med :mod:`optparse` kan alternativargument antingen vara i ett separat "
"argument från sitt alternativ:"

msgid ""
"-f foo\n"
"--file foo"
msgstr ""
"-f foo\n"
"--fil foo"

msgid "or included in the same argument:"
msgstr "eller ingår i samma argument:"

msgid ""
"-ffoo\n"
"--file=foo"
msgstr ""
"-ffoo\n"
"--fil=foo"

msgid ""
"Typically, a given option either takes an argument or it doesn't. Lots of "
"people want an \"optional option arguments\" feature, meaning that some "
"options will take an argument if they see it, and won't if they don't.  This "
"is somewhat controversial, because it makes parsing ambiguous: if ``-a`` "
"takes an optional argument and ``-b`` is another option entirely, how do we "
"interpret ``-ab``?  Because of this ambiguity, :mod:`optparse` does not "
"support this feature."
msgstr ""
"Vanligtvis tar ett givet alternativ antingen ett argument eller så gör det "
"inte det. Många människor vill ha en funktion för \"valfria "
"alternativargument\", vilket innebär att vissa alternativ tar ett argument "
"om de ser det, och inte om de inte gör det.  Detta är något kontroversiellt, "
"eftersom det gör parsing tvetydigt: om ``-a`` tar ett valfritt argument och "
"``-b`` är ett helt annat alternativ, hur tolkar vi ``-ab``?  På grund av "
"denna tvetydighet har :mod:`optparse` inte stöd för denna funktion."

msgid "positional argument"
msgstr "positionsargument"

msgid ""
"something leftover in the argument list after options have been parsed, i.e. "
"after options and their arguments have been parsed and removed from the "
"argument list."
msgstr ""
"något som finns kvar i argumentlistan efter att alternativen har "
"analyserats, dvs. efter att alternativen och deras argument har analyserats "
"och tagits bort från argumentlistan."

msgid "required option"
msgstr "önskat alternativ"

msgid ""
"an option that must be supplied on the command-line; note that the phrase "
"\"required option\" is self-contradictory in English.  :mod:`optparse` "
"doesn't prevent you from implementing required options, but doesn't give you "
"much help at it either."
msgstr ""
"ett alternativ som måste anges på kommandoraden; observera att frasen "
"\"required option\" är självmotsägande på engelska. :mod:`optparse` hindrar "
"dig inte från att implementera nödvändiga alternativ, men ger dig inte "
"mycket hjälp med det heller."

msgid "For example, consider this hypothetical command-line::"
msgstr "Tänk till exempel på denna hypotetiska kommandorad::"

msgid "prog -v --report report.txt foo bar"
msgstr "prog -v --rapport rapport.txt foo bar"

msgid ""
"``-v`` and ``--report`` are both options.  Assuming that ``--report`` takes "
"one argument, ``report.txt`` is an option argument.  ``foo`` and ``bar`` are "
"positional arguments."
msgstr ""
"``-v`` och ``--report`` är båda alternativ.  Om man antar att ``--report`` "
"tar ett argument, är ``report.txt`` ett alternativargument.  ``foo`` och "
"``bar`` är positionella argument."

msgid "What are options for?"
msgstr "Vad är alternativ till för?"

msgid ""
"Options are used to provide extra information to tune or customize the "
"execution of a program.  In case it wasn't clear, options are usually "
"*optional*.  A program should be able to run just fine with no options "
"whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can it "
"run without any options at all and still make sense?  The main exceptions "
"are ``find``, ``tar``, and ``dd``\\ ---all of which are mutant oddballs that "
"have been rightly criticized for their non-standard syntax and confusing "
"interfaces.)"
msgstr ""
"Alternativ används för att ge extra information för att ställa in eller "
"anpassa körningen av ett program.  Om det inte framgick tydligt är optioner "
"vanligtvis *optionella*.  Ett program ska kunna köras alldeles utmärkt utan "
"några som helst alternativ.  (Välj ett slumpmässigt program från Unix- eller "
"GNU-verktygsuppsättningarna.  Kan det köras utan några alternativ alls och "
"fortfarande vara vettigt?  De viktigaste undantagen är ``find``, ``tar`` och "
"``dd``, som alla är muterade udda program som med rätta har kritiserats för "
"sin icke-standardiserade syntax och förvirrande gränssnitt)"

msgid ""
"Lots of people want their programs to have \"required options\".  Think "
"about it. If it's required, then it's *not optional*!  If there is a piece "
"of information that your program absolutely requires in order to run "
"successfully, that's what positional arguments are for."
msgstr ""
"Många människor vill att deras program ska ha \"obligatoriska alternativ\".  "
"Tänk på det. Om det är obligatoriskt, då är det *inte valfritt*!  Om det "
"finns någon information som ditt program absolut behöver för att kunna köras "
"framgångsrikt, så är det vad positionsargument är till för."

msgid ""
"As an example of good command-line interface design, consider the humble "
"``cp`` utility, for copying files.  It doesn't make much sense to try to "
"copy files without supplying a destination and at least one source. Hence, "
"``cp`` fails if you run it with no arguments.  However, it has a flexible, "
"useful syntax that does not require any options at all::"
msgstr ""
"Som ett exempel på god design av kommandoradsgränssnitt kan man ta det enkla "
"verktyget ``cp`` för kopiering av filer.  Det är inte särskilt meningsfullt "
"att försöka kopiera filer utan att ange en destination och minst en källa. "
"Därför misslyckas ``cp`` om du kör det utan argument.  Det har dock en "
"flexibel och användbar syntax som inte kräver några alternativ alls::"

msgid ""
"cp SOURCE DEST\n"
"cp SOURCE ... DEST-DIR"
msgstr ""
"cp SOURCE DEST\n"
"cp SOURCE ... DEST-DIR"

msgid ""
"You can get pretty far with just that.  Most ``cp`` implementations provide "
"a bunch of options to tweak exactly how the files are copied: you can "
"preserve mode and modification time, avoid following symlinks, ask before "
"clobbering existing files, etc.  But none of this distracts from the core "
"mission of ``cp``, which is to copy either one file to another, or several "
"files to another directory."
msgstr ""
"Du kan komma ganska långt med bara det.  De flesta ``cp``-implementationer "
"ger en massa alternativ för att justera exakt hur filerna kopieras: du kan "
"bevara läge och modifieringstid, undvika att följa symlinks, fråga innan du "
"kopierar befintliga filer, etc.  Men inget av detta distraherar från "
"kärnuppdraget för ``cp``, vilket är att kopiera antingen en fil till en "
"annan eller flera filer till en annan katalog."

msgid "What are positional arguments for?"
msgstr "Vad är positionsargument för?"

msgid ""
"Positional arguments are for those pieces of information that your program "
"absolutely, positively requires to run."
msgstr ""
"Positionsargument är till för de delar av informationen som ditt program "
"absolut, absolut måste ha för att kunna köras."

msgid ""
"A good user interface should have as few absolute requirements as possible.  "
"If your program requires 17 distinct pieces of information in order to run "
"successfully, it doesn't much matter *how* you get that information from the "
"user---most people will give up and walk away before they successfully run "
"the program.  This applies whether the user interface is a command-line, a "
"configuration file, or a GUI: if you make that many demands on your users, "
"most of them will simply give up."
msgstr ""
"Ett bra användargränssnitt bör ha så få absoluta krav som möjligt.  Om ditt "
"program kräver 17 olika informationsbitar för att kunna köras framgångsrikt "
"spelar det ingen större roll *hur* du får den informationen från användaren "
"- de flesta kommer att ge upp och gå därifrån innan de lyckas köra "
"programmet.  Detta gäller oavsett om användargränssnittet är en kommandorad, "
"en konfigurationsfil eller ett GUI: om du ställer så många krav på dina "
"användare kommer de flesta av dem helt enkelt att ge upp."

msgid ""
"In short, try to minimize the amount of information that users are "
"absolutely required to supply---use sensible defaults whenever possible.  Of "
"course, you also want to make your programs reasonably flexible.  That's "
"what options are for.  Again, it doesn't matter if they are entries in a "
"config file, widgets in the \"Preferences\" dialog of a GUI, or command-line "
"options---the more options you implement, the more flexible your program is, "
"and the more complicated its implementation becomes.  Too much flexibility "
"has drawbacks as well, of course; too many options can overwhelm users and "
"make your code much harder to maintain."
msgstr ""
"Kort sagt, försök att minimera den mängd information som användarna absolut "
"måste tillhandahålla - använd förnuftiga standardvärden när det är möjligt.  "
"Naturligtvis vill du också göra dina program rimligt flexibla.  Det är vad "
"alternativ är till för.  Återigen, det spelar ingen roll om de är poster i "
"en konfigurationsfil, widgets i dialogrutan \"Preferences\" i ett GUI eller "
"kommandoradsalternativ - ju fler alternativ du implementerar, desto mer "
"flexibelt är ditt program och desto mer komplicerat blir dess "
"implementering.  För mycket flexibilitet har naturligtvis också nackdelar; "
"för många alternativ kan göra användarna överväldigade och göra din kod "
"mycket svårare att underhålla."

msgid "Tutorial"
msgstr "Handledning"

msgid ""
"While :mod:`optparse` is quite flexible and powerful, it's also "
"straightforward to use in most cases.  This section covers the code patterns "
"that are common to any :mod:`optparse`\\ -based program."
msgstr ""
"Även om :mod:`optparse` är ganska flexibelt och kraftfullt är det också "
"enkelt att använda i de flesta fall.  I det här avsnittet beskrivs de "
"kodmönster som är vanliga i alla :mod:`optparse`-baserade program."

msgid ""
"First, you need to import the OptionParser class; then, early in the main "
"program, create an OptionParser instance::"
msgstr ""
"Först måste du importera OptionParser-klassen; sedan, tidigt i "
"huvudprogrammet, skapar du en OptionParser-instans::"

msgid ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"parser = OptionParser()"

msgid "Then you can start defining options.  The basic syntax is::"
msgstr ""
"Sedan kan du börja definiera alternativ.  Den grundläggande syntaxen är::"

msgid ""
"parser.add_option(opt_str, ...,\n"
"                  attr=value, ...)"
msgstr ""
"parser.add_option(opt_str, ...,\n"
"                  attr=värde, ...)"

msgid ""
"Each option has one or more option strings, such as ``-f`` or ``--file``, "
"and several option attributes that tell :mod:`optparse` what to expect and "
"what to do when it encounters that option on the command line."
msgstr ""
"Varje alternativ har en eller flera alternativsträngar, t.ex. ``-f`` eller "
"``--file``, och flera alternativattribut som talar om för :mod:`optparse` "
"vad den kan förvänta sig och vad den ska göra när den stöter på alternativet "
"på kommandoraden."

msgid ""
"Typically, each option will have one short option string and one long option "
"string, e.g.::"
msgstr ""
"Vanligtvis har varje alternativ en kort alternativsträng och en lång "
"alternativsträng, t.ex.::"

msgid "parser.add_option(\"-f\", \"--file\", ...)"
msgstr "parser.add_option(\"-f\", \"--file\", ...)"

msgid ""
"You're free to define as many short option strings and as many long option "
"strings as you like (including zero), as long as there is at least one "
"option string overall."
msgstr ""
"Det står dig fritt att definiera så många korta alternativsträngar och så "
"många långa alternativsträngar som du vill (inklusive noll), så länge det "
"finns minst en alternativsträng totalt sett."

msgid ""
"The option strings passed to :meth:`OptionParser.add_option` are effectively "
"labels for the option defined by that call.  For brevity, we will frequently "
"refer to *encountering an option* on the command line; in reality, :mod:"
"`optparse` encounters *option strings* and looks up options from them."
msgstr ""
"Alternativsträngarna som skickas till :meth:`OptionParser.add_option` är i "
"själva verket etiketter för det alternativ som definieras av det anropet.  "
"För korthetens skull kommer vi ofta att hänvisa till att *möta ett "
"alternativ* på kommandoraden; i verkligheten möter :mod:`optparse` "
"*alternativsträngar* och letar upp alternativ från dem."

msgid ""
"Once all of your options are defined, instruct :mod:`optparse` to parse your "
"program's command line::"
msgstr ""
"När alla dina alternativ har definierats, instruerar du :mod:`optparse` att "
"analysera ditt programs kommandorad::"

msgid "(options, args) = parser.parse_args()"
msgstr "(alternativ, args) = parser.parse_args()"

msgid ""
"(If you like, you can pass a custom argument list to :meth:`~OptionParser."
"parse_args`, but that's rarely necessary: by default it uses ``sys."
"argv[1:]``.)"
msgstr ""
"(Om du vill kan du skicka en anpassad argumentlista till :meth:"
"`~OptionParser.parse_args`, men det är sällan nödvändigt: som standard "
"använder den ``sys.argv[1:]``)"

msgid ":meth:`~OptionParser.parse_args` returns two values:"
msgstr ":meth:`~OptionParser.parse_args` returnerar två värden:"

msgid ""
"``options``, an object containing values for all of your options---e.g. if "
"``--file`` takes a single string argument, then ``options.file`` will be the "
"filename supplied by the user, or ``None`` if the user did not supply that "
"option"
msgstr ""
"``options``, ett objekt som innehåller värden för alla dina alternativ - t."
"ex. om ``--file`` tar ett enda strängargument, kommer ``options.file`` att "
"vara det filnamn som användaren angav, eller ``None`` om användaren inte "
"angav det alternativet"

msgid ""
"``args``, the list of positional arguments leftover after parsing options"
msgstr ""
"``args``, listan över positionella argument som återstår efter parsning av "
"alternativ"

msgid ""
"This tutorial section only covers the four most important option "
"attributes: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destination), and :attr:`~Option.help`. Of these, :attr:`~Option."
"action` is the most fundamental."
msgstr ""
"I detta avsnitt behandlas endast de fyra viktigaste attributen för "
"alternativ: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destination) och :attr:`~Option.help`. Av dessa är :attr:`~Option."
"action` den mest grundläggande."

msgid "Understanding option actions"
msgstr "Förståelse av alternativåtgärder"

msgid ""
"Actions tell :mod:`optparse` what to do when it encounters an option on the "
"command line.  There is a fixed set of actions hard-coded into :mod:"
"`optparse`; adding new actions is an advanced topic covered in section :ref:"
"`optparse-extending-optparse`.  Most actions tell :mod:`optparse` to store a "
"value in some variable---for example, take a string from the command line "
"and store it in an attribute of ``options``."
msgstr ""
"Åtgärder talar om för :mod:`optparse` vad den ska göra när den stöter på ett "
"alternativ på kommandoraden.  Det finns en fast uppsättning åtgärder "
"hårdkodade i :mod:`optparse`; att lägga till nya åtgärder är ett avancerat "
"ämne som behandlas i avsnittet :ref:`optparse-extending-optparse`.  De "
"flesta åtgärder säger åt :mod:`optparse` att lagra ett värde i någon "
"variabel - till exempel att ta en sträng från kommandoraden och lagra den i "
"ett attribut i ``options``."

msgid ""
"If you don't specify an option action, :mod:`optparse` defaults to ``store``."
msgstr ""
"Om du inte anger någon alternativåtgärd är standardvärdet för :mod:"
"`optparse` ``store``."

msgid "The store action"
msgstr "Åtgärder i butiken"

msgid ""
"The most common option action is ``store``, which tells :mod:`optparse` to "
"take the next argument (or the remainder of the current argument), ensure "
"that it is of the correct type, and store it to your chosen destination."
msgstr ""
"Det vanligaste alternativet är ``store``, som säger till :mod:`optparse` att "
"ta nästa argument (eller resten av det aktuella argumentet), se till att det "
"är av rätt typ och lagra det på önskad plats."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"store\", type=\"string\", dest=\"filename\")"
msgstr ""
"parser.add_option(\"-f\", \"--file\",\n"
"                  action=\"lagra\", type=\"sträng\", dest=\"filnamn\")"

msgid ""
"Now let's make up a fake command line and ask :mod:`optparse` to parse it::"
msgstr ""
"Låt oss nu skapa en falsk kommandorad och be :mod:`optparse` att tolka den::"

msgid ""
"args = [\"-f\", \"foo.txt\"]\n"
"(options, args) = parser.parse_args(args)"
msgstr ""
"args = [\"-f\", \"foo.txt\"]\n"
"(alternativ, args) = parser.parse_args(args)"

msgid ""
"When :mod:`optparse` sees the option string ``-f``, it consumes the next "
"argument, ``foo.txt``, and stores it in ``options.filename``.  So, after "
"this call to :meth:`~OptionParser.parse_args`, ``options.filename`` is "
"``\"foo.txt\"``."
msgstr ""
"När :mod:`optparse` ser alternativsträngen ``-f`` tar den nästa argument, "
"``foo.txt``, och lagrar det i ``options.filename``.  Så efter detta anrop "
"till :meth:`~OptionParser.parse_args` är ``options.filename`` ``\"foo."
"txt\"``."

msgid ""
"Some other option types supported by :mod:`optparse` are ``int`` and "
"``float``. Here's an option that expects an integer argument::"
msgstr ""
"Några andra alternativtyper som stöds av :mod:`optparse` är ``int`` och "
"``float``. Här är ett alternativ som förväntar sig ett heltalsargument::"

msgid "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"
msgstr "parser.add_option(\"-n\", type=\"int\", dest=\"num\")"

msgid ""
"Note that this option has no long option string, which is perfectly "
"acceptable. Also, there's no explicit action, since the default is ``store``."
msgstr ""
"Observera att det här alternativet inte har någon lång alternativsträng, "
"vilket är helt acceptabelt. Det finns inte heller någon explicit åtgärd, "
"eftersom standardvärdet är ``store``."

msgid ""
"Let's parse another fake command-line.  This time, we'll jam the option "
"argument right up against the option: since ``-n42`` (one argument) is "
"equivalent to ``-n 42`` (two arguments), the code ::"
msgstr ""
"Låt oss analysera en annan falsk kommandorad.  Den här gången ställer vi "
"alternativargumentet rakt upp mot alternativet: eftersom ``-n42`` (ett "
"argument) är likvärdigt med ``-n 42`` (två argument), blir koden ::"

msgid ""
"(options, args) = parser.parse_args([\"-n42\"])\n"
"print(options.num)"
msgstr ""
"(alternativ, args) = parser.parse_args([\"-n42\"])\n"
"print(alternativ.nummer)"

msgid "will print ``42``."
msgstr "kommer att skriva ut ``42``."

msgid ""
"If you don't specify a type, :mod:`optparse` assumes ``string``.  Combined "
"with the fact that the default action is ``store``, that means our first "
"example can be a lot shorter::"
msgstr ""
"Om du inte anger någon typ antar :mod:`optparse` ``string``.  Kombinerat med "
"det faktum att standardåtgärden är ``store``, betyder det att vårt första "
"exempel kan vara mycket kortare::"

msgid "parser.add_option(\"-f\", \"--file\", dest=\"filename\")"
msgstr "parser.add_option(\"-f\", \"--file\", dest=\"filnamn\")"

msgid ""
"If you don't supply a destination, :mod:`optparse` figures out a sensible "
"default from the option strings: if the first long option string is ``--foo-"
"bar``, then the default destination is ``foo_bar``.  If there are no long "
"option strings, :mod:`optparse` looks at the first short option string: the "
"default destination for ``-f`` is ``f``."
msgstr ""
"Om du inte anger någon destination räknar :mod:`optparse` ut en vettig "
"standard från alternativsträngarna: om den första långa alternativsträngen "
"är ``--foo-bar`` är standarddestinationen ``foo_bar``.  Om det inte finns "
"några långa alternativsträngar tittar :mod:`optparse` på den första korta "
"alternativsträngen: standarddestinationen för ``-f`` är ``f``."

msgid ""
":mod:`optparse` also includes the built-in ``complex`` type.  Adding types "
"is covered in section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` innehåller också den inbyggda typen ``complex``.  Att lägga "
"till typer behandlas i avsnitt :ref:`optparse-extending-optparse`."

msgid "Handling boolean (flag) options"
msgstr "Hantering av booleska (flagga) alternativ"

msgid ""
"Flag options---set a variable to true or false when a particular option is "
"seen---are quite common.  :mod:`optparse` supports them with two separate "
"actions, ``store_true`` and ``store_false``.  For example, you might have a "
"``verbose`` flag that is turned on with ``-v`` and off with ``-q``::"
msgstr ""
"Flaggalternativ - ställ in en variabel till sant eller falskt när ett visst "
"alternativ visas - är ganska vanliga. :mod:`optparse` stöder dem med två "
"separata åtgärder, ``store_true`` och ``store_false``.  Du kan till exempel "
"ha en ``verbose``-flagga som slås på med ``-v`` och av med ``-q``::"

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"

msgid ""
"Here we have two different options with the same destination, which is "
"perfectly OK.  (It just means you have to be a bit careful when setting "
"default values---see below.)"
msgstr ""
"Här har vi två olika alternativ med samma destination, vilket är helt OK.  "
"(Det betyder bara att du måste vara lite försiktig när du ställer in "
"standardvärden - se nedan)"

msgid ""
"When :mod:`optparse` encounters ``-v`` on the command line, it sets "
"``options.verbose`` to ``True``; when it encounters ``-q``, ``options."
"verbose`` is set to ``False``."
msgstr ""
"När :mod:`optparse` stöter på ``-v`` på kommandoraden sätts ``options."
"verbose`` till ``True``; när den stöter på ``-q`` sätts ``options.verbose`` "
"till ``False``."

msgid "Other actions"
msgstr "Övriga handlingar"

msgid "Some other actions supported by :mod:`optparse` are:"
msgstr "Några andra åtgärder som stöds av :mod:`optparse` är:"

msgid "``\"store_const\"``"
msgstr "``\"store_const\"```"

msgid "store a constant value, pre-set via :attr:`Option.const`"
msgstr "lagra ett konstant värde, förinställt via :attr:`Option.const`"

msgid "``\"append\"``"
msgstr "``\"append\"``"

msgid "append this option's argument to a list"
msgstr "lägg till argumentet för detta alternativ till en lista"

msgid "``\"count\"``"
msgstr "``\"räkna\"``"

msgid "increment a counter by one"
msgstr "öka en räknare med ett steg"

msgid "``\"callback\"``"
msgstr "``\"callback\"``"

msgid "call a specified function"
msgstr "anropa en angiven funktion"

msgid ""
"These are covered in section :ref:`optparse-reference-guide`, and section :"
"ref:`optparse-option-callbacks`."
msgstr ""
"Dessa behandlas i avsnitt :ref:`optparse-reference-guide` och avsnitt :ref:"
"`optparse-option-callbacks`."

msgid "Default values"
msgstr "Standardvärden"

msgid ""
"All of the above examples involve setting some variable (the "
"\"destination\") when certain command-line options are seen.  What happens "
"if those options are never seen?  Since we didn't supply any defaults, they "
"are all set to ``None``.  This is usually fine, but sometimes you want more "
"control.  :mod:`optparse` lets you supply a default value for each "
"destination, which is assigned before the command line is parsed."
msgstr ""
"Alla exemplen ovan innebär att en variabel (destinationen) ställs in när "
"vissa kommandoradsalternativ visas.  Vad händer om dessa alternativ aldrig "
"visas?  Eftersom vi inte har angett några standardvärden sätts de alla till "
"``None``.  Detta är vanligtvis bra, men ibland vill du ha mer kontroll. :mod:"
"`optparse` låter dig ange ett standardvärde för varje destination, som "
"tilldelas innan kommandoraden analyseras."

msgid ""
"First, consider the verbose/quiet example.  If we want :mod:`optparse` to "
"set ``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::"
msgstr ""
"Ta först exemplet med verbose/quiet.  Om vi vill att :mod:`optparse` ska "
"sätta ``verbose`` till ``True`` om inte ``-q`` ses, så kan vi göra så här::"

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=True)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\")"

msgid ""
"Since default values apply to the *destination* rather than to any "
"particular option, and these two options happen to have the same "
"destination, this is exactly equivalent::"
msgstr ""
"Eftersom standardvärden gäller för *destinationen* snarare än för något "
"särskilt alternativ, och dessa två alternativ råkar ha samma destination, är "
"detta exakt likvärdigt::"

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\")\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"

msgid "Consider this::"
msgstr "Tänk på detta::"

msgid ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"
msgstr ""
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\", "
"default=False)\n"
"parser.add_option(\"-q\", action=\"store_false\", dest=\"verbose\", "
"default=True)"

msgid ""
"Again, the default value for ``verbose`` will be ``True``: the last default "
"value supplied for any particular destination is the one that counts."
msgstr ""
"Återigen kommer standardvärdet för ``verbose`` att vara ``True``: det sista "
"standardvärdet som anges för en viss destination är det som räknas."

msgid ""
"A clearer way to specify default values is the :meth:`set_defaults` method "
"of OptionParser, which you can call at any time before calling :meth:"
"`~OptionParser.parse_args`::"
msgstr ""
"Ett tydligare sätt att ange standardvärden är metoden :meth:`set_defaults` i "
"OptionParser, som du kan anropa när som helst innan du anropar :meth:"
"`~OptionParser.parse_args`::"

msgid ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(options, args) = parser.parse_args()"
msgstr ""
"parser.set_defaults(verbose=True)\n"
"parser.add_option(...)\n"
"(alternativ, args) = parser.parse_args()"

msgid ""
"As before, the last value specified for a given option destination is the "
"one that counts.  For clarity, try to use one method or the other of setting "
"default values, not both."
msgstr ""
"Som tidigare gäller att det är det sista värdet som anges för en given "
"alternativdestination som räknas.  För tydlighetens skull bör du försöka "
"använda den ena eller den andra metoden för att ange standardvärden, inte "
"båda."

msgid "Generating help"
msgstr "Generera hjälp"

msgid ""
":mod:`optparse`'s ability to generate help and usage text automatically is "
"useful for creating user-friendly command-line interfaces.  All you have to "
"do is supply a :attr:`~Option.help` value for each option, and optionally a "
"short usage message for your whole program.  Here's an OptionParser "
"populated with user-friendly (documented) options::"
msgstr ""
":mod:`optparse`:s förmåga att automatiskt generera hjälp- och "
"användningstext är användbar för att skapa användarvänliga "
"kommandoradsgränssnitt.  Allt du behöver göra är att ange ett :attr:`~Option."
"help`-värde för varje alternativ, och eventuellt ett kort "
"användningsmeddelande för hela ditt program.  Här är en OptionParser som är "
"fylld med användarvänliga (dokumenterade) alternativ::"

msgid ""
"usage = \"usage: %prog [options] arg1 arg2\"\n"
"parser = OptionParser(usage=usage)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"make lots of noise [default]\")\n"
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"be vewwy quiet (I'm hunting wabbits)\")\n"
"parser.add_option(\"-f\", \"--filename\",\n"
"                  metavar=\"FILE\", help=\"write output to FILE\")\n"
"parser.add_option(\"-m\", \"--mode\",\n"
"                  default=\"intermediate\",\n"
"                  help=\"interaction mode: novice, intermediate, \"\n"
"                       \"or expert [default: %default]\")"
msgstr ""
"usage = \"användning: %prog [alternativ] arg1 arg2\"\n"
"parser = OptionParser(användning=användning)\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_true\", dest=\"verbose\", default=True,\n"
"                  help=\"gör mycket ljud [default]\")\n"
"parser.add_option(\"-q\",\"--quiet\",\n"
"                  action=\"store_false\", dest=\"verbose\",\n"
"                  help=\"var jättetyst (jag jagar wabbits)\")\n"
"parser.add_option(\"-f\",\"--filnamn\",\n"
"                  metavar=\"FILE\", help=\"skriv utdata till FILE\")\n"
"parser.add_option(\"-m\",\"--mode\",\n"
"                  default=\"mellanläge\",\n"
"                  help=\"interaktionsläge: nybörjare, mellanliggande, \"\n"
"                       \"eller expert [standard: %default]\")"

msgid ""
"If :mod:`optparse` encounters either ``-h`` or ``--help`` on the command-"
"line, or if you just call :meth:`parser.print_help`, it prints the following "
"to standard output:"
msgstr ""
"Om :mod:`optparse` stöter på antingen ``-h`` eller ``--help`` på "
"kommandoraden, eller om du bara anropar :meth:`parser.print_help`, skriver "
"den ut följande till standardutmatningen:"

msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]"
msgstr ""
"Användning: <yourscript> [alternativ] arg1 arg2\n"
"\n"
"Alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --verbose gör mycket ljud [standard]\n"
"  -q, --quiet vara jättetyst (jag jagar wabbits)\n"
"  -f FILE, --filnamn=FILE\n"
"                        skriva utdata till FILE\n"
"  -m MODE, --mode=MODE interaktionsläge: nybörjare, medel eller\n"
"                        expert [standard: intermediär]"

msgid ""
"(If the help output is triggered by a help option, :mod:`optparse` exits "
"after printing the help text.)"
msgstr ""
"(Om hjälputmatningen utlöses av ett hjälpalternativ avslutas :mod:`optparse` "
"efter att hjälptexten har skrivits ut)"

msgid ""
"There's a lot going on here to help :mod:`optparse` generate the best "
"possible help message:"
msgstr ""
"Det är mycket som händer här för att hjälpa :mod:`optparse` att generera "
"bästa möjliga hjälpmeddelande:"

msgid "the script defines its own usage message::"
msgstr "skriptet definierar sitt eget användningsmeddelande::"

msgid "usage = \"usage: %prog [options] arg1 arg2\""
msgstr "usage = \"användning: %prog [alternativ] arg1 arg2\""

msgid ""
":mod:`optparse` expands ``%prog`` in the usage string to the name of the "
"current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded "
"string is then printed before the detailed option help."
msgstr ""
":mod:`optparse` expanderar ``%prog`` i användningssträngen till namnet på "
"det aktuella programmet, d.v.s. ``os.path.basename(sys.argv[0])``.  Den "
"expanderade strängen skrivs sedan ut före den detaljerade alternativhjälpen."

msgid ""
"If you don't supply a usage string, :mod:`optparse` uses a bland but "
"sensible default: ``\"Usage: %prog [options]\"``, which is fine if your "
"script doesn't take any positional arguments."
msgstr ""
"Om du inte anger någon användningssträng använder :mod:`optparse` en "
"intetsägande men förnuftig standard: ``\"Usage: %prog [options]\"``, vilket "
"är bra om ditt skript inte tar några positionella argument."

msgid ""
"every option defines a help string, and doesn't worry about line-wrapping---"
"\\ :mod:`optparse` takes care of wrapping lines and making the help output "
"look good."
msgstr ""
"varje alternativ definierar en hjälpsträng och bryr sig inte om radbrytning "
"--- :mod:`optparse` tar hand om radbrytning och ser till att "
"hjälputmatningen ser bra ut."

msgid ""
"options that take a value indicate this fact in their automatically "
"generated help message, e.g. for the \"mode\" option::"
msgstr ""
"alternativ som tar ett värde anger detta faktum i sitt automatiskt "
"genererade hjälpmeddelande, t.ex. för alternativet \"mode\"::"

msgid "-m MODE, --mode=MODE"
msgstr "-m MODE, --mode=MODE"

msgid ""
"Here, \"MODE\" is called the meta-variable: it stands for the argument that "
"the user is expected to supply to ``-m``/``--mode``.  By default, :mod:"
"`optparse` converts the destination variable name to uppercase and uses that "
"for the meta-variable.  Sometimes, that's not what you want---for example, "
"the ``--filename`` option explicitly sets ``metavar=\"FILE\"``, resulting in "
"this automatically generated option description::"
msgstr ""
"Här kallas \"MODE\" för meta-variabeln: den står för det argument som "
"användaren förväntas ge till ``-m``/``--mode``.  Som standard konverterar :"
"mod:`optparse` namnet på målvariabeln till versaler och använder det som "
"metavariabel.  Ibland är det inte vad du vill - till exempel, alternativet "
"``--filename`` sätter explicit ``metavar=\"FILE\"``, vilket resulterar i "
"denna automatiskt genererade alternativbeskrivning::"

msgid "-f FILE, --filename=FILE"
msgstr "-f FILE, --filnamn=FILE"

msgid ""
"This is important for more than just saving space, though: the manually "
"written help text uses the meta-variable ``FILE`` to clue the user in that "
"there's a connection between the semi-formal syntax ``-f FILE`` and the "
"informal semantic description \"write output to FILE\". This is a simple but "
"effective way to make your help text a lot clearer and more useful for end "
"users."
msgstr ""
"Detta är dock viktigt för mer än bara att spara utrymme: den manuellt "
"skrivna hjälptexten använder metavariabeln ``FILE`` för att ge användaren en "
"ledtråd om att det finns en koppling mellan den semi-formella syntaxen ``-f "
"FILE`` och den informella semantiska beskrivningen \"skriv utdata till "
"FILE\". Detta är ett enkelt men effektivt sätt att göra din hjälptext mycket "
"tydligare och mer användbar för slutanvändarna."

msgid ""
"options that have a default value can include ``%default`` in the help "
"string---\\ :mod:`optparse` will replace it with :func:`str` of the option's "
"default value.  If an option has no default value (or the default value is "
"``None``), ``%default`` expands to ``none``."
msgstr ""
"alternativ som har ett standardvärde kan inkludera ``%default`` i "
"hjälpsträngen---\\\\ :mod:`optparse` kommer att ersätta det med :func:`str` "
"av alternativets standardvärde.  Om ett alternativ inte har något "
"standardvärde (eller standardvärdet är ``None``), expanderar ``%default`` "
"till ``none``."

msgid "Grouping Options"
msgstr "Grupperingsalternativ"

msgid ""
"When dealing with many options, it is convenient to group these options for "
"better help output.  An :class:`OptionParser` can contain several option "
"groups, each of which can contain several options."
msgstr ""
"När man hanterar många alternativ är det praktiskt att gruppera dessa "
"alternativ för bättre hjälputmatning.  En :class:`OptionParser` kan "
"innehålla flera alternativgrupper, som var och en kan innehålla flera "
"alternativ."

msgid "An option group is obtained using the class :class:`OptionGroup`:"
msgstr "En optionsgrupp erhålls med hjälp av klassen :class:`OptionGroup`:"

msgid "where"
msgstr "där"

msgid ""
"parser is the :class:`OptionParser` instance the group will be inserted in to"
msgstr ""
"parser är :class:`OptionParser`-instansen som gruppen kommer att infogas i "
"för att"

msgid "title is the group title"
msgstr "title är gruppens titel"

msgid "description, optional, is a long description of the group"
msgstr "description, valfritt, är en lång beskrivning av gruppen"

msgid ""
":class:`OptionGroup` inherits from :class:`OptionContainer` (like :class:"
"`OptionParser`) and so the :meth:`add_option` method can be used to add an "
"option to the group."
msgstr ""
":class:`OptionGroup` ärver från :class:`OptionContainer` (liksom :class:"
"`OptionParser`) och därför kan metoden :meth:`add_option` användas för att "
"lägga till ett alternativ i gruppen."

msgid ""
"Once all the options are declared, using the :class:`OptionParser` method :"
"meth:`add_option_group` the group is added to the previously defined parser."
msgstr ""
"När alla alternativ har deklarerats, med hjälp av :class:`OptionParser`-"
"metoden :meth:`add_option_group`, läggs gruppen till i den tidigare "
"definierade parsern."

msgid ""
"Continuing with the parser defined in the previous section, adding an :class:"
"`OptionGroup` to a parser is easy::"
msgstr ""
"Om vi fortsätter med den parser som definierades i föregående avsnitt är det "
"enkelt att lägga till en :class:`OptionGroup` till en parser::"

msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)"
msgstr ""
"group = OptionGroup(parser, \"Farliga alternativ\",\n"
"                    \"Varning: använd dessa alternativ på egen risk.  \"\n"
"                    \"Det tros att vissa av dem biter.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Gruppalternativ.\")\n"
"parser.add_option_group(grupp)"

msgid "This would result in the following help output:"
msgstr "Detta skulle resultera i följande hjälputskrift:"

msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or\n"
"                        expert [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option."
msgstr ""
"Användning: <yourscript> [alternativ] arg1 arg2\n"
"\n"
"Alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --verbose gör mycket ljud [standard]\n"
"  -q, --quiet vara jättetyst (jag jagar wabbits)\n"
"  -f FILE, --filnamn=FILE\n"
"                        skriva utdata till FILE\n"
"  -m MODE, --mode=MODE interaktionsläge: nybörjare, medel eller\n"
"                        expert [standard: intermediär]\n"
"\n"
"  Farliga alternativ:\n"
"    Varning: Använd dessa alternativ på egen risk.  Det tros att vissa av "
"dem\n"
"    av dem biter.\n"
"\n"
"    -g Gruppalternativ."

msgid ""
"A bit more complete example might involve using more than one group: still "
"extending the previous example::"
msgstr ""
"Ett lite mer komplett exempel skulle kunna innebära att man använder mer än "
"en grupp: som en fortsättning på det tidigare exemplet::"

msgid ""
"group = OptionGroup(parser, \"Dangerous Options\",\n"
"                    \"Caution: use these options at your own risk.  \"\n"
"                    \"It is believed that some of them bite.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Group option.\")\n"
"parser.add_option_group(group)\n"
"\n"
"group = OptionGroup(parser, \"Debug Options\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Print debug information\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Print all SQL statements executed\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Print every action "
"done\")\n"
"parser.add_option_group(group)"
msgstr ""
"group = OptionGroup(parser, \"Farliga alternativ\",\n"
"                    \"Varning: använd dessa alternativ på egen risk.  \"\n"
"                    \"Det tros att vissa av dem biter.\")\n"
"group.add_option(\"-g\", action=\"store_true\", help=\"Gruppalternativ.\")\n"
"parser.add_option_group(grupp)\n"
"\n"
"group = OptionGroup(parser, \"Alternativ för felsökning\")\n"
"group.add_option(\"-d\", \"--debug\", action=\"store_true\",\n"
"                 help=\"Skriv ut felsökningsinformation\")\n"
"group.add_option(\"-s\", \"--sql\", action=\"store_true\",\n"
"                 help=\"Skriv ut alla SQL-satser som körts\")\n"
"group.add_option(\"-e\", action=\"store_true\", help=\"Skriv ut alla "
"åtgärder som utförts\")\n"
"parser.add_option_group(grupp)"

msgid "that results in the following output:"
msgstr "som resulterar i följande utdata:"

msgid ""
"Usage: <yourscript> [options] arg1 arg2\n"
"\n"
"Options:\n"
"  -h, --help            show this help message and exit\n"
"  -v, --verbose         make lots of noise [default]\n"
"  -q, --quiet           be vewwy quiet (I'm hunting wabbits)\n"
"  -f FILE, --filename=FILE\n"
"                        write output to FILE\n"
"  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert\n"
"                        [default: intermediate]\n"
"\n"
"  Dangerous Options:\n"
"    Caution: use these options at your own risk.  It is believed that some\n"
"    of them bite.\n"
"\n"
"    -g                  Group option.\n"
"\n"
"  Debug Options:\n"
"    -d, --debug         Print debug information\n"
"    -s, --sql           Print all SQL statements executed\n"
"    -e                  Print every action done"
msgstr ""
"Användning: <yourscript> [alternativ] arg1 arg2\n"
"\n"
"Alternativ:\n"
"  -h, --help visa detta hjälpmeddelande och avsluta\n"
"  -v, --verbose gör mycket ljud [standard]\n"
"  -q, --quiet vara jättetyst (jag jagar wabbits)\n"
"  -f FILE, --filnamn=FILE\n"
"                        skriva utdata till FILE\n"
"  -m MODE, --mode=MODE interaktionsläge: nybörjare, medel eller expert\n"
"                        [standard: intermediär]\n"
"\n"
"  Farliga alternativ:\n"
"    Varning: Använd dessa alternativ på egen risk.  Det tros att vissa av "
"dem\n"
"    av dem biter.\n"
"\n"
"    -g Gruppalternativ.\n"
"\n"
"  Alternativ för debuggning:\n"
"    -d, --debug Skriv ut felsökningsinformation\n"
"    -s, --sql Skriv ut alla SQL-satser som körts\n"
"    -e Skriv ut alla utförda åtgärder"

msgid ""
"Another interesting method, in particular when working programmatically with "
"option groups is:"
msgstr ""
"En annan intressant metod, särskilt när man arbetar programmatiskt med "
"optionsgrupper, är"

msgid ""
"Return the :class:`OptionGroup` to which the short or long option string "
"*opt_str* (e.g. ``'-o'`` or ``'--option'``) belongs. If there's no such :"
"class:`OptionGroup`, return ``None``."
msgstr ""
"Returnerar den :class:`OptionGroup` till vilken den korta eller långa "
"optionssträngen *opt_str* (t.ex. ``'-o'`` eller ``'--option'``) hör. Om det "
"inte finns någon sådan :class:`OptionGroup`, returneras ``None``."

msgid "Printing a version string"
msgstr "Skriva ut en versionssträng"

msgid ""
"Similar to the brief usage string, :mod:`optparse` can also print a version "
"string for your program.  You have to supply the string as the ``version`` "
"argument to OptionParser::"
msgstr ""
"I likhet med den korta användningssträngen kan :mod:`optparse` också skriva "
"ut en versionssträng för ditt program.  Du måste ange strängen som "
"argumentet ``version`` till OptionParser::"

msgid "parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"
msgstr ""
"parser = OptionParser(usage=\"%prog [-f] [-q]\", version=\"%prog 1.0\")"

msgid ""
"``%prog`` is expanded just like it is in ``usage``.  Apart from that, "
"``version`` can contain anything you like.  When you supply it, :mod:"
"`optparse` automatically adds a ``--version`` option to your parser. If it "
"encounters this option on the command line, it expands your ``version`` "
"string (by replacing ``%prog``), prints it to stdout, and exits."
msgstr ""
"``%prog`` är expanderat precis som det är i ``usage``.  Bortsett från det "
"kan ``version`` innehålla vad du vill.  När du anger det, lägger :mod:"
"`optparse` automatiskt till ett ``--version``-alternativ till din parser. Om "
"den stöter på detta alternativ på kommandoraden, expanderar den din "
"``version``-sträng (genom att ersätta ``%prog``), skriver ut den till stdout "
"och avslutar."

msgid "For example, if your script is called ``/usr/bin/foo``:"
msgstr "Om ditt skript till exempel heter ``/usr/bin/foo``:"

msgid ""
"$ /usr/bin/foo --version\n"
"foo 1.0"
msgstr ""
"$ /usr/bin/foo --version\n"
"foo 1.0"

msgid ""
"The following two methods can be used to print and get the ``version`` "
"string:"
msgstr ""
"Följande två metoder kan användas för att skriva ut och hämta ``version``-"
"strängen:"

msgid ""
"Print the version message for the current program (``self.version``) to "
"*file* (default stdout).  As with :meth:`print_usage`, any occurrence of "
"``%prog`` in ``self.version`` is replaced with the name of the current "
"program.  Does nothing if ``self.version`` is empty or undefined."
msgstr ""
"Skriver ut versionsmeddelandet för det aktuella programmet (``self."
"version``) till *fil* (standard stdout).  Precis som med :meth:`print_usage` "
"ersätts alla förekomster av ``%prog`` i ``self.version`` med namnet på det "
"aktuella programmet.  Gör ingenting om ``self.version`` är tom eller "
"odefinierad."

msgid ""
"Same as :meth:`print_version` but returns the version string instead of "
"printing it."
msgstr ""
"Samma sak som :meth:`print_version` men returnerar versionssträngen i "
"stället för att skriva ut den."

msgid "How :mod:`optparse` handles errors"
msgstr "Hur :mod:`optparse` hanterar fel"

msgid ""
"There are two broad classes of errors that :mod:`optparse` has to worry "
"about: programmer errors and user errors.  Programmer errors are usually "
"erroneous calls to :func:`OptionParser.add_option`, e.g. invalid option "
"strings, unknown option attributes, missing option attributes, etc.  These "
"are dealt with in the usual way: raise an exception (either :exc:`optparse."
"OptionError` or :exc:`TypeError`) and let the program crash."
msgstr ""
"Det finns två stora klasser av fel som :mod:`optparse` måste ta hand om: "
"programmeringsfel och användarfel.  Programmeringsfel är vanligtvis "
"felaktiga anrop till :func:`OptionParser.add_option`, t.ex. ogiltiga "
"alternativsträngar, okända alternativattribut, saknade alternativattribut, "
"etc.  Dessa hanteras på vanligt sätt: skapa ett undantag (antingen :exc:"
"`optparse.OptionError` eller :exc:`TypeError`) och låt programmet krascha."

msgid ""
"Handling user errors is much more important, since they are guaranteed to "
"happen no matter how stable your code is.  :mod:`optparse` can automatically "
"detect some user errors, such as bad option arguments (passing ``-n 4x`` "
"where ``-n`` takes an integer argument), missing arguments (``-n`` at the "
"end of the command line, where ``-n`` takes an argument of any type).  Also, "
"you can call :func:`OptionParser.error` to signal an application-defined "
"error condition::"
msgstr ""
"Hantering av användarfel är mycket viktigare, eftersom de garanterat kommer "
"att inträffa oavsett hur stabil din kod är. :mod:`optparse` kan automatiskt "
"upptäcka vissa användarfel, t.ex. dåliga alternativargument (skicka ``-n "
"4x`` där ``-n`` tar ett heltalsargument), saknade argument (``-n`` i slutet "
"av kommandoraden, där ``-n`` tar ett argument av valfri typ).  Du kan också "
"anropa :func:`OptionParser.error` för att signalera ett programdefinierat "
"feltillstånd::"

msgid ""
"(options, args) = parser.parse_args()\n"
"...\n"
"if options.a and options.b:\n"
"    parser.error(\"options -a and -b are mutually exclusive\")"
msgstr ""
"(alternativ, args) = parser.parse_args()\n"
"...\n"
"om alternativ.a och alternativ.b:\n"
"    parser.error(\"alternativen -a och -b är ömsesidigt uteslutande\")"

msgid ""
"In either case, :mod:`optparse` handles the error the same way: it prints "
"the program's usage message and an error message to standard error and exits "
"with error status 2."
msgstr ""
"I båda fallen hanterar :mod:`optparse` felet på samma sätt: det skriver ut "
"programmets användningsmeddelande och ett felmeddelande till standardfelet "
"och avslutas med felstatus 2."

msgid ""
"Consider the first example above, where the user passes ``4x`` to an option "
"that takes an integer:"
msgstr ""
"Tänk på det första exemplet ovan, där användaren ger ``4x`` till ett "
"alternativ som tar ett heltal:"

msgid ""
"$ /usr/bin/foo -n 4x\n"
"Usage: foo [options]\n"
"\n"
"foo: error: option -n: invalid integer value: '4x'"
msgstr ""
"$ /usr/bin/foo -n 4x\n"
"Användning: foo [alternativ]\n"
"\n"
"foo: fel: alternativ -n: ogiltigt heltalsvärde: '4x'"

msgid "Or, where the user fails to pass a value at all:"
msgstr "Eller där användaren inte skickar något värde alls:"

msgid ""
"$ /usr/bin/foo -n\n"
"Usage: foo [options]\n"
"\n"
"foo: error: -n option requires an argument"
msgstr ""
"$ /usr/bin/foo -n\n"
"Användning: foo [alternativ]\n"
"\n"
"foo: fel: alternativet -n kräver ett argument"

msgid ""
":mod:`optparse`\\ -generated error messages take care always to mention the "
"option involved in the error; be sure to do the same when calling :func:"
"`OptionParser.error` from your application code."
msgstr ""
":mod:`optparse` -genererade felmeddelanden är noga med att alltid nämna det "
"alternativ som är inblandat i felet; se till att göra detsamma när du "
"anropar :func:`OptionParser.error` från din programkod."

msgid ""
"If :mod:`optparse`'s default error-handling behaviour does not suit your "
"needs, you'll need to subclass OptionParser and override its :meth:"
"`~OptionParser.exit` and/or :meth:`~OptionParser.error` methods."
msgstr ""
"Om :mod:`optparse` standardfelhanteringsbeteende inte passar dina behov, "
"måste du underklassa OptionParser och åsidosätta dess :meth:`~OptionParser."
"exit` och/eller :meth:`~OptionParser.error` metoder."

msgid "Putting it all together"
msgstr "Att sätta ihop allt"

msgid "Here's what :mod:`optparse`\\ -based scripts usually look like::"
msgstr "Så här ser :mod:`optparse` -baserade skript vanligtvis ut::"

msgid ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    usage = \"usage: %prog [options] arg\"\n"
"    parser = OptionParser(usage)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n"
"                      help=\"read data from FILENAME\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (options, args) = parser.parse_args()\n"
"    if len(args) != 1:\n"
"        parser.error(\"incorrect number of arguments\")\n"
"    if options.verbose:\n"
"        print(\"reading %s...\" % options.filename)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""
"from optparse import OptionParser\n"
"...\n"
"def main():\n"
"    användning = \"användning: %prog [alternativ] arg\"\n"
"    parser = OptionParser(användning)\n"
"    parser.add_option(\"-f\", \"--file\", dest=\"filnamn\",\n"
"                      help=\"läs data från FILNAMN\")\n"
"    parser.add_option(\"-v\", \"--verbose\",\n"
"                      action=\"store_true\", dest=\"verbose\")\n"
"    parser.add_option(\"-q\", \"--quiet\",\n"
"                      action=\"store_false\", dest=\"verbose\")\n"
"    ...\n"
"    (alternativ, args) = parser.parse_args()\n"
"    om len(args) != 1:\n"
"        parser.error(\"felaktigt antal argument\")\n"
"    if options.verbose:\n"
"        print(\"läser %s...\" % options.filnamn)\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"

msgid "Reference Guide"
msgstr "Referensguide"

msgid "Creating the parser"
msgstr "Skapa parsern"

msgid ""
"The first step in using :mod:`optparse` is to create an OptionParser "
"instance."
msgstr ""
"Det första steget i användningen av :mod:`optparse` är att skapa en "
"OptionParser-instans."

msgid ""
"The OptionParser constructor has no required arguments, but a number of "
"optional keyword arguments.  You should always pass them as keyword "
"arguments, i.e. do not rely on the order in which the arguments are declared."
msgstr ""
"OptionParser-konstruktören har inga obligatoriska argument, men ett antal "
"valfria nyckelordsargument.  Du bör alltid skicka dem som "
"nyckelordsargument, dvs. inte förlita dig på den ordning i vilken argumenten "
"deklareras."

msgid "``usage`` (default: ``\"%prog [options]\"``)"
msgstr "``usage`` (standard: ``\"%prog [options]\"``)"

msgid ""
"The usage summary to print when your program is run incorrectly or with a "
"help option.  When :mod:`optparse` prints the usage string, it expands "
"``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you passed "
"that keyword argument).  To suppress a usage message, pass the special "
"value :const:`optparse.SUPPRESS_USAGE`."
msgstr ""
"Den användningsöversikt som ska skrivas ut när programmet körs felaktigt "
"eller med ett hjälpalternativ.  När :mod:`optparse` skriver ut "
"användningssträngen expanderar den ``%prog`` till ``os.path.basename(sys."
"argv[0])`` (eller till ``prog`` om du angav det nyckelordet som argument).  "
"För att undertrycka ett användningsmeddelande, skicka det speciella värdet :"
"const:`optparse.SUPPRESS_USAGE`."

msgid "``option_list`` (default: ``[]``)"
msgstr "``option_list`` (standard: ``[]``)"

msgid ""
"A list of Option objects to populate the parser with.  The options in "
"``option_list`` are added after any options in ``standard_option_list`` (a "
"class attribute that may be set by OptionParser subclasses), but before any "
"version or help options. Deprecated; use :meth:`add_option` after creating "
"the parser instead."
msgstr ""
"En lista med Option-objekt att fylla parsern med.  Alternativen i "
"``option_list`` läggs till efter eventuella alternativ i "
"``standard_option_list`` (ett klassattribut som kan ställas in av "
"OptionParser-subklasser), men före eventuella versions- eller "
"hjälpalternativ. Utgår; använd :meth:`add_option` efter att parsern skapats "
"istället."

msgid "``option_class`` (default: optparse.Option)"
msgstr "``option_class`` (standard: optparse.Option)"

msgid "Class to use when adding options to the parser in :meth:`add_option`."
msgstr ""
"Klass som ska användas när alternativ läggs till i parsern i :meth:"
"`add_option`."

msgid "``version`` (default: ``None``)"
msgstr "``version`` (standard: ``None``)"

msgid ""
"A version string to print when the user supplies a version option. If you "
"supply a true value for ``version``, :mod:`optparse` automatically adds a "
"version option with the single option string ``--version``.  The substring "
"``%prog`` is expanded the same as for ``usage``."
msgstr ""
"En versionssträng som skrivs ut när användaren anger ett versionsalternativ. "
"Om du anger ett sant värde för ``version``, lägger :mod:`optparse` "
"automatiskt till ett versionsalternativ med den enkla optionssträngen ``--"
"version``.  Understrängen ``%prog`` expanderas på samma sätt som för "
"``usage``."

msgid "``conflict_handler`` (default: ``\"error\"``)"
msgstr "``conflict_handler`` (standard: ``\"error\"``)"

msgid ""
"Specifies what to do when options with conflicting option strings are added "
"to the parser; see section :ref:`optparse-conflicts-between-options`."
msgstr ""
"Anger vad som ska göras när alternativ med motstridiga alternativsträngar "
"läggs till i parsern; se avsnitt :ref:`optparse-conflicts-between-options`."

msgid "``description`` (default: ``None``)"
msgstr "``description`` (standard: ``None``)"

msgid ""
"A paragraph of text giving a brief overview of your program. :mod:`optparse` "
"reformats this paragraph to fit the current terminal width and prints it "
"when the user requests help (after ``usage``, but before the list of "
"options)."
msgstr ""
"Ett stycke text som ger en kort översikt över ditt program. :mod:`optparse` "
"omformaterar detta stycke så att det passar den aktuella terminalbredden och "
"skriver ut det när användaren ber om hjälp (efter ``usage``, men före listan "
"med alternativ)."

msgid "``formatter`` (default: a new :class:`IndentedHelpFormatter`)"
msgstr "``formatter`` (standard: en ny :class:`IndentedHelpFormatter`)"

msgid ""
"An instance of optparse.HelpFormatter that will be used for printing help "
"text.  :mod:`optparse` provides two concrete classes for this purpose: "
"IndentedHelpFormatter and TitledHelpFormatter."
msgstr ""
"En instans av optparse.HelpFormatter som kommer att användas för att skriva "
"ut hjälptext. :mod:`optparse` tillhandahåller två konkreta klasser för detta "
"ändamål: IndentedHelpFormatter och TitledHelpFormatter."

msgid "``add_help_option`` (default: ``True``)"
msgstr "``add_help_option`` (standard: ``True``)"

msgid ""
"If true, :mod:`optparse` will add a help option (with option strings ``-h`` "
"and ``--help``) to the parser."
msgstr ""
"Om true, kommer :mod:`optparse` att lägga till ett hjälpalternativ (med "
"alternativsträngarna ``-h`` och ``--help``) till parsern."

msgid "``prog``"
msgstr "``prog``"

msgid ""
"The string to use when expanding ``%prog`` in ``usage`` and ``version`` "
"instead of ``os.path.basename(sys.argv[0])``."
msgstr ""
"Den sträng som ska användas när ``%prog`` expanderas i ``usage`` och "
"``version`` istället för ``os.path.basename(sys.argv[0])``."

msgid "``epilog`` (default: ``None``)"
msgstr "``epilog`` (standard: ``None``)"

msgid "A paragraph of help text to print after the option help."
msgstr "Ett stycke hjälptext som ska skrivas ut efter alternativet help."

msgid "Populating the parser"
msgstr "Fylla på parsern"

msgid ""
"There are several ways to populate the parser with options.  The preferred "
"way is by using :meth:`OptionParser.add_option`, as shown in section :ref:"
"`optparse-tutorial`.  :meth:`add_option` can be called in one of two ways:"
msgstr ""
"Det finns flera sätt att fylla på parsern med alternativ.  Det föredragna "
"sättet är att använda :meth:`OptionParser.add_option`, som visas i avsnitt :"
"ref:`optparse-tutorial`. :meth:`add_option` kan anropas på ett av två sätt:"

msgid "pass it an Option instance (as returned by :func:`make_option`)"
msgstr ""
"skicka en Option-instans till den (som returneras av :func:`make_option`)"

msgid ""
"pass it any combination of positional and keyword arguments that are "
"acceptable to :func:`make_option` (i.e., to the Option constructor), and it "
"will create the Option instance for you"
msgstr ""
"skicka valfri kombination av positions- och nyckelordsargument som är "
"acceptabla för :func:`make_option` (dvs. för Option-konstruktören), så "
"skapar den Option-instansen åt dig"

msgid ""
"The other alternative is to pass a list of pre-constructed Option instances "
"to the OptionParser constructor, as in::"
msgstr ""
"Det andra alternativet är att skicka en lista med förkonstruerade Option-"
"instanser till OptionParser-konstruktören, som i::"

msgid ""
"option_list = [\n"
"    make_option(\"-f\", \"--filename\",\n"
"                action=\"store\", type=\"string\", dest=\"filename\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""
"option_list = [\n"
"    make_option(\"-f\", \"--filnamn\",\n"
"                action=\"lagra\", type=\"sträng\", dest=\"filnamn\"),\n"
"    make_option(\"-q\", \"--quiet\",\n"
"                action=\"store_false\", dest=\"verbose\"),\n"
"    ]\n"
"parser = OptionParser(option_list=option_list)"

msgid ""
"(:func:`make_option` is a factory function for creating Option instances; "
"currently it is an alias for the Option constructor.  A future version of :"
"mod:`optparse` may split Option into several classes, and :func:"
"`make_option` will pick the right class to instantiate.  Do not instantiate "
"Option directly.)"
msgstr ""
"(:func:`make_option` är en fabriksfunktion för att skapa Option-instanser; "
"för närvarande är det ett alias för Option-konstruktören.  En framtida "
"version av :mod:`optparse` kan dela upp Option i flera klasser, och :func:"
"`make_option` kommer att välja rätt klass att instansiera.  Instansiera inte "
"Option direkt)"

msgid "Defining options"
msgstr "Definiera alternativ"

msgid ""
"Each Option instance represents a set of synonymous command-line option "
"strings, e.g. ``-f`` and ``--file``.  You can specify any number of short or "
"long option strings, but you must specify at least one overall option string."
msgstr ""
"Varje Option-instans representerar en uppsättning synonyma "
"kommandoradsalternativsträngar, t.ex. ``-f`` och ``--file``.  Du kan ange "
"ett valfritt antal korta eller långa alternativsträngar, men du måste ange "
"minst en övergripande alternativsträng."

msgid ""
"The canonical way to create an :class:`Option` instance is with the :meth:"
"`add_option` method of :class:`OptionParser`."
msgstr ""
"Det kanoniska sättet att skapa en instans av :class:`Option` är med metoden :"
"meth:`add_option` i :class:`OptionParser`."

msgid "To define an option with only a short option string::"
msgstr "För att definiera ett alternativ med endast en kort alternativsträng::"

msgid "parser.add_option(\"-f\", attr=value, ...)"
msgstr "parser.add_option(\"-f\", attr=värde, ...)"

msgid "And to define an option with only a long option string::"
msgstr ""
"Och för att definiera ett alternativ med endast en lång alternativsträng::"

msgid "parser.add_option(\"--foo\", attr=value, ...)"
msgstr "parser.add_option(\"--foo\", attr=värde, ...)"

msgid ""
"The keyword arguments define attributes of the new Option object.  The most "
"important option attribute is :attr:`~Option.action`, and it largely "
"determines which other attributes are relevant or required.  If you pass "
"irrelevant option attributes, or fail to pass required ones, :mod:`optparse` "
"raises an :exc:`OptionError` exception explaining your mistake."
msgstr ""
"Nyckelordsargumenten definierar attribut för det nya Option-objektet.  Det "
"viktigaste attributet är :attr:`~Option.action`, och det avgör till stor del "
"vilka andra attribut som är relevanta eller obligatoriska.  Om du skickar "
"irrelevanta optionsattribut eller inte skickar nödvändiga sådana, ger :mod:"
"`optparse` upphov till ett :exc:`OptionError` undantag som förklarar ditt "
"misstag."

msgid ""
"An option's *action* determines what :mod:`optparse` does when it encounters "
"this option on the command-line.  The standard option actions hard-coded "
"into :mod:`optparse` are:"
msgstr ""
"Ett alternativs *åtgärd* avgör vad :mod:`optparse` gör när den stöter på "
"detta alternativ på kommandoraden.  De standardåtgärder för alternativ som "
"är hårdkodade i :mod:`optparse` är:"

msgid "``\"store\"``"
msgstr "``\"butik\"``"

msgid "store this option's argument (default)"
msgstr "lagra argumentet för detta alternativ (standard)"

msgid "``\"store_true\"``"
msgstr "``\"store_true\"```"

msgid "store ``True``"
msgstr "lagra ``True``"

msgid "``\"store_false\"``"
msgstr "``\"store_false\"```"

msgid "store ``False``"
msgstr "lagra ``False``"

msgid "``\"append_const\"``"
msgstr "``\"append_const\"```"

msgid "append a constant value to a list, pre-set via :attr:`Option.const`"
msgstr ""
"lägger till ett konstant värde till en lista, förinställt via :attr:`Option."
"const`"

msgid "``\"help\"``"
msgstr "``\"hjälp\"``"

msgid ""
"print a usage message including all options and the documentation for them"
msgstr ""
"skriva ut ett användningsmeddelande som innehåller alla alternativ och "
"dokumentationen för dem"

msgid ""
"(If you don't supply an action, the default is ``\"store\"``.  For this "
"action, you may also supply :attr:`~Option.type` and :attr:`~Option.dest` "
"option attributes; see :ref:`optparse-standard-option-actions`.)"
msgstr ""
"(Om du inte anger någon åtgärd är standardvärdet ``\"store\"``.  För denna "
"åtgärd kan du också ange alternativattributen :attr:`~Option.type` och :attr:"
"`~Option.dest`; se :ref:`optparse-standard-option-actions`.)"

msgid ""
"As you can see, most actions involve storing or updating a value somewhere. :"
"mod:`optparse` always creates a special object for this, conventionally "
"called ``options``, which is an instance of :class:`optparse.Values`."
msgstr ""
"Som du kan se handlar de flesta åtgärder om att lagra eller uppdatera ett "
"värde någonstans. :mod:`optparse` skapar alltid ett speciellt objekt för "
"detta, konventionellt kallat ``options``, som är en instans av :class:"
"`optparse.Values`."

msgid ""
"An object holding parsed argument names and values as attributes. Normally "
"created by calling when calling :meth:`OptionParser.parse_args`, and can be "
"overridden by a custom subclass passed to the *values* argument of :meth:"
"`OptionParser.parse_args` (as described in :ref:`optparse-parsing-"
"arguments`)."
msgstr ""
"Ett objekt som innehåller namn och värden för analyserade argument som "
"attribut. Skapas normalt genom att anropa :meth:`OptionParser.parse_args`, "
"och kan åsidosättas av en anpassad underklass som skickas till *values*-"
"argumentet i :meth:`OptionParser.parse_args` (enligt beskrivningen i :ref:"
"`optparse-parsing-arguments`)."

msgid ""
"Option arguments (and various other values) are stored as attributes of this "
"object, according to the :attr:`~Option.dest` (destination) option attribute."
msgstr ""
"Alternativargument (och diverse andra värden) lagras som attribut för detta "
"objekt, enligt alternativattributet :attr:`~Option.dest` (destination)."

msgid "For example, when you call ::"
msgstr "Till exempel när du ringer ::"

msgid "parser.parse_args()"
msgstr "parser.parse_args()"

msgid ""
"one of the first things :mod:`optparse` does is create the ``options`` "
"object::"
msgstr ""
"en av de första sakerna som :mod:`optparse` gör är att skapa objektet "
"``options``::"

msgid "options = Values()"
msgstr "alternativ = Värden()"

msgid "If one of the options in this parser is defined with ::"
msgstr "Om ett av alternativen i denna parser definieras med ::"

msgid ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"
msgstr ""
"parser.add_option(\"-f\", \"--file\", action=\"store\", type=\"string\", "
"dest=\"filename\")"

msgid "and the command-line being parsed includes any of the following::"
msgstr "och kommandoraden som analyseras innehåller något av följande::"

msgid ""
"-ffoo\n"
"-f foo\n"
"--file=foo\n"
"--file foo"
msgstr ""
"-ffoo\n"
"-f foo\n"
"--file=foo\n"
"--fil foo"

msgid ""
"then :mod:`optparse`, on seeing this option, will do the equivalent of ::"
msgstr ""
"då kommer :mod:`optparse`, när den ser detta alternativ, att göra "
"motsvarande ::"

msgid "options.filename = \"foo\""
msgstr "alternativ.filnamn = \"foo\""

msgid ""
"The :attr:`~Option.type` and :attr:`~Option.dest` option attributes are "
"almost as important as :attr:`~Option.action`, but :attr:`~Option.action` is "
"the only one that makes sense for *all* options."
msgstr ""
"Alternativattributen :attr:`~Option.type` och :attr:`~Option.dest` är nästan "
"lika viktiga som :attr:`~Option.action`, men :attr:`~Option.action` är det "
"enda som är meningsfullt för *alla* alternativ."

msgid "Option attributes"
msgstr "Attribut för alternativ"

msgid ""
"A single command line argument, with various attributes passed by keyword to "
"the constructor. Normally created with :meth:`OptionParser.add_option` "
"rather than directly, and can be overridden by a custom class via the "
"*option_class* argument to :class:`OptionParser`."
msgstr ""
"Ett enda kommandoradsargument, med olika attribut som skickas med nyckelord "
"till konstruktören. Skapas normalt med :meth:`OptionParser.add_option` "
"snarare än direkt, och kan åsidosättas av en anpassad klass via argumentet "
"*option_class* till :class:`OptionParser`."

msgid ""
"The following option attributes may be passed as keyword arguments to :meth:"
"`OptionParser.add_option`.  If you pass an option attribute that is not "
"relevant to a particular option, or fail to pass a required option "
"attribute, :mod:`optparse` raises :exc:`OptionError`."
msgstr ""
"Följande optionsattribut kan skickas som nyckelordsargument till :meth:"
"`OptionParser.add_option`.  Om du skickar ett alternativattribut som inte är "
"relevant för ett visst alternativ, eller misslyckas med att skicka ett "
"obligatoriskt alternativattribut, ger :mod:`optparse` upphov till :exc:"
"`OptionError`."

msgid "(default: ``\"store\"``)"
msgstr "(standard: ``\"store\"``)"

msgid ""
"Determines :mod:`optparse`'s behaviour when this option is seen on the "
"command line; the available options are documented :ref:`here <optparse-"
"standard-option-actions>`."
msgstr ""
"Bestämmer :mod:`optparse` beteende när detta alternativ visas på "
"kommandoraden; de tillgängliga alternativen finns dokumenterade :ref:`här "
"<optparse-standard-option-actions>`."

msgid "(default: ``\"string\"``)"
msgstr "(standard: ``\"sträng\"``)"

msgid ""
"The argument type expected by this option (e.g., ``\"string\"`` or "
"``\"int\"``); the available option types are documented :ref:`here <optparse-"
"standard-option-types>`."
msgstr ""
"Den argumenttyp som förväntas av detta alternativ (t.ex. ``\"string\"`` "
"eller ``\"int\"``); de tillgängliga alternativtyperna finns dokumenterade :"
"ref:`här <optparse-standard-option-types>`."

msgid "(default: derived from option strings)"
msgstr "(standard: härledd från optionssträngar)"

msgid ""
"If the option's action implies writing or modifying a value somewhere, this "
"tells :mod:`optparse` where to write it: :attr:`~Option.dest` names an "
"attribute of the ``options`` object that :mod:`optparse` builds as it parses "
"the command line."
msgstr ""
"Om optionens åtgärd innebär att ett värde skrivs eller ändras någonstans, "
"talar detta om för :mod:`optparse` var det ska skrivas: :attr:`~Option.dest` "
"namnger ett attribut i objektet ``options`` som :mod:`optparse` bygger upp "
"när den analyserar kommandoraden."

msgid ""
"The value to use for this option's destination if the option is not seen on "
"the command line.  See also :meth:`OptionParser.set_defaults`."
msgstr ""
"Det värde som ska användas för detta alternativs destination om alternativet "
"inte visas på kommandoraden.  Se även :meth:`OptionParser.set_defaults`."

msgid "(default: 1)"
msgstr "(standard: 1)"

msgid ""
"How many arguments of type :attr:`~Option.type` should be consumed when this "
"option is seen.  If > 1, :mod:`optparse` will store a tuple of values to :"
"attr:`~Option.dest`."
msgstr ""
"Hur många argument av typen :attr:`~Option.type` som ska användas när detta "
"alternativ visas.  Om > 1, kommer :mod:`optparse` att lagra en tupel av "
"värden till :attr:`~Option.dest`."

msgid "For actions that store a constant value, the constant value to store."
msgstr ""
"För åtgärder som lagrar ett konstant värde, det konstanta värde som ska "
"lagras."

msgid ""
"For options of type ``\"choice\"``, the list of strings the user may choose "
"from."
msgstr ""
"För alternativ av typen ``\"choice\"``, listan med strängar som användaren "
"kan välja mellan."

msgid ""
"For options with action ``\"callback\"``, the callable to call when this "
"option is seen.  See section :ref:`optparse-option-callbacks` for detail on "
"the arguments passed to the callable."
msgstr ""
"För alternativ med åtgärden ``\"callback\"``, den anropbara funktionen som "
"ska anropas när detta alternativ visas.  Se avsnitt :ref:`optparse-option-"
"callbacks` för detaljer om de argument som skickas till anropsbarnet."

msgid ""
"Additional positional and keyword arguments to pass to ``callback`` after "
"the four standard callback arguments."
msgstr ""
"Ytterligare positions- och nyckelordsargument att skicka till ``callback`` "
"efter de fyra standardargumenten för återuppringning."

msgid ""
"Help text to print for this option when listing all available options after "
"the user supplies a :attr:`~Option.help` option (such as ``--help``).  If no "
"help text is supplied, the option will be listed without help text.  To hide "
"this option, use the special value :const:`optparse.SUPPRESS_HELP`."
msgstr ""
"Hjälptext som ska skrivas ut för detta alternativ när alla tillgängliga "
"alternativ listas efter att användaren har angett ett :attr:`~Option.help`-"
"alternativ (t.ex. ``--help``).  Om ingen hjälptext anges kommer alternativet "
"att listas utan hjälptext.  Om du vill dölja det här alternativet använder "
"du specialvärdet :const:`optparse.SUPPRESS_HELP`."

msgid ""
"Stand-in for the option argument(s) to use when printing help text.  See "
"section :ref:`optparse-tutorial` for an example."
msgstr ""
"Ersättare för det eller de alternativargument som ska användas vid utskrift "
"av hjälptext.  Se avsnitt :ref:`optparse-tutorial` för ett exempel."

msgid "Standard option actions"
msgstr "Standardalternativ för åtgärder"

msgid ""
"The various option actions all have slightly different requirements and "
"effects. Most actions have several relevant option attributes which you may "
"specify to guide :mod:`optparse`'s behaviour; a few have required "
"attributes, which you must specify for any option using that action."
msgstr ""
"De olika alternativåtgärderna har alla lite olika krav och effekter. De "
"flesta åtgärder har flera relevanta alternativattribut som du kan ange för "
"att styra :mod:`optparse`:s beteende; några få har obligatoriska attribut "
"som du måste ange för alla alternativ som använder den åtgärden."

msgid ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"

msgid ""
"The option must be followed by an argument, which is converted to a value "
"according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  If :"
"attr:`~Option.nargs` > 1, multiple arguments will be consumed from the "
"command line; all will be converted according to :attr:`~Option.type` and "
"stored to :attr:`~Option.dest` as a tuple.  See the :ref:`optparse-standard-"
"option-types` section."
msgstr ""
"Alternativet måste följas av ett argument, som konverteras till ett värde "
"enligt :attr:`~Option.type` och lagras i :attr:`~Option.dest`.  Om :attr:"
"`~Option.nargs` > 1, kommer flera argument att hämtas från kommandoraden; "
"alla kommer att konverteras enligt :attr:`~Option.type` och lagras i :attr:"
"`~Option.dest` som en tupel.  Se avsnittet :ref:`optparse-standard-option-"
"types`."

msgid ""
"If :attr:`~Option.choices` is supplied (a list or tuple of strings), the "
"type defaults to ``\"choice\"``."
msgstr ""
"Om :attr:`~Option.choices` anges (en lista eller tupel av strängar), är "
"typen standardmässigt ``\"choice\"``."

msgid "If :attr:`~Option.type` is not supplied, it defaults to ``\"string\"``."
msgstr "Om :attr:`~Option.type` inte anges är standardvärdet ``\"string\"``."

msgid ""
"If :attr:`~Option.dest` is not supplied, :mod:`optparse` derives a "
"destination from the first long option string (e.g., ``--foo-bar`` implies "
"``foo_bar``). If there are no long option strings, :mod:`optparse` derives a "
"destination from the first short option string (e.g., ``-f`` implies ``f``)."
msgstr ""
"Om :attr:`~Option.dest` inte anges, härleder :mod:`optparse` en destination "
"från den första långa alternativsträngen (t.ex. ``--foo-bar`` implicerar "
"``foo_bar``). Om det inte finns några långa alternativsträngar, härleder :"
"mod:`optparse` en destination från den första korta alternativsträngen (t."
"ex. ``-f`` implicerar ``f``)."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"
msgstr ""
"parser.add_option(\"-f\")\n"
"parser.add_option(\"-p\", type=\"float\", nargs=3, dest=\"point\")"

msgid "As it parses the command line ::"
msgstr "När den analyserar kommandoraden ::"

msgid "-f foo.txt -p 1 -3.5 4 -fbar.txt"
msgstr "-f foo.txt -p 1 -3.5 4 -fbar.txt"

msgid ":mod:`optparse` will set ::"
msgstr ":mod:`optparse` kommer att ställa in ::"

msgid ""
"options.f = \"foo.txt\"\n"
"options.point = (1.0, -3.5, 4.0)\n"
"options.f = \"bar.txt\""
msgstr ""
"options.f = \"foo.txt\"\n"
"alternativ.punkt = (1,0, -3,5, 4,0)\n"
"alternativ.f = \"bar.txt\""

msgid ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"

msgid "The value :attr:`~Option.const` is stored in :attr:`~Option.dest`."
msgstr "Värdet :attr:`~Option.const` lagras i :attr:`~Option.dest`."

msgid ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"
msgstr ""
"parser.add_option(\"-q\", \"--quiet\",\n"
"                  action=\"store_const\", const=0, dest=\"verbose\")\n"
"parser.add_option(\"-v\", \"--verbose\",\n"
"                  action=\"store_const\", const=1, dest=\"verbose\")\n"
"parser.add_option(\"--noisy\",\n"
"                  action=\"store_const\", const=2, dest=\"verbose\")"

msgid "If ``--noisy`` is seen, :mod:`optparse` will set  ::"
msgstr "Om ``--noisy`` ses, kommer :mod:`optparse` att sätta ::"

msgid "options.verbose = 2"
msgstr "options.verbose = 2"

msgid "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"

msgid ""
"A special case of ``\"store_const\"`` that stores ``True`` to :attr:`~Option."
"dest`."
msgstr ""
"Ett specialfall av ``\"store_const\"`` som lagrar ``True`` till :attr:"
"`~Option.dest`."

msgid "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"

msgid "Like ``\"store_true\"``, but stores ``False``."
msgstr "Som ``\"store_true\"``, men lagrar ``False``."

msgid ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", dest=\"clobber\")"
msgstr ""
"parser.add_option(\"--clobber\", action=\"store_true\", dest=\"clobber\")\n"
"parser.add_option(\"--no-clobber\", action=\"store_false\", dest=\"clobber\")"

msgid ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"

msgid ""
"The option must be followed by an argument, which is appended to the list "
"in :attr:`~Option.dest`.  If no default value for :attr:`~Option.dest` is "
"supplied, an empty list is automatically created when :mod:`optparse` first "
"encounters this option on the command-line.  If :attr:`~Option.nargs` > 1, "
"multiple arguments are consumed, and a tuple of length :attr:`~Option.nargs` "
"is appended to :attr:`~Option.dest`."
msgstr ""
"Alternativet måste följas av ett argument som läggs till i listan i :attr:"
"`~Option.dest`.  Om inget standardvärde anges för :attr:`~Option.dest` "
"skapas automatiskt en tom lista när :mod:`optparse` för första gången möter "
"detta alternativ på kommandoraden.  Om :attr:`~Option.nargs` > 1, används "
"flera argument och en tupel med längden :attr:`~Option.nargs` läggs till :"
"attr:`~Option.dest`."

msgid ""
"The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the same "
"as for the ``\"store\"`` action."
msgstr ""
"Standardvärdena för :attr:`~Option.type` och :attr:`~Option.dest` är desamma "
"som för åtgärden ``\"store\"``."

msgid ""
"parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"
msgstr ""
"parser.add_option(\"-t\", \"--tracks\", action=\"append\", type=\"int\")"

msgid ""
"If ``-t3`` is seen on the command-line, :mod:`optparse` does the equivalent "
"of::"
msgstr "Om ``-t3`` visas på kommandoraden gör :mod:`optparse` motsvarande::"

msgid ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"
msgstr ""
"options.tracks = []\n"
"options.tracks.append(int(\"3\"))"

msgid "If, a little later on, ``--tracks=4`` is seen, it does::"
msgstr "Om man lite senare ser ``--tracks=4`` så gör den det::"

msgid "options.tracks.append(int(\"4\"))"
msgstr "options.tracks.append(int(\"4\"))"

msgid ""
"The ``append`` action calls the ``append`` method on the current value of "
"the option.  This means that any default value specified must have an "
"``append`` method.  It also means that if the default value is non-empty, "
"the default elements will be present in the parsed value for the option, "
"with any values from the command line appended after those default values::"
msgstr ""
"Åtgärden ``append`` anropar metoden ``append`` på det aktuella värdet för "
"alternativet.  Detta innebär att alla standardvärden som anges måste ha en "
"``append``-metod.  Det innebär också att om standardvärdet inte är tomt "
"kommer standardelementen att finnas i det analyserade värdet för "
"alternativet, med eventuella värden från kommandoraden tillagda efter dessa "
"standardvärden::"

msgid ""
">>> parser.add_option(\"--files\", action=\"append\", default=['~/.mypkg/"
"defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.files\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"
msgstr ""
">>> parser.add_option(\"--files\", action=\"append\", default=['~/.mypkg/"
"defaults'])\n"
">>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])\n"
">>> opts.filer\n"
"['~/.mypkg/defaults', 'overrides.mypkg']"

msgid ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"

msgid ""
"Like ``\"store_const\"``, but the value :attr:`~Option.const` is appended "
"to :attr:`~Option.dest`; as with ``\"append\"``, :attr:`~Option.dest` "
"defaults to ``None``, and an empty list is automatically created the first "
"time the option is encountered."
msgstr ""
"Som ``\"store_const\"``, men värdet :attr:`~Option.const` läggs till :attr:"
"`~Option.dest`; som med ``\"append\"``, är :attr:`~Option.dest` "
"standardvärdet ``None``, och en tom lista skapas automatiskt första gången "
"alternativet påträffas."

msgid "``\"count\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"count\"`` [relevant: :attr:`~Option.dest`]"

msgid ""
"Increment the integer stored at :attr:`~Option.dest`.  If no default value "
"is supplied, :attr:`~Option.dest` is set to zero before being incremented "
"the first time."
msgstr ""
"Ökar det heltal som lagras i :attr:`~Option.dest`.  Om inget standardvärde "
"anges, sätts :attr:`~Option.dest` till noll innan det ökas första gången."

msgid "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"
msgstr "parser.add_option(\"-v\", action=\"count\", dest=\"verbosity\")"

msgid ""
"The first time ``-v`` is seen on the command line, :mod:`optparse` does the "
"equivalent of::"
msgstr ""
"Första gången ``-v`` syns på kommandoraden gör :mod:`optparse` motsvarande::"

msgid ""
"options.verbosity = 0\n"
"options.verbosity += 1"
msgstr ""
"options.verbosity = 0\n"
"options.verbosity += 1"

msgid "Every subsequent occurrence of ``-v`` results in  ::"
msgstr "Varje efterföljande förekomst av ``-v`` resulterar i ::"

msgid "options.verbosity += 1"
msgstr "options.verbosity += 1"

msgid ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"
msgstr ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"

msgid ""
"Call the function specified by :attr:`~Option.callback`, which is called "
"as ::"
msgstr ""
"Anropa den funktion som anges av :attr:`~Option.callback`, som anropas som ::"

msgid "func(option, opt_str, value, parser, *args, **kwargs)"
msgstr "func(option, opt_str, värde, parser, *args, **kwargs)"

msgid "See section :ref:`optparse-option-callbacks` for more detail."
msgstr "Se avsnitt :ref:`optparse-option-callbacks` för mer information."

msgid ""
"Prints a complete help message for all the options in the current option "
"parser.  The help message is constructed from the ``usage`` string passed to "
"OptionParser's constructor and the :attr:`~Option.help` string passed to "
"every option."
msgstr ""
"Skriver ut ett komplett hjälpmeddelande för alla alternativ i den aktuella "
"alternativparsern.  Hjälpmeddelandet konstrueras utifrån strängen ``usage`` "
"som skickas till OptionParser-konstruktören och strängen :attr:`~Option."
"help` som skickas till varje alternativ."

msgid ""
"If no :attr:`~Option.help` string is supplied for an option, it will still "
"be listed in the help message.  To omit an option entirely, use the special "
"value :const:`optparse.SUPPRESS_HELP`."
msgstr ""
"Om ingen :attr:`~Option.help`-sträng anges för ett alternativ kommer det "
"ändå att anges i hjälpmeddelandet.  Om du vill utelämna ett alternativ helt "
"använder du specialvärdet :const:`optparse.SUPPRESS_HELP`."

msgid ""
":mod:`optparse` automatically adds a :attr:`~Option.help` option to all "
"OptionParsers, so you do not normally need to create one."
msgstr ""
":mod:`optparse` lägger automatiskt till ett :attr:`~Option.help`-alternativ "
"till alla OptionParsers, så du behöver normalt inte skapa ett."

msgid ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# usually, a help option is added automatically, but that can\n"
"# be suppressed using the add_help_option argument\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Be moderately verbose\")\n"
"parser.add_option(\"--file\", dest=\"filename\",\n"
"                  help=\"Input file to read data from\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"
msgstr ""
"from optparse import OptionParser, SUPPRESS_HELP\n"
"\n"
"# vanligtvis läggs ett hjälpalternativ till automatiskt, men det kan\n"
"# undertryckas med hjälp av argumentet add_help_option\n"
"parser = OptionParser(add_help_option=False)\n"
"\n"
"parser.add_option(\"-h\", \"--help\", action=\"help\")\n"
"parser.add_option(\"-v\", action=\"store_true\", dest=\"verbose\",\n"
"                  help=\"Var måttligt utförlig\")\n"
"parser.add_option(\"--file\", dest=\"filnamn\",\n"
"                  help=\"Inmatningsfil att läsa data från\")\n"
"parser.add_option(\"--secret\", help=SUPPRESS_HELP)"

msgid ""
"If :mod:`optparse` sees either ``-h`` or ``--help`` on the command line, it "
"will print something like the following help message to stdout (assuming "
"``sys.argv[0]`` is ``\"foo.py\"``):"
msgstr ""
"Om :mod:`optparse` ser antingen ``-h`` eller ``--help`` på kommandoraden "
"kommer den att skriva ut något i stil med följande hjälpmeddelande till "
"stdout (förutsatt att ``sys.argv[0]`` är ``\"foo.py\"``):"

msgid ""
"Usage: foo.py [options]\n"
"\n"
"Options:\n"
"  -h, --help        Show this help message and exit\n"
"  -v                Be moderately verbose\n"
"  --file=FILENAME   Input file to read data from"
msgstr ""
"Användning: foo.py [alternativ]\n"
"\n"
"Alternativ:\n"
"  -h, --help Visa detta hjälpmeddelande och avsluta\n"
"  -v Var måttligt utförlig\n"
"  --file=FILENAME Inmatningsfil att läsa data från"

msgid ""
"After printing the help message, :mod:`optparse` terminates your process "
"with ``sys.exit(0)``."
msgstr ""
"Efter att ha skrivit ut hjälpmeddelandet avslutar :mod:`optparse` din "
"process med ``sys.exit(0)``."

msgid "``\"version\"``"
msgstr "``\"version\"``"

msgid ""
"Prints the version number supplied to the OptionParser to stdout and exits. "
"The version number is actually formatted and printed by the "
"``print_version()`` method of OptionParser.  Generally only relevant if the "
"``version`` argument is supplied to the OptionParser constructor.  As with :"
"attr:`~Option.help` options, you will rarely create ``version`` options, "
"since :mod:`optparse` automatically adds them when needed."
msgstr ""
"Skriver ut versionsnumret som angetts till OptionParser på stdout och "
"avslutar. Versionsnumret formateras faktiskt och skrivs ut med metoden "
"``print_version()`` i OptionParser.  I allmänhet endast relevant om "
"argumentet ``version`` anges i OptionParser-konstruktören.  Precis som med :"
"attr:`~Option.help`-alternativen kommer du sällan att skapa ``version``-"
"alternativ, eftersom :mod:`optparse` automatiskt lägger till dem när de "
"behövs."

msgid "Standard option types"
msgstr "Typer av standardtillval"

msgid ""
":mod:`optparse` has five built-in option types: ``\"string\"``, ``\"int\"``, "
"``\"choice\"``, ``\"float\"`` and ``\"complex\"``.  If you need to add new "
"option types, see section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` har fem inbyggda alternativtyper: ``\"string\"``, "
"``\"int\"``, ``\"choice\"``, ``\"float\"`` och ``\"complex\"``.  Om du "
"behöver lägga till nya alternativtyper, se avsnitt :ref:`optparse-extending-"
"optparse`."

msgid ""
"Arguments to string options are not checked or converted in any way: the "
"text on the command line is stored in the destination (or passed to the "
"callback) as-is."
msgstr ""
"Argument till strängalternativ kontrolleras eller konverteras inte på något "
"sätt: texten på kommandoraden lagras i destinationen (eller skickas till "
"återuppringningen) som den är."

msgid "Integer arguments (type ``\"int\"``) are parsed as follows:"
msgstr "Heltalsargument (typ ``\"int\"``) tolkas på följande sätt:"

msgid "if the number starts with ``0x``, it is parsed as a hexadecimal number"
msgstr "om talet börjar med ``0x``, tolkas det som ett hexadecimalt tal"

msgid "if the number starts with ``0``, it is parsed as an octal number"
msgstr "om talet börjar med ``0``, tolkas det som ett oktalt tal"

msgid "if the number starts with ``0b``, it is parsed as a binary number"
msgstr "om talet börjar med ``0b``, tolkas det som ett binärt tal"

msgid "otherwise, the number is parsed as a decimal number"
msgstr "annars tolkas talet som ett decimaltal"

msgid ""
"The conversion is done by calling :func:`int` with the appropriate base (2, "
"8, 10, or 16).  If this fails, so will :mod:`optparse`, although with a more "
"useful error message."
msgstr ""
"Omvandlingen görs genom att anropa :func:`int` med lämplig bas (2, 8, 10 "
"eller 16).  Om detta misslyckas, gör även :mod:`optparse` det, men med ett "
"mer användbart felmeddelande."

msgid ""
"``\"float\"`` and ``\"complex\"`` option arguments are converted directly "
"with :func:`float` and :func:`complex`, with similar error-handling."
msgstr ""
"alternativargumenten ``\"float\"`` och ``\"complex\"`` konverteras direkt "
"med :func:`float` och :func:`complex`, med liknande felhantering."

msgid ""
"``\"choice\"`` options are a subtype of ``\"string\"`` options.  The :attr:"
"`~Option.choices` option attribute (a sequence of strings) defines the set "
"of allowed option arguments.  :func:`optparse.check_choice` compares user-"
"supplied option arguments against this master list and raises :exc:"
"`OptionValueError` if an invalid string is given."
msgstr ""
"``\"choice\"``-alternativ är en subtyp av ``\"string\"``-alternativ.  "
"Alternativattributet :attr:`~Option.choices` (en sekvens av strängar) "
"definierar uppsättningen av tillåtna alternativargument. :func:`optparse."
"check_choice` jämför användartillhandahållna alternativargument mot denna "
"huvudlista och ger upphov till :exc:`OptionValueError` om en ogiltig sträng "
"anges."

msgid "Parsing arguments"
msgstr "Tolkning av argument"

msgid ""
"The whole point of creating and populating an OptionParser is to call its :"
"meth:`~OptionParser.parse_args` method."
msgstr ""
"Hela poängen med att skapa och fylla i en OptionParser är att anropa dess :"
"meth:`~OptionParser.parse_args`-metod."

msgid "Parse the command-line options found in *args*."
msgstr "Analyserar kommandoradsalternativen som finns i *args*."

msgid "The input parameters are"
msgstr "Ingångsparametrarna är"

msgid "``args``"
msgstr "``args``"

msgid "the list of arguments to process (default: ``sys.argv[1:]``)"
msgstr "listan med argument som ska bearbetas (standard: ``sys.argv[1:]``)"

msgid "``values``"
msgstr "``värden``"

msgid ""
"a :class:`Values` object to store option arguments in (default: a new "
"instance of :class:`Values`) -- if you give an existing object, the option "
"defaults will not be initialized on it"
msgstr ""
"ett :class:`Values`-objekt att lagra alternativargument i (standard: en ny "
"instans av :class:`Values`) -- om du anger ett befintligt objekt kommer "
"alternativinställningarna inte att initialiseras på det"

msgid "and the return value is a pair ``(options, args)`` where"
msgstr "och returvärdet är ett par ``(options, args)`` där"

msgid "``options``"
msgstr "``alternativ``"

msgid ""
"the same object that was passed in as *values*, or the ``optparse.Values`` "
"instance created by :mod:`optparse`"
msgstr ""
"samma objekt som skickades in som *values*, eller instansen ``optparse."
"Values`` som skapades av :mod:`optparse`"

msgid "the leftover positional arguments after all options have been processed"
msgstr ""
"de kvarvarande positionsargumenten efter att alla alternativ har behandlats"

msgid ""
"The most common usage is to supply neither keyword argument.  If you supply "
"``values``, it will be modified with repeated :func:`setattr` calls (roughly "
"one for every option argument stored to an option destination) and returned "
"by :meth:`~OptionParser.parse_args`."
msgstr ""
"Den vanligaste användningen är att inte ange något nyckelordsargument.  Om "
"du anger ``values`` kommer det att modifieras med upprepade :func:`setattr`-"
"anrop (ungefär ett för varje alternativargument som lagras i en "
"alternativdestination) och returneras av :meth:`~OptionParser.parse_args`."

msgid ""
"If :meth:`~OptionParser.parse_args` encounters any errors in the argument "
"list, it calls the OptionParser's :meth:`error` method with an appropriate "
"end-user error message. This ultimately terminates your process with an exit "
"status of 2 (the traditional Unix exit status for command-line errors)."
msgstr ""
"Om :meth:`~OptionParser.parse_args` stöter på några fel i argumentlistan "
"anropas OptionParsers metod :meth:`error` med ett lämpligt felmeddelande för "
"slutanvändaren. Detta avslutar slutligen din process med en utgångsstatus på "
"2 (den traditionella Unix-utgångsstatusen för kommandoradsfel)."

msgid "Querying and manipulating your option parser"
msgstr "Förfrågan och manipulering av din optionsparser"

msgid ""
"The default behavior of the option parser can be customized slightly, and "
"you can also poke around your option parser and see what's there.  "
"OptionParser provides several methods to help you out:"
msgstr ""
"Standardbeteendet för optionsparsern kan anpassas något, och du kan också "
"rota runt i din optionsparser och se vad som finns där.  OptionParser "
"tillhandahåller flera metoder för att hjälpa dig:"

msgid ""
"Set parsing to stop on the first non-option.  For example, if ``-a`` and ``-"
"b`` are both simple options that take no arguments, :mod:`optparse` normally "
"accepts this syntax::"
msgstr ""
"Ställ in parsning så att den stoppas vid det första icke-alternativet.  Till "
"exempel, om ``-a`` och ``-b`` båda är enkla alternativ som inte tar några "
"argument, accepterar :mod:`optparse` normalt denna syntax::"

msgid "prog -a arg1 -b arg2"
msgstr "prog -a arg1 -b arg2"

msgid "and treats it as equivalent to  ::"
msgstr "och behandlar det som likvärdigt med ::"

msgid "prog -a -b arg1 arg2"
msgstr "prog -a -b arg1 arg2"

msgid ""
"To disable this feature, call :meth:`disable_interspersed_args`.  This "
"restores traditional Unix syntax, where option parsing stops with the first "
"non-option argument."
msgstr ""
"För att inaktivera den här funktionen, anropa :meth:"
"`disable_interspersed_args`.  Detta återställer traditionell Unix-syntax, "
"där parsning av alternativ slutar med det första argumentet som inte är ett "
"alternativ."

msgid ""
"Use this if you have a command processor which runs another command which "
"has options of its own and you want to make sure these options don't get "
"confused.  For example, each command might have a different set of options."
msgstr ""
"Använd detta om du har en kommandoprocessor som kör ett annat kommando som "
"har egna alternativ och du vill se till att dessa alternativ inte blandas "
"ihop.  Varje kommando kan t.ex. ha olika uppsättningar alternativ."

msgid ""
"Set parsing to not stop on the first non-option, allowing interspersing "
"switches with command arguments.  This is the default behavior."
msgstr ""
"Ställ in parsning så att den inte stoppas vid det första icke-alternativet, "
"vilket gör det möjligt att varva omkopplare med kommandoparametrar.  Detta "
"är standardbeteendet."

msgid ""
"Returns the Option instance with the option string *opt_str*, or ``None`` if "
"no options have that option string."
msgstr ""
"Returnerar Option-instansen med optionssträngen *opt_str*, eller ``None`` om "
"inga optioner har den optionssträngen."

msgid ""
"Return ``True`` if the OptionParser has an option with option string "
"*opt_str* (e.g., ``-q`` or ``--verbose``)."
msgstr ""
"Returnerar ``True`` om OptionParser har ett alternativ med "
"alternativsträngen *opt_str* (t.ex. ``-q`` eller ``--verbose``)."

msgid ""
"If the :class:`OptionParser` has an option corresponding to *opt_str*, that "
"option is removed.  If that option provided any other option strings, all of "
"those option strings become invalid. If *opt_str* does not occur in any "
"option belonging to this :class:`OptionParser`, raises :exc:`ValueError`."
msgstr ""
"Om :class:`OptionParser` har ett alternativ som motsvarar *opt_str*, tas det "
"alternativet bort.  Om det alternativet innehöll några andra "
"alternativsträngar, blir alla dessa alternativsträngar ogiltiga. Om "
"*opt_str* inte förekommer i något alternativ som tillhör denna :class:"
"`OptionParser`, utlöses :exc:`ValueError`."

msgid "Conflicts between options"
msgstr "Konflikter mellan olika alternativ"

msgid ""
"If you're not careful, it's easy to define options with conflicting option "
"strings::"
msgstr ""
"Om du inte är försiktig är det lätt att definiera alternativ med motstridiga "
"alternativsträngar::"

msgid ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"
msgstr ""
"parser.add_option(\"-n\", \"--dry-run\", ...)\n"
"...\n"
"parser.add_option(\"-n\", \"--noisy\", ...)"

msgid ""
"(This is particularly true if you've defined your own OptionParser subclass "
"with some standard options.)"
msgstr ""
"(Detta gäller i synnerhet om du har definierat din egen OptionParser-"
"underklass med några standardalternativ)"

msgid ""
"Every time you add an option, :mod:`optparse` checks for conflicts with "
"existing options.  If it finds any, it invokes the current conflict-handling "
"mechanism. You can set the conflict-handling mechanism either in the "
"constructor::"
msgstr ""
"Varje gång du lägger till ett alternativ kontrollerar :mod:`optparse` om det "
"finns konflikter med befintliga alternativ.  Om den hittar några, anropar "
"den den aktuella konflikthanteringsmekanismen. Du kan ställa in "
"konflikthanteringsmekanismen antingen i konstruktören::"

msgid "parser = OptionParser(..., conflict_handler=handler)"
msgstr "parser = OptionParser(..., conflict_handler=handler)"

msgid "or with a separate call::"
msgstr "eller med ett separat anrop::"

msgid "parser.set_conflict_handler(handler)"
msgstr "parser.set_conflict_handler(handler)"

msgid "The available conflict handlers are:"
msgstr "De tillgängliga konflikthanterarna är:"

msgid "``\"error\"`` (default)"
msgstr "``\"error\"`` (standard)"

msgid ""
"assume option conflicts are a programming error and raise :exc:"
"`OptionConflictError`"
msgstr ""
"anta att optionskonflikter är ett programmeringsfel och skapa :exc:"
"`OptionConflictError`"

msgid "``\"resolve\"``"
msgstr "``\"resolve\"``"

msgid "resolve option conflicts intelligently (see below)"
msgstr "lösa optionskonflikter på ett intelligent sätt (se nedan)"

msgid ""
"As an example, let's define an :class:`OptionParser` that resolves conflicts "
"intelligently and add conflicting options to it::"
msgstr ""
"Som ett exempel kan vi definiera en :class:`OptionParser` som löser "
"konflikter på ett intelligent sätt och lägga till konfliktfyllda alternativ "
"i den::"

msgid ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\", \"--dry-run\", ..., help=\"do no harm\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"be noisy\")"
msgstr ""
"parser = OptionParser(conflict_handler=\"resolve\")\n"
"parser.add_option(\"-n\",\"--dry-run\", ..., help=\"gör ingen skada\")\n"
"parser.add_option(\"-n\", \"--noisy\", ..., help=\"var högljudd\")"

msgid ""
"At this point, :mod:`optparse` detects that a previously added option is "
"already using the ``-n`` option string.  Since ``conflict_handler`` is "
"``\"resolve\"``, it resolves the situation by removing ``-n`` from the "
"earlier option's list of option strings.  Now ``--dry-run`` is the only way "
"for the user to activate that option.  If the user asks for help, the help "
"message will reflect that::"
msgstr ""
"Vid denna punkt upptäcker :mod:`optparse` att ett tidigare tillagt "
"alternativ redan använder alternativsträngen ``-n``.  Eftersom "
"``conflict_handler`` är ``\"resolve\"``, löser den situationen genom att ta "
"bort ``-n`` från det tidigare alternativets lista över alternativsträngar.  "
"Nu är ``--dry-run`` det enda sättet för användaren att aktivera det "
"alternativet.  Om användaren ber om hjälp kommer detta att framgå av "
"hjälpmeddelandet:"

msgid ""
"Options:\n"
"  --dry-run     do no harm\n"
"  ...\n"
"  -n, --noisy   be noisy"
msgstr ""
"Alternativ:\n"
"  --dry-run gör ingen skada\n"
"  ...\n"
"  -n, --noisy vara högljudd"

msgid ""
"It's possible to whittle away the option strings for a previously added "
"option until there are none left, and the user has no way of invoking that "
"option from the command-line.  In that case, :mod:`optparse` removes that "
"option completely, so it doesn't show up in help text or anywhere else. "
"Carrying on with our existing OptionParser::"
msgstr ""
"Det är möjligt att ta bort alternativsträngarna för ett tidigare tillagt "
"alternativ tills det inte finns några kvar, och användaren inte har något "
"sätt att använda alternativet från kommandoraden.  I så fall tar :mod:"
"`optparse` bort alternativet helt och hållet, så att det inte visas i "
"hjälptexten eller någon annanstans. Fortsätter med vår befintliga "
"OptionParser::"

msgid "parser.add_option(\"--dry-run\", ..., help=\"new dry-run option\")"
msgstr ""
"parser.add_option(\"--dry-run\", ..., help=\"nytt alternativ för "
"torrkörning\")"

msgid ""
"At this point, the original ``-n``/``--dry-run`` option is no longer "
"accessible, so :mod:`optparse` removes it, leaving this help text::"
msgstr ""
"Vid denna tidpunkt är det ursprungliga alternativet ``-n``/``--dry-run`` "
"inte längre tillgängligt, så :mod:`optparse` tar bort det och lämnar denna "
"hjälptext::"

msgid ""
"Options:\n"
"  ...\n"
"  -n, --noisy   be noisy\n"
"  --dry-run     new dry-run option"
msgstr ""
"Alternativ:\n"
"  ...\n"
"  -n, --noisy vara högljudd\n"
"  --dry-run nytt alternativ för torrkörning"

msgid "Cleanup"
msgstr "Rensa upp"

msgid ""
"OptionParser instances have several cyclic references.  This should not be a "
"problem for Python's garbage collector, but you may wish to break the cyclic "
"references explicitly by calling :meth:`~OptionParser.destroy` on your "
"OptionParser once you are done with it.  This is particularly useful in long-"
"running applications where large object graphs are reachable from your "
"OptionParser."
msgstr ""
"OptionParser-instanser har flera cykliska referenser.  Detta bör inte vara "
"något problem för Pythons skräpsamlare, men du kanske vill bryta de cykliska "
"referenserna explicit genom att anropa :meth:`~OptionParser.destroy` på din "
"OptionParser när du är klar med den.  Detta är särskilt användbart i "
"långkörande applikationer där stora objektgrafer kan nås från din "
"OptionParser."

msgid "Other methods"
msgstr "Andra metoder"

msgid "OptionParser supports several other public methods:"
msgstr "OptionParser stöder flera andra publika metoder:"

msgid ""
"Set the usage string according to the rules described above for the "
"``usage`` constructor keyword argument.  Passing ``None`` sets the default "
"usage string; use :const:`optparse.SUPPRESS_USAGE` to suppress a usage "
"message."
msgstr ""
"Ställ in användningssträngen enligt de regler som beskrivs ovan för "
"nyckelordsargumentet ``usage`` i konstruktören.  Om du skickar ``None`` "
"anges standardanvändningssträngen; använd :const:`optparse.SUPPRESS_USAGE` "
"för att undertrycka ett användningsmeddelande."

msgid ""
"Print the usage message for the current program (``self.usage``) to *file* "
"(default stdout).  Any occurrence of the string ``%prog`` in ``self.usage`` "
"is replaced with the name of the current program.  Does nothing if ``self."
"usage`` is empty or not defined."
msgstr ""
"Skriv ut användningsmeddelandet för det aktuella programmet (``self.usage``) "
"till *fil* (standard stdout).  Alla förekomster av strängen ``%prog`` i "
"``self.usage`` ersätts med namnet på det aktuella programmet.  Gör ingenting "
"om ``self.usage`` är tom eller inte definierad."

msgid ""
"Same as :meth:`print_usage` but returns the usage string instead of printing "
"it."
msgstr ""
"Samma sak som :meth:`print_usage` men returnerar användningssträngen i "
"stället för att skriva ut den."

msgid ""
"Set default values for several option destinations at once.  Using :meth:"
"`set_defaults` is the preferred way to set default values for options, since "
"multiple options can share the same destination.  For example, if several "
"\"mode\" options all set the same destination, any one of them can set the "
"default, and the last one wins::"
msgstr ""
"Ange standardvärden för flera alternativdestinationer på en gång.  Att "
"använda :meth:`set_defaults` är det bästa sättet att ange standardvärden för "
"alternativ, eftersom flera alternativ kan dela samma destination.  Om t.ex. "
"flera \"mode\"-alternativ anger samma destination kan vilket som helst av "
"dem ange standardvärdet, och det sista alternativet vinner:"

msgid ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"novice\")    # overridden below\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"advanced\")  # overrides above setting"
msgstr ""
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\",\n"
"                  default=\"nybörjare\")    # åsidosätts nedan\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\",\n"
"                  default=\"avancerad\")  # åsidosätter ovanstående "
"inställning"

msgid "To avoid this confusion, use :meth:`set_defaults`::"
msgstr "För att undvika denna förvirring, använd :meth:`set_defaults`::"

msgid ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"
msgstr ""
"parser.set_defaults(mode=\"advanced\")\n"
"parser.add_option(\"--advanced\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"advanced\")\n"
"parser.add_option(\"--novice\", action=\"store_const\",\n"
"                  dest=\"mode\", const=\"novice\")"

msgid "Option Callbacks"
msgstr "Option Callbacks"

msgid ""
"When :mod:`optparse`'s built-in actions and types aren't quite enough for "
"your needs, you have two choices: extend :mod:`optparse` or define a "
"callback option. Extending :mod:`optparse` is more general, but overkill for "
"a lot of simple cases.  Quite often a simple callback is all you need."
msgstr ""
"När :mod:`optparse`:s inbyggda åtgärder och typer inte räcker till för dina "
"behov har du två val: utöka :mod:`optparse` eller definiera ett "
"återuppringningsalternativ. Att utöka :mod:`optparse` är mer generellt, men "
"överdrivet i många enkla fall.  Ofta är en enkel återuppringning allt du "
"behöver."

msgid "There are two steps to defining a callback option:"
msgstr "Det finns två steg för att definiera ett callback-alternativ:"

msgid "define the option itself using the ``\"callback\"`` action"
msgstr "definiera själva alternativet med hjälp av åtgärden ``\"callback\"``"

msgid ""
"write the callback; this is a function (or method) that takes at least four "
"arguments, as described below"
msgstr ""
"skriv återuppringningen; detta är en funktion (eller metod) som tar minst "
"fyra argument, enligt beskrivningen nedan"

msgid "Defining a callback option"
msgstr "Definiera ett återuppringningsalternativ"

msgid ""
"As always, the easiest way to define a callback option is by using the :meth:"
"`OptionParser.add_option` method.  Apart from :attr:`~Option.action`, the "
"only option attribute you must specify is ``callback``, the function to "
"call::"
msgstr ""
"Som alltid är det enklaste sättet att definiera ett callback-alternativ att "
"använda metoden :meth:`OptionParser.add_option`.  Förutom :attr:`~Option."
"action` är det enda alternativattributet du måste ange ``callback``, "
"funktionen som ska anropas::"

msgid "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"
msgstr "parser.add_option(\"-c\", action=\"callback\", callback=my_callback)"

msgid ""
"``callback`` is a function (or other callable object), so you must have "
"already defined ``my_callback()`` when you create this callback option. In "
"this simple case, :mod:`optparse` doesn't even know if ``-c`` takes any "
"arguments, which usually means that the option takes no arguments---the mere "
"presence of ``-c`` on the command-line is all it needs to know.  In some "
"circumstances, though, you might want your callback to consume an arbitrary "
"number of command-line arguments.  This is where writing callbacks gets "
"tricky; it's covered later in this section."
msgstr ""
"``callback`` är en funktion (eller annat anropbart objekt), så du måste "
"redan ha definierat ``my_callback()`` när du skapar detta callback-"
"alternativ. I det här enkla fallet vet :mod:`optparse` inte ens om ``-c`` "
"tar några argument, vilket vanligtvis betyder att alternativet inte tar "
"några argument--den blotta närvaron av ``-c`` på kommandoraden är allt den "
"behöver veta.  Under vissa omständigheter kan du dock vilja att din "
"återuppringning ska konsumera ett godtyckligt antal kommandoradsargument.  "
"Det är här det blir knepigt att skriva återuppringningar; det täcks senare i "
"detta avsnitt."

msgid ""
":mod:`optparse` always passes four particular arguments to your callback, "
"and it will only pass additional arguments if you specify them via :attr:"
"`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus, the "
"minimal callback function signature is::"
msgstr ""
":mod:`optparse` skickar alltid fyra specifika argument till din "
"återuppringning, och den skickar bara ytterligare argument om du anger dem "
"via :attr:`~Option.callback_args` och :attr:`~Option.callback_kwargs`.  Den "
"minimala signaturen för en callback-funktion är alltså::"

msgid "def my_callback(option, opt, value, parser):"
msgstr "def my_callback(option, opt, värde, parser):"

msgid "The four arguments to a callback are described below."
msgstr "De fyra argumenten till en callback beskrivs nedan."

msgid ""
"There are several other option attributes that you can supply when you "
"define a callback option:"
msgstr ""
"Det finns flera andra optionsattribut som du kan ange när du definierar ett "
"callback-alternativ:"

msgid ":attr:`~Option.type`"
msgstr ":attr:`~Option.typ`"

msgid ""
"has its usual meaning: as with the ``\"store\"`` or ``\"append\"`` actions, "
"it instructs :mod:`optparse` to consume one argument and convert it to :attr:"
"`~Option.type`.  Rather than storing the converted value(s) anywhere, "
"though, :mod:`optparse` passes it to your callback function."
msgstr ""
"har sin vanliga betydelse: som med åtgärderna ``\"store\"`` eller "
"``\"append\"`` instruerar den :mod:`optparse` att ta emot ett argument och "
"konvertera det till :attr:`~Option.type`.  Istället för att lagra det "
"konverterade värdet någonstans, skickar :mod:`optparse` det till din "
"återuppringningsfunktion."

msgid ":attr:`~Option.nargs`"
msgstr ":attr:`~Option.nargs`"

msgid ""
"also has its usual meaning: if it is supplied and > 1, :mod:`optparse` will "
"consume :attr:`~Option.nargs` arguments, each of which must be convertible "
"to :attr:`~Option.type`.  It then passes a tuple of converted values to your "
"callback."
msgstr ""
"har också sin vanliga betydelse: om den anges och > 1, kommer :mod:"
"`optparse` att använda :attr:`~Option.nargs`-argument, som alla måste kunna "
"konverteras till :attr:`~Option.type`.  Den skickar sedan en tupel av "
"konverterade värden till din callback."

msgid ":attr:`~Option.callback_args`"
msgstr ":attr:`~Option.callback_args`"

msgid "a tuple of extra positional arguments to pass to the callback"
msgstr ""
"en tupel av extra positionella argument som ska skickas till "
"återuppringningen"

msgid ":attr:`~Option.callback_kwargs`"
msgstr ":attr:`~Option.callback_kwargs`"

msgid "a dictionary of extra keyword arguments to pass to the callback"
msgstr ""
"en ordbok med extra nyckelordsargument som ska skickas till återuppringningen"

msgid "How callbacks are called"
msgstr "Hur återuppringningar anropas"

msgid "All callbacks are called as follows::"
msgstr "Alla callbacks anropas på följande sätt::"

msgid "``option``"
msgstr "``alternativ``"

msgid "is the Option instance that's calling the callback"
msgstr "är den Option-instans som anropar återuppringningen"

msgid "``opt_str``"
msgstr "``opt_str``"

msgid ""
"is the option string seen on the command-line that's triggering the "
"callback. (If an abbreviated long option was used, ``opt_str`` will be the "
"full, canonical option string---e.g. if the user puts ``--foo`` on the "
"command-line as an abbreviation for ``--foobar``, then ``opt_str`` will be "
"``\"--foobar\"``.)"
msgstr ""
"är den alternativsträng som sågs på kommandoraden och som utlöser "
"återuppringningen. (Om ett förkortat långt alternativ användes kommer "
"``opt_str`` att vara den fullständiga, kanoniska alternativsträngen - t.ex. "
"om användaren anger ``--foo`` på kommandoraden som en förkortning för ``--"
"foobar`` kommer ``opt_str`` att vara ``\"--foobar\"``.)"

msgid "``value``"
msgstr "``värde``"

msgid ""
"is the argument to this option seen on the command-line.  :mod:`optparse` "
"will only expect an argument if :attr:`~Option.type` is set; the type of "
"``value`` will be the type implied by the option's type.  If :attr:`~Option."
"type` for this option is ``None`` (no argument expected), then ``value`` "
"will be ``None``.  If :attr:`~Option.nargs` > 1, ``value`` will be a tuple "
"of values of the appropriate type."
msgstr ""
"är argumentet till detta alternativ sett på kommandoraden. :mod:`optparse` "
"förväntar sig bara ett argument om :attr:`~Option.type` är inställd; typen "
"av ``value`` kommer att vara den typ som impliceras av alternativets typ.  "
"Om :attr:`~Option.type` för detta alternativ är ``None`` (inget argument "
"förväntas), kommer ``value`` att vara ``None``.  Om :attr:`~Option.nargs` > "
"1, kommer ``value`` att vara en tupel av värden av lämplig typ."

msgid "``parser``"
msgstr "``parser``"

msgid ""
"is the OptionParser instance driving the whole thing, mainly useful because "
"you can access some other interesting data through its instance attributes:"
msgstr ""
"är OptionParser-instansen som driver det hela, främst användbar eftersom du "
"kan komma åt några andra intressanta data via dess instansattribut:"

msgid "``parser.largs``"
msgstr "``parser.largs``"

msgid ""
"the current list of leftover arguments, ie. arguments that have been "
"consumed but are neither options nor option arguments. Feel free to modify "
"``parser.largs``, e.g. by adding more arguments to it.  (This list will "
"become ``args``, the second return value of :meth:`~OptionParser."
"parse_args`.)"
msgstr ""
"den aktuella listan med kvarvarande argument, dvs. argument som har använts "
"men som varken är alternativ eller alternativargument. Känn dig fri att "
"modifiera ``parser.largs``, t.ex. genom att lägga till fler argument.  "
"(Denna lista kommer att bli ``args``, det andra returvärdet av :meth:"
"`~OptionParser.parse_args`.)"

msgid "``parser.rargs``"
msgstr "``parser.rargs``"

msgid ""
"the current list of remaining arguments, ie. with ``opt_str`` and ``value`` "
"(if applicable) removed, and only the arguments following them still there.  "
"Feel free to modify ``parser.rargs``, e.g. by consuming more arguments."
msgstr ""
"den aktuella listan med återstående argument, dvs. med ``opt_str`` och "
"``value`` (om tillämpligt) borttagna, och endast argumenten efter dem finns "
"kvar.  Modifiera gärna ``parser.rargs``, t.ex. genom att använda fler "
"argument."

msgid "``parser.values``"
msgstr "``parser.värden``"

msgid ""
"the object where option values are by default stored (an instance of "
"optparse.OptionValues).  This lets callbacks use the same mechanism as the "
"rest of :mod:`optparse` for storing option values; you don't need to mess "
"around with globals or closures.  You can also access or modify the value(s) "
"of any options already encountered on the command-line."
msgstr ""
"objektet där alternativvärdena lagras som standard (en instans av optparse."
"OptionValues).  Detta gör att återuppringningar kan använda samma mekanism "
"som resten av :mod:`optparse` för att lagra alternativvärden; du behöver "
"inte röra runt med globaler eller stängningar.  Du kan också komma åt eller "
"ändra värdet/värdena för alla alternativ som redan finns på kommandoraden."

msgid ""
"is a tuple of arbitrary positional arguments supplied via the :attr:`~Option."
"callback_args` option attribute."
msgstr ""
"är en tupel av godtyckliga positionella argument som tillhandahålls via "
"alternativattributet :attr:`~Option.callback_args`."

msgid "``kwargs``"
msgstr "``kwargs``"

msgid ""
"is a dictionary of arbitrary keyword arguments supplied via :attr:`~Option."
"callback_kwargs`."
msgstr ""
"är en ordbok med godtyckliga nyckelordsargument som tillhandahålls via :attr:"
"`~Option.callback_kwargs`."

msgid "Raising errors in a callback"
msgstr "Felmeddelanden i en callback"

msgid ""
"The callback function should raise :exc:`OptionValueError` if there are any "
"problems with the option or its argument(s).  :mod:`optparse` catches this "
"and terminates the program, printing the error message you supply to "
"stderr.  Your message should be clear, concise, accurate, and mention the "
"option at fault. Otherwise, the user will have a hard time figuring out what "
"they did wrong."
msgstr ""
"Återkallningsfunktionen bör ge upphov till :exc:`OptionValueError` om det "
"finns några problem med alternativet eller dess argument. :mod:`optparse` "
"fångar upp detta och avslutar programmet genom att skriva ut det "
"felmeddelande du anger till stderr.  Meddelandet bör vara tydligt, "
"kortfattat och korrekt och nämna det felaktiga alternativet. Annars kommer "
"användaren att ha svårt att förstå vad han eller hon gjorde för fel."

msgid "Callback example 1: trivial callback"
msgstr "Exempel på återuppringning 1: trivial återuppringning"

msgid ""
"Here's an example of a callback option that takes no arguments, and simply "
"records that the option was seen::"
msgstr ""
"Här är ett exempel på ett callback-alternativ som inte tar några argument, "
"och som bara registrerar att alternativet sågs::"

msgid ""
"def record_foo_seen(option, opt_str, value, parser):\n"
"    parser.values.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", callback=record_foo_seen)"
msgstr ""
"def record_foo_seen(option, opt_str, värde, parser):\n"
"    parser.värden.saw_foo = True\n"
"\n"
"parser.add_option(\"--foo\", action=\"callback\", callback=record_foo_seen)"

msgid "Of course, you could do that with the ``\"store_true\"`` action."
msgstr "Naturligtvis kan du göra det med åtgärden ``\"store_true\"``."

msgid "Callback example 2: check option order"
msgstr "Exempel på återuppringning 2: kontrollera alternativ order"

msgid ""
"Here's a slightly more interesting example: record the fact that ``-a`` is "
"seen, but blow up if it comes after ``-b`` in the command-line.  ::"
msgstr ""
"Här är ett lite mer intressant exempel: registrera det faktum att ``-a`` "
"ses, men spräng om det kommer efter ``-b`` i kommandoraden. ::"

msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use -a after -b\")\n"
"    parser.values.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"
msgstr ""
"def check_order(option, opt_str, värde, parser):\n"
"    if parser.värden.b:\n"
"        raise OptionValueError(\"kan inte använda -a efter -b\")\n"
"    parser.värden.a = 1\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order)\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")"

msgid "Callback example 3: check option order (generalized)"
msgstr "Återkallelse exempel 3: kontrollera alternativ ordning (generaliserad)"

msgid ""
"If you want to reuse this callback for several similar options (set a flag, "
"but blow up if ``-b`` has already been seen), it needs a bit of work: the "
"error message and the flag that it sets must be generalized.  ::"
msgstr ""
"Om du vill återanvända denna återuppringning för flera liknande alternativ "
"(ställa in en flagga, men spränga om ``-b`` redan har setts), behöver den "
"lite arbete: felmeddelandet och flaggan som det ställer in måste "
"generaliseras:"

msgid ""
"def check_order(option, opt_str, value, parser):\n"
"    if parser.values.b:\n"
"        raise OptionValueError(\"can't use %s after -b\" % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, "
"dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, "
"dest='c')"
msgstr ""
"def check_order(option, opt_str, värde, parser):\n"
"    if parser.värden.b:\n"
"        raise OptionValueError(\"kan inte använda %s efter -b\" % opt_str)\n"
"    setattr(parser.värden, option.dest, 1)\n"
"...\n"
"parser.add_option(\"-a\", action=\"callback\", callback=check_order, "
"dest='a')\n"
"parser.add_option(\"-b\", action=\"store_true\", dest=\"b\")\n"
"parser.add_option(\"-c\", action=\"callback\", callback=check_order, "
"dest='c')"

msgid "Callback example 4: check arbitrary condition"
msgstr "Exempel på återuppringning 4: kontrollera godtyckligt tillstånd"

msgid ""
"Of course, you could put any condition in there---you're not limited to "
"checking the values of already-defined options.  For example, if you have "
"options that should not be called when the moon is full, all you have to do "
"is this::"
msgstr ""
"Naturligtvis kan du lägga in vilket villkor som helst där - du är inte "
"begränsad till att kontrollera värdena för redan definierade alternativ.  Om "
"du till exempel har alternativ som inte ska anropas när månen är full, "
"behöver du bara göra så här::"

msgid ""
"def check_moon(option, opt_str, value, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s option invalid when moon is full\"\n"
"                               % opt_str)\n"
"    setattr(parser.values, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=check_moon, dest=\"foo\")"
msgstr ""
"def check_moon(option, opt_str, värde, parser):\n"
"    if is_moon_full():\n"
"        raise OptionValueError(\"%s alternativet ogiltigt när månen är "
"full\"\n"
"                               % opt_str)\n"
"    setattr(parser.värden, option.dest, 1)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"återuppringning\", återuppringning=check_moon, "
"dest=\"foo\")"

msgid ""
"(The definition of ``is_moon_full()`` is left as an exercise for the reader.)"
msgstr "(Definitionen av ``is_moon_full()`` lämnas som en övning för läsaren)"

msgid "Callback example 5: fixed arguments"
msgstr "Exempel på återuppringning 5: fasta argument"

msgid ""
"Things get slightly more interesting when you define callback options that "
"take a fixed number of arguments.  Specifying that a callback option takes "
"arguments is similar to defining a ``\"store\"`` or ``\"append\"`` option: "
"if you define :attr:`~Option.type`, then the option takes one argument that "
"must be convertible to that type; if you further define :attr:`~Option."
"nargs`, then the option takes :attr:`~Option.nargs` arguments."
msgstr ""
"Saker och ting blir lite mer intressanta när du definierar callback-"
"alternativ som tar ett fast antal argument.  Att ange att ett callback-"
"alternativ tar argument liknar att definiera ett ``\"store\"`` eller "
"``\"append\"``-alternativ: om du definierar :attr:`~Option.type`, så tar "
"alternativet ett argument som måste kunna konverteras till den typen; om du "
"vidare definierar :attr:`~Option.nargs`, så tar alternativet :attr:`~Option."
"nargs`-argument."

msgid ""
"Here's an example that just emulates the standard ``\"store\"`` action::"
msgstr "Här är ett exempel som bara emulerar standardåtgärden ``\"store\"``::"

msgid ""
"def store_value(option, opt_str, value, parser):\n"
"    setattr(parser.values, option.dest, value)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"callback\", callback=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"
msgstr ""
"def store_value(option, opt_str, värde, parser):\n"
"    setattr(parser.values, option.dest, värde)\n"
"...\n"
"parser.add_option(\"--foo\",\n"
"                  action=\"återuppringning\", återuppringning=store_value,\n"
"                  type=\"int\", nargs=3, dest=\"foo\")"

msgid ""
"Note that :mod:`optparse` takes care of consuming 3 arguments and converting "
"them to integers for you; all you have to do is store them.  (Or whatever; "
"obviously you don't need a callback for this example.)"
msgstr ""
"Observera att :mod:`optparse` tar hand om att konsumera 3 argument och "
"konvertera dem till heltal åt dig; allt du behöver göra är att lagra dem.  "
"(Eller vad som helst; uppenbarligen behöver du inte en callback för det här "
"exemplet)"

msgid "Callback example 6: variable arguments"
msgstr "Callback exempel 6: variabelargument"

msgid ""
"Things get hairy when you want an option to take a variable number of "
"arguments. For this case, you must write a callback, as :mod:`optparse` "
"doesn't provide any built-in capabilities for it.  And you have to deal with "
"certain intricacies of conventional Unix command-line parsing that :mod:"
"`optparse` normally handles for you.  In particular, callbacks should "
"implement the conventional rules for bare ``--`` and ``-`` arguments:"
msgstr ""
"Det blir lite knepigt när du vill att ett alternativ ska ta ett variabelt "
"antal argument. I det här fallet måste du skriva en callback, eftersom :mod:"
"`optparse` inte har några inbyggda funktioner för det.  Och du måste hantera "
"vissa svårigheter med konventionell Unix kommandoradsanalys som :mod:"
"`optparse` normalt hanterar åt dig.  I synnerhet bör återuppringningar "
"implementera de konventionella reglerna för nakna ``--`` och ``-`` argument:"

msgid "either ``--`` or ``-`` can be option arguments"
msgstr "antingen ``--`` eller ``-`` kan vara alternativargument"

msgid ""
"bare ``--`` (if not the argument to some option): halt command-line "
"processing and discard the ``--``"
msgstr ""
"bara ``--`` (om det inte är argumentet till något alternativ): stoppa "
"kommandoradsbehandlingen och kasta bort ``--``"

msgid ""
"bare ``-`` (if not the argument to some option): halt command-line "
"processing but keep the ``-`` (append it to ``parser.largs``)"
msgstr ""
"bare ``-`` (om det inte är argumentet till något alternativ): stoppa "
"kommandoradsbehandlingen men behåll ``-`` (lägg till det i ``parser.largs``)"

msgid ""
"If you want an option that takes a variable number of arguments, there are "
"several subtle, tricky issues to worry about.  The exact implementation you "
"choose will be based on which trade-offs you're willing to make for your "
"application (which is why :mod:`optparse` doesn't support this sort of thing "
"directly)."
msgstr ""
"Om du vill ha ett alternativ som tar ett variabelt antal argument finns det "
"flera subtila, knepiga frågor att oroa sig för.  Den exakta implementeringen "
"du väljer kommer att baseras på vilka avvägningar du är villig att göra för "
"din applikation (vilket är anledningen till att :mod:`optparse` inte stöder "
"den här typen av saker direkt)."

msgid ""
"Nevertheless, here's a stab at a callback for an option with variable "
"arguments::"
msgstr ""
"Här är ändå ett försök till en callback för ett alternativ med variabla "
"argument::"

msgid ""
"def vararg_callback(option, opt_str, value, parser):\n"
"    assert value is None\n"
"    value = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            return True\n"
"        except ValueError:\n"
"            return False\n"
"\n"
"    for arg in parser.rargs:\n"
"        # stop on --foo like options\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # stop on -a, but not on -3 or -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        value.append(arg)\n"
"\n"
"    del parser.rargs[:len(value)]\n"
"    setattr(parser.values, option.dest, value)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"callback\", callback=vararg_callback)"
msgstr ""
"def vararg_callback(option, opt_str, värde, parser):\n"
"    assert värdet är None\n"
"    värde = []\n"
"\n"
"    def floatable(str):\n"
"        try:\n"
"            float(str)\n"
"            returnerar sant\n"
"        utom ValueError:\n"
"            return False\n"
"\n"
"    för arg i parser.rargs:\n"
"        # stoppa på --foo som alternativ\n"
"        if arg[:2] == \"--\" and len(arg) > 2:\n"
"            break\n"
"        # stoppa på -a, men inte på -3 eller -3.0\n"
"        if arg[:1] == \"-\" and len(arg) > 1 and not floatable(arg):\n"
"            break\n"
"        värde.append(arg)\n"
"\n"
"    del parser.rargs[:len(värde)]\n"
"    setattr(parser.värden, option.dest, värde)\n"
"\n"
"...\n"
"parser.add_option(\"-c\", \"--callback\", dest=\"vararg_attr\",\n"
"                  action=\"återuppringning\", "
"återuppringning=vararg_callback)"

msgid "Extending :mod:`optparse`"
msgstr "Utökning av :mod:`optparse`"

msgid ""
"Since the two major controlling factors in how :mod:`optparse` interprets "
"command-line options are the action and type of each option, the most likely "
"direction of extension is to add new actions and new types."
msgstr ""
"Eftersom de två viktigaste faktorerna som styr hur :mod:`optparse` tolkar "
"kommandoradsalternativ är åtgärden och typen för varje alternativ, är den "
"mest sannolika inriktningen för utvidgning att lägga till nya åtgärder och "
"nya typer."

msgid "Adding new types"
msgstr "Lägga till nya typer"

msgid ""
"To add new types, you need to define your own subclass of :mod:`optparse`'s :"
"class:`Option` class.  This class has a couple of attributes that define :"
"mod:`optparse`'s types: :attr:`~Option.TYPES` and :attr:`~Option."
"TYPE_CHECKER`."
msgstr ""
"För att lägga till nya typer måste du definiera din egen underklass av :mod:"
"`optparse` :class:`Option`-klassen.  Denna klass har ett par attribut som "
"definierar :mod:`optparse`:s typer: :attr:`~Option.TYPES` och :attr:`~Option."
"TYPE_CHECKER`."

msgid ""
"A tuple of type names; in your subclass, simply define a new tuple :attr:"
"`TYPES` that builds on the standard one."
msgstr ""
"En tupel av typnamn; i din subklass definierar du helt enkelt en ny tupel :"
"attr:`TYPES` som bygger på standardtupeln."

msgid ""
"A dictionary mapping type names to type-checking functions.  A type-checking "
"function has the following signature::"
msgstr ""
"En ordbok som mappar typnamn till typkontrollfunktioner.  En "
"typkontrollfunktion har följande signatur::"

msgid "def check_mytype(option, opt, value)"
msgstr "def check_mytype(option, opt, värde)"

msgid ""
"where ``option`` is an :class:`Option` instance, ``opt`` is an option string "
"(e.g., ``-f``), and ``value`` is the string from the command line that must "
"be checked and converted to your desired type.  ``check_mytype()`` should "
"return an object of the hypothetical type ``mytype``.  The value returned by "
"a type-checking function will wind up in the OptionValues instance returned "
"by :meth:`OptionParser.parse_args`, or be passed to a callback as the "
"``value`` parameter."
msgstr ""
"där ``option`` är en instans av :class:`Option`, ``opt`` är en optionssträng "
"(t.ex. ``-f``) och ``value`` är strängen från kommandoraden som måste "
"kontrolleras och konverteras till önskad typ.  ``check_mytype()`` bör "
"returnera ett objekt av den hypotetiska typen ``mytype``.  Det värde som "
"returneras av en typkontrollfunktion hamnar i OptionValues-instansen som "
"returneras av :meth:`OptionParser.parse_args`, eller skickas till en "
"callback som parametern ``value``."

msgid ""
"Your type-checking function should raise :exc:`OptionValueError` if it "
"encounters any problems.  :exc:`OptionValueError` takes a single string "
"argument, which is passed as-is to :class:`OptionParser`'s :meth:`error` "
"method, which in turn prepends the program name and the string ``\"error:"
"\"`` and prints everything to stderr before terminating the process."
msgstr ""
"Din typkontrollfunktion bör ge upphov till :exc:`OptionValueError` om den "
"stöter på några problem. :exc:`OptionValueError` tar ett enda "
"strängargument, som skickas som det är till :class:`OptionParser`:s :meth:"
"`error`-metod, som i sin tur lägger till programnamnet och strängen "
"``\"error:\"`` och skriver ut allt till stderr innan processen avslutas."

msgid ""
"Here's a silly example that demonstrates adding a ``\"complex\"`` option "
"type to parse Python-style complex numbers on the command line.  (This is "
"even sillier than it used to be, because :mod:`optparse` 1.3 added built-in "
"support for complex numbers, but never mind.)"
msgstr ""
"Här är ett fånigt exempel som visar hur man lägger till en ``\"complex\"`` "
"alternativtyp för att analysera komplexa tal i Python-stil på "
"kommandoraden.  (Det här är ännu fånigare än det brukade vara, eftersom :mod:"
"`optparse` 1.3 lade till inbyggt stöd för komplexa tal, men strunt samma)"

msgid "First, the necessary imports::"
msgstr "Först den nödvändiga importen::"

msgid ""
"from copy import copy\n"
"from optparse import Option, OptionValueError"
msgstr ""
"från copy import kopiera\n"
"från optparse import Option, OptionValueError"

msgid ""
"You need to define your type-checker first, since it's referred to later (in "
"the :attr:`~Option.TYPE_CHECKER` class attribute of your Option subclass)::"
msgstr ""
"Du måste definiera din typkontroll först, eftersom det hänvisas till senare "
"(i :attr:`~Option.TYPE_CHECKER` klassattributet i din Option-underklass)::"

msgid ""
"def check_complex(option, opt, value):\n"
"    try:\n"
"        return complex(value)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"option %s: invalid complex value: %r\" % (opt, value))"
msgstr ""
"def check_complex(option, opt, värde):\n"
"    försök:\n"
"        return komplex(värde)\n"
"    except ValueError:\n"
"        raise OptionValueError(\n"
"            \"option %s: ogiltigt komplext värde: %r\" % (opt, värde))"

msgid "Finally, the Option subclass::"
msgstr "Slutligen kan Option-underklassen::"

msgid ""
"class MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"complex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"
msgstr ""
"klass MyOption (Option):\n"
"    TYPES = Option.TYPES + (\"komplex\",)\n"
"    TYPE_CHECKER = copy(Option.TYPE_CHECKER)\n"
"    TYPE_CHECKER[\"complex\"] = check_complex"

msgid ""
"(If we didn't make a :func:`copy` of :attr:`Option.TYPE_CHECKER`, we would "
"end up modifying the :attr:`~Option.TYPE_CHECKER` attribute of :mod:"
"`optparse`'s Option class.  This being Python, nothing stops you from doing "
"that except good manners and common sense.)"
msgstr ""
"(Om vi inte gjorde en :func:`copy` av :attr:`Option.TYPE_CHECKER`, skulle vi "
"sluta med att modifiera attributet :attr:`~Option.TYPE_CHECKER` i :mod:"
"`optparse`s Option-klass.  Eftersom det här är Python finns det inget som "
"hindrar dig från att göra det, förutom gott uppförande och sunt förnuft)"

msgid ""
"That's it!  Now you can write a script that uses the new option type just "
"like any other :mod:`optparse`\\ -based script, except you have to instruct "
"your OptionParser to use MyOption instead of Option::"
msgstr ""
"Nu är det klart!  Nu kan du skriva ett skript som använder den nya "
"optionstypen precis som alla andra :mod:`optparse` -baserade skript, förutom "
"att du måste instruera din OptionParser att använda MyOption i stället för "
"Option::"

msgid ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"
msgstr ""
"parser = OptionParser(option_class=MyOption)\n"
"parser.add_option(\"-c\", type=\"complex\")"

msgid ""
"Alternately, you can build your own option list and pass it to OptionParser; "
"if you don't use :meth:`add_option` in the above way, you don't need to tell "
"OptionParser which option class to use::"
msgstr ""
"Alternativt kan du skapa din egen alternativlista och skicka den till "
"OptionParser; om du inte använder :meth:`add_option` på ovanstående sätt "
"behöver du inte tala om för OptionParser vilken alternativklass som ska "
"användas::"

msgid ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", "
"dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"
msgstr ""
"option_list = [MyOption(\"-c\", action=\"store\", type=\"complex\", "
"dest=\"c\")]\n"
"parser = OptionParser(option_list=option_list)"

msgid "Adding new actions"
msgstr "Lägga till nya åtgärder"

msgid ""
"Adding new actions is a bit trickier, because you have to understand that :"
"mod:`optparse` has a couple of classifications for actions:"
msgstr ""
"Att lägga till nya åtgärder är lite knepigare, eftersom du måste förstå att :"
"mod:`optparse` har ett par klassificeringar för åtgärder:"

msgid "\"store\" actions"
msgstr "\"lagra\" åtgärder"

msgid ""
"actions that result in :mod:`optparse` storing a value to an attribute of "
"the current OptionValues instance; these options require a :attr:`~Option."
"dest` attribute to be supplied to the Option constructor."
msgstr ""
"åtgärder som resulterar i att :mod:`optparse` lagrar ett värde till ett "
"attribut i den aktuella OptionValues-instansen; dessa alternativ kräver att "
"ett :attr:`~Option.dest`-attribut tillhandahålls till Option-konstruktören."

msgid "\"typed\" actions"
msgstr "\"typade\" åtgärder"

msgid ""
"actions that take a value from the command line and expect it to be of a "
"certain type; or rather, a string that can be converted to a certain type. "
"These options require a :attr:`~Option.type` attribute to the Option "
"constructor."
msgstr ""
"åtgärder som tar ett värde från kommandoraden och förväntar sig att det ska "
"vara av en viss typ; eller snarare en sträng som kan konverteras till en "
"viss typ. Dessa alternativ kräver ett :attr:`~Option.type`-attribut till "
"Option-konstruktören."

msgid ""
"These are overlapping sets: some default \"store\" actions are "
"``\"store\"``, ``\"store_const\"``, ``\"append\"``, and ``\"count\"``, while "
"the default \"typed\" actions are ``\"store\"``, ``\"append\"``, and "
"``\"callback\"``."
msgstr ""
"Dessa är överlappande uppsättningar: vissa standard \"store\"-åtgärder är "
"``\"store\"``, ``\"store_const\"``, ``\"append\"`` och ``\"count\"``, medan "
"standard \"typed\"-åtgärder är ``\"store\"``, ``\"append\"`` och "
"``\"callback\"``."

msgid ""
"When you add an action, you need to categorize it by listing it in at least "
"one of the following class attributes of Option (all are lists of strings):"
msgstr ""
"När du lägger till en åtgärd måste du kategorisera den genom att lista den i "
"minst ett av följande klassattribut för Option (alla är listor med strängar):"

msgid "All actions must be listed in ACTIONS."
msgstr "Alla åtgärder måste listas i ACTIONS."

msgid "\"store\" actions are additionally listed here."
msgstr "\"Store\"-åtgärder är dessutom listade här."

msgid "\"typed\" actions are additionally listed here."
msgstr "\"typade\" åtgärder listas dessutom här."

msgid ""
"Actions that always take a type (i.e. whose options always take a value) are "
"additionally listed here.  The only effect of this is that :mod:`optparse` "
"assigns the default type, ``\"string\"``, to options with no explicit type "
"whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`."
msgstr ""
"Åtgärder som alltid tar en typ (d.v.s. vars alternativ alltid tar ett värde) "
"listas dessutom här.  Den enda effekten av detta är att :mod:`optparse` "
"tilldelar standardtypen, ``\"string\"``, till alternativ utan explicit typ "
"vars åtgärd listas i :attr:`ALWAYS_TYPED_ACTIONS`."

msgid ""
"In order to actually implement your new action, you must override Option's :"
"meth:`take_action` method and add a case that recognizes your action."
msgstr ""
"För att faktiskt kunna implementera din nya åtgärd måste du åsidosätta "
"Options :meth:`take_action`-metod och lägga till ett fall som känner igen "
"din åtgärd."

msgid ""
"For example, let's add an ``\"extend\"`` action.  This is similar to the "
"standard ``\"append\"`` action, but instead of taking a single value from "
"the command-line and appending it to an existing list, ``\"extend\"`` will "
"take multiple values in a single comma-delimited string, and extend an "
"existing list with them.  That is, if ``--names`` is an ``\"extend\"`` "
"option of type ``\"string\"``, the command line ::"
msgstr ""
"Låt oss till exempel lägga till en ``\"extend\"``-åtgärd.  Detta liknar "
"standardåtgärden ``\"append\"``, men i stället för att ta ett enda värde "
"från kommandoraden och lägga till det i en befintlig lista, tar "
"``\"extend\"`` flera värden i en enda kommaseparerad sträng och utökar en "
"befintlig lista med dem.  Det vill säga, om ``--names`` är ett "
"``\"extend\"``-alternativ av typen ``\"string\"``, kommer kommandoraden ::"

msgid "--names=foo,bar --names blah --names ding,dong"
msgstr "--namn=foo,bar --namn blah --namn ding,dong"

msgid "would result in a list  ::"
msgstr "skulle resultera i en lista ::"

msgid "[\"foo\", \"bar\", \"blah\", \"ding\", \"dong\"]"
msgstr "[\"foo\", \"bar\", \"blah\", \"ding\", \"dong\"]"

msgid "Again we define a subclass of Option::"
msgstr "Återigen definierar vi en underklass av Option::"

msgid ""
"class MyOption(Option):\n"
"\n"
"    ACTIONS = Option.ACTIONS + (\"extend\",)\n"
"    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n"
"    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n"
"    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + (\"extend\",)\n"
"\n"
"    def take_action(self, action, dest, opt, value, values, parser):\n"
"        if action == \"extend\":\n"
"            lvalue = value.split(\",\")\n"
"            values.ensure_value(dest, []).extend(lvalue)\n"
"        else:\n"
"            Option.take_action(\n"
"                self, action, dest, opt, value, values, parser)"
msgstr ""
"klass MyOption(Option):\n"
"\n"
"    ACTIONS = Option.ACTIONS + (\"extend\",)\n"
"    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n"
"    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n"
"    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + (\"extend\",)\n"
"\n"
"    def take_action(self, action, dest, opt, value, values, parser):\n"
"        if action == \"extend\":\n"
"            lvalue = värde.split(\",\")\n"
"            values.ensure_value(dest, []).extend(lvalue)\n"
"        annat:\n"
"            Option.take_action(\n"
"                self, action, dest, opt, värde, värden, parser)"

msgid "Features of note:"
msgstr "Funktioner av betydelse:"

msgid ""
"``\"extend\"`` both expects a value on the command-line and stores that "
"value somewhere, so it goes in both :attr:`~Option.STORE_ACTIONS` and :attr:"
"`~Option.TYPED_ACTIONS`."
msgstr ""
"``\"extend\"`` både förväntar sig ett värde på kommandoraden och lagrar det "
"värdet någonstans, så det går in i både :attr:`~Option.STORE_ACTIONS` och :"
"attr:`~Option.TYPED_ACTIONS`."

msgid ""
"to ensure that :mod:`optparse` assigns the default type of ``\"string\"`` to "
"``\"extend\"`` actions, we put the ``\"extend\"`` action in :attr:`~Option."
"ALWAYS_TYPED_ACTIONS` as well."
msgstr ""
"för att säkerställa att :mod:`optparse` tilldelar standardtypen "
"``\"string\"`` till ``\"extend\"``-åtgärder, lägger vi till ``\"extend\"``-"
"åtgärden i :attr:`~Option.ALWAYS_TYPED_ACTIONS` också."

msgid ""
":meth:`MyOption.take_action` implements just this one new action, and passes "
"control back to :meth:`Option.take_action` for the standard :mod:`optparse` "
"actions."
msgstr ""
":meth:`MyOption.take_action` implementerar bara denna enda nya åtgärd och "
"lämnar tillbaka kontrollen till :meth:`Option.take_action` för "
"standardåtgärderna i :mod:`optparse`."

msgid ""
"``values`` is an instance of the optparse_parser.Values class, which "
"provides the very useful :meth:`ensure_value` method. :meth:`ensure_value` "
"is essentially :func:`getattr` with a safety valve; it is called as ::"
msgstr ""
"``values`` är en instans av klassen optparse_parser.Values, som "
"tillhandahåller den mycket användbara metoden :meth:`ensure_value`. :meth:"
"`ensure_value` är i huvudsak :func:`getattr` med en säkerhetsventil; den "
"kallas som ::"

msgid "values.ensure_value(attr, value)"
msgstr "values.ensure_value(attr, värde)"

msgid ""
"If the ``attr`` attribute of ``values`` doesn't exist or is ``None``, then "
"ensure_value() first sets it to ``value``, and then returns ``value``. This "
"is very handy for actions like ``\"extend\"``, ``\"append\"``, and "
"``\"count\"``, all of which accumulate data in a variable and expect that "
"variable to be of a certain type (a list for the first two, an integer for "
"the latter).  Using :meth:`ensure_value` means that scripts using your "
"action don't have to worry about setting a default value for the option "
"destinations in question; they can just leave the default as ``None`` and :"
"meth:`ensure_value` will take care of getting it right when it's needed."
msgstr ""
"Om attributet ``attr`` i ``values`` inte existerar eller är ``None``, sätter "
"ensure_value() det först till ``value`` och returnerar sedan ``value``. "
"Detta är mycket praktiskt för åtgärder som ``\"extend\"``, ``\"append\"`` "
"och ``\"count\"``, som alla ackumulerar data i en variabel och förväntar sig "
"att variabeln ska vara av en viss typ (en lista för de två första, ett "
"heltal för den senare).  Att använda :meth:`ensure_value` innebär att skript "
"som använder din åtgärd inte behöver oroa sig för att ställa in ett "
"standardvärde för alternativdestinationerna i fråga; de kan bara lämna "
"standardvärdet som ``None`` och :meth:`ensure_value` kommer att ta hand om "
"att få det rätt när det behövs."

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"Raised if an :class:`Option` instance is created with invalid or "
"inconsistent arguments."
msgstr ""
"Utlöses om en :class:`Option`-instans skapas med ogiltiga eller "
"inkonsekventa argument."

msgid "Raised if conflicting options are added to an :class:`OptionParser`."
msgstr ""
"Uppstår om motstridiga alternativ läggs till i en :class:`OptionParser`."

msgid "Raised if an invalid option value is encountered on the command line."
msgstr "Utlöses om ett ogiltigt alternativvärde påträffas på kommandoraden."

msgid "Raised if an invalid option is passed on the command line."
msgstr "Utlöses om ett ogiltigt alternativ anges på kommandoraden."

msgid "Raised if an ambiguous option is passed on the command line."
msgstr "Utlöses om ett tvetydigt alternativ skickas på kommandoraden."
