# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Importing Modules"
msgstr "Importera moduler"

msgid ""
"This is a wrapper around :c:func:`PyImport_Import()` which takes a :c:expr:"
"`const char *` as an argument instead of a :c:expr:`PyObject *`."
msgstr ""
"Detta är ett omslag runt :c:func:`PyImport_Import()` som tar en :c:expr:"
"`const char *` som argument istället för en :c:expr:`PyObject *`."

msgid "This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr ""
"Denna funktion är ett föråldrat alias för :c:func:`PyImport_ImportModule`."

msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to per-"
"module locks for most purposes, so this function's special behaviour isn't "
"needed anymore."
msgstr ""
"Denna funktion brukade misslyckas omedelbart när importlåset hölls av en "
"annan tråd.  I Python 3.3 övergick dock låsningssystemet till per-modul-lås "
"för de flesta ändamål, så den här funktionens speciella beteende behövs inte "
"längre."

msgid "Use :c:func:`PyImport_ImportModule` instead."
msgstr "Använd :c:func:`PyImport_ImportModule` istället."

msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`."
msgstr ""
"Importera en modul.  Detta beskrivs bäst genom att hänvisa till den inbyggda "
"Python-funktionen :func:`__import__`."

msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or ``NULL`` with an exception set on failure.  Like for :func:"
"`__import__`, the return value when a submodule of a package was requested "
"is normally the top-level package, unless a non-empty *fromlist* was given."
msgstr ""
"Returvärdet är en ny referens till den importerade modulen eller paketet på "
"högsta nivån, eller ``NULL`` med en undantagsuppsättning vid misslyckande.  "
"Precis som för :func:`__import__` är returvärdet när en undermodul av ett "
"paket begärdes normalt paketet på högsta nivån, såvida inte en icke-tom "
"*fromlist* gavs."

msgid ""
"Failing imports remove incomplete module objects, like with :c:func:"
"`PyImport_ImportModule`."
msgstr ""
"Felaktig import tar bort ofullständiga modulobjekt, som med :c:func:"
"`PyImport_ImportModule`."

msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"Importera en modul.  Detta beskrivs bäst genom att hänvisa till den inbyggda "
"Python-funktionen :func:`__import__`, eftersom standardfunktionen :func:"
"`__import__` anropar denna funktion direkt."

msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Liknar :c:func:`PyImport_ImportModuleLevelObject`, men namnet är en UTF-8-"
"kodad sträng i stället för ett Unicode-objekt."

msgid "Negative values for *level* are no longer accepted."
msgstr "Negativa värden för *level* accepteras inte längre."

msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever import "
"hooks are installed in the current environment."
msgstr ""
"Detta är ett gränssnitt på högre nivå som anropar den aktuella "
"\"importkrokfunktionen\" (med en explicit *nivå* på 0, vilket innebär "
"absolut import).  Den anropar :func:`__import__`-funktionen från "
"``__builtins__`` i de aktuella globalerna.  Detta innebär att importen görs "
"med hjälp av de importkrokar som finns installerade i den aktuella miljön."

msgid "This function always uses absolute imports."
msgstr "Denna funktion använder alltid absolut import."

msgid ""
"Reload a module.  Return a new reference to the reloaded module, or ``NULL`` "
"with an exception set on failure (the module still exists in this case)."
msgstr ""
"Ladda om en modul.  Returnerar en ny referens till den omladdade modulen, "
"eller ``NULL`` med ett undantag om den misslyckas (modulen finns fortfarande "
"i det här fallet)."

msgid "Return the module object corresponding to a module name."
msgstr "Returnerar det modulobjekt som motsvarar ett modulnamn."

msgid ""
"The *name* argument may be of the form ``package.module``. First check the "
"modules dictionary if there's one there, and if not, create a new one and "
"insert it in the modules dictionary."
msgstr ""
"Argumentet *namn* kan vara av formen ``package.module``. Kontrollera först i "
"modulordlistan om det finns någon där, och om inte, skapa en ny och infoga "
"den i modulordlistan."

msgid ""
"Return a :term:`strong reference` to the module on success. Return ``NULL`` "
"with an exception set on failure."
msgstr ""
"Returnerar en :term:`strong-referens` till modulen vid framgång. Returnerar "
"``NULL`` med en undantagsuppsättning vid misslyckande."

msgid "The module name *name* is decoded from UTF-8."
msgstr "Modulnamnet *name* avkodas från UTF-8."

msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use :c:func:"
"`PyImport_ImportModule` or one of its variants to import a module. Package "
"structures implied by a dotted name for *name* are not created if not "
"already present."
msgstr ""
"Den här funktionen laddar eller importerar inte modulen; om modulen inte "
"redan var laddad får du ett tomt modulobjekt. Använd :c:func:"
"`PyImport_ImportModule` eller en av dess varianter för att importera en "
"modul. Paketstrukturer som impliceras av ett prickat namn för *namn* skapas "
"inte om de inte redan finns."

msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference` and *name* is a Python :class:`str` object."
msgstr ""
"Liknar :c:func:`PyImport_AddModuleRef`, men returnerar en :term:`lånad "
"referens` och *namn* är ett Python :class:`str`-objekt."

msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference`."
msgstr ""
"Liknar :c:func:`PyImport_AddModuleRef`, men returnerar en :term:`lånad "
"referens`."

msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or ``NULL`` with an exception set if an error occurred.  "
"*name* is removed from :data:`sys.modules` in error cases, even if *name* "
"was already in :data:`sys.modules` on entry to :c:func:"
"`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules in :"
"data:`sys.modules` is dangerous, as imports of such modules have no way to "
"know that the module object is an unknown (and probably damaged with respect "
"to the module author's intents) state."
msgstr ""
"Med ett modulnamn (eventuellt av formen ``package.module``) och ett "
"kodobjekt läst från en Python-bytecode-fil eller erhållet från den inbyggda "
"funktionen :func:`compile`, laddar modulen.  Returnerar en ny referens till "
"modulobjektet, eller ``NULL`` med en undantagsuppsättning om ett fel "
"inträffade.  *name* tas bort från :data:`sys.modules` i felfall, även om "
"*name* redan fanns i :data:`sys.modules` vid inmatningen till :c:func:"
"`PyImport_ExecCodeModule`.  Att lämna ofullständigt initialiserade moduler "
"i :data:`sys.modules` är farligt, eftersom import av sådana moduler inte har "
"något sätt att veta att modulobjektet är ett okänt (och förmodligen skadat "
"med avseende på modulförfattarens avsikter) tillstånd."

msgid ""
"The module's :attr:`~module.__spec__` and :attr:`~module.__loader__` will be "
"set, if not set already, with the appropriate values.  The spec's loader "
"will be set to the module's :attr:`!__loader__` (if set) and to an instance "
"of :class:`~importlib.machinery.SourceFileLoader` otherwise."
msgstr ""
"Modulens :attr:`~module.__spec__` och :attr:`~module.__loader__` sätts, om "
"de inte redan är satta, med lämpliga värden.  Specs laddare kommer att "
"sättas till modulens :attr:`!__loader__` (om den är satt) och annars till en "
"instans av :class:`~importlib.machinery.SourceFileLoader`."

msgid ""
"The module's :attr:`~module.__file__` attribute will be set to the code "
"object's :attr:`~codeobject.co_filename`.  If applicable, :attr:`~module."
"__cached__` will also be set."
msgstr ""
"Modulens attribut :attr:`~module.__file__` kommer att sättas till "
"kodobjektets :attr:`~codeobject.co_filename`.  Om tillämpligt kommer även :"
"attr:`~module.__cached__` att sättas."

msgid ""
"This function will reload the module if it was already imported.  See :c:"
"func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"Denna funktion kommer att ladda om modulen om den redan importerats.  Se :c:"
"func:`PyImport_ReloadModule` för det avsedda sättet att ladda om en modul."

msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"Om *name* pekar på ett prickat namn av formen ``package.module`` kommer alla "
"paketstrukturer som inte redan har skapats ändå inte att skapas."

msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
"Se även :c:func:`PyImport_ExecCodeModuleEx` och :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."

msgid ""
"The setting of :attr:`~module.__cached__` and :attr:`~module.__loader__` is "
"deprecated. See :class:`~importlib.machinery.ModuleSpec` for alternatives."
msgstr ""
"Inställningen av :attr:`~module.__cached__` och :attr:`~module.__loader__` "
"är föråldrad. Se :class:`~importlib.machinery.ModuleSpec` för alternativ."

msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`~module.__file__` "
"attribute of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
"Som :c:func:`PyImport_ExecCodeModule`, men attributet :attr:`~module."
"__file__` i modulobjektet sätts till *pathname* om det inte är ``NULL``."

msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr "Se även :c:func:`PyImport_ExecCodeModuleWithPathnames`."

msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the :attr:`~module.__cached__` "
"attribute of the module object is set to *cpathname* if it is non-``NULL``.  "
"Of the three functions, this is the preferred one to use."
msgstr ""
"Som :c:func:`PyImport_ExecCodeModuleEx`, men attributet :attr:`~module."
"__cached__` i modulobjektet sätts till *cpathname* om det inte är ``NULL``.  "
"Av de tre funktionerna är denna att föredra att använda."

msgid ""
"Setting :attr:`~module.__cached__` is deprecated. See :class:`~importlib."
"machinery.ModuleSpec` for alternatives."
msgstr ""
"Inställningen :attr:`~module.__cached__` är föråldrad. Se :class:`~importlib."
"machinery.ModuleSpec` för alternativ."

msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure out "
"what the value for *pathname* should be from *cpathname* if the former is "
"set to ``NULL``."
msgstr ""
"Som :c:func:`PyImport_ExecCodeModuleObject`, men *name*, *pathname* och "
"*cpathname* är UTF-8-kodade strängar. Försök görs också att räkna ut vad "
"värdet för *pathname* ska vara från *cpathname* om det förra är satt till "
"``NULL``."

msgid ""
"Uses :func:`!imp.source_from_cache` in calculating the source path if only "
"the bytecode path is provided."
msgstr ""
"Använder :func:`!imp.source_from_cache` vid beräkning av källsökvägen om "
"endast bytecode-sökvägen anges."

msgid "No longer uses the removed :mod:`!imp` module."
msgstr "Använder inte längre den borttagna modulen :mod:`!imp`."

msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"Returnerar det magiska numret för Python-bytekodfiler (även känd som :file:`."
"pyc`-fil). Det magiska numret bör finnas i de första fyra byte i bytecode-"
"filen, i little-endian byte-ordning. Returnerar ``-1`` vid fel."

msgid "Return value of ``-1`` upon failure."
msgstr "Returnerar värdet ``-1`` vid fel."

msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` is "
"authoritative and should be used instead of this function."
msgstr ""
"Returnerar den magiska taggsträngen för filnamn i Python-bytekod i formatet :"
"pep:`3147`.  Tänk på att värdet i ``sys.implementation.cache_tag`` är "
"auktoritativt och bör användas i stället för denna funktion."

msgid ""
"Return the dictionary used for the module administration (a.k.a. ``sys."
"modules``).  Note that this is a per-interpreter variable."
msgstr ""
"Returnerar den ordbok som används för moduladministration (även kallad ``sys."
"modules``).  Observera att detta är en variabel för varje tolk."

msgid ""
"Return the already imported module with the given name.  If the module has "
"not been imported yet then returns ``NULL`` but does not set an error.  "
"Returns ``NULL`` and sets an error if the lookup failed."
msgstr ""
"Returnerar den redan importerade modulen med det angivna namnet.  Om modulen "
"inte har importerats ännu returneras ``NULL`` men inget felmeddelande "
"anges.  Returnerar ``NULL`` och anger ett fel om uppslagningen misslyckades."

msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`!pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook "
"is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller that the :term:`path based finder` could not find a "
"finder for this path item. Cache the result in :data:`sys."
"path_importer_cache`. Return a new reference to the finder object."
msgstr ""
"Returnerar ett sökobjekt för ett :data:`sys.path`/:attr:`!pkg.__path__`-"
"objekt *path*, eventuellt genom att hämta det från :data:`sys."
"path_importer_cache` dict.  Om det ännu inte var cachat, traversera :data:"
"`sys.path_hooks` tills en krok hittas som kan hantera sökvägsobjektet.  "
"Returnera ``None`` om ingen krok kan; detta talar om för vår anropare att :"
"term:`path based finder` inte kunde hitta någon sökare för detta "
"sökvägsobjekt. Cacha resultatet i :data:`sys.path_importer_cache`. Returnera "
"en ny referens till sökobjektet."

msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use :c:func:"
"`PyImport_ImportModule`.  (Note the misnomer --- this function would reload "
"the module if it was already imported.)"
msgstr ""
"Laddar en fryst modul med namnet *namn*.  Returnerar ``1`` om det lyckas, "
"``0`` om modulen inte hittas och ``-1`` med ett undantag om initialiseringen "
"misslyckades.  För att komma åt den importerade modulen vid en lyckad "
"laddning, använd :c:func:`PyImport_ImportModule`.  (Notera den felaktiga "
"benämningen --- denna funktion skulle ladda om modulen om den redan var "
"importerad)"

msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "Attributet ``__file__`` är inte längre inställt på modulen."

msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Liknar :c:func:`PyImport_ImportFrozenModuleObject`, men namnet är en UTF-8-"
"kodad sträng i stället för ett Unicode-objekt."

msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the "
"Python source distribution).  Its definition, found in :file:`Include/import."
"h`, is::"
msgstr ""
"Detta är strukturtypdefinitionen för frysta modulbeskrivare, som genereras "
"av :program:`freeze`-verktyget (se :file:`Tools/freeze/` i Python-"
"källdistributionen).  Dess definition, som finns i :file:`Include/import.h`, "
"är::"

msgid ""
"struct _frozen {\n"
"    const char *name;\n"
"    const unsigned char *code;\n"
"    int size;\n"
"    bool is_package;\n"
"};"
msgstr ""
"struct _frozen {\n"
"    const char *namn;\n"
"    konst osignerad char *code;\n"
"    int storlek;\n"
"    bool is_package;\n"
"};"

msgid ""
"The new ``is_package`` field indicates whether the module is a package or "
"not. This replaces setting the ``size`` field to a negative value."
msgstr ""
"Det nya fältet ``is_package`` anger om modulen är ett paket eller inte. "
"Detta ersätter inställningen av fältet ``size`` till ett negativt värde."

msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Denna pekare initialiseras så att den pekar på en array av :c:struct:"
"`_frozen`-poster, som avslutas med en post vars alla medlemmar är ``NULL`` "
"eller noll.  När en fryst modul importeras söks den i den här tabellen.  "
"Tredjepartskod kan använda detta för att skapa en dynamiskt skapad samling "
"av frysta moduler."

msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"Lägg till en enda modul i den befintliga tabellen över inbyggda moduler.  "
"Detta är en bekväm omslutning kring :c:func:`PyImport_ExtendInittab`, som "
"returnerar ``-1`` om tabellen inte kunde utökas.  Den nya modulen kan "
"importeras med namnet *name* och använder funktionen *initfunc* som "
"initialiseringsfunktion vid det första importförsöket.  Denna bör anropas "
"före :c:func:`Py_Initialize`."

msgid ""
"Structure describing a single entry in the list of built-in modules. "
"Programs which embed Python may use an array of these structures in "
"conjunction with :c:func:`PyImport_ExtendInittab` to provide additional "
"built-in modules. The structure consists of two members:"
msgstr ""
"Struktur som beskriver en enda post i listan över inbyggda moduler. Program "
"som bygger in Python kan använda en array av dessa strukturer tillsammans "
"med :c:func:`PyImport_ExtendInittab` för att tillhandahålla ytterligare "
"inbyggda moduler. Strukturen består av två medlemmar:"

msgid "The module name, as an ASCII encoded string."
msgstr "Modulens namn, som en ASCII-kodad sträng."

msgid "Initialization function for a module built into the interpreter."
msgstr "Initialiseringsfunktion för en modul som är inbyggd i tolken."

msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains ``NULL`` for the :c:"
"member:`~_inittab.name` field; failure to provide the sentinel value can "
"result in a memory fault. Returns ``0`` on success or ``-1`` if insufficient "
"memory could be allocated to extend the internal table.  In the event of "
"failure, no modules are added to the internal table.  This must be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"Lägger till en samling moduler i tabellen över inbyggda moduler.  Arrayen "
"*newtab* måste sluta med en sentinel-post som innehåller ``NULL`` för "
"fältet :c:member:`~_inittab.name`; om sentinel-värdet inte anges kan det "
"resultera i ett minnesfel. Returnerar ``0`` vid framgång eller ``-1`` om "
"otillräckligt minne kunde allokeras för att utöka den interna tabellen.  Vid "
"misslyckande läggs inga moduler till i den interna tabellen.  Detta måste "
"anropas före :c:func:`Py_Initialize`."

msgid ""
"If Python is initialized multiple times, :c:func:`PyImport_AppendInittab` "
"or :c:func:`PyImport_ExtendInittab` must be called before each Python "
"initialization."
msgstr ""
"Om Python initialiseras flera gånger måste :c:func:`PyImport_AppendInittab` "
"eller :c:func:`PyImport_ExtendInittab` anropas före varje Python-"
"initialisering."

msgid "Import the module *mod_name* and get its attribute *attr_name*."
msgstr "Importera modulen *mod_name* och hämta dess attribut *attr_name*."

msgid "Names must be Python :class:`str` objects."
msgstr "Namnen måste vara Python :class:`str`-objekt."

msgid ""
"Helper function combining :c:func:`PyImport_Import` and :c:func:"
"`PyObject_GetAttr`. For example, it can raise :exc:`ImportError` if the "
"module is not found, and :exc:`AttributeError` if the attribute doesn't "
"exist."
msgstr ""
"Hjälpfunktion som kombinerar :c:func:`PyImport_Import` och :c:func:"
"`PyObject_GetAttr`. Den kan till exempel ge upphov till :exc:`ImportError` "
"om modulen inte hittas och :exc:`AttributeError` om attributet inte finns."

msgid ""
"Similar to :c:func:`PyImport_ImportModuleAttr`, but names are UTF-8 encoded "
"strings instead of Python :class:`str` objects."
msgstr ""
"Liknar :c:func:`PyImport_ImportModuleAttr`, men namnen är UTF-8-kodade "
"strängar istället för Python :class:`str`-objekt."

msgid "package variable"
msgstr "paketvariabel"

msgid "__all__"
msgstr "alla"

msgid "__all__ (package variable)"
msgstr "__all__ (paketvariabel)"

msgid "modules (in module sys)"
msgstr "moduler (i modul sys)"

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "__import__"
msgstr "__import__"

msgid "compile"
msgstr "sammanställa"

msgid "freeze utility"
msgstr "frysa verktyg"
