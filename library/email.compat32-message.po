# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`email.message.Message`: Representing an email message using the :data:"
"`~email.policy.compat32` API"
msgstr ""
":mod:`email.message.Message`: Representerar ett e-postmeddelande med hjälp "
"av :data:`~email.policy.compat32` API"

msgid ""
"The :class:`Message` class is very similar to the :class:`~email.message."
"EmailMessage` class, without the methods added by that class, and with the "
"default behavior of certain other methods being slightly different.  We also "
"document here some methods that, while supported by the :class:`~email."
"message.EmailMessage` class, are not recommended unless you are dealing with "
"legacy code."
msgstr ""
"Klassen :class:`Message` är mycket lik klassen :class:`~email.message."
"EmailMessage`, utan de metoder som lagts till av den klassen, och med "
"standardbeteendet för vissa andra metoder som är något annorlunda.  Vi "
"dokumenterar också här några metoder som, även om de stöds av klassen :class:"
"`~email.message.EmailMessage`, inte rekommenderas om du inte har att göra "
"med äldre kod."

msgid "The philosophy and structure of the two classes is otherwise the same."
msgstr "Filosofin och strukturen för de två klasserna är i övrigt densamma."

msgid ""
"This document describes the behavior under the default (for :class:"
"`Message`) policy :attr:`~email.policy.Compat32`.  If you are going to use "
"another policy, you should be using the :class:`~email.message.EmailMessage` "
"class instead."
msgstr ""
"Detta dokument beskriver beteendet under standardpolicyn (för :class:"
"`Message`) :attr:`~email.policy.Compat32`.  Om du tänker använda en annan "
"policy bör du använda klassen :class:`~email.message.EmailMessage` istället."

msgid ""
"An email message consists of *headers* and a *payload*.  Headers must be :"
"rfc:`5322` style names and values, where the field name and value are "
"separated by a colon.  The colon is not part of either the field name or the "
"field value.  The payload may be a simple text message, or a binary object, "
"or a structured sequence of sub-messages each with their own set of headers "
"and their own payload.  The latter type of payload is indicated by the "
"message having a MIME type such as :mimetype:`multipart/\\*` or :mimetype:"
"`message/rfc822`."
msgstr ""
"Ett e-postmeddelande består av *headers* och en *payload*.  Headers måste "
"vara namn och värden i stil med :rfc:`5322`, där fältnamnet och värdet "
"separeras med ett kolon.  Kolonet är inte en del av vare sig fältnamnet "
"eller fältvärdet.  Nyttolasten kan vara ett enkelt textmeddelande, ett "
"binärt objekt eller en strukturerad sekvens av undermeddelanden, vart och "
"ett med sin egen uppsättning rubriker och sin egen nyttolast.  Den senare "
"typen av nyttolast indikeras av att meddelandet har en MIME-typ som :"
"mimetype:`multipart/\\*` eller :mimetype:`message/rfc822`."

msgid ""
"The conceptual model provided by a :class:`Message` object is that of an "
"ordered dictionary of headers with additional methods for accessing both "
"specialized information from the headers, for accessing the payload, for "
"generating a serialized version of the message, and for recursively walking "
"over the object tree.  Note that duplicate headers are supported but special "
"methods must be used to access them."
msgstr ""
"Den konceptuella modell som tillhandahålls av ett :class:`Message`-objekt är "
"en ordnad ordbok med rubriker med ytterligare metoder för åtkomst till både "
"specialiserad information från rubrikerna, för åtkomst till nyttolasten, för "
"generering av en serialiserad version av meddelandet och för rekursiv "
"vandring över objektträdet.  Observera att duplicerade headers stöds men att "
"särskilda metoder måste användas för att komma åt dem."

msgid ""
"The :class:`Message` pseudo-dictionary is indexed by the header names, which "
"must be ASCII values.  The values of the dictionary are strings that are "
"supposed to contain only ASCII characters; there is some special handling "
"for non-ASCII input, but it doesn't always produce the correct results.  "
"Headers are stored and returned in case-preserving form, but field names are "
"matched case-insensitively.  There may also be a single envelope header, "
"also known as the *Unix-From* header or the ``From_`` header.  The *payload* "
"is either a string or bytes, in the case of simple message objects, or a "
"list of :class:`Message` objects, for MIME container documents (e.g. :"
"mimetype:`multipart/\\*` and :mimetype:`message/rfc822`)."
msgstr ""
"Pseudoordboken :class:`Message` indexeras av rubriknamnen, som måste vara "
"ASCII-värden.  Värdena i ordlistan är strängar som endast ska innehålla "
"ASCII-tecken; det finns viss specialhantering för icke-ASCII-data, men den "
"ger inte alltid rätt resultat.  Rubrikerna lagras och returneras med "
"bibehållen skiftlägespresentation, men fältnamnen matchas utan hänsyn till "
"skiftlägespresentation.  Det kan också finnas ett enda kuverthuvud, även "
"känt som *Unix-From*-huvudet eller ``From_``-huvudet.  *payload* är antingen "
"en sträng eller bytes, när det gäller enkla meddelandeobjekt, eller en lista "
"med :class:`Message`-objekt, för MIME-containerdokument (t.ex. :mimetype:"
"`multipart/\\*` och :mimetype:`message/rfc822`)."

msgid "Here are the methods of the :class:`Message` class:"
msgstr "Här är metoderna i klassen :class:`Message`:"

msgid ""
"If *policy* is specified (it must be an instance of a :mod:`~email.policy` "
"class) use the rules it specifies to update and serialize the representation "
"of the message.  If *policy* is not set, use the :class:`compat32 <email."
"policy.Compat32>` policy, which maintains backward compatibility with the "
"Python 3.2 version of the email package.  For more information see the :mod:"
"`~email.policy` documentation."
msgstr ""
"Om *policy* anges (den måste vara en instans av en :mod:`~email.policy`-"
"klass) används de regler som anges för att uppdatera och serialisera "
"representationen av meddelandet.  Om *policy* inte anges används :class:"
"`compat32 <email.policy.Compat32>`-policyn, som upprätthåller "
"bakåtkompatibilitet med Python 3.2-versionen av e-postpaketet.  För mer "
"information se :mod:`~email.policy`-dokumentationen."

msgid "The *policy* keyword argument was added."
msgstr "Nyckelordsargumentet *policy* har lagts till."

msgid ""
"Return the entire message flattened as a string.  When optional *unixfrom* "
"is true, the envelope header is included in the returned string. *unixfrom* "
"defaults to ``False``.  For backward compatibility reasons, *maxheaderlen* "
"defaults to ``0``, so if you want a different value you must override it "
"explicitly (the value specified for *max_line_length* in the policy will be "
"ignored by this method).  The *policy* argument may be used to override the "
"default policy obtained from the message instance. This can be used to "
"control some of the formatting produced by the method, since the specified "
"*policy* will be passed to the ``Generator``."
msgstr ""
"Returnerar hela meddelandet plattat som en sträng.  När det valfria "
"*unixfrom* är true inkluderas kuvertrubriken i den returnerade strängen. "
"*unixfrom* har ``False`` som standard.  Av bakåtkompatibilitetsskäl är "
"*maxheaderlen* standardvärdet ``0``, så om du vill ha ett annat värde måste "
"du uttryckligen åsidosätta det (det värde som anges för *max_line_length* i "
"policyn ignoreras av den här metoden).  Argumentet *policy* kan användas för "
"att åsidosätta den standardpolicy som hämtas från meddelandeinstansen. Detta "
"kan användas för att kontrollera en del av formateringen som produceras av "
"metoden, eftersom den angivna *policyn* kommer att skickas till "
"``Generator``."

msgid ""
"Flattening the message may trigger changes to the :class:`Message` if "
"defaults need to be filled in to complete the transformation to a string "
"(for example, MIME boundaries may be generated or modified)."
msgstr ""
"Att göra meddelandet plattare kan leda till ändringar i :class:`Message` om "
"standardvärden måste fyllas i för att slutföra omvandlingen till en sträng "
"(till exempel kan MIME-gränser genereras eller ändras)."

msgid ""
"Note that this method is provided as a convenience and may not always format "
"the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox "
"format.  For more flexibility, instantiate a :class:`~email.generator."
"Generator` instance and use its :meth:`~email.generator.Generator.flatten` "
"method directly.  For example::"
msgstr ""
"Observera att den här metoden är en bekvämlighetsåtgärd och att den kanske "
"inte alltid formaterar meddelandet på det sätt du vill.  Som standard görs t."
"ex. inte den mangling av rader som börjar med ``From`` som krävs av Unix "
"mbox-format.  För mer flexibilitet kan du instansiera en :class:`~email."
"generator.Generator`-instans och använda dess :meth:`~email.generator."
"Generator.flatten`-metod direkt.  Till exempel::"

msgid ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import StringIO\n"
"from email.generator import Generator\n"
"fp = StringIO()\n"
"g = Generator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

msgid ""
"If the message object contains binary data that is not encoded according to "
"RFC standards, the non-compliant data will be replaced by unicode \"unknown "
"character\" code points.  (See also :meth:`.as_bytes` and :class:`~email."
"generator.BytesGenerator`.)"
msgstr ""
"Om meddelandeobjektet innehåller binära data som inte är kodade enligt RFC-"
"standarder, kommer de data som inte uppfyller kraven att ersättas av "
"kodpunkter för \"okända tecken\" i Unicode.  (Se även :meth:`.as_bytes` och :"
"class:`~email.generator.BytesGenerator`.)"

msgid "the *policy* keyword argument was added."
msgstr "nyckelordsargumentet *policy* har lagts till."

msgid ""
"Equivalent to :meth:`.as_string`.  Allows ``str(msg)`` to produce a string "
"containing the formatted message."
msgstr ""
"Motsvarar :meth:`.as_string`.  Tillåter ``str(msg)`` att producera en sträng "
"som innehåller det formaterade meddelandet."

msgid ""
"Return the entire message flattened as a bytes object.  When optional "
"*unixfrom* is true, the envelope header is included in the returned string.  "
"*unixfrom* defaults to ``False``.  The *policy* argument may be used to "
"override the default policy obtained from the message instance. This can be "
"used to control some of the formatting produced by the method, since the "
"specified *policy* will be passed to the ``BytesGenerator``."
msgstr ""
"Returnerar hela meddelandet plattat som ett bytesobjekt.  När det valfria "
"*unixfrom* är true inkluderas kuvertrubriken i den returnerade strängen.  "
"*unixfrom* är som standard ``False``.  Argumentet *policy* kan användas för "
"att åsidosätta den standardpolicy som hämtas från meddelandeinstansen. Detta "
"kan användas för att styra en del av formateringen som produceras av "
"metoden, eftersom den angivna *policyn* kommer att skickas till "
"``BytesGenerator``."

msgid ""
"Note that this method is provided as a convenience and may not always format "
"the message the way you want.  For example, by default it does not do the "
"mangling of lines that begin with ``From`` that is required by the Unix mbox "
"format.  For more flexibility, instantiate a :class:`~email.generator."
"BytesGenerator` instance and use its :meth:`~email.generator.BytesGenerator."
"flatten` method directly. For example::"
msgstr ""
"Observera att den här metoden är en bekvämlighetsåtgärd och att den kanske "
"inte alltid formaterar meddelandet på det sätt du vill.  Som standard görs t."
"ex. inte den mangling av rader som börjar med ``From`` som krävs av Unix "
"mbox-format.  För mer flexibilitet kan du instansiera en :class:`~email."
"generator.BytesGenerator`-instans och använda dess :meth:`~email.generator."
"BytesGenerator.flatten`-metod direkt. Till exempel::"

msgid ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"
msgstr ""
"from io import BytesIO\n"
"from email.generator import BytesGenerator\n"
"fp = BytesIO()\n"
"g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)\n"
"g.flatten(msg)\n"
"text = fp.getvalue()"

msgid ""
"Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a bytes "
"object containing the formatted message."
msgstr ""
"Motsvarar :meth:`.as_bytes`.  Tillåter ``bytes(msg)`` att producera ett "
"bytesobjekt som innehåller det formaterade meddelandet."

msgid ""
"Return ``True`` if the message's payload is a list of sub-\\ :class:"
"`Message` objects, otherwise return ``False``.  When :meth:`is_multipart` "
"returns ``False``, the payload should be a string object (which might be a "
"CTE encoded binary payload).  (Note that :meth:`is_multipart` returning "
"``True`` does not necessarily mean that \"msg.get_content_maintype() == "
"'multipart'\" will return the ``True``. For example, ``is_multipart`` will "
"return ``True`` when the :class:`Message` is of type ``message/rfc822``.)"
msgstr ""
"Returnerar ``True`` om meddelandets nyttolast är en lista med sub-objekt av :"
"class:`Message`, annars returneras ``False``.  När :meth:`is_multipart` "
"returnerar ``False``, bör nyttolasten vara ett strängobjekt (som kan vara en "
"CTE-kodad binär nyttolast).  (Observera att om :meth:`is_multipart` "
"returnerar ``True`` betyder det inte nödvändigtvis att \"msg."
"get_content_maintype() == 'multipart'\" kommer att returnera ``True``. Till "
"exempel kommer ``is_multipart`` att returnera ``True`` när :class:`Message` "
"är av typen ``message/rfc822``)"

msgid ""
"Set the message's envelope header to *unixfrom*, which should be a string."
msgstr ""
"Ställ in meddelandets kuverthuvud på *unixfrom*, som ska vara en sträng."

msgid ""
"Return the message's envelope header.  Defaults to ``None`` if the envelope "
"header was never set."
msgstr ""
"Returnerar meddelandets kuverthuvud.  Standardvärdet är ``None`` om "
"kuverthuvudet aldrig har angetts."

msgid ""
"Add the given *payload* to the current payload, which must be ``None`` or a "
"list of :class:`Message` objects before the call. After the call, the "
"payload will always be a list of :class:`Message` objects.  If you want to "
"set the payload to a scalar object (e.g. a string), use :meth:`set_payload` "
"instead."
msgstr ""
"Lägger till den angivna *payload* till den aktuella payloaden, som måste "
"vara ``None`` eller en lista med :class:`Message`-objekt före anropet. Efter "
"anropet kommer nyttolasten alltid att vara en lista med :class:`Message`-"
"objekt.  Om du vill ställa in nyttolasten till ett skalärt objekt (t.ex. en "
"sträng), använd :meth:`set_payload` istället."

msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by :meth:`~email.message.EmailMessage."
"set_content` and the related ``make`` and ``add`` methods."
msgstr ""
"Detta är en äldre metod.  I klassen :class:`~email.message.EmailMessage` "
"ersätts dess funktionalitet av :meth:`~email.message.EmailMessage."
"set_content` och de relaterade metoderna ``make`` och ``add``."

msgid ""
"Return the current payload, which will be a list of :class:`Message` objects "
"when :meth:`is_multipart` is ``True``, or a string when :meth:`is_multipart` "
"is ``False``.  If the payload is a list and you mutate the list object, you "
"modify the message's payload in place."
msgstr ""
"Returnerar den aktuella nyttolasten, som kommer att vara en lista av :class:"
"`Message`-objekt när :meth:`is_multipart` är ``True``, eller en sträng när :"
"meth:`is_multipart` är ``False``.  Om nyttolasten är en lista och du muterar "
"listobjektet, ändrar du meddelandets nyttolast på plats."

msgid ""
"With optional argument *i*, :meth:`get_payload` will return the *i*-th "
"element of the payload, counting from zero, if :meth:`is_multipart` is "
"``True``.  An :exc:`IndexError` will be raised if *i* is less than 0 or "
"greater than or equal to the number of items in the payload.  If the payload "
"is a string (i.e.  :meth:`is_multipart` is ``False``) and *i* is given, a :"
"exc:`TypeError` is raised."
msgstr ""
"Med det valfria argumentet *i* returnerar :meth:`get_payload` det *i*-tredje "
"elementet i payloaden, räknat från noll, om :meth:`is_multipart` är "
"``True``.  Ett :exc:`IndexError` kommer att uppstå om *i* är mindre än 0 "
"eller större än eller lika med antalet element i payloaden.  Om nyttolasten "
"är en sträng (d.v.s. :meth:`is_multipart` är ``False``) och *i* anges, "
"kommer ett :exc:`TypeError` att uppstå."

msgid ""
"Optional *decode* is a flag indicating whether the payload should be decoded "
"or not, according to the :mailheader:`Content-Transfer-Encoding` header. "
"When ``True`` and the message is not a multipart, the payload will be "
"decoded if this header's value is ``quoted-printable`` or ``base64``. If "
"some other encoding is used, or :mailheader:`Content-Transfer-Encoding` "
"header is missing, the payload is returned as-is (undecoded).  In all cases "
"the returned value is binary data.  If the message is a multipart and the "
"*decode* flag is ``True``, then ``None`` is returned.  If the payload is "
"base64 and it was not perfectly formed (missing padding, characters outside "
"the base64 alphabet), then an appropriate defect will be added to the "
"message's defect property (:class:`~email.errors.InvalidBase64PaddingDefect` "
"or :class:`~email.errors.InvalidBase64CharactersDefect`, respectively)."
msgstr ""
"Valfritt *decode* är en flagga som anger om nyttolasten skall avkodas eller "
"inte, enligt :mailheader:`Content-Transfer-Encoding`-rubriken. När ``True`` "
"och meddelandet inte är en multipart, kommer nyttolasten att avkodas om "
"värdet på denna header är ``quoted-printable`` eller ``base64``. Om någon "
"annan kodning används, eller om :mailheader:`Content-Transfer-Encoding`-"
"headern saknas, returneras nyttolasten som den är (odekodad).  I samtliga "
"fall är det returnerade värdet binära data.  Om meddelandet är ett multipart "
"och flaggan *decode* är ``True``, returneras ``None``.  Om nyttolasten är "
"base64 och den inte var perfekt formad (saknar utfyllnad, tecken utanför "
"base64-alfabetet), kommer en lämplig defekt att läggas till meddelandets "
"defektegenskap (:class:`~email.errors.InvalidBase64PaddingDefect` eller :"
"class:`~email.errors.InvalidBase64CharactersDefect`, respektive)."

msgid ""
"When *decode* is ``False`` (the default) the body is returned as a string "
"without decoding the :mailheader:`Content-Transfer-Encoding`.  However, for "
"a :mailheader:`Content-Transfer-Encoding` of 8bit, an attempt is made to "
"decode the original bytes using the ``charset`` specified by the :mailheader:"
"`Content-Type` header, using the ``replace`` error handler. If no "
"``charset`` is specified, or if the ``charset`` given is not recognized by "
"the email package, the body is decoded using the default ASCII charset."
msgstr ""
"När *decode* är ``False`` (standard) returneras meddelandet som en sträng "
"utan avkodning av :mailheader:`Content-Transfer-Encoding`.  För en :"
"mailheader:`Content-Transfer-Encoding` på 8bit görs dock ett försök att "
"avkoda de ursprungliga bytena med hjälp av det ``charset`` som anges i :"
"mailheader:`Content-Type`-huvudet, med hjälp av felhanteraren ``replace``. "
"Om ingen ``charset`` anges, eller om den ``charset`` som anges inte känns "
"igen av e-postpaketet, avkodas texten med standard ASCII-charset."

msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by :meth:`~email.message.EmailMessage."
"get_content` and :meth:`~email.message.EmailMessage.iter_parts`."
msgstr ""
"Detta är en äldre metod.  I klassen :class:`~email.message.EmailMessage` "
"ersätts dess funktionalitet av :meth:`~email.message.EmailMessage."
"get_content` och :meth:`~email.message.EmailMessage.iter_parts`."

msgid ""
"Set the entire message object's payload to *payload*.  It is the client's "
"responsibility to ensure the payload invariants.  Optional *charset* sets "
"the message's default character set; see :meth:`set_charset` for details."
msgstr ""
"Ställ in hela meddelandeobjektets payload till *payload*.  Det är klientens "
"ansvar att se till att nyttolasten är invariant.  Valfri *charset* anger "
"meddelandets standardteckensats; se :meth:`set_charset` för detaljer."

msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by :meth:`~email.message.EmailMessage."
"set_content`."
msgstr ""
"Detta är en äldre metod.  I klassen :class:`~email.message.EmailMessage` "
"ersätts dess funktionalitet av :meth:`~email.message.EmailMessage."
"set_content`."

msgid ""
"Set the character set of the payload to *charset*, which can either be a :"
"class:`~email.charset.Charset` instance (see :mod:`email.charset`), a string "
"naming a character set, or ``None``.  If it is a string, it will be "
"converted to a :class:`~email.charset.Charset` instance.  If *charset* is "
"``None``, the ``charset`` parameter will be removed from the :mailheader:"
"`Content-Type` header (the message will not be otherwise modified).  "
"Anything else will generate a :exc:`TypeError`."
msgstr ""
"Ställer in teckenuppsättningen för nyttolasten till *charset*, som antingen "
"kan vara en :class:`~email.charset.Charset`-instans (se :mod:`email."
"charset`), en sträng som namnger en teckenuppsättning eller ``None``.  Om "
"det är en sträng kommer den att konverteras till en :class:`~email.charset."
"Charset`-instans.  Om *charset* är ``None`` kommer parametern ``charset`` "
"att tas bort från :mailheader:`Content-Type`-rubriken (meddelandet kommer "
"inte att ändras på något annat sätt).  Allt annat kommer att generera ett :"
"exc:`TypeError`."

msgid ""
"If there is no existing :mailheader:`MIME-Version` header one will be "
"added.  If there is no existing :mailheader:`Content-Type` header, one will "
"be added with a value of :mimetype:`text/plain`.  Whether the :mailheader:"
"`Content-Type` header already exists or not, its ``charset`` parameter will "
"be set to *charset.output_charset*.   If *charset.input_charset* and "
"*charset.output_charset* differ, the payload will be re-encoded to the "
"*output_charset*.  If there is no existing :mailheader:`Content-Transfer-"
"Encoding` header, then the payload will be transfer-encoded, if needed, "
"using the specified :class:`~email.charset.Charset`, and a header with the "
"appropriate value will be added.  If a :mailheader:`Content-Transfer-"
"Encoding` header already exists, the payload is assumed to already be "
"correctly encoded using that :mailheader:`Content-Transfer-Encoding` and is "
"not modified."
msgstr ""
"Om det inte finns någon befintlig :mailheader:`MIME-Version` header kommer "
"en sådan att läggas till.  Om det inte finns någon befintlig :mailheader:"
"`Content-Type` header, kommer en sådan att läggas till med värdet :mimetype:"
"`text/plain`.  Oavsett om rubriken :mailheader:`Content-Type` redan finns "
"eller inte, kommer dess parameter ``charset`` att sättas till *charset."
"output_charset*.   Om *charset.input_charset* och *charset.output_charset* "
"skiljer sig åt kommer nyttolasten att kodas om till *output_charset*.  Om "
"det inte finns något befintligt :mailheader:`Content-Transfer-Encoding`-"
"huvud, kommer nyttolasten att överföringskodas, om det behövs, med hjälp av "
"den angivna :class:`~email.charset.Charset`, och ett huvud med lämpligt "
"värde kommer att läggas till.  Om en :mailheader:`Content-Transfer-Encoding` "
"header redan finns, antas nyttolasten redan vara korrekt kodad med hjälp av "
"den :mailheader:`Content-Transfer-Encoding` och ändras inte."

msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by the *charset* parameter of the :meth:`email."
"message.EmailMessage.set_content` method."
msgstr ""
"Detta är en äldre metod.  I klassen :class:`~email.message.EmailMessage` "
"ersätts dess funktionalitet av parametern *charset* i metoden :meth:`email."
"message.EmailMessage.set_content`."

msgid ""
"Return the :class:`~email.charset.Charset` instance associated with the "
"message's payload."
msgstr ""
"Returnerar :class:`~email.charset.Charset`-instansen som är associerad med "
"meddelandets nyttolast."

msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"it always returns ``None``."
msgstr ""
"Detta är en äldre metod.  I klassen :class:`~email.message.EmailMessage` "
"returnerar den alltid ``None``."

msgid ""
"The following methods implement a mapping-like interface for accessing the "
"message's :rfc:`2822` headers.  Note that there are some semantic "
"differences between these methods and a normal mapping (i.e. dictionary) "
"interface.  For example, in a dictionary there are no duplicate keys, but "
"here there may be duplicate message headers.  Also, in dictionaries there is "
"no guaranteed order to the keys returned by :meth:`keys`, but in a :class:"
"`Message` object, headers are always returned in the order they appeared in "
"the original message, or were added to the message later.  Any header "
"deleted and then re-added are always appended to the end of the header list."
msgstr ""
"Följande metoder implementerar ett mappningsliknande gränssnitt för åtkomst "
"till meddelandets :rfc:`2822`-rubriker.  Observera att det finns vissa "
"semantiska skillnader mellan dessa metoder och ett normalt "
"mappningsgränssnitt (dvs. ett dictionary-gränssnitt).  I en dictionary finns "
"det t.ex. inga duplicerade nycklar, men här kan det finnas duplicerade "
"meddelandehuvuden.  I ordböcker finns det inte heller någon garanterad "
"ordning på de nycklar som returneras av :meth:`keys`, men i ett :class:"
"`Message`-objekt returneras alltid rubrikerna i den ordning de förekom i det "
"ursprungliga meddelandet eller lades till i meddelandet senare.  Eventuella "
"rubriker som raderats och sedan lagts till igen läggs alltid till i slutet "
"av rubriklistan."

msgid ""
"These semantic differences are intentional and are biased toward maximal "
"convenience."
msgstr ""
"Dessa semantiska skillnader är avsiktliga och syftar till maximal "
"bekvämlighet."

msgid ""
"Note that in all cases, any envelope header present in the message is not "
"included in the mapping interface."
msgstr ""
"Observera att i samtliga fall ingår inte eventuella kuvertrubriker som finns "
"i meddelandet i mappningsgränssnittet."

msgid ""
"In a model generated from bytes, any header values that (in contravention of "
"the RFCs) contain non-ASCII bytes will, when retrieved through this "
"interface, be represented as :class:`~email.header.Header` objects with a "
"charset of ``unknown-8bit``."
msgstr ""
"I en modell som genereras från byte kommer alla rubrikvärden som (i strid "
"med RFC) innehåller icke-ASCII-byte, när de hämtas via detta gränssnitt, att "
"representeras som :class:`~email.header.Header`-objekt med en "
"teckenuppsättning på ``unknown-8bit``."

msgid "Return the total number of headers, including duplicates."
msgstr "Returnerar det totala antalet headers, inklusive dubbletter."

msgid ""
"Return ``True`` if the message object has a field named *name*. Matching is "
"done case-insensitively and *name* should not include the trailing colon. "
"Used for the ``in`` operator, e.g.::"
msgstr ""
"Returnerar ``True`` om meddelandeobjektet har ett fält med namnet *name*. "
"Matchning sker utan hänsyn till skiftlägesskillnader och *namn* bör inte "
"innehålla kolon. Används för operatorn ``in``, t.ex.::"

msgid ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"
msgstr ""
"if 'message-id' in myMessage:\n"
"   print('Message-ID:', myMessage['message-id'])"

msgid ""
"Return the value of the named header field.  *name* should not include the "
"colon field separator.  If the header is missing, ``None`` is returned; a :"
"exc:`KeyError` is never raised."
msgstr ""
"Returnerar värdet för det namngivna rubrikfältet.  *name* bör inte innehålla "
"fältavgränsaren kolon.  Om rubriken saknas returneras ``None``; ett :exc:"
"`KeyError` uppstår aldrig."

msgid ""
"Note that if the named field appears more than once in the message's "
"headers, exactly which of those field values will be returned is undefined.  "
"Use the :meth:`get_all` method to get the values of all the extant named "
"headers."
msgstr ""
"Observera att om det namngivna fältet förekommer mer än en gång i "
"meddelandets rubriker är det odefinierat exakt vilket av dessa fältvärden "
"som kommer att returneras.  Använd metoden :meth:`get_all` för att få "
"värdena för alla befintliga namngivna rubriker."

msgid ""
"Add a header to the message with field name *name* and value *val*.  The "
"field is appended to the end of the message's existing fields."
msgstr ""
"Lägg till en rubrik i meddelandet med fältnamnet *name* och värdet *val*.  "
"Fältet läggs till i slutet av meddelandets befintliga fält."

msgid ""
"Note that this does *not* overwrite or delete any existing header with the "
"same name.  If you want to ensure that the new header is the only one "
"present in the message with field name *name*, delete the field first, e.g.::"
msgstr ""
"Observera att detta *inte* skriver över eller raderar någon befintlig header "
"med samma namn.  Om du vill vara säker på att det nya sidhuvudet är det enda "
"som finns i meddelandet med fältnamnet *namn*, raderar du fältet först, t."
"ex.::"

msgid ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"
msgstr ""
"del msg['subject']\n"
"msg['subject'] = 'Python roolz!'"

msgid ""
"Delete all occurrences of the field with name *name* from the message's "
"headers.  No exception is raised if the named field isn't present in the "
"headers."
msgstr ""
"Ta bort alla förekomster av fältet med namnet *namn* från meddelandets "
"rubriker.  Inget undantag görs om det namngivna fältet inte finns med i "
"sidhuvudet."

msgid "Return a list of all the message's header field names."
msgstr "Returnerar en lista med alla namn på fält i meddelandets header."

msgid "Return a list of all the message's field values."
msgstr "Returnerar en lista med alla fältvärden i meddelandet."

msgid ""
"Return a list of 2-tuples containing all the message's field headers and "
"values."
msgstr ""
"Returnerar en lista med 2-tuples som innehåller alla meddelandets "
"fältrubriker och värden."

msgid ""
"Return the value of the named header field.  This is identical to :meth:"
"`~object.__getitem__` except that optional *failobj* is returned if the "
"named header is missing (defaults to ``None``)."
msgstr ""
"Returnerar värdet för det namngivna rubrikfältet.  Detta är identiskt med :"
"meth:`~object.__getitem__` förutom att den valfria *failobj* returneras om "
"det angivna sidhuvudet saknas (standard är ``None``)."

msgid "Here are some additional useful methods:"
msgstr "Här är några ytterligare användbara metoder:"

msgid ""
"Return a list of all the values for the field named *name*. If there are no "
"such named headers in the message, *failobj* is returned (defaults to "
"``None``)."
msgstr ""
"Returnerar en lista med alla värden för fältet med namnet *name*. Om det "
"inte finns några sådana namngivna rubriker i meddelandet returneras "
"*failobj* (standardvärde är ``None``)."

msgid ""
"Extended header setting.  This method is similar to :meth:`__setitem__` "
"except that additional header parameters can be provided as keyword "
"arguments.  *_name* is the header field to add and *_value* is the *primary* "
"value for the header."
msgstr ""
"Utökad inställning av sidhuvud.  Den här metoden liknar :meth:`__setitem__` "
"förutom att ytterligare rubrikparametrar kan anges som nyckelordsargument.  "
"*_name* är rubrikfältet som ska läggas till och *_value* är det *primära* "
"värdet för rubriken."

msgid ""
"For each item in the keyword argument dictionary *_params*, the key is taken "
"as the parameter name, with underscores converted to dashes (since dashes "
"are illegal in Python identifiers).  Normally, the parameter will be added "
"as ``key=\"value\"`` unless the value is ``None``, in which case only the "
"key will be added.  If the value contains non-ASCII characters, it can be "
"specified as a three tuple in the format ``(CHARSET, LANGUAGE, VALUE)``, "
"where ``CHARSET`` is a string naming the charset to be used to encode the "
"value, ``LANGUAGE`` can usually be set to ``None`` or the empty string (see :"
"rfc:`2231` for other possibilities), and ``VALUE`` is the string value "
"containing non-ASCII code points.  If a three tuple is not passed and the "
"value contains non-ASCII characters, it is automatically encoded in :rfc:"
"`2231` format using a ``CHARSET`` of ``utf-8`` and a ``LANGUAGE`` of "
"``None``."
msgstr ""
"För varje objekt i nyckelordets argumentordbok *_params* tas nyckeln som "
"parameternamn, med understrykningar konverterade till bindestreck (eftersom "
"bindestreck är olagliga i Python-identifierare).  Normalt kommer parametern "
"att läggas till som ``key=\"value\"`` om inte värdet är ``None``, i vilket "
"fall endast nyckeln kommer att läggas till.  Om värdet innehåller icke-ASCII-"
"tecken kan det specificeras som en tupel med tre tecken i formatet "
"``(CHARSET, LANGUAGE, VALUE)``, där ``CHARSET`` är en sträng som namnger det "
"teckenuppsättning som skall användas för att koda värdet, ``LANGUAGE`` kan "
"vanligtvis sättas till ``None`` eller tomsträngen (se :rfc:`2231` för andra "
"möjligheter), och ``VALUE`` är strängvärdet som innehåller icke-ASCII-"
"kodpunkter.  Om en tupel med tre inte skickas och värdet innehåller icke-"
"ASCII-tecken, kodas det automatiskt i :rfc:`2231`-format med ``CHARSET`` "
"``utf-8`` och ``LANGUAGE`` ``None``."

msgid "Here's an example::"
msgstr "Här är ett exempel::"

msgid "msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')"

msgid "This will add a header that looks like ::"
msgstr "Detta kommer att lägga till en rubrik som ser ut som ::"

msgid "Content-Disposition: attachment; filename=\"bud.gif\""
msgstr "Content-Disposition: attachment; filename=\"bud.gif\""

msgid "An example with non-ASCII characters::"
msgstr "Ett exempel med icke-ASCII-tecken::"

msgid ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"
msgstr ""
"msg.add_header('Content-Disposition', 'attachment',\n"
"               filename=('iso-8859-1', '', 'Fußballer.ppt'))"

msgid "Which produces ::"
msgstr "Som producerar ::"

msgid ""
"Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""
msgstr ""
"Content-Disposition: attachment; filename*=\"iso-8859-1''Fu%DFballer.ppt\""

msgid ""
"Replace a header.  Replace the first header found in the message that "
"matches *_name*, retaining header order and field name case.  If no matching "
"header was found, a :exc:`KeyError` is raised."
msgstr ""
"Ersätt ett huvud.  Ersätt den första headern som hittas i meddelandet som "
"matchar *_namn*, med bibehållen headerordning och skiftlägesordning för "
"fältnamn.  Om inget matchande huvud hittades, uppstår ett :exc:`KeyError`."

msgid ""
"Return the message's content type.  The returned string is coerced to lower "
"case of the form :mimetype:`maintype/subtype`.  If there was no :mailheader:"
"`Content-Type` header in the message the default type as given by :meth:"
"`get_default_type` will be returned.  Since according to :rfc:`2045`, "
"messages always have a default type, :meth:`get_content_type` will always "
"return a value."
msgstr ""
"Returnerar meddelandets innehållstyp.  Den returnerade strängen är tvingad "
"till gemener av formen :mimetype:`maintype/subtype`.  Om det inte fanns "
"någon :mailheader:`Content-Type` header i meddelandet returneras "
"standardtypen som anges av :meth:`get_default_type`.  Eftersom meddelanden "
"enligt :rfc:`2045` alltid har en standardtyp, kommer :meth:"
"`get_content_type` alltid att returnera ett värde."

msgid ""
":rfc:`2045` defines a message's default type to be :mimetype:`text/plain` "
"unless it appears inside a :mimetype:`multipart/digest` container, in which "
"case it would be :mimetype:`message/rfc822`.  If the :mailheader:`Content-"
"Type` header has an invalid type specification, :rfc:`2045` mandates that "
"the default type be :mimetype:`text/plain`."
msgstr ""
"Enligt :rfc:`2045` är standardtypen för ett meddelande :mimetype:`text/"
"plain`, såvida det inte finns i en :mimetype:`multipart/digest`-behållare, i "
"vilket fall det skulle vara :mimetype:`message/rfc822`.  Om rubriken :"
"mailheader:`Content-Type` har en ogiltig typspecifikation, föreskriver :rfc:"
"`2045` att standardtypen skall vara :mimetype:`text/plain`."

msgid ""
"Return the message's main content type.  This is the :mimetype:`maintype` "
"part of the string returned by :meth:`get_content_type`."
msgstr ""
"Returnerar meddelandets huvudsakliga innehållstyp.  Detta är :mimetype:"
"`maintype`-delen av strängen som returneras av :meth:`get_content_type`."

msgid ""
"Return the message's sub-content type.  This is the :mimetype:`subtype` part "
"of the string returned by :meth:`get_content_type`."
msgstr ""
"Returnerar meddelandets typ av underinnehåll.  Detta är :mimetype:`subtype`-"
"delen av strängen som returneras av :meth:`get_content_type`."

msgid ""
"Return the default content type.  Most messages have a default content type "
"of :mimetype:`text/plain`, except for messages that are subparts of :"
"mimetype:`multipart/digest` containers.  Such subparts have a default "
"content type of :mimetype:`message/rfc822`."
msgstr ""
"Returnerar den förvalda innehållstypen.  De flesta meddelanden har "
"standardinnehållstypen :mimetype:`text/plain`, utom meddelanden som är "
"underdelar av behållare av typen :mimetype:`multipart/digest`.  Sådana "
"underdelar har en standardinnehållstyp av typen :mimetype:`message/rfc822`."

msgid ""
"Set the default content type.  *ctype* should either be :mimetype:`text/"
"plain` or :mimetype:`message/rfc822`, although this is not enforced.  The "
"default content type is not stored in the :mailheader:`Content-Type` header."
msgstr ""
"Ställer in standardinnehållstypen.  *ctype* bör antingen vara :mimetype:"
"`text/plain` eller :mimetype:`message/rfc822`, även om detta inte är "
"obligatoriskt.  Standardinnehållstypen lagras inte i rubriken :mailheader:"
"`Content-Type`."

msgid ""
"Return the message's :mailheader:`Content-Type` parameters, as a list. The "
"elements of the returned list are 2-tuples of key/value pairs, as split on "
"the ``'='`` sign.  The left hand side of the ``'='`` is the key, while the "
"right hand side is the value.  If there is no ``'='`` sign in the parameter "
"the value is the empty string, otherwise the value is as described in :meth:"
"`get_param` and is unquoted if optional *unquote* is ``True`` (the default)."
msgstr ""
"Returnerar meddelandets :mailheader:`Content-Type`-parametrar som en lista. "
"Elementen i den returnerade listan är 2-tuples av nyckel/värde-par, som "
"delas upp med tecknet ``'='``.  Den vänstra sidan av ``'='`` är nyckeln, "
"medan den högra sidan är värdet.  Om det inte finns något ``'='``-tecken i "
"parametern är värdet den tomma strängen, annars är värdet enligt "
"beskrivningen i :meth:`get_param` och är ociterat om den valfria *unquote* "
"är ``True`` (standard)."

msgid ""
"Optional *failobj* is the object to return if there is no :mailheader:"
"`Content-Type` header.  Optional *header* is the header to search instead "
"of :mailheader:`Content-Type`."
msgstr ""
"Valfritt *failobj* är det objekt som skall returneras om det inte finns "
"något :mailheader:`Content-Type`-huvud.  Valfritt *header* är rubriken som "
"ska sökas i stället för :mailheader:`Content-Type`."

msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by the *params* property of the individual "
"header objects returned by the header access methods."
msgstr ""
"Detta är en äldre metod.  I klassen :class:`~email.message.EmailMessage` "
"ersätts dess funktionalitet av egenskapen *params* i de enskilda "
"rubrikobjekt som returneras av metoderna för rubrikåtkomst."

msgid ""
"Return the value of the :mailheader:`Content-Type` header's parameter "
"*param* as a string.  If the message has no :mailheader:`Content-Type` "
"header or if there is no such parameter, then *failobj* is returned "
"(defaults to ``None``)."
msgstr ""
"Returnerar värdet av :mailheader:`Content-Type`-headerns parameter *param* "
"som en sträng.  Om meddelandet inte har någon :mailheader:`Content-Type`-"
"rubrik eller om det inte finns någon sådan parameter returneras *failobj* "
"(standardvärde är ``None``)."

msgid ""
"Optional *header* if given, specifies the message header to use instead of :"
"mailheader:`Content-Type`."
msgstr ""
"Valfritt *header* om det anges, anger meddelandehuvudet som ska användas i "
"stället för :mailheader:`Content-Type`."

msgid ""
"Parameter keys are always compared case insensitively.  The return value can "
"either be a string, or a 3-tuple if the parameter was :rfc:`2231` encoded.  "
"When it's a 3-tuple, the elements of the value are of the form ``(CHARSET, "
"LANGUAGE, VALUE)``.  Note that both ``CHARSET`` and ``LANGUAGE`` can be "
"``None``, in which case you should consider ``VALUE`` to be encoded in the "
"``us-ascii`` charset.  You can usually ignore ``LANGUAGE``."
msgstr ""
"Parameternycklar jämförs alltid utan hänsyn till skift.  Returvärdet kan "
"antingen vara en sträng eller en 3-tupel om parametern var :rfc:`2231`-"
"kodad.  När det är en 3-tupel är elementen i värdet av formen ``(CHARSET, "
"LANGUAGE, VALUE)``.  Observera att både ``CHARSET`` och ``LANGUAGE`` kan "
"vara ``None``, i vilket fall du bör betrakta ``VALUE`` som kodat i ``us-"
"ascii`` charset.  Du kan vanligtvis ignorera ``LANGUAGE``."

msgid ""
"If your application doesn't care whether the parameter was encoded as in :"
"rfc:`2231`, you can collapse the parameter value by calling :func:`email."
"utils.collapse_rfc2231_value`, passing in the return value from :meth:"
"`get_param`.  This will return a suitably decoded Unicode string when the "
"value is a tuple, or the original string unquoted if it isn't.  For example::"
msgstr ""
"Om din applikation inte bryr sig om huruvida parametern kodades enligt :rfc:"
"`2231`, kan du kollapsa parametervärdet genom att anropa :func:`email.utils."
"collapse_rfc2231_value` och skicka in returvärdet från :meth:`get_param`.  "
"Detta kommer att returnera en lämpligt avkodad Unicode-sträng när värdet är "
"en tupel, eller originalsträngen utan citat om den inte är det.  Till "
"exempel::"

msgid ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"
msgstr ""
"rawparam = msg.get_param('foo')\n"
"param = email.utils.collapse_rfc2231_value(rawparam)"

msgid ""
"In any case, the parameter value (either the returned string, or the "
"``VALUE`` item in the 3-tuple) is always unquoted, unless *unquote* is set "
"to ``False``."
msgstr ""
"I vilket fall som helst är parametervärdet (antingen den returnerade "
"strängen eller ``VALUE``-objektet i 3-tupeln) alltid ociterat, såvida inte "
"*unquote* är satt till ``False``."

msgid ""
"Set a parameter in the :mailheader:`Content-Type` header.  If the parameter "
"already exists in the header, its value will be replaced with *value*.  If "
"the :mailheader:`Content-Type` header as not yet been defined for this "
"message, it will be set to :mimetype:`text/plain` and the new parameter "
"value will be appended as per :rfc:`2045`."
msgstr ""
"Ange en parameter i :mailheader:s `Content-Type`-rubrik.  Om parametern "
"redan finns i rubriken kommer dess värde att ersättas med *värde*.  Om "
"rubriken :mailheader:`Content-Type` ännu inte har definierats för detta "
"meddelande, kommer den att sättas till :mimetype:`text/plain` och det nya "
"parametervärdet kommer att läggas till enligt :rfc:`2045`."

msgid ""
"Optional *header* specifies an alternative header to :mailheader:`Content-"
"Type`, and all parameters will be quoted as necessary unless optional "
"*requote* is ``False`` (the default is ``True``)."
msgstr ""
"Det valfria *header* anger ett alternativt huvud till :mailheader:`Content-"
"Type`, och alla parametrar kommer att citeras vid behov om inte det valfria "
"*requote* är ``False`` (standard är ``True``)."

msgid ""
"If optional *charset* is specified, the parameter will be encoded according "
"to :rfc:`2231`. Optional *language* specifies the RFC 2231 language, "
"defaulting to the empty string.  Both *charset* and *language* should be "
"strings."
msgstr ""
"Om *charset* anges som tillval kommer parametern att kodas enligt :rfc:"
"`2231`. Det valfria *language* anger RFC 2231-språket, med den tomma "
"strängen som standard.  Både *charset* och *language* bör vara strängar."

msgid ""
"If *replace* is ``False`` (the default) the header is moved to the end of "
"the list of headers.  If *replace* is ``True``, the header will be updated "
"in place."
msgstr ""
"Om *replace* är ``False`` (standard) flyttas rubriken till slutet av listan "
"med rubriker.  Om *replace* är ``True`` kommer rubriken att uppdateras på "
"plats."

msgid "``replace`` keyword was added."
msgstr "nyckelordet ``replace`` har lagts till."

msgid ""
"Remove the given parameter completely from the :mailheader:`Content-Type` "
"header.  The header will be re-written in place without the parameter or its "
"value.  All values will be quoted as necessary unless *requote* is ``False`` "
"(the default is ``True``).  Optional *header* specifies an alternative to :"
"mailheader:`Content-Type`."
msgstr ""
"Tar bort den angivna parametern helt från :mailheader:`Content-Type`-"
"huvudet.  Rubriken kommer att skrivas om på plats utan parametern eller dess "
"värde.  Alla värden kommer att citeras vid behov om inte *requote* är "
"``False`` (standard är ``True``).  Valfria *header* anger ett alternativ "
"till :mailheader:`Content-Type`."

msgid ""
"Set the main type and subtype for the :mailheader:`Content-Type` header. "
"*type* must be a string in the form :mimetype:`maintype/subtype`, otherwise "
"a :exc:`ValueError` is raised."
msgstr ""
"Anger huvudtyp och undertyp för rubriken :mailheader:`Content-Type`. *type* "
"måste vara en sträng i formen :mimetype:`maintype/subtype`, annars uppstår "
"ett :exc:`ValueError`."

msgid ""
"This method replaces the :mailheader:`Content-Type` header, keeping all the "
"parameters in place.  If *requote* is ``False``, this leaves the existing "
"header's quoting as is, otherwise the parameters will be quoted (the "
"default)."
msgstr ""
"Denna metod ersätter :mailheader:`Content-Type`-headern och behåller alla "
"parametrar på plats.  Om *requote* är ``False``, lämnas den befintliga "
"headerns citering som den är, annars kommer parametrarna att citeras "
"(standard)."

msgid ""
"An alternative header can be specified in the *header* argument. When the :"
"mailheader:`Content-Type` header is set a :mailheader:`MIME-Version` header "
"is also added."
msgstr ""
"Ett alternativt huvud kan anges i argumentet *header*. När rubriken :"
"mailheader:`Content-Type` anges läggs även rubriken :mailheader:`MIME-"
"Version` till."

msgid ""
"This is a legacy method.  On the :class:`~email.message.EmailMessage` class "
"its functionality is replaced by the ``make_`` and ``add_`` methods."
msgstr ""
"Detta är en äldre metod.  I klassen :class:`~email.message.EmailMessage` "
"ersätts dess funktionalitet av metoderna ``make_`` och ``add_``."

msgid ""
"Return the value of the ``filename`` parameter of the :mailheader:`Content-"
"Disposition` header of the message.  If the header does not have a "
"``filename`` parameter, this method falls back to looking for the ``name`` "
"parameter on the :mailheader:`Content-Type` header.  If neither is found, or "
"the header is missing, then *failobj* is returned. The returned string will "
"always be unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Returnerar värdet på parametern ``filename`` i :mailheader:`Content-"
"Disposition`-rubriken i meddelandet.  Om rubriken inte har någon parameter "
"för ``filename``, går denna metod tillbaka till att leta efter parametern "
"``name`` i rubriken :mailheader:`Content-Type`.  Om ingen av dessa hittas, "
"eller om rubriken saknas, returneras *failobj*. Den returnerade strängen "
"kommer alltid att vara ociterad enligt :func:`email.utils.unquote`."

msgid ""
"Return the value of the ``boundary`` parameter of the :mailheader:`Content-"
"Type` header of the message, or *failobj* if either the header is missing, "
"or has no ``boundary`` parameter.  The returned string will always be "
"unquoted as per :func:`email.utils.unquote`."
msgstr ""
"Returnerar värdet på parametern ``boundary`` i :mailheader:`Content-Type`-"
"rubriken i meddelandet, eller *failobj* om rubriken saknas eller inte har "
"någon parameter för ``boundary``.  Den returnerade strängen kommer alltid "
"att vara ociterad enligt :func:`email.utils.unquote`."

msgid ""
"Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to "
"*boundary*.  :meth:`set_boundary` will always quote *boundary* if "
"necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the message "
"object has no :mailheader:`Content-Type` header."
msgstr ""
"Ställ in parametern ``boundary`` i rubriken :mailheader:`Content-Type` till "
"*boundary*. :meth:`set_boundary` kommer alltid att citera *boundary* om det "
"behövs.  Ett :exc:`~email.errors.HeaderParseError` uppstår om "
"meddelandeobjektet inte har något :mailheader:`Content-Type`-huvud."

msgid ""
"Note that using this method is subtly different than deleting the old :"
"mailheader:`Content-Type` header and adding a new one with the new boundary "
"via :meth:`add_header`, because :meth:`set_boundary` preserves the order of "
"the :mailheader:`Content-Type` header in the list of headers. However, it "
"does *not* preserve any continuation lines which may have been present in "
"the original :mailheader:`Content-Type` header."
msgstr ""
"Observera att den här metoden är något annorlunda än att ta bort den gamla :"
"mailheader:`Content-Type`-rubriken och lägga till en ny med den nya gränsen "
"via :meth:`add_header`, eftersom :meth:`set_boundary` bevarar ordningen på :"
"mailheader:`Content-Type`-rubriken i listan över rubriker. Den bevarar dock "
"*inte* några fortsättningsrader som kan ha funnits i den ursprungliga :"
"mailheader:`Content-Type`-rubriken."

msgid ""
"Return the ``charset`` parameter of the :mailheader:`Content-Type` header, "
"coerced to lower case.  If there is no :mailheader:`Content-Type` header, or "
"if that header has no ``charset`` parameter, *failobj* is returned."
msgstr ""
"Returnerar parametern ``charset`` för rubriken :mailheader:`Content-Type`, "
"omgjord till gemener.  Om det inte finns någon :mailheader:`Content-Type` "
"header, eller om den headern inte har någon ``charset`` parameter, "
"returneras *failobj*."

msgid ""
"Note that this method differs from :meth:`get_charset` which returns the :"
"class:`~email.charset.Charset` instance for the default encoding of the "
"message body."
msgstr ""
"Observera att den här metoden skiljer sig från :meth:`get_charset` som "
"returnerar :class:`~email.charset.Charset`-instansen för standardkodningen "
"av meddelandetexten."

msgid ""
"Return a list containing the character set names in the message.  If the "
"message is a :mimetype:`multipart`, then the list will contain one element "
"for each subpart in the payload, otherwise, it will be a list of length 1."
msgstr ""
"Returnerar en lista som innehåller teckenuppsättningsnamnen i meddelandet.  "
"Om meddelandet är en :mimetype:`multipart`, kommer listan att innehålla ett "
"element för varje underdel i nyttolasten, annars kommer det att vara en "
"lista med längden 1."

msgid ""
"Each item in the list will be a string which is the value of the ``charset`` "
"parameter in the :mailheader:`Content-Type` header for the represented "
"subpart.  However, if the subpart has no :mailheader:`Content-Type` header, "
"no ``charset`` parameter, or is not of the :mimetype:`text` main MIME type, "
"then that item in the returned list will be *failobj*."
msgstr ""
"Varje post i listan kommer att vara en sträng som är värdet på parametern "
"``charset`` i :mailheader:`Content-Type`-huvudet för den representerade "
"underdelen.  Men om underdelen inte har något :mailheader:`Content-Type`-"
"huvud, ingen ``charset``-parameter eller inte är av huvud-MIME-typen :"
"mimetype:`text`, kommer den posten i den returnerade listan att vara "
"*failobj*."

msgid ""
"Return the lowercased value (without parameters) of the message's :"
"mailheader:`Content-Disposition` header if it has one, or ``None``.  The "
"possible values for this method are *inline*, *attachment* or ``None`` if "
"the message follows :rfc:`2183`."
msgstr ""
"Returnerar det gemena värdet (utan parametrar) av meddelandets :mailheader:"
"`Content-Disposition`-huvud om det har ett sådant, eller ``None``.  De "
"möjliga värdena för denna metod är *inline*, *attachment* eller ``None`` om "
"meddelandet följer :rfc:`2183`."

msgid ""
"The :meth:`walk` method is an all-purpose generator which can be used to "
"iterate over all the parts and subparts of a message object tree, in depth-"
"first traversal order.  You will typically use :meth:`walk` as the iterator "
"in a ``for`` loop; each iteration returns the next subpart."
msgstr ""
"Metoden :meth:`walk` är en allroundgenerator som kan användas för att "
"iterera över alla delar och underdelar i ett meddelandeobjektträd, i "
"djupförsta traversalordning.  Du kommer vanligtvis att använda :meth:`walk` "
"som iterator i en ``for``-loop; varje iteration returnerar nästa underdel."

msgid ""
"Here's an example that prints the MIME type of every part of a multipart "
"message structure:"
msgstr ""
"Här är ett exempel som skriver ut MIME-typen för varje del i en flerdelad "
"meddelandestruktur:"

msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_type())\n"
"multipart/report\n"
"text/plain\n"
"message/delivery-status\n"
"text/plain\n"
"text/plain\n"
"message/rfc822\n"
"text/plain"

msgid ""
"``walk`` iterates over the subparts of any part where :meth:`is_multipart` "
"returns ``True``, even though ``msg.get_content_maintype() == 'multipart'`` "
"may return ``False``.  We can see this in our example by making use of the "
"``_structure`` debug helper function:"
msgstr ""
"``walk`` itererar över underdelarna av alla delar där :meth:`is_multipart`` "
"returnerar ``True``, även om ``msg.get_content_maintype() == 'multipart'`` "
"kan returnera ``False``.  Vi kan se detta i vårt exempel genom att använda "
"hjälpfunktionen ``_structure`` debug:"

msgid ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"
msgstr ""
">>> for part in msg.walk():\n"
"...     print(part.get_content_maintype() == 'multipart',\n"
"...           part.is_multipart())\n"
"True True\n"
"False False\n"
"False True\n"
"False False\n"
"False False\n"
"False True\n"
"False False\n"
">>> _structure(msg)\n"
"multipart/report\n"
"    text/plain\n"
"    message/delivery-status\n"
"        text/plain\n"
"        text/plain\n"
"    message/rfc822\n"
"        text/plain"

msgid ""
"Here the ``message`` parts are not ``multiparts``, but they do contain "
"subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends into the "
"subparts."
msgstr ""
"Här är ``message`` delarna inte ``multiparts``, men de innehåller subparts. "
"``is_multipart()`` returnerar ``True`` och ``walk`` går ner i underdelarna."

msgid ""
":class:`Message` objects can also optionally contain two instance "
"attributes, which can be used when generating the plain text of a MIME "
"message."
msgstr ""
":class:`Message`-objekt kan också innehålla två instansattribut, som kan "
"användas när man genererar klartexten i ett MIME-meddelande."

msgid ""
"The format of a MIME document allows for some text between the blank line "
"following the headers, and the first multipart boundary string. Normally, "
"this text is never visible in a MIME-aware mail reader because it falls "
"outside the standard MIME armor.  However, when viewing the raw text of the "
"message, or when viewing the message in a non-MIME aware reader, this text "
"can become visible."
msgstr ""
"Formatet för ett MIME-dokument tillåter viss text mellan blankraden efter "
"rubrikerna och den första multipart boundary-strängen. Normalt är denna text "
"aldrig synlig i en MIME-medveten e-postläsare eftersom den faller utanför "
"MIME-standarden.  Men när man tittar på råtexten i meddelandet, eller när "
"man tittar på meddelandet i en läsare som inte är MIME-medveten, kan denna "
"text bli synlig."

msgid ""
"The *preamble* attribute contains this leading extra-armor text for MIME "
"documents.  When the :class:`~email.parser.Parser` discovers some text after "
"the headers but before the first boundary string, it assigns this text to "
"the message's *preamble* attribute.  When the :class:`~email.generator."
"Generator` is writing out the plain text representation of a MIME message, "
"and it finds the message has a *preamble* attribute, it will write this text "
"in the area between the headers and the first boundary.  See :mod:`email."
"parser` and :mod:`email.generator` for details."
msgstr ""
"Attributet *preamble* innehåller denna ledande extra pansartext för MIME-"
"dokument.  När :class:`~email.parser.Parser` upptäcker text efter rubrikerna "
"men före den första gränssträngen, tilldelar den denna text till "
"meddelandets *preamble*-attribut.  När :class:`~email.generator.Generator` "
"skriver ut klartextrepresentationen av ett MIME-meddelande och upptäcker att "
"meddelandet har ett *preamble*-attribut, skriver den denna text i området "
"mellan rubrikerna och den första gränssträngen.  Se :mod:`email.parser` och :"
"mod:`email.generator` för mer information."

msgid ""
"Note that if the message object has no preamble, the *preamble* attribute "
"will be ``None``."
msgstr ""
"Observera att om meddelandeobjektet inte har någon preamble, kommer "
"attributet *preamble* att vara ``None``."

msgid ""
"The *epilogue* attribute acts the same way as the *preamble* attribute, "
"except that it contains text that appears between the last boundary and the "
"end of the message."
msgstr ""
"Attributet *epilogue* fungerar på samma sätt som attributet *preamble*, "
"förutom att det innehåller text som visas mellan den sista boundary och "
"slutet av meddelandet."

msgid ""
"You do not need to set the epilogue to the empty string in order for the :"
"class:`~email.generator.Generator` to print a newline at the end of the file."
msgstr ""
"Du behöver inte sätta epilogen till den tomma strängen för att :class:"
"`~email.generator.Generator` ska skriva ut en ny rad i slutet av filen."

msgid ""
"The *defects* attribute contains a list of all the problems found when "
"parsing this message.  See :mod:`email.errors` for a detailed description of "
"the possible parsing defects."
msgstr ""
"Attributet *defects* innehåller en lista över alla problem som upptäcktes "
"när meddelandet analyserades.  Se :mod:`email.errors` för en detaljerad "
"beskrivning av de möjliga defekterna vid tolkningen."
