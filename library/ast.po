# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!ast` --- Abstract syntax trees"
msgstr ":mod:`!ast` --- Abstrakta syntaxträd"

msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Källkod:** :source:`Lib/ast.py`"

msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"Modulen :mod:`ast` hjälper Python-program att bearbeta träd av Pythons "
"abstrakta syntaxgrammatik.  Den abstrakta syntaxen i sig kan ändras med "
"varje Python-version; den här modulen hjälper till att programmatiskt ta "
"reda på hur den aktuella grammatiken ser ut."

msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Ett abstrakt syntaxträd kan genereras genom att skicka :data:`ast."
"PyCF_ONLY_AST` som en flagga till den inbyggda funktionen :func:`compile`, "
"eller genom att använda hjälpen :func:`parse` som finns i den här modulen.  "
"Resultatet blir ett träd av objekt vars klasser alla ärver från :class:`ast."
"AST`.  Ett abstrakt syntaxträd kan kompileras till ett Python-kodobjekt med "
"hjälp av den inbyggda funktionen :func:`compile`."

msgid "Abstract grammar"
msgstr "Abstrakt grammatik"

msgid "The abstract grammar is currently defined as follows:"
msgstr "Den abstrakta grammatiken definieras för närvarande på följande sätt:"

msgid ""
"-- ASDL's 4 builtin types are:\n"
"-- identifier, int, string, constant\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body, type_ignore* type_ignores)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       string? type_comment, type_param* type_params)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             string? type_comment, type_param* type_params)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list,\n"
"             type_param* type_params)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value, string? type_comment)\n"
"          | TypeAlias(expr name, type_param* type_params, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indicates that we annotate simple name without parens\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- use 'orelse' because else is a keyword in target languages\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse, string? "
"type_comment)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, "
"string? type_comment)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body, string? type_comment)\n"
"          | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
"\n"
"          | Match(expr subject, match_case* cases)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() can use left & right?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | NamedExpr(expr target, expr value)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr?* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- the grammar constrains where yield expressions can occur\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- need sequences for compare to distinguish between\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | FormattedValue(expr value, int conversion, expr? format_spec)\n"
"         | Interpolation(expr value, constant str, int conversion, expr? "
"format_spec)\n"
"         | JoinedStr(expr* values)\n"
"         | TemplateStr(expr* values)\n"
"         | Constant(constant value, string? kind)\n"
"\n"
"         -- the following expression can appear in assignment context\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, expr slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- can appear only in Subscript\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Load | Store | Del\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n"
"                    attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation, string? type_comment)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- keyword arguments supplied to call (NULL identifier for **kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"               attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- import name with optional 'as' alias.\n"
"    alias = (identifier name, identifier? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr value)\n"
"            | MatchSingleton(constant value)\n"
"            | MatchSequence(pattern* patterns)\n"
"            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
"            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, "
"pattern* kwd_patterns)\n"
"\n"
"            | MatchStar(identifier? name)\n"
"            -- The optional \"rest\" MatchMapping parameter handles "
"capturing extra mapping keys\n"
"\n"
"            | MatchAs(pattern? pattern, identifier? name)\n"
"            | MatchOr(pattern* patterns)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n"
"               | ParamSpec(identifier name, expr? default_value)\n"
"               | TypeVarTuple(identifier name, expr? default_value)\n"
"               attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"}\n"
msgstr ""
"-- ASDL's 4 builtin types are:\n"
"-- identifier, int, string, constant\n"
"\n"
"module Python\n"
"{\n"
"    mod = Module(stmt* body, type_ignore* type_ignores)\n"
"        | Interactive(stmt* body)\n"
"        | Expression(expr body)\n"
"        | FunctionType(expr* argtypes, expr returns)\n"
"\n"
"    stmt = FunctionDef(identifier name, arguments args,\n"
"                       stmt* body, expr* decorator_list, expr? returns,\n"
"                       string? type_comment, type_param* type_params)\n"
"          | AsyncFunctionDef(identifier name, arguments args,\n"
"                             stmt* body, expr* decorator_list, expr? "
"returns,\n"
"                             string? type_comment, type_param* type_params)\n"
"\n"
"          | ClassDef(identifier name,\n"
"             expr* bases,\n"
"             keyword* keywords,\n"
"             stmt* body,\n"
"             expr* decorator_list,\n"
"             type_param* type_params)\n"
"          | Return(expr? value)\n"
"\n"
"          | Delete(expr* targets)\n"
"          | Assign(expr* targets, expr value, string? type_comment)\n"
"          | TypeAlias(expr name, type_param* type_params, expr value)\n"
"          | AugAssign(expr target, operator op, expr value)\n"
"          -- 'simple' indicates that we annotate simple name without parens\n"
"          | AnnAssign(expr target, expr annotation, expr? value, int "
"simple)\n"
"\n"
"          -- use 'orelse' because else is a keyword in target languages\n"
"          | For(expr target, expr iter, stmt* body, stmt* orelse, string? "
"type_comment)\n"
"          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, "
"string? type_comment)\n"
"          | While(expr test, stmt* body, stmt* orelse)\n"
"          | If(expr test, stmt* body, stmt* orelse)\n"
"          | With(withitem* items, stmt* body, string? type_comment)\n"
"          | AsyncWith(withitem* items, stmt* body, string? type_comment)\n"
"\n"
"          | Match(expr subject, match_case* cases)\n"
"\n"
"          | Raise(expr? exc, expr? cause)\n"
"          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* "
"finalbody)\n"
"          | Assert(expr test, expr? msg)\n"
"\n"
"          | Import(alias* names)\n"
"          | ImportFrom(identifier? module, alias* names, int? level)\n"
"\n"
"          | Global(identifier* names)\n"
"          | Nonlocal(identifier* names)\n"
"          | Expr(expr value)\n"
"          | Pass | Break | Continue\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"          -- BoolOp() can use left & right?\n"
"    expr = BoolOp(boolop op, expr* values)\n"
"         | NamedExpr(expr target, expr value)\n"
"         | BinOp(expr left, operator op, expr right)\n"
"         | UnaryOp(unaryop op, expr operand)\n"
"         | Lambda(arguments args, expr body)\n"
"         | IfExp(expr test, expr body, expr orelse)\n"
"         | Dict(expr?* keys, expr* values)\n"
"         | Set(expr* elts)\n"
"         | ListComp(expr elt, comprehension* generators)\n"
"         | SetComp(expr elt, comprehension* generators)\n"
"         | DictComp(expr key, expr value, comprehension* generators)\n"
"         | GeneratorExp(expr elt, comprehension* generators)\n"
"         -- the grammar constrains where yield expressions can occur\n"
"         | Await(expr value)\n"
"         | Yield(expr? value)\n"
"         | YieldFrom(expr value)\n"
"         -- need sequences for compare to distinguish between\n"
"         -- x < 4 < 3 and (x < 4) < 3\n"
"         | Compare(expr left, cmpop* ops, expr* comparators)\n"
"         | Call(expr func, expr* args, keyword* keywords)\n"
"         | FormattedValue(expr value, int conversion, expr? format_spec)\n"
"         | Interpolation(expr value, constant str, int conversion, expr? "
"format_spec)\n"
"         | JoinedStr(expr* values)\n"
"         | TemplateStr(expr* values)\n"
"         | Constant(constant value, string? kind)\n"
"\n"
"         -- the following expression can appear in assignment context\n"
"         | Attribute(expr value, identifier attr, expr_context ctx)\n"
"         | Subscript(expr value, expr slice, expr_context ctx)\n"
"         | Starred(expr value, expr_context ctx)\n"
"         | Name(identifier id, expr_context ctx)\n"
"         | List(expr* elts, expr_context ctx)\n"
"         | Tuple(expr* elts, expr_context ctx)\n"
"\n"
"         -- can appear only in Subscript\n"
"         | Slice(expr? lower, expr? upper, expr? step)\n"
"\n"
"          -- col_offset is the byte offset in the utf8 string the parser "
"uses\n"
"          attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    expr_context = Load | Store | Del\n"
"\n"
"    boolop = And | Or\n"
"\n"
"    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift\n"
"                 | RShift | BitOr | BitXor | BitAnd | FloorDiv\n"
"\n"
"    unaryop = Invert | Not | UAdd | USub\n"
"\n"
"    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn\n"
"\n"
"    comprehension = (expr target, expr iter, expr* ifs, int is_async)\n"
"\n"
"    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)\n"
"                    attributes (int lineno, int col_offset, int? end_lineno, "
"int? end_col_offset)\n"
"\n"
"    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,\n"
"                 expr* kw_defaults, arg? kwarg, expr* defaults)\n"
"\n"
"    arg = (identifier arg, expr? annotation, string? type_comment)\n"
"           attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- keyword arguments supplied to call (NULL identifier for **kwargs)\n"
"    keyword = (identifier? arg, expr value)\n"
"               attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    -- import name with optional 'as' alias.\n"
"    alias = (identifier name, identifier? asname)\n"
"             attributes (int lineno, int col_offset, int? end_lineno, int? "
"end_col_offset)\n"
"\n"
"    withitem = (expr context_expr, expr? optional_vars)\n"
"\n"
"    match_case = (pattern pattern, expr? guard, stmt* body)\n"
"\n"
"    pattern = MatchValue(expr value)\n"
"            | MatchSingleton(constant value)\n"
"            | MatchSequence(pattern* patterns)\n"
"            | MatchMapping(expr* keys, pattern* patterns, identifier? rest)\n"
"            | MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, "
"pattern* kwd_patterns)\n"
"\n"
"            | MatchStar(identifier? name)\n"
"            -- The optional \"rest\" MatchMapping parameter handles "
"capturing extra mapping keys\n"
"\n"
"            | MatchAs(pattern? pattern, identifier? name)\n"
"            | MatchOr(pattern* patterns)\n"
"\n"
"             attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"\n"
"    type_ignore = TypeIgnore(int lineno, string tag)\n"
"\n"
"    type_param = TypeVar(identifier name, expr? bound, expr? default_value)\n"
"               | ParamSpec(identifier name, expr? default_value)\n"
"               | TypeVarTuple(identifier name, expr? default_value)\n"
"               attributes (int lineno, int col_offset, int end_lineno, int "
"end_col_offset)\n"
"}\n"

msgid "Node classes"
msgstr "Klasser för noder"

msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`!_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"Detta är basen för alla AST-nodklasser.  De faktiska nodklasserna härleds "
"från filen :file:`Parser/Python.asdl`, som reproduceras :ref:``above "
"<abstract-grammar>`.  De definieras i C-modulen :mod:`!_ast` och exporteras "
"på nytt i :mod:`ast`."

msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Det finns en klass definierad för varje symbol på vänstersidan i den "
"abstrakta grammatiken (t.ex. :class:`ast.stmt` eller :class:`ast.expr`).  "
"Dessutom finns det en klass definierad för varje konstruktör på högersidan; "
"dessa klasser ärver från klasserna för vänstersidans träd.  Till exempel "
"ärver :class:`ast.BinOp` från :class:`ast.expr`.  För produktionsregler med "
"alternativ (även kallade \"summor\") är klassen på vänster sida abstrakt: "
"endast instanser av specifika konstruktörsnoder skapas någonsin."

msgid ""
"Each concrete class has an attribute :attr:`!_fields` which gives the names "
"of all child nodes."
msgstr ""
"Varje konkret klass har ett attribut :attr:`!_fields` som anger namnen på "
"alla underordnade noder."

msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Varje instans av en konkret klass har ett attribut för varje underordnad "
"nod, av den typ som definieras i grammatiken.  Exempelvis har instanser av :"
"class:`ast.BinOp` ett attribut :attr:`left` av typen :class:`ast.expr`."

msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Om dessa attribut är markerade som valfria i grammatiken (med ett "
"frågetecken) kan värdet vara ``None``.  Om attributen kan ha noll eller fler "
"värden (markerade med en asterisk), representeras värdena som Python-"
"listor.  Alla möjliga attribut måste finnas och ha giltiga värden när man "
"kompilerar en AST med :func:`compile`."

msgid ""
"The :attr:`!_field_types` attribute on each concrete class is a dictionary "
"mapping field names (as also listed in :attr:`_fields`) to their types."
msgstr ""
"Attributet :attr:`!_field_types` på varje konkret klass är en ordbok som "
"mappar fältnamn (som också listas i :attr:`_fields`) till deras typer."

msgid ""
">>> ast.TypeVar._field_types\n"
"{'name': <class 'str'>, 'bound': ast.expr | None, 'default_value': ast.expr "
"| None}"
msgstr ""
">>> ast.TypeVar._field_types\n"
"{'namn': <class 'str'>, 'bound': ast.expr | None, 'default_value': ast.expr "
"| None}"

msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"Instanser av underklasserna :class:`ast.expr` och :class:`ast.stmt` har "
"attributen :attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno` och :attr:"
"`end_col_offset`.  Attributen :attr:`lineno` och :attr:`end_lineno` är det "
"första och sista radnumret i källtexten (1-indexerat så att den första raden "
"är rad 1) och attributen :attr:`col_offset` och :attr:`end_col_offset` är "
"motsvarande UTF-8-byteoffset för den första och sista tokens som genererade "
"noden. UTF-8-offset registreras eftersom parsern använder UTF-8 internt."

msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Observera att slutpositionerna inte krävs av kompilatorn och därför är "
"valfria. Slutoffsetet är *efter* den sista symbolen, till exempel kan man få "
"källsegmentet för en nod med enradigt uttryck med hjälp av "
"``source_line[node.col_offset : node.end_col_offset]``."

msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"Konstruktören för en klass :class:`ast.T` analyserar sina argument på "
"följande sätt:"

msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Om det finns positionella argument måste det finnas lika många som det finns "
"objekt i :attr:`T._fields`; de kommer att tilldelas som attribut till dessa "
"namn."

msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Om det finns nyckelordsargument kommer de att ställa in attributen med samma "
"namn till de angivna värdena."

msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Om du till exempel vill skapa och fylla i en :class:`ast.UnaryOp`-nod kan du "
"använda ::"

msgid ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"
msgstr ""
"node = ast.UnaryOp(ast.USub(), ast.Constant(5, lineno=0, col_offset=0),\n"
"                   lineno=0, col_offset=0)"

msgid ""
"If a field that is optional in the grammar is omitted from the constructor, "
"it defaults to ``None``. If a list field is omitted, it defaults to the "
"empty list. If a field of type :class:`!ast.expr_context` is omitted, it "
"defaults to :class:`Load() <ast.Load>`. If any other field is omitted, a :"
"exc:`DeprecationWarning` is raised and the AST node will not have this "
"field. In Python 3.15, this condition will raise an error."
msgstr ""
"Om ett fält som är valfritt i grammatiken utelämnas från konstruktorn, blir "
"standardvärdet ``None``. Om ett listfält utelämnas är standardvärdet den "
"tomma listan. Om ett fält av typen :class:`!ast.expr_context` utelämnas, "
"blir standardvärdet :class:`Load() <ast.Load>`. Om något annat fält "
"utelämnas, kommer en :exc:`DeprecationWarning` att visas och AST-noden "
"kommer inte att ha detta fält. I Python 3.15 kommer detta villkor att ge "
"upphov till ett fel."

msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "Klassen :class:`ast.Constant` används nu för alla konstanter."

msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Enkla index representeras av sitt värde, extended slices representeras som "
"tupler."

msgid ""
"The :meth:`~object.__repr__` output of :class:`~ast.AST` nodes includes the "
"values of the node fields."
msgstr ""
"Utmatningen :meth:`~object.__repr__` av :class:`~ast.AST`-noder innehåller "
"värdena för nodfälten."

msgid ""
"Old classes :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` and :class:`!ast.Ellipsis` are still available, "
"but they will be removed in future Python releases.  In the meantime, "
"instantiating them will return an instance of a different class."
msgstr ""
"Gamla klasser :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` och :class:`!ast.Ellipsis` är fortfarande "
"tillgängliga, men de kommer att tas bort i framtida Python-versioner.  Under "
"tiden kommer instansiering av dem att returnera en instans av en annan klass."

msgid ""
"Old classes :class:`!ast.Index` and :class:`!ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"Gamla klasser :class:`!ast.Index` och :class:`!ast.ExtSlice` är fortfarande "
"tillgängliga, men de kommer att tas bort i framtida Python-versioner. Under "
"tiden kommer instansiering av dem att returnera en instans av en annan klass."

msgid ""
"Previous versions of Python allowed the creation of AST nodes that were "
"missing required fields. Similarly, AST node constructors allowed arbitrary "
"keyword arguments that were set as attributes of the AST node, even if they "
"did not match any of the fields of the AST node. This behavior is deprecated "
"and will be removed in Python 3.15."
msgstr ""
"Tidigare versioner av Python tillät skapandet av AST-noder som saknade "
"obligatoriska fält. På samma sätt tillät AST-nodkonstruktörer godtyckliga "
"nyckelordsargument som sattes som attribut för AST-noden, även om de inte "
"matchade något av fälten i AST-noden. Detta beteende är föråldrat och kommer "
"att tas bort i Python 3.15."

msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"Beskrivningarna av de specifika nodklasserna som visas här anpassades "
"ursprungligen från det fantastiska projektet `Green Tree Snakes <https://"
"greentreesnakes.readthedocs.io/en/latest/>`__ och alla dess bidragsgivare."

msgid "Root nodes"
msgstr "Rotnoder"

msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type generated "
"by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""
"En Python-modul, som med :ref:`file input <file-input>`. Nodtyp genererad "
"av :func:`ast.parse` i standard ``\"exec\"`` *mode*."

msgid "``body`` is a :class:`list` of the module's :ref:`ast-statements`."
msgstr "``body`` är en :class:`lista` av modulens :ref:`ast-statements`."

msgid ""
"``type_ignores`` is a :class:`list` of the module's type ignore comments; "
"see :func:`ast.parse` for more details."
msgstr ""
"``type_ignores`` är en :class:`lista` över modulens kommentarer för "
"ignorerade typer; se :func:`ast.parse` för mer information."

msgid ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1'), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Store())],\n"
"            värde=Konstant(värde=1))])"

msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""
"En enda Python :ref:`uttrycksinmatning <expression-input>`. Nodtyp som "
"genereras av :func:`ast.parse` när *mode* är ``\"eval\"``."

msgid ""
"``body`` is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""
"``body`` är en enskild nod, en av :ref:`uttryckstyperna <ast-expressions>`."

msgid ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Constant(value=123))"
msgstr ""
">>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Konstant(värde=123))"

msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-interac`. "
"Node type generated by :func:`ast.parse` when *mode* is ``\"single\"``."
msgstr ""
"En enda :ref:`interaktiv inmatning <interactive>`, som i :ref:`tut-interac`. "
"Nodtyp som genereras av :func:`ast.parse` när *mode* är ``\"single\"``."

msgid "``body`` is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""
"``body`` är en :class:`list` av :ref:``statement nodes <ast-statements>`."

msgid ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interactive(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1)),\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='y', ctx=Store())],\n"
"            value=Constant(value=2))])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))\n"
"Interaktiv(\n"
"    kropp=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Store())],\n"
"            värde=Konstant(värde=1)),\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='y', ctx=Store())],\n"
"            värde=Konstant(värde=2))])"

msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""
"En representation av en gammal typkommentar för funktioner, eftersom Python-"
"versioner före 3.5 inte hade stöd för :pep:`484`-annoteringar. Nodtyp som "
"genereras av :func:`ast.parse` när *mode* är ``\"func_type\"``."

msgid "Such type comments would look like this::"
msgstr "En sådan typ av kommentarer skulle se ut så här::"

msgid ""
"def sum_two_number(a, b):\n"
"    # type: (int, int) -> int\n"
"    return a + b"
msgstr ""
"def sum_two_number(a, b):\n"
"    # typ: (int, int) -> int\n"
"    returnerar a + b"

msgid ""
"``argtypes`` is a :class:`list` of :ref:`expression nodes <ast-expressions>`."
msgstr ""
"``argtypes`` är en :class:`list` av :ref:`uttrycksnoder <ast-expressions>`."

msgid "``returns`` is a single :ref:`expression node <ast-expressions>`."
msgstr "``returns`` är en enda :ref:`uttrycksnod <ast-expressions>`."

msgid ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"FunctionType(\n"
"    argtypes=[\n"
"        Name(id='int', ctx=Load()),\n"
"        Name(id='str', ctx=Load())],\n"
"    returns=Subscript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), "
"indent=4))\n"
"Funktionstyp(\n"
"    argtypes=[\n"
"        Namn(id='int', ctx=Load()),\n"
"        Namn(id='str', ctx=Load())],\n"
"    returns=Subskript(\n"
"        value=Name(id='List', ctx=Load()),\n"
"        slice=Name(id='int', ctx=Load()),\n"
"        ctx=Load()))"

msgid "Literals"
msgstr "Bokstäver"

msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"instances of :class:`str`, :class:`bytes`, :class:`int`, :class:`float`, :"
"class:`complex`, and :class:`bool`, and the constants :data:`None` and :data:"
"`Ellipsis`."
msgstr ""
"Ett konstant värde. Attributet ``value`` för ``Constant`` literalen "
"innehåller det Python-objekt som den representerar. De värden som "
"representeras kan vara instanser av :class:`str`, :class:`bytes`, :class:"
"`int`, :class:`float`, :class:`complex` och :class:`bool`, samt "
"konstanterna :data:`None` och :data:`Ellipsis`."

msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Nod som representerar ett enda formateringsfält i en f-sträng. Om strängen "
"innehåller ett enda formateringsfält och inget annat kan noden isoleras, "
"annars visas den i :class:`JoinedStr`."

msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``värde`` är vilken uttrycksnod som helst (t.ex. en bokstav, en variabel "
"eller ett funktionsanrop)."

msgid "``conversion`` is an integer:"
msgstr "``konvertering`` är ett heltal:"

msgid "-1: no formatting"
msgstr "-1: ingen formatering"

msgid "115 (``ord('s')``): ``!s`` string formatting"
msgstr "115 (``ord('s')``): ``!s`` strängformatering"

msgid "114 (``ord('r')``): ``!r`` repr formatting"
msgstr "114 (``ord('r')``): ``!r`` repr formatering"

msgid "97 (``ord('a')``): ``!a`` ASCII formatting"
msgstr "97 (``ord('a')``): ``!a`` ASCII-formatering"

msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` är en :class:`JoinedStr`-nod som representerar formateringen "
"av värdet, eller ``None`` om inget format har angetts. Både ``conversion`` "
"och ``format_spec`` kan anges samtidigt."

msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"En f-sträng som består av en serie :class:`FormattedValue`- och :class:"
"`Constant`-noder."

msgid ""
">>> print(ast.dump(ast.parse('f\"sin({a}) is {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=JoinedStr(\n"
"        values=[\n"
"            Constant(value='sin('),\n"
"            FormattedValue(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                conversion=-1),\n"
"            Constant(value=') is '),\n"
"            FormattedValue(\n"
"                value=Call(\n"
"                    func=Name(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Name(id='a', ctx=Load())]),\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='.3')]))]))"
msgstr ""
">>> print(ast.dump(ast.parse('f\"sin({a}) är {sin(a):.3}\"', mode='eval'), "
"indent=4))\n"
"Uttryck(\n"
"    kropp=JoinedStr(\n"
"        värden=[\n"
"            Constant(värde='sin('),\n"
"            FormateratVärde(\n"
"                värde=Namn(id='a', ctx=Load()),\n"
"                konvertering=-1),\n"
"            Constant(värde=') är '),\n"
"            FormateratVärde(\n"
"                värde=Anrop(\n"
"                    func=Namn(id='sin', ctx=Load()),\n"
"                    args=[\n"
"                        Namn(id='a', ctx=Load())]),\n"
"                konvertering=-1,\n"
"                format_spec=JoinedStr(\n"
"                    värden=[\n"
"                        Constant(värde='.3')]))]))"

msgid ""
"A t-string, comprising a series of :class:`Interpolation` and :class:"
"`Constant` nodes."
msgstr ""
"En t-sträng som består av en serie :class:`Interpolation`- och :class:"
"`Constant`-noder."

msgid ""
">>> print(ast.dump(ast.parse('t\"{name} finished {place:ordinal}\"', "
"mode='eval'), indent=4))\n"
"Expression(\n"
"    body=TemplateStr(\n"
"        values=[\n"
"            Interpolation(\n"
"                value=Name(id='name', ctx=Load()),\n"
"                str='name',\n"
"                conversion=-1),\n"
"            Constant(value=' finished '),\n"
"            Interpolation(\n"
"                value=Name(id='place', ctx=Load()),\n"
"                str='place',\n"
"                conversion=-1,\n"
"                format_spec=JoinedStr(\n"
"                    values=[\n"
"                        Constant(value='ordinal')]))]))"
msgstr ""
">>> print(ast.dump(ast.parse('t\"{name} färdig {place:ordinal}\"', "
"mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=MallStr(\n"
"        värden=[\n"
"            Interpolering(\n"
"                värde=Namn(id='namn', ctx=Load()),\n"
"                str='namn',\n"
"                konvertering=-1),\n"
"            Konstant(värde=' färdig '),\n"
"            Interpolation(\n"
"                värde=Namn(id='plats', ctx=Load()),\n"
"                str='plats',\n"
"                konvertering=-1,\n"
"                format_spec=JoinedStr(\n"
"                    värden=[\n"
"                        Constant(value='ordinal')]))]))"

msgid "Node representing a single interpolation field in a t-string."
msgstr "Nod som representerar ett enda interpoleringsfält i en t-sträng."

msgid ""
"``str`` is a constant containing the text of the interpolation expression."
msgstr ""
"``str`` är en konstant som innehåller texten i interpoleringsuttrycket."

msgid "-1: no conversion"
msgstr "-1: ingen konvertering"

msgid "115: ``!s`` string conversion"
msgstr "115: ``!s`` strängomvandling"

msgid "114: ``!r`` repr conversion"
msgstr "114: ``!r`` repr konvertering"

msgid "97: ``!a`` ascii conversion"
msgstr "97: ``!a`` ascii-konvertering"

msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"En lista eller tupel. ``elts`` innehåller en lista med noder som "
"representerar elementen. ``ctx`` är :class:`Store`` om behållaren är ett mål "
"för en tilldelning (dvs. ``(x,y)=något``), och :class:`Load`` annars."

msgid ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=List(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Tuple(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)],\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('[1, 2, 3]', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    kropp=Lista(\n"
"        elts=[\n"
"            Konstant(värde=1),\n"
"            Konstant(värde=2),\n"
"            Konstant(värde=3)],\n"
"        ctx=Load()))\n"
">>> print(ast.dump(ast.parse('(1, 2, 3)', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Tupel(\n"
"        elts=[\n"
"            Konstant(värde=1),\n"
"            Konstant(värde=2),\n"
"            Konstant(värde=3)],\n"
"        ctx=Load()))"

msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"En uppsättning. ``elts`` innehåller en lista med noder som representerar "
"setets element."

msgid ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Set(\n"
"        elts=[\n"
"            Constant(value=1),\n"
"            Constant(value=2),\n"
"            Constant(value=3)]))"
msgstr ""
">>> print(ast.dump(ast.parse('{1, 2, 3}', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    kropp=Set(\n"
"        elts=[\n"
"            Konstant(värde=1),\n"
"            Konstant(värde=2),\n"
"            Konstant(värde=3)]))"

msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"En ordbok. ``keys`` och ``values`` innehåller listor med noder som "
"representerar nycklarna respektive värdena, i matchande ordning (vad som "
"skulle returneras vid anrop av :code:`dictionary.keys()` och :code:"
"`dictionary.values()`)."

msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Vid uppackning av ordböcker med hjälp av ordbokslitteraler hamnar det "
"uttryck som ska expanderas i listan ``values``, med en ``None`` på "
"motsvarande position i ``keys``."

msgid ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Dict(\n"
"        keys=[\n"
"            Constant(value='a'),\n"
"            None],\n"
"        values=[\n"
"            Constant(value=1),\n"
"            Name(id='d', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('{\"a\":1, **d}', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Dict(\n"
"        nycklar=[\n"
"            Konstant(värde='a'),\n"
"            Ingen],\n"
"        values=[\n"
"            Konstant(värde=1),\n"
"            Namn(id='d', ctx=Load())]))"

msgid "Variables"
msgstr "Variabler"

msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Ett variabelnamn. ``id`` innehåller namnet som en sträng, och ``ctx`` är en "
"av följande typer."

msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"Variabelreferenser kan användas för att ladda en variabels värde, tilldela "
"den ett nytt värde eller ta bort den. Variabelreferenser ges ett sammanhang "
"för att skilja dessa fall åt."

msgid ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Name(id='a', ctx=Load()))])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='a', ctx=Del())])])"
msgstr ""
">>> print(ast.dump(ast.parse('a'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=Namn(id='a', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('a = 1'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='a', ctx=Store())],\n"
"            värde=Konstant(värde=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('del a'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Radera(\n"
"            mål=[\n"
"                Namn(id='a', ctx=Del())])])])"

msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"En ``*var`` variabelreferens. ``value`` innehåller variabeln, vanligtvis en :"
"class:`Name`-nod. Denna typ måste användas när man bygger en :class:`Call`-"
"nod med ``*args``."

msgid ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Starred(\n"
"                            value=Name(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('a, *b = it'), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Tupel(\n"
"                    elts=[\n"
"                        Namn(id='a', ctx=Store()),\n"
"                        Stjärnmärkt(\n"
"                            värde=Namn(id='b', ctx=Store()),\n"
"                            ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='it', ctx=Load())))])"

msgid "Expressions"
msgstr "Uttryck"

msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"När ett uttryck, t.ex. ett funktionsanrop, visas som en egen sats utan att "
"dess returvärde används eller lagras, omsluts det av denna container. "
"``value`` innehåller en av de andra noderna i detta avsnitt, en :class:"
"`Constant`, en :class:`Name`, en :class:`Lambda`, en :class:`Yield` eller :"
"class:`YieldFrom` nod."

msgid ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Name(id='a', ctx=Load())))])"
msgstr ""
">>> print(ast.dump(ast.parse('-a'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=UnaryOp(\n"
"                op=USub(),\n"
"                operand=Namn(id='a', ctx=Load())))]))"

msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr "En unär operation. ``op`` är operatorn och ``operand`` en uttrycksnod."

msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Unära operatortokens. :class:`Not` är nyckelordet ``not``, :class:`Invert` "
"är operatorn ``~``."

msgid ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=UnaryOp(\n"
"        op=Not(),\n"
"        operand=Name(id='x', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('not x', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=UnaryOp(\n"
"        op=Inte(),\n"
"        operand=Namn(id='x', ctx=Load())))"

msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"En binär operation (som addition eller division). ``op`` är operatorn, och "
"``left`` och ``right`` är valfria uttrycksnoder."

msgid ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BinOp(\n"
"        left=Name(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('x + y', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=BinOp(\n"
"        left=Namn(id='x', ctx=Load()),\n"
"        op=Add(),\n"
"        right=Name(id='y', ctx=Load())))"

msgid "Binary operator tokens."
msgstr "Tokens för binära operatorer."

msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"En boolesk operation, \"eller\" eller \"och\". ``op`` är :class:`Or` eller :"
"class:`And`. ``values`` är de involverade värdena. På varandra följande "
"operationer med samma operator, t.ex. ``a eller b eller c``, slås samman "
"till en nod med flera värden."

msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Detta inkluderar inte ``not``, som är en :class:`UnaryOp`."

msgid ""
">>> print(ast.dump(ast.parse('x or y', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        values=[\n"
"            Name(id='x', ctx=Load()),\n"
"            Name(id='y', ctx=Load())]))"
msgstr ""
">>> print(ast.dump(ast.parse('x eller y', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=BoolOp(\n"
"        op=Or(),\n"
"        värden=[\n"
"            Namn(id='x', ctx=Load()),\n"
"            Namn(id='y', ctx=Load())]))"

msgid "Boolean operator tokens."
msgstr "Tokens för booleska operatorer."

msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"En jämförelse av två eller flera värden. ``left`` är det första värdet i "
"jämförelsen, ``ops`` listan med operatorer och ``comparators`` listan med "
"värden efter det första elementet i jämförelsen."

msgid ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Compare(\n"
"        left=Constant(value=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Constant(value=10)]))"
msgstr ""
">>> print(ast.dump(ast.parse('1 <= a < 10', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Jämför(\n"
"        vänster=Konstant(värde=1),\n"
"        ops=[\n"
"            LtE(),\n"
"            Lt()],\n"
"        comparators=[\n"
"            Namn(id='a', ctx=Load()),\n"
"            Konstant(värde=10)]))"

msgid "Comparison operator tokens."
msgstr "Tokens för jämförelseoperator."

msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Ett anrop av en funktion. ``func`` är funktionen, som ofta kommer att vara "
"ett :class:`Name` eller :class:`Attribute` objekt. Av argumenten:"

msgid "``args`` holds a list of the arguments passed by position."
msgstr ""
"``args`` innehåller en lista över de argument som skickas med position."

msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr ""
"``keywords`` innehåller en lista med :class:`.keyword`-objekt som "
"representerar argument som skickas med keyword."

msgid ""
"The ``args`` and ``keywords`` arguments are optional and default to empty "
"lists."
msgstr ""
"Argumenten ``args`` och ``keywords`` är valfria och är som standard tomma "
"listor."

msgid ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Expression(\n"
"    body=Call(\n"
"        func=Name(id='func', ctx=Load()),\n"
"        args=[\n"
"            Name(id='a', ctx=Load()),\n"
"            Starred(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        keywords=[\n"
"            keyword(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            keyword(\n"
"                value=Name(id='e', ctx=Load()))]))"
msgstr ""
">>> print(ast.dump(ast.parse('func(a, b=c, *d, **e)', mode='eval'), "
"indent=4))\n"
"Uttryck(\n"
"    body=Anrop(\n"
"        func=Namn(id='func', ctx=Load()),\n"
"        args=[\n"
"            Namn(id='a', ctx=Load()),\n"
"            Stjärnmärkt(\n"
"                value=Name(id='d', ctx=Load()),\n"
"                ctx=Load())],\n"
"        nyckelord=[\n"
"            nyckelord(\n"
"                arg='b',\n"
"                value=Name(id='c', ctx=Load())),\n"
"            nyckelord(\n"
"                value=Name(id='e', ctx=Load())))]))"

msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Ett nyckelordsargument till ett funktionsanrop eller en klassdefinition. "
"``arg`` är en rå sträng med parameternamnet, ``value`` är en nod att skicka "
"in."

msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Ett uttryck som ``a if b else c``. Varje fält innehåller en enda nod, så i "
"följande exempel är alla tre :class:`Name`-noder."

msgid ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=IfExp(\n"
"        test=Name(id='b', ctx=Load()),\n"
"        body=Name(id='a', ctx=Load()),\n"
"        orelse=Name(id='c', ctx=Load())))"
msgstr ""
">>> print(ast.dump(ast.parse('a if b else c', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=IfExp(\n"
"        test=Namn(id='b', ctx=Load()),\n"
"        body=Namn(id='a', ctx=Load()),\n"
"        orelse=Namn(id='c', ctx=Load())))"

msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Attributåtkomst, t.ex. ``d.keys``. ``value`` är en nod, vanligtvis en :class:"
"`Name`. ``attr`` är en naken sträng som anger namnet på attributet, och "
"``ctx`` är :class:`Load`, :class:`Store` eller :class:`Del` beroende på hur "
"attributet används."

msgid ""
">>> print(ast.dump(ast.parse('snake.colour', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Attribute(\n"
"        value=Name(id='snake', ctx=Load()),\n"
"        attr='colour',\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('snake.color', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Attribut(\n"
"        value=Namn(id='snake', ctx=Load()),\n"
"        attr='färg',\n"
"        ctx=Load()))"

msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Ett namngivet uttryck. Denna AST-nod produceras av operatorn för assignment-"
"uttryck (även känd som valrossoperatorn). I motsats till :class:`Assign`-"
"noden där det första argumentet kan vara flera noder, måste i detta fall "
"både ``target`` och ``value`` vara enstaka noder."

msgid ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=NamedExpr(\n"
"        target=Name(id='x', ctx=Store()),\n"
"        value=Constant(value=4)))"
msgstr ""
">>> print(ast.dump(ast.parse('(x := 4)', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=NamnExpr(\n"
"        target=Namn(id='x', ctx=Store()),\n"
"        värde=Konstant(värde=4)))"

msgid "Subscripting"
msgstr "Subskription"

msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Ett index, t.ex. ``l[1]``. ``value`` är det subskriberade objektet "
"(vanligtvis sekvens eller mappning). ``lice`` är ett index, en skiva eller "
"en nyckel. Det kan vara en :class:`Tuple` och innehålla en :class:`Slice`. "
"``ctx`` är :class:`Load`, :class:`Store` eller :class:`Del` beroende på "
"vilken åtgärd som utförs med subskriptionen."

msgid ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Tuple(\n"
"            elts=[\n"
"                Slice(\n"
"                    lower=Constant(value=1),\n"
"                    upper=Constant(value=2)),\n"
"                Constant(value=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2, 3]', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Subskript(\n"
"        value=Namn(id='l', ctx=Load()),\n"
"        slice=Tupel(\n"
"            elts=[\n"
"                Slice(\n"
"                    lägre=Konstant(värde=1),\n"
"                    övre=Konstant(värde=2)),\n"
"                Konstant(värde=3)],\n"
"            ctx=Load()),\n"
"        ctx=Load()))"

msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Vanlig skärning (på formen ``lower:upper`` eller ``lower:upper:step``). Kan "
"endast förekomma i fältet *slice* i :class:`Subscript`, antingen direkt "
"eller som ett element i :class:`Tuple`."

msgid ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Expression(\n"
"    body=Subscript(\n"
"        value=Name(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Constant(value=1),\n"
"            upper=Constant(value=2)),\n"
"        ctx=Load()))"
msgstr ""
">>> print(ast.dump(ast.parse('l[1:2]', mode='eval'), indent=4))\n"
"Uttryck(\n"
"    body=Subskript(\n"
"        value=Namn(id='l', ctx=Load()),\n"
"        slice=Slice(\n"
"            lower=Konstant(värde=1),\n"
"            övre=Konstant(värde=2)),\n"
"        ctx=Load()))"

msgid "Comprehensions"
msgstr "Förståelse"

msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"List- och set-förståelser, generatoruttryck och ordboksförståelser. ``elt`` "
"(eller ``key`` och ``value``) är en enda nod som representerar den del som "
"kommer att utvärderas för varje objekt."

msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` är en lista av :class:`comprehension` noder."

msgid ""
">>> print(ast.dump(\n"
"...     ast.parse('[x for x in numbers]', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x: x**2 for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=DictComp(\n"
"        key=Name(id='x', ctx=Load()),\n"
"        value=BinOp(\n"
"            left=Name(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"...     ast.parse('{x for x in numbers}', mode='eval'),\n"
"...     indent=4,\n"
"... ))\n"
"Expression(\n"
"    body=SetComp(\n"
"        elt=Name(id='x', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))"
msgstr ""
">>> print(ast.dump(\n"
"... ast.parse('[x för x i tal]', mode='eval'),\n"
"... indrag=4,\n"
"... ))\n"
"Uttryck(\n"
"    body=ListComp(\n"
"        elt=Namn(id='x', ctx=Load()),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"... ast.parse('{x: x**2 for x in numbers}', mode='eval'),\n"
"... indrag=4,\n"
"... ))\n"
"Uttryck(\n"
"    body=DictComp(\n"
"        nyckel=Namn(id='x', ctx=Load()),\n"
"        värde=BinOp(\n"
"            left=Namn(id='x', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Konstant(värde=2)),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))\n"
">>> print(ast.dump(\n"
"... ast.parse('{x för x i tal}', mode='eval'),\n"
"... indrag=4,\n"
"... ))\n"
"Uttryck(\n"
"    body=SetComp(\n"
"        elt=Namn(id='x', ctx=Load()),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='x', ctx=Store()),\n"
"                iter=Name(id='numbers', ctx=Load()),\n"
"                is_async=0)]))"

msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"En ``for``-sats i en förståelse. ``target`` är referensen som ska användas "
"för varje element - typiskt en :class:`Name` eller :class:`Tuple` nod. "
"``iter`` är det objekt som ska itereras över. ``ifs`` är en lista med "
"testuttryck: varje ``for``-klausul kan ha flera ``ifs``."

msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` indikerar att en förståelse är asynkron (använder en ``async "
"for`` istället för ``for``). Värdet är ett heltal (0 eller 1)."

msgid ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"...                indent=4)) # Multiple comprehensions in one.\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Call(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())]),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                is_async=0),\n"
"            comprehension(\n"
"                target=Name(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"...                indent=4)) # generator comprehension\n"
"Expression(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Name(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Constant(value=2)),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='n', ctx=Store()),\n"
"                iter=Name(id='it', ctx=Load()),\n"
"                ifs=[\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    Compare(\n"
"                        left=Name(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(value=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"...                indent=4)) # Async comprehension\n"
"Expression(\n"
"    body=ListComp(\n"
"        elt=Name(id='i', ctx=Load()),\n"
"        generators=[\n"
"            comprehension(\n"
"                target=Name(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                is_async=1)]))"
msgstr ""
">>> print(ast.dump(ast.parse('[ord(c) for line in file for c in line]', "
"mode='eval'),\n"
"... indent=4)) # Flera förståelser i en.\n"
"Uttryck(\n"
"    kropp=ListComp(\n"
"        elt=Anrop(\n"
"            func=Name(id='ord', ctx=Load()),\n"
"            args=[\n"
"                Name(id='c', ctx=Load())]),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='line', ctx=Store()),\n"
"                iter=Name(id='file', ctx=Load()),\n"
"                is_async=0),\n"
"            förståelse(\n"
"                target=Namn(id='c', ctx=Store()),\n"
"                iter=Name(id='line', ctx=Load()),\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('(n**2 for n in it if n>5 if n<10)', "
"mode='eval'),\n"
"... indent=4)) # generatorförståelse\n"
"Uttryck(\n"
"    body=GeneratorExp(\n"
"        elt=BinOp(\n"
"            left=Namn(id='n', ctx=Load()),\n"
"            op=Pow(),\n"
"            right=Konstant(värde=2)),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='n', ctx=Store()),\n"
"                iter=Namn(id='det', ctx=Load()),\n"
"                ifs=[\n"
"                    Jämför(\n"
"                        left=Namn(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Konstant(värde=5)]),\n"
"                    Jämför(\n"
"                        left=Namn(id='n', ctx=Load()),\n"
"                        ops=[\n"
"                            Lt()],\n"
"                        comparators=[\n"
"                            Constant(värde=10)])],\n"
"                is_async=0)]))\n"
"\n"
">>> print(ast.dump(ast.parse('[i async for i in soc]', mode='eval'),\n"
"... indent=4)) # Asynkron förståelse\n"
"Uttryck(\n"
"    body=ListComp(\n"
"        elt=Namn(id='i', ctx=Load()),\n"
"        generatorer=[\n"
"            förståelse(\n"
"                target=Namn(id='i', ctx=Store()),\n"
"                iter=Name(id='soc', ctx=Load()),\n"
"                is_async=1)]))"

msgid "Statements"
msgstr "Specifikation"

msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"En tilldelning. ``targets`` är en lista med noder och ``value`` är en "
"enskild nod."

msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"Flera noder i ``targets`` representerar att tilldela samma värde till alla. "
"Uppackning representeras genom att sätta en :class:`Tuple` eller :class:"
"`List` inom ``targets``."

msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` är en valfri sträng med typannoteringen som en kommentar."

msgid ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multiple assignment\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='a', ctx=Store()),\n"
"                Name(id='b', ctx=Store())],\n"
"            value=Constant(value=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Unpacking\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Name(id='a', ctx=Store()),\n"
"                        Name(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('a = b = 1'), indent=4)) # Multipel "
"tilldelning\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='a', ctx=Store()),\n"
"                Namn(id='b', ctx=Store())],\n"
"            värde=Konstant(värde=1))])\n"
"\n"
">>> print(ast.dump(ast.parse('a,b = c'), indent=4)) # Uppackning\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Tuple(\n"
"                    elts=[\n"
"                        Namn(id='a', ctx=Store()),\n"
"                        Namn(id='b', ctx=Store())],\n"
"                    ctx=Store())],\n"
"            value=Name(id='c', ctx=Load()))])"

msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, an :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node."
msgstr ""
"Ett uppdrag med en typannotering. ``target`` är en enskild nod och kan vara "
"en :class:`Name`, en :class:`Attribute` eller en :class:`Subscript`. "
"``annotation`` är annoteringen, t.ex. en nod av typen :class:`Constant` "
"eller :class:`Name`. ``value`` är en enskild valfri nod."

msgid ""
"``simple`` is always either 0 (indicating a \"complex\" target) or 1 "
"(indicating a \"simple\" target). A \"simple\" target consists solely of a :"
"class:`Name` node that does not appear between parentheses; all other "
"targets are considered complex. Only simple targets appear in the :attr:"
"`~object.__annotations__` dictionary of modules and classes."
msgstr ""
"``simple`` är alltid antingen 0 (indikerar ett \"komplext\" mål) eller 1 "
"(indikerar ett \"enkelt\" mål). Ett \"enkelt\" mål består enbart av en :"
"class:`Name`-nod som inte förekommer inom parentes; alla andra mål betraktas "
"som komplexa. Endast enkla mål visas i :attr:`~object.__annotations__`-"
"ordlistan över moduler och klasser."

msgid ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation with "
"parenthesis\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attribute annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Attribute(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript "
"annotation\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Subscript(\n"
"                value=Name(id='a', ctx=Load()),\n"
"                slice=Constant(value=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])"
msgstr ""
">>> print(ast.dump(ast.parse('c: int'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Namn(id='c', ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=1)])\n"
"\n"
">>> print(ast.dump(ast.parse('(a): int = 1'), indent=4)) # Annotation med "
"parentes\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Namn(id='a', ctx=Store()),\n"
"            annotation=Namn(id='int', ctx=Load()),\n"
"            värde=Konstant(värde=1),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a.b: int'), indent=4)) # Attributanteckning\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            mål=Attribut(\n"
"                value=Namn(id='a', ctx=Load()),\n"
"                attr='b',\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])\n"
"\n"
">>> print(ast.dump(ast.parse('a[1]: int'), indent=4)) # Subscript-"
"annotering\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            mål=Subscript(\n"
"                value=Namn(id='a', ctx=Load()),\n"
"                slice=Konstant(värde=1),\n"
"                ctx=Store()),\n"
"            annotation=Name(id='int', ctx=Load()),\n"
"            simple=0)])"

msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Förstärkt tilldelning, t.ex. ``a += 1``. I följande exempel är ``target`` "
"en :class:`Name`-nod för ``x`` (med :class:`Store`-kontexten), ``op`` är :"
"class:`Add`, och ``value`` är en :class:`Constant` med värdet 1."

msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"Attributet ``target`` kan inte vara av klass :class:`Tuple` eller :class:"
"`List`, till skillnad från målen i :class:`Assign`."

msgid ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            value=Constant(value=2))])"
msgstr ""
">>> print(ast.dump(ast.parse('x += 2'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        AugAssign(\n"
"            target=Namn(id='x', ctx=Store()),\n"
"            op=Add(),\n"
"            värde=Konstant(värde=2))])"

msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"En ``raise``-sats. ``exc`` är undantagsobjektet som ska tas upp, normalt en :"
"class:`Call` eller :class:`Name`, eller ``None`` för en fristående "
"``raise``. ``cause`` är den valfria delen för ``y`` i ``raise x from y``."

msgid ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Raise(\n"
"            exc=Name(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('raise x from y'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Höjning(\n"
"            exc=Namn(id='x', ctx=Load()),\n"
"            cause=Name(id='y', ctx=Load())))])"

msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Ett påstående. ``test`` innehåller villkoret, t.ex. en :class:`Compare`-nod. "
"``msg`` innehåller felmeddelandet."

msgid ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assert(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            msg=Name(id='y', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('assert x,y'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Assert(\n"
"            test=Namn(id='x', ctx=Load()),\n"
"            msg=Namn(id='y', ctx=Load())))])"

msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Representerar en ``del``-sats. ``targets`` är en lista med noder, t.ex. "
"noderna :class:`Name`, :class:`Attribute` eller :class:`Subscript`."

msgid ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Delete(\n"
"            targets=[\n"
"                Name(id='x', ctx=Del()),\n"
"                Name(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del())])])"
msgstr ""
">>> print(ast.dump(ast.parse('del x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Radera(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Del()),\n"
"                Namn(id='y', ctx=Del()),\n"
"                Name(id='z', ctx=Del()))])])"

msgid "A ``pass`` statement."
msgstr "Ett \"godkänt\" uttalande."

msgid ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Pass()])"
msgstr ""
">>> print(ast.dump(ast.parse('pass'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Pass()])"

msgid ""
"A :ref:`type alias <type-aliases>` created through the :keyword:`type` "
"statement. ``name`` is the name of the alias, ``type_params`` is a list of :"
"ref:`type parameters <ast-type-params>`, and ``value`` is the value of the "
"type alias."
msgstr ""
"Ett :ref:`type-alias <type-aliases>` som skapas genom :keyword:`type`-"
"satsen. ``name`` är namnet på aliaset, ``type_params`` är en lista med :ref:"
"`type-parametrar <ast-type-params>`, och ``value`` är värdet på typaliaset."

msgid ""
">>> print(ast.dump(ast.parse('type Alias = int'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            value=Name(id='int', ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse('typ Alias = int'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            value=Name(id='int', ctx=Load())))])"

msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Andra uttalanden som endast är tillämpliga inom funktioner eller loopar "
"beskrivs i andra avsnitt."

msgid "Imports"
msgstr "Importer"

msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "En importförklaring. ``names`` är en lista med :class:`alias`-noder."

msgid ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Import(\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])])"
msgstr ""
">>> print(ast.dump(ast.parse('import x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Import(\n"
"            namn=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')])])"

msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Representerar ``from x import y``. ``module`` är en rå sträng av 'from'-"
"namnet, utan några inledande punkter, eller ``None`` för uttalanden som "
"``from . import foo``. ``level`` är ett heltal som anger nivån på den "
"relativa importen (0 betyder absolut import)."

msgid ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='y',\n"
"            names=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            level=0)])"
msgstr ""
">>> print(ast.dump(ast.parse('from y import x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        ImportFrom(\n"
"            modul='y',\n"
"            namn=[\n"
"                alias(name='x'),\n"
"                alias(name='y'),\n"
"                alias(name='z')],\n"
"            nivå=0)])"

msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Båda parametrarna är råa strängar av namnen. ``asname`` kan vara ``None`` om "
"det vanliga namnet ska användas."

msgid ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ImportFrom(\n"
"            module='foo.bar',\n"
"            names=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            level=2)])"
msgstr ""
">>> print(ast.dump(ast.parse('from ..foo.bar import a as b, c'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        ImportFrom(\n"
"            modul='foo.bar',\n"
"            namn=[\n"
"                alias(name='a', asname='b'),\n"
"                alias(name='c')],\n"
"            nivå=2)])"

msgid "Control flow"
msgstr "Kontrollflöde"

msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Valfria klausuler som ``else`` lagras som en tom lista om de inte finns med."

msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"En ``if``-sats. ``test`` innehåller en enda nod, t.ex. en :class:`Compare`-"
"nod. ``body`` och ``orelse`` innehåller var och en en lista med noder."

msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"``elif``-klausuler har ingen speciell representation i AST, utan visas "
"snarare som extra :class:`If`-noder i ``orelse``-avsnittet i det föregående."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... if x:\n"
"...    ...\n"
"... elif y:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        If(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                If(\n"
"                    test=Name(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... om x:\n"
"... ...\n"
"... elif y:\n"
"... ...\n"
"... annat:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Om(\n"
"            test=Namn(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            orelse=[\n"
"                Om(\n"
"                    test=Namn(id='y', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))],\n"
"                    orelse=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))])])]])"

msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple`, :class:`List`, :class:`Attribute` or :"
"class:`Subscript` node. ``iter`` holds the item to be looped over, again as "
"a single node. ``body`` and ``orelse`` contain lists of nodes to execute. "
"Those in ``orelse`` are executed if the loop finishes normally, rather than "
"via a ``break`` statement."
msgstr ""
"En ``for``-slinga. ``target`` innehåller variabeln/variablerna som loopen "
"tilldelar, som en enskild :class:`Name`, :class:`Tuple`, :class:`List`, :"
"class:`Attribute` eller :class:`Subscript` nod. ``iter`` innehåller det "
"objekt som ska loopas över, återigen som en enda nod. ``body`` och "
"``orelse`` innehåller listor över noder som ska köras. De i ``orelse`` "
"exekveras om loopen avslutas på normalt sätt, snarare än via en ``break``-"
"sats."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... for x in y:\n"
"...     ...\n"
"... else:\n"
"...     ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... för x i y:\n"
"... ...\n"
"... annat:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        För(\n"
"            target=Namn(id='x', ctx=Store()),\n"
"            iter=Name(id='y', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))])])"

msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"En ``while``-loop. ``test`` innehåller villkoret, t.ex. en :class:`Compare`-"
"nod."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... while x:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        While(\n"
"            test=Name(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... medan x:\n"
"... ...\n"
"... annat:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Medan(\n"
"            test=Namn(id='x', ctx=Load()),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            orelse=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))])])"

msgid "The ``break`` and ``continue`` statements."
msgstr "Uttalandena ``bryt`` och ``fortsätt``."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... for a in b:\n"
"...     if a > 5:\n"
"...         break\n"
"...     else:\n"
"...         continue\n"
"...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        For(\n"
"            target=Name(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                If(\n"
"                    test=Compare(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Continue()])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... för a i b:\n"
"... om a > 5:\n"
"... break\n"
"... annars:\n"
"... fortsätt\n"
"...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        För(\n"
"            target=Namn(id='a', ctx=Store()),\n"
"            iter=Name(id='b', ctx=Load()),\n"
"            body=[\n"
"                Om(\n"
"                    test=Jämför(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(värde=5)]),\n"
"                    body=[\n"
"                        Break()],\n"
"                    orelse=[\n"
"                        Fortsätt()])])])"

msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``försök`` block. Alla attribut är listor över noder som ska köras, utom "
"``handlers``, som är en lista över :class:`ExceptHandler`-noder."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except Exception:\n"
"...    ...\n"
"... except OtherException as e:\n"
"...    ...\n"
"... else:\n"
"...    ...\n"
"... finally:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            finalbody=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... försök:\n"
"... ...\n"
"... utom Exception:\n"
"... ...\n"
"... förutom OtherException som e:\n"
"... ...\n"
"... else:\n"
"... ...\n"
"... slutligen:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Försök(\n"
"            kropp=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            handlers=[\n"
"                UndantagHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                ExceptHandler(\n"
"                    type=Name(id='OtherException', ctx=Load()),\n"
"                    name='e',\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis)))])],\n"
"            orelse=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            slutkropp=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))])]])"

msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""
"``try``-block som följs av ``except*``-klausuler. Attributen är desamma som "
"för :class:`Try` men :class:`ExceptHandler`-noderna i ``handlers`` tolkas "
"som ``except*`-block i stället för ``except``."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... try:\n"
"...    ...\n"
"... except* Exception:\n"
"...    ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TryStar(\n"
"            body=[\n"
"                Expr(\n"
"                    value=Constant(value=Ellipsis))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... försök:\n"
"... ...\n"
"... except* Undantag:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        TryStar(\n"
"            kropp=[\n"
"                Expr(\n"
"                    värde=Konstant(värde=Ellipsis))],\n"
"            handlers=[\n"
"                UndantagHandler(\n"
"                    type=Name(id='Exception', ctx=Load()),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"En enda ``except`` klausul. ``type`` är undantagstypen som den kommer att "
"matcha, vanligtvis en :class:`Name` nod (eller ``None`` för en catch-all "
"``except:`` klausul). ``name`` är en rå sträng för namnet på undantaget, "
"eller ``None`` om klausulen inte har ``as foo``. ``body`` är en lista med "
"noder."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... try:\n"
"...     a + 1\n"
"... except TypeError:\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Try(\n"
"            body=[\n"
"                Expr(\n"
"                    value=BinOp(\n"
"                        left=Name(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Constant(value=1)))],\n"
"            handlers=[\n"
"                ExceptHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\"\")\n"
"... försök:\n"
"... a + 1\n"
"... förutom TypeError:\n"
"... pass\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Försök(\n"
"            kropp=[\n"
"                Expr(\n"
"                    värde=BinOp(\n"
"                        left=Namn(id='a', ctx=Load()),\n"
"                        op=Add(),\n"
"                        right=Konstant(värde=1)))],\n"
"            handlers=[\n"
"                UndantagHandler(\n"
"                    type=Name(id='TypeError', ctx=Load()),\n"
"                    body=[\n"
"                        Pass()])])])"

msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Ett ``with``-block. ``items`` är en lista med :class:`withitem`-noder som "
"representerar kontexthanterarna, och ``body`` är det indragna blocket inuti "
"kontexten."

msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"En enda kontexthanterare i ett ``with``-block. ``context_expr`` är "
"kontexthanteraren, ofta en :class:`Call` nod. ``optional_vars`` är en :class:"
"`Name`, :class:`Tuple` eller :class:`List` för ``as foo`` delen, eller "
"``None`` om det inte används."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... with a as b, c as d:\n"
"...    something(b, d)\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        With(\n"
"            items=[\n"
"                withitem(\n"
"                    context_expr=Name(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                withitem(\n"
"                    context_expr=Name(id='c', ctx=Load()),\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    value=Call(\n"
"                        func=Name(id='something', ctx=Load()),\n"
"                        args=[\n"
"                            Name(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())]))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... med a som b, c som d:\n"
"... något(b, d)\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Med(\n"
"            objekt=[\n"
"                medobjekt(\n"
"                    context_expr=Namn(id='a', ctx=Load()),\n"
"                    optional_vars=Name(id='b', ctx=Store())),\n"
"                medobjekt(\n"
"                    context_expr=Name(id='c', ctx=Load()), "
"optional_vars=Name(id='b', ctx=Store())\n"
"                    optional_vars=Name(id='d', ctx=Store()))],\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Anrop(\n"
"                        func=Name(id='något', ctx=Load()),\n"
"                        args=[\n"
"                            Namn(id='b', ctx=Load()),\n"
"                            Name(id='d', ctx=Load())]))])])])"

msgid "Pattern matching"
msgstr "Mönstermatchning"

msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"En ``match``-sats. ``subject`` innehåller ämnet för matchningen (det objekt "
"som matchas mot fallen) och ``cases`` innehåller en iterabel av :class:"
"`match_case`-noder med de olika fallen."

msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"Ett enskilt fallmönster i en ``match``-sats. ``pattern`` innehåller det "
"matchningsmönster som ämnet kommer att matchas mot. Observera att de :class:"
"`AST`-noder som produceras för mönster skiljer sig från dem som produceras "
"för uttryck, även om de har samma syntax."

msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""
"Attributet ``guard`` innehåller ett uttryck som kommer att utvärderas om "
"mönstret matchar ämnet."

msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` innehåller en lista med noder som ska köras om mönstret matchar och "
"resultatet av utvärderingen av guard-uttrycket är sant."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] if x>0:\n"
"...         ...\n"
"...     case tuple():\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Compare(\n"
"                        left=Name(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Constant(value=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load())),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... case [x] if x>0:\n"
"... ...\n"
"... fall tuple():\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchAs(name='x')]),\n"
"                    guard=Jämförelse(\n"
"                        left=Namn(id='x', ctx=Load()),\n"
"                        ops=[\n"
"                            Gt()],\n"
"                        comparators=[\n"
"                            Konstant(värde=0)]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='tuple', ctx=Load())),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"Ett matchande bokstavs- eller värdemönster som jämförs genom likhet. "
"``value`` är en uttrycksnod. Tillåtna värdenoder är begränsade enligt "
"beskrivningen i dokumentationen för match-satsen. Det här mönstret lyckas om "
"matchningsobjektet är lika med det utvärderade värdet."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case \"Relevant\":\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchValue(\n"
"                        value=Constant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall \"Relevant\":\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matchvärde(\n"
"                        value=Konstant(value='Relevant')),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])]])"

msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"Ett litterärt matchningsmönster som jämför med identitet. ``value`` är den "
"singleton som ska jämföras mot: ``None``, ``True``, eller ``False``. Detta "
"mönster lyckas om matchningsobjektet är den givna konstanten."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case None:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"... fall Ingen:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=MatchSingleton(value=None),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])]])"

msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"Ett matchningsmönster för en sekvens. ``patterns`` innehåller de mönster som "
"ska matchas mot ämneselementen om ämnet är en sekvens. Matchar en sekvens "
"med variabel längd om ett av undermönstren är en ``MatchStar``-nod, annars "
"matchas en sekvens med fast längd."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [1, 2]:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=1)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=2))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])]])"

msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"Matchar resten av sekvensen i ett matchsekvensmönster med variabel längd. Om "
"``name`` inte är ``None``, binds en lista som innehåller de återstående "
"sekvenselementen till det namnet om det övergripande sekvensmönstret är "
"framgångsrikt."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [1, 2, *rest]:\n"
"...         ...\n"
"...     case [*_]:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=1)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchSequence(\n"
"                        patterns=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [1, 2, *rest]:\n"
"... ...\n"
"... fall [*_]:\n"
"... ...\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=1)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=2)),\n"
"                            MatchStar(name='rest')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=Matcha sekvens(\n"
"                        mönster=[\n"
"                            MatchStar()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"Ett matchande mappningsmönster. ``keys`` är en sekvens av uttrycksnoder. "
"``patterns`` är en motsvarande sekvens av mönsternoder. ``rest`` är ett "
"valfritt namn som kan anges för att fånga de återstående mappningselementen. "
"Tillåtna nyckeluttryck begränsas på det sätt som beskrivs i dokumentationen "
"för match statement."

msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"Detta mönster lyckas om ämnet är en mappning, alla utvärderade nyckeluttryck "
"finns i mappningen och värdet som motsvarar varje nyckel matchar motsvarande "
"undermönster. Om ``rest`` inte är ``None``, binds en dict som innehåller de "
"återstående mappningselementen till namnet om det övergripande "
"mappningsmönstret är framgångsrikt."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case {1: _, 2: _}:\n"
"...         ...\n"
"...     case {**rest}:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchMapping(\n"
"                        keys=[\n"
"                            Constant(value=1),\n"
"                            Constant(value=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall {1: _, 2: _}:\n"
"... ...\n"
"... fall {**rest}:\n"
"... ...\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchMapping(\n"
"                        nycklar=[\n"
"                            Konstant(värde=1),\n"
"                            Konstant(värde=2)],\n"
"                        patterns=[\n"
"                            MatchAs(),\n"
"                            MatchAs()]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchMapping(rest='rest'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))])])]])"

msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"Ett matchningsmönster för klass. ``cls`` är ett uttryck som anger den "
"nominella klass som skall matchas. ``patterns`` är en sekvens av "
"mönsternoder som skall matchas mot den klassdefinierade sekvensen av "
"attribut för mönstermatchning. ``kwd_attrs`` är en sekvens av ytterligare "
"attribut som skall matchas (specificerade som nyckelordsargument i "
"klassmönstret), ``kwd_patterns`` är motsvarande mönster (specificerade som "
"nyckelordsvärden i klassmönstret)."

msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"Detta mönster lyckas om ämnet är en instans av den nominerade klassen, alla "
"positionsmönster matchar motsvarande klassdefinierade attribut och alla "
"angivna nyckelordsattribut matchar motsvarande mönster."

msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"Observera: Klasser kan definiera en egenskap som returnerar self för att "
"matcha en mönsternod mot den instans som ska matchas. Flera inbyggda typer "
"matchas också på detta sätt, vilket beskrivs i dokumentationen för match "
"statement."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case Point2D(0, 0):\n"
"...         ...\n"
"...     case Point3D(x=0, y=0, z=0):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Name(id='Point3D', ctx=Load()),\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0)),\n"
"                            MatchValue(\n"
"                                value=Constant(value=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall Point2D(0, 0):\n"
"... ...\n"
"... case Point3D(x=0, y=0, z=0):\n"
"... ...\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchClass(\n"
"                        cls=Name(id='Point2D', ctx=Load()),\n"
"                        patterns=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchClass(\n"
"                        cls=Namn(id='Point3D', ctx=Load()),\n"
"                        kwd_attrs=[\n"
"                            'x',\n"
"                            'y',\n"
"                            'z'],\n"
"                        kwd_patterns=[\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0)),\n"
"                            MatchValue(\n"
"                                värde=Konstant(värde=0))]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"En matchning \"som mönster\", fångstmönster eller jokerteckenmönster. "
"``pattern`` innehåller det matchningsmönster som ämnet kommer att matchas "
"mot. Om mönstret är ``None`` representerar noden ett fångstmönster (dvs. ett "
"tomt namn) och kommer alltid att lyckas."

msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"Attributet ``name`` innehåller det namn som kommer att bindas om mönstret är "
"framgångsrikt. Om ``name`` är ``None`` måste ``pattern`` också vara ``None`` "
"och noden representerar wildcard-mönstret."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] as y:\n"
"...         ...\n"
"...     case _:\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchAs(\n"
"                        pattern=MatchSequence(\n"
"                            patterns=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [x] som y:\n"
"... ...\n"
"... fall _:\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchAs(\n"
"                        mönster=MatchSequence(\n"
"                            mönster=[\n"
"                                MatchAs(name='x')]),\n"
"                        name='y'),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))]),\n"
"                match_case(\n"
"                    pattern=MatchAs(),\n"
"                    body=[\n"
"                        Expr(\n"
"                            värde=Konstant(värde=Ellipsis))])])]])"

msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"En matchning \"eller-mönster\". Ett eller-mönster matchar vart och ett av "
"sina undermönster i tur och ordning till ämnet, tills ett lyckas. Då anses "
"or-mönstret vara framgångsrikt. Om inget av undermönstren lyckas misslyckas "
"or-mönstret. Attributet ``patterns`` innehåller en lista över "
"matchningsmönsternoder som kommer att matchas mot subjektet."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... match x:\n"
"...     case [x] | (y):\n"
"...         ...\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Match(\n"
"            subject=Name(id='x', ctx=Load()),\n"
"            cases=[\n"
"                match_case(\n"
"                    pattern=MatchOr(\n"
"                        patterns=[\n"
"                            MatchSequence(\n"
"                                patterns=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Constant(value=Ellipsis))])])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\n"
"... matcha x:\n"
"... fall [x] | (y):\n"
"... ...\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    kropp=[\n"
"        Matchning(\n"
"            subject=Namn(id='x', ctx=Load()),\n"
"            fall=[\n"
"                match_case(\n"
"                    mönster=MatchOr(\n"
"                        mönster=[\n"
"                            MatchSequence(\n"
"                                mönster=[\n"
"                                    MatchAs(name='x')]),\n"
"                            MatchAs(name='y')]),\n"
"                    body=[\n"
"                        Expr(\n"
"                            value=Konstant(value=Ellipsis))])])])])"

msgid "Type annotations"
msgstr "Typ av anteckningar"

msgid ""
"A ``# type: ignore`` comment located at *lineno*. *tag* is the optional tag "
"specified by the form ``# type: ignore <tag>``."
msgstr ""
"En ``# type: ignore`` kommentar som finns på *lineno*. *tag* är den valfria "
"tagg som anges av formuläret ``# type: ignore <tag>``."

msgid ""
">>> print(ast.dump(ast.parse('x = 1 # type: ignore', type_comments=True), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        Assign(\n"
"            targets=[\n"
"                Name(id='x', ctx=Store())],\n"
"            value=Constant(value=1))],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='')])\n"
">>> print(ast.dump(ast.parse('x: bool = 1 # type: ignore[assignment]', "
"type_comments=True), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Name(id='x', ctx=Store()),\n"
"            annotation=Name(id='bool', ctx=Load()),\n"
"            value=Constant(value=1),\n"
"            simple=1)],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='[assignment]')])"
msgstr ""
">>> print(ast.dump(ast.parse('x = 1 # typ: ignorera', type_comments=True), "
"indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Tilldela(\n"
"            mål=[\n"
"                Namn(id='x', ctx=Store())],\n"
"            value=Konstant(värde=1))],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='')])\n"
">>> print(ast.dump(ast.parse('x: bool = 1 # type: ignore[assignment]', "
"type_comments=True), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        AnnAssign(\n"
"            target=Namn(id='x', ctx=Store()),\n"
"            annotation=Name(id='bool', ctx=Load()),\n"
"            value=Konstant(värde=1),\n"
"            simple=1)],\n"
"    type_ignores=[\n"
"        TypeIgnore(lineno=1, tag='[assignment]')])"

msgid ""
":class:`!TypeIgnore` nodes are not generated when the *type_comments* "
"parameter is set to ``False`` (default).  See :func:`ast.parse` for more "
"details."
msgstr ""
":class:`!TypeIgnore`-noder genereras inte när parametern *type_comments* är "
"inställd på ``False`` (standard).  Se :func:`ast.parse` för mer information."

msgid "Type parameters"
msgstr "Typ av parametrar"

msgid ""
":ref:`Type parameters <type-params>` can exist on classes, functions, and "
"type aliases."
msgstr ""
":ref:`Typ-parametrar <type-params>` kan finnas i klasser, funktioner och "
"typaliaser."

msgid ""
"A :class:`typing.TypeVar`. ``name`` is the name of the type variable. "
"``bound`` is the bound or constraints, if any. If ``bound`` is a :class:"
"`Tuple`, it represents constraints; otherwise it represents the bound. "
"``default_value`` is the default value; if the :class:`!TypeVar` has no "
"default, this attribute will be set to ``None``."
msgstr ""
"En :class:`typing.TypeVar`. ``name`` är namnet på typvariabeln. ``bound`` är "
"bindningen eller begränsningarna, om sådana finns. Om ``bound`` är en :class:"
"`Tuple` representerar den begränsningar; annars representerar den "
"bindningen. ``default_value`` är standardvärdet; om :class:`!TypeVar` inte "
"har något standardvärde kommer detta attribut att sättas till ``None``."

msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[T: int = bool] = list[T]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()),\n"
"                    default_value=Name(id='bool', ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"typ Alias[T: int = bool] = list[T]\"), "
"indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVar(\n"
"                    name='T',\n"
"                    bound=Name(id='int', ctx=Load()),\n"
"                    default_value=Name(id='bool', ctx=Load()))],\n"
"            värde=Subskript(\n"
"                value=Name(id='list', ctx=Load()),\n"
"                slice=Name(id='T', ctx=Load()),\n"
"                ctx=Load()))])"

msgid "Added the *default_value* parameter."
msgstr "Parametern *default_value* har lagts till."

msgid ""
"A :class:`typing.ParamSpec`. ``name`` is the name of the parameter "
"specification. ``default_value`` is the default value; if the :class:`!"
"ParamSpec` has no default, this attribute will be set to ``None``."
msgstr ""
"En :class:`typing.ParamSpec`. ``name`` är namnet på "
"parameterspecifikationen. ``default_value`` är standardvärdet; om :class:`!"
"ParamSpec` inte har något standardvärde kommer detta attribut att sättas "
"till ``None``."

msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[**P = [int, str]] = Callable[P, "
"int]\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(\n"
"                    name='P',\n"
"                    default_value=List(\n"
"                        elts=[\n"
"                            Name(id='int', ctx=Load()),\n"
"                            Name(id='str', ctx=Load())],\n"
"                        ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Name(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"typ Alias[**P = [int, str]] = Callable[P, "
"int]\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                ParamSpec(\n"
"                    name='P',\n"
"                    default_value=Lista(\n"
"                        elts=[\n"
"                            Namn(id='int', ctx=Load()),\n"
"                            Name(id='str', ctx=Load()))],\n"
"                        ctx=Load())))],\n"
"            värde=Subskript(\n"
"                value=Name(id='Callable', ctx=Load()),\n"
"                slice=Tupel(\n"
"                    elts=[\n"
"                        Namn(id='P', ctx=Load()),\n"
"                        Name(id='int', ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"

msgid ""
"A :class:`typing.TypeVarTuple`. ``name`` is the name of the type variable "
"tuple. ``default_value`` is the default value; if the :class:`!TypeVarTuple` "
"has no default, this attribute will be set to ``None``."
msgstr ""
"En :class:`typing.TypeVarTuple`. ``name`` är namnet på typvariabeln tuple. "
"``default_value`` är standardvärdet; om :class:`!TypeVarTuple` inte har "
"något standardvärde kommer detta attribut att sättas till ``None``."

msgid ""
">>> print(ast.dump(ast.parse(\"type Alias[*Ts = ()] = tuple[*Ts]\"), "
"indent=4))\n"
"Module(\n"
"    body=[\n"
"        TypeAlias(\n"
"            name=Name(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(\n"
"                    name='Ts',\n"
"                    default_value=Tuple(ctx=Load()))],\n"
"            value=Subscript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tuple(\n"
"                    elts=[\n"
"                        Starred(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"typ Alias[*Ts = ()] = tuple[*Ts]\"), "
"indent=4))\n"
"Modul(\n"
"    body=[\n"
"        TypAlias(\n"
"            name=Namn(id='Alias', ctx=Store()),\n"
"            type_params=[\n"
"                TypeVarTuple(\n"
"                    name='Ts',\n"
"                    default_value=Tuple(ctx=Load()))],\n"
"            value=Subskript(\n"
"                value=Name(id='tuple', ctx=Load()),\n"
"                slice=Tupel(\n"
"                    elts=[\n"
"                        Stjärnmärkt(\n"
"                            value=Name(id='Ts', ctx=Load()),\n"
"                            ctx=Load())],\n"
"                    ctx=Load()),\n"
"                ctx=Load()))])"

msgid "Function and class definitions"
msgstr "Funktions- och klassdefinitioner"

msgid "A function definition."
msgstr "En funktionsdefinition."

msgid "``name`` is a raw string of the function name."
msgstr "``name`` är en rå sträng med funktionens namn."

msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` är en nod i :class:`arguments`."

msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` är listan över noder i funktionen."

msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` är listan över dekoratorer som ska tillämpas, lagrade "
"längst ut först (dvs. den första i listan kommer att tillämpas sist)."

msgid "``returns`` is the return annotation."
msgstr "``returns`` är returannoteringen."

msgid "``type_params`` is a list of :ref:`type parameters <ast-type-params>`."
msgstr ""
"``type_params`` är en lista med :ref:`typ-parametrar <ast-type-params>`."

msgid "Added ``type_params``."
msgstr "Lagt till ``type_params``."

msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` är en minimal funktionsdefinition som kan användas inuti ett "
"uttryck. Till skillnad från :class:`FunctionDef` innehåller ``body`` en enda "
"nod."

msgid ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Lambda(\n"
"                args=arguments(\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')]),\n"
"                body=Constant(value=Ellipsis)))])"
msgstr ""
">>> print(ast.dump(ast.parse('lambda x,y: ...'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=Lambda(\n"
"                args=argument(\n"
"                    args=[\n"
"                        arg(arg='x'),\n"
"                        arg(arg='y')]),\n"
"                body=Konstant(värde=Ellipsis)))])"

msgid "The arguments for a function."
msgstr "Argumenten för en funktion."

msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` och ``kwonlyargs`` är listor av :class:`arg`-noder."

msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` och ``kwarg`` är enskilda :class:`arg`-noder som refererar till "
"parametrarna ``*args, **kwargs``."

msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` är en lista med standardvärden för argument som endast "
"innehåller nyckelord. Om ett är ``None`` krävs motsvarande argument."

msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` är en lista med standardvärden för argument som kan skickas "
"positionellt. Om det finns färre standardvärden motsvarar de de sista n "
"argumenten."

msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name; "
"``annotation`` is its annotation, such as a :class:`Name` node."
msgstr ""
"Ett enskilt argument i en lista. ``arg`` är en rå sträng med argumentets "
"namn; ``annotation`` är dess annotation, t.ex. en :class:`Name`-nod."

msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` är en valfri sträng med typannoteringen som en kommentar"

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'return "
"annotation':\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        FunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Constant(value='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    None,\n"
"                    Constant(value=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Constant(value=1),\n"
"                    Constant(value=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())],\n"
"            returns=Constant(value='return annotation'))])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\"\")\n"
"... @dekoratör1\n"
"... @dekorerare2\n"
"... def f(a: 'annotation', b=1, c=2, *d, e, f=3, **g) -> 'returnera "
"annotation':\n"
"... pass\n"
"... \"\"\"), indrag=4))\n"
"Modul(\n"
"    body=[\n"
"        FunktionDef(\n"
"            name='f',\n"
"            args=argument(\n"
"                args=[\n"
"                    arg(\n"
"                        arg='a',\n"
"                        annotation=Konstant(värde='annotation')),\n"
"                    arg(arg='b'),\n"
"                    arg(arg='c')],\n"
"                vararg=arg(arg='d'),\n"
"                kwonlyargs=[\n"
"                    arg(arg='e'),\n"
"                    arg(arg='f')],\n"
"                kw_defaults=[\n"
"                    Ingen,\n"
"                    Constant(värde=3)],\n"
"                kwarg=arg(arg='g'),\n"
"                defaults=[\n"
"                    Konstant(värde=1),\n"
"                    Constant(värde=2)]),\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Namn(id='decorator1', ctx=Load()),\n"
"                Name(id='dekorator2', ctx=Load())],\n"
"            returns=Constant(value='returnera anteckning'))])"

msgid "A ``return`` statement."
msgstr "Ett ``retur`` uttalande."

msgid ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Return(\n"
"            value=Constant(value=4))])"
msgstr ""
">>> print(ast.dump(ast.parse('return 4'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Retur(\n"
"            värde=Konstant(värde=4))])"

msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in an :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"Ett ``yield`` eller ``yield from`` uttryck. Eftersom det här är uttryck "
"måste de omslutas av en :class:`Expr`-nod om värdet som skickas tillbaka "
"inte ska användas."

msgid ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=Yield(\n"
"                value=Name(id='x', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('yield from x'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Expr(\n"
"            value=YieldFrom(\n"
"                value=Name(id='x', ctx=Load())))])"
msgstr ""
">>> print(ast.dump(ast.parse('yield x'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=Yield(\n"
"                värde=Namn(id='x', ctx=Load())))])\n"
"\n"
">>> print(ast.dump(ast.parse('yield från x'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Expr(\n"
"            värde=YieldFrom(\n"
"                värde=Namn(id='x', ctx=Load())))])"

msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"``global`` och ``nonlocal`` satser. ``names`` är en lista med råa strängar."

msgid ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Global(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])\n"
"\n"
">>> print(ast.dump(ast.parse('nonlocal x,y,z'), indent=4))\n"
"Module(\n"
"    body=[\n"
"        Nonlocal(\n"
"            names=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])"
msgstr ""
">>> print(ast.dump(ast.parse('global x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Global(\n"
"            namn=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])\n"
"\n"
">>> print(ast.dump(ast.parse('icke-lokala x,y,z'), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        Icke-lokala(\n"
"            namn=[\n"
"                'x',\n"
"                'y',\n"
"                'z'])])"

msgid "A class definition."
msgstr "En klassdefinition."

msgid "``name`` is a raw string for the class name"
msgstr "``name`` är en rå sträng för klassnamnet"

msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases`` är en lista med noder för explicit angivna basklasser."

msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per :pep:"
"`3115`."
msgstr ""
"``keywords`` är en lista med :class:`.keyword`-noder, huvudsakligen för "
"'metaclass'. Andra nyckelord kommer att skickas till metaklassen, enligt :"
"pep:`3115`."

msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""
"``body`` är en lista med noder som representerar koden i klassdefinitionen."

msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` är en lista med noder, som i :class:`FunctionDef`."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... @decorator1\n"
"... @decorator2\n"
"... class Foo(base1, base2, metaclass=meta):\n"
"...     pass\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        ClassDef(\n"
"            name='Foo',\n"
"            bases=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            keywords=[\n"
"                keyword(\n"
"                    arg='metaclass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\"\")\n"
"... @dekoratör1\n"
"... @dekorerare2\n"
"... klass Foo(bas1, bas2, metaklass=meta):\n"
"... pass\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    body=[\n"
"        KlassDef(\n"
"            name='Foo',\n"
"            baser=[\n"
"                Name(id='base1', ctx=Load()),\n"
"                Name(id='base2', ctx=Load())],\n"
"            nyckelord=[\n"
"                nyckelord(\n"
"                    arg='metaklass',\n"
"                    value=Name(id='meta', ctx=Load()))],\n"
"            body=[\n"
"                Pass()],\n"
"            decorator_list=[\n"
"                Name(id='decorator1', ctx=Load()),\n"
"                Name(id='decorator2', ctx=Load())])])"

msgid "Async and await"
msgstr "Asynkron och await"

msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"En ``async def`` funktionsdefinition. Har samma fält som :class:"
"`FunctionDef`."

msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Ett ``await``-uttryck. ``värde`` är vad den väntar på. Endast giltigt i "
"kroppen av en :class:`AsyncFunctionDef`."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()))))])])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... asynkron def f():\n"
"... vänta på andra_func()\n"
"... \"\"\"), indent=4))\n"
"Modul(\n"
"    kropp=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=argument(),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Avvakta(\n"
"                        värde=Kalla(\n"
"                            func=Namn(id='other_func', ctx=Load()))))]))])"

msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for``-loopar och ``async with``-kontexthanterare. De har samma fält "
"som :class:`For` respektive :class:`With`. Endast giltig i kroppen av en :"
"class:`AsyncFunctionDef`."

msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (for example, :class:`ast.Add`)."
msgstr ""
"När en sträng analyseras av :func:`ast.parse`, kommer operator-noder "
"(underklasser till :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast."
"cmpop`, :class:`ast.boolop` och :class:`ast.expr_context`) på det "
"returnerade trädet att vara singletons. Ändringar i ett av dem kommer att "
"återspeglas i alla andra förekomster av samma värde (t.ex. :class:`ast.Add`)."

msgid ":mod:`ast` helpers"
msgstr ":mod:`ast` hjälpare"

msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Förutom nodklasserna definierar modulen :mod:`ast` dessa verktygsfunktioner "
"och klasser för genomgång av abstrakta syntaxträd:"

msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, flags=FLAGS_VALUE, optimize=optimize)``, where "
"``FLAGS_VALUE`` is ``ast.PyCF_ONLY_AST`` if ``optimize <= 0`` and ``ast."
"PyCF_OPTIMIZED_AST`` otherwise."
msgstr ""
"Parsar källan till en AST-nod.  Motsvarar ``compile(source, filename, mode, "
"flags=FLAGS_VALUE, optimize=optimize)``, där ``FLAGS_VALUE`` är ``ast."
"PyCF_ONLY_AST`` om ``optimize <= 0`` och ``ast.PyCF_OPTIMIZED_AST`` annars."

msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"Om ``type_comments=True`` anges, modifieras parsern för att kontrollera och "
"returnera typkommentarer som specificeras av :pep:`484` och :pep:`526`. "
"Detta är likvärdigt med att lägga till :data:`ast.PyCF_TYPE_COMMENTS` till "
"flaggorna som skickas till :func:`compile`.  Detta kommer att rapportera "
"syntaxfel för felplacerade typkommentarer.  Utan denna flagga kommer "
"typkommentarer att ignoreras och fältet ``type_comment`` på valda AST-noder "
"kommer alltid att vara ``None``.  Dessutom kommer platserna för ``# type: "
"ignore`` kommentarer att returneras som ``type_ignores`` attributet för :"
"class:`Module` (annars är det alltid en tom lista)."

msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Dessutom, om ``mode`` är ``'func_type'``, ändras inmatningssyntaxen för att "
"motsvara :pep:`484` \"signaturtypskommentarer\", t.ex. ``(str, int) -> "
"List[str]``."

msgid ""
"Setting ``feature_version`` to a tuple ``(major, minor)`` will result in a "
"\"best-effort\" attempt to parse using that Python version's grammar. For "
"example, setting ``feature_version=(3, 9)`` will attempt to disallow parsing "
"of :keyword:`match` statements. Currently ``major`` must equal to ``3``. The "
"lowest supported version is ``(3, 7)`` (and this may increase in future "
"Python versions); the highest is ``sys.version_info[0:2]``. \"Best-effort\" "
"attempt means there is no guarantee that the parse (or success of the parse) "
"is the same as when run on the Python version corresponding to "
"``feature_version``."
msgstr ""
"Om du anger ``feature_version`` till en tupel ``(major, minor)`` kommer det "
"att resultera i ett \"best-effort\" försök att analysera med hjälp av den "
"Python-versionens grammatik. Till exempel, att sätta ``feature_version=(3, "
"9)`` kommer att försöka att inte tillåta parsning av :keyword:`match`-"
"satser. För närvarande måste ``major`` vara lika med ``3``. Den lägsta "
"versionen som stöds är ``(3, 7)`` (och detta kan öka i framtida Python-"
"versioner); den högsta är ``sys.version_info[0:2]``. \"Best-effort\"-försök "
"innebär att det inte finns någon garanti för att parsen (eller att parsen "
"lyckas) är densamma som när den körs på den Python-version som motsvarar "
"``feature_version``."

msgid ""
"If source contains a null character (``\\0``), :exc:`ValueError` is raised."
msgstr "Om källan innehåller ett null-tecken (``\\0``), :exc:`ValueError`."

msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"Observera att en lyckad parsning av källkod till ett AST-objekt inte "
"garanterar att den källkod som tillhandahålls är giltig Python-kod som kan "
"exekveras eftersom kompileringssteget kan ge upphov till ytterligare :exc:"
"`SyntaxError`-undantag. Till exempel genererar källan ``return 42`` en "
"giltig AST-nod för en return-sats, men den kan inte kompileras ensam (den "
"måste vara inuti en funktionsnod)."

msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"I synnerhet kommer :func:`ast.parse` inte att göra några scoping-kontroller, "
"vilket kompileringssteget gör."

msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"Det är möjligt att krascha Python-tolken med en tillräckligt stor/komplex "
"sträng på grund av begränsningar i stackdjupet i Pythons AST-kompilator."

msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"Lagt till ``type_comments``, ``mode='func_type'`` och ``feature_version``."

msgid ""
"The minimum supported version for ``feature_version`` is now ``(3, 7)``. The "
"``optimize`` argument was added."
msgstr ""
"Den minsta versionen som stöds för ``feature_version`` är nu ``(3, 7)``. "
"Argumentet ``optimize`` har lagts till."

msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"Unparse ett :class:`ast.AST`-objekt och generera en sträng med kod som "
"skulle producera ett motsvarande :class:`ast.AST`-objekt om det analyserades "
"tillbaka med :func:`ast.parse`."

msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"Den kodsträng som produceras kommer inte nödvändigtvis att vara lika med den "
"ursprungliga koden som genererade :class:`ast.AST`-objektet (utan några "
"kompilatoroptimeringar, t.ex. konstanta tuples/frozensets)."

msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Försök att unparsa ett mycket komplext uttryck skulle resultera i :exc:"
"`RecursionError`."

msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Utvärderar en uttrycksnod eller en sträng som endast innehåller en Python-"
"litteral eller containervisning.  Den angivna strängen eller noden får "
"endast bestå av följande Python-litteralstrukturer: strängar, bytes, tal, "
"tupler, listor, dicts, set, booleaner, ``None`` och ``Ellipsis``."

msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""
"Detta kan användas för att utvärdera strängar som innehåller Python-värden "
"utan att man behöver analysera värdena själv.  Den kan inte utvärdera "
"godtyckligt komplexa uttryck, t.ex. med operatorer eller indexering."

msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"Denna funktion har tidigare dokumenterats som \"säker\" utan att det har "
"definierats vad det innebär. Det var missvisande. Detta är specifikt "
"utformat för att inte exekvera Python-kod, till skillnad från den mer "
"allmänna :func:`eval`. Det finns ingen namnrymd, inga namnuppslagningar "
"eller möjlighet att ringa ut. Men det är inte fritt från angrepp: En "
"relativt liten inmatning kan leda till att minnet eller C-stacken tar slut "
"och att processen kraschar. Det finns också möjlighet till överdriven CPU-"
"konsumtion, denial of service, för vissa indata. Att anropa den på icke "
"betrodda data rekommenderas därför inte."

msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"Det är möjligt att krascha Python-tolken på grund av begränsningar i "
"stackdjupet i Pythons AST-kompilator."

msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"Det kan ge upphov till :exc:`ValueError`, :exc:`TypeError`, :exc:"
"`SyntaxError`, :exc:`MemoryError` och :exc:`RecursionError` beroende på den "
"felaktiga indata."

msgid "Now allows bytes and set literals."
msgstr "Tillåter nu bytes och set-litteraler."

msgid "Now supports creating empty sets with ``'set()'``."
msgstr "Stöder nu skapandet av tomma uppsättningar med ``'set()'``."

msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr "För stränginmatningar tas nu inledande mellanslag och tabbar bort."

msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Returnerar dokumentsträngen för den givna *noden* (som måste vara en :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, eller :class:"
"`Module` nod), eller ``None`` om den inte har någon dokumentsträng. Om "
"*clean* är true, rensa upp dokumentsträngens indrag med :func:`inspect."
"cleandoc`."

msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` stöds nu."

msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.end_lineno`, :"
"attr:`~ast.AST.col_offset`, or :attr:`~ast.AST.end_col_offset`) is missing, "
"return ``None``."
msgstr ""
"Hämta källkodssegmentet för den *källa* som genererade *nod*. Om någon "
"platsinformation (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.end_lineno`, :"
"attr:`~ast.AST.col_offset`, eller :attr:`~ast.AST.end_col_offset`) saknas, "
"returneras ``None``."

msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Om *padded* är ``True``, kommer den första raden i ett flerradigt uttalande "
"att fyllas med mellanslag för att matcha dess ursprungliga position."

msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`~ast.AST.lineno` and :attr:`~ast.AST.col_offset` attributes for every "
"node that supports them.  This is rather tedious to fill in for generated "
"nodes, so this helper adds these attributes recursively where not already "
"set, by setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""
"När du kompilerar ett nodträd med :func:`compile` förväntar sig kompilatorn "
"attributen :attr:`~ast.AST.lineno` och :attr:`~ast.AST.col_offset` för varje "
"nod som stöder dem.  Detta är ganska tråkigt att fylla i för genererade "
"noder, så den här hjälpen lägger till dessa attribut rekursivt där de inte "
"redan är inställda, genom att ställa in dem till värdena för den överordnade "
"noden.  Det fungerar rekursivt med början på *node*."

msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Öka radnumret och slutradnumret för varje nod i trädet som börjar vid *nod* "
"med *n*. Detta är användbart för att \"flytta kod\" till en annan plats i en "
"fil."

msgid ""
"Copy source location (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.col_offset`, :"
"attr:`~ast.AST.end_lineno`, and :attr:`~ast.AST.end_col_offset`) from "
"*old_node* to *new_node* if possible, and return *new_node*."
msgstr ""
"Kopiera källplatsen (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.col_offset`, :"
"attr:`~ast.AST.end_lineno`, och :attr:`~ast.AST.end_col_offset`) från "
"*old_node* till *new_node* om möjligt, och returnera *new_node*."

msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Ger en tupel av ``(fältnamn, värde)`` för varje fält i ``node._fields`` som "
"finns på *node*."

msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Ger alla direkta underordnade noder till *node*, dvs. alla fält som är noder "
"och alla fältobjekt som är listor över noder."

msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Ger rekursivt alla nedstigande noder i trädet som börjar på *node* "
"(inklusive *node* själv), utan specificerad ordning.  Detta är användbart om "
"du bara vill modifiera noder på plats och inte bryr dig om sammanhanget."

msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"En basklass för nodbesökare som går igenom det abstrakta syntaxträdet och "
"anropar en besökarfunktion för varje nod som hittas.  Denna funktion kan "
"returnera ett värde som vidarebefordras av :meth:`visit`-metoden."

msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Denna klass är avsedd att underklassificeras, varvid underklassen lägger "
"till besöksmetoder."

msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Besöker en nod.  Standardimplementeringen anropar metoden som heter :samp:"
"`self.visit_{classname}` där *klassnamn* är namnet på nodklassen, eller :"
"meth:`generic_visit` om den metoden inte finns."

msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Den här besökaren anropar :meth:`visit` på alla barn till noden."

msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Observera att barnnoder till noder som har en anpassad besöksmetod inte "
"kommer att besökas om inte besökaren anropar :meth:`generic_visit` eller "
"besöker dem själv."

msgid "Handles all constant nodes."
msgstr "Hanterar alla konstanta noder."

msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"Använd inte :class:`NodeVisitor` om du vill göra ändringar i noder under "
"traversal.  För detta finns en speciell besökare (:class:`NodeTransformer`) "
"som tillåter ändringar."

msgid ""
"Methods :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :meth:"
"`!visit_NameConstant` and :meth:`!visit_Ellipsis` are deprecated now and "
"will not be called in future Python versions.  Add the :meth:"
"`visit_Constant` method to handle all constant nodes."
msgstr ""
"Metoderna :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :"
"meth:`!visit_NameConstant` och :meth:`!visit_Ellipsis` är föråldrade nu och "
"kommer inte att anropas i framtida Python-versioner.  Lägg till metoden :"
"meth:`visit_Constant` för att hantera alla konstanta noder."

msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"En :class:`NodeVisitor`-underklass som går igenom det abstrakta syntaxträdet "
"och tillåter modifiering av noder."

msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` kommer att gå igenom AST och använda returvärdet "
"från besöksmetoderna för att ersätta eller ta bort den gamla noden.  Om "
"besöksmetodens returvärde är ``None`` kommer noden att tas bort från sin "
"plats, annars ersätts den med returvärdet.  Returvärdet kan vara den "
"ursprungliga noden och i så fall sker ingen ersättning."

msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Här är ett exempel på en transformator som skriver om alla förekomster av "
"namnuppslagningar (``foo``) till ``data['foo']``::"

msgid ""
"class RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Name(id='data', ctx=Load()),\n"
"            slice=Constant(value=node.id),\n"
"            ctx=node.ctx\n"
"        )"
msgstr ""
"klass RewriteName(NodeTransformer):\n"
"\n"
"    def visit_Name(self, node):\n"
"        return Subscript(\n"
"            value=Namn(id='data', ctx=Load()),\n"
"            slice=Konstant(värde=node.id),\n"
"            ctx=nod.ctx\n"
"        )"

msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`~ast."
"NodeVisitor.generic_visit` method for the node first."
msgstr ""
"Tänk på att om den nod du använder har underordnade noder måste du antingen "
"transformera de underordnade noderna själv eller anropa metoden :meth:`~ast."
"NodeVisitor.generic_visit` för noden först."

msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"För noder som ingick i en samling uttalanden (det gäller alla "
"uttalandenoder) kan besökaren också returnera en lista med noder i stället "
"för bara en enda nod."

msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:`~ast."
"AST.lineno`), :func:`fix_missing_locations` should be called with the new "
"sub-tree to recalculate the location information::"
msgstr ""
"Om :class:`NodeTransformer` introducerar nya noder (som inte var en del av "
"det ursprungliga trädet) utan att ge dem platsinformation (t.ex. :attr:`~ast."
"AST.lineno`), bör :func:`fix_missing_locations` anropas med det nya "
"delträdet för att räkna om platsinformationen::"

msgid ""
"tree = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"
msgstr ""
"träd = ast.parse('foo', mode='eval')\n"
"new_tree = fix_missing_locations(RewriteName().visit(tree))"

msgid "Usually you use the transformer like this::"
msgstr "Vanligtvis använder du transformatorn på följande sätt::"

msgid "node = YourTransformer().visit(node)"
msgstr "nod = DinTransformator().visit(nod)"

msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Returnerar en formaterad dumpning av trädet i *node*.  Detta är främst "
"användbart för felsökning.  Om *annotate_fields* är true (standard) kommer "
"den returnerade strängen att visa namn och värden för fälten. Om "
"*annotate_fields* är false blir resultatsträngen mer kompakt genom att "
"otvetydiga fältnamn utelämnas.  Attribut som radnummer och kolumnoffset "
"dumpas inte som standard.  Om detta önskas kan *include_attributes* sättas "
"till true."

msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Om *indent* är ett icke-negativt heltal eller en sträng, kommer trädet att "
"skrivas ut med den indragsnivån.  En indragsnivå på 0, negativ eller "
"``\"\"`` kommer endast att infoga nya rader.  ``None`` (standard) väljer "
"representation med en rad. Om du använder ett positivt heltal indenteras så "
"många mellanslag per nivå.  Om *indent* är en sträng (t.ex. ``\"\\t\"``) "
"används den strängen för att dra in varje nivå."

msgid ""
"If *show_empty* is false (the default), optional empty lists will be omitted "
"from the output. Optional ``None`` values are always omitted."
msgstr ""
"Om *show_empty* är false (standard) kommer valfria tomma listor att "
"utelämnas från utdata. Valfria ``None``-värden utelämnas alltid."

msgid "Added the *indent* option."
msgstr "Lagt till alternativet *indent*."

msgid "Added the *show_empty* option."
msgstr "Lagt till alternativet *show_empty*."

msgid ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... async def f():\n"
"...     await other_func()\n"
"... \"\"\"), indent=4, show_empty=True))\n"
"Module(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=arguments(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    value=Await(\n"
"                        value=Call(\n"
"                            func=Name(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            keywords=[])))],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    type_ignores=[])"
msgstr ""
">>> print(ast.dump(ast.parse(\"\"\"\\\n"
"... asynkron def f():\n"
"... vänta på andra_func()\n"
"... \"\"\"), indent=4, show_empty=True))\n"
"Modul(\n"
"    body=[\n"
"        AsyncFunctionDef(\n"
"            name='f',\n"
"            args=argument(\n"
"                posonlyargs=[],\n"
"                args=[],\n"
"                kwonlyargs=[],\n"
"                kw_defaults=[],\n"
"                defaults=[]),\n"
"            body=[\n"
"                Expr(\n"
"                    värde=Vänta(\n"
"                        värde=Kalla(\n"
"                            func=Namn(id='other_func', ctx=Load()),\n"
"                            args=[],\n"
"                            nyckelord=[])))]],\n"
"            decorator_list=[],\n"
"            type_params=[])],\n"
"    typ_ignores=[])"

msgid "Compiler flags"
msgstr "Flaggor för kompilator"

msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Följande flaggor kan skickas till :func:`compile` för att ändra effekterna "
"på kompileringen av ett program:"

msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Aktiverar stöd för toppnivå ``await``, ``async for``, ``async with`` och "
"async-förståelser."

msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Genererar och returnerar ett abstrakt syntaxträd i stället för att returnera "
"ett kompilerat kodobjekt."

msgid ""
"The returned AST is optimized according to the *optimize* argument in :func:"
"`compile` or :func:`ast.parse`."
msgstr ""
"Den returnerade AST:n optimeras enligt *optimize*-argumentet i :func:"
"`compile` eller :func:`ast.parse`."

msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Aktiverar stöd för typkommentarer i stil med :pep:`484` och :pep:`526` (``# "
"type: <type>``, ``# type: ignore <stuff>``)."

msgid "Recursively compares two ASTs."
msgstr "Jämför rekursivt två AST:er."

msgid ""
"*compare_attributes* affects whether AST attributes are considered in the "
"comparison. If *compare_attributes* is ``False`` (default), then attributes "
"are ignored. Otherwise they must all be equal. This option is useful to "
"check whether the ASTs are structurally equal but differ in whitespace or "
"similar details. Attributes include line numbers and column offsets."
msgstr ""
"*compare_attributes* påverkar om AST-attribut ska beaktas i jämförelsen. Om "
"*compare_attributes* är ``False`` (standard) ignoreras attributen. Annars "
"måste de alla vara lika. Det här alternativet är användbart för att "
"kontrollera om AST:erna är strukturellt lika men skiljer sig åt i blanksteg "
"eller liknande detaljer. Attribut inkluderar radnummer och kolumnoffset."

msgid "Command-line usage"
msgstr "Användning av kommandoraden"

msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"Modulen :mod:`ast` kan köras som ett skript från kommandoraden. Det är så "
"enkelt som att:"

msgid "python -m ast [-m <mode>] [-a] [infile]"
msgstr "python -m ast [-m <mode>] [-a] [infile]"

msgid "The following options are accepted:"
msgstr "Följande alternativ accepteras:"

msgid "Show the help message and exit."
msgstr "Visa hjälpmeddelandet och avsluta."

msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Ange vilken typ av kod som ska kompileras, som *mode*-argumentet i :func:"
"`parse`."

msgid "Don't parse type comments."
msgstr "Analysera inte typkommentarer."

msgid "Include attributes such as line numbers and column offsets."
msgstr "Inkludera attribut som radnummer och kolumnförskjutningar."

msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Indragning av noder i AST (antal mellanslag)."

msgid ""
"Python version in the format 3.x (for example, 3.10). Defaults to the "
"current version of the interpreter."
msgstr ""
"Python-version i formatet 3.x (t.ex. 3.10). Standardvärdet är den aktuella "
"versionen av tolken."

msgid "Optimization level for parser. Defaults to no optimization."
msgstr "Optimeringsnivå för parsern. Standardvärdet är ingen optimering."

msgid ""
"Show empty lists and fields that are ``None``. Defaults to not showing empty "
"objects."
msgstr ""
"Visa tomma listor och fält som är ``None``. Standardinställningen är att "
"inte visa tomma objekt."

msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Om :file:`infile` anges analyseras dess innehåll till AST och dumpas till "
"stdout.  I annat fall läses innehållet från stdin."

msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, en extern "
"dokumentationsresurs, har bra detaljer om hur man arbetar med Python ASTs."

msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annoterar Python ASTs med positionerna för tokens och text i källkoden som "
"genererade dem. Detta är användbart för verktyg som gör "
"källkodstransformationer."

msgid ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ unifies the token-based and parse-tree-based views of python programs "
"by inserting two-way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html#leoast-"
"py>`_ förenar de tokenbaserade och parse-tree-baserade vyerna av "
"pythonprogram genom att infoga tvåvägslänkar mellan tokens och ast-noder."

msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ analyserar kod som ett konkret "
"syntaxträd som ser ut som ett asträd och behåller alla formateringsdetaljer. "
"Det är användbart för att bygga automatiserade refaktoriseringsprogram "
"(codemod) och linters."

msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your Python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ är en Python-parser som stöder "
"felåterställning och round-trip-parsing för olika Python-versioner (i flera "
"Python-versioner). Parso kan också lista flera syntaxfel i din Python-fil."

msgid "? (question mark)"
msgstr "? (frågetecken)"

msgid "in AST grammar"
msgstr "i AST-grammatik"

msgid "* (asterisk)"
msgstr "* (asterisk)"
