# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Streams"
msgstr "Streams"

msgid "**Source code:** :source:`Lib/asyncio/streams.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/streams.py`"

msgid ""
"Streams are high-level async/await-ready primitives to work with network "
"connections.  Streams allow sending and receiving data without using "
"callbacks or low-level protocols and transports."
msgstr ""
"Streams är async/await-ready-primitiver på hög nivå för att arbeta med "
"nätverksanslutningar.  Streams gör det möjligt att skicka och ta emot data "
"utan att använda callbacks eller lågnivåprotokoll och transporter."

msgid "Here is an example of a TCP echo client written using asyncio streams::"
msgstr ""
"Här är ett exempel på en TCP-ekoklient som skrivits med hjälp av asyncio-"
"strömmar::"

msgid ""
"import asyncio\n"
"\n"
"async def tcp_echo_client(message):\n"
"    reader, writer = await asyncio.open_connection(\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    print(f'Send: {message!r}')\n"
"    writer.write(message.encode())\n"
"    await writer.drain()\n"
"\n"
"    data = await reader.read(100)\n"
"    print(f'Received: {data.decode()!r}')\n"
"\n"
"    print('Close the connection')\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"asyncio.run(tcp_echo_client('Hello World!'))"
msgstr ""
"import asyncio\n"
"\n"
"async def tcp_echo_client(message):\n"
"    reader, writer = await asyncio.open_connection(\n"
"        '127.0.0.1', 8888)\n"
"\n"
"    print(f'Send: {message!r}')\n"
"    writer.write(message.encode())\n"
"    await writer.drain()\n"
"\n"
"    data = await reader.read(100)\n"
"    print(f'Received: {data.decode()!r}')\n"
"\n"
"    print('Close the connection')\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"asyncio.run(tcp_echo_client('Hello World!'))"

msgid "See also the `Examples`_ section below."
msgstr "Se även avsnittet `Exempel` nedan."

msgid "Stream Functions"
msgstr "Strömfunktioner"

msgid ""
"The following top-level asyncio functions can be used to create and work "
"with streams:"
msgstr ""
"Följande asynciofunktioner på högsta nivå kan användas för att skapa och "
"arbeta med strömmar:"

msgid ""
"Establish a network connection and return a pair of ``(reader, writer)`` "
"objects."
msgstr ""
"Upprätta en nätverksanslutning och returnera ett par objekt av typen "
"``(reader, writer)``."

msgid ""
"The returned *reader* and *writer* objects are instances of :class:"
"`StreamReader` and :class:`StreamWriter` classes."
msgstr ""
"De returnerade *reader*- och *writer*-objekten är instanser av klasserna :"
"class:`StreamReader` och :class:`StreamWriter`."

msgid ""
"*limit* determines the buffer size limit used by the returned :class:"
"`StreamReader` instance.  By default the *limit* is set to 64 KiB."
msgstr ""
"*limit* bestämmer den buffertstorleksgräns som används av den returnerade :"
"class:`StreamReader`-instansen.  Som standard är *limit* inställd på 64 KiB."

msgid ""
"The rest of the arguments are passed directly to :meth:`loop."
"create_connection`."
msgstr ""
"Resten av argumenten skickas direkt till :meth:`loop.create_connection`."

msgid ""
"The *sock* argument transfers ownership of the socket to the :class:"
"`StreamWriter` created. To close the socket, call its :meth:`~asyncio."
"StreamWriter.close` method."
msgstr ""
"Argumentet *sock* överför ägandet av sockeln till den skapade :class:"
"`StreamWriter`. För att stänga sockeln, anropa dess :meth:`~asyncio."
"StreamWriter.close` metod."

msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Parametern *ssl_handshake_timeout* har lagts till."

msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Lagt till parametrarna *happy_eyeballs_delay* och *interleave*."

msgid "Removed the *loop* parameter."
msgstr "Parametern *loop* har tagits bort."

msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "Parametern *ssl_shutdown_timeout* har lagts till."

msgid "Start a socket server."
msgstr "Starta en socket-server."

msgid ""
"The *client_connected_cb* callback is called whenever a new client "
"connection is established.  It receives a ``(reader, writer)`` pair as two "
"arguments, instances of the :class:`StreamReader` and :class:`StreamWriter` "
"classes."
msgstr ""
"Callbacken *client_connected_cb* anropas när en ny klientanslutning "
"upprättas.  Den får ett par ``(reader, writer)`` som två argument, instanser "
"av klasserna :class:`StreamReader` och :class:`StreamWriter`."

msgid ""
"*client_connected_cb* can be a plain callable or a :ref:`coroutine function "
"<coroutine>`; if it is a coroutine function, it will be automatically "
"scheduled as a :class:`Task`."
msgstr ""
"*client_connected_cb* kan vara en vanlig callable eller en :ref:`coroutine-"
"funktion <coroutine>`; om det är en coroutine-funktion kommer den "
"automatiskt att schemaläggas som en :class:`Task`."

msgid ""
"The rest of the arguments are passed directly to :meth:`loop.create_server`."
msgstr "Resten av argumenten skickas direkt till :meth:`loop.create_server`."

msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"Argumentet *sock* överför äganderätten till sockeln till den server som "
"skapats. För att stänga sockeln anropar du serverns :meth:`~asyncio.Server."
"close`-metod."

msgid "Added the *ssl_handshake_timeout* and *start_serving* parameters."
msgstr ""
"Parametrarna *ssl_handshake_timeout* och *start_serving* har lagts till."

msgid "Added the *keep_alive* parameter."
msgstr "Parametern *keep_alive* har lagts till."

msgid "Unix Sockets"
msgstr "Unix Sockets"

msgid ""
"Establish a Unix socket connection and return a pair of ``(reader, writer)``."
msgstr ""
"Upprätta en Unix-socketanslutning och returnera ett par ``(reader, writer)``."

msgid "Similar to :func:`open_connection` but operates on Unix sockets."
msgstr "Liknar :func:`open_connection` men fungerar på Unix-sockets."

msgid "See also the documentation of :meth:`loop.create_unix_connection`."
msgstr "Se även dokumentationen av :meth:`loop.create_unix_connection`."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`"
msgstr ""
"Parametern *ssl_handshake_timeout* har lagts till. Parametern *path* kan nu "
"vara en :term:`path-liknande objekt`"

msgid "Start a Unix socket server."
msgstr "Starta en Unix-socket-server."

msgid "Similar to :func:`start_server` but works with Unix sockets."
msgstr "Liknar :func:`start_server` men fungerar med Unix-sockets."

msgid ""
"If *cleanup_socket* is true then the Unix socket will automatically be "
"removed from the filesystem when the server is closed, unless the socket has "
"been replaced after the server has been created."
msgstr ""
"Om *cleanup_socket* är true kommer Unix-sockeln automatiskt att tas bort "
"från filsystemet när servern stängs, såvida inte sockeln har bytts ut efter "
"att servern skapades."

msgid "See also the documentation of :meth:`loop.create_unix_server`."
msgstr "Se även dokumentationen av :meth:`loop.create_unix_server`."

msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :term:`path-like object`."
msgstr ""
"Parametrarna *ssl_handshake_timeout* och *start_serving* har lagts till. "
"Parametern *path* kan nu vara en :term:`path-liknande objekt`."

msgid "Added the *cleanup_socket* parameter."
msgstr "Parametern *cleanup_socket* har lagts till."

msgid "StreamReader"
msgstr "Strömläsare"

msgid ""
"Represents a reader object that provides APIs to read data from the IO "
"stream. As an :term:`asynchronous iterable`, the object supports the :"
"keyword:`async for` statement."
msgstr ""
"Representerar ett läsarobjekt som tillhandahåller API:er för att läsa data "
"från IO-strömmen. Som en :term:`asynkron iterabel` stöder objektet :keyword:"
"`async for`-satsen."

msgid ""
"It is not recommended to instantiate *StreamReader* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"Det är inte rekommenderat att instansiera *StreamReader*-objekt direkt; "
"använd istället :func:`open_connection` och :func:`start_server`."

msgid "Acknowledge the EOF."
msgstr "Bekräfta EOF."

msgid "Read up to *n* bytes from the stream."
msgstr "Läs upp till *n* byte från strömmen."

msgid ""
"If *n* is not provided or set to ``-1``, read until EOF, then return all "
"read :class:`bytes`. If EOF was received and the internal buffer is empty, "
"return an empty ``bytes`` object."
msgstr ""
"Om *n* inte anges eller sätts till ``-1``, läs tills EOF, returnera sedan "
"alla lästa :class:`bytes`. Om EOF mottogs och den interna bufferten är tom, "
"returneras ett tomt ``bytes``-objekt."

msgid "If *n* is ``0``, return an empty ``bytes`` object immediately."
msgstr "Om *n* är ``0``, returneras ett tomt ``bytes``-objekt omedelbart."

msgid ""
"If *n* is positive, return at most *n* available ``bytes`` as soon as at "
"least 1 byte is available in the internal buffer. If EOF is received before "
"any byte is read, return an empty ``bytes`` object."
msgstr ""
"Om *n* är positiv, returneras högst *n* tillgängliga ``bytes`` så snart "
"minst 1 byte finns tillgängligt i den interna bufferten. Om EOF tas emot "
"innan någon byte har lästs, returneras ett tomt ``bytes``-objekt."

msgid ""
"Read one line, where \"line\" is a sequence of bytes ending with ``\\n``."
msgstr "Läs en rad, där \"rad\" är en sekvens av bytes som slutar med ``\\n``."

msgid ""
"If EOF is received and ``\\n`` was not found, the method returns partially "
"read data."
msgstr ""
"Om EOF tas emot och ``\\n`` inte hittades, returnerar metoden delvis lästa "
"data."

msgid ""
"If EOF is received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr ""
"Om EOF tas emot och den interna bufferten är tom, returneras ett tomt "
"``bytes``-objekt."

msgid "Read exactly *n* bytes."
msgstr "Läs exakt *n* byte."

msgid ""
"Raise an :exc:`IncompleteReadError` if EOF is reached before *n* can be "
"read.  Use the :attr:`IncompleteReadError.partial` attribute to get the "
"partially read data."
msgstr ""
"Skapa ett :exc:`IncompleteReadError` om EOF nås innan *n* kan läsas.  Använd "
"attributet :attr:`IncompleteReadError.partial` för att hämta delvis lästa "
"data."

msgid "Read data from the stream until *separator* is found."
msgstr "Läs data från strömmen tills *separator* hittas."

msgid ""
"On success, the data and separator will be removed from the internal buffer "
"(consumed). Returned data will include the separator at the end."
msgstr ""
"Vid framgång kommer data och separator att tas bort från den interna "
"bufferten (konsumeras). Returnerade data kommer att innehålla separatorn i "
"slutet."

msgid ""
"If the amount of data read exceeds the configured stream limit, a :exc:"
"`LimitOverrunError` exception is raised, and the data is left in the "
"internal buffer and can be read again."
msgstr ""
"Om mängden data som läses överskrider den konfigurerade streamgränsen, "
"uppstår ett :exc:`LimitOverrunError`-undantag och data lämnas kvar i den "
"interna bufferten och kan läsas igen."

msgid ""
"If EOF is reached before the complete separator is found, an :exc:"
"`IncompleteReadError` exception is raised, and the internal buffer is "
"reset.  The :attr:`IncompleteReadError.partial` attribute may contain a "
"portion of the separator."
msgstr ""
"Om EOF nås innan den fullständiga separatorn hittats, uppstår ett :exc:"
"`IncompleteReadError` undantag och den interna bufferten nollställs.  "
"Attributet :attr:`IncompleteReadError.partial` kan innehålla en del av "
"separatorn."

msgid ""
"The *separator* may also be a tuple of separators. In this case the return "
"value will be the shortest possible that has any separator as the suffix. "
"For the purposes of :exc:`LimitOverrunError`, the shortest possible "
"separator is considered to be the one that matched."
msgstr ""
"*Separator* kan också vara en tupel av separatorer. I detta fall kommer "
"returvärdet att vara det kortaste möjliga som har någon separator som "
"suffix. När det gäller :exc:`LimitOverrunError` anses den kortaste möjliga "
"separatorn vara den som matchade."

msgid "The *separator* parameter may now be a :class:`tuple` of separators."
msgstr "Parametern *separator* kan nu vara en :class:`tuple` av separatorer."

msgid "Return ``True`` if the buffer is empty and :meth:`feed_eof` was called."
msgstr ""
"Returnerar ``True`` om bufferten är tom och :meth:`feed_eof` anropades."

msgid "StreamWriter"
msgstr "StreamWriter"

msgid ""
"Represents a writer object that provides APIs to write data to the IO stream."
msgstr ""
"Representerar ett writer-objekt som tillhandahåller API:er för att skriva "
"data till IO-strömmen."

msgid ""
"It is not recommended to instantiate *StreamWriter* objects directly; use :"
"func:`open_connection` and :func:`start_server` instead."
msgstr ""
"Det är inte rekommenderat att instansiera *StreamWriter*-objekt direkt; "
"använd istället :func:`open_connection` och :func:`start_server`."

msgid ""
"The method attempts to write the *data* to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"Metoden försöker skriva *data* till det underliggande uttaget omedelbart. Om "
"det misslyckas köas data i en intern skrivbuffert tills det kan skickas."

msgid "The method should be used along with the ``drain()`` method::"
msgstr "Metoden bör användas tillsammans med metoden ``drain()``::"

msgid ""
"stream.write(data)\n"
"await stream.drain()"
msgstr ""
"stream.write(data)\n"
"await ström.dränera()"

msgid ""
"The method writes a list (or any iterable) of bytes to the underlying socket "
"immediately. If that fails, the data is queued in an internal write buffer "
"until it can be sent."
msgstr ""
"Metoden skriver en lista (eller en iterabel) med bytes till den "
"underliggande sockeln omedelbart. Om det misslyckas köas data i en intern "
"skrivbuffert tills den kan skickas."

msgid ""
"stream.writelines(lines)\n"
"await stream.drain()"
msgstr ""
"stream.writelines(linjer)\n"
"await ström.dränera()"

msgid "The method closes the stream and the underlying socket."
msgstr "Metoden stänger strömmen och det underliggande uttaget."

msgid ""
"The method should be used, though not mandatory, along with the "
"``wait_closed()`` method::"
msgstr ""
"Metoden bör användas, men är inte obligatorisk, tillsammans med metoden "
"``wait_closed()``::"

msgid ""
"stream.close()\n"
"await stream.wait_closed()"
msgstr ""
"stream.stäng()\n"
"await stream.wait_closed()"

msgid ""
"Return ``True`` if the underlying transport supports the :meth:`write_eof` "
"method, ``False`` otherwise."
msgstr ""
"Returnerar ``True`` om den underliggande transporten stöder metoden :meth:"
"`write_eof`, annars ``False``."

msgid ""
"Close the write end of the stream after the buffered write data is flushed."
msgstr ""
"Stäng skrivänden av strömmen efter att den buffrade skrivdatan har spolats."

msgid "Return the underlying asyncio transport."
msgstr "Returnerar den underliggande asynciotransporten."

msgid ""
"Access optional transport information; see :meth:`BaseTransport."
"get_extra_info` for details."
msgstr ""
"Tillgång till valfri transportinformation; se :meth:`BaseTransport."
"get_extra_info` för detaljer."

msgid "Wait until it is appropriate to resume writing to the stream. Example::"
msgstr ""
"Vänta tills det är lämpligt att återuppta skrivningen till strömmen. "
"Exempel::"

msgid ""
"writer.write(data)\n"
"await writer.drain()"
msgstr ""
"writer.write(data)\n"
"await skribent.dränera()"

msgid ""
"This is a flow control method that interacts with the underlying IO write "
"buffer.  When the size of the buffer reaches the high watermark, *drain()* "
"blocks until the size of the buffer is drained down to the low watermark and "
"writing can be resumed.  When there is nothing to wait for, the :meth:"
"`drain` returns immediately."
msgstr ""
"Detta är en metod för flödeskontroll som interagerar med den underliggande "
"IO-skrivbufferten.  När storleken på bufferten når den höga vattenstämpeln "
"blockerar *drain()* tills storleken på bufferten har tömts ner till den låga "
"vattenstämpeln och skrivningen kan återupptas.  När det inte finns något att "
"vänta på återgår :meth:`drain` omedelbart."

msgid "Upgrade an existing stream-based connection to TLS."
msgstr "Uppgradera en befintlig strömbaserad anslutning till TLS."

msgid "Parameters:"
msgstr "Parametrar:"

msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: en konfigurerad instans av :class:`~ssl.SSLContext`."

msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: anger eller åsidosätter det värdnamn som målserverns "
"certifikat ska matchas mot."

msgid ""
"*ssl_handshake_timeout* is the time in seconds to wait for the TLS handshake "
"to complete before aborting the connection.  ``60.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_handshake_timeout* är den tid i sekunder som TLS-handskakningen ska "
"vänta på att slutföras innan anslutningen avbryts.  ``60,0`` sekunder om "
"``None`` (standard)."

msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_shutdown_timeout* är den tid i sekunder som ska vänta på att SSL-"
"avstängningen ska slutföras innan anslutningen avbryts. ``30.0`` sekunder om "
"``None`` (standard)."

msgid ""
"Return ``True`` if the stream is closed or in the process of being closed."
msgstr "Returnerar ``True`` om strömmen är stängd eller håller på att stängas."

msgid "Wait until the stream is closed."
msgstr "Vänta tills strömmen är stängd."

msgid ""
"Should be called after :meth:`close` to wait until the underlying connection "
"is closed, ensuring that all data has been flushed before e.g. exiting the "
"program."
msgstr ""
"Bör anropas efter :meth:`close` för att vänta tills den underliggande "
"anslutningen har stängts, vilket säkerställer att alla data har spolats "
"innan programmet avslutas."

msgid "Examples"
msgstr "Exempel"

msgid "TCP echo client using streams"
msgstr "TCP-ekoklient som använder strömmar"

msgid "TCP echo client using the :func:`asyncio.open_connection` function::"
msgstr ""
"TCP-ekoklient som använder funktionen :func:`asyncio.open_connection`::"

msgid ""
"The :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` example uses the low-level :meth:"
"`loop.create_connection` method."
msgstr ""
"I exemplet :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` används lågnivåmetoden :meth:"
"`loop.create_connection`."

msgid "TCP echo server using streams"
msgstr "TCP-ekoserver med hjälp av strömmar"

msgid "TCP echo server using the :func:`asyncio.start_server` function::"
msgstr "TCP-ekoserver med hjälp av funktionen :func:`asyncio.start_server`::"

msgid ""
"import asyncio\n"
"\n"
"async def handle_echo(reader, writer):\n"
"    data = await reader.read(100)\n"
"    message = data.decode()\n"
"    addr = writer.get_extra_info('peername')\n"
"\n"
"    print(f\"Received {message!r} from {addr!r}\")\n"
"\n"
"    print(f\"Send: {message!r}\")\n"
"    writer.write(data)\n"
"    await writer.drain()\n"
"\n"
"    print(\"Close the connection\")\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"async def main():\n"
"    server = await asyncio.start_server(\n"
"        handle_echo, '127.0.0.1', 8888)\n"
"\n"
"    addrs = ', '.join(str(sock.getsockname()) for sock in server.sockets)\n"
"    print(f'Serving on {addrs}')\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def handle_echo(reader, writer):\n"
"    data = await reader.read(100)\n"
"    message = data.decode()\n"
"    addr = writer.get_extra_info('peername')\n"
"\n"
"    print(f\"Received {message!r} from {addr!r}\")\n"
"\n"
"    print(f\"Send: {message!r}\")\n"
"    writer.write(data)\n"
"    await writer.drain()\n"
"\n"
"    print(\"Close the connection\")\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"async def main():\n"
"    server = await asyncio.start_server(\n"
"        handle_echo, '127.0.0.1', 8888)\n"
"\n"
"    addrs = ', '.join(str(sock.getsockname()) for sock in server.sockets)\n"
"    print(f'Serving on {addrs}')\n"
"\n"
"    async with server:\n"
"        await server.serve_forever()\n"
"\n"
"asyncio.run(main())"

msgid ""
"The :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` example uses the :meth:`loop."
"create_server` method."
msgstr ""
"I exemplet :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` används metoden :meth:`loop."
"create_server`."

msgid "Get HTTP headers"
msgstr "Hämta HTTP-rubriker"

msgid ""
"Simple example querying HTTP headers of the URL passed on the command line::"
msgstr ""
"Enkelt exempel på en fråga om HTTP-rubriker för den URL som skickas på "
"kommandoraden::"

msgid ""
"import asyncio\n"
"import urllib.parse\n"
"import sys\n"
"\n"
"async def print_http_headers(url):\n"
"    url = urllib.parse.urlsplit(url)\n"
"    if url.scheme == 'https':\n"
"        reader, writer = await asyncio.open_connection(\n"
"            url.hostname, 443, ssl=True)\n"
"    else:\n"
"        reader, writer = await asyncio.open_connection(\n"
"            url.hostname, 80)\n"
"\n"
"    query = (\n"
"        f\"HEAD {url.path or '/'} HTTP/1.0\\r\\n\"\n"
"        f\"Host: {url.hostname}\\r\\n\"\n"
"        f\"\\r\\n\"\n"
"    )\n"
"\n"
"    writer.write(query.encode('latin-1'))\n"
"    while True:\n"
"        line = await reader.readline()\n"
"        if not line:\n"
"            break\n"
"\n"
"        line = line.decode('latin1').rstrip()\n"
"        if line:\n"
"            print(f'HTTP header> {line}')\n"
"\n"
"    # Ignore the body, close the socket\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"url = sys.argv[1]\n"
"asyncio.run(print_http_headers(url))"
msgstr ""
"import asyncio\n"
"import urllib.parse\n"
"import sys\n"
"\n"
"async def print_http_headers(url):\n"
"    url = urllib.parse.urlsplit(url)\n"
"    if url.scheme == 'https':\n"
"        reader, writer = await asyncio.open_connection(\n"
"            url.hostname, 443, ssl=True)\n"
"    else:\n"
"        reader, writer = await asyncio.open_connection(\n"
"            url.hostname, 80)\n"
"\n"
"    query = (\n"
"        f\"HEAD {url.path or '/'} HTTP/1.0\\r\\n\"\n"
"        f\"Host: {url.hostname}\\r\\n\"\n"
"        f\"\\r\\n\"\n"
"    )\n"
"\n"
"    writer.write(query.encode('latin-1'))\n"
"    while True:\n"
"        line = await reader.readline()\n"
"        if not line:\n"
"            break\n"
"\n"
"        line = line.decode('latin1').rstrip()\n"
"        if line:\n"
"            print(f'HTTP header> {line}')\n"
"\n"
"    # Ignore the body, close the socket\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"url = sys.argv[1]\n"
"asyncio.run(print_http_headers(url))"

msgid "Usage::"
msgstr "Användning::"

msgid "python example.py http://example.com/path/page.html"
msgstr "python example.py http://example.com/path/page.html"

msgid "or with HTTPS::"
msgstr "eller med HTTPS::"

msgid "python example.py https://example.com/path/page.html"
msgstr "python example.py https://example.com/path/page.html"

msgid "Register an open socket to wait for data using streams"
msgstr "Registrera ett öppet uttag för att vänta på data med hjälp av strömmar"

msgid ""
"Coroutine waiting until a socket receives data using the :func:"
"`open_connection` function::"
msgstr ""
"Coroutine som väntar tills ett uttag tar emot data med hjälp av funktionen :"
"func:`open_connection`::"

msgid ""
"import asyncio\n"
"import socket\n"
"\n"
"async def wait_for_data():\n"
"    # Get a reference to the current event loop because\n"
"    # we want to access low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a pair of connected sockets.\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the open socket to wait for data.\n"
"    reader, writer = await asyncio.open_connection(sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    # Wait for data\n"
"    data = await reader.read(100)\n"
"\n"
"    # Got data, we are done: close the socket\n"
"    print(\"Received:\", data.decode())\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"    # Close the second socket\n"
"    wsock.close()\n"
"\n"
"asyncio.run(wait_for_data())"
msgstr ""
"import asyncio\n"
"import socket\n"
"\n"
"async def wait_for_data():\n"
"    # Get a reference to the current event loop because\n"
"    # we want to access low-level APIs.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a pair of connected sockets.\n"
"    rsock, wsock = socket.socketpair()\n"
"\n"
"    # Register the open socket to wait for data.\n"
"    reader, writer = await asyncio.open_connection(sock=rsock)\n"
"\n"
"    # Simulate the reception of data from the network\n"
"    loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"    # Wait for data\n"
"    data = await reader.read(100)\n"
"\n"
"    # Got data, we are done: close the socket\n"
"    print(\"Received:\", data.decode())\n"
"    writer.close()\n"
"    await writer.wait_closed()\n"
"\n"
"    # Close the second socket\n"
"    wsock.close()\n"
"\n"
"asyncio.run(wait_for_data())"

msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` example uses a low-level protocol and "
"the :meth:`loop.create_connection` method."
msgstr ""
"Exemplet :ref:`registrera ett öppet uttag för att vänta på data med hjälp av "
"ett protokoll <asyncio_example_create_connection>` använder ett protokoll på "
"låg nivå och metoden :meth:`loop.create_connection`."

msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to watch a file descriptor."
msgstr ""
"I exemplet :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` används lågnivåmetoden :meth:`loop.add_reader` "
"för att bevaka en filbeskrivare."
