# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Expressions"
msgstr "Uttryck"

msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "I detta kapitel förklaras betydelsen av elementen i uttryck i Python."

msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**I detta och de följande kapitlen används utökad BNF-notation för att "
"beskriva syntax, inte lexikal analys.  När (ett alternativ till) en "
"syntaxregel har formen"

msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"och ingen semantik anges, är semantiken för denna form av ``name`` densamma "
"som för ``othername``."

msgid "Arithmetic conversions"
msgstr "Aritmetiska omvandlingar"

msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common real type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""
"När en beskrivning av en aritmetisk operator nedan använder frasen \"de "
"numeriska argumenten konverteras till en gemensam reell typ\", betyder det "
"att operatorns implementering för inbyggda typer fungerar på följande sätt:"

msgid "If both arguments are complex numbers, no conversion is performed;"
msgstr "Om båda argumenten är komplexa tal utförs ingen konvertering;"

msgid ""
"if either argument is a complex or a floating-point number, the other is "
"converted to a floating-point number;"
msgstr ""
"om något av argumenten är ett komplext tal eller ett flyttal, konverteras "
"det andra till ett flyttal;"

msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "i annat fall måste båda vara heltal och ingen konvertering behövs."

msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"Vissa ytterligare regler gäller för vissa operatorer (t.ex. en sträng som "
"vänster argument till operatorn '%').  Tillägg måste definiera sitt eget "
"konverteringsbeteende."

msgid "Atoms"
msgstr "Atomer"

msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Atomer är de mest grundläggande elementen i uttryck.  De enklaste atomerna "
"är identifierare eller literaler.  Former inom parenteser, hakparenteser "
"eller parenteser kategoriseras också syntaktiskt som atomer.  Syntaxen för "
"atomer är:"

msgid "Identifiers (Names)"
msgstr "Identifierare (namn)"

msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"En identifierare som förekommer som en atom är ett namn.  Se avsnitt :ref:"
"`identifiers` för lexikal definition och avsnitt :ref:`naming` för "
"dokumentation av namngivning och bindning."

msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"När namnet är bundet till ett objekt, ger utvärderingen av atomen det "
"objektet. När ett namn inte är bundet, ger ett försök att utvärdera det "
"upphov till ett :exc:`NameError` undantag."

msgid "Private name mangling"
msgstr "Mangling av privata namn"

msgid ""
"When an identifier that textually occurs in a class definition begins with "
"two or more underscore characters and does not end in two or more "
"underscores, it is considered a :dfn:`private name` of that class."
msgstr ""
"När en identifierare som förekommer textuellt i en klassdefinition börjar "
"med två eller flera understreck och inte slutar med två eller flera "
"understreck, anses den vara ett :dfn:`privat namn` för den klassen."

msgid "The :ref:`class specifications <class>`."
msgstr "Den :ref:`klassspecifikationer <class>`."

msgid ""
"More precisely, private names are transformed to a longer form before code "
"is generated for them.  If the transformed name is longer than 255 "
"characters, implementation-defined truncation may happen."
msgstr ""
"Närmare bestämt omvandlas privata namn till en längre form innan kod "
"genereras för dem.  Om det transformerade namnet är längre än 255 tecken kan "
"en implementationsdefinierad trunkering ske."

msgid ""
"The transformation is independent of the syntactical context in which the "
"identifier is used but only the following private identifiers are mangled:"
msgstr ""
"Omvandlingen är oberoende av det syntaktiska sammanhang i vilket "
"identifieraren används, men endast följande privata identifierare manglas:"

msgid ""
"Any name used as the name of a variable that is assigned or read or any name "
"of an attribute being accessed."
msgstr ""
"Varje namn som används som namn på en variabel som tilldelas eller läses "
"eller varje namn på ett attribut som nås."

msgid ""
"The :attr:`~definition.__name__` attribute of nested functions, classes, and "
"type aliases is however not mangled."
msgstr ""
"Attributet :attr:`~definition.__name__` för nästlade funktioner, klasser och "
"typaliaser manglas dock inte."

msgid ""
"The name of imported modules, e.g., ``__spam`` in ``import __spam``. If the "
"module is part of a package (i.e., its name contains a dot), the name is "
"*not* mangled, e.g., the ``__foo`` in ``import __foo.bar`` is not mangled."
msgstr ""
"Namnet på importerade moduler, t.ex. ``__spam`` i ``import __spam``. Om "
"modulen är en del av ett paket (dvs. dess namn innehåller en punkt), manglas "
"namnet *inte*, t.ex. manglas inte ``__foo`` i ``import __foo.bar``."

msgid ""
"The name of an imported member, e.g., ``__f`` in ``from spam import __f``."
msgstr ""
"Namnet på en importerad medlem, t.ex. ``__f`` i ``from spam import __f``."

msgid "The transformation rule is defined as follows:"
msgstr "Transformationsregeln definieras enligt följande:"

msgid ""
"The class name, with leading underscores removed and a single leading "
"underscore inserted, is inserted in front of the identifier, e.g., the "
"identifier ``__spam`` occurring in a class named ``Foo``, ``_Foo`` or "
"``__Foo`` is transformed to ``_Foo__spam``."
msgstr ""
"Klassnamnet, med inledande understrykningar borttagna och en enda inledande "
"understrykning införd, infogas framför identifieraren, t.ex. identifieraren "
"``__spam`` som förekommer i en klass med namnet ``Foo``, ``_Foo`` eller "
"``__Foo`` omvandlas till ``_Foo__spam``."

msgid ""
"If the class name consists only of underscores, the transformation is the "
"identity, e.g., the identifier ``__spam`` occurring in a class named ``_`` "
"or ``__`` is left as is."
msgstr ""
"Om klassnamnet endast består av understreck är transformationen identiteten, "
"t.ex. identifieraren ``__spam`` som förekommer i en klass med namnet ``_`` "
"eller ``__`` lämnas oförändrad."

msgid "Literals"
msgstr "Bokstäver"

msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""
"Python stöder sträng- och byteslitteraler samt olika numeriska litteraler:"

msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating-point number, complex number) with the given value.  The "
"value may be approximated in the case of floating-point and imaginary "
"(complex) literals. See section :ref:`literals` for details. See section :"
"ref:`string-concatenation` for details on ``strings``."
msgstr ""
"Utvärdering av en literal ger ett objekt av den angivna typen (sträng, "
"bytes, heltal, flyttal, komplext tal) med det angivna värdet.  Värdet kan "
"approximeras när det gäller flyttal och imaginära (komplexa) literaler. Se "
"avsnitt :ref:`literals` för detaljer. Se avsnitt :ref:`string-concatenation` "
"för detaljer om ``strängar``."

msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Alla literaler motsvarar oföränderliga datatyper, och därför är objektets "
"identitet mindre viktig än dess värde.  Flera utvärderingar av litteraler "
"med samma värde (antingen samma förekomst i programtexten eller en annan "
"förekomst) kan ge samma objekt eller ett annat objekt med samma värde."

msgid "String literal concatenation"
msgstr "Sammankoppling av strängbokstäver"

msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation::"
msgstr ""
"Flera intilliggande sträng- eller byte-litteraler (avgränsade av blanksteg), "
"eventuellt med olika citatkonventioner, är tillåtna och deras betydelse är "
"densamma som deras sammankoppling::"

msgid ""
">>> \"hello\" 'world'\n"
"\"helloworld\""
msgstr ""
">>> \"hej\" \"värld\n"
"\"helloworld\""

msgid "Formally:"
msgstr "Formellt sett:"

msgid ""
"This feature is defined at the syntactical level, so it only works with "
"literals. To concatenate string expressions at run time, the '+' operator "
"may be used::"
msgstr ""
"Den här funktionen definieras på syntaktisk nivå, så den fungerar bara med "
"bokstavstecken. För att konkatenera stränguttryck i körtid kan operatorn '+' "
"användas::"

msgid ""
">>> greeting = \"Hello\"\n"
">>> space = \" \"\n"
">>> name = \"Blaise\"\n"
">>> print(greeting + space + name)   # not: print(greeting space name)\n"
"Hello Blaise"
msgstr ""
">>> hälsning = \"Hej\"\n"
">>> mellanslag = \" \"\n"
">>> namn = \"Blaise\"\n"
">>> print(hälsning + mellanslag + namn) # not: print(hälsning mellanslag "
"namn)\n"
"Hej Blaise"

msgid ""
"Literal concatenation can freely mix raw strings, triple-quoted strings, and "
"formatted string literals. For example::"
msgstr ""
"Litteral konkatenering kan fritt blanda råa strängar, strängar med "
"trippelcitat och formaterade stränglitteraler. Till exempel::"

msgid ""
">>> \"Hello\" r', ' f\"{name}!\"\n"
"\"Hello, Blaise!\""
msgstr ""
">>> \"Hej\" r', ' f\"{name}!\"\n"
"\"Hej, Blaise!\""

msgid ""
"This feature can be used to reduce the number of backslashes needed, to "
"split long strings conveniently across long lines, or even to add comments "
"to parts of strings. For example::"
msgstr ""
"Denna funktion kan användas för att minska antalet backslash som behövs, för "
"att dela upp långa strängar på ett bekvämt sätt över långa rader eller till "
"och med för att lägga till kommentarer till delar av strängar. Till exempel::"

msgid ""
"re.compile(\"[A-Za-z_]\"       # letter or underscore\n"
"           \"[A-Za-z0-9_]*\"   # letter, digit or underscore\n"
"          )"
msgstr ""
"re.compile(\"[A-Za-z_]\"       # bokstav eller understreck\n"
"           \"[A-Za-z0-9_]*\"   # bokstav, siffra eller understreck\n"
"          )"

msgid ""
"However, bytes literals may only be combined with other byte literals; not "
"with string literals of any kind. Also, template string literals may only be "
"combined with other template string literals::"
msgstr ""
"Byte-litteraler får dock endast kombineras med andra byte-litteraler, inte "
"med sträng-litteraler av något slag. Dessutom får mallsträngsliteraler "
"endast kombineras med andra mallsträngsliteraler::"

msgid ""
">>> t\"Hello\" t\"{name}!\"\n"
"Template(strings=('Hello', '!'), interpolations=(...))"
msgstr ""
">>> t\"Hej\" t\"{name}!\"\n"
"Template(strängar=('Hello', '!'), interpolationer=(...))"

msgid "Parenthesized forms"
msgstr "Formulär inom parentes"

msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "En parentesform är en lista med valfria uttryck inom parentes:"

msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"En uttrycksförteckning med parenteser ger det som uttrycksförteckningen ger: "
"om förteckningen innehåller minst ett kommatecken ger den en tupel, annars "
"ger den det enskilda uttryck som utgör uttrycksförteckningen."

msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"Ett tomt par parenteser ger ett tomt tupelobjekt.  Eftersom tuplar är "
"oföränderliga gäller samma regler som för literals (dvs. två förekomster av "
"den tomma tupeln kan ge eller inte ge samma objekt)."

msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma.  The exception is the empty tuple, for which parentheses *are* "
"required --- allowing unparenthesized \"nothing\" in expressions would cause "
"ambiguities and allow common typos to pass uncaught."
msgstr ""
"Observera att tupler inte bildas av parenteserna, utan snarare genom att "
"använda kommatecken.  Undantaget är den tomma tupeln, för vilken parenteser "
"*krävs* --- att tillåta \"ingenting\" utan parenteser i uttryck skulle "
"orsaka tvetydigheter och tillåta vanliga typfel att passera utan att "
"upptäckas."

msgid "Displays for lists, sets and dictionaries"
msgstr "Displayer för listor, uppsättningar och ordböcker"

msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"För att konstruera en lista, en uppsättning eller en ordbok tillhandahåller "
"Python en speciell syntax som kallas \"displays\", var och en av dem i två "
"varianter:"

msgid "either the container contents are listed explicitly, or"
msgstr "antingen anges innehållet i behållaren uttryckligen, eller"

msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"de beräknas via en uppsättning loopnings- och filtreringsinstruktioner, "
"kallad en :dfn:`comprehension`."

msgid "Common syntax elements for comprehensions are:"
msgstr "Vanliga syntaxelement för förståelser är:"

msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"Förståelsen består av ett enda uttryck följt av minst en :keyword:`!for`-"
"klausul och noll eller fler :keyword:`!for`- eller :keyword:`!if`-klausuler. "
"I detta fall är elementen i den nya behållaren de som skulle produceras "
"genom att betrakta var och en av :keyword:`!for`- eller :keyword:`!if`-"
"klausulerna som ett block, nestning från vänster till höger och utvärdering "
"av uttrycket för att producera ett element varje gång det innersta blocket "
"nås."

msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"Bortsett från det iterabla uttrycket i :keyword:`!for`-satsen längst till "
"vänster utförs dock förståelsen i ett separat implicit nästlat scope. Detta "
"säkerställer att namn som tilldelats i mållistan inte \"läcker\" in i det "
"omslutande scopet."

msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"Det iterabla uttrycket i :keyword:`!for`-satsen längst till vänster "
"utvärderas direkt i det inneslutande scopet och skickas sedan som ett "
"argument till det implicit nästlade scopet. Efterföljande :keyword:`!for`-"
"satser och eventuella filtervillkor i :keyword:`!for`-satsen längst till "
"vänster kan inte utvärderas i det inneslutande scopet eftersom de kan vara "
"beroende av de värden som erhålls från iterabeln längst till vänster. Till "
"exempel: ``[x*y for x in range(10) for y in range(x, x+10)]``."

msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr ""
"För att säkerställa att förståelsen alltid resulterar i en container av rätt "
"typ, är uttrycken ``yield`` och ``yield from`` förbjudna i det implicit "
"nästlade omfånget."

msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions."
msgstr ""
"Sedan Python 3.6, i en :keyword:`async def`-funktion, kan en :keyword:`!"
"async for`-sats användas för att iterera över en :term:`asynkron iterator`. "
"En förståelse i en :keyword:`!async def`-funktion kan bestå av antingen en :"
"keyword:`!for`- eller :keyword:`!async for`-klausul efter det ledande "
"uttrycket, kan innehålla ytterligare :keyword:`!for`- eller :keyword:`!async "
"for`-klausuler och kan även använda :keyword:`await`-uttryck."

msgid ""
"If a comprehension contains :keyword:`!async for` clauses, or if it "
"contains :keyword:`!await` expressions or other asynchronous comprehensions "
"anywhere except the iterable expression in the leftmost :keyword:`!for` "
"clause, it is called an :dfn:`asynchronous comprehension`. An asynchronous "
"comprehension may suspend the execution of the coroutine function in which "
"it appears. See also :pep:`530`."
msgstr ""
"Om en comprehension innehåller :keyword:`!async for`-klausuler, eller om den "
"innehåller :keyword:`!await`-uttryck eller andra asynkrona comprehensions "
"överallt utom det iterabla uttrycket i :keyword:`!for`-klausulen längst till "
"vänster, kallas den en :dfn:`asynchronous comprehension`. En asynkron "
"förståelse kan avbryta exekveringen av den coroutine-funktion där den "
"förekommer. Se även :pep:`530`."

msgid "Asynchronous comprehensions were introduced."
msgstr "Asynkrona förståelser introducerades."

msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr ""
"``yield`` och ``yield from`` förbjudna i det implicit nästlade omfånget."

msgid ""
"Asynchronous comprehensions are now allowed inside comprehensions in "
"asynchronous functions. Outer comprehensions implicitly become asynchronous."
msgstr ""
"Asynkrona förståelser är nu tillåtna inuti förståelser i asynkrona "
"funktioner. Yttre förståelser blir implicit asynkrona."

msgid "List displays"
msgstr "Lista visar"

msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"En listdisplay är en eventuellt tom serie av uttryck inom hakparenteser:"

msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"En listvisning resulterar i ett nytt listobjekt, vars innehåll specificeras "
"av antingen en lista med uttryck eller en förståelse.  När en kommaseparerad "
"lista med uttryck anges, utvärderas dess element från vänster till höger och "
"placeras i listobjektet i den ordningen.  När en förståelse anges "
"konstrueras listan av de element som blir resultatet av förståelsen."

msgid "Set displays"
msgstr "Ställ in skärmar"

msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"En set-display betecknas med hakparenteser och skiljer sig från en "
"dictionary-display genom att det inte finns några kolon som separerar "
"nycklar och värden:"

msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"En set-visning ger ett nytt muterbart set-objekt, vars innehåll specificeras "
"av antingen en sekvens av uttryck eller en förståelse.  När en "
"kommaseparerad lista med uttryck anges, utvärderas dess element från vänster "
"till höger och läggs till i set-objektet.  När en förståelse anges "
"konstrueras setet av de element som blir resultatet av förståelsen."

msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"En tom uppsättning kan inte konstrueras med ``{}``; denna bokstav "
"konstruerar en tom ordbok."

msgid "Dictionary displays"
msgstr "Ordbok visar"

msgid ""
"A dictionary display is a possibly empty series of dict items (key/value "
"pairs) enclosed in curly braces:"
msgstr ""
"En dictionary-display är en eventuellt tom serie av dict-objekt (nyckel/"
"värde-par) inneslutna inom hakparenteser:"

msgid "A dictionary display yields a new dictionary object."
msgstr "En ordboksvisning resulterar i ett nytt ordboksobjekt."

msgid ""
"If a comma-separated sequence of dict items is given, they are evaluated "
"from left to right to define the entries of the dictionary: each key object "
"is used as a key into the dictionary to store the corresponding value.  This "
"means that you can specify the same key multiple times in the dict item "
"list, and the final dictionary's value for that key will be the last one "
"given."
msgstr ""
"Om en kommaseparerad sekvens av dict-objekt anges utvärderas de från vänster "
"till höger för att definiera posterna i ordlistan: varje nyckelobjekt "
"används som en nyckel i ordlistan för att lagra motsvarande värde.  Det "
"innebär att du kan ange samma nyckel flera gånger i listan med dict-objekt, "
"och det slutliga värdet i ordboken för den nyckeln kommer att vara det "
"senast angivna."

msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier dict items "
"and earlier dictionary unpackings."
msgstr ""
"En dubbel asterisk ``**`` betecknar :dfn:`dictionary unpacking`. Dess "
"operand måste vara en :term:`mappning`.  Varje mappningsobjekt läggs till i "
"den nya ordboken.  Senare värden ersätter värden som redan ställts in av "
"tidigare dict-objekt och tidigare uppackningar av ordböcker."

msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""
"Unpacking into dictionary displays, ursprungligen föreslagen av :pep:`448`."

msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"En dict-förståelse, till skillnad från list- och set-förståelser, behöver "
"två uttryck åtskilda med ett kolon följt av de vanliga \"for\"- och \"if\"-"
"klausulerna. När förståelsen körs infogas de resulterande nyckel- och "
"värdeelementen i den nya ordlistan i den ordning de producerades."

msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last value (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"Restriktioner för typerna av nyckelvärden anges tidigare i avsnitt :ref:"
"`types`.  (Sammanfattningsvis bör nyckeltypen vara :term:`hashable`, vilket "
"utesluter alla föränderliga objekt)  Kollisioner mellan duplicerade nycklar "
"upptäcks inte; det sista värdet (textuellt längst till höger i displayen) "
"som lagras för ett visst nyckelvärde har företräde."

msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"Före Python 3.8 var utvärderingsordningen för nyckel och värde inte "
"väldefinierad i dict-comprehensions.  I CPython utvärderades värdet före "
"nyckeln.  Från och med 3.8 utvärderas nyckeln före värdet, enligt förslaget "
"i :pep:`572`."

msgid "Generator expressions"
msgstr "Generatoruttryck"

msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "Ett generatoruttryck är en kompakt generatornotation inom parentes:"

msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Ett generatoruttryck ger upphov till ett nytt generatorobjekt.  Syntaxen är "
"densamma som för förståelser, förutom att det omges av parenteser istället "
"för parenteser eller hakparenteser."

msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, and the :term:"
"`iterator` is immediately created for that iterable, so that an error "
"produced while creating the iterator will be emitted at the point where the "
"generator expression is defined, rather than at the point where the first "
"value is retrieved. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"Variabler som används i generatoruttrycket utvärderas latent när metoden :"
"meth:`~generator.__next__` anropas för generatorobjektet (på samma sätt som "
"för normala generatorer).  Det iterabla uttrycket i :keyword:`!for`-satsen "
"längst till vänster utvärderas dock omedelbart och :term:`iterator` skapas "
"omedelbart för den iterabla, så att ett fel som uppstår när iteratorn skapas "
"kommer att avges vid den punkt där generatoruttrycket definieras, snarare än "
"vid den punkt där det första värdet hämtas. Efterföljande :keyword:`!for`-"
"satser och eventuella filtervillkor i :keyword:`!for`-satsen längst till "
"vänster kan inte utvärderas i det omslutande området eftersom de kan vara "
"beroende av de värden som erhålls från iteratorn längst till vänster. Till "
"exempel: ``(x*y for x in range(10) for y in range(x, x+10))``."

msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""
"Parentesen kan utelämnas vid anrop med endast ett argument.  Se avsnitt :ref:"
"`calls` för detaljer."

msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr ""
"För att inte störa den förväntade funktionen hos själva generatoruttrycket "
"är uttrycken ``yield`` och ``yield from`` förbjudna i den implicit "
"definierade generatorn."

msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"Om ett generatoruttryck innehåller antingen :keyword:`!async for`-klausuler "
"eller :keyword:`await`-uttryck kallas det ett :dfn:`asynkront "
"generatoruttryck`.  Ett asynkront generatoruttryck returnerar ett nytt "
"asynkront generatorobjekt, som är en asynkron iterator (se :ref:`async-"
"iterators`)."

msgid "Asynchronous generator expressions were introduced."
msgstr "Asynkrona generatoruttryck infördes."

msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"Före Python 3.7 kunde asynkrona generatoruttryck endast förekomma i :keyword:"
"`async def` coroutines.  Från och med 3.7 kan alla funktioner använda "
"asynkrona generatoruttryck."

msgid "Yield expressions"
msgstr "Avkastningsuttryck"

msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator function, and using it in an :"
"keyword:`async def` function's body causes that coroutine function to be an "
"asynchronous generator function. For example::"
msgstr ""
"Yield-uttrycket används när man definierar en :term:`generator`-funktion "
"eller en :term:`asynkron generator`-funktion och kan därför bara användas i "
"en funktionsdefinition.  Om du använder ett yield-uttryck i en funktions "
"kropp blir funktionen en generatorfunktion och om du använder det i en :"
"keyword:`async def`-funktions kropp blir coroutine-funktionen en asynkron "
"generatorfunktion. Till exempel::"

msgid ""
"def gen():  # defines a generator function\n"
"    yield 123\n"
"\n"
"async def agen(): # defines an asynchronous generator function\n"
"    yield 123"
msgstr ""
"def gen():  # definierar en generatorfunktion\n"
"    avkastning 123\n"
"\n"
"async def agen(): # definierar en asynkron generatorfunktion\n"
"    yield 123"

msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr ""
"På grund av sina bieffekter på det innehållande omfånget är ``yield``-"
"uttryck inte tillåtna som en del av de implicit definierade omfång som "
"används för att implementera förståelser och generatoruttryck."

msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""
"Yield-uttryck som är förbjudna i de implicit nästlade scopes som används för "
"att implementera förståelser och generatoruttryck."

msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"Generatorfunktioner beskrivs nedan, medan asynkrona generatorfunktioner "
"beskrivs separat i avsnitt :ref:``asynchronous-generator-functions``."

msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function.  The execution starts when one of the generator's methods is "
"called. At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`~python-grammar:"
"yield_list` to the generator's caller, or ``None`` if :token:`~python-"
"grammar:yield_list` is omitted. By suspended, we mean that all local state "
"is retained, including the current bindings of local variables, the "
"instruction pointer, the internal evaluation stack, and the state of any "
"exception handling. When the execution is resumed by calling one of the "
"generator's methods, the function can proceed exactly as if the yield "
"expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~generator.__next__` is used (typically via either a :"
"keyword:`for` or the :func:`next` builtin) then the result is :const:"
"`None`.  Otherwise, if :meth:`~generator.send` is used, then the result will "
"be the value passed in to that method."
msgstr ""
"När en generatorfunktion anropas returnerar den en iterator, en så kallad "
"generator.  Denna generator styr sedan exekveringen av generatorfunktionen.  "
"Exekveringen startar när någon av generatorns metoder anropas. Vid den "
"tidpunkten fortsätter exekveringen till det första yield-uttrycket, där den "
"avbryts igen och returnerar värdet av :token:`~python-grammar:yield_list` "
"till generatorns anropare, eller ``None`` om :token:`~python-grammar:"
"yield_list` utelämnas. Med suspenderad menar vi att allt lokalt tillstånd "
"behålls, inklusive de aktuella bindningarna av lokala variabler, "
"instruktionspekaren, den interna utvärderingsstacken och tillståndet för "
"eventuell undantagshantering. När exekveringen återupptas genom att anropa "
"en av generatorns metoder kan funktionen fortsätta precis som om yield-"
"uttrycket bara var ett annat externt anrop.  Värdet på yield-uttrycket efter "
"återupptagandet beror på vilken metod som återupptog exekveringen.  Om :meth:"
"`~generator.__next__` används (typiskt via antingen ett :keyword:`for` "
"eller :func:`next` inbyggd) så är resultatet :const:`None`.  Annars, om :"
"meth:`~generator.send` används, blir resultatet det värde som skickas in "
"till den metoden."

msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"Allt detta gör generatorfunktioner ganska lika coroutines; de ger flera "
"gånger, de har mer än en ingångspunkt och deras exekvering kan avbrytas.  "
"Den enda skillnaden är att en generatorfunktion inte kan styra var "
"exekveringen ska fortsätta efter att den har gett upp; kontrollen överförs "
"alltid till generatorns anropare."

msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
"Yield-uttryck är tillåtna var som helst i en :keyword:`try`-konstruktion.  "
"Om generatorn inte återupptas innan den är avslutad (genom att "
"referensantalet blir noll eller genom att den samlas in), kommer generator-"
"iteratorns :meth:`~generator.close`-metod att anropas, vilket gör att alla "
"väntande :keyword:`finally`-klausuler kan utföras."

msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed directly "
"to the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"När ``yield from <expr>`` används måste det medföljande uttrycket vara en "
"iterabel. De värden som produceras genom att iterera denna iterabel skickas "
"direkt till den som anropar den aktuella generatorns metoder. Alla värden "
"som skickas in med :meth:`~generator.send` och alla undantag som skickas in "
"med :meth:`~generator.throw` skickas till den underliggande iteratorn om den "
"har lämpliga metoder.  Om så inte är fallet kommer :meth:`~generator.send` "
"att ge upphov till :exc:`AttributeError` eller :exc:`TypeError`, medan :meth:"
"`~generator.throw` bara kommer att ge upphov till det undantag som skickats "
"in omedelbart."

msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"När den underliggande iteratorn är klar blir attributet :attr:"
"`~StopIteration.value` i den upphöjda :exc:`StopIteration`-instansen värdet "
"på yield-uttrycket. Det kan antingen sättas explicit när :exc:"
"`StopIteration` väcks, eller automatiskt när subiteratorn är en generator "
"(genom att returnera ett värde från subgeneratorn)."

msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""
"Lagt till ``yield from <expr>`` för att delegera kontrollflödet till en "
"subiterator."

msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""
"Parenteserna kan utelämnas när yield-uttrycket är det enda uttrycket på "
"höger sida av en assignment-sats."

msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Enkla generatorer"

msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""
"Förslaget att lägga till generatorer och :keyword:`yield`-satsen i Python."

msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - Coroutines via förbättrade generatorer"

msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"Förslaget att förbättra API:et och syntaxen för generatorer, så att de kan "
"användas som enkla coroutines."

msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - Syntax för att delegera till en undergenerator"

msgid ""
"The proposal to introduce the :token:`~python-grammar:yield_from` syntax, "
"making delegation to subgenerators easy."
msgstr ""
"Förslaget att införa syntaxen :token:`~python-grammar:yield_from`, vilket "
"gör det enkelt att delegera till undergenererare."

msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` - Asynkrona generatorer"

msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr ""
"Förslaget som utökade :pep:`492` genom att lägga till generatormöjligheter "
"till coroutine-funktioner."

msgid "Generator-iterator methods"
msgstr "Generator-iterator-metoder"

msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"I detta underavsnitt beskrivs metoderna för en generatoriterator.  De kan "
"användas för att styra utförandet av en generatorfunktion."

msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Observera att anrop av någon av generatormetoderna nedan när generatorn "
"redan körs ger upphov till ett :exc:`ValueError`-undantag."

msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`~python-grammar:yield_list` is returned to :meth:`__next__`'s "
"caller.  If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""
"Startar exekveringen av en generatorfunktion eller återupptar den vid det "
"senast exekverade yield-uttrycket.  När en generatorfunktion återupptas med "
"en :meth:`~generator.__next__`-metod utvärderas det aktuella yield-uttrycket "
"alltid till :const:`None`.  Exekveringen fortsätter sedan till nästa yield-"
"uttryck, där generatorn avbryts igen och värdet i :token:`~python-grammar:"
"yield_list` returneras till :meth:`__next__`:s anropare.  Om generatorn "
"avslutas utan att ge något annat värde, uppstår ett :exc:`StopIteration`-"
"undantag."

msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""
"Denna metod anropas normalt implicit, t.ex. av en :keyword:`for`-loop, eller "
"av den inbyggda :func:`next`-funktionen."

msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"Återupptar exekveringen och \"skickar\" ett värde till generatorfunktionen.  "
"Argumentet *value* blir resultatet av det aktuella yield-uttrycket.  "
"Metoden :meth:`send` returnerar nästa värde som generatorn ger, eller ger "
"upphov till :exc:`StopIteration` om generatorn avslutas utan att ge något "
"annat värde.  När :meth:`send` anropas för att starta generatorn måste den "
"anropas med :const:`None` som argument, eftersom det inte finns något yield-"
"uttryck som kan ta emot värdet."

msgid ""
"Raises an exception at the point where the generator was paused, and returns "
"the next value yielded by the generator function.  If the generator exits "
"without yielding another value, a :exc:`StopIteration` exception is raised.  "
"If the generator function does not catch the passed-in exception, or raises "
"a different exception, then that exception propagates to the caller."
msgstr ""
"Utlöser ett undantag vid den punkt där generatorn pausades och returnerar "
"nästa värde som generatorns funktion ger.  Om generatorn avslutas utan att "
"ge något annat värde, utlöses ett :exc:`StopIteration`-undantag.  Om "
"generatorfunktionen inte fångar upp det överlämnade undantaget, eller om ett "
"annat undantag uppstår, sprids undantaget till den som anropar."

msgid ""
"In typical use, this is called with a single exception instance similar to "
"the way the :keyword:`raise` keyword is used."
msgstr ""
"I normal användning anropas detta med en enda undantagsinstans på liknande "
"sätt som nyckelordet :keyword:`raise` används."

msgid ""
"For backwards compatibility, however, the second signature is supported, "
"following a convention from older versions of Python. The *type* argument "
"should be an exception class, and *value* should be an exception instance. "
"If the *value* is not provided, the *type* constructor is called to get an "
"instance. If *traceback* is provided, it is set on the exception, otherwise "
"any existing :attr:`~BaseException.__traceback__` attribute stored in "
"*value* may be cleared."
msgstr ""
"För bakåtkompatibilitet stöds dock den andra signaturen, enligt en "
"konvention från äldre versioner av Python. Argumentet *type* ska vara en "
"undantagsklass och *value* ska vara en undantagsinstans. Om *value* inte "
"anges anropas konstruktören *type* för att hämta en instans. Om *traceback* "
"anges, sätts det på undantaget, annars kan alla befintliga :attr:"
"`~BaseException.__traceback__`-attribut som lagras i *value* rensas."

msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""
"Den andra signaturen \\(type\\[, value\\[, traceback\\]\\]\\ \\) är "
"föråldrad och kan tas bort i en framtida version av Python."

msgid ""
"Raises a :exc:`GeneratorExit` exception at the point where the generator "
"function was paused (equivalent to calling ``throw(GeneratorExit)``). The "
"exception is raised by the yield expression where the generator was paused. "
"If the generator function catches the exception and returns a value, this "
"value is returned from :meth:`close`.  If the generator function is already "
"closed, or raises :exc:`GeneratorExit` (by not catching the exception), :"
"meth:`close` returns :const:`None`.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  If the generator has already exited due to an "
"exception or normal exit, :meth:`close` returns :const:`None` and has no "
"other effect."
msgstr ""
"Utlöser ett :exc:`GeneratorExit`-undantag vid den punkt där "
"generatorfunktionen pausades (motsvarar anropet ``throw(GeneratorExit)``). "
"Undantaget utlöses av det yield-uttryck där generatorn pausades. Om "
"generatorfunktionen fångar upp undantaget och returnerar ett värde, "
"returneras detta värde från :meth:`close`.  Om generatorfunktionen redan är "
"stängd, eller ger upphov till :exc:`GeneratorExit` (genom att inte fånga upp "
"undantaget), returnerar :meth:`close` :const:`None`.  Om generatorn ger ett "
"värde, uppstår ett :exc:`RuntimeError`.  Om generatorn ger upphov till något "
"annat undantag sprids det till den som anropar.  Om generatorn redan har "
"avslutats på grund av ett undantag eller en normal avslutning, returnerar :"
"meth:`close` :const:`None` och har ingen annan effekt."

msgid ""
"If a generator returns a value upon being closed, the value is returned by :"
"meth:`close`."
msgstr ""
"Om en generator returnerar ett värde när den stängs, returneras värdet av :"
"meth:`close`."

msgid "Examples"
msgstr "Exempel"

msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Här följer ett enkelt exempel som visar hur generatorer och "
"generatorfunktioner fungerar::"

msgid ""
">>> def echo(value=None):\n"
"...     print(\"Execution starts when 'next()' is called for the first time."
"\")\n"
"...     try:\n"
"...         while True:\n"
"...             try:\n"
"...                 value = (yield value)\n"
"...             except Exception as e:\n"
"...                 value = e\n"
"...     finally:\n"
"...         print(\"Don't forget to clean up when 'close()' is called.\")\n"
"...\n"
">>> generator = echo(1)\n"
">>> print(next(generator))\n"
"Execution starts when 'next()' is called for the first time.\n"
"1\n"
">>> print(next(generator))\n"
"None\n"
">>> print(generator.send(2))\n"
"2\n"
">>> generator.throw(TypeError, \"spam\")\n"
"TypeError('spam',)\n"
">>> generator.close()\n"
"Don't forget to clean up when 'close()' is called."
msgstr ""
">>> def echo(värde=None):\n"
"... print(\"Exekveringen startar när 'next()' anropas för första gången.\")\n"
"... försök:\n"
"... while True:\n"
"... försök:\n"
"... värde = (ge värde)\n"
"... utom Exception som e:\n"
"... värde = e\n"
"... slutligen:\n"
"... print(\"Glöm inte att städa upp när 'close()' anropas.\")\n"
"...\n"
">>> generator = echo(1)\n"
">>> print(nästa(generator))\n"
"Exekveringen startar när 'next()' anropas för första gången.\n"
"1\n"
">>> print(nästa(generator))\n"
"Ingen\n"
">>> print(generator.skicka(2))\n"
"2\n"
">>> generator.throw(TypeError, \"spam\")\n"
"TypeError('skräppost',)\n"
">>> generator.close()\n"
"Glöm inte att städa upp när 'close()' anropas."

msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"För exempel på användning av ``yield from``, se :ref:`pep-380` i \"What's "
"New in Python\""

msgid "Asynchronous generator functions"
msgstr "Asynkrongeneratorfunktioner"

msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"Närvaron av ett yield-uttryck i en funktion eller metod som definieras med :"
"keyword:`async def` definierar funktionen ytterligare som en :term:`asynkron "
"generator`-funktion."

msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"När en asynkron generatorfunktion anropas returnerar den en asynkron "
"iterator, ett så kallat asynkront generatorobjekt. Det objektet styr sedan "
"exekveringen av generatorfunktionen. Ett asynkront generatorobjekt används "
"vanligtvis i en :keyword:`async for`-sats i en coroutine-funktion på samma "
"sätt som ett generatorobjekt skulle användas i en :keyword:`for`-sats."

msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`~python-grammar:"
"yield_list` to the awaiting coroutine. As with a generator, suspension means "
"that all local state is retained, including the current bindings of local "
"variables, the instruction pointer, the internal evaluation stack, and the "
"state of any exception handling. When the execution is resumed by awaiting "
"on the next object returned by the asynchronous generator's methods, the "
"function can proceed exactly as if the yield expression were just another "
"external call. The value of the yield expression after resuming depends on "
"the method which resumed the execution.  If :meth:`~agen.__anext__` is used "
"then the result is :const:`None`. Otherwise, if :meth:`~agen.asend` is used, "
"then the result will be the value passed in to that method."
msgstr ""
"Anrop av en av den asynkrona generatorns metoder returnerar ett :term:"
"`awaitable`-objekt, och exekveringen startar när detta objekt är väntat på. "
"Vid den tidpunkten fortsätter exekveringen till det första yield-uttrycket, "
"där den avbryts igen och returnerar värdet av :token:`~python-grammar:"
"yield_list` till den väntande coroutinen. Precis som med en generator "
"innebär avbrytandet att allt lokalt tillstånd bibehålls, inklusive de lokala "
"variablernas aktuella bindningar, instruktionspekaren, den interna "
"utvärderingsstapeln och tillståndet för eventuell undantagshantering. När "
"exekveringen återupptas genom att vänta på nästa objekt som returneras av "
"den asynkrona generatorns metoder, kan funktionen fortsätta precis som om "
"yield-uttrycket bara var ett annat externt anrop. Värdet på yield-uttrycket "
"efter återupptagandet beror på vilken metod som återupptog exekveringen.  "
"Om :meth:`~agen.__anext__` används så är resultatet :const:`None`. I annat "
"fall, om :meth:`~agen.asend` används, blir resultatet det värde som "
"skickades in till den metoden."

msgid ""
"If an asynchronous generator happens to exit early by :keyword:`break`, the "
"caller task being cancelled, or other exceptions, the generator's async "
"cleanup code will run and possibly raise exceptions or access context "
"variables in an unexpected context--perhaps after the lifetime of tasks it "
"depends, or during the event loop shutdown when the async-generator garbage "
"collection hook is called. To prevent this, the caller must explicitly close "
"the async generator by calling :meth:`~agen.aclose` method to finalize the "
"generator and ultimately detach it from the event loop."
msgstr ""
"Om en asynkron generator avslutas tidigt genom :keyword:`break`, att den "
"anropande uppgiften avbryts eller andra undantag, kommer generatorns "
"asynkrona uppstädningskod att köras och eventuellt ge upphov till undantag "
"eller åtkomst till kontextvariabler i ett oväntat sammanhang - kanske efter "
"livstiden för de uppgifter den är beroende av, eller under nedstängningen av "
"händelseslingan när async-generatorens garbage collection hook anropas. För "
"att förhindra detta måste anroparen uttryckligen stänga async-generatorn "
"genom att anropa :meth:`~agen.aclose`-metoden för att slutföra generatorn "
"och slutligen koppla bort den från händelseslingan."

msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"I en asynkron generatorfunktion är yield-uttryck tillåtna var som helst i "
"en :keyword:`try`-konstruktion. Men om en asynkron generator inte återupptas "
"innan den avslutas (genom att referensantalet blir noll eller genom att den "
"samlas in i en s.k. garbage collection), kan ett yield-uttryck i en :keyword:"
"`!try`-konstruktion leda till att väntande :keyword:`finally`-klausuler inte "
"kan exekveras.  I detta fall är det ansvaret för den händelseslinga eller "
"schemaläggare som kör den asynkrona generatorn att anropa den asynkrona "
"generator-iteratorns :meth:`~agen.aclose`-metod och köra det resulterande "
"coroutine-objektet, så att eventuella väntande :keyword:`!finally`-klausuler "
"kan exekveras."

msgid ""
"To take care of finalization upon event loop termination, an event loop "
"should define a *finalizer* function which takes an asynchronous generator-"
"iterator and presumably calls :meth:`~agen.aclose` and executes the "
"coroutine. This  *finalizer* may be registered by calling :func:`sys."
"set_asyncgen_hooks`. When first iterated over, an asynchronous generator-"
"iterator will store the registered *finalizer* to be called upon "
"finalization. For a reference example of a *finalizer* method see the "
"implementation of ``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/"
"asyncio/base_events.py`."
msgstr ""
"För att ta hand om avslutning vid avslutning av en händelseslinga bör en "
"händelseslinga definiera en *finalizer*-funktion som tar en asynkron "
"generator-iterator och förmodligen anropar :meth:`~agen.aclose` och kör "
"coroutinen. Denna *finalizer* kan registreras genom att anropa :func:`sys."
"set_asyncgen_hooks`. Vid första iterationen över en asynkron generator-"
"iterator lagras den registrerade *finalizer* som anropas vid slutförande. "
"För ett referensexempel på en *finalizer*-metod se implementeringen av "
"``asyncio.Loop.shutdown_asyncgens`` i :source:`Lib/asyncio/base_events.py`."

msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""
"Uttrycket ``yield from <expr>`` är ett syntaxfel när det används i en "
"asynkron generatorfunktion."

msgid "Asynchronous generator-iterator methods"
msgstr "Asynkrona generator-iterator-metoder"

msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr ""
"I detta underavsnitt beskrivs metoderna för en asynkron generatoriterator, "
"som används för att styra exekveringen av en generatorfunktion."

msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`~python-grammar:yield_list` of the "
"yield expression is the value of the :exc:`StopIteration` exception raised "
"by the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises a :exc:"
"`StopAsyncIteration` exception, signalling that the asynchronous iteration "
"has completed."
msgstr ""
"Returnerar en awaitable som när den körs börjar exekvera den asynkrona "
"generatorn eller återupptar den vid det senast exekverade yield-uttrycket.  "
"När en asynkron generatorfunktion återupptas med en :meth:`~agen.__anext__`-"
"metod utvärderas det aktuella yield-uttrycket alltid till :const:`None` i "
"den returnerade awaitable, som när den körs fortsätter till nästa yield-"
"uttryck. Värdet på :token:`~python-grammar:yield_list` i yield-uttrycket är "
"värdet på :exc:`StopIteration`-undantaget som den avslutande coroutinen ger "
"upphov till.  Om den asynkrona generatorn avslutas utan att ge ett annat "
"värde, ger awaitable istället upphov till ett :exc:`StopAsyncIteration`-"
"undantag, vilket signalerar att den asynkrona iterationen har slutförts."

msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""
"Denna metod anropas normalt implicit av en :keyword:`async for`-slinga."

msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""
"Returnerar en awaitable som när den körs återupptar exekveringen av den "
"asynkrona generatorn. Precis som med metoden :meth:`~generator.send` för en "
"generator, \"skickar\" denna ett värde till den asynkrona "
"generatorfunktionen, och argumentet *value* blir resultatet av det aktuella "
"yield-uttrycket. Den awaitable som returneras av metoden :meth:`asend` "
"kommer att returnera nästa värde som generatorn ger som värdet av den "
"upphöjda :exc:`StopIteration`, eller upphöjer :exc:`StopAsyncIteration` om "
"den asynkrona generatorn avslutas utan att ge ett annat värde.  När :meth:"
"`asend` anropas för att starta den asynkrona generatorn måste den anropas "
"med :const:`None` som argument, eftersom det inte finns något yield-uttryck "
"som kan ta emot värdet."

msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"Returnerar en awaitable som utlöser ett undantag av typen ``type`` vid den "
"punkt där den asynkrona generatorn pausades, och returnerar nästa värde som "
"genereras av generatorfunktionen som värdet på det utlösta :exc:"
"`StopIteration`-undantaget.  Om den asynkrona generatorn avslutas utan att "
"ge något annat värde, väcks ett :exc:`StopAsyncIteration`-undantag av "
"awaitable. Om generatorfunktionen inte fångar upp det överlämnade "
"undantaget, eller väcker ett annat undantag, när awaitable körs, sprids "
"undantaget till den som anropar awaitable."

msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"Returnerar en awaitable som när den körs kommer att kasta en :exc:"
"`GeneratorExit` till den asynkrona generatorfunktionen vid den punkt där den "
"pausades. Om den asynkrona generatorfunktionen sedan avslutas på ett elegant "
"sätt, redan är stängd, eller ger upphov till :exc:`GeneratorExit` (genom att "
"inte fånga upp undantaget), så kommer den returnerade awaitable att ge "
"upphov till ett :exc:`StopIteration` undantag. Alla ytterligare awaitables "
"som returneras av efterföljande anrop till den asynkrona generatorn kommer "
"att ge upphov till ett :exc:`StopAsyncIteration`-undantag.  Om den asynkrona "
"generatorn ger ett värde, kommer ett :exc:`RuntimeError` att uppstå i "
"awaitable.  Om den asynkrona generatorn ger upphov till något annat "
"undantag, sprids det till den som anropar awaitable.  Om den asynkrona "
"generatorn redan har avslutats på grund av ett undantag eller en normal "
"avslutning, kommer ytterligare anrop till :meth:`aclose` att returnera en "
"awaitable som inte gör någonting."

msgid "Primaries"
msgstr "Primärval"

msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Primaries representerar de mest bundna operationerna i språket. Deras syntax "
"är:"

msgid "Attribute references"
msgstr "Attributreferenser"

msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "En attributreferens är en primär följt av en punkt och ett namn:"

msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier. The type and value produced is "
"determined by the object.  Multiple evaluations of the same attribute "
"reference may yield different objects."
msgstr ""
"Primären måste utvärderas till ett objekt av en typ som stöder "
"attributreferenser, vilket de flesta objekt gör.  Detta objekt ombeds sedan "
"att producera det attribut vars namn är identifieraren. Den typ och det "
"värde som produceras bestäms av objektet.  Flera utvärderingar av samma "
"attributreferens kan ge olika objekt."

msgid ""
"This production can be customized by overriding the :meth:`~object."
"__getattribute__` method or the :meth:`~object.__getattr__` method.  The :"
"meth:`!__getattribute__` method is called first and either returns a value "
"or raises :exc:`AttributeError` if the attribute is not available."
msgstr ""
"Denna produktion kan anpassas genom att åsidosätta metoden :meth:`~object."
"__getattribute__` eller metoden :meth:`~object.__getattr__`.  Metoden :meth:"
"`!__getattribute__` anropas först och returnerar antingen ett värde eller "
"ger upphov till :exc:`AttributeError` om attributet inte är tillgängligt."

msgid ""
"If an :exc:`AttributeError` is raised and the object has a :meth:`!"
"__getattr__` method, that method is called as a fallback."
msgstr ""
"Om ett :exc:`AttributeError` uppstår och objektet har en :meth:`!"
"__getattr__`-metod, anropas den metoden som en fallback."

msgid "Subscriptions"
msgstr "Prenumerationer"

msgid ""
"The subscription of an instance of a :ref:`container class <sequence-types>` "
"will generally select an element from the container. The subscription of a :"
"term:`generic class <generic type>` will generally return a :ref:"
"`GenericAlias <types-genericalias>` object."
msgstr ""
"Prenumerationen av en instans av en :ref:`container class <sequence-types>` "
"kommer i allmänhet att välja ett element från containern. Prenumerationen av "
"en :term:`generic class <generic type>` kommer i allmänhet att returnera "
"ett :ref:`GenericAlias <types-genericalias>` objekt."

msgid ""
"When an object is subscripted, the interpreter will evaluate the primary and "
"the expression list."
msgstr ""
"När ett objekt prenumereras kommer tolken att utvärdera primären och "
"uttrycksförteckningen."

msgid ""
"The primary must evaluate to an object that supports subscription. An object "
"may support subscription through defining one or both of :meth:`~object."
"__getitem__` and :meth:`~object.__class_getitem__`. When the primary is "
"subscripted, the evaluated result of the expression list will be passed to "
"one of these methods. For more details on when ``__class_getitem__`` is "
"called instead of ``__getitem__``, see :ref:`classgetitem-versus-getitem`."
msgstr ""
"Primären måste utvärderas till ett objekt som stöder prenumeration. Ett "
"objekt kan stödja prenumeration genom att definiera en eller båda av :meth:"
"`~object.__getitem__` och :meth:`~object.__class_getitem__`. När primären är "
"abonnerad kommer det utvärderade resultatet av uttryckslistan att skickas "
"till en av dessa metoder. För mer information om när ``__class_getitem__`` "
"anropas i stället för ``__getitem__``, se :ref:`classgetitem-versus-getitem`."

msgid ""
"If the expression list contains at least one comma, or if any of the "
"expressions are starred, the expression list will evaluate to a :class:"
"`tuple` containing the items of the expression list. Otherwise, the "
"expression list will evaluate to the value of the list's sole member."
msgstr ""
"Om uttrycksförteckningen innehåller minst ett kommatecken eller om något av "
"uttrycken är stjärnmärkt, utvärderas uttrycksförteckningen till en :class:"
"`tuple` som innehåller posterna i uttrycksförteckningen. I annat fall "
"utvärderas uttrycksförteckningen till värdet av förteckningens enda medlem."

msgid "Expressions in an expression list may be starred. See :pep:`646`."
msgstr "Uttryck i en uttrycksförteckning kan vara stjärnmärkta. Se :pep:`646`."

msgid ""
"For built-in objects, there are two types of objects that support "
"subscription via :meth:`~object.__getitem__`:"
msgstr ""
"För inbyggda objekt finns det två typer av objekt som stöder prenumeration "
"via :meth:`~object.__getitem__`:"

msgid ""
"Mappings. If the primary is a :term:`mapping`, the expression list must "
"evaluate to an object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that key. "
"An example of a builtin mapping class is the :class:`dict` class."
msgstr ""
"Mappningar. Om primären är en :term:`mappning` måste uttryckslistan "
"utvärderas till ett objekt vars värde är en av nycklarna i mappningen, och "
"prenumerationen väljer det värde i mappningen som motsvarar den nyckeln. Ett "
"exempel på en inbyggd mappningsklass är klassen :class:`dict`."

msgid ""
"Sequences. If the primary is a :term:`sequence`, the expression list must "
"evaluate to an :class:`int` or a :class:`slice` (as discussed in the "
"following section). Examples of builtin sequence classes include the :class:"
"`str`, :class:`list` and :class:`tuple` classes."
msgstr ""
"Sekvenser. Om primären är en :term:`sequence` måste uttryckslistan "
"utvärderas till en :class:`int` eller en :class:`slice` (som beskrivs i "
"följande avsnitt). Exempel på inbyggda sekvensklasser är klasserna :class:"
"`str`, :class:`list` och :class:`tuple`."

msgid ""
"The formal syntax makes no special provision for negative indices in :term:"
"`sequences <sequence>`. However, built-in sequences all provide a :meth:"
"`~object.__getitem__` method that interprets negative indices by adding the "
"length of the sequence to the index so that, for example, ``x[-1]`` selects "
"the last item of ``x``. The resulting value must be a nonnegative integer "
"less than the number of items in the sequence, and the subscription selects "
"the item whose index is that value (counting from zero). Since the support "
"for negative indices and slicing occurs in the object's :meth:`~object."
"__getitem__` method, subclasses overriding this method will need to "
"explicitly add that support."
msgstr ""
"Den formella syntaxen innehåller inga särskilda bestämmelser för negativa "
"index i :term:`sekvenser <sequence>`. Alla inbyggda sekvenser har dock en :"
"meth:`~object.__getitem__`-metod som tolkar negativa index genom att lägga "
"till sekvensens längd till indexet så att till exempel ``x[-1]`` väljer det "
"sista objektet i ``x``. Det resulterande värdet måste vara ett icke-negativt "
"heltal som är mindre än antalet objekt i sekvensen, och prenumerationen "
"väljer det objekt vars index är det värdet (räknat från noll). Eftersom "
"stödet för negativa index och slicing finns i objektets :meth:`~object."
"__getitem__`-metod, måste subklasser som åsidosätter denna metod "
"uttryckligen lägga till detta stöd."

msgid ""
"A :class:`string <str>` is a special kind of sequence whose items are "
"*characters*. A character is not a separate data type but a string of "
"exactly one character."
msgstr ""
"En :class:`sträng <str>` är en speciell typ av sekvens vars element är "
"*tecken*. Ett tecken är inte en separat datatyp utan en sträng med exakt ett "
"tecken."

msgid "Slicings"
msgstr "Skivor"

msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"En slicing väljer ut ett intervall av objekt i ett sekvensobjekt (t.ex. en "
"sträng, tupel eller lista).  Slicings kan användas som uttryck eller som mål "
"i assignment- eller :keyword:`del`-satser.  Syntaxen för en slicing:"

msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"Det finns en tvetydighet i den formella syntaxen här: allt som ser ut som en "
"uttryckslista ser också ut som en skivlista, så alla prenumerationer kan "
"tolkas som en skivning.  I stället för att ytterligare komplicera syntaxen, "
"kan detta klargöras genom att definiera att i detta fall har tolkningen som "
"en prenumeration prioritet över tolkningen som en skivning (detta är fallet "
"om skivlistan inte innehåller någon riktig skiva)."

msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`~object.__getitem__` method as normal subscription) with a "
"key that is constructed from the slice list, as follows.  If the slice list "
"contains at least one comma, the key is a tuple containing the conversion of "
"the slice items; otherwise, the conversion of the lone slice item is the "
"key.  The conversion of a slice item that is an expression is that "
"expression.  The conversion of a proper slice is a slice object (see "
"section :ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :"
"attr:`~slice.step` attributes are the values of the expressions given as "
"lower bound, upper bound and stride, respectively, substituting ``None`` for "
"missing expressions."
msgstr ""
"Semantiken för en slicing är som följer.  Primären indexeras (med samma :"
"meth:`~object.__getitem__`-metod som vid normal prenumeration) med en nyckel "
"som konstrueras från slice-listan, enligt följande.  Om slice-listan "
"innehåller minst ett kommatecken är nyckeln en tupel som innehåller "
"konverteringen av slice-objekten; i annat fall är konverteringen av det enda "
"slice-objektet nyckeln.  Konverteringen av ett slice-objekt som är ett "
"uttryck är detta uttryck.  Konverteringen av en riktig slice är ett slice-"
"objekt (se avsnitt :ref:`types`) vars attribut :attr:`~slice.start`, :attr:"
"`~slice.stop` och :attr:`~slice.step` är värdena för de uttryck som anges "
"som lower bound, upper bound respektive stride, med ``None`` som ersättning "
"för uttryck som saknas."

msgid "Calls"
msgstr "Calls"

msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Ett anrop anropar ett anropbart objekt (t.ex. en :term:`funktion`) med en "
"eventuellt tom serie av :term:`argument <argument>`:"

msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""
"Ett valfritt efterföljande kommatecken kan finnas efter positions- och "
"nyckelordsargumenten, men påverkar inte semantiken."

msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`~object.__call__` method "
"are callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"Det primära måste utvärderas till ett anropbart objekt (användardefinierade "
"funktioner, inbyggda funktioner, metoder för inbyggda objekt, klassobjekt, "
"metoder för klassinstanser och alla objekt som har en :meth:`~object."
"__call__`-metod är anropbara).  Alla argumentuttryck utvärderas innan "
"anropet görs.  Se avsnitt :ref:`function` för syntaxen för formella :term:"
"`parameter`-listor."

msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the argument is placed in the slot, filling it (even if the expression is "
"``None``, it fills the slot).  When all arguments have been processed, the "
"slots that are still unfilled are filled with the corresponding default "
"value from the function definition.  (Default values are calculated, once, "
"when the function is defined; thus, a mutable object such as a list or "
"dictionary used as default value will be shared by all calls that don't "
"specify an argument value for the corresponding slot; this should usually be "
"avoided.)  If there are any unfilled slots for which no default value is "
"specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of "
"filled slots is used as the argument list for the call."
msgstr ""
"Om nyckelordsargument förekommer konverteras de först till positionsargument "
"på följande sätt.  Först skapas en lista med ofyllda slots för de formella "
"parametrarna.  Om det finns N positionella argument placeras de i de första "
"N platserna.  Därefter används identifieraren för varje nyckelordsargument "
"för att bestämma motsvarande plats (om identifieraren är densamma som det "
"första formella parameternamnet används den första platsen, och så vidare).  "
"Om platsen redan är fylld utlöses ett :exc:`TypeError`-undantag. I annat "
"fall placeras argumentet i slotten och fyller den (även om uttrycket är "
"``None`` fyller det slotten).  När alla argument har behandlats fylls de "
"platser som fortfarande är ofyllda med motsvarande standardvärde från "
"funktionsdefinitionen.  (Standardvärden beräknas en gång när funktionen "
"definieras; ett föränderligt objekt som en lista eller en ordbok som används "
"som standardvärde kommer därför att delas av alla anrop som inte anger ett "
"argumentvärde för motsvarande slot; detta bör vanligtvis undvikas)  Om det "
"finns några ofyllda slots för vilka inget standardvärde har angetts, uppstår "
"ett :exc:`TypeError` undantag.  I annat fall används listan med fyllda slots "
"som argumentlista för anropet."

msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"En implementation kan tillhandahålla inbyggda funktioner vars positionella "
"parametrar inte har namn, även om de \"namnges\" i dokumentationssyfte, och "
"som därför inte kan anges med nyckelord.  I CPython är detta fallet för "
"funktioner som implementerats i C och som använder :c:func:"
"`PyArg_ParseTuple` för att analysera sina argument."

msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"Om det finns fler positionella argument än det finns formella "
"parameterplatser, uppstår ett :exc:`TypeError`-undantag, såvida inte en "
"formell parameter med syntaxen ``*identifier`` finns; i så fall får den "
"formella parametern en tupel som innehåller de överflödiga positionella "
"argumenten (eller en tom tupel om det inte fanns några överflödiga "
"positionella argument)."

msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Om något nyckelordsargument inte motsvarar ett formellt parameternamn, "
"uppstår ett :exc:`TypeError`-undantag, såvida inte en formell parameter med "
"syntaxen ``**identifier`` finns; i så fall får den formella parametern en "
"ordbok som innehåller de överflödiga nyckelordsargumenten (med nyckelorden "
"som nycklar och argumentvärdena som motsvarande värden), eller en (ny) tom "
"ordbok om det inte fanns några överflödiga nyckelordsargument."

msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"Om syntaxen ``*expression`` förekommer i funktionsanropet måste "
"``expression`` utvärderas till en :term:`iterable`.  Element från dessa "
"iterabler behandlas som om de vore ytterligare positionella argument.  För "
"anropet ``f(x1, x2, *y, x3, x4)``, om *y* utvärderas till en sekvens "
"*y1*, ..., *yM*, är detta likvärdigt med ett anrop med M+4 positionella "
"argument *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*."

msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"En konsekvens av detta är att även om syntaxen ``*expression`` kan visas "
"*efter* explicita nyckelordsargument, bearbetas den *före* "
"nyckelordsargumenten (och eventuella ``**expression``-argument - se nedan).  "
"Så::"

msgid ""
">>> def f(a, b):\n"
"...     print(a, b)\n"
"...\n"
">>> f(b=1, *(2,))\n"
"2 1\n"
">>> f(a=1, *(2,))\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: f() got multiple values for keyword argument 'a'\n"
">>> f(1, *(2,))\n"
"1 2"
msgstr ""
"&gt;&gt;&gt; def f(a, b):\n"
"... print(a, b)\n"
"...\n"
"&gt;&gt;&gt; f(b=1, *(2,))\n"
"2 1\n"
"&gt;&gt;&gt; f(a=1, *(2,))\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: f() fick flera värden för nyckelordsargumentet 'a'\n"
"&gt;&gt;&gt; f(1, *(2,))\n"
"1 2"

msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not often arise."
msgstr ""
"Det är ovanligt att både nyckelordsargument och syntaxen ``*expression`` "
"används i samma anrop, så i praktiken uppstår inte denna förvirring särskilt "
"ofta."

msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments. If a parameter matching a key has already been "
"given a value (by an explicit keyword argument, or from another unpacking), "
"a :exc:`TypeError` exception is raised."
msgstr ""
"Om syntaxen ``**expression`` förekommer i funktionsanropet, måste "
"``expression`` utvärderas till en :term:`mapping`, vars innehåll behandlas "
"som ytterligare nyckelordsargument. Om en parameter som matchar en nyckel "
"redan har fått ett värde (genom ett explicit nyckelordsargument, eller från "
"en annan uppackning), uppstår ett :exc:`TypeError` undantag."

msgid ""
"When ``**expression`` is used, each key in this mapping must be a string. "
"Each value from the mapping is assigned to the first formal parameter "
"eligible for keyword assignment whose name is equal to the key. A key need "
"not be a Python identifier (e.g. ``\"max-temp °F\"`` is acceptable, although "
"it will not match any formal parameter that could be declared). If there is "
"no match to a formal parameter the key-value pair is collected by the ``**`` "
"parameter, if there is one, or if there is not, a :exc:`TypeError` exception "
"is raised."
msgstr ""
"När ``**expression`` används måste varje nyckel i denna mappning vara en "
"sträng. Varje värde från mappningen tilldelas den första formella parametern "
"som är kvalificerad för nyckelordstilldelning vars namn är lika med nyckeln. "
"En nyckel behöver inte vara en Python-identifierare (t.ex. ``\"max-temp "
"°F\"`` är acceptabelt, även om det inte kommer att matcha någon formell "
"parameter som kan deklareras). Om det inte finns någon matchning till en "
"formell parameter samlas nyckel-värdeparet in av parametern ``**``, om det "
"finns en, eller om det inte finns en, ett :exc:`TypeError` undantag tas upp."

msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"Formella parametrar som använder syntaxen ``*identifier`` eller "
"``**identifier`` kan inte användas som positionella argumentplatser eller "
"som nyckelordsargumentnamn."

msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"Funktionsanrop accepterar valfritt antal ``*`` och ``**`` uppackningar, "
"positionella argument kan följa iterabla uppackningar (``*``) och "
"nyckelordsargument kan följa uppackningar av ordböcker (``**``). "
"Ursprungligen föreslagen av :pep:`448`."

msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Ett anrop returnerar alltid ett värde, eventuellt ``None``, såvida det inte "
"leder till ett undantag.  Hur detta värde beräknas beror på typen av det "
"anropbara objektet."

msgid "If it is---"
msgstr "Om det är det.."

msgid "a user-defined function:"
msgstr "en användardefinierad funktion:"

msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call.  If execution reaches the end of the code block "
"without executing a :keyword:`return` statement, the return value is "
"``None``."
msgstr ""
"Kodblocket för funktionen exekveras genom att argumentlistan skickas till "
"det.  Det första kodblocket gör är att binda de formella parametrarna till "
"argumenten; detta beskrivs i avsnitt :ref:`function`.  När kodblocket "
"exekverar en :keyword:`return`-sats, anger detta returvärdet för "
"funktionsanropet.  Om exekveringen når slutet av kodblocket utan att en :"
"keyword:`return`-sats exekveras, är returvärdet ``None``."

msgid "a built-in function or method:"
msgstr "en inbyggd funktion eller metod:"

msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"Resultatet är upp till tolken; se :ref:`built-in-funcs` för beskrivningar av "
"inbyggda funktioner och metoder."

msgid "a class object:"
msgstr "ett klassobjekt:"

msgid "A new instance of that class is returned."
msgstr "En ny instans av den klassen returneras."

msgid "a class instance method:"
msgstr "en metod för klassinstans:"

msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"Motsvarande användardefinierade funktion anropas, med en argumentlista som "
"är en längre än anropets argumentlista: instansen blir det första argumentet."

msgid "a class instance:"
msgstr "en klassinstans:"

msgid ""
"The class must define a :meth:`~object.__call__` method; the effect is then "
"the same as if that method was called."
msgstr ""
"Klassen måste definiera en :meth:`~object.__call__`-metod; effekten blir då "
"densamma som om den metoden anropades."

msgid "Await expression"
msgstr "Avvakta uttryck"

msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"Avbryter exekveringen av :term:`coroutine` på ett :term:`awaitable`-objekt. "
"Kan endast användas inuti en :term:`coroutine function`."

msgid "The power operator"
msgstr "Den kraftfulla operatoren"

msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"Power-operatorn binder hårdare än unära operatorer till vänster om den; den "
"binder mindre hårt än unära operatorer till höger om den.  Syntaxen är:"

msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"I en sekvens av potens- och unära operatorer som inte är parentetisk "
"utvärderas operatorerna från höger till vänster (detta begränsar inte "
"utvärderingsordningen för operanderna): ``-1**2`` resulterar i ``-1``."

msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"Potensoperatorn har samma semantik som den inbyggda funktionen :func:`pow`, "
"när den anropas med två argument: den ger sitt vänstra argument upphöjt till "
"potensen av sitt högra argument.  De numeriska argumenten konverteras först "
"till en gemensam typ, och resultatet är av den typen."

msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"För int-operander har resultatet samma typ som operanderna om inte det andra "
"argumentet är negativt; i så fall konverteras alla argument till float och "
"ett float-resultat levereras. Till exempel ger ``10**2`` resultatet ``100``, "
"men ``10**-2`` ger ``0,01``."

msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Att höja ``0.0`` till en negativ potens resulterar i ett :exc:"
"`ZeroDivisionError`. Att höja ett negativt tal till en bråkpotens resulterar "
"i ett :class:`komplex` tal. (I tidigare versioner gav det upphov till ett :"
"exc:`ValueError`.)"

msgid ""
"This operation can be customized using the special :meth:`~object.__pow__` "
"and :meth:`~object.__rpow__` methods."
msgstr ""
"Denna operation kan anpassas med hjälp av specialmetoderna :meth:`~object."
"__pow__` och :meth:`~object.__rpow__`."

msgid "Unary arithmetic and bitwise operations"
msgstr "Unär aritmetik och bitvisa operationer"

msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "Alla unära aritmetiska och bitvisa operationer har samma prioritet:"

msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument; the operation can be overridden with the :meth:`~object.__neg__` "
"special method."
msgstr ""
"Den unära operatorn ``-`` (minus) ger negationen av sitt numeriska argument; "
"operationen kan åsidosättas med specialmetoden :meth:`~object.__neg__`."

msgid ""
"The unary ``+`` (plus) operator yields its numeric argument unchanged; the "
"operation can be overridden with the :meth:`~object.__pos__` special method."
msgstr ""
"Den unära operatorn ``+`` (plus) ger sitt numeriska argument oförändrat; "
"operationen kan åsidosättas med specialmetoden :meth:`~object.__pos__`."

msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers or to custom objects that override the :"
"meth:`~object.__invert__` special method."
msgstr ""
"Den unära operatorn ``~`` (invert) ger den bitvisa inverteringen av dess "
"heltalsargument.  Den bitvisa inverteringen av ``x`` definieras som ``-"
"(x+1)``.  Den gäller endast för heltal eller för anpassade objekt som "
"åsidosätter specialmetoden :meth:`~object.__invert__`."

msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"I alla tre fallen, om argumentet inte har rätt typ, uppstår ett :exc:"
"`TypeError` undantag."

msgid "Binary arithmetic operations"
msgstr "Binära aritmetiska operationer"

msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"De binära aritmetiska operationerna har de konventionella "
"prioritetsnivåerna.  Observera att vissa av dessa operationer även gäller "
"för vissa icke-numeriska typer.  Bortsett från potensoperatorn finns det "
"bara två nivåer, en för multiplikativa operatorer och en för additiva "
"operatorer:"

msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common real type and then multiplied together.  In the "
"latter case, sequence repetition is performed; a negative repetition factor "
"yields an empty sequence."
msgstr ""
"Operatorn ``*`` (multiplikation) ger produkten av sina argument.  Argumenten "
"måste antingen båda vara tal eller så måste det ena argumentet vara ett "
"heltal och det andra en sekvens. I det förstnämnda fallet konverteras talen "
"till en gemensam reell typ och multipliceras sedan med varandra.  I det "
"senare fallet utförs sekvensrepetition; en negativ repetitionsfaktor ger en "
"tom sekvens."

msgid ""
"This operation can be customized using the special :meth:`~object.__mul__` "
"and :meth:`~object.__rmul__` methods."
msgstr ""
"Denna operation kan anpassas med hjälp av specialmetoderna :meth:`~object."
"__mul__` och :meth:`~object.__rmul__`."

msgid ""
"If only one operand is a complex number, the other operand is converted to a "
"floating-point number."
msgstr ""
"Om endast ett operand är ett komplext tal, omvandlas det andra operand till "
"ett flyttal."

msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"Operatorn ``@`` (at) är avsedd att användas för matrismultiplikation.  Inga "
"inbyggda Python-typer implementerar denna operator."

msgid ""
"This operation can be customized using the special :meth:`~object."
"__matmul__` and :meth:`~object.__rmatmul__` methods."
msgstr ""
"Denna operation kan anpassas med hjälp av specialmetoderna :meth:`~object."
"__matmul__` och :meth:`~object.__rmatmul__`."

msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"Operatorerna ``/`` (division) och ``//`` (golvdivision) ger kvoten av sina "
"argument.  De numeriska argumenten konverteras först till en gemensam typ. "
"Division av heltal ger en float, medan golvdivision av heltal ger ett "
"heltal; resultatet är detsamma som matematisk division med \"golv\"-"
"funktionen tillämpad på resultatet.  Division med noll ger upphov till "
"undantaget :exc:`ZeroDivisionError`."

msgid ""
"The division operation can be customized using the special :meth:`~object."
"__truediv__` and :meth:`~object.__rtruediv__` methods. The floor division "
"operation can be customized using the special :meth:`~object.__floordiv__` "
"and :meth:`~object.__rfloordiv__` methods."
msgstr ""
"Delningsoperationen kan anpassas med hjälp av specialmetoderna :meth:"
"`~object.__truediv__` och :meth:`~object.__rtruediv__`. "
"Golvdelningsoperationen kan anpassas med hjälp av specialmetoderna :meth:"
"`~object.__floordiv__` och :meth:`~object.__rfloordiv__`."

msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating-point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"Operatorn ``%`` (modulo) ger återstoden av divisionen av det första "
"argumentet med det andra.  De numeriska argumenten konverteras först till en "
"gemensam typ.  Ett argument med noll till höger ger upphov till undantaget :"
"exc:`ZeroDivisionError`.  Argumenten kan vara flyttal, t.ex. ``3,14%0,7`` är "
"lika med ``0,34`` (eftersom ``3,14`` är lika med ``4*0,7 + 0,34``.) "
"Operatorn modulo ger alltid ett resultat med samma tecken som den andra "
"operanden (eller noll); resultatets absoluta värde är strikt mindre än den "
"andra operandens absoluta värde [#]_."

msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"Operatorerna vågdivision och modulo är förbundna med varandra genom följande "
"identitet: ``x == (x//y)*y + (x%y)``.  Våningsdivision och modulo är också "
"kopplade till den inbyggda funktionen :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."

msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"Förutom att utföra modulo-operationen på tal, är operatorn ``%`` också "
"överbelastad av strängobjekt för att utföra gammaldags strängformatering "
"(även känd som interpolering).  Syntaxen för strängformatering beskrivs i "
"Python Library Reference, avsnitt :ref:`old-string-formatting`."

msgid ""
"The *modulo* operation can be customized using the special :meth:`~object."
"__mod__` and :meth:`~object.__rmod__` methods."
msgstr ""
"Operationen *modulo* kan anpassas med hjälp av specialmetoderna :meth:"
"`~object.__mod__` och :meth:`~object.__rmod__`."

msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating-point number using the :func:`abs` function if appropriate."
msgstr ""
"Operatorn för vågdivision, operatorn modulo och funktionen :func:`divmod` är "
"inte definierade för komplexa tal.  Konvertera istället till ett flyttal med "
"hjälp av funktionen :func:`abs` om det är lämpligt."

msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common real type "
"and then added together. In the latter case, the sequences are concatenated."
msgstr ""
"Operatorn ``+`` (addition) ger summan av sina argument.  Argumenten måste "
"antingen båda vara tal eller båda vara sekvenser av samma typ.  I det "
"förstnämnda fallet konverteras talen till en gemensam reell typ och adderas "
"sedan. I det senare fallet konkateneras sekvenserna."

msgid ""
"This operation can be customized using the special :meth:`~object.__add__` "
"and :meth:`~object.__radd__` methods."
msgstr ""
"Denna operation kan anpassas med hjälp av specialmetoderna :meth:`~object."
"__add__` och :meth:`~object.__radd__`."

msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common real type."
msgstr ""
"Operatorn ``-`` (subtraktion) ger skillnaden mellan sina argument.  De "
"numeriska argumenten konverteras först till en gemensam real typ."

msgid ""
"This operation can be customized using the special :meth:`~object.__sub__` "
"and :meth:`~object.__rsub__` methods."
msgstr ""
"Denna operation kan anpassas med hjälp av specialmetoderna :meth:`~object."
"__sub__` och :meth:`~object.__rsub__`."

msgid "Shifting operations"
msgstr "Skiftande verksamhet"

msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"Skiftoperationerna har lägre prioritet än de aritmetiska operationerna:"

msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""
"Dessa operatorer accepterar heltal som argument.  De förskjuter det första "
"argumentet åt vänster eller höger med det antal bitar som anges i det andra "
"argumentet."

msgid ""
"The left shift operation can be customized using the special :meth:`~object."
"__lshift__` and :meth:`~object.__rlshift__` methods. The right shift "
"operation can be customized using the special :meth:`~object.__rshift__` "
"and :meth:`~object.__rrshift__` methods."
msgstr ""
"Vänsterförskjutningen kan anpassas med hjälp av specialmetoderna :meth:"
"`~object.__lshift__` och :meth:`~object.__rlshift__`. Högerförskjutningen "
"kan anpassas med hjälp av specialmetoderna :meth:`~object.__rshift__` och :"
"meth:`~object.__rrshift__`."

msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"En högerförskjutning med *n* bitar definieras som golvdivision med ``pow(2,"
"n)``.  En vänsterförskjutning med *n* bitar definieras som multiplikation "
"med ``pow(2,n)``."

msgid "Binary bitwise operations"
msgstr "Binära bitvisa operationer"

msgid "Each of the three bitwise operations has a different priority level:"
msgstr "Var och en av de tre bitvisa operationerna har olika prioritetsnivå:"

msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers or one of them must be a custom object overriding :meth:`~object."
"__and__` or :meth:`~object.__rand__` special methods."
msgstr ""
"Operatorn ``&`` ger det bitvisa AND av sina argument, som måste vara heltal "
"eller ett av dem måste vara ett anpassat objekt som åsidosätter "
"specialmetoderna :meth:`~object.__and__` eller :meth:`~object.__rand__`."

msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers or one of them must be a custom object overriding :"
"meth:`~object.__xor__` or :meth:`~object.__rxor__` special methods."
msgstr ""
"Operatorn ``^`` ger bitvis XOR (exclusive OR) av sina argument, som måste "
"vara heltal eller ett av dem måste vara ett anpassat objekt som åsidosätter "
"specialmetoderna :meth:`~object.__xor__` eller :meth:`~object.__rxor__`."

msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers or one of them must be a custom object overriding :meth:"
"`~object.__or__` or :meth:`~object.__ror__` special methods."
msgstr ""
"Operatorn ``|`` ger det bitvisa (inkluderande) OR av dess argument, som "
"måste vara heltal eller så måste ett av dem vara ett anpassat objekt som "
"åsidosätter specialmetoderna :meth:`~object.__or__` eller :meth:`~object."
"__ror__`."

msgid "Comparisons"
msgstr "Jämförelser"

msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"Till skillnad från C har alla jämförelseoperationer i Python samma "
"prioritet, som är lägre än den för aritmetiska, skiftande eller bitvisa "
"operationer.  Till skillnad från C har också uttryck som ``a < b < c`` den "
"tolkning som är konventionell inom matematiken:"

msgid ""
"Comparisons yield boolean values: ``True`` or ``False``. Custom :dfn:`rich "
"comparison methods` may return non-boolean values. In this case Python will "
"call :func:`bool` on such value in boolean contexts."
msgstr ""
"Jämförelser ger booleska värden: ``True`` eller ``False``. Anpassade :dfn:"
"`rika jämförelsemetoder` kan returnera icke-booleska värden. I detta fall "
"kommer Python att anropa :func:`bool` på sådana värden i booleska kontexter."

msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"Jämförelser kan kedjas godtyckligt, t.ex. är ``x < y <= z`` ekvivalent med "
"``x < y och y <= z``, förutom att ``y`` bara utvärderas en gång (men i båda "
"fallen utvärderas inte ``z`` alls när ``x < y`` visar sig vara falskt)."

msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Formellt, om *a*, *b*, *c*, ..., *y*, *z* är uttryck och *op1*, *op2*, ..., "
"*opN* är jämförelseoperatorer, så är ``a op1 b op2 c ... y opN z`` "
"ekvivalent med ``a op1 b och b op2 c och ... y opN z``, förutom att varje "
"uttryck utvärderas högst en gång."

msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Observera att ``a op1 b op2 c`` inte innebär någon form av jämförelse mellan "
"*a* och *c*, så att t.ex. ``x < y > z`` är helt lagligt (men kanske inte "
"vackert)."

msgid "Value comparisons"
msgstr "Värdejämförelser"

msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"Operatorerna ``<``, ``>``, ``==``, ``>=``, ``<=`` och ``!=`` jämför värdena "
"hos två objekt.  Objekten behöver inte ha samma typ."

msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"Kapitel :ref:`objects` anger att objekt har ett värde (utöver typ och "
"identitet).  Värdet på ett objekt är ett ganska abstrakt begrepp i Python: "
"Det finns t.ex. ingen kanonisk åtkomstmetod för ett objekts värde.  Det "
"finns inte heller något krav på att ett objekts värde ska vara konstruerat "
"på ett visst sätt, t.ex. bestå av alla dess dataattribut. "
"Jämförelseoperatorer implementerar en särskild uppfattning om vad ett "
"objekts värde är.  Man kan se det som att de definierar ett objekts värde "
"indirekt, med hjälp av sin jämförelseimplementering."

msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`~object.__lt__`, described in :ref:`customization`."
msgstr ""
"Eftersom alla typer är (direkta eller indirekta) subtyper av :class:"
"`object`, ärver de standardjämförelsebeteendet från :class:`object`.  Typer "
"kan anpassa sitt jämförelsebeteende genom att implementera :dfn:`rika "
"jämförelsemetoder` som :meth:`~object.__lt__`, som beskrivs i :ref:"
"`customization`."

msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"Standardbeteendet för jämlikhetsjämförelser (``==`` och ``!=``) baseras på "
"objektens identitet.  Därför resulterar jämlikhetsjämförelse av instanser "
"med samma identitet i jämlikhet, och jämlikhetsjämförelse av instanser med "
"olika identiteter resulterar i ojämlikhet.  Ett motiv för detta "
"standardbeteende är önskemålet att alla objekt ska vara reflexiva (dvs. ``x "
"är y`` innebär ``x == y``)."

msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"En standardjämförelseordning (``<``, ``>``, ``<=`` och ``>=``) "
"tillhandahålls inte; ett försök ger upphov till :exc:`TypeError`.  Ett motiv "
"för detta standardbeteende är avsaknaden av en liknande invariant som för "
"likhet."

msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"Standardjämförelsen för jämlikhet, att instanser med olika identiteter "
"alltid är ojämlika, kan stå i kontrast till vad typer behöver som har en "
"vettig definition av objektvärde och värdebaserad jämlikhet.  Sådana typer "
"kommer att behöva anpassa sitt jämförelsebeteende, och det har faktiskt ett "
"antal inbyggda typer gjort."

msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""
"I följande lista beskrivs jämförelsebeteendet för de viktigaste inbyggda "
"typerna."

msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"Tal av inbyggda numeriska typer (:ref:`typesnumeric`) och av "
"standardbibliotekets typer :class:`fractions.Fraction` och :class:`decimal."
"Decimal` kan jämföras inom och mellan sina typer, med begränsningen att "
"komplexa tal inte stöder orderjämförelse.  Inom gränserna för de berörda "
"typerna jämförs de matematiskt (algoritmiskt) korrekt utan förlust av "
"precision."

msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"Värdena \"not-a-number\" ``float('NaN')`` och ``decimal.decimal('NaN')`` är "
"speciella.  Varje ordnad jämförelse av ett tal med ett värde som inte är ett "
"tal är falsk. En kontraintuitiv implikation är att värden som inte är ett "
"tal inte är lika med sig själva.  Till exempel, om ``x = float('NaN')``, ``3 "
"< x``, ``x < 3`` och ``x == x`` är alla falska, medan ``x != x`` är sant.  "
"Detta beteende är förenligt med IEEE 754."

msgid ""
"``None`` and :data:`NotImplemented` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` och :data:`NotImplemented`` är singletoner. :PEP:`8`` rekommenderar "
"att jämförelser för singletoner alltid skall göras med ``is`` eller ``is "
"not``, aldrig med jämställdhetsoperatorerna."

msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"Binära sekvenser (instanser av :class:`bytes` eller :class:`bytearray`) kan "
"jämföras inom och mellan sina typer.  De jämförs lexikografiskt med hjälp av "
"de numeriska värdena för sina element."

msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""
"Strängar (instanser av :class:`str`) jämförs lexikografiskt med hjälp av de "
"numeriska Unicode-kodpunkterna (resultatet av den inbyggda funktionen :func:"
"`ord`) för sina tecken. "

msgid "Strings and binary sequences cannot be directly compared."
msgstr "Strängar och binära sekvenser kan inte jämföras direkt."

msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"Sekvenser (instanser av :class:`tuple`, :class:`list` eller :class:`range`) "
"kan endast jämföras inom var och en av sina typer, med begränsningen att "
"intervall inte stöder orderjämförelse.  Jämlikhetsjämförelse mellan dessa "
"typer resulterar i ojämlikhet, och ordningsjämförelse mellan dessa typer ger "
"upphov till :exc:`TypeError`."

msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"Sekvenser jämförs lexikografiskt med hjälp av jämförelse av motsvarande "
"element.  De inbyggda behållarna antar vanligtvis att identiska objekt är "
"lika med sig själva.  Det gör att de kan kringgå likhetstester för identiska "
"objekt för att förbättra prestanda och för att upprätthålla sina interna "
"invarianter."

msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""
"Lexikografisk jämförelse mellan inbyggda samlingar fungerar på följande sätt:"

msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"För att två samlingar ska kunna jämföras lika måste de vara av samma typ, ha "
"samma längd och varje par av motsvarande element måste jämföras lika (till "
"exempel är ``[1,2] == (1,2)`` falskt eftersom typen inte är densamma)."

msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"Samlingar som stöder orderjämförelse ordnas på samma sätt som deras första "
"ojämna element (till exempel har ``[1,2,x] <= [1,2,y]`` samma värde som ``x "
"<= y``).  Om det inte finns något motsvarande element ordnas den kortare "
"samlingen först (t.ex. ``[1,2] < [1,2,3]`` är sant)."

msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal ``(key, value)`` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"Avbildningar (instanser av :class:`dict`) jämför lika om och endast om de "
"har lika ``(nyckel, värde)``-par. Jämförelse av nycklar och värden som är "
"lika verkställer reflexivitet."

msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""
"Orderjämförelser (``<``, ``>``, ``<=`` och ``>=``) ger upphov till :exc:"
"`TypeError`."

msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"Uppsättningar (instanser av :class:`set` eller :class:`frozenset`) kan "
"jämföras inom och mellan sina typer."

msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"De definierar operatorer för jämförelse av ordningar som innebär test av "
"delmängder och övermängder.  Dessa relationer definierar inte totalordning "
"(till exempel är de två mängderna ``{1,2}`` och ``{2,3}`` inte lika, och "
"inte heller delmängder av varandra eller övermängder av varandra).  "
"Följaktligen är mängder inte lämpliga argument för funktioner som är "
"beroende av total ordning (till exempel :func:`min`, :func:`max` och :func:"
"`sorted` ger odefinierade resultat om de får en lista med mängder som "
"indata)."

msgid "Comparison of sets enforces reflexivity of its elements."
msgstr ""
"Jämförelse av uppsättningar tvingar fram reflexivitet hos dess element."

msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""
"De flesta andra inbyggda typer har inga jämförelsemetoder implementerade, så "
"de ärver standardjämförelsebeteendet."

msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"Användardefinierade klasser som anpassar sitt jämförelsebeteende bör om "
"möjligt följa vissa konsistensregler:"

msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"Jämförelse av jämlikhet bör vara reflexiv. Med andra ord bör identiska "
"objekt jämföras lika:"

msgid "``x is y`` implies ``x == y``"
msgstr "``x är y`` innebär ``x == y``"

msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"Jämförelsen ska vara symmetrisk. Med andra ord ska följande uttryck ge samma "
"resultat:"

msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` och ``y == x``"

msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` och ``y != x``"

msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` och ``y > x``"

msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` och ``y >= x``"

msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"Jämförelsen ska vara transitiv. Följande (icke uttömmande) exempel "
"illustrerar detta:"

msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y och y > z`` innebär ``x > z``"

msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y och y <= z`` innebär ``x < z``"

msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"Omvänd jämförelse bör resultera i den booleska negationen. Med andra ord bör "
"följande uttryck ge samma resultat:"

msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` och ``not x != y``"

msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` och ``not x >= y`` (för total ordning)"

msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` och ``not x <= y`` (för total ordning)"

msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"De två sista uttrycken gäller för totalt ordnade samlingar (t.ex. sekvenser, "
"men inte för mängder eller avbildningar). Se även dekoratorn :func:"
"`~functools.total_ordering`."

msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
"Resultatet av :func:`hash` bör vara förenligt med likhet. Objekt som är lika "
"bör antingen ha samma hashvärde eller markeras som icke-hashbara."

msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""
"Python upprätthåller inte dessa konsistensregler. Faktum är att värdena för "
"not-a-number är ett exempel på att dessa regler inte följs."

msgid "Membership test operations"
msgstr "Testverksamhet för medlemskap"

msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Operatorerna :keyword:`in` och :keyword:`not in` testar medlemskap.  ``x in "
"s`` utvärderas till ``True`` om *x* är en medlem av *s*, och ``False`` "
"annars. ``x not in s`` returnerar negationen av ``x in s``.  Alla inbyggda "
"sekvenser och set-typer stöder detta liksom dictionary, för vilket :keyword:"
"`!in` testar om dictionary har en given nyckel. För containertyper som list, "
"tuple, set, frozenset, dict eller collections.deque är uttrycket ``x in y`` "
"ekvivalent med ``any(x is e or x == e for e in y)``."

msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"För sträng- och bytestyperna är ``x in y`` ``True`` om och endast om *x* är "
"en delsträng av *y*.  Ett motsvarande test är ``y.find(x) != -1``.  Tomma "
"strängar anses alltid vara en delsträng av någon annan sträng, så ``\"\" i "
"\"abc\"`` kommer att returnera ``True``."

msgid ""
"For user-defined classes which define the :meth:`~object.__contains__` "
"method, ``x in y`` returns ``True`` if ``y.__contains__(x)`` returns a true "
"value, and ``False`` otherwise."
msgstr ""
"För användardefinierade klasser som definierar metoden :meth:`~object."
"__contains__` returnerar ``x in y`` ``True`` om ``y.__contains__(x)`` "
"returnerar ett sant värde och ``False`` annars."

msgid ""
"For user-defined classes which do not define :meth:`~object.__contains__` "
"but do define :meth:`~object.__iter__`, ``x in y`` is ``True`` if some value "
"``z``, for which the expression ``x is z or x == z`` is true, is produced "
"while iterating over ``y``. If an exception is raised during the iteration, "
"it is as if :keyword:`in` raised that exception."
msgstr ""
"För användardefinierade klasser som inte definierar :meth:`~object."
"__contains__` men som definierar :meth:`~object.__iter__`, är ``x in y`` "
"``True`` om något värde ``z``, för vilket uttrycket ``x är z eller x == z`` "
"är sant, produceras under iteration över ``y``. Om ett undantag görs under "
"iterationen, är det som om :keyword:`in` gjorde detta undantag."

msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`~object.__getitem__`, ``x in y`` is ``True`` if and only if there is a non-"
"negative integer index *i* such that ``x is y[i] or x == y[i]``, and no "
"lower integer index raises the :exc:`IndexError` exception.  (If any other "
"exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"Slutligen prövas det gamla iterationsprotokollet: om en klass definierar :"
"meth:`~object.__getitem__`, är ``x in y`` ``True`` om och endast om det "
"finns ett icke-negativt heltalsindex *i* så att ``x är y[i] eller x == "
"y[i]``, och inget lägre heltalsindex ger upphov till :exc:`IndexError`-"
"undantaget.  (Om något annat undantag görs, är det som om :keyword:`in` "
"gjorde det undantaget)."

msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr ""
"Operatorn :keyword:`not in` är definierad att ha det omvända sanningsvärdet "
"av :keyword:`in`."

msgid "Identity comparisons"
msgstr "Identitetsjämförelser"

msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Operatorerna :keyword:`is` och :keyword:`is not` testar ett objekts "
"identitet: ``x är y`` är sant om och endast om *x* och *y* är samma objekt.  "
"Ett objekts identitet bestäms med hjälp av funktionen :meth:`id`.  ``x är "
"inte y`` ger det omvända sanningsvärdet. "

msgid "Boolean operations"
msgstr "Booleska operationer"

msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`~object."
"__bool__` method."
msgstr ""
"I samband med booleska operationer, och även när uttryck används av "
"kontrollflödessatser, tolkas följande värden som falska: ``False``, "
"``None``, numeriska nollor av alla typer, och tomma strängar och behållare "
"(inklusive strängar, tupler, listor, ordböcker, mängder och frozensets).  "
"Alla andra värden tolkas som sanna.  Användardefinierade objekt kan anpassa "
"sitt sanningsvärde genom att tillhandahålla en :meth:`~object.__bool__`-"
"metod."

msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"Operatorn :keyword:`not` ger ``True`` om dess argument är falskt, ``False`` "
"annars."

msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Uttrycket ``x och y`` utvärderar först *x*; om *x* är falskt returneras dess "
"värde; i annat fall utvärderas *y* och det resulterande värdet returneras."

msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Uttrycket ``x eller y`` utvärderar först *x*; om *x* är sant returneras dess "
"värde; annars utvärderas *y* och det resulterande värdet returneras."

msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"Observera att varken :keyword:`and` eller :keyword:`or` begränsar värdet och "
"typen som returneras till ``False`` och ``True``, utan returnerar det senast "
"utvärderade argumentet.  Detta är ibland användbart, t.ex. om ``s`` är en "
"sträng som ska ersättas med ett standardvärde om den är tom, ger uttrycket "
"``s eller 'foo'`` det önskade värdet.  Eftersom :keyword:`not` måste skapa "
"ett nytt värde, returnerar det ett booleskt värde oavsett typen av argument "
"(till exempel, ``not 'foo'`` producerar ``False`` snarare än ``''``)"

msgid "Assignment expressions"
msgstr "Uppdragets uttryck"

msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`~python-grammar:expression` to an :token:"
"`~python-grammar:identifier`, while also returning the value of the :token:"
"`~python-grammar:expression`."
msgstr ""
"Ett tilldelningsuttryck (ibland även kallat \"namngivet uttryck\" eller "
"\"valross\") tilldelar en :token:`~python-grammar:expression` till en :token:"
"`~python-grammar:identifier`, samtidigt som det returnerar värdet av :token:"
"`~python-grammar:expression`."

msgid "One common use case is when handling matched regular expressions:"
msgstr ""
"Ett vanligt användningsfall är när man hanterar matchade reguljära uttryck:"

msgid ""
"if matching := pattern.search(data):\n"
"    do_something(matching)"
msgstr ""
"if matching := pattern.search(data):\n"
"    gör_något(matchning)"

msgid "Or, when processing a file stream in chunks:"
msgstr "Eller när du bearbetar en filström i bitar:"

msgid ""
"while chunk := file.read(9000):\n"
"    process(chunk)"
msgstr ""
"while chunk := file.read(9000):\n"
"    process(chunk)"

msgid ""
"Assignment expressions must be surrounded by parentheses when used as "
"expression statements and when used as sub-expressions in slicing, "
"conditional, lambda, keyword-argument, and comprehension-if expressions and "
"in ``assert``, ``with``, and ``assignment`` statements. In all other places "
"where they can be used, parentheses are not required, including in ``if`` "
"and ``while`` statements."
msgstr ""
"Tilldelningsuttryck måste omges av parenteser när de används som "
"uttryckssatser och när de används som underuttryck i slicing-, conditional-, "
"lambda-, keyword-argument- och comprehension-if-uttryck samt i ``assert``-, "
"``with``- och ``assignment``-satser. Parenteser behövs inte på alla andra "
"ställen där de kan användas, inklusive i ``if``- och ``while``-satser."

msgid "See :pep:`572` for more details about assignment expressions."
msgstr "Se :pep:`572` för mer information om assignment-uttryck."

msgid "Conditional expressions"
msgstr "Villkorliga uttryck"

msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"Villkorliga uttryck (kallas ibland \"ternär operator\") har den lägsta "
"prioriteten av alla Python-operationer."

msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"Uttrycket ``x if C else y`` utvärderar först villkoret *C* i stället för "
"*x*. Om *C* är sant, utvärderas *x* och dess värde returneras; annars "
"utvärderas *y* och dess värde returneras."

msgid "See :pep:`308` for more details about conditional expressions."
msgstr "Se :pep:`308` för mer information om villkorliga uttryck."

msgid "Lambdas"
msgstr "Lambdas"

msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"Lambda-uttryck (ibland kallade lambda-formulär) används för att skapa "
"anonyma funktioner. Uttrycket ``lambda parameters: expression`` ger ett "
"funktionsobjekt.  Det namnlösa objektet beter sig som ett funktionsobjekt "
"definierat med:"

msgid ""
"def <lambda>(parameters):\n"
"    return expression"
msgstr ""
"def <lambda>(parametrar):\n"
"    returnera uttryck"

msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"Se avsnitt :ref:`function` för syntaxen för parameterlistor.  Observera att "
"funktioner som skapas med lambda-uttryck inte kan innehålla satser eller "
"annoteringar."

msgid "Expression lists"
msgstr "Uttryckslistor"

msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"En uttrycksförteckning som innehåller minst ett kommatecken ger en tupel, "
"utom när den ingår i en list- eller set-visning.  Längden på tupeln är lika "
"med antalet uttryck i listan.  Uttrycken utvärderas från vänster till höger."

msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"En asterisk ``*`` betecknar :dfn:`iterable unpacking`.  Dess operand måste "
"vara en :term:`iterable`.  Den iterabla expanderas till en sekvens av objekt "
"som ingår i den nya tupeln, listan eller mängden på platsen för uppackningen."

msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""
"Iterabel uppackning i uttrycksförteckningar, ursprungligen föreslagen av :"
"pep:`448`."

msgid "Any item in an expression list may be starred. See :pep:`646`."
msgstr ""
"Alla objekt i en uttrycksförteckning kan stjärnmarkeras. Se :pep:`646`."

msgid ""
"A trailing comma is required only to create a one-item tuple, such as ``1,"
"``; it is optional in all other cases. A single expression without a "
"trailing comma doesn't create a tuple, but rather yields the value of that "
"expression. (To create an empty tuple, use an empty pair of parentheses: "
"``()``.)"
msgstr ""
"Ett efterföljande kommatecken krävs endast för att skapa en tupel med en "
"post, t.ex. ``1,``; det är valfritt i alla andra fall. Ett enstaka uttryck "
"utan efterföljande kommatecken skapar inte en tupel, utan ger värdet av "
"uttrycket. (Om du vill skapa en tom tupel använder du ett tomt par "
"parenteser: ``()``.)"

msgid "Evaluation order"
msgstr "Utvärderingsorder"

msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python utvärderar uttryck från vänster till höger.  Lägg märke till att när "
"du utvärderar en tilldelning utvärderas högersidan före vänstersidan."

msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"I följande rader kommer uttrycken att utvärderas i aritmetisk ordning efter "
"sina suffix::"

msgid ""
"expr1, expr2, expr3, expr4\n"
"(expr1, expr2, expr3, expr4)\n"
"{expr1: expr2, expr3: expr4}\n"
"expr1 + expr2 * (expr3 - expr4)\n"
"expr1(expr2, expr3, *expr4, **expr5)\n"
"expr3, expr4 = expr1, expr2"
msgstr ""
"expr1, expr2, expr3, expr4\n"
"(expr1, expr2, expr3, expr4)\n"
"{expr1: expr2, expr3: expr4}\n"
"expr1 + expr2 * (expr3 - expr4)\n"
"expr1(expr2, expr3, *expr4, **expr5)\n"
"expr3, expr4 = expr1, expr2"

msgid "Operator precedence"
msgstr "Operatorens företräde"

msgid ""
"The following table summarizes the operator precedence in Python, from "
"highest precedence (most binding) to lowest precedence (least binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation and conditional expressions, which "
"group from right to left)."
msgstr ""
"Följande tabell sammanfattar operatorprioriteringen i Python, från högsta "
"prioritet (mest bindande) till lägsta prioritet (minst bindande).  "
"Operatorer i samma ruta har samma företräde.  Om inte syntaxen uttryckligen "
"anges är operatorer binära.  Operatorer i samma ruta grupperas från vänster "
"till höger (med undantag för exponentiering och villkorliga uttryck, som "
"grupperas från höger till vänster)."

msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
"Observera att jämförelser, medlemskapstest och identitetstest alla har samma "
"företräde och har en vänster-till-höger kedjefunktion som beskrivs i "
"avsnittet :ref:`comparisons`."

msgid "Operator"
msgstr "Operator"

msgid "Description"
msgstr "Beskrivning"

msgid "``(expressions...)``,"
msgstr "``(uttryck...)``,"

msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[uttryck...]``, ``{nyckel: värde...}`, ``{expressions...}``"

msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr ""
"Bindande eller parentetiskt uttryck, listvisning, ordboksvisning, set-visning"

msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(argument...)``, ``x.attribute``"

msgid "Subscription, slicing, call, attribute reference"
msgstr "Prenumeration, slicing, samtal, attributreferens"

msgid ":keyword:`await x <await>`"
msgstr ":nyckelord:`await x <await>`"

msgid "``**``"
msgstr "``**``"

msgid "Exponentiation [#]_"
msgstr "Exponentiering [#]_"

msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

msgid "Positive, negative, bitwise NOT"
msgstr "Positiv, negativ, bitvis NOT"

msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr ""
"Multiplikation, matrismultiplikation, division, våningsdivision, rest [#]_"

msgid "``+``, ``-``"
msgstr "``+``, ``-``"

msgid "Addition and subtraction"
msgstr "Addition och subtraktion"

msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

msgid "Shifts"
msgstr "Skift"

msgid "``&``"
msgstr "``&``"

msgid "Bitwise AND"
msgstr "Bitvis AND"

msgid "``^``"
msgstr "``^``"

msgid "Bitwise XOR"
msgstr "Bitvis XOR"

msgid "``|``"
msgstr "``|``"

msgid "Bitwise OR"
msgstr "Bitvis OR"

msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

msgid "Comparisons, including membership tests and identity tests"
msgstr "Jämförelser, inklusive medlemstester och identitetstester"

msgid ":keyword:`not x <not>`"
msgstr ":nyckelord:`inte x <not>`"

msgid "Boolean NOT"
msgstr "Boolean NOT"

msgid ":keyword:`and`"
msgstr ":nyckelord:`och`"

msgid "Boolean AND"
msgstr "Booleansk AND"

msgid ":keyword:`or`"
msgstr ":nyckelord:`eller`"

msgid "Boolean OR"
msgstr "Booleansk OR"

msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

msgid "Conditional expression"
msgstr "Villkorligt uttryck"

msgid ":keyword:`lambda`"
msgstr ":nyckelord:`lambda`"

msgid "Lambda expression"
msgstr "Lambda-uttryck"

msgid "``:=``"
msgstr "``:=``"

msgid "Assignment expression"
msgstr "Uppdragets uttryck"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"Medan ``abs(x%y) < abs(y)`` är sant matematiskt, är det för flottörer kanske "
"inte sant numeriskt på grund av avrundning.  Till exempel, och förutsatt att "
"en plattform där en Python float är ett IEEE 754 dubbelprecisionstal, för "
"att ``-1e-100 % 1e100`` ska ha samma tecken som ``1e100``, är det beräknade "
"resultatet ``-1e-100 + 1e100``, vilket är numeriskt exakt lika med "
"``1e100``.  Funktionen :func:`math.fmod` returnerar istället ett resultat "
"vars tecken matchar tecknet på det första argumentet, och returnerar alltså "
"``-1e-100`` i det här fallet. Vilket tillvägagångssätt som är lämpligast "
"beror på tillämpningen."

msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"Om x är mycket nära en exakt heltalsmultipel av y, är det möjligt att ``x//"
"y`` är ett större än ``(x-x%y)//y`` på grund av avrundning.  I sådana fall "
"returnerar Python det senare resultatet, för att bevara att ``divmod(x,y)[0] "
"* y + x % y`` är mycket nära ``x``."

msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Unicode-standarden skiljer mellan :dfn:`kodpunkter` (t.ex. U+0041) och :dfn:"
"`abstrakta tecken` (t.ex. \"LATIN CAPITAL LETTER A\"). Även om de flesta "
"abstrakta tecken i Unicode endast representeras med en kodpunkt, finns det "
"ett antal abstrakta tecken som dessutom kan representeras med en sekvens av "
"mer än en kodpunkt.  Till exempel kan det abstrakta tecknet \"LATIN CAPITAL "
"LETTER C WITH CEDILLA\" representeras som ett enda :dfn:`förkomponerat "
"tecken` vid kodposition U+00C7, eller som en sekvens av ett :dfn:`bas-"
"tecken` vid kodposition U+0043 (LATIN CAPITAL LETTER C), följt av ett :dfn:"
"`kombinationstecken` vid kodposition U+0327 (KOMBINERANDE CEDILLA)."

msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"Jämförelseoperatorerna på strängar jämför på nivån för Unicode-kodpunkter. "
"Detta kan vara kontraintuitivt för människor.  Till exempel är ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"``falskt``, även om båda strängarna representerar samma "
"abstrakta tecken \"LATIN CAPITAL LETTER C WITH CEDILLA\"."

msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"Om du vill jämföra strängar på nivån för abstrakta tecken (dvs. på ett sätt "
"som är intuitivt för människor) använder du :func:`unicodedata.normalize`."

msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"På grund av automatisk garbage-collection, fria listor och deskriptorns "
"dynamiska natur kan du märka ett till synes ovanligt beteende i vissa "
"användningar av operatorn :keyword:`is`, till exempel när det gäller "
"jämförelser mellan instansmetoder eller konstanter.  Kontrollera deras "
"dokumentation för mer information."

msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"Potensoperatorn ``**`` binder mindre hårt än en aritmetisk eller bitvis unär "
"operator till höger om den, det vill säga ``2**-1`` är ``0,5``."

msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"Operatorn ``%`` används också för strängformatering; samma företräde gäller."

msgid "expression"
msgstr "uttryck"

msgid "BNF"
msgstr "BNF"

msgid "arithmetic"
msgstr "aritmetisk"

msgid "conversion"
msgstr "omvandling"

msgid "atom"
msgstr "atom"

msgid "name"
msgstr "namn"

msgid "identifier"
msgstr "identifierare"

msgid "exception"
msgstr "undantag"

msgid "NameError"
msgstr "NamnFel"

msgid "mangling"
msgstr "mangling"

msgid "private"
msgstr "privat"

msgid "names"
msgstr "namn"

msgid "literal"
msgstr "bokstavlig"

msgid "immutable"
msgstr "oföränderlig"

msgid "data"
msgstr "data"

msgid "type"
msgstr "typ"

msgid "object"
msgstr "objekt"

msgid "parenthesized form"
msgstr "parentesform"

msgid "() (parentheses)"
msgstr "() (inom parentes)"

msgid "tuple display"
msgstr "tupelvisning"

msgid "empty"
msgstr "tom"

msgid "tuple"
msgstr "tupel"

msgid "comma"
msgstr "komma"

msgid ", (comma)"
msgstr ", (kommatecken)"

msgid "comprehensions"
msgstr "förståelser"

msgid "for"
msgstr "för"

msgid "in comprehensions"
msgstr "i förståelser"

msgid "if"
msgstr "om"

msgid "async for"
msgstr "asynkron för"

msgid "await"
msgstr "invänta"

msgid "list"
msgstr "lista"

msgid "display"
msgstr "display"

msgid "[] (square brackets)"
msgstr "[] (hakparenteser)"

msgid "list expression"
msgstr "lista uttryck"

msgid "expression list"
msgstr "uttrycksförteckning"

msgid "set"
msgstr "set"

msgid "{} (curly brackets)"
msgstr "{} (inom hakparentes)"

msgid "set expression"
msgstr "inställt uttryck"

msgid "dictionary"
msgstr "ordbok"

msgid "key"
msgstr "nyckel"

msgid "value"
msgstr "värde"

msgid "key/value pair"
msgstr "nyckel/värde-par"

msgid "dictionary expression"
msgstr "ordboksuttryck"

msgid ": (colon)"
msgstr ": (kolon)"

msgid "in dictionary expressions"
msgstr "i ordboksuttryck"

msgid "in dictionary displays"
msgstr "i ordboksuppslagningar"

msgid "unpacking"
msgstr "uppackning"

msgid "**"
msgstr "**"

msgid "hashable"
msgstr "hashbar"

msgid "generator"
msgstr "generator"

msgid "generator expression"
msgstr "generatoruttryck"

msgid "keyword"
msgstr "sökord"

msgid "yield"
msgstr "avkastning"

msgid "from"
msgstr "från"

msgid "function"
msgstr "funktion"

msgid "coroutine"
msgstr "coroutine"

msgid "yield from expression"
msgstr "avkastning från uttryck"

msgid "StopIteration"
msgstr "StopIteration"

msgid "GeneratorExit"
msgstr "GeneratorExit"

msgid "examples"
msgstr "exempel"

msgid "asynchronous-generator"
msgstr "asynkron-generator"

msgid "StopAsyncIteration"
msgstr "StoppaAsyncIteration"

msgid "primary"
msgstr "primär"

msgid "attribute"
msgstr "attribut"

msgid "reference"
msgstr "referens"

msgid ". (dot)"
msgstr ". (punkt)"

msgid "attribute reference"
msgstr "attributreferens"

msgid "AttributeError"
msgstr "AttributFel"

msgid "module"
msgstr "modul"

msgid "subscription"
msgstr "prenumeration"

msgid "sequence"
msgstr "sekvens"

msgid "mapping"
msgstr "kartläggning"

msgid "string"
msgstr "sträng"

msgid "item"
msgstr "objekt"

msgid "character"
msgstr "tecken"

msgid "slicing"
msgstr "skivning"

msgid "slice"
msgstr "skiva"

msgid "start (slice object attribute)"
msgstr "start (attribut för skivobjekt)"

msgid "stop (slice object attribute)"
msgstr "stopp (attribut för skivobjekt)"

msgid "step (slice object attribute)"
msgstr "steg (objektattribut för skiva)"

msgid "callable"
msgstr "anropsbar"

msgid "call"
msgstr "ring upp"

msgid "argument"
msgstr "argument"

msgid "call semantics"
msgstr "semantik för anrop"

msgid "argument list"
msgstr "argumentlista"

msgid "= (equals)"
msgstr "= (lika med)"

msgid "in function calls"
msgstr "i funktionsanrop"

msgid "parameter"
msgstr "parameter"

msgid "* (asterisk)"
msgstr "* (asterisk)"

msgid "user-defined"
msgstr "användardefinierad"

msgid "user-defined function"
msgstr "användardefinierad funktion"

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "method"
msgstr "metod"

msgid "built-in method"
msgstr "inbyggd metod"

msgid "class"
msgstr "klass"

msgid "class object"
msgstr "klassobjekt"

msgid "class instance"
msgstr "klassinstans"

msgid "instance"
msgstr "instans"

msgid "__call__() (object method)"
msgstr "__call__() (objektmetod)"

msgid "power"
msgstr "kraft"

msgid "operation"
msgstr "drift"

msgid "operator"
msgstr "operator"

msgid "unary"
msgstr "unär"

msgid "bitwise"
msgstr "bitvis"

msgid "negation"
msgstr "förnekande"

msgid "minus"
msgstr "minus"

msgid "- (minus)"
msgstr "- (minus)"

msgid "unary operator"
msgstr "unär operator"

msgid "plus"
msgstr "plus"

msgid "+ (plus)"
msgstr "+ (plus)"

msgid "inversion"
msgstr "inversion"

msgid "~ (tilde)"
msgstr "~ (tilde)"

msgid "TypeError"
msgstr "Typfel"

msgid "binary"
msgstr "binär"

msgid "multiplication"
msgstr "multiplikation"

msgid "matrix multiplication"
msgstr "matrismultiplikation"

msgid "@ (at)"
msgstr "@ (vid)"

msgid "ZeroDivisionError"
msgstr "NollDivisionFel"

msgid "division"
msgstr "division"

msgid "/ (slash)"
msgstr "/ (snedstreck)"

msgid "//"
msgstr "//"

msgid "modulo"
msgstr "modulo"

msgid "% (percent)"
msgstr "% (procent)"

msgid "addition"
msgstr "tillägg"

msgid "binary operator"
msgstr "binär operator"

msgid "subtraction"
msgstr "subtraktion"

msgid "shifting"
msgstr "förskjutning"

msgid "<<"
msgstr "<<"

msgid ">>"
msgstr ">>"

msgid "ValueError"
msgstr "VärdeFel"

msgid "and"
msgstr "och"

msgid "& (ampersand)"
msgstr "& (ampersand)"

msgid "xor"
msgstr "xor"

msgid "exclusive"
msgstr "exklusiv"

msgid "or"
msgstr "eller"

msgid "^ (caret)"
msgstr "^ (caret)"

msgid "inclusive"
msgstr "inkluderande"

msgid "| (vertical bar)"
msgstr "| (vertikal stapel)"

msgid "comparison"
msgstr "jämförelse"

msgid "C"
msgstr "C"

msgid "language"
msgstr "språk"

msgid "< (less)"
msgstr "< (mindre)"

msgid "> (greater)"
msgstr "> (större)"

msgid "<="
msgstr "<="

msgid ">="
msgstr ">="

msgid "=="
msgstr "=="

msgid "!="
msgstr "!="

msgid "chaining"
msgstr "kedja"

msgid "comparisons"
msgstr "jämförelser"

msgid "in"
msgstr "i"

msgid "not in"
msgstr "inte i"

msgid "membership"
msgstr "medlemskap"

msgid "test"
msgstr "test"

msgid "is"
msgstr "är"

msgid "is not"
msgstr "är inte"

msgid "identity"
msgstr "identitet"

msgid "Conditional"
msgstr "Villkorlig"

msgid "Boolean"
msgstr "Boolean"

msgid "not"
msgstr "inte"

msgid ":= (colon equals)"
msgstr ":= (kolon är lika med)"

msgid "assignment expression"
msgstr "uppdragets uttryck"

msgid "walrus operator"
msgstr "valrossoperator"

msgid "named expression"
msgstr "namngivet uttryck"

msgid "assignment"
msgstr "uppgift"

msgid "conditional"
msgstr "villkorlig"

msgid "ternary"
msgstr "ternär"

msgid "conditional expression"
msgstr "villkorligt uttryck"

msgid "else"
msgstr "annat"

msgid "lambda"
msgstr "lambda"

msgid "form"
msgstr "formulär"

msgid "anonymous"
msgstr "anonym"

msgid "lambda expression"
msgstr "lambda-uttryck"

msgid "iterable"
msgstr "itererbar"

msgid "in expression lists"
msgstr "i uttrycksförteckningar"

msgid "trailing"
msgstr "efterföljande"

msgid "evaluation"
msgstr "utvärdering"

msgid "order"
msgstr "order"

msgid "precedence"
msgstr "företräde"
