# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!importlib.metadata` -- Accessing package metadata"
msgstr ":mod:`!importlib.metadata` -- Tillgång till metadata för paket"

msgid "``importlib.metadata`` is no longer provisional."
msgstr "``importlib.metadata`` är inte längre provisorisk."

msgid "**Source code:** :source:`Lib/importlib/metadata/__init__.py`"
msgstr "**Källkod:** :source:`Lib/importlib/metadata/__init__.py`"

msgid ""
"``importlib.metadata`` is a library that provides access to the metadata of "
"an installed `Distribution Package <https://packaging.python.org/en/latest/"
"glossary/#term-Distribution-Package>`_, such as its entry points or its top-"
"level names (`Import Package <https://packaging.python.org/en/latest/"
"glossary/#term-Import-Package>`_\\s, modules, if any). Built in part on "
"Python's import system, this library intends to replace similar "
"functionality in the `entry point API`_ and `metadata API`_ of "
"``pkg_resources``. Along with :mod:`importlib.resources`, this package can "
"eliminate the need to use the older and less efficient ``pkg_resources`` "
"package."
msgstr ""
"``importlib.metadata`` är ett bibliotek som ger tillgång till metadata för "
"ett installerat `Distribution Package <https://packaging.python.org/en/"
"latest/glossary/#term-Distribution-Package>`_, såsom dess ingångspunkter "
"eller dess toppnivånamn (`Import Package <https://packaging.python.org/en/"
"latest/glossary/#term-Import-Package>`_\\s, moduler, om sådana finns). Det "
"här biblioteket bygger delvis på Pythons importsystem och avser att ersätta "
"liknande funktionalitet i `entry point API`_ och `metadata API`_ i "
"``pkg_resources``. Tillsammans med :mod:`importlib.resources` kan detta "
"paket eliminera behovet av att använda det äldre och mindre effektiva "
"paketet ``pkg_resources``."

msgid ""
"``importlib.metadata`` operates on third-party *distribution packages* "
"installed into Python's ``site-packages`` directory via tools such as :pypi:"
"`pip`. Specifically, it works with distributions with discoverable ``dist-"
"info`` or ``egg-info`` directories, and metadata defined by the `Core "
"metadata specifications <https://packaging.python.org/en/latest/"
"specifications/core-metadata/#core-metadata>`_."
msgstr ""
"``importlib.metadata`` fungerar på tredjeparts *distributionspaket* som "
"installeras i Pythons ``site-packages``-katalog via verktyg som :pypi:`pip`. "
"Specifikt fungerar det med distributioner med upptäckbara ``dist-info`` "
"eller ``egg-info``-kataloger och metadata som definieras av `Core metadata "
"specifications <https://packaging.python.org/en/latest/specifications/core-"
"metadata/#core-metadata>`_."

msgid ""
"These are *not* necessarily equivalent to or correspond 1:1 with the top-"
"level *import package* names that can be imported inside Python code. One "
"*distribution package* can contain multiple *import packages* (and single "
"modules), and one top-level *import package* may map to multiple "
"*distribution packages* if it is a namespace package. You can use :ref:"
"`packages_distributions() <package-distributions>` to get a mapping between "
"them."
msgstr ""
"Dessa är *inte* nödvändigtvis likvärdiga med eller motsvarar 1:1 de "
"*importpaket*-namn på toppnivå som kan importeras i Python-kod. Ett "
"*distributionspaket* kan innehålla flera *importpaket* (och enstaka "
"moduler), och ett *importpaket* på toppnivå kan mappa till flera "
"*distributionspaket* om det är ett namnrymdspaket. Du kan använda :ref:"
"`packages_distributions() <package-distributions>` för att få en mappning "
"mellan dem."

msgid ""
"By default, distribution metadata can live on the file system or in zip "
"archives on :data:`sys.path`. Through an extension mechanism, the metadata "
"can live almost anywhere."
msgstr ""
"Som standard kan distributionsmetadata finnas i filsystemet eller i zip-"
"arkiv på :data:`sys.path`. Genom en tilläggsmekanism kan metadata lagras "
"nästan var som helst."

msgid "https://importlib-metadata.readthedocs.io/"
msgstr "https://importlib-metadata.readthedocs.io/"

msgid ""
"The documentation for ``importlib_metadata``, which supplies a backport of "
"``importlib.metadata``. This includes an `API reference <https://importlib-"
"metadata.readthedocs.io/en/latest/api.html>`__ for this module's classes and "
"functions, as well as a `migration guide <https://importlib-metadata."
"readthedocs.io/en/latest/migration.html>`__ for existing users of "
"``pkg_resources``."
msgstr ""
"Dokumentationen för ``importlib_metadata``, som tillhandahåller en backport "
"av ``importlib.metadata``. Detta inkluderar en `API-referens <https://"
"importlib-metadata.readthedocs.io/en/latest/api.html>`__ för den här "
"modulens klasser och funktioner, samt en `migreringsguide <https://importlib-"
"metadata.readthedocs.io/en/latest/migration.html>`__ för befintliga "
"användare av ``pkg_resources``."

msgid "Overview"
msgstr "Översikt"

msgid ""
"Let's say you wanted to get the version string for a `Distribution Package "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ you've installed using ``pip``. We start by creating a virtual "
"environment and installing something into it:"
msgstr ""
"Låt oss säga att du vill få fram versionssträngen för ett `Distribution "
"Package <https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_ som du har installerat med hjälp av ``pip``. Vi börjar med att "
"skapa en virtuell miljö och installerar något i den:"

msgid ""
"$ python -m venv example\n"
"$ source example/bin/activate\n"
"(example) $ python -m pip install wheel"
msgstr ""
"$ python -m venv example\n"
"$ source example/bin/activate\n"
"(example) $ python -m pip install wheel"

msgid "You can get the version string for ``wheel`` by running the following:"
msgstr "Du kan få fram versionssträngen för ``wheel`` genom att köra följande:"

msgid ""
"(example) $ python\n"
">>> from importlib.metadata import version\n"
">>> version('wheel')\n"
"'0.32.3'"
msgstr ""
"(example) $ python\n"
">>> from importlib.metadata import version\n"
">>> version('wheel')\n"
"'0.32.3'"

msgid ""
"You can also get a collection of entry points selectable by properties of "
"the EntryPoint (typically 'group' or 'name'), such as ``console_scripts``, "
"``distutils.commands`` and others. Each group contains a collection of :ref:"
"`EntryPoint <entry-points>` objects."
msgstr ""
"Du kan också få en samling ingångspunkter som kan väljas genom egenskaper "
"hos EntryPoint (vanligtvis 'group' eller 'name'), t.ex. ``console_scripts``, "
"``distutils.commands`` och andra. Varje grupp innehåller en samling av :ref:"
"``EntryPoint <entry-points>`` objekt."

msgid "You can get the :ref:`metadata for a distribution <metadata>`::"
msgstr "Du kan få :ref:`metadata för en distribution <metadata>`::"

msgid ""
">>> list(metadata('wheel'))\n"
"['Metadata-Version', 'Name', 'Version', 'Summary', 'Home-page', 'Author', "
"'Author-email', 'Maintainer', 'Maintainer-email', 'License', 'Project-URL', "
"'Project-URL', 'Project-URL', 'Keywords', 'Platform', 'Classifier', "
"'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', "
"'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', "
"'Classifier', 'Requires-Python', 'Provides-Extra', 'Requires-Dist', "
"'Requires-Dist']"
msgstr ""
">>> list(metadata('wheel'))\n"
"['Metadata-Version', 'Name', 'Version', 'Summary', 'Home-page', 'Author', "
"'Author-email', 'Maintainer', 'Maintainer-email', 'License', 'Project-URL', "
"'Project-URL', 'Project-URL', 'Keywords', 'Platform', 'Classifier', "
"'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', "
"'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', "
"'Classifier', 'Requires-Python', 'Provides-Extra', 'Requires-Dist', "
"'Requires-Dist']"

msgid ""
"You can also get a :ref:`distribution's version number <version>`, list its :"
"ref:`constituent files <files>`, and get a list of the distribution's :ref:"
"`requirements`."
msgstr ""
"Du kan också få en :ref:`distributions versionsnummer <version>`, lista "
"dess :ref:`beståndsdelar <files>` och få en lista över distributionens :ref:"
"`krav`."

msgid ""
"Subclass of :class:`ModuleNotFoundError` raised by several functions in this "
"module when queried for a distribution package which is not installed in the "
"current Python environment."
msgstr ""
"Underklass till :class:`ModuleNotFoundError` som orsakas av flera funktioner "
"i denna modul när de frågar efter ett distributionspaket som inte är "
"installerat i den aktuella Python-miljön."

msgid "Functional API"
msgstr "Funktionellt API"

msgid "This package provides the following functionality via its public API."
msgstr ""
"Detta paket tillhandahåller följande funktionalitet via sitt publika API."

msgid "Entry points"
msgstr "Ingångspunkter"

msgid ""
"Returns a :class:`EntryPoints` instance describing entry points for the "
"current environment. Any given keyword parameters are passed to the :meth:`!"
"select` method for comparison to the attributes of the individual entry "
"point definitions."
msgstr ""
"Returnerar en :class:`EntryPoints`-instans som beskriver entry points för "
"den aktuella miljön. Eventuella nyckelordsparametrar skickas till :meth:`!"
"select`-metoden för jämförelse med attributen i de enskilda entry point-"
"definitionerna."

msgid ""
"Note: it is not currently possible to query for entry points based on their :"
"attr:`!EntryPoint.dist` attribute (as different :class:`!Distribution` "
"instances do not currently compare equal, even if they have the same "
"attributes)"
msgstr ""
"Obs: det är för närvarande inte möjligt att fråga efter entry points baserat "
"på deras :attr:`!EntryPoint.dist`-attribut (eftersom olika :class:`!"
"Distribution`-instanser för närvarande inte jämförs lika, även om de har "
"samma attribut)"

msgid "Details of a collection of installed entry points."
msgstr "Detaljer om en samling installerade inmatningspunkter."

msgid ""
"Also provides a ``.groups`` attribute that reports all identified entry "
"point groups, and a ``.names`` attribute that reports all identified entry "
"point names."
msgstr ""
"Innehåller även attributet ``.groups`` som rapporterar alla identifierade "
"grupper av entrépunkter och attributet ``.names`` som rapporterar alla "
"identifierade namn på entrépunkter."

msgid "Details of an installed entry point."
msgstr "Detaljer om en installerad ingångspunkt."

msgid ""
"Each :class:`!EntryPoint` instance has ``.name``, ``.group``, and ``.value`` "
"attributes and a ``.load()`` method to resolve the value. There are also ``."
"module``, ``.attr``, and ``.extras`` attributes for getting the components "
"of the ``.value`` attribute, and ``.dist`` for obtaining information "
"regarding the distribution package that provides the entry point."
msgstr ""
"Varje :class:`!EntryPoint`-instans har attributen ``.name``, ``.group`` och "
"``.value`` och en ``.load()``-metod för att lösa upp värdet. Det finns också "
"attributen ``.module``, ``.attr`` och ``.extras`` för att hämta "
"komponenterna i attributet ``.value`` och ``.dist`` för att hämta "
"information om det distributionspaket som tillhandahåller entrypointen."

msgid "Query all entry points::"
msgstr "Fråga alla inmatningspunkter::"

msgid ">>> eps = entry_points()"
msgstr ">>> eps = entry_points()"

msgid ""
"The :func:`!entry_points` function returns a :class:`!EntryPoints` object, a "
"collection of all :class:`!EntryPoint` objects with ``names`` and ``groups`` "
"attributes for convenience::"
msgstr ""
"Funktionen :func:`!entry_points` returnerar ett :class:`!EntryPoints`-"
"objekt, en samling av alla :class:`!EntryPoint`-objekt med attributen "
"``names`` och ``groups`` för enkelhetens skull::"

msgid ""
">>> sorted(eps.groups)\n"
"['console_scripts', 'distutils.commands', 'distutils.setup_keywords', "
"'egg_info.writers', 'setuptools.installation']"
msgstr ""
">>> sorted(eps.groups)\n"
"['console_scripts', 'distutils.commands', 'distutils.setup_keywords', "
"'egg_info.writers', 'setuptools.installation']"

msgid ""
":class:`!EntryPoints` has a :meth:`!select` method to select entry points "
"matching specific properties. Select entry points in the ``console_scripts`` "
"group::"
msgstr ""
":class:`!EntryPoints` har en :meth:`!select`-metod för att välja "
"entrypunkter som matchar specifika egenskaper. Välj ingångspunkter i gruppen "
"``console_scripts``::"

msgid ">>> scripts = eps.select(group='console_scripts')"
msgstr ">>> scripts = eps.select(group='console_scripts')"

msgid ""
"Equivalently, since :func:`!entry_points` passes keyword arguments through "
"to select::"
msgstr ""
"På motsvarande sätt, eftersom :func:`!entry_points` skickar "
"nyckelordsargument vidare till select::"

msgid ">>> scripts = entry_points(group='console_scripts')"
msgstr ">>> scripts = entry_points(group='console_scripts')"

msgid ""
"Pick out a specific script named \"wheel\" (found in the wheel project)::"
msgstr ""
"Välj ut ett specifikt skript som heter \"wheel\" (finns i wheel-projektet)::"

msgid ""
">>> 'wheel' in scripts.names\n"
"True\n"
">>> wheel = scripts['wheel']"
msgstr ""
">>> 'wheel' in scripts.names\n"
"True\n"
">>> wheel = scripts['wheel']"

msgid "Equivalently, query for that entry point during selection::"
msgstr "På motsvarande sätt, fråga efter den ingångspunkten under urvalet::"

msgid ""
">>> (wheel,) = entry_points(group='console_scripts', name='wheel')\n"
">>> (wheel,) = entry_points().select(group='console_scripts', name='wheel')"
msgstr ""
">>> (wheel,) = entry_points(group='console_scripts', name='wheel')\n"
">>> (wheel,) = entry_points().select(group='console_scripts', name='wheel')"

msgid "Inspect the resolved entry point::"
msgstr "Inspektera den lösta ingångspunkten::"

msgid ""
">>> wheel\n"
"EntryPoint(name='wheel', value='wheel.cli:main', group='console_scripts')\n"
">>> wheel.module\n"
"'wheel.cli'\n"
">>> wheel.attr\n"
"'main'\n"
">>> wheel.extras\n"
"[]\n"
">>> main = wheel.load()\n"
">>> main\n"
"<function main at 0x103528488>"
msgstr ""
">>> wheel\n"
"EntryPoint(name='wheel', value='wheel.cli:main', group='console_scripts')\n"
">>> wheel.module\n"
"'wheel.cli'\n"
">>> wheel.attr\n"
"'main'\n"
">>> wheel.extras\n"
"[]\n"
">>> main = wheel.load()\n"
">>> main\n"
"<function main at 0x103528488>"

msgid ""
"The ``group`` and ``name`` are arbitrary values defined by the package "
"author and usually a client will wish to resolve all entry points for a "
"particular group. Read `the setuptools docs <https://setuptools.pypa.io/en/"
"latest/userguide/entry_point.html>`_ for more information on entry points, "
"their definition, and usage."
msgstr ""
"``group`` och ``name`` är godtyckliga värden som definieras av paketets "
"författare och vanligtvis kommer en klient att vilja lösa alla "
"ingångspunkter för en viss grupp. Läs `the setuptools docs <https://"
"setuptools.pypa.io/en/latest/userguide/entry_point.html>`_ för mer "
"information om ingångspunkter, deras definition och användning."

msgid ""
"The \"selectable\" entry points were introduced in ``importlib_metadata`` "
"3.6 and Python 3.10. Prior to those changes, ``entry_points`` accepted no "
"parameters and always returned a dictionary of entry points, keyed by group. "
"With ``importlib_metadata`` 5.0 and Python 3.12, ``entry_points`` always "
"returns an ``EntryPoints`` object. See :pypi:`backports."
"entry_points_selectable` for compatibility options."
msgstr ""
"De \"valbara\" ingångspunkterna introducerades i ``importlib_metadata`` 3.6 "
"och Python 3.10. Före dessa ändringar accepterade ``entry_points`` inga "
"parametrar och returnerade alltid en ordbok med ingångspunkter, med grupp "
"som nyckel. Med ``importlib_metadata`` 5.0 och Python 3.12 returnerar "
"``entry_points`` alltid ett ``EntryPoints``-objekt. Se :pypi:`backports."
"entry_points_selectable` för kompatibilitetsalternativ."

msgid ""
"``EntryPoint`` objects no longer present a tuple-like interface (:meth:"
"`~object.__getitem__`)."
msgstr ""
"``EntryPoint``-objekt har inte längre ett tuple-liknande gränssnitt (:meth:"
"`~object.__getitem__`)."

msgid "Distribution metadata"
msgstr "Metadata för distribution"

msgid ""
"Return the distribution metadata corresponding to the named distribution "
"package as a :class:`PackageMetadata` instance."
msgstr ""
"Returnerar distributionsmetadata som motsvarar det angivna "
"distributionspaketet som en instans av :class:`PackageMetadata`."

msgid ""
"Raises :exc:`PackageNotFoundError` if the named distribution package is not "
"installed in the current Python environment."
msgstr ""
"Utlöser :exc:`PackageNotFoundError` om det angivna distributionspaketet inte "
"är installerat i den aktuella Python-miljön."

msgid ""
"A concrete implementation of the `PackageMetadata protocol <https://"
"importlib-metadata.readthedocs.io/en/latest/api.html#importlib_metadata."
"PackageMetadata>`_."
msgstr ""
"En konkret implementering av `PackageMetadata-protokollet <https://importlib-"
"metadata.readthedocs.io/en/latest/api.html#importlib_metadata."
"PackageMetadata>`_."

msgid ""
"In addition to providing the defined protocol methods and attributes, "
"subscripting the instance is equivalent to calling the :meth:`!get` method."
msgstr ""
"Förutom att tillhandahålla de definierade protokollmetoderna och -"
"attributen, motsvarar subskription av instansen anrop av metoden :meth:`!"
"get`."

msgid ""
"Every `Distribution Package <https://packaging.python.org/en/latest/glossary/"
"#term-Distribution-Package>`_ includes some metadata, which you can extract "
"using the :func:`!metadata` function::"
msgstr ""
"Varje `Distributionspaket <https://packaging.python.org/en/latest/glossary/"
"#term-Distribution-Package>`_ innehåller en del metadata, som du kan "
"extrahera med hjälp av funktionen :func:`!metadata`::"

msgid ">>> wheel_metadata = metadata('wheel')"
msgstr ">>> wheel_metadata = metadata('wheel')"

msgid ""
"The keys of the returned data structure name the metadata keywords, and the "
"values are returned unparsed from the distribution metadata::"
msgstr ""
"Nycklarna i den returnerade datastrukturen namnger nyckelorden i metadata "
"och värdena returneras oanalyserade från distributionsmetadata::"

msgid ""
">>> wheel_metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"
msgstr ""
">>> wheel_metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"

msgid ""
":class:`PackageMetadata` also presents a :attr:`!json` attribute that "
"returns all the metadata in a JSON-compatible form per :PEP:`566`::"
msgstr ""
":class:`PackageMetadata` har också ett :attr:`!json`-attribut som returnerar "
"alla metadata i JSON-kompatibel form enligt :PEP:`566`::"

msgid ""
">>> wheel_metadata.json['requires_python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"
msgstr ""
">>> wheel_metadata.json['requires_python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'"

msgid ""
"The full set of available metadata is not described here. See the PyPA `Core "
"metadata specification <https://packaging.python.org/en/latest/"
"specifications/core-metadata/#core-metadata>`_ for additional details."
msgstr ""
"Den fullständiga uppsättningen tillgängliga metadata beskrivs inte här. Se "
"PyPA:s `Core metadata specification <https://packaging.python.org/en/latest/"
"specifications/core-metadata/#core-metadata>`_ för ytterligare detaljer."

msgid ""
"The ``Description`` is now included in the metadata when presented through "
"the payload. Line continuation characters have been removed."
msgstr ""
"``Description`` ingår nu i metadata när den presenteras genom nyttolasten. "
"Radernas fortsättningstecken har tagits bort."

msgid "The ``json`` attribute was added."
msgstr "Attributet ``json`` har lagts till."

msgid "Distribution versions"
msgstr "Distribution av versioner"

msgid ""
"Return the installed distribution package `version <https://packaging.python."
"org/en/latest/specifications/core-metadata/#version>`__ for the named "
"distribution package."
msgstr ""
"Returnerar det installerade distributionspaketet `version <https://packaging."
"python.org/en/latest/specifications/core-metadata/#version>`__ för det "
"angivna distributionspaketet."

msgid ""
"The :func:`!version` function is the quickest way to get a `Distribution "
"Package <https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_'s version number, as a string::"
msgstr ""
"Funktionen :func:`!version` är det snabbaste sättet att få ett `Distribution "
"Package <https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_:s versionsnummer, som en sträng::"

msgid ""
">>> version('wheel')\n"
"'0.32.3'"
msgstr ""
">>> version('wheel')\n"
"'0.32.3'"

msgid "Distribution files"
msgstr "Distributionsfiler"

msgid ""
"Return the full set of files contained within the named distribution package."
msgstr ""
"Returnerar den fullständiga uppsättningen filer som ingår i det namngivna "
"distributionspaketet."

msgid ""
"Returns :const:`None` if the distribution is found but the installation "
"database records reporting the files associated with the distribution "
"package are missing."
msgstr ""
"Returnerar :const:`None` om distributionen hittas men installationsdatabasen "
"rapporterar att de filer som är associerade med distributionspaketet saknas."

msgid ""
"A :class:`pathlib.PurePath` derived object with additional ``dist``, "
"``size``, and ``hash`` properties corresponding to the distribution "
"package's installation metadata for that file."
msgstr ""
"Ett :class:`pathlib.PurePath`-deriverat objekt med ytterligare ``dist``-, "
"``size``- och ``hash``-egenskaper som motsvarar distributionspaketets "
"installationsmetadata för den filen."

msgid ""
"The :func:`!files` function takes a `Distribution Package <https://packaging."
"python.org/en/latest/glossary/#term-Distribution-Package>`_ name and returns "
"all of the files installed by this distribution. Each file is reported as a :"
"class:`PackagePath` instance. For example::"
msgstr ""
"Funktionen :func:`!files` tar ett namn på `Distribution Package <https://"
"packaging.python.org/en/latest/glossary/#term-Distribution-Package>`_ och "
"returnerar alla filer som installerats av denna distribution. Varje fil "
"rapporteras som en instans av :class:`PackagePath`. Till exempel::"

msgid ""
">>> util = [p for p in files('wheel') if 'util.py' in str(p)][0]\n"
">>> util\n"
"PackagePath('wheel/util.py')\n"
">>> util.size\n"
"859\n"
">>> util.dist\n"
"<importlib.metadata._hooks.PathDistribution object at 0x101e0cef0>\n"
">>> util.hash\n"
"<FileHash mode: sha256 value: bYkw5oMccfazVCoYQwKkkemoVyMAFoR34mmKBx8R1NI>"
msgstr ""
">>> util = [p for p in files('wheel') if 'util.py' in str(p)][0]\n"
">>> util\n"
"PackagePath('wheel/util.py')\n"
">>> util.size\n"
"859\n"
">>> util.dist\n"
"<importlib.metadata._hooks.PathDistribution object at 0x101e0cef0>\n"
">>> util.hash\n"
"<FileHash mode: sha256 value: bYkw5oMccfazVCoYQwKkkemoVyMAFoR34mmKBx8R1NI>"

msgid "Once you have the file, you can also read its contents::"
msgstr "När du har filen kan du också läsa dess innehåll::"

msgid ""
">>> print(util.read_text())\n"
"import base64\n"
"import sys\n"
"...\n"
"def as_bytes(s):\n"
"    if isinstance(s, text_type):\n"
"        return s.encode('utf-8')\n"
"    return s"
msgstr ""
">>> print(util.read_text())\n"
"import base64\n"
"import sys\n"
"...\n"
"def as_bytes(s):\n"
"    if isinstance(s, text_type):\n"
"        return s.encode('utf-8')\n"
"    return s"

msgid ""
"You can also use the :meth:`!locate` method to get the absolute path to the "
"file::"
msgstr ""
"Du kan också använda metoden :meth:`!locate` för att få den absoluta "
"sökvägen till filen::"

msgid ""
">>> util.locate()\n"
"PosixPath('/home/gustav/example/lib/site-packages/wheel/util.py')"
msgstr ""
">>> util.locate()\n"
"PosixPath('/home/gustav/example/lib/site-packages/wheel/util.py')"

msgid ""
"In the case where the metadata file listing files (``RECORD`` or ``SOURCES."
"txt``) is missing, :func:`!files` will return :const:`None`. The caller may "
"wish to wrap calls to :func:`!files` in `always_iterable <https://more-"
"itertools.readthedocs.io/en/stable/api.html#more_itertools."
"always_iterable>`_ or otherwise guard against this condition if the target "
"distribution is not known to have the metadata present."
msgstr ""
"I fallet där metadatafilen som listar filer (``RECORD`` eller ``SOURCES."
"txt``) saknas, kommer :func:`!files` att returnera :const:`None`. Den som "
"anropar kan vilja linda in anrop till :func:`!files` i `always_iterable "
"<https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools."
"always_iterable>`_ eller på annat sätt skydda sig mot detta villkor om det "
"inte är känt att måldistributionen har metadata närvarande."

msgid "Distribution requirements"
msgstr "Krav på distribution"

msgid ""
"Return the declared dependency specifiers for the named distribution package."
msgstr ""
"Returnerar de deklarerade beroendespecifikationerna för det namngivna "
"distributionspaketet."

msgid ""
"To get the full set of requirements for a `Distribution Package <https://"
"packaging.python.org/en/latest/glossary/#term-Distribution-Package>`_, use "
"the :func:`!requires` function::"
msgstr ""
"För att få den fullständiga uppsättningen krav för ett `Distributionspaket "
"<https://packaging.python.org/en/latest/glossary/#term-Distribution-"
"Package>`_, använd funktionen :func:`!requires`::"

msgid ""
">>> requires('wheel')\n"
"[\"pytest (>=3.0.0) ; extra == 'test'\", \"pytest-cov ; extra == 'test'\"]"
msgstr ""
">>> requires('wheel')\n"
"[\"pytest (>=3.0.0) ; extra == 'test'\", \"pytest-cov ; extra == 'test'\"]"

msgid "Mapping import to distribution packages"
msgstr "Mappning av import till distributionspaket"

msgid ""
"Return a mapping from the top level module and import package names found "
"via :data:`sys.meta_path` to the names of the distribution packages (if any) "
"that provide the corresponding files."
msgstr ""
"Returnerar en mappning från toppnivåmodulen och importpaketnamnen som hittas "
"via :data:`sys.meta_path` till namnen på distributionspaketen (om sådana "
"finns) som tillhandahåller motsvarande filer."

msgid ""
"To allow for namespace packages (which may have members provided by multiple "
"distribution packages), each top level import name maps to a list of "
"distribution names rather than mapping directly to a single name."
msgstr ""
"För att möjliggöra namnrymdspaket (som kan ha medlemmar som tillhandahålls "
"av flera distributionspaket) mappas varje importnamn på högsta nivån till en "
"lista med distributionsnamn i stället för att mappas direkt till ett enda "
"namn."

msgid ""
"A convenience method to resolve the `Distribution Package <https://packaging."
"python.org/en/latest/glossary/#term-Distribution-Package>`_ name (or names, "
"in the case of a namespace package) that provide each importable top-level "
"Python module or `Import Package <https://packaging.python.org/en/latest/"
"glossary/#term-Import-Package>`_::"
msgstr ""
"En bekvämlighetsmetod för att lösa `Distribution Package <https://packaging."
"python.org/en/latest/glossary/#term-Distribution-Package>`_-namnet (eller "
"namnen, i fallet med ett namnrymdspaket) som tillhandahåller varje "
"importerbar Python-modul på högsta nivån eller `Import Package <https://"
"packaging.python.org/en/latest/glossary/#term-Import-Package>`_::"

msgid ""
">>> packages_distributions()\n"
"{'importlib_metadata': ['importlib-metadata'], 'yaml': ['PyYAML'], 'jaraco': "
"['jaraco.classes', 'jaraco.functools'], ...}"
msgstr ""
">>> packages_distributions()\n"
"{'importlib_metadata': ['importlib-metadata'], 'yaml': ['PyYAML'], 'jaraco': "
"['jaraco.classes', 'jaraco.functools'], ...}"

msgid ""
"Some editable installs, `do not supply top-level names <https://github.com/"
"pypa/packaging-problems/issues/609>`_, and thus this function is not "
"reliable with such installs."
msgstr ""
"Vissa redigerbara installationer, `levererar inte toppnamn <https://github."
"com/pypa/packaging-problems/issues/609>`_, och därför är denna funktion inte "
"tillförlitlig med sådana installationer."

msgid "Distributions"
msgstr "Utdelningar"

msgid ""
"Return a :class:`Distribution` instance describing the named distribution "
"package."
msgstr ""
"Returnerar en :class:`Distribution`-instans som beskriver det namngivna "
"distributionspaketet."

msgid "Details of an installed distribution package."
msgstr "Detaljer om ett installerat distributionspaket."

msgid ""
"Note: different :class:`!Distribution` instances do not currently compare "
"equal, even if they relate to the same installed distribution and "
"accordingly have the same attributes."
msgstr ""
"Observera: olika :class:`!Distribution`-instanser jämförs för närvarande "
"inte på samma sätt, även om de hänför sig till samma installerade "
"distribution och därmed har samma attribut."

msgid ""
"While the module level API described above is the most common and convenient "
"usage, you can get all of that information from the :class:`!Distribution` "
"class. :class:`!Distribution` is an abstract object that represents the "
"metadata for a Python `Distribution Package <https://packaging.python.org/en/"
"latest/glossary/#term-Distribution-Package>`_. You can get the concrete :"
"class:`!Distribution` subclass instance for an installed distribution "
"package by calling the :func:`distribution` function::"
msgstr ""
"Även om API:et på modulnivå som beskrivs ovan är den vanligaste och mest "
"praktiska användningen, kan du få all denna information från klassen :class:"
"`!Distribution`. :class:`!Distribution` är ett abstrakt objekt som "
"representerar metadata för ett Python `Distribution Package <https://"
"packaging.python.org/en/latest/glossary/#term-Distribution-Package>`_. Du "
"kan få den konkreta :class:`!Distribution`-underklassinstansen för ett "
"installerat distributionspaket genom att anropa :func:`distribution`-"
"funktionen::"

msgid ""
">>> from importlib.metadata import distribution\n"
">>> dist = distribution('wheel')\n"
">>> type(dist)\n"
"<class 'importlib.metadata.PathDistribution'>"
msgstr ""
">>> from importlib.metadata import distribution\n"
">>> dist = distribution('wheel')\n"
">>> type(dist)\n"
"<class 'importlib.metadata.PathDistribution'>"

msgid ""
"Thus, an alternative way to get the version number is through the :class:`!"
"Distribution` instance::"
msgstr ""
"Ett alternativt sätt att få versionsnumret är alltså genom :class:`!"
"Distribution`-instansen::"

msgid ""
">>> dist.version\n"
"'0.32.3'"
msgstr ""
">>> dist.version\n"
"'0.32.3'"

msgid ""
"There are all kinds of additional metadata available on :class:`!"
"Distribution` instances::"
msgstr ""
"Det finns alla typer av ytterligare metadata tillgängliga för :class:`!"
"Distribution`-instanser::"

msgid ""
">>> dist.metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'\n"
">>> dist.metadata['License']\n"
"'MIT'"
msgstr ""
">>> dist.metadata['Requires-Python']\n"
"'>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'\n"
">>> dist.metadata['License']\n"
"'MIT'"

msgid ""
"For editable packages, an ``origin`` property may present :pep:`610` "
"metadata::"
msgstr ""
"För redigerbara paket kan en egenskap ``origin`` presentera :pep:`610`` "
"metadata::"

msgid ""
">>> dist.origin.url\n"
"'file:///path/to/wheel-0.32.3.editable-py3-none-any.whl'"
msgstr ""
">>> dist.origin.url\n"
"'file:///path/to/wheel-0.32.3.editable-py3-none-any.whl'"

msgid "The ``.origin`` property was added."
msgstr "Egenskapen ``.origin`` har lagts till."

msgid "Distribution Discovery"
msgstr "Distribution Discovery"

msgid ""
"By default, this package provides built-in support for discovery of metadata "
"for file system and zip file `Distribution Package <https://packaging.python."
"org/en/latest/glossary/#term-Distribution-Package>`_\\s. This metadata "
"finder search defaults to ``sys.path``, but varies slightly in how it "
"interprets those values from how other import machinery does. In particular:"
msgstr ""
"Som standard ger det här paketet inbyggt stöd för sökning av metadata för "
"filsystem och zip-filer `Distribution Package <https://packaging.python.org/"
"en/latest/glossary/#term-Distribution-Package>`_\\s. Denna metadatasökning "
"använder som standard ``sys.path``, men skiljer sig något i hur den tolkar "
"dessa värden från hur andra importmaskiner gör. I synnerhet:"

msgid ""
"``importlib.metadata`` does not honor :class:`bytes` objects on ``sys.path``."
msgstr ""
"``importlib.metadata`` respekterar inte :class:`bytes`-objekt på ``sys."
"path``."

msgid ""
"``importlib.metadata`` will incidentally honor :py:class:`pathlib.Path` "
"objects on ``sys.path`` even though such values will be ignored for imports."
msgstr ""
"``importlib.metadata`` kommer av en händelse att hedra :py:class:`pathlib."
"Path`-objekt på ``sys.path`` även om sådana värden kommer att ignoreras för "
"import."

msgid "Implementing Custom Providers"
msgstr "Implementering av anpassade providers"

msgid ""
"``importlib.metadata`` address two API surfaces, one for *consumers* and "
"another for *providers*. Most users are consumers, consuming metadata "
"provided by the packages. There are other use-cases, however, where users "
"wish to expose metadata through some other mechanism, such as alongside a "
"custom importer. Such a use case calls for a *custom provider*."
msgstr ""
"``importlib.metadata`` adresserar två API-ytor, en för *konsumenter* och en "
"annan för *leverantörer*. De flesta användare är konsumenter och konsumerar "
"metadata som tillhandahålls av paketen. Det finns dock andra användningsfall "
"där användare vill exponera metadata genom någon annan mekanism, t.ex. "
"tillsammans med en anpassad importör. Ett sådant användningsfall kräver en "
"*custom provider*."

msgid ""
"Because `Distribution Package <https://packaging.python.org/en/latest/"
"glossary/#term-Distribution-Package>`_ metadata is not available through :"
"data:`sys.path` searches, or package loaders directly, the metadata for a "
"distribution is found through import system :ref:`finders <finders-and-"
"loaders>`. To find a distribution package's metadata, ``importlib.metadata`` "
"queries the list of :term:`meta path finders <meta path finder>` on :data:"
"`sys.meta_path`."
msgstr ""
"Eftersom metadata för `Distributionspaket &lt;https://packaging.python.org/"
"en/latest/glossary/#term-Distribution-Package&gt;`_ inte är tillgängliga "
"via :data:`sys.path`-sökningar eller paketladdare direkt, hittas metadata "
"för en distribution via importsystemets :ref:`finders <finders-and-"
"loaders>`. För att hitta metadata för ett distributionspaket frågar "
"``importlib.metadata`` listan över :term:`meta path finders <meta path "
"finder>` på :data:`sys.meta_path`."

msgid ""
"The implementation has hooks integrated into the ``PathFinder``, serving "
"metadata for distribution packages found on the file system."
msgstr ""
"Implementeringen har krokar integrerade i ``PathFinder``, som serverar "
"metadata för distributionspaket som finns i filsystemet."

msgid ""
"The abstract class :py:class:`importlib.abc.MetaPathFinder` defines the "
"interface expected of finders by Python's import system. ``importlib."
"metadata`` extends this protocol by looking for an optional "
"``find_distributions`` callable on the finders from :data:`sys.meta_path` "
"and presents this extended interface as the ``DistributionFinder`` abstract "
"base class, which defines this abstract method::"
msgstr ""
"Den abstrakta klassen :py:class:`importlib.abc.MetaPathFinder` definierar "
"det gränssnitt som Pythons importsystem förväntar sig av sökare. ``importlib."
"metadata`` utökar detta protokoll genom att leta efter en valfri "
"``find_distributions`` anropbar på sökarna från :data:`sys.meta_path` och "
"presenterar detta utökade gränssnitt som den abstrakta basklassen "
"``DistributionFinder``, som definierar denna abstrakta metod::"

msgid ""
"@abc.abstractmethod\n"
"def find_distributions(context=DistributionFinder.Context()) -> "
"Iterable[Distribution]:\n"
"    \"\"\"Return an iterable of all Distribution instances capable of\n"
"    loading the metadata for packages for the indicated ``context``.\n"
"    \"\"\""
msgstr ""
"@abc.abstractmethod\n"
"def find_distributions(context=DistributionFinder.Context()) -> "
"Iterable[Distribution]:\n"
"    \"\"\"Return an iterable of all Distribution instances capable of\n"
"    loading the metadata for packages for the indicated ``context``.\n"
"    \"\"\""

msgid ""
"The ``DistributionFinder.Context`` object provides ``.path`` and ``.name`` "
"properties indicating the path to search and name to match and may supply "
"other relevant context sought by the consumer."
msgstr ""
"Objektet ``DistributionFinder.Context`` tillhandahåller egenskaperna ``."
"path`` och ``.name`` som anger sökvägen som ska sökas och namnet som ska "
"matchas och kan tillhandahålla annan relevant kontext som efterfrågas av "
"konsumenten."

msgid ""
"In practice, to support finding distribution package metadata in locations "
"other than the file system, subclass ``Distribution`` and implement the "
"abstract methods. Then from a custom finder, return instances of this "
"derived ``Distribution`` in the ``find_distributions()`` method."
msgstr ""
"I praktiken, för att stödja sökning av metadata för distributionspaket på "
"andra platser än filsystemet, kan du underordna dig ``Distribution`` och "
"implementera de abstrakta metoderna. Sedan från en anpassad sökare, "
"returnera instanser av denna härledda ``Distribution`` i metoden "
"``find_distributions()``."

msgid "Example"
msgstr "Exempel"

msgid "Imagine a custom finder that loads Python modules from a database::"
msgstr ""
"Tänk dig en anpassad sökare som laddar Python-moduler från en databas::"

msgid ""
"class DatabaseImporter(importlib.abc.MetaPathFinder):\n"
"    def __init__(self, db):\n"
"        self.db = db\n"
"\n"
"    def find_spec(self, fullname, target=None) -> ModuleSpec:\n"
"        return self.db.spec_from_name(fullname)\n"
"\n"
"sys.meta_path.append(DatabaseImporter(connect_db(...)))"
msgstr ""
"class DatabaseImporter(importlib.abc.MetaPathFinder):\n"
"    def __init__(self, db):\n"
"        self.db = db\n"
"\n"
"    def find_spec(self, fullname, target=None) -> ModuleSpec:\n"
"        return self.db.spec_from_name(fullname)\n"
"\n"
"sys.meta_path.append(DatabaseImporter(connect_db(...)))"

msgid ""
"That importer now presumably provides importable modules from a database, "
"but it provides no metadata or entry points. For this custom importer to "
"provide metadata, it would also need to implement ``DistributionFinder``::"
msgstr ""
"Den importören tillhandahåller nu antagligen importerbara moduler från en "
"databas, men den tillhandahåller inga metadata eller ingångspunkter. För att "
"denna anpassade importör ska kunna tillhandahålla metadata skulle den också "
"behöva implementera ``DistributionFinder``::"

msgid ""
"from importlib.metadata import DistributionFinder\n"
"\n"
"class DatabaseImporter(DistributionFinder):\n"
"    ...\n"
"\n"
"    def find_distributions(self, context=DistributionFinder.Context()):\n"
"        query = dict(name=context.name) if context.name else {}\n"
"        for dist_record in self.db.query_distributions(query):\n"
"            yield DatabaseDistribution(dist_record)"
msgstr ""
"from importlib.metadata import DistributionFinder\n"
"\n"
"class DatabaseImporter(DistributionFinder):\n"
"    ...\n"
"\n"
"    def find_distributions(self, context=DistributionFinder.Context()):\n"
"        query = dict(name=context.name) if context.name else {}\n"
"        for dist_record in self.db.query_distributions(query):\n"
"            yield DatabaseDistribution(dist_record)"

msgid ""
"In this way, ``query_distributions`` would return records for each "
"distribution served by the database matching the query. For example, if "
"``requests-1.0`` is in the database, ``find_distributions`` would yield a "
"``DatabaseDistribution`` for ``Context(name='requests')`` or "
"``Context(name=None)``."
msgstr ""
"På detta sätt skulle ``query_distributions`` returnera poster för varje "
"distribution som betjänas av den databas som matchar frågan. Om till exempel "
"``requests-1.0`` finns i databasen, skulle ``find_distributions`` ge en "
"``DatabaseDistribution`` för ``Context(name='requests')`` eller "
"``Context(name=None)``."

msgid ""
"For the sake of simplicity, this example ignores ``context.path``\\. The "
"``path`` attribute defaults to ``sys.path`` and is the set of import paths "
"to be considered in the search. A ``DatabaseImporter`` could potentially "
"function without any concern for a search path. Assuming the importer does "
"no partitioning, the \"path\" would be irrelevant. In order to illustrate "
"the purpose of ``path``, the example would need to illustrate a more complex "
"``DatabaseImporter`` whose behavior varied depending on ``sys.path``/"
"``PYTHONPATH``. In that case, the ``find_distributions`` should honor the "
"``context.path`` and only yield ``Distribution``\\ s pertinent to that path."
msgstr ""
"För enkelhetens skull ignoreras ``context.path`` i detta exempel. Attributet "
"``path`` har ```sys.path`` som standard och är den uppsättning "
"importsökvägar som ska beaktas vid sökningen. En ``DatabaseImporter`` kan "
"potentiellt fungera utan att behöva bry sig om en sökväg. Förutsatt att "
"importören inte gör någon partitionering, skulle \"sökvägen\" vara "
"irrelevant. För att illustrera syftet med ``path`` skulle exemplet behöva "
"illustrera en mer komplex ``DatabaseImporter`` vars beteende varierade "
"beroende på ``sys.path``/`PYTHONPATH``. I så fall bör ``find_distributions`` "
"respektera ``context.path`` och endast ge ``Distribution`` som är relevanta "
"för den sökvägen."

msgid "``DatabaseDistribution``, then, would look something like::"
msgstr "``DatabaseDistribution`` skulle då se ut ungefär som::"

msgid ""
"class DatabaseDistribution(importlib.metadata.Distribution):\n"
"    def __init__(self, record):\n"
"        self.record = record\n"
"\n"
"    def read_text(self, filename):\n"
"        \"\"\"\n"
"        Read a file like \"METADATA\" for the current distribution.\n"
"        \"\"\"\n"
"        if filename == \"METADATA\":\n"
"            return f\"\"\"Name: {self.record.name}\n"
"Version: {self.record.version}\n"
"\"\"\"\n"
"        if filename == \"entry_points.txt\":\n"
"            return \"\\n\".join(\n"
"              f\"\"\"[{ep.group}]\\n{ep.name}={ep.value}\"\"\"\n"
"              for ep in self.record.entry_points)\n"
"\n"
"    def locate_file(self, path):\n"
"        raise RuntimeError(\"This distribution has no file system\")"
msgstr ""
"class DatabaseDistribution(importlib.metadata.Distribution):\n"
"    def __init__(self, record):\n"
"        self.record = record\n"
"\n"
"    def read_text(self, filename):\n"
"        \"\"\"\n"
"        Read a file like \"METADATA\" for the current distribution.\n"
"        \"\"\"\n"
"        if filename == \"METADATA\":\n"
"            return f\"\"\"Name: {self.record.name}\n"
"Version: {self.record.version}\n"
"\"\"\"\n"
"        if filename == \"entry_points.txt\":\n"
"            return \"\\n\".join(\n"
"              f\"\"\"[{ep.group}]\\n{ep.name}={ep.value}\"\"\"\n"
"              for ep in self.record.entry_points)\n"
"\n"
"    def locate_file(self, path):\n"
"        raise RuntimeError(\"This distribution has no file system\")"

msgid ""
"This basic implementation should provide metadata and entry points for "
"packages served by the ``DatabaseImporter``, assuming that the ``record`` "
"supplies suitable ``.name``, ``.version``, and ``.entry_points`` attributes."
msgstr ""
"Denna grundläggande implementering bör tillhandahålla metadata och "
"ingångspunkter för paket som betjänas av ``DatabaseImporter``, förutsatt att "
"``record`` tillhandahåller lämpliga attribut för ``.name``, ``.version`` och "
"``.entry_points``."

msgid ""
"The ``DatabaseDistribution`` may also provide other metadata files, like "
"``RECORD`` (required for ``Distribution.files``) or override the "
"implementation of ``Distribution.files``. See the source for more "
"inspiration."
msgstr ""
"``DatabaseDistribution`` kan också tillhandahålla andra metadatafiler, som "
"``RECORD`` (krävs för ``Distribution.files``) eller åsidosätta "
"implementeringen av ``Distribution.files``. Se källan för mer inspiration."
