# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Futures"
msgstr "Futures"

msgid ""
"**Source code:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"
msgstr ""
"**Källkod:** :source:`Lib/asyncio/futures.py`, :source:`Lib/asyncio/"
"base_futures.py`"

msgid ""
"*Future* objects are used to bridge **low-level callback-based code** with "
"high-level async/await code."
msgstr ""
"*Future*-objekt används för att överbrygga **kallelsebaserad kod på låg "
"nivå** med async/await-kod på hög nivå."

msgid "Future Functions"
msgstr "Framtida funktioner"

msgid "Return ``True`` if *obj* is either of:"
msgstr "Returnera ``True`` om *obj* är något av:"

msgid "an instance of :class:`asyncio.Future`,"
msgstr "en instans av :class:`asyncio.Future`,"

msgid "an instance of :class:`asyncio.Task`,"
msgstr "en instans av :class:`asyncio.Task`,"

msgid "a Future-like object with a ``_asyncio_future_blocking`` attribute."
msgstr ""
"ett Future-liknande objekt med attributet ``_asyncio_future_blocking``."

msgid "Return:"
msgstr "Returnera:"

msgid ""
"*obj* argument as is, if *obj* is a :class:`Future`, a :class:`Task`, or a "
"Future-like object (:func:`isfuture` is used for the test.)"
msgstr ""
"*obj* argument som det är, om *obj* är en :class:`Future`, en :class:`Task`, "
"eller ett Future-liknande objekt (:func:`isfuture` används för testet.)"

msgid ""
"a :class:`Task` object wrapping *obj*, if *obj* is a coroutine (:func:"
"`iscoroutine` is used for the test); in this case the coroutine will be "
"scheduled by ``ensure_future()``."
msgstr ""
"ett :class:`Task`-objekt som omsluter *obj*, om *obj* är en coroutine (:func:"
"`iscoroutine` används för testet); i detta fall kommer coroutinen att "
"schemaläggas med ``ensure_future()``."

msgid ""
"a :class:`Task` object that would await on *obj*, if *obj* is an awaitable (:"
"func:`inspect.isawaitable` is used for the test.)"
msgstr ""
"ett :class:`Task`-objekt som skulle awaita på *obj*, om *obj* är en "
"awaitable (:func:`inspect.isawaitable` används för testet.)"

msgid "If *obj* is neither of the above a :exc:`TypeError` is raised."
msgstr ""
"Om *obj* inte är någon av de ovan nämnda händelserna uppstår ett :exc:"
"`TypeError`."

msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution."
msgstr ""
"Spara en referens till resultatet av denna funktion, för att undvika att en "
"uppgift försvinner mitt under utförandet."

msgid ""
"See also the :func:`create_task` function which is the preferred way for "
"creating new tasks or use :class:`asyncio.TaskGroup` which keeps reference "
"to the task internally."
msgstr ""
"Se även funktionen :func:`create_task` som är det föredragna sättet att "
"skapa nya uppgifter eller använd :class:`asyncio.TaskGroup` som håller "
"referensen till uppgiften internt."

msgid "The function accepts any :term:`awaitable` object."
msgstr "Funktionen accepterar alla :term:`awaitable`-objekt."

msgid ""
"Deprecation warning is emitted if *obj* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Deprecation-varning utfärdas om *obj* inte är ett Future-liknande objekt och "
"*loop* inte anges och det inte finns någon pågående händelseslinga."

msgid ""
"Wrap a :class:`concurrent.futures.Future` object in a :class:`asyncio."
"Future` object."
msgstr ""
"Packa in ett :class:`concurrent.futures.Future`-objekt i ett :class:`asyncio."
"Future`-objekt."

msgid ""
"Deprecation warning is emitted if *future* is not a Future-like object and "
"*loop* is not specified and there is no running event loop."
msgstr ""
"Deprecation-varning utfärdas om *future* inte är ett Future-liknande objekt "
"och *loop* inte anges och det inte finns någon pågående händelseslinga."

msgid "Future Object"
msgstr "Framtida objekt"

msgid ""
"A Future represents an eventual result of an asynchronous operation.  Not "
"thread-safe."
msgstr ""
"En Future representerar ett eventuellt resultat av en asynkron operation.  "
"Inte tråd-säker."

msgid ""
"Future is an :term:`awaitable` object.  Coroutines can await on Future "
"objects until they either have a result or an exception set, or until they "
"are cancelled. A Future can be awaited multiple times and the result is same."
msgstr ""
"Future är ett :term:`awaitable`-objekt.  Coroutines kan vänta på Future-"
"objekt tills de antingen har ett resultat eller ett undantag inställt, eller "
"tills de avbryts. En Future kan väntas flera gånger och resultatet blir "
"detsamma."

msgid ""
"Typically Futures are used to enable low-level callback-based code (e.g. in "
"protocols implemented using asyncio :ref:`transports <asyncio-transports-"
"protocols>`) to interoperate with high-level async/await code."
msgstr ""
"Futures används vanligtvis för att göra det möjligt för callback-baserad kod "
"på låg nivå (t.ex. i protokoll som implementeras med asyncio :ref:"
"`transports <asyncio-transports-protocols>`) att samverka med async/await-"
"kod på hög nivå."

msgid ""
"The rule of thumb is to never expose Future objects in user-facing APIs, and "
"the recommended way to create a Future object is to call :meth:`loop."
"create_future`.  This way alternative event loop implementations can inject "
"their own optimized implementations of a Future object."
msgstr ""
"Tumregeln är att aldrig exponera Future-objekt i API:er som vänder sig till "
"användare, och det rekommenderade sättet att skapa ett Future-objekt är att "
"anropa :meth:`loop.create_future`.  På så sätt kan alternativa "
"implementeringar av händelseslingor injicera sina egna optimerade "
"implementeringar av ett Future-objekt."

msgid "Added support for the :mod:`contextvars` module."
msgstr "Lagt till stöd för modulen :mod:`contextvars`."

msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Deprecation-varning utfärdas om *loop* inte anges och det inte finns någon "
"pågående händelseslinga."

msgid "Return the result of the Future."
msgstr "Returnera resultatet av Future."

msgid ""
"If the Future is *done* and has a result set by the :meth:`set_result` "
"method, the result value is returned."
msgstr ""
"Om Future är *done* och har ett resultat som ställts in med metoden :meth:"
"`set_result`, returneras resultatvärdet."

msgid ""
"If the Future is *done* and has an exception set by the :meth:"
"`set_exception` method, this method raises the exception."
msgstr ""
"Om Future är *done* och har ett undantag som ställts in med metoden :meth:"
"`set_exception`, kommer undantaget att tas upp med denna metod."

msgid ""
"If the Future has been *cancelled*, this method raises a :exc:"
"`CancelledError` exception."
msgstr ""
"Om framtiden har *avbrutits*, ger denna metod upphov till ett :exc:"
"`CancelledError`-undantag."

msgid ""
"If the Future's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Om framtidens resultat ännu inte är tillgängligt, ger denna metod upphov "
"till ett :exc:`InvalidStateError`-undantag."

msgid "Mark the Future as *done* and set its result."
msgstr "Markera Future som *utförd* och ange dess resultat."

msgid ""
"Raises an :exc:`InvalidStateError` error if the Future is already *done*."
msgstr "Utlöser ett :exc:`InvalidStateError`-fel om Future redan är *done*."

msgid "Mark the Future as *done* and set an exception."
msgstr "Markera Future som *done* och ställ in ett undantag."

msgid "Return ``True`` if the Future is *done*."
msgstr "Returnerar ``True`` om framtiden är *done*."

msgid ""
"A Future is *done* if it was *cancelled* or if it has a result or an "
"exception set with :meth:`set_result` or :meth:`set_exception` calls."
msgstr ""
"En Future är *done* om den *cancelled* eller om den har ett resultat eller "
"ett undantag som ställts in med :meth:`set_result` eller :meth:"
"`set_exception` anrop."

msgid "Return ``True`` if the Future was *cancelled*."
msgstr "Returnerar ``True`` om Framtiden var *avbruten*."

msgid ""
"The method is usually used to check if a Future is not *cancelled* before "
"setting a result or an exception for it::"
msgstr ""
"Metoden används vanligtvis för att kontrollera om en Future inte är "
"*cancelled* innan ett resultat eller ett undantag anges för den::"

msgid ""
"if not fut.cancelled():\n"
"    fut.set_result(42)"
msgstr ""
"om inte fut.cancelled():\n"
"    fut.set_result(42)"

msgid "Add a callback to be run when the Future is *done*."
msgstr "Lägg till en återuppringning som ska köras när Future är *done*."

msgid "The *callback* is called with the Future object as its only argument."
msgstr "*Callback* anropas med Future-objektet som enda argument."

msgid ""
"If the Future is already *done* when this method is called, the callback is "
"scheduled with :meth:`loop.call_soon`."
msgstr ""
"Om Future redan är *färdig* när den här metoden anropas, schemaläggs "
"återuppringningen med :meth:`loop.call_soon`."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *callback* ska köras i. "
"Den aktuella kontexten används när ingen *kontext* anges."

msgid ""
":func:`functools.partial` can be used to pass parameters to the callback, e."
"g.::"
msgstr ""
":func:`functools.partial` kan användas för att skicka parametrar till "
"återuppringningen, t.ex.::"

msgid ""
"# Call 'print(\"Future:\", fut)' when \"fut\" is done.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Future:\"))"
msgstr ""
"# Call 'print(\"Future:\", fut)' when \"fut\" is done.\n"
"fut.add_done_callback(\n"
"    functools.partial(print, \"Future:\"))"

msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Parametern *context* (endast nyckelord) har lagts till. Se :pep:`567` för "
"mer information."

msgid "Remove *callback* from the callbacks list."
msgstr "Ta bort *callback* från listan över callbacks."

msgid ""
"Returns the number of callbacks removed, which is typically 1, unless a "
"callback was added more than once."
msgstr ""
"Returnerar antalet borttagna återuppringningar, vilket vanligtvis är 1, "
"såvida inte en återuppringning har lagts till mer än en gång."

msgid "Cancel the Future and schedule callbacks."
msgstr "Avbryt Future och schemalägg callbacks."

msgid ""
"If the Future is already *done* or *cancelled*, return ``False``. Otherwise, "
"change the Future's state to *cancelled*, schedule the callbacks, and return "
"``True``."
msgstr ""
"Om framtiden redan är *done* eller *cancelled*, returneras ``False``. I "
"annat fall ändras Framtidens tillstånd till *avbruten*, schemalägger "
"återuppringningarna och returnerar ``True``."

msgid "Added the *msg* parameter."
msgstr "Parametern *msg* har lagts till."

msgid "Return the exception that was set on this Future."
msgstr "Returnerar det undantag som ställdes in för denna Future."

msgid ""
"The exception (or ``None`` if no exception was set) is returned only if the "
"Future is *done*."
msgstr ""
"Undantaget (eller ``None`` om inget undantag har angetts) returneras endast "
"om Future är *done*."

msgid ""
"If the Future isn't *done* yet, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Om Future inte är *färdig* ännu, ger denna metod upphov till ett :exc:"
"`InvalidStateError`-undantag."

msgid "Return the event loop the Future object is bound to."
msgstr "Returnerar den händelseslinga som Future-objektet är bundet till."

msgid ""
"This example creates a Future object, creates and schedules an asynchronous "
"Task to set result for the Future, and waits until the Future has a result::"
msgstr ""
"I det här exemplet skapas ett Future-objekt, en asynkron Task skapas och "
"schemaläggs för att ange resultat för Future och väntar tills Future har ett "
"resultat::"

msgid ""
"async def set_after(fut, delay, value):\n"
"    # Sleep for *delay* seconds.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # Set *value* as a result of *fut* Future.\n"
"    fut.set_result(value)\n"
"\n"
"async def main():\n"
"    # Get the current event loop.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a new Future object.\n"
"    fut = loop.create_future()\n"
"\n"
"    # Run \"set_after()\" coroutine in a parallel Task.\n"
"    # We are using the low-level \"loop.create_task()\" API here because\n"
"    # we already have a reference to the event loop at hand.\n"
"    # Otherwise we could have just used \"asyncio.create_task()\".\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... world'))\n"
"\n"
"    print('hello ...')\n"
"\n"
"    # Wait until *fut* has a result (1 second) and print it.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def set_after(fut, delay, value):\n"
"    # Sleep for *delay* seconds.\n"
"    await asyncio.sleep(delay)\n"
"\n"
"    # Set *value* as a result of *fut* Future.\n"
"    fut.set_result(value)\n"
"\n"
"async def main():\n"
"    # Get the current event loop.\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Create a new Future object.\n"
"    fut = loop.create_future()\n"
"\n"
"    # Run \"set_after()\" coroutine in a parallel Task.\n"
"    # We are using the low-level \"loop.create_task()\" API here because\n"
"    # we already have a reference to the event loop at hand.\n"
"    # Otherwise we could have just used \"asyncio.create_task()\".\n"
"    loop.create_task(\n"
"        set_after(fut, 1, '... world'))\n"
"\n"
"    print('hello ...')\n"
"\n"
"    # Wait until *fut* has a result (1 second) and print it.\n"
"    print(await fut)\n"
"\n"
"asyncio.run(main())"

msgid ""
"The Future object was designed to mimic :class:`concurrent.futures.Future`.  "
"Key differences include:"
msgstr ""
"Future-objektet har utformats för att efterlikna :class:`concurrent.futures."
"Future`.  Viktiga skillnader inkluderar:"

msgid ""
"unlike asyncio Futures, :class:`concurrent.futures.Future` instances cannot "
"be awaited."
msgstr ""
"till skillnad från asyncio Futures, kan :class:`concurrent.futures.Future`-"
"instanser inte inväntas."

msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` do not "
"accept the *timeout* argument."
msgstr ""
":meth:`asyncio.Future.result` och :meth:`asyncio.Future.exception` "
"accepterar inte argumentet *timeout*."

msgid ""
":meth:`asyncio.Future.result` and :meth:`asyncio.Future.exception` raise an :"
"exc:`InvalidStateError` exception when the Future is not *done*."
msgstr ""
":meth:`asyncio.Future.result` och :meth:`asyncio.Future.exception` ger "
"upphov till ett :exc:`InvalidStateError` undantag när framtiden inte är "
"*done*."

msgid ""
"Callbacks registered with :meth:`asyncio.Future.add_done_callback` are not "
"called immediately.  They are scheduled with :meth:`loop.call_soon` instead."
msgstr ""
"Återanrop som registrerats med :meth:`asyncio.Future.add_done_callback` "
"anropas inte omedelbart.  De schemaläggs med :meth:`loop.call_soon` istället."

msgid ""
"asyncio Future is not compatible with the :func:`concurrent.futures.wait` "
"and :func:`concurrent.futures.as_completed` functions."
msgstr ""
"asyncio Future är inte kompatibel med funktionerna :func:`concurrent.futures."
"wait` och :func:`concurrent.futures.as_completed`."

msgid ""
":meth:`asyncio.Future.cancel` accepts an optional ``msg`` argument, but :"
"meth:`concurrent.futures.Future.cancel` does not."
msgstr ""
":meth:`asyncio.Future.cancel` accepterar ett valfritt ``msg`` argument, men :"
"meth:`concurrent.futures.Future.cancel` gör det inte."
