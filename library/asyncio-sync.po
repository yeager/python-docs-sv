# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Synchronization Primitives"
msgstr "Synkroniseringsprimitiver"

msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/locks.py`"

msgid ""
"asyncio synchronization primitives are designed to be similar to those of "
"the :mod:`threading` module with two important caveats:"
msgstr ""
"asyncios synkroniseringsprimitiver är utformade för att likna dem i modulen :"
"mod:`threading` med två viktiga förbehåll:"

msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used "
"for OS thread synchronization (use :mod:`threading` for that);"
msgstr ""
"asyncioprimitiver är inte trådsäkra, därför bör de inte användas för "
"synkronisering av OS-trådar (använd :mod:`threading` för det);"

msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations "
"with timeouts."
msgstr ""
"metoderna för dessa synkroniseringsprimitiver accepterar inte argumentet "
"*timeout*; använd funktionen :func:`asyncio.wait_for` för att utföra "
"operationer med timeouts."

msgid "asyncio has the following basic synchronization primitives:"
msgstr "asyncio har följande grundläggande synkroniseringsprimitiver:"

msgid ":class:`Lock`"
msgstr ":class:`Lock`"

msgid ":class:`Event`"
msgstr ":class:`Event`"

msgid ":class:`Condition`"
msgstr ":class:`Condition`"

msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

msgid ":class:`Barrier`"
msgstr ":class:`Barrier`"

msgid "Lock"
msgstr "Lås"

msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr "Implementerar ett mutex-lås för asyncio-uppgifter.  Inte tråd-säker."

msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr ""
"Ett asynciolås kan användas för att garantera exklusiv tillgång till en "
"delad resurs."

msgid "The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr ""
"Det föredragna sättet att använda ett Lock är en :nyckelord:`async with`-"
"sats::"

msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"async with lock:\n"
"    # access shared state"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"async with lock:\n"
"    # access shared state"

msgid "which is equivalent to::"
msgstr "vilket är likvärdigt med::"

msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"await lock.acquire()\n"
"try:\n"
"    # access shared state\n"
"finally:\n"
"    lock.release()"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"await lock.acquire()\n"
"try:\n"
"    # access shared state\n"
"finally:\n"
"    lock.release()"

msgid "Removed the *loop* parameter."
msgstr "Parametern *loop* har tagits bort."

msgid "Acquire the lock."
msgstr "Förvärva låset."

msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr ""
"Den här metoden väntar tills låset är *unlocked*, sätter det till *locked* "
"och returnerar ``True``."

msgid ""
"When more than one coroutine is blocked in :meth:`acquire` waiting for the "
"lock to be unlocked, only one coroutine eventually proceeds."
msgstr ""
"När mer än en coroutine blockeras i :meth:`acquire` i väntan på att låset "
"ska låsas upp, fortsätter bara en coroutine till slut."

msgid ""
"Acquiring a lock is *fair*: the coroutine that proceeds will be the first "
"coroutine that started waiting on the lock."
msgstr ""
"Att förvärva ett lås är *rättvist*: den coroutine som fortsätter kommer att "
"vara den första coroutine som började vänta på låset."

msgid "Release the lock."
msgstr "Lossa låset."

msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr "När låset är *locked*, återställ det till *unlocked* och returnera."

msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr "Om låset är *olåst* uppstår ett :exc:`RuntimeError`."

msgid "Return ``True`` if the lock is *locked*."
msgstr "Returnerar ``True`` om låset är *locked*."

msgid "Event"
msgstr "Event"

msgid "An event object.  Not thread-safe."
msgstr "Ett händelseobjekt.  Inte tråd-säkert."

msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr ""
"En asynciohändelse kan användas för att meddela flera asynciouppgifter att "
"en händelse har inträffat."

msgid ""
"An Event object manages an internal flag that can be set to *true* with the :"
"meth:`~Event.set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is set to "
"*true*.  The flag is set to *false* initially."
msgstr ""
"Ett Event-objekt hanterar en intern flagga som kan sättas till *true* med "
"metoden :meth:`~Event.set` och återställas till *false* med metoden :meth:"
"`clear`.  Metoden :meth:`~Event.wait` blockerar tills flaggan är satt till "
"*true*.  Flaggan är initialt satt till *false*."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # Create an Event object.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Spawn a Task to wait until 'event' is set.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Sleep for 1 second and set the event.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Wait until the waiter task is finished.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # Create an Event object.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Spawn a Task to wait until 'event' is set.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Sleep for 1 second and set the event.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Wait until the waiter task is finished.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"

msgid "Wait until the event is set."
msgstr "Vänta tills händelsen är inställd."

msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`~Event.set`."
msgstr ""
"Om händelsen är inställd, returnera ``True`` omedelbart. Annars blockeras "
"tills en annan uppgift anropar :meth:`~Event.set`."

msgid "Set the event."
msgstr "Ställ in händelsen."

msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr ""
"Alla uppgifter som väntar på att händelsen ska aktiveras kommer omedelbart "
"att väckas."

msgid "Clear (unset) the event."
msgstr "Rensa (avmarkera) händelsen."

msgid ""
"Tasks awaiting on :meth:`~Event.wait` will now block until the :meth:`~Event."
"set` method is called again."
msgstr ""
"Uppgifter som väntar på :meth:`~Event.wait` kommer nu att blockeras tills "
"metoden :meth:`~Event.set` anropas igen."

msgid "Return ``True`` if the event is set."
msgstr "Returnerar ``True`` om händelsen är inställd."

msgid "Condition"
msgstr "Villkor"

msgid "A Condition object.  Not thread-safe."
msgstr "Ett Condition-objekt.  Inte tråd-säkert."

msgid ""
"An asyncio condition primitive can be used by a task to wait for some event "
"to happen and then get exclusive access to a shared resource."
msgstr ""
"En asyncio-villkorsprimitiv kan användas av en uppgift för att vänta på att "
"en händelse ska inträffa och sedan få exklusiv tillgång till en delad resurs."

msgid ""
"In essence, a Condition object combines the functionality of an :class:"
"`Event` and a :class:`Lock`.  It is possible to have multiple Condition "
"objects share one Lock, which allows coordinating exclusive access to a "
"shared resource between different tasks interested in particular states of "
"that shared resource."
msgstr ""
"I huvudsak kombinerar ett Condition-objekt funktionaliteten hos en :class:"
"`Event` och en :class:`Lock`.  Det är möjligt att låta flera Condition-"
"objekt dela ett Lock, vilket gör det möjligt att samordna exklusiv tillgång "
"till en delad resurs mellan olika uppgifter som är intresserade av särskilda "
"tillstånd för den delade resursen."

msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``.  In "
"the latter case a new Lock object is created automatically."
msgstr ""
"Det valfria *lock*-argumentet måste vara ett :class:`Lock`-objekt eller "
"``None``.  I det senare fallet skapas ett nytt Lock-objekt automatiskt."

msgid ""
"The preferred way to use a Condition is an :keyword:`async with` statement::"
msgstr ""
"Det föredragna sättet att använda ett villkor är en :nyckelord:`async with`-"
"sats::"

msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"async with cond:\n"
"    await cond.wait()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"async with cond:\n"
"    await cond.wait()"

msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"

msgid "Acquire the underlying lock."
msgstr "Förvärva det underliggande låset."

msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr ""
"Denna metod väntar tills det underliggande låset är *unlocked*, sätter det "
"till *locked* och returnerar ``True``."

msgid ""
"Wake up *n* tasks (1 by default) waiting on this condition.  If fewer than "
"*n* tasks are waiting they are all awakened."
msgstr ""
"Väck *n* uppgifter (1 som standard) som väntar på detta villkor.  Om färre "
"än *n* uppgifter väntar väcks de alla."

msgid ""
"The lock must be acquired before this method is called and released shortly "
"after.  If called with an *unlocked* lock a :exc:`RuntimeError` error is "
"raised."
msgstr ""
"Låset måste förvärvas innan denna metod anropas och släppas kort därefter.  "
"Om metoden anropas med ett *olåst* lås kommer ett :exc:`RuntimeError`-fel "
"att uppstå."

msgid "Return ``True`` if the underlying lock is acquired."
msgstr "Returnerar ``True`` om det underliggande låset är förvärvat."

msgid "Wake up all tasks waiting on this condition."
msgstr "Väck alla uppgifter som väntar på detta villkor."

msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr ""
"Den här metoden fungerar som :meth:`notify`, men väcker alla väntande "
"uppgifter."

msgid "Release the underlying lock."
msgstr "Lossa det underliggande låset."

msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr "När den anropas på ett olåst lås uppstår ett :exc:`RuntimeError`."

msgid "Wait until notified."
msgstr "Vänta tills du får besked."

msgid ""
"If the calling task has not acquired the lock when this method is called, a :"
"exc:`RuntimeError` is raised."
msgstr ""
"Om den anropande uppgiften inte har förvärvat låset när denna metod anropas, "
"uppstår ett :exc:`RuntimeError`."

msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, the "
"Condition re-acquires its lock and this method returns ``True``."
msgstr ""
"Den här metoden frigör det underliggande låset och blockerar sedan tills den "
"väcks av ett anrop från :meth:`notify` eller :meth:`notify_all`. När den har "
"väckts återtar Condition sitt lås och denna metod returnerar ``True``."

msgid ""
"Note that a task *may* return from this call spuriously, which is why the "
"caller should always re-check the state and be prepared to :meth:`~Condition."
"wait` again. For this reason, you may prefer to use :meth:`~Condition."
"wait_for` instead."
msgstr ""
"Observera att en uppgift *kan* återvända från detta anrop på ett felaktigt "
"sätt, vilket är anledningen till att anroparen alltid bör kontrollera "
"tillståndet igen och vara beredd att :meth:`~Condition.wait` igen. Av denna "
"anledning kanske du föredrar att använda :meth:`~Condition.wait_for` "
"istället."

msgid "Wait until a predicate becomes *true*."
msgstr "Vänta tills ett predikat blir *sant*."

msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The method will repeatedly :meth:`~Condition.wait` until the "
"predicate evaluates to *true*. The final value is the return value."
msgstr ""
"Predikatet måste vara en callable vars resultat kommer att tolkas som ett "
"booleskt värde.  Metoden kommer att upprepa :meth:`~Condition.wait` tills "
"predikatet utvärderas till *true*. Det slutliga värdet är returvärdet."

msgid "Semaphore"
msgstr "Semafor"

msgid "A Semaphore object.  Not thread-safe."
msgstr "Ett semaforobjekt.  Inte tråd-säkert."

msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`acquire` call and incremented by each :meth:`release` call. The counter can "
"never go below zero; when :meth:`acquire` finds that it is zero, it blocks, "
"waiting until some task calls :meth:`release`."
msgstr ""
"En semafor hanterar en intern räknare som decimeras vid varje anrop av :meth:"
"`acquire` och ökas vid varje anrop av :meth:`release`. Räknaren kan aldrig "
"gå under noll; när :meth:`acquire` upptäcker att den är noll blockeras den "
"och väntar tills någon uppgift anropar :meth:`release`."

msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a :exc:"
"`ValueError` is raised."
msgstr ""
"Det valfria argumentet *value* anger det initiala värdet för den interna "
"räknaren (``1`` som standard). Om det angivna värdet är mindre än ``0`` "
"uppstår ett :exc:`ValueError`."

msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` statement::"
msgstr ""
"Det föredragna sättet att använda en semafor är en :keyword:`async with`-"
"sats::"

msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"async with sem:\n"
"    # work with shared resource"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"async with sem:\n"
"    # work with shared resource"

msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"await sem.acquire()\n"
"try:\n"
"    # work with shared resource\n"
"finally:\n"
"    sem.release()"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"await sem.acquire()\n"
"try:\n"
"    # work with shared resource\n"
"finally:\n"
"    sem.release()"

msgid "Acquire a semaphore."
msgstr "Förvärva en semafor."

msgid ""
"If the internal counter is greater than zero, decrement it by one and return "
"``True`` immediately.  If it is zero, wait until a :meth:`release` is called "
"and return ``True``."
msgstr ""
"Om den interna räknaren är större än noll, decimera den med ett och "
"returnera ``True`` omedelbart.  Om den är noll, vänta tills en :meth:"
"`release` anropas och returnera ``True``."

msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr "Returnerar ``True`` om semaforen inte kan förvärvas omedelbart."

msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake up a "
"task waiting to acquire the semaphore."
msgstr ""
"Frigör en semafor, vilket ökar den interna räknaren med ett steg. Kan väcka "
"en uppgift som väntar på att förvärva semaforen."

msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""
"Till skillnad från :class:`BoundedSemaphore` tillåter :class:`Semaphore` "
"fler ``release()``-anrop än ``acquire()``-anrop."

msgid "BoundedSemaphore"
msgstr "BoundedSemaphore"

msgid "A bounded semaphore object.  Not thread-safe."
msgstr "Ett avgränsat semaforobjekt.  Inte tråd-säkert."

msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a :exc:"
"`ValueError` in :meth:`~Semaphore.release` if it increases the internal "
"counter above the initial *value*."
msgstr ""
"Bounded Semaphore är en version av :class:`Semaphore` som ger upphov till "
"ett :exc:`ValueError` i :meth:`~Semaphore.release` om den ökar den interna "
"räknaren över det ursprungliga *värdet*."

msgid "Barrier"
msgstr "Barrier"

msgid "A barrier object.  Not thread-safe."
msgstr "Ett barriärobjekt.  Inte tråd-säkert."

msgid ""
"A barrier is a simple synchronization primitive that allows to block until "
"*parties* number of tasks are waiting on it. Tasks can wait on the :meth:"
"`~Barrier.wait` method and would be blocked until the specified number of "
"tasks end up waiting on :meth:`~Barrier.wait`. At that point all of the "
"waiting tasks would unblock simultaneously."
msgstr ""
"En barriär är en enkel synkroniseringsprimitiv som gör det möjligt att "
"blockera tills *parties* antal uppgifter väntar på den. Uppgifter kan vänta "
"på :meth:`~Barrier.wait`-metoden och blockeras tills det angivna antalet "
"uppgifter slutar vänta på :meth:`~Barrier.wait`. Vid den tidpunkten kommer "
"alla väntande uppgifter att avblockeras samtidigt."

msgid ""
":keyword:`async with` can be used as an alternative to awaiting on :meth:"
"`~Barrier.wait`."
msgstr ""
":keyword:`async with` kan användas som ett alternativ till att vänta på :"
"meth:`~Barrier.wait`."

msgid "The barrier can be reused any number of times."
msgstr "Barriären kan återanvändas ett obegränsat antal gånger."

msgid ""
"async def example_barrier():\n"
"   # barrier with 3 parties\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # create 2 new waiting tasks\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # The third .wait() call passes the barrier\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"
msgstr ""
"async def example_barrier():\n"
"   # barrier with 3 parties\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # create 2 new waiting tasks\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # The third .wait() call passes the barrier\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"

msgid "Result of this example is::"
msgstr "Resultatet av detta exempel är::"

msgid ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"
msgstr ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"

msgid ""
"Pass the barrier. When all the tasks party to the barrier have called this "
"function, they are all unblocked simultaneously."
msgstr ""
"Passera spärren. När alla uppgifter som är parter i barriären har anropat "
"denna funktion, avblockeras alla samtidigt."

msgid ""
"When a waiting or blocked task in the barrier is cancelled, this task exits "
"the barrier which stays in the same state. If the state of the barrier is "
"\"filling\", the number of waiting task decreases by 1."
msgstr ""
"När en väntande eller blockerad uppgift i barriären avbryts, lämnar denna "
"uppgift barriären som förblir i samma tillstånd. Om barriärens tillstånd är "
"\"fyllning\", minskar antalet väntande uppgifter med 1."

msgid ""
"The return value is an integer in the range of 0 to ``parties-1``, different "
"for each task. This can be used to select a task to do some special "
"housekeeping, e.g.::"
msgstr ""
"Returvärdet är ett heltal i intervallet 0 till ``parties-1``, olika för "
"varje uppgift. Detta kan användas för att välja en uppgift för att göra "
"några speciella hushållsarbeten, t.ex.::"

msgid ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Only one task prints this\n"
"      print('End of *draining phase*')"
msgstr ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Only one task prints this\n"
"      print('End of *draining phase*')"

msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a task is waiting. It could raise a :exc:"
"`CancelledError` if a task is cancelled."
msgstr ""
"Denna metod kan ge upphov till ett :class:`BrokenBarrierError` undantag om "
"barriären bryts eller återställs medan en uppgift väntar. Den kan ge upphov "
"till ett :exc:`CancelledError` om en uppgift avbryts."

msgid ""
"Return the barrier to the default, empty state.  Any tasks waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Återställer barriären till standardtillståndet, tom.  Alla uppgifter som "
"väntar på den kommer att få undantaget :class:`BrokenBarrierError`."

msgid ""
"If a barrier is broken it may be better to just leave it and create a new "
"one."
msgstr ""
"Om en barriär är bruten kan det vara bättre att bara lämna den och skapa en "
"ny."

msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`~Barrier.wait` to fail with the :class:`BrokenBarrierError`. Use "
"this for example if one of the tasks needs to abort, to avoid infinite "
"waiting tasks."
msgstr ""
"Sätter barriären i ett trasigt tillstånd.  Detta gör att alla aktiva eller "
"framtida anrop till :meth:`~Barrier.wait` misslyckas med :class:"
"`BrokenBarrierError`. Använd detta till exempel om en av uppgifterna måste "
"avbrytas, för att undvika oändligt väntande uppgifter."

msgid "The number of tasks required to pass the barrier."
msgstr "Det antal uppgifter som krävs för att passera barriären."

msgid "The number of tasks currently waiting in the barrier while filling."
msgstr ""
"Antalet uppgifter som för närvarande väntar i barriären medan den fylls på."

msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "En boolean som är ``True`` om barriären är i ett trasigt tillstånd."

msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Detta undantag, en underklass till :exc:`RuntimeError`, uppstår när "
"objektet :class:`Barrier` återställs eller bryts."

msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or :keyword:"
"`with` statement (``with await lock``, ``with (yield from lock)``) was "
"removed.  Use ``async with lock`` instead."
msgstr ""
"Att förvärva ett lås med hjälp av ``await lock`` eller ``yield from lock`` "
"och/eller :keyword:`with`-satsen (``with await lock``, ``with (yield from "
"lock)``) togs bort.  Använd ``async with lock`` istället."
