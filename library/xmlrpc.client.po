# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!xmlrpc.client` --- XML-RPC client access"
msgstr ":mod:`!xmlrpc.client` --- XML-RPC-klientåtkomst"

msgid "**Source code:** :source:`Lib/xmlrpc/client.py`"
msgstr "**Källkod:** :source:`Lib/xmlrpc/client.py`"

msgid ""
"XML-RPC is a Remote Procedure Call method that uses XML passed via HTTP(S) "
"as a transport.  With it, a client can call methods with parameters on a "
"remote server (the server is named by a URI) and get back structured data.  "
"This module supports writing XML-RPC client code; it handles all the details "
"of translating between conformable Python objects and XML on the wire."
msgstr ""
"XML-RPC är en Remote Procedure Call-metod som använder XML som skickas via "
"HTTP(S) som transport.  Med den kan en klient anropa metoder med parametrar "
"på en fjärrserver (servern namnges av en URI) och få tillbaka strukturerade "
"data.  Den här modulen stöder skrivandet av XML-RPC-klientkod; den hanterar "
"alla detaljer i översättningen mellan kompatibla Python-objekt och XML på "
"kabeln."

msgid ""
"The :mod:`xmlrpc.client` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data, "
"see :ref:`xml-security`."
msgstr ""
"Modulen :mod:`xmlrpc.client` är inte säker mot skadligt konstruerade data.  "
"Om du behöver analysera icke betrodda eller oautentiserade data, se :ref:"
"`xml-security`."

msgid ""
"For HTTPS URIs, :mod:`xmlrpc.client` now performs all the necessary "
"certificate and hostname checks by default."
msgstr ""
"För HTTPS URI:er utför :mod:`xmlrpc.client` nu alla nödvändiga certifikat- "
"och värdnamnskontroller som standard."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid ""
"A :class:`ServerProxy` instance is an object that manages communication with "
"a remote XML-RPC server.  The required first argument is a URI (Uniform "
"Resource Indicator), and will normally be the URL of the server.  The "
"optional second argument is a transport factory instance; by default it is "
"an internal :class:`SafeTransport` instance for https: URLs and an internal "
"HTTP :class:`Transport` instance otherwise.  The optional third argument is "
"an encoding, by default UTF-8. The optional fourth argument is a debugging "
"flag."
msgstr ""
"En instans av :class:`ServerProxy` är ett objekt som hanterar "
"kommunikationen med en XML-RPC-fjärrserver.  Det obligatoriska första "
"argumentet är en URI (Uniform Resource Indicator) som normalt är serverns "
"URL.  Det valfria andra argumentet är en transportfabriksinstans; som "
"standard är det en intern :class:`SafeTransport`-instans för https: URL:er "
"och en intern HTTP :class:`Transport`-instans i annat fall.  Det valfria "
"tredje argumentet är en kodning, som standard UTF-8. Det valfria fjärde "
"argumentet är en felsökningsflagga."

msgid ""
"The following parameters govern the use of the returned proxy instance. If "
"*allow_none* is true,  the Python constant ``None`` will be translated into "
"XML; the default behaviour is for ``None`` to raise a :exc:`TypeError`. This "
"is a commonly used extension to the XML-RPC specification, but isn't "
"supported by all clients and servers; see `http://ontosys.com/xml-rpc/"
"extensions.php <https://web.archive.org/web/20130120074804/http://ontosys."
"com/xml-rpc/extensions.php>`_ for a description. The *use_builtin_types* "
"flag can be used to cause date/time values to be presented as :class:"
"`datetime.datetime` objects and binary data to be presented as :class:"
"`bytes` objects; this flag is false by default. :class:`datetime.datetime`, :"
"class:`bytes` and :class:`bytearray` objects may be passed to calls. The "
"*headers* parameter is an optional sequence of HTTP headers to send with "
"each request, expressed as a sequence of 2-tuples representing the header "
"name and value. (e.g. ``[('Header-Name', 'value')]``). If an HTTPS URL is "
"provided, *context* may be :class:`ssl.SSLContext` and configures the SSL "
"settings of the underlying HTTPS connection. The obsolete *use_datetime* "
"flag is similar to *use_builtin_types* but it applies only to date/time "
"values."
msgstr ""
"Följande parametrar styr användningen av den returnerade proxyinstansen. Om "
"*allow_none* är true kommer Python-konstanten ``None`` att översättas till "
"XML; standardbeteendet är att ``None`` ger upphov till ett :exc:`TypeError`. "
"Detta är en vanligt förekommande utvidgning av XML-RPC-specifikationen, men "
"stöds inte av alla klienter och servrar; se `http://ontosys.com/xml-rpc/"
"extensions.php <https://web.archive.org/web/20130120074804/http://ontosys."
"com/xml-rpc/extensions.php>`_ för en beskrivning. Flaggan "
"*use_builtin_types* kan användas för att få datum/tidsvärden att presenteras "
"som :class:`datetime.datetime`-objekt och binära data att presenteras som :"
"class:`bytes`-objekt; denna flagga är false som standard. :class:`datetime."
"datetime`-, :class:`bytes`- och :class:`bytearray`-objekt kan skickas till "
"anrop. Parametern *headers* är en valfri sekvens av HTTP-rubriker som ska "
"skickas med varje begäran, uttryckt som en sekvens av 2-tuples som "
"representerar rubrikens namn och värde. (t.ex. ``[('Header-Name', "
"'value')]``). Om en HTTPS-URL tillhandahålls kan *context* vara :class:`ssl."
"SSLContext` och konfigurerar SSL-inställningarna för den underliggande HTTPS-"
"anslutningen. Den obsoleta flaggan *use_datetime* liknar *use_builtin_types* "
"men gäller endast datum-/tidsvärden."

msgid "The *use_builtin_types* flag was added."
msgstr "Flaggan *use_builtin_types* har lagts till."

msgid "The *headers* parameter was added."
msgstr "Parametern *headers* har lagts till."

msgid ""
"Both the HTTP and HTTPS transports support the URL syntax extension for HTTP "
"Basic Authentication: ``http://user:pass@host:port/path``.  The  ``user:"
"pass`` portion will be base64-encoded as an HTTP 'Authorization' header, and "
"sent to the remote server as part of the connection process when invoking an "
"XML-RPC method.  You only need to use this if the remote server requires a "
"Basic Authentication user and password."
msgstr ""
"Både HTTP- och HTTPS-transporterna stöder URL-syntaxtillägget för HTTP Basic "
"Authentication: ``http://user:pass@host:port/path``.  Delen ``user:pass`` "
"kommer att base64-kodas som en HTTP \"Authorization\"-rubrik och skickas "
"till fjärrservern som en del av anslutningsprocessen när en XML-RPC-metod "
"anropas.  Du behöver bara använda detta om fjärrservern kräver en användare "
"och ett lösenord med Basic Authentication."

msgid ""
"The returned instance is a proxy object with methods that can be used to "
"invoke corresponding RPC calls on the remote server.  If the remote server "
"supports the introspection API, the proxy can also be used to query the "
"remote server for the methods it supports (service discovery) and fetch "
"other server-associated metadata."
msgstr ""
"Den returnerade instansen är ett proxyobjekt med metoder som kan användas "
"för att anropa motsvarande RPC-anrop på fjärrservern.  Om fjärrservern "
"stöder introspection API kan proxyn också användas för att fråga "
"fjärrservern om de metoder den stöder (service discovery) och hämta andra "
"serverassocierade metadata."

msgid ""
"Types that are conformable (e.g. that can be marshalled through XML), "
"include the following (and except where noted, they are unmarshalled as the "
"same Python type):"
msgstr ""
"Typer som är konforma (dvs. som kan marshallas genom XML), inkluderar "
"följande (och förutom där det anges, är de inte marshallade som samma Python-"
"typ):"

msgid "XML-RPC type"
msgstr "XML-RPC-typ"

msgid "Python type"
msgstr "Python-typ"

msgid "``boolean``"
msgstr "``boolean``"

msgid ":class:`bool`"
msgstr ":class:`bool`"

msgid "``int``, ``i1``, ``i2``,  ``i4``, ``i8`` or ``biginteger``"
msgstr "``int``, ``i1``, ``i2``, ``i4``, ``i8`` eller ``biginteger``"

msgid ""
":class:`int` in range from -2147483648 to 2147483647. Values get the "
"``<int>`` tag."
msgstr ""
":class:`int` i intervallet från -2147483648 till 2147483647. Värdena får "
"taggen ``<int>``."

msgid "``double`` or ``float``"
msgstr "``dubbel`` eller ``flata``"

msgid ":class:`float`.  Values get the ``<double>`` tag."
msgstr ":class:`float`.  Värden får taggen ``<double>``."

msgid "``string``"
msgstr "``sträng``"

msgid ":class:`str`"
msgstr ":class:`str`"

msgid "``array``"
msgstr "``array``"

msgid ""
":class:`list` or :class:`tuple` containing conformable elements.  Arrays are "
"returned as :class:`lists <list>`."
msgstr ""
":class:`list` eller :class:`tuple` som innehåller överensstämmande element.  "
"Arrayer returneras som :class:`lists <list>`."

msgid "``struct``"
msgstr "``struktur``"

msgid ""
":class:`dict`.  Keys must be strings, values may be any conformable type.  "
"Objects of user-defined classes can be passed in; only their :attr:`~object."
"__dict__` attribute is transmitted."
msgstr ""
":class:`dict`.  Nycklar måste vara strängar, värden kan vara vilken typ som "
"helst.  Objekt av användardefinierade klasser kan skickas in; endast deras :"
"attr:`~object.__dict__`-attribut överförs."

msgid "``dateTime.iso8601``"
msgstr "``dateTime.iso8601```"

msgid ""
":class:`DateTime` or :class:`datetime.datetime`. Returned type depends on "
"values of *use_builtin_types* and *use_datetime* flags."
msgstr ""
":class:`DateTime` eller :class:`datetime.datetime`. Returnerad typ beror på "
"värdena för flaggorna *use_builtin_types* och *use_datetime*."

msgid "``base64``"
msgstr "``base64``"

msgid ""
":class:`Binary`, :class:`bytes` or :class:`bytearray`.  Returned type "
"depends on the value of the *use_builtin_types* flag."
msgstr ""
":class:`Binary`, :class:`bytes` eller :class:`bytearray`.  Returnerad typ "
"beror på värdet av flaggan *use_builtin_types*."

msgid "``nil``"
msgstr "``nil``"

msgid ""
"The ``None`` constant.  Passing is allowed only if *allow_none* is true."
msgstr ""
"Konstanten ``None``.  Överföring är tillåten endast om *allow_none* är true."

msgid "``bigdecimal``"
msgstr "``bigdecimal``"

msgid ":class:`decimal.Decimal`.  Returned type only."
msgstr ":class:`decimal.Decimal`.  Endast returnerad typ."

msgid ""
"This is the full set of data types supported by XML-RPC.  Method calls may "
"also raise a special :exc:`Fault` instance, used to signal XML-RPC server "
"errors, or :exc:`ProtocolError` used to signal an error in the HTTP/HTTPS "
"transport layer. Both :exc:`Fault` and :exc:`ProtocolError` derive from a "
"base class called :exc:`Error`.  Note that the xmlrpc client module "
"currently does not marshal instances of subclasses of built-in types."
msgstr ""
"Detta är den fullständiga uppsättning datatyper som stöds av XML-RPC.  "
"Metodanrop kan också ge upphov till en speciell :exc:`Fault`-instans, som "
"används för att signalera XML-RPC-serverfel, eller :exc:`ProtocolError` som "
"används för att signalera ett fel i HTTP/HTTPS-transportlagret. Både :exc:"
"`Fault` och :exc:`ProtocolError` härstammar från en basklass som heter :exc:"
"`Error`.  Observera att xmlrpc-klientmodulen för närvarande inte marshalar "
"instanser av underklasser av inbyggda typer."

msgid ""
"When passing strings, characters special to XML such as ``<``, ``>``, and "
"``&`` will be automatically escaped.  However, it's the caller's "
"responsibility to ensure that the string is free of characters that aren't "
"allowed in XML, such as the control characters with ASCII values between 0 "
"and 31 (except, of course, tab, newline and carriage return); failing to do "
"this will result in an XML-RPC request that isn't well-formed XML.  If you "
"have to pass arbitrary bytes via XML-RPC, use :class:`bytes` or :class:"
"`bytearray` classes or the :class:`Binary` wrapper class described below."
msgstr ""
"När strängar skickas kommer tecken som är speciella för XML, t.ex. ``<``, "
"``>`` och ``&``, att escapas automatiskt.  Det är dock anroparens ansvar att "
"se till att strängen är fri från tecken som inte är tillåtna i XML, t.ex. "
"kontrolltecken med ASCII-värden mellan 0 och 31 (förutom tab, newline och "
"carriage return); om du inte gör detta kommer det att resultera i en XML-RPC-"
"begäran som inte är välformad XML.  Om du måste skicka godtyckliga bytes via "
"XML-RPC, använd :class:`bytes` eller :class:`bytearray` klasserna eller :"
"class:`Binary` wrapper klassen som beskrivs nedan."

msgid ""
":class:`Server` is retained as an alias for :class:`ServerProxy` for "
"backwards compatibility.  New code should use :class:`ServerProxy`."
msgstr ""
":class:`Server` behålls som ett alias för :class:`ServerProxy` för "
"bakåtkompatibilitet.  Ny kod bör använda :class:`ServerProxy`."

msgid "Added the *context* argument."
msgstr "Lagt till argumentet *context*."

msgid ""
"Added support of type tags with prefixes (e.g. ``ex:nil``). Added support of "
"unmarshalling additional types used by Apache XML-RPC implementation for "
"numerics: ``i1``, ``i2``, ``i8``, ``biginteger``, ``float`` and "
"``bigdecimal``. See https://ws.apache.org/xmlrpc/types.html for a "
"description."
msgstr ""
"Stöd för typtaggar med prefix har lagts till (t.ex. ``ex:nil``). Lagt till "
"stöd för unmarshalling av ytterligare typer som används av Apache XML-RPC-"
"implementering för numeriska värden: ``i1``, ``i2``, ``i8``, ``biginteger``, "
"``float`` och ``bigdecimal``. Se https://ws.apache.org/xmlrpc/types.html för "
"en beskrivning."

msgid "`XML-RPC HOWTO <https://tldp.org/HOWTO/XML-RPC-HOWTO/index.html>`_"
msgstr "`XML-RPC HOWTO <https://tldp.org/HOWTO/XML-RPC-HOWTO/index.html>`_"

msgid ""
"A good description of XML-RPC operation and client software in several "
"languages. Contains pretty much everything an XML-RPC client developer needs "
"to know."
msgstr ""
"En bra beskrivning av XML-RPC-operation och klientprogramvara på flera "
"språk. Innehåller i stort sett allt som en XML-RPC-klientutvecklare behöver "
"veta."

msgid ""
"`XML-RPC Introspection <https://xmlrpc-c.sourceforge.io/introspection.html>`_"
msgstr ""
"xML-RPC Introspektion <https://xmlrpc-c.sourceforge.io/introspection.html>`_"

msgid "Describes the XML-RPC protocol extension for introspection."
msgstr "Beskriver XML-RPC-protokolltillägget för introspektion."

msgid "`XML-RPC Specification <http://xmlrpc.scripting.com/spec.html>`_"
msgstr "xML-RPC-specifikation <http://xmlrpc.scripting.com/spec.html>`_"

msgid "The official specification."
msgstr "Den officiella specifikationen."

msgid "ServerProxy Objects"
msgstr "ServerProxy-objekt"

msgid ""
"A :class:`ServerProxy` instance has a method corresponding to each remote "
"procedure call accepted by the XML-RPC server.  Calling the method performs "
"an RPC, dispatched by both name and argument signature (e.g. the same method "
"name can be overloaded with multiple argument signatures).  The RPC finishes "
"by returning a value, which may be either returned data in a conformant type "
"or a :class:`Fault` or :class:`ProtocolError` object indicating an error."
msgstr ""
"En :class:`ServerProxy`-instans har en metod som motsvarar varje "
"fjärrproceduranrop som accepteras av XML-RPC-servern.  När metoden anropas "
"utförs ett RPC-anrop, som skickas med både namn och argumentsignatur (t.ex. "
"kan samma metodnamn överbelastas med flera argumentsignaturer).  RPC "
"avslutas med att ett värde returneras, vilket kan vara antingen returnerade "
"data i en överensstämmande typ eller ett :class:`Fault`- eller :class:"
"`ProtocolError`-objekt som indikerar ett fel."

msgid ""
"Servers that support the XML introspection API support some common methods "
"grouped under the reserved :attr:`~ServerProxy.system` attribute:"
msgstr ""
"Servrar som stöder XML introspection API stöder några vanliga metoder som "
"grupperas under det reserverade attributet :attr:`~ServerProxy.system`:"

msgid ""
"This method returns a list of strings, one for each (non-system) method "
"supported by the XML-RPC server."
msgstr ""
"Denna metod returnerar en lista med strängar, en för varje (icke-system) "
"metod som stöds av XML-RPC-servern."

msgid ""
"This method takes one parameter, the name of a method implemented by the XML-"
"RPC server. It returns an array of possible signatures for this method. A "
"signature is an array of types. The first of these types is the return type "
"of the method, the rest are parameters."
msgstr ""
"Denna metod tar emot en parameter, namnet på en metod som implementeras av "
"XML-RPC-servern. Den returnerar en array av möjliga signaturer för denna "
"metod. En signatur är en array av typer. Den första av dessa typer är "
"metodens returtyp, resten är parametrar."

msgid ""
"Because multiple signatures (ie. overloading) is permitted, this method "
"returns a list of signatures rather than a singleton."
msgstr ""
"Eftersom flera signaturer (dvs. överbelastning) är tillåtna returnerar denna "
"metod en lista med signaturer i stället för en singleton."

msgid ""
"Signatures themselves are restricted to the top level parameters expected by "
"a method. For instance if a method expects one array of structs as a "
"parameter, and it returns a string, its signature is simply \"string, "
"array\". If it expects three integers and returns a string, its signature is "
"\"string, int, int, int\"."
msgstr ""
"Själva signaturerna är begränsade till de parametrar på högsta nivå som "
"förväntas av en metod. Om en metod t.ex. förväntar sig en array av structs "
"som parameter och returnerar en sträng, är dess signatur helt enkelt "
"\"string, array\". Om den förväntar sig tre heltal och returnerar en sträng "
"är signaturen \"string, int, int, int\"."

msgid ""
"If no signature is defined for the method, a non-array value is returned. In "
"Python this means that the type of the returned  value will be something "
"other than list."
msgstr ""
"Om ingen signatur har definierats för metoden returneras ett värde som inte "
"är en array. I Python betyder det att typen av det returnerade värdet kommer "
"att vara något annat än list."

msgid ""
"This method takes one parameter, the name of a method implemented by the XML-"
"RPC server.  It returns a documentation string describing the use of that "
"method. If no such string is available, an empty string is returned. The "
"documentation string may contain HTML markup."
msgstr ""
"Denna metod tar en parameter, namnet på en metod som implementeras av XML-"
"RPC-servern.  Den returnerar en dokumentationssträng som beskriver "
"användningen av den metoden. Om ingen sådan sträng finns tillgänglig "
"returneras en tom sträng. Dokumentationssträngen kan innehålla HTML-markup."

msgid ""
"Instances of :class:`ServerProxy` support the :term:`context manager` "
"protocol for closing the underlying transport."
msgstr ""
"Instanser av :class:`ServerProxy` stöder :term:`context manager`-protokollet "
"för att stänga den underliggande transporten."

msgid "A working example follows. The server code::"
msgstr "Här följer ett fungerande exempel. Serverkoden::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"\n"
"def is_even(n):\n"
"    return n % 2 == 0\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Listening on port 8000...\")\n"
"server.register_function(is_even, \"is_even\")\n"
"server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"\n"
"def is_even(n):\n"
"    return n % 2 == 0\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Lyssnar på port 8000...\")\n"
"server.register_function(is_even, \"is_even\")\n"
"server.serve_forever()"

msgid "The client code for the preceding server::"
msgstr "Klientkoden för den föregående servern::"

msgid ""
"import xmlrpc.client\n"
"\n"
"with xmlrpc.client.ServerProxy(\"http://localhost:8000/\") as proxy:\n"
"    print(\"3 is even: %s\" % str(proxy.is_even(3)))\n"
"    print(\"100 is even: %s\" % str(proxy.is_even(100)))"
msgstr ""
"import xmlrpc.client\n"
"\n"
"with xmlrpc.client.ServerProxy(\"http://localhost:8000/\") as proxy:\n"
"    print(\"3 is even: %s\" % str(proxy.is_even(3)))\n"
"    print(\"100 is even: %s\" % str(proxy.is_even(100)))"

msgid "DateTime Objects"
msgstr "DateTime-objekt"

msgid ""
"This class may be initialized with seconds since the epoch, a time tuple, an "
"ISO 8601 time/date string, or a :class:`datetime.datetime` instance.  It has "
"the following methods, supported mainly for internal use by the marshalling/"
"unmarshalling code:"
msgstr ""
"Klassen kan initialiseras med sekunder sedan epoken, en tidstupel, en ISO "
"8601 tid/datum-sträng eller en :class:`datetime.datetime`-instans.  Den har "
"följande metoder, som huvudsakligen stöds för internt bruk av marshalling/"
"unmarshalling-koden:"

msgid "Accept a string as the instance's new time value."
msgstr "Acceptera en sträng som instansens nya tidsvärde."

msgid ""
"Write the XML-RPC encoding of this :class:`DateTime` item to the *out* "
"stream object."
msgstr ""
"Skriv XML-RPC-kodningen av detta :class:`DateTime`-objekt till *out*-"
"strömobjektet."

msgid ""
"It also supports certain of Python's built-in operators through :meth:`rich "
"comparison <object.__lt__>` and :meth:`~object.__repr__` methods."
msgstr ""
"Den stöder också vissa av Pythons inbyggda operatorer genom metoderna :meth:"
"`rich comparison <object.__lt__>` och :meth:`~object.__repr__`."

msgid ""
"import datetime\n"
"from xmlrpc.server import SimpleXMLRPCServer\n"
"import xmlrpc.client\n"
"\n"
"def today():\n"
"    today = datetime.datetime.today()\n"
"    return xmlrpc.client.DateTime(today)\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Listening on port 8000...\")\n"
"server.register_function(today, \"today\")\n"
"server.serve_forever()"
msgstr ""
"import datetime\n"
"from xmlrpc.server import SimpleXMLRPCServer\n"
"import xmlrpc.client\n"
"\n"
"def today():\n"
"    today = datetime.datetime.today()\n"
"    return xmlrpc.client.DateTime(today)\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Listening on port 8000...\")\n"
"server.register_function(today, \"today\")\n"
"server.serve_forever()"

msgid ""
"import xmlrpc.client\n"
"import datetime\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"\n"
"today = proxy.today()\n"
"# convert the ISO8601 string to a datetime object\n"
"converted = datetime.datetime.strptime(today.value, \"%Y%m%dT%H:%M:%S\")\n"
"print(\"Today: %s\" % converted.strftime(\"%d.%m.%Y, %H:%M\"))"
msgstr ""
"import xmlrpc.client\n"
"import datetime\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"\n"
"today = proxy.today()\n"
"# convert the ISO8601 string to a datetime object\n"
"converted = datetime.datetime.strptime(today.value, \"%Y%m%dT%H:%M:%S\")\n"
"print(\"Today: %s\" % converted.strftime(\"%d.%m.%Y, %H:%M\"))"

msgid "Binary Objects"
msgstr "Binära objekt"

msgid ""
"This class may be initialized from bytes data (which may include NULs). The "
"primary access to the content of a :class:`Binary` object is provided by an "
"attribute:"
msgstr ""
"Denna klass kan initialiseras från bytesdata (som kan innehålla NUL). Den "
"primära tillgången till innehållet i ett :class:`Binary`-objekt ges av ett "
"attribut:"

msgid ""
"The binary data encapsulated by the :class:`Binary` instance.  The data is "
"provided as a :class:`bytes` object."
msgstr ""
"De binära data som inkapslas av :class:`Binary`-instansen.  Data "
"tillhandahålls som ett :class:`bytes`-objekt."

msgid ""
":class:`Binary` objects have the following methods, supported mainly for "
"internal use by the marshalling/unmarshalling code:"
msgstr ""
":class:`Binary`-objekt har följande metoder, som huvudsakligen stöds för "
"internt bruk av marshalling/unmarshalling-koden:"

msgid ""
"Accept a base64 :class:`bytes` object and decode it as the instance's new "
"data."
msgstr ""
"Acceptera ett base64 :class:`bytes`-objekt och avkoda det som instansens nya "
"data."

msgid ""
"Write the XML-RPC base 64 encoding of this binary item to the *out* stream "
"object."
msgstr ""
"Skriv XML-RPC-bas 64-kodningen av detta binära objekt till *out*-"
"strömobjektet."

msgid ""
"The encoded data will have newlines every 76 characters as per :rfc:`RFC "
"2045 section 6.8 <2045#section-6.8>`, which was the de facto standard base64 "
"specification when the XML-RPC spec was written."
msgstr ""
"De kodade data kommer att ha nya rader var 76:e tecken enligt :rfc:`RFC 2045 "
"section 6.8 <2045#section-6.8>`, som var de facto-standarden för base64-"
"specifikationen när XML-RPC-specifikationen skrevs."

msgid ""
"It also supports certain of Python's built-in operators through :meth:"
"`~object.__eq__` and :meth:`~object.__ne__` methods."
msgstr ""
"Den stöder också vissa av Pythons inbyggda operatorer genom metoderna :meth:"
"`~object.__eq__` och :meth:`~object.__ne__`."

msgid ""
"Example usage of the binary objects.  We're going to transfer an image over "
"XMLRPC::"
msgstr ""
"Exempel på användning av de binära objekten.  Vi kommer att överföra en bild "
"via XMLRPC::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"import xmlrpc.client\n"
"\n"
"def python_logo():\n"
"    with open(\"python_logo.jpg\", \"rb\") as handle:\n"
"        return xmlrpc.client.Binary(handle.read())\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Listening on port 8000...\")\n"
"server.register_function(python_logo, 'python_logo')\n"
"\n"
"server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"import xmlrpc.client\n"
"\n"
"def python_logo():\n"
"    with open(\"python_logo.jpg\", \"rb\") as handle:\n"
"        return xmlrpc.client.Binary(handle.read())\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Listening on port 8000...\")\n"
"server.register_function(python_logo, 'python_logo')\n"
"\n"
"server.serve_forever()"

msgid "The client gets the image and saves it to a file::"
msgstr "Klienten hämtar bilden och sparar den i en fil::"

msgid ""
"import xmlrpc.client\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"with open(\"fetched_python_logo.jpg\", \"wb\") as handle:\n"
"    handle.write(proxy.python_logo().data)"
msgstr ""
"import xmlrpc.client\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"with open(\"fetched_python_logo.jpg\", \"wb\") as handle:\n"
"    handle.write(proxy.python_logo().data)"

msgid "Fault Objects"
msgstr "Felobjekt"

msgid ""
"A :class:`Fault` object encapsulates the content of an XML-RPC fault tag. "
"Fault objects have the following attributes:"
msgstr ""
"Ett :class:`Fault`-objekt kapslar in innehållet i en XML-RPC fault-tagg. "
"Fault-objekt har följande attribut:"

msgid "An int indicating the fault type."
msgstr "Ett int som anger feltypen."

msgid "A string containing a diagnostic message associated with the fault."
msgstr ""
"En sträng som innehåller ett diagnostiskt meddelande som är kopplat till "
"felet."

msgid ""
"In the following example we're going to intentionally cause a :exc:`Fault` "
"by returning a complex type object.  The server code::"
msgstr ""
"I följande exempel ska vi avsiktligt orsaka ett :exc:`Fault` genom att "
"returnera ett objekt av komplex typ.  Serverkoden::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"\n"
"# A marshalling error is going to occur because we're returning a\n"
"# complex number\n"
"def add(x, y):\n"
"    return x+y+0j\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Listening on port 8000...\")\n"
"server.register_function(add, 'add')\n"
"\n"
"server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"\n"
"# Ett marshalling-fel kommer att uppstå eftersom vi returnerar ett\n"
"# komplext tal\n"
"def add(x, y):\n"
"    returnerar x+y+0j\n"
"\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Lyssnar på port 8000...\")\n"
"server.register_function(add, 'add')\n"
"\n"
"server.serve_forever()"

msgid ""
"import xmlrpc.client\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"try:\n"
"    proxy.add(2, 5)\n"
"except xmlrpc.client.Fault as err:\n"
"    print(\"A fault occurred\")\n"
"    print(\"Fault code: %d\" % err.faultCode)\n"
"    print(\"Fault string: %s\" % err.faultString)"
msgstr ""
"import xmlrpc.client\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"try:\n"
"    proxy.add(2, 5)\n"
"except xmlrpc.client.Fault as err:\n"
"    print(\"A fault occurred\")\n"
"    print(\"Fault code: %d\" % err.faultCode)\n"
"    print(\"Fault string: %s\" % err.faultString)"

msgid "ProtocolError Objects"
msgstr "ProtokollFel Objekt"

msgid ""
"A :class:`ProtocolError` object describes a protocol error in the underlying "
"transport layer (such as a 404 'not found' error if the server named by the "
"URI does not exist).  It has the following attributes:"
msgstr ""
"Ett :class:`ProtocolError`-objekt beskriver ett protokollfel i det "
"underliggande transportlagret (t.ex. ett 404 \"not found\"-fel om servern "
"som anges av URI:n inte existerar).  Det har följande attribut:"

msgid "The URI or URL that triggered the error."
msgstr "Den URI eller URL som utlöste felet."

msgid "The error code."
msgstr "Felkoden."

msgid "The error message or diagnostic string."
msgstr "Felmeddelandet eller diagnossträngen."

msgid ""
"A dict containing the headers of the HTTP/HTTPS request that triggered the "
"error."
msgstr ""
"En dict som innehåller rubrikerna för den HTTP/HTTPS-begäran som utlöste "
"felet."

msgid ""
"In the following example we're going to intentionally cause a :exc:"
"`ProtocolError` by providing an invalid URI::"
msgstr ""
"I följande exempel kommer vi avsiktligt att orsaka ett :exc:`ProtocolError` "
"genom att ange en ogiltig URI::"

msgid ""
"import xmlrpc.client\n"
"\n"
"# create a ServerProxy with a URI that doesn't respond to XMLRPC requests\n"
"proxy = xmlrpc.client.ServerProxy(\"http://google.com/\")\n"
"\n"
"try:\n"
"    proxy.some_method()\n"
"except xmlrpc.client.ProtocolError as err:\n"
"    print(\"A protocol error occurred\")\n"
"    print(\"URL: %s\" % err.url)\n"
"    print(\"HTTP/HTTPS headers: %s\" % err.headers)\n"
"    print(\"Error code: %d\" % err.errcode)\n"
"    print(\"Error message: %s\" % err.errmsg)"
msgstr ""
"import xmlrpc.client\n"
"\n"
"# create a ServerProxy with a URI that doesn't respond to XMLRPC requests\n"
"proxy = xmlrpc.client.ServerProxy(\"http://google.com/\")\n"
"\n"
"try:\n"
"    proxy.some_method()\n"
"except xmlrpc.client.ProtocolError as err:\n"
"    print(\"A protocol error occurred\")\n"
"    print(\"URL: %s\" % err.url)\n"
"    print(\"HTTP/HTTPS headers: %s\" % err.headers)\n"
"    print(\"Error code: %d\" % err.errcode)\n"
"    print(\"Error message: %s\" % err.errmsg)"

msgid "MultiCall Objects"
msgstr "MultiCall-objekt"

msgid ""
"The :class:`MultiCall` object provides a way to encapsulate multiple calls "
"to a remote server into a single request [#]_."
msgstr ""
"Objektet :class:`MultiCall` ger möjlighet att kapsla in flera anrop till en "
"fjärrserver i en enda begäran [#]_."

msgid ""
"Create an object used to boxcar method calls. *server* is the eventual "
"target of the call. Calls can be made to the result object, but they will "
"immediately return ``None``, and only store the call name and parameters in "
"the :class:`MultiCall` object. Calling the object itself causes all stored "
"calls to be transmitted as a single ``system.multicall`` request. The result "
"of this call is a :term:`generator`; iterating over this generator yields "
"the individual results."
msgstr ""
"Skapa ett objekt som används för att boxcar-metodanrop. *server* är det "
"slutliga målet för anropet. Anrop kan göras till resultatobjektet, men de "
"kommer omedelbart att returnera ``None``, och bara lagra anropets namn och "
"parametrar i :class:`MultiCall`-objektet. Anrop av själva objektet gör att "
"alla lagrade anrop överförs som en enda ``system.multicall``-begäran. "
"Resultatet av detta anrop är en :term:`generator`; genom att iterera över "
"denna generator erhålls de enskilda resultaten."

msgid "A usage example of this class follows.  The server code::"
msgstr "Här följer ett exempel på användning av denna klass.  Serverkoden::"

msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"\n"
"def add(x, y):\n"
"    return x + y\n"
"\n"
"def subtract(x, y):\n"
"    return x - y\n"
"\n"
"def multiply(x, y):\n"
"    return x * y\n"
"\n"
"def divide(x, y):\n"
"    return x // y\n"
"\n"
"# A simple server with simple arithmetic functions\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Listening on port 8000...\")\n"
"server.register_multicall_functions()\n"
"server.register_function(add, 'add')\n"
"server.register_function(subtract, 'subtract')\n"
"server.register_function(multiply, 'multiply')\n"
"server.register_function(divide, 'divide')\n"
"server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"\n"
"def add(x, y):\n"
"    return x + y\n"
"\n"
"def subtract(x, y):\n"
"    returnerar x - y\n"
"\n"
"def multiply(x, y):\n"
"    returnerar x * y\n"
"\n"
"def divide(x, y):\n"
"    returnerar x // y\n"
"\n"
"# En enkel server med enkla aritmetiska funktioner\n"
"server = SimpleXMLRPCServer((\"localhost\", 8000))\n"
"print(\"Lyssnar på port 8000...\")\n"
"server.register_multicall_functions()\n"
"server.register_function(add, 'add')\n"
"server.register_function(subtract, 'subtrahera')\n"
"server.register_funktion(multiplicera, 'multiply')\n"
"server.register_function(divide, 'dividera')\n"
"server.serve_forever()"

msgid ""
"import xmlrpc.client\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"multicall = xmlrpc.client.MultiCall(proxy)\n"
"multicall.add(7, 3)\n"
"multicall.subtract(7, 3)\n"
"multicall.multiply(7, 3)\n"
"multicall.divide(7, 3)\n"
"result = multicall()\n"
"\n"
"print(\"7+3=%d, 7-3=%d, 7*3=%d, 7//3=%d\" % tuple(result))"
msgstr ""
"import xmlrpc.client\n"
"\n"
"proxy = xmlrpc.client.ServerProxy(\"http://localhost:8000/\")\n"
"multicall = xmlrpc.client.MultiCall(proxy)\n"
"multicall.add(7, 3)\n"
"multicall.subtract(7, 3)\n"
"multicall.multiply(7, 3)\n"
"multicall.divide(7, 3)\n"
"result = multicall()\n"
"\n"
"print(\"7+3=%d, 7-3=%d, 7*3=%d, 7//3=%d\" % tuple(result))"

msgid "Convenience Functions"
msgstr "Bekväma funktioner"

msgid ""
"Convert *params* into an XML-RPC request. or into a response if "
"*methodresponse* is true. *params* can be either a tuple of arguments or an "
"instance of the :exc:`Fault` exception class.  If *methodresponse* is true, "
"only a single value can be returned, meaning that *params* must be of length "
"1. *encoding*, if supplied, is the encoding to use in the generated XML; the "
"default is UTF-8. Python's :const:`None` value cannot be used in standard "
"XML-RPC; to allow using it via an extension,  provide a true value for "
"*allow_none*."
msgstr ""
"Konverterar *params* till en XML-RPC-begäran eller till ett svar om "
"*methodresponse* är sant. *params* kan vara antingen en tupel av argument "
"eller en instans av undantagsklassen :exc:`Fault`.  Om *methodresponse* är "
"true kan endast ett enda värde returneras, vilket innebär att *params* måste "
"ha längden 1. *encoding*, om det anges, är den kodning som ska användas i "
"den XML som genereras; standard är UTF-8. Pythons :const:`None`-värde kan "
"inte användas i standard XML-RPC; för att tillåta att det används via ett "
"tillägg, ange ett true-värde för *allow_none*."

msgid ""
"Convert an XML-RPC request or response into Python objects, a ``(params, "
"methodname)``.  *params* is a tuple of argument; *methodname* is a string, "
"or ``None`` if no method name is present in the packet. If the XML-RPC "
"packet represents a fault condition, this function will raise a :exc:`Fault` "
"exception. The *use_builtin_types* flag can be used to cause date/time "
"values to be presented as :class:`datetime.datetime` objects and binary data "
"to be presented as :class:`bytes` objects; this flag is false by default."
msgstr ""
"Konverterar en XML-RPC-begäran eller ett svar till Python-objekt, en "
"``(params, methodname)``.  *params* är en tupel av argument; *methodname* är "
"en sträng, eller ``None`` om inget metodnamn finns i paketet. Om XML-RPC-"
"paketet representerar ett feltillstånd, kommer denna funktion att ge upphov "
"till ett :exc:`Fault` undantag. Flaggan *use_builtin_types* kan användas för "
"att få datum/tidsvärden att presenteras som :class:`datetime.datetime`-"
"objekt och binära data att presenteras som :class:`bytes`-objekt; denna "
"flagga är falsk som standard."

msgid ""
"The obsolete *use_datetime* flag is similar to *use_builtin_types* but it "
"applies only to date/time values."
msgstr ""
"Den föråldrade flaggan *use_datetime* liknar *use_builtin_types* men gäller "
"bara för datum-/tidsvärden."

msgid "Example of Client Usage"
msgstr "Exempel på klientanvändning"

msgid ""
"# simple test program (from the XML-RPC specification)\n"
"from xmlrpc.client import ServerProxy, Error\n"
"\n"
"# server = ServerProxy(\"http://localhost:8000\") # local server\n"
"with ServerProxy(\"http://betty.userland.com\") as proxy:\n"
"\n"
"    print(proxy)\n"
"\n"
"    try:\n"
"        print(proxy.examples.getStateName(41))\n"
"    except Error as v:\n"
"        print(\"ERROR\", v)"
msgstr ""
"# enkelt testprogram (från XML-RPC-specifikationen)\n"
"from xmlrpc.client import ServerProxy, Fel\n"
"\n"
"# server = ServerProxy(\"http://localhost:8000\") # lokal server\n"
"med ServerProxy(\"http://betty.userland.com\") som proxy:\n"
"\n"
"    print(proxy)\n"
"\n"
"    försök:\n"
"        print(proxy.examples.getStateName(41))\n"
"    except Error as v:\n"
"        print(\"ERROR\", v)"

msgid ""
"To access an XML-RPC server through a HTTP proxy, you need to define a "
"custom transport.  The following example shows how::"
msgstr ""
"Om du vill komma åt en XML-RPC-server via en HTTP-proxy måste du definiera "
"en anpassad transport.  Följande exempel visar hur::"

msgid ""
"import http.client\n"
"import xmlrpc.client\n"
"\n"
"class ProxiedTransport(xmlrpc.client.Transport):\n"
"\n"
"    def set_proxy(self, host, port=None, headers=None):\n"
"        self.proxy = host, port\n"
"        self.proxy_headers = headers\n"
"\n"
"    def make_connection(self, host):\n"
"        connection = http.client.HTTPConnection(*self.proxy)\n"
"        connection.set_tunnel(host, headers=self.proxy_headers)\n"
"        self._connection = host, connection\n"
"        return connection\n"
"\n"
"transport = ProxiedTransport()\n"
"transport.set_proxy('proxy-server', 8080)\n"
"server = xmlrpc.client.ServerProxy('http://betty.userland.com', "
"transport=transport)\n"
"print(server.examples.getStateName(41))"
msgstr ""
"import http.client\n"
"import xmlrpc.client\n"
"\n"
"class ProxiedTransport(xmlrpc.client.Transport):\n"
"\n"
"    def set_proxy(self, host, port=None, headers=None):\n"
"        self.proxy = host, port\n"
"        self.proxy_headers = headers\n"
"\n"
"    def make_connection(self, host):\n"
"        connection = http.client.HTTPConnection(*self.proxy)\n"
"        connection.set_tunnel(host, headers=self.proxy_headers)\n"
"        self._connection = host, connection\n"
"        return connection\n"
"\n"
"transport = ProxiedTransport()\n"
"transport.set_proxy('proxy-server', 8080)\n"
"server = xmlrpc.client.ServerProxy('http://betty.userland.com', "
"transport=transport)\n"
"print(server.examples.getStateName(41))"

msgid "Example of Client and Server Usage"
msgstr "Exempel på användning av klient och server"

msgid "See :ref:`simplexmlrpcserver-example`."
msgstr "Se :ref:`simplexmlrpcserver-example`."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"This approach has been first presented in `a discussion on xmlrpc.com "
"<https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/"
"msgReader$1208?mode=topic>`_."
msgstr ""
"Detta tillvägagångssätt presenterades för första gången i en diskussion på "
"xmlrpc.com <https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/"
"discuss/msgReader$1208?mode=topic>`_."
