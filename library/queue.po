# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!queue` --- A synchronized queue class"
msgstr ":mod:`!queue` --- En synkroniserad kö-klass"

msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**Källkod:** :source:`Lib/queue.py`"

msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics."
msgstr ""
"Modulen :mod:`queue` implementerar köer med flera producenter och flera "
"konsumenter. Den är särskilt användbar i trådad programmering när "
"information måste utbytas säkert mellan flera trådar.  Klassen :class:"
"`Queue` i denna modul implementerar all nödvändig låsningssemantik."

msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved.  In a :abbr:`LIFO "
"(last-in, first-out)` queue, the most recently added entry is the first "
"retrieved (operating like a stack).  With a priority queue, the entries are "
"kept sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""
"Modulen implementerar tre typer av köer, som endast skiljer sig åt i den "
"ordning i vilken posterna hämtas.  I en :abbr:`FIFO (first-in, first-out)`-"
"kö hämtas de först tillagda uppgifterna först.  I en :abbr:`LIFO (last-in, "
"first-out)`-kö hämtas den senast tillagda posten först (fungerar som en "
"stapel).  Med en prioritetskö hålls posterna sorterade (med hjälp av "
"modulen :mod:`heapq`) och den post som har lägst värde hämtas först."

msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"Internt använder dessa tre typer av köer lås för att tillfälligt blockera "
"konkurrerande trådar, men de är inte utformade för att hantera reentrancy "
"inom en tråd."

msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, first-"
"out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"Dessutom implementerar modulen en \"enkel\" :abbr:`FIFO (first-in, first-"
"out)` kötyp, :class:`SimpleQueue`, vars specifika implementering ger "
"ytterligare garantier i utbyte mot den mindre funktionaliteten."

msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr "Modulen :mod:`queue` definierar följande klasser och undantag:"

msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Konstruktör för en :abbr:`FIFO (först in, först ut)`-kö.  *maxsize* är ett "
"heltal som anger den övre gränsen för hur många objekt som kan placeras i "
"kön.  Inmatningen blockeras när denna storlek har uppnåtts, tills köobjekten "
"är förbrukade.  Om *maxsize* är mindre än eller lika med noll är köstorleken "
"oändlig."

msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Konstruktör för en :abbr:`LIFO (sist in, först ut)`-kö.  *maxsize* är ett "
"heltal som anger den övre gränsen för hur många objekt som kan placeras i "
"kön.  Inmatningen blockeras när denna storlek har uppnåtts, tills köobjekten "
"är förbrukade.  Om *maxsize* är mindre än eller lika med noll är köstorleken "
"oändlig."

msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"Konstruktor för en prioriterad kö.  *maxsize* är ett heltal som anger den "
"övre gränsen för hur många objekt som kan placeras i kön.  Inmatningen "
"kommer att blockeras när denna storlek har uppnåtts, tills köobjekten är "
"förbrukade.  Om *maxsize* är mindre än eller lika med noll är köstorleken "
"oändlig."

msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one that would be returned by ``min(entries)``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"De lägst värderade posterna hämtas först (den lägst värderade posten är den "
"som skulle returneras av ``min(entries)``).  Ett typiskt mönster för poster "
"är en tupel i formen: ``(priority_number, data)``."

msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr ""
"Om *data*-elementen inte är jämförbara kan data förpackas i en klass som "
"ignorerar dataelementet och endast jämför prioritetsnumret::"

msgid ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"
msgstr ""
"from dataclasses import dataclass, field\n"
"from typing import Any\n"
"\n"
"@dataclass(order=True)\n"
"class PrioritizedItem:\n"
"    priority: int\n"
"    item: Any=field(compare=False)"

msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"Konstruktör för en obegränsad :abbr:`FIFO (först in, först ut)`-kö. Enkla "
"köer saknar avancerad funktionalitet som t.ex. uppgiftsspårning."

msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"Exception uppstår när icke-blockerande :meth:`~Queue.get` (eller :meth:"
"`~Queue.get_nowait`) anropas på ett :class:`Queue`-objekt som är tomt."

msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"Exception uppstår när icke-blockerande :meth:`~Queue.put` (eller :meth:"
"`~Queue.put_nowait`) anropas på ett :class:`Queue`-objekt som är fullt."

msgid ""
"Exception raised when :meth:`~Queue.put` or :meth:`~Queue.get` is called on "
"a :class:`Queue` object which has been shut down."
msgstr ""
"Exception som uppstår när :meth:`~Queue.put` eller :meth:`~Queue.get` "
"anropas på ett :class:`Queue`-objekt som har stängts ner."

msgid "Queue Objects"
msgstr "Objekt för köer"

msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"Queue-objekt (:class:`Queue`, :class:`LifoQueue` eller :class:"
"`PriorityQueue`) tillhandahåller de publika metoder som beskrivs nedan."

msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"Returnerar den ungefärliga storleken på kön.  Observera att qsize() > 0 inte "
"garanterar att en efterföljande get() inte blockeras, och att qsize() < "
"maxsize inte garanterar att put() inte blockeras."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"Returnerar ``True`` om kön är tom, annars ``False``.  Om empty() returnerar "
"``True`` garanterar det inte att ett efterföljande anrop till put() inte "
"kommer att blockeras.  På samma sätt, om empty() returnerar ``False`` "
"garanterar det inte att ett efterföljande anrop till get() inte kommer att "
"blockeras."

msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"Returnerar ``True`` om kön är full, annars ``False``.  Om full() returnerar "
"``True`` garanterar det inte att ett efterföljande anrop till get() inte "
"kommer att blockeras.  På samma sätt, om full() returnerar ``False`` "
"garanterar det inte att ett efterföljande anrop till put() inte kommer att "
"blockeras."

msgid ""
"Put *item* into the queue.  If optional args *block* is true and *timeout* "
"is ``None`` (the default), block if necessary until a free slot is "
"available.  If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Full` exception if no free slot was available "
"within that time. Otherwise (*block* is false), put an item on the queue if "
"a free slot is immediately available, else raise the :exc:`Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"Lägger in *objekt* i kön.  Om de valfria argen *block* är true och *timeout* "
"är ``None`` (standard), blockeras vid behov tills en ledig plats finns "
"tillgänglig.  Om *timeout* är ett positivt tal blockeras högst *timeout* "
"sekunder och :exc:`Full` undantaget uppstår om ingen ledig plats fanns "
"tillgänglig inom den tiden. I annat fall (*block* är false) läggs ett objekt "
"i kön om en ledig plats omedelbart finns tillgänglig, annars uppstår "
"undantaget :exc:`Full` (*timeout* ignoreras i det fallet)."

msgid "Raises :exc:`ShutDown` if the queue has been shut down."
msgstr "Utlöser :exc:`ShutDown` om kön har stängts av."

msgid "Equivalent to ``put(item, block=False)``."
msgstr "Motsvarar ``put(item, block=False)``."

msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Tar bort och returnerar ett objekt från kön.  Om de valfria argen *block* är "
"true och *timeout* är ``None`` (standard), blockeras vid behov tills ett "
"objekt är tillgängligt. Om *timeout* är ett positivt tal blockerar den i "
"högst *timeout* sekunder och ger upphov till :exc:`Empty`-undantaget om "
"inget objekt var tillgängligt inom den tiden. I annat fall (*block* är "
"false) returneras ett objekt om ett sådant är omedelbart tillgängligt, "
"annars uppstår undantaget :exc:`Empty` (*timeout* ignoreras i det fallet)."

msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock.  This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a :exc:"
"`KeyboardInterrupt`."
msgstr ""
"Före 3.0 på POSIX-system, och för alla versioner på Windows, om *block* är "
"true och *timeout* är ``None``, går denna operation in i en oavbruten väntan "
"på ett underliggande lås.  Detta innebär att inga undantag kan inträffa, och "
"i synnerhet kommer inte en SIGINT att utlösa ett :exc:`KeyboardInterrupt`."

msgid ""
"Raises :exc:`ShutDown` if the queue has been shut down and is empty, or if "
"the queue has been shut down immediately."
msgstr ""
"Utlöser :exc:`ShutDown` om kön har stängts av och är tom, eller om kön har "
"stängts av omedelbart."

msgid "Equivalent to ``get(False)``."
msgstr "Motsvarar ``get(False)``."

msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"Det finns två metoder för att spåra om uppgifter i kö har bearbetats "
"fullständigt av daemonens konsumenttrådar."

msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"Anger att en tidigare köad uppgift är slutförd.  Används av kö-"
"konsumenttrådar.  För varje :meth:`get` som används för att hämta en "
"uppgift, talar ett efterföljande anrop till :meth:`task_done` om för kön att "
"bearbetningen av uppgiften är klar."

msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
"Om en :meth:`join` för närvarande blockeras kommer den att återupptas när "
"alla objekt har behandlats (vilket innebär att ett :meth:`task_done`-anrop "
"har mottagits för varje objekt som har :meth:`put` i kön)."

msgid ""
"``shutdown(immediate=True)`` calls :meth:`task_done` for each remaining item "
"in the queue."
msgstr ""
"``shutdown(immediate=True)`` anropar :meth:`task_done` för varje återstående "
"objekt i kön."

msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Utlöser ett :exc:`ValueError` om den anropas fler gånger än det finns objekt "
"i kön."

msgid "Blocks until all items in the queue have been gotten and processed."
msgstr "Blockerar tills alla objekt i kön har hämtats och bearbetats."

msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"Antalet oavslutade uppgifter ökar varje gång ett objekt läggs till i kön. "
"Antalet sjunker när en konsumenttråd anropar :meth:`task_done` för att ange "
"att objektet hämtades och att allt arbete med det är slutfört.  När antalet "
"oavslutade uppgifter sjunker till noll avblockeras :meth:`join`."

msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "Exempel på hur man väntar på att uppgifter i kön ska slutföras::"

msgid ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"
msgstr ""
"import threading\n"
"import queue\n"
"\n"
"q = queue.Queue()\n"
"\n"
"def worker():\n"
"    while True:\n"
"        item = q.get()\n"
"        print(f'Working on {item}')\n"
"        print(f'Finished {item}')\n"
"        q.task_done()\n"
"\n"
"# Turn-on the worker thread.\n"
"threading.Thread(target=worker, daemon=True).start()\n"
"\n"
"# Send thirty task requests to the worker.\n"
"for item in range(30):\n"
"    q.put(item)\n"
"\n"
"# Block until all tasks are done.\n"
"q.join()\n"
"print('All work completed')"

msgid "Terminating queues"
msgstr "Avsluta köer"

msgid ""
":class:`Queue` objects can be made to prevent further interaction by "
"shutting them down."
msgstr ""
":class:`Queue`-objekt kan göras så att ytterligare interaktion förhindras "
"genom att de stängs av."

msgid ""
"Shut down the queue, making :meth:`~Queue.get` and :meth:`~Queue.put` raise :"
"exc:`ShutDown`."
msgstr ""
"Stänger av kön, vilket gör att :meth:`~Queue.get` och :meth:`~Queue.put` ger "
"upphov till :exc:`ShutDown`."

msgid ""
"By default, :meth:`~Queue.get` on a shut down queue will only raise once the "
"queue is empty. Set *immediate* to true to make :meth:`~Queue.get` raise "
"immediately instead."
msgstr ""
"Som standard kommer :meth:`~Queue.get` på en avstängd kö inte att aktiveras "
"förrän kön är tom. Sätt *immediate* till true för att få :meth:`~Queue.get` "
"att starta omedelbart istället."

msgid ""
"All blocked callers of :meth:`~Queue.put` and :meth:`~Queue.get` will be "
"unblocked. If *immediate* is true, a task will be marked as done for each "
"remaining item in the queue, which may unblock callers of :meth:`~Queue."
"join`."
msgstr ""
"Alla blockerade anropare av :meth:`~Queue.put` och :meth:`~Queue.get` kommer "
"att avblockeras. Om *immediate* är true, kommer en uppgift att markeras som "
"utförd för varje återstående objekt i kön, vilket kan avblockera anropare "
"av :meth:`~Queue.join`."

msgid "SimpleQueue Objects"
msgstr "SimpleQueue-objekt"

msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ""
":class:`SimpleQueue`-objekt tillhandahåller de publika metoder som beskrivs "
"nedan."

msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"Returnerar den ungefärliga storleken på kön.  Observera att qsize() > 0 inte "
"garanterar att en efterföljande get() inte blockeras."

msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""
"Returnerar ``True`` om kön är tom, annars ``False``.  Om empty() returnerar "
"``False`` garanterar det inte att ett efterföljande anrop till get() inte "
"kommer att blockeras."

msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"Lägg in *objekt* i kön.  Metoden blockerar aldrig och lyckas alltid (med "
"undantag för potentiella lågnivåfel som misslyckande med att allokera "
"minne). De valfria argen *block* och *timeout* ignoreras och tillhandahålls "
"endast för kompatibilitet med :meth:`Queue.put`."

msgid ""
"This method has a C implementation which is reentrant.  That is, a ``put()`` "
"or ``get()`` call can be interrupted by another ``put()`` call in the same "
"thread without deadlocking or corrupting internal state inside the queue.  "
"This makes it appropriate for use in destructors such as ``__del__`` methods "
"or :mod:`weakref` callbacks."
msgstr ""
"Denna metod har en C-implementering som är reentrant.  Det innebär att ett "
"``put()``- eller ``get()``-anrop kan avbrytas av ett annat ``put()``-anrop i "
"samma tråd utan att det blir dödläge eller att det interna tillståndet i kön "
"korrumperas.  Detta gör den lämplig att använda i destruktorer som "
"``__del__`` metoder eller :mod:`weakref` callbacks."

msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with :"
"meth:`Queue.put_nowait`."
msgstr ""
"Motsvarar ``put(item, block=False)``, tillhandahålls för kompatibilitet med :"
"meth:`Queue.put_nowait`."

msgid "Class :class:`multiprocessing.Queue`"
msgstr "Klass :class:`multiprocessing.Queue`"

msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"En köklass för användning i en multiprocessing-kontext (snarare än multi-"
"threading)."

msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking and also "
"support indexing."
msgstr ""
":class:``collections.deque`` är en alternativ implementering av obegränsade "
"köer med snabba atomiska :meth:`~collections.deque.append`- och :meth:"
"`~collections.deque.popleft`-operationer som inte kräver låsning och som "
"även stöder indexering."
