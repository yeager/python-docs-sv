# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!difflib` --- Helpers for computing deltas"
msgstr ":mod:`!difflib` --- Hjälpmedel för att beräkna deltan"

msgid "**Source code:** :source:`Lib/difflib.py`"
msgstr "**Källkod:** :source:`Lib/difflib.py`"

msgid ""
"This module provides classes and functions for comparing sequences. It can "
"be used for example, for comparing files, and can produce information about "
"file differences in various formats, including HTML and context and unified "
"diffs. For comparing directories and files, see also, the :mod:`filecmp` "
"module."
msgstr ""
"Den här modulen innehåller klasser och funktioner för jämförelse av "
"sekvenser. Den kan till exempel användas för att jämföra filer och kan "
"producera information om filskillnader i olika format, inklusive HTML och "
"context och unified diffs. För jämförelse av kataloger och filer, se även "
"modulen :mod:`filecmp`."

msgid ""
"This is a flexible class for comparing pairs of sequences of any type, so "
"long as the sequence elements are :term:`hashable`.  The basic algorithm "
"predates, and is a little fancier than, an algorithm published in the late "
"1980's by Ratcliff and Obershelp under the hyperbolic name \"gestalt pattern "
"matching.\"  The idea is to find the longest contiguous matching subsequence "
"that contains no \"junk\" elements; these \"junk\" elements are ones that "
"are uninteresting in some sense, such as blank lines or whitespace.  "
"(Handling junk is an extension to the Ratcliff and Obershelp algorithm.) The "
"same idea is then applied recursively to the pieces of the sequences to the "
"left and to the right of the matching subsequence.  This does not yield "
"minimal edit sequences, but does tend to yield matches that \"look right\" "
"to people."
msgstr ""
"Detta är en flexibel klass för att jämföra par av sekvenser av alla typer, "
"så länge som sekvenselementen är :term:`hashable`.  Den grundläggande "
"algoritmen föregår, och är lite mer avancerad än, en algoritm som "
"publicerades i slutet av 1980-talet av Ratcliff och Obershelp under det "
"hyperboliska namnet \"gestalt pattern matching\"  Tanken är att hitta den "
"längsta sammanhängande matchande undersekvensen som inte innehåller några "
"\"skräp\"-element; dessa \"skräp\"-element är sådana som är ointressanta i "
"någon mening, till exempel tomma rader eller blanksteg.  (Hantering av skräp "
"är en utvidgning av Ratcliff och Obershelp-algoritmen.) Samma idé tillämpas "
"sedan rekursivt på delarna av sekvenserna till vänster och till höger om den "
"matchande undersekvensen.  Detta ger inte minimala redigeringssekvenser, men "
"tenderar att ge matchningar som \"ser rätt ut\" för människor."

msgid ""
"**Timing:** The basic Ratcliff-Obershelp algorithm is cubic time in the "
"worst case and quadratic time in the expected case. :class:`SequenceMatcher` "
"is quadratic time for the worst case and has expected-case behavior "
"dependent in a complicated way on how many elements the sequences have in "
"common; best case time is linear."
msgstr ""
"**Timing:** Den grundläggande Ratcliff-Obershelp-algoritmen är kubisk tid i "
"värsta fall och kvadratisk tid i det förväntade fallet. :class:"
"`SequenceMatcher` är kvadratisk tid i värsta fall och har ett förväntat "
"beteende som på ett komplicerat sätt beror på hur många element sekvenserna "
"har gemensamt; bästa fall är tiden linjär."

msgid ""
"**Automatic junk heuristic:** :class:`SequenceMatcher` supports a heuristic "
"that automatically treats certain sequence items as junk. The heuristic "
"counts how many times each individual item appears in the sequence. If an "
"item's duplicates (after the first one) account for more than 1% of the "
"sequence and the sequence is at least 200 items long, this item is marked as "
"\"popular\" and is treated as junk for the purpose of sequence matching. "
"This heuristic can be turned off by setting the ``autojunk`` argument to "
"``False`` when creating the :class:`SequenceMatcher`."
msgstr ""
"**Automatisk skräpheuristik:** :class:`SequenceMatcher` stöder en heuristik "
"som automatiskt behandlar vissa sekvensobjekt som skräp. Heuristiken räknar "
"hur många gånger varje enskilt objekt förekommer i sekvensen. Om ett objekts "
"duplikat (efter det första) utgör mer än 1% of av sekvensen och sekvensen är "
"minst 200 objekt lång, markeras detta objekt som \"populärt\" och behandlas "
"som skräp vid sekvensmatchning. Denna heuristik kan stängas av genom att "
"ställa in argumentet ``autojunk`` till ``False`` när du skapar :class:"
"`SequenceMatcher`."

msgid "Added the *autojunk* parameter."
msgstr "Lagt till parametern *autojunk*."

msgid ""
"This is a class for comparing sequences of lines of text, and producing "
"human-readable differences or deltas.  Differ uses :class:`SequenceMatcher` "
"both to compare sequences of lines, and to compare sequences of characters "
"within similar (near-matching) lines."
msgstr ""
"Detta är en klass för att jämföra sekvenser av textrader och producera "
"mänskligt läsbara skillnader eller deltan.  Differ använder :class:"
"`SequenceMatcher` både för att jämföra sekvenser av rader och för att "
"jämföra sekvenser av tecken inom liknande (nästan matchande) rader."

msgid "Each line of a :class:`Differ` delta begins with a two-letter code:"
msgstr ""
"Varje rad i ett :class:`Differ` delta börjar med en kod på två bokstäver:"

msgid "Code"
msgstr "Kod"

msgid "Meaning"
msgstr "Betydelse"

msgid "``'- '``"
msgstr "``'- '``"

msgid "line unique to sequence 1"
msgstr "linje unik för sekvens 1"

msgid "``'+ '``"
msgstr "``'+ '``"

msgid "line unique to sequence 2"
msgstr "linje unik för sekvens 2"

msgid "``'  '``"
msgstr "``' '``"

msgid "line common to both sequences"
msgstr "linje som är gemensam för båda sekvenserna"

msgid "``'? '``"
msgstr "``'? '``"

msgid "line not present in either input sequence"
msgstr "rad som inte finns i någon av de ingående sekvenserna"

msgid ""
"Lines beginning with '``?``' attempt to guide the eye to intraline "
"differences, and were not present in either input sequence. These lines can "
"be confusing if the sequences contain whitespace characters, such as spaces, "
"tabs or line breaks."
msgstr ""
"Rader som börjar med \"``?``\" försöker vägleda ögat till "
"intralinjeskillnader och fanns inte i någon av indatasekvenserna. Dessa "
"rader kan vara förvirrande om sekvenserna innehåller tecken för blanksteg, t."
"ex. mellanslag, tabbar eller radbrytningar."

msgid ""
"This class can be used to create an HTML table (or a complete HTML file "
"containing the table) showing a side by side, line by line comparison of "
"text with inter-line and intra-line change highlights.  The table can be "
"generated in either full or contextual difference mode."
msgstr ""
"Denna klass kan användas för att skapa en HTML-tabell (eller en komplett "
"HTML-fil som innehåller tabellen) som visar en jämförelse av text sida vid "
"sida, rad för rad med markeringar för ändringar mellan och inom raderna.  "
"Tabellen kan genereras i antingen fullständigt eller kontextuellt "
"skillnadsläge."

msgid "The constructor for this class is:"
msgstr "Konstruktören för denna klass är:"

msgid "Initializes instance of :class:`HtmlDiff`."
msgstr "Initialiserar en instans av :class:`HtmlDiff`."

msgid ""
"*tabsize* is an optional keyword argument to specify tab stop spacing and "
"defaults to ``8``."
msgstr ""
"*tabsize* är ett valfritt nyckelordsargument för att ange "
"tabbstoppsavståndet och standardvärdet är ``8``."

msgid ""
"*wrapcolumn* is an optional keyword to specify column number where lines are "
"broken and wrapped, defaults to ``None`` where lines are not wrapped."
msgstr ""
"*wrapcolumn* är ett valfritt nyckelord för att ange kolumnnumret där raderna "
"bryts och omsluts, standard är ``None`` där raderna inte omsluts."

msgid ""
"*linejunk* and *charjunk* are optional keyword arguments passed into :func:"
"`ndiff` (used by :class:`HtmlDiff` to generate the side by side HTML "
"differences).  See :func:`ndiff` documentation for argument default values "
"and descriptions."
msgstr ""
"*linejunk* och *charjunk* är valfria nyckelordsargument som skickas till :"
"func:`ndiff` (används av :class:`HtmlDiff` för att generera HTML-skillnader "
"sida vid sida).  Se :func:`ndiff` dokumentation för argumentens "
"standardvärden och beskrivningar."

msgid "The following methods are public:"
msgstr "Följande metoder är publika:"

msgid ""
"Compares *fromlines* and *tolines* (lists of strings) and returns a string "
"which is a complete HTML file containing a table showing line by line "
"differences with inter-line and intra-line changes highlighted."
msgstr ""
"Jämför *fromlines* och *tolines* (listor med strängar) och returnerar en "
"sträng som är en komplett HTML-fil innehållande en tabell som visar "
"skillnader rad för rad med förändringar mellan och inom raderna markerade."

msgid ""
"*fromdesc* and *todesc* are optional keyword arguments to specify from/to "
"file column header strings (both default to an empty string)."
msgstr ""
"*fromdesc* och *todesc* är valfria nyckelordsargument för att ange "
"kolumnhuvudsträngar för från/till-filen (båda har en tom sträng som "
"standard)."

msgid ""
"*context* and *numlines* are both optional keyword arguments. Set *context* "
"to ``True`` when contextual differences are to be shown, else the default is "
"``False`` to show the full files. *numlines* defaults to ``5``.  When "
"*context* is ``True`` *numlines* controls the number of context lines which "
"surround the difference highlights.  When *context* is ``False`` *numlines* "
"controls the number of lines which are shown before a difference highlight "
"when using the \"next\" hyperlinks (setting to zero would cause the \"next\" "
"hyperlinks to place the next difference highlight at the top of the browser "
"without any leading context)."
msgstr ""
"*context* och *numlines* är båda valfria nyckelordsargument. Sätt *context* "
"till ``True`` när kontextuella skillnader ska visas, annars är "
"standardvärdet ``False`` för att visa de fullständiga filerna. *numlines* är "
"som standard ``5``.  När *context* är ``True`` styr *numlines* antalet "
"kontextlinjer som omger de markerade skillnaderna.  När *kontext* är "
"``False`` styr *numlines* antalet rader som visas före en skillnadsmarkering "
"när du använder hyperlänkarna \"next\" (om du ställer in noll skulle "
"hyperlänkarna \"next\" placera nästa skillnadsmarkering högst upp i "
"webbläsaren utan någon ledande kontext)."

msgid ""
"*fromdesc* and *todesc* are interpreted as unescaped HTML and should be "
"properly escaped while receiving input from untrusted sources."
msgstr ""
"*fromdesc* och *todesc* tolkas som oescapad HTML och bör escapas på rätt "
"sätt när man tar emot indata från icke tillförlitliga källor."

msgid ""
"*charset* keyword-only argument was added.  The default charset of HTML "
"document changed from ``'ISO-8859-1'`` to ``'utf-8'``."
msgstr ""
"*charset* nyckelord-bara argument lades till.  HTML-dokumentets "
"standardcharset ändrades från ``'ISO-8859-1'`` till ``'utf-8'``."

msgid ""
"Compares *fromlines* and *tolines* (lists of strings) and returns a string "
"which is a complete HTML table showing line by line differences with inter-"
"line and intra-line changes highlighted."
msgstr ""
"Jämför *fromlines* och *tolines* (listor med strängar) och returnerar en "
"sträng som är en komplett HTML-tabell som visar skillnader rad för rad med "
"förändringar mellan och inom raderna markerade."

msgid ""
"The arguments for this method are the same as those for the :meth:"
"`make_file` method."
msgstr ""
"Argumenten för den här metoden är desamma som för metoden :meth:`make_file`."

msgid ""
"Compare *a* and *b* (lists of strings); return a delta (a :term:`generator` "
"generating the delta lines) in context diff format."
msgstr ""
"Jämför *a* och *b* (listor med strängar); returnerar ett delta (en :term:"
"`generator` som genererar delta-raderna) i context diff-format."

msgid ""
"Context diffs are a compact way of showing just the lines that have changed "
"plus a few lines of context.  The changes are shown in a before/after "
"style.  The number of context lines is set by *n* which defaults to three."
msgstr ""
"Kontextdifferenser är ett kompakt sätt att visa bara de rader som har "
"ändrats plus några rader med sammanhang.  Ändringarna visas i en före/efter-"
"stil.  Antalet kontextrader anges av *n* som standard är tre."

msgid ""
"By default, the diff control lines (those with ``***`` or ``---``) are "
"created with a trailing newline.  This is helpful so that inputs created "
"from :func:`io.IOBase.readlines` result in diffs that are suitable for use "
"with :func:`io.IOBase.writelines` since both the inputs and outputs have "
"trailing newlines."
msgstr ""
"Som standard skapas kontrollinjerna för diff (de med ``***`` eller ``---``) "
"med en efterföljande ny rad.  Detta är till hjälp så att inmatningar som "
"skapas från :func:`io.IOBase.readlines` resulterar i diffar som är lämpliga "
"att använda med :func:`io.IOBase.writelines` eftersom både inmatningar och "
"utmatningar har efterföljande nya rader."

msgid ""
"For inputs that do not have trailing newlines, set the *lineterm* argument "
"to ``\"\"`` so that the output will be uniformly newline free."
msgstr ""
"För indata som inte har efterföljande nya rader, sätt *lineterm*-argumentet "
"till ``\"\"`` så att utdata kommer att vara enhetligt fria från nya rader."

msgid ""
"The context diff format normally has a header for filenames and modification "
"times.  Any or all of these may be specified using strings for *fromfile*, "
"*tofile*, *fromfiledate*, and *tofiledate*.  The modification times are "
"normally expressed in the ISO 8601 format. If not specified, the strings "
"default to blanks."
msgstr ""
"Formatet för context diff har normalt ett huvud för filnamn och "
"ändringstider.  Alla eller några av dessa kan anges med strängar för "
"*fromfile*, *tofile*, *fromfiledate* och *tofiledate*.  Modifieringstiderna "
"uttrycks normalt i ISO 8601-format. Om strängarna inte specificeras är "
"standardvärdet blanksteg."

msgid "See :ref:`difflib-interface` for a more detailed example."
msgstr "Se :ref:`difflib-interface` för ett mer detaljerat exempel."

msgid ""
"Return a list of the best \"good enough\" matches.  *word* is a sequence for "
"which close matches are desired (typically a string), and *possibilities* is "
"a list of sequences against which to match *word* (typically a list of "
"strings)."
msgstr ""
"Returnerar en lista med de bästa \"tillräckligt bra\"-matchningarna.  *word* "
"är en sekvens för vilken nära matchningar önskas (vanligtvis en sträng) och "
"*possibilities* är en lista med sekvenser som *word* kan matchas mot "
"(vanligtvis en lista med strängar)."

msgid ""
"Optional argument *n* (default ``3``) is the maximum number of close matches "
"to return; *n* must be greater than ``0``."
msgstr ""
"Valfritt argument *n* (standard ``3``) är det maximala antalet nära "
"matchningar som ska returneras; *n* måste vara större än ``0``."

msgid ""
"Optional argument *cutoff* (default ``0.6``) is a float in the range [0, 1]. "
"Possibilities that don't score at least that similar to *word* are ignored."
msgstr ""
"Det valfria argumentet *cutoff* (standard ``0.6``) är en float i intervallet "
"[0, 1]. Möjligheter som inte har en poäng som är minst lika stor som *ord* "
"ignoreras."

msgid ""
"The best (no more than *n*) matches among the possibilities are returned in "
"a list, sorted by similarity score, most similar first."
msgstr ""
"De bästa (högst *n*) matchningarna bland möjligheterna returneras i en "
"lista, sorterade efter likhetspoäng, mest lika först."

msgid ""
"Compare *a* and *b* (lists of strings); return a :class:`Differ`\\ -style "
"delta (a :term:`generator` generating the delta lines)."
msgstr ""
"Jämför *a* och *b* (listor med strängar); returnera ett delta i stil med :"
"class:`Differ` (en :term:`generator` som genererar deltaraderna)."

msgid ""
"Optional keyword parameters *linejunk* and *charjunk* are filtering "
"functions (or ``None``):"
msgstr ""
"De valfria nyckelordsparametrarna *linejunk* och *charjunk* är "
"filtreringsfunktioner (eller ``None``):"

msgid ""
"*linejunk*: A function that accepts a single string argument, and returns "
"true if the string is junk, or false if not. The default is ``None``. There "
"is also a module-level function :func:`IS_LINE_JUNK`, which filters out "
"lines without visible characters, except for at most one pound character "
"(``'#'``) -- however the underlying :class:`SequenceMatcher` class does a "
"dynamic analysis of which lines are so frequent as to constitute noise, and "
"this usually works better than using this function."
msgstr ""
"*linejunk*: En funktion som accepterar ett enda strängargument och "
"returnerar true om strängen är skräp, eller false om den inte är det. "
"Standardvärdet är ``None``. Det finns också en funktion på modulnivå :func:"
"`IS_LINE_JUNK`, som filtrerar bort rader utan synliga tecken, förutom högst "
"ett pundtecken (``'#'``) -- den underliggande klassen :class:"
"`SequenceMatcher` gör dock en dynamisk analys av vilka rader som är så "
"frekventa att de utgör brus, och detta fungerar vanligtvis bättre än att "
"använda den här funktionen."

msgid ""
"*charjunk*: A function that accepts a character (a string of length 1), and "
"returns if the character is junk, or false if not. The default is module-"
"level function :func:`IS_CHARACTER_JUNK`, which filters out whitespace "
"characters (a blank or tab; it's a bad idea to include newline in this!)."
msgstr ""
"*charjunk*: En funktion som accepterar ett tecken (en sträng med längden 1) "
"och returnerar om tecknet är skräp, eller false om det inte är det. Standard "
"är modulnivåfunktionen :func:`IS_CHARACTER_JUNK`, som filtrerar bort "
"blankstegstecken (ett blanksteg eller en tabb; det är en dålig idé att "
"inkludera newline i detta!)"

msgid "Return one of the two sequences that generated a delta."
msgstr "Returnera en av de två sekvenser som genererade ett delta."

msgid ""
"Given a *sequence* produced by :meth:`Differ.compare` or :func:`ndiff`, "
"extract lines originating from file 1 or 2 (parameter *which*), stripping "
"off line prefixes."
msgstr ""
"Givet en *sekvens* producerad av :meth:`Differ.compare` eller :func:`ndiff`, "
"extrahera rader som härrör från fil 1 eller 2 (parameter *which*) och ta "
"bort radprefix."

msgid "Example:"
msgstr "Exempel:"

msgid ""
"Compare *a* and *b* (lists of strings); return a delta (a :term:`generator` "
"generating the delta lines) in unified diff format."
msgstr ""
"Jämför *a* och *b* (listor med strängar); returnerar ett delta (en :term:"
"`generator` som genererar delta-raderna) i unified diff-format."

msgid ""
"Unified diffs are a compact way of showing just the lines that have changed "
"plus a few lines of context.  The changes are shown in an inline style "
"(instead of separate before/after blocks).  The number of context lines is "
"set by *n* which defaults to three."
msgstr ""
"Unified diffs är ett kompakt sätt att bara visa de rader som har ändrats "
"plus några rader med sammanhang.  Ändringarna visas i en inline-stil (i "
"stället för separata före/efter-block).  Antalet kontextrader anges av *n* "
"som standard är tre."

msgid ""
"By default, the diff control lines (those with ``---``, ``+++``, or ``@@``) "
"are created with a trailing newline.  This is helpful so that inputs created "
"from :func:`io.IOBase.readlines` result in diffs that are suitable for use "
"with :func:`io.IOBase.writelines` since both the inputs and outputs have "
"trailing newlines."
msgstr ""
"Som standard skapas kontrollinjerna för diff (de med ``---``, ``+++`` eller "
"``@@``) med en efterföljande ny rad.  Detta är till hjälp så att inmatningar "
"som skapas från :func:`io.IOBase.readlines` resulterar i diffar som är "
"lämpliga att använda med :func:`io.IOBase.writelines` eftersom både "
"inmatningar och utmatningar har efterföljande nya rader."

msgid ""
"The unified diff format normally has a header for filenames and modification "
"times.  Any or all of these may be specified using strings for *fromfile*, "
"*tofile*, *fromfiledate*, and *tofiledate*.  The modification times are "
"normally expressed in the ISO 8601 format. If not specified, the strings "
"default to blanks."
msgstr ""
"Det enhetliga diff-formatet har normalt ett huvud för filnamn och "
"ändringstider.  Alla eller några av dessa kan anges med strängar för "
"*fromfile*, *tofile*, *fromfiledate* och *tofiledate*.  Modifieringstiderna "
"uttrycks normalt i ISO 8601-format. Om strängarna inte specificeras är "
"standardvärdet blanksteg."

msgid ""
"Compare *a* and *b* (lists of bytes objects) using *dfunc*; yield a sequence "
"of delta lines (also bytes) in the format returned by *dfunc*. *dfunc* must "
"be a callable, typically either :func:`unified_diff` or :func:`context_diff`."
msgstr ""
"Jämför *a* och *b* (listor med bytesobjekt) med hjälp av *dfunc*; ger en "
"sekvens av deltarader (också bytes) i det format som returneras av *dfunc*. "
"*dfunc* måste vara en callable, typiskt antingen :func:`unified_diff` eller :"
"func:`context_diff`."

msgid ""
"Allows you to compare data with unknown or inconsistent encoding. All inputs "
"except *n* must be bytes objects, not str. Works by losslessly converting "
"all inputs (except *n*) to str, and calling ``dfunc(a, b, fromfile, tofile, "
"fromfiledate, tofiledate, n, lineterm)``. The output of *dfunc* is then "
"converted back to bytes, so the delta lines that you receive have the same "
"unknown/inconsistent encodings as *a* and *b*."
msgstr ""
"Gör det möjligt att jämföra data med okänd eller inkonsekvent kodning. Alla "
"indata utom *n* måste vara bytes-objekt, inte str. Fungerar genom att "
"förlustfritt konvertera alla indata (utom *n*) till str och anropa "
"``dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm)``. "
"Utdata från *dfunc* konverteras sedan tillbaka till bytes, så de deltarader "
"som du får har samma okända/inkonsekventa kodning som *a* och *b*."

msgid ""
"Return ``True`` for ignorable lines.  The line *line* is ignorable if *line* "
"is blank or contains a single ``'#'``, otherwise it is not ignorable.  Used "
"as a default for parameter *linejunk* in :func:`ndiff` in older versions."
msgstr ""
"Returnerar ``True`` för ignorerbara rader.  Raden *line* är ignorerbar om "
"*line* är tom eller innehåller en enda ``'#'``, annars är den inte "
"ignorerbar.  Används som standard för parametern *linejunk* i :func:`ndiff` "
"i äldre versioner."

msgid ""
"Return ``True`` for ignorable characters.  The character *ch* is ignorable "
"if *ch* is a space or tab, otherwise it is not ignorable.  Used as a default "
"for parameter *charjunk* in :func:`ndiff`."
msgstr ""
"Returnerar ``True`` för tecken som inte kan ignoreras.  Tecknet *ch* är "
"ignorerbart om *ch* är ett mellanslag eller en tabb, annars är det inte "
"ignorerbart.  Används som standard för parametern *charjunk* i :func:`ndiff`."

msgid ""
"`Pattern Matching: The Gestalt Approach <https://www.drdobbs.com/database/"
"pattern-matching-the-gestalt-approach/184407970>`_"
msgstr ""
"`Mönstermatchning: Gestaltmetoden <https://www.drdobbs.com/database/pattern-"
"matching-the-gestalt-approach/184407970>`_"

msgid ""
"Discussion of a similar algorithm by John W. Ratcliff and D. E. Metzener. "
"This was published in `Dr. Dobb's Journal <https://www.drdobbs.com/>`_ in "
"July, 1988."
msgstr ""
"Diskussion om en liknande algoritm av John W. Ratcliff och D. E. Metzener. "
"Detta publicerades i `Dr. Dobb's Journal <https://www.drdobbs.com/>`_ i juli "
"1988."

msgid "SequenceMatcher Objects"
msgstr "SequenceMatcher-objekt"

msgid "The :class:`SequenceMatcher` class has this constructor:"
msgstr "Klassen :class:`SequenceMatcher` har denna konstruktor:"

msgid ""
"Optional argument *isjunk* must be ``None`` (the default) or a one-argument "
"function that takes a sequence element and returns true if and only if the "
"element is \"junk\" and should be ignored. Passing ``None`` for *isjunk* is "
"equivalent to passing ``lambda x: False``; in other words, no elements are "
"ignored. For example, pass::"
msgstr ""
"Det valfria argumentet *isjunk* måste vara ``None`` (standard) eller en "
"funktion med ett argument som tar ett sekvenselement och returnerar true om "
"och endast om elementet är \"skräp\" och ska ignoreras. Att skicka ``None`` "
"för *isjunk* är likvärdigt med att skicka ``lambda x: False``; med andra ord "
"ignoreras inga element. Till exempel, pass::"

msgid "lambda x: x in \" \\t\""
msgstr "lambda x: x i \" \\t\""

msgid ""
"if you're comparing lines as sequences of characters, and don't want to "
"synch up on blanks or hard tabs."
msgstr ""
"om du jämför rader som sekvenser av tecken och inte vill synkronisera med "
"blanksteg eller hårda flikar."

msgid ""
"The optional arguments *a* and *b* are sequences to be compared; both "
"default to empty strings.  The elements of both sequences must be :term:"
"`hashable`."
msgstr ""
"De valfria argumenten *a* och *b* är sekvenser som ska jämföras; båda är "
"tomma strängar som standard.  Elementen i båda sekvenserna måste vara :term:"
"`hashable`."

msgid ""
"The optional argument *autojunk* can be used to disable the automatic junk "
"heuristic."
msgstr ""
"Det valfria argumentet *autojunk* kan användas för att inaktivera den "
"automatiska skräpheuristiken."

msgid ""
"SequenceMatcher objects get three data attributes: *bjunk* is the set of "
"elements of *b* for which *isjunk* is ``True``; *bpopular* is the set of non-"
"junk elements considered popular by the heuristic (if it is not disabled); "
"*b2j* is a dict mapping the remaining elements of *b* to a list of positions "
"where they occur. All three are reset whenever *b* is reset with :meth:"
"`set_seqs` or :meth:`set_seq2`."
msgstr ""
"SequenceMatcher-objekt får tre dataattribut: *bjunk* är den uppsättning "
"element i *b* för vilka *isjunk* är ``True``; *bpopular* är den uppsättning "
"element som inte är skräp som anses populära av heuristiken (om den inte är "
"inaktiverad); *b2j* är en dict som mappar de återstående elementen i *b* "
"till en lista över positioner där de förekommer. Alla tre återställs när *b* "
"återställs med :meth:`set_seqs` eller :meth:`set_seq2`."

msgid "The *bjunk* and *bpopular* attributes."
msgstr "Attributen *bjunk* och *bpopulär*."

msgid ":class:`SequenceMatcher` objects have the following methods:"
msgstr ":class:`SequenceMatcher`-objekt har följande metoder:"

msgid "Set the two sequences to be compared."
msgstr "Ställ in de två sekvenser som ska jämföras."

msgid ""
":class:`SequenceMatcher` computes and caches detailed information about the "
"second sequence, so if you want to compare one sequence against many "
"sequences, use :meth:`set_seq2` to set the commonly used sequence once and "
"call :meth:`set_seq1` repeatedly, once for each of the other sequences."
msgstr ""
":class:`SequenceMatcher` beräknar och lagrar detaljerad information om den "
"andra sekvensen, så om du vill jämföra en sekvens med många sekvenser kan du "
"använda :meth:`set_seq2` för att ställa in den vanliga sekvensen en gång och "
"anropa :meth:`set_seq1` upprepade gånger, en gång för var och en av de andra "
"sekvenserna."

msgid ""
"Set the first sequence to be compared.  The second sequence to be compared "
"is not changed."
msgstr ""
"Ställ in den första sekvensen som ska jämföras.  Den andra sekvensen som ska "
"jämföras ändras inte."

msgid ""
"Set the second sequence to be compared.  The first sequence to be compared "
"is not changed."
msgstr ""
"Ställ in den andra sekvensen som ska jämföras.  Den första sekvensen som ska "
"jämföras ändras inte."

msgid "Find longest matching block in ``a[alo:ahi]`` and ``b[blo:bhi]``."
msgstr ""
"Hitta det längsta matchande blocket i ``a[alo:ahi]`` och ``b[blo:bhi]``."

msgid ""
"If *isjunk* was omitted or ``None``, :meth:`find_longest_match` returns "
"``(i, j, k)`` such that ``a[i:i+k]`` is equal to ``b[j:j+k]``, where ``alo "
"<= i <= i+k <= ahi`` and ``blo <= j <= j+k <= bhi``. For all ``(i', j', "
"k')`` meeting those conditions, the additional conditions ``k >= k'``, ``i "
"<= i'``, and if ``i == i'``, ``j <= j'`` are also met. In other words, of "
"all maximal matching blocks, return one that starts earliest in *a*, and of "
"all those maximal matching blocks that start earliest in *a*, return the one "
"that starts earliest in *b*."
msgstr ""
"Om *isjunk* utelämnades eller ``None``, returnerar :meth:"
"`find_longest_match` ``(i, j, k)`` så att ``a[i:i+k]`` är lika med ``b[j:"
"j+k]``, där ``alo <= i <= i+k <= ahi`` och ``blo <= j <= j+k <= bhi``. För "
"alla ``(i', j', k')`` som uppfyller dessa villkor uppfylls också "
"tilläggsvillkoren ``k >= k'``, ``i <= i'``, och om ``i == i'``, ``j <= j'``. "
"Med andra ord, av alla maximalt matchande block, returnera det som börjar "
"tidigast i *a*, och av alla de maximalt matchande block som börjar tidigast "
"i *a*, returnera det som börjar tidigast i *b*."

msgid ""
"If *isjunk* was provided, first the longest matching block is determined as "
"above, but with the additional restriction that no junk element appears in "
"the block.  Then that block is extended as far as possible by matching "
"(only) junk elements on both sides. So the resulting block never matches on "
"junk except as identical junk happens to be adjacent to an interesting match."
msgstr ""
"Om *isjunk* har angetts, bestäms först det längsta matchande blocket enligt "
"ovan, men med den ytterligare begränsningen att inget junk-element får "
"förekomma i blocket.  Sedan förlängs det blocket så långt som möjligt genom "
"att matcha (endast) skräpelement på båda sidor. Det resulterande blocket "
"matchar alltså aldrig på skräp utom när identiskt skräp råkar ligga intill "
"en intressant matchning."

msgid ""
"Here's the same example as before, but considering blanks to be junk. That "
"prevents ``' abcd'`` from matching the ``' abcd'`` at the tail end of the "
"second sequence directly.  Instead only the ``'abcd'`` can match, and "
"matches the leftmost ``'abcd'`` in the second sequence:"
msgstr ""
"Här är samma exempel som tidigare, men där blanksteg betraktas som skräp. "
"Det hindrar ``' abcd'`` från att matcha ``' abcd'`` i slutet av den andra "
"sekvensen direkt.  Istället är det bara ``'abcd'`` som kan matcha, och den "
"matchar ``'abcd'`` längst till vänster i den andra sekvensen:"

msgid "If no blocks match, this returns ``(alo, blo, 0)``."
msgstr "Om inga block matchar returneras ``(alo, blo, 0)``."

msgid "This method returns a :term:`named tuple` ``Match(a, b, size)``."
msgstr ""
"Denna metod returnerar en :term:`namngiven tupel` ``Match(a, b, size)``."

msgid "Added default arguments."
msgstr "Lagt till standardargument."

msgid ""
"Return list of triples describing non-overlapping matching subsequences. "
"Each triple is of the form ``(i, j, n)``, and means that ``a[i:i+n] == b[j:"
"j+n]``.  The triples are monotonically increasing in *i* and *j*."
msgstr ""
"Returnerar en lista med tripplar som beskriver icke-överlappande matchande "
"undersekvenser. Varje trippel är av formen ``(i, j, n)`` och betyder att "
"``a[i:i+n] == b[j:j+n]``.  Tripplarna är monotont ökande i *i* och *j*."

msgid ""
"The last triple is a dummy, and has the value ``(len(a), len(b), 0)``.  It "
"is the only triple with ``n == 0``.  If ``(i, j, n)`` and ``(i', j', n')`` "
"are adjacent triples in the list, and the second is not the last triple in "
"the list, then ``i+n < i'`` or ``j+n < j'``; in other words, adjacent "
"triples always describe non-adjacent equal blocks."
msgstr ""
"Den sista trippeln är en dummy och har värdet ``(len(a), len(b), 0)``.  Det "
"är den enda trippeln med ``n == 0``.  Om ``(i, j, n)`` och ``(i', j', n')`` "
"är angränsande tripplar i listan och den andra inte är den sista trippeln i "
"listan, så är ``i+n < i'`` eller ``j+n < j'``; med andra ord beskriver "
"angränsande tripplar alltid icke angränsande lika block."

msgid ""
">>> s = SequenceMatcher(None, \"abxcd\", \"abcd\")\n"
">>> s.get_matching_blocks()\n"
"[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]"
msgstr ""
">>> s = SequenceMatcher(None, \"abxcd\", \"abcd\")\n"
">>> s.get_matching_blocks()\n"
"[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]"

msgid ""
"Return list of 5-tuples describing how to turn *a* into *b*. Each tuple is "
"of the form ``(tag, i1, i2, j1, j2)``.  The first tuple has ``i1 == j1 == "
"0``, and remaining tuples have *i1* equal to the *i2* from the preceding "
"tuple, and, likewise, *j1* equal to the previous *j2*."
msgstr ""
"Returnerar en lista med 5-tupler som beskriver hur man förvandlar *a* till "
"*b*. Varje tupel är av formen ``(tag, i1, i2, j1, j2)``.  Den första tupeln "
"har ``i1 == j1 == 0``, och de återstående tuplarna har *i1* lika med *i2* "
"från föregående tupel, och på samma sätt är *j1* lika med föregående *j2*."

msgid "The *tag* values are strings, with these meanings:"
msgstr "*tag*-värdena är strängar med följande betydelser:"

msgid "Value"
msgstr "Värde"

msgid "``'replace'``"
msgstr "``'ersätta'```"

msgid "``a[i1:i2]`` should be replaced by ``b[j1:j2]``."
msgstr "``a[i1:i2]`` bör ersättas med ``b[j1:j2]``."

msgid "``'delete'``"
msgstr "``'ta bort'```"

msgid "``a[i1:i2]`` should be deleted.  Note that ``j1 == j2`` in this case."
msgstr "``a[i1:i2]`` bör tas bort.  Observera att ``j1 == j2`` i detta fall."

msgid "``'insert'``"
msgstr "``'infoga'```"

msgid ""
"``b[j1:j2]`` should be inserted at ``a[i1:i1]``. Note that ``i1 == i2`` in "
"this case."
msgstr ""
"``b[j1:j2]`` bör infogas vid ``a[i1:i1]``. Observera att ``i1 == i2`` i "
"detta fall."

msgid "``'equal'``"
msgstr "``'lika'```"

msgid "``a[i1:i2] == b[j1:j2]`` (the sub-sequences are equal)."
msgstr "``a[i1:i2] == b[j1:j2]`` (undersekvenserna är lika)."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
">>> a = \"qabxcd\"\n"
">>> b = \"abycdf\"\n"
">>> s = SequenceMatcher(None, a, b)\n"
">>> for tag, i1, i2, j1, j2 in s.get_opcodes():\n"
"...     print('{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format(\n"
"...         tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))\n"
"delete    a[0:1] --> b[0:0]      'q' --> ''\n"
"equal     a[1:3] --> b[0:2]     'ab' --> 'ab'\n"
"replace   a[3:4] --> b[2:3]      'x' --> 'y'\n"
"equal     a[4:6] --> b[3:5]     'cd' --> 'cd'\n"
"insert    a[6:6] --> b[5:6]       '' --> 'f'"
msgstr ""
">>> a = \"qabxcd\"\n"
">>> b = \"abycdf\"\n"
">>> s = Sekvensmatchare(None, a, b)\n"
">>> for tag, i1, i2, j1, j2 in s.get_opcodes():\n"
"... print('{:7} a[{}:{}] -> b[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format(\n"
"... tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))\n"
"delete a[0:1] --> b[0:0] 'q' --> ''\n"
"equal a[1:3] --> b[0:2] 'ab' --> 'ab'\n"
"replace a[3:4] --> b[2:3] 'x' --> 'y'\n"
"equal a[4:6] --> b[3:5] 'cd' --> 'cd'\n"
"insert a[6:6] --> b[5:6] '' --> 'f'"

msgid "Return a :term:`generator` of groups with up to *n* lines of context."
msgstr ""
"Returnerar en :term:`generator` av grupper med upp till *n* rader av kontext."

msgid ""
"Starting with the groups returned by :meth:`get_opcodes`, this method splits "
"out smaller change clusters and eliminates intervening ranges which have no "
"changes."
msgstr ""
"Med utgångspunkt från de grupper som returneras av :meth:`get_opcodes`, "
"delar denna metod upp mindre förändringskluster och eliminerar "
"mellanliggande intervall som inte har några förändringar."

msgid "The groups are returned in the same format as :meth:`get_opcodes`."
msgstr "Grupperna returneras i samma format som :meth:`get_opcodes`."

msgid ""
"Return a measure of the sequences' similarity as a float in the range [0, 1]."
msgstr ""
"Returnerar ett mått på sekvensernas likhet som en flottör i intervallet [0, "
"1]."

msgid ""
"Where T is the total number of elements in both sequences, and M is the "
"number of matches, this is 2.0\\*M / T. Note that this is ``1.0`` if the "
"sequences are identical, and ``0.0`` if they have nothing in common."
msgstr ""
"Där T är det totala antalet element i båda sekvenserna och M är antalet "
"matchningar, är detta 2,0 \\ * M / T. Observera att detta är \"1,0\" om "
"sekvenserna är identiska och \"0,0\" om de inte har något gemensamt."

msgid ""
"This is expensive to compute if :meth:`get_matching_blocks` or :meth:"
"`get_opcodes` hasn't already been called, in which case you may want to try :"
"meth:`quick_ratio` or :meth:`real_quick_ratio` first to get an upper bound."
msgstr ""
"Detta är dyrt att beräkna om :meth:`get_matching_blocks` eller :meth:"
"`get_opcodes` inte redan har anropats, i vilket fall du kanske vill prova :"
"meth:`quick_ratio` eller :meth:`real_quick_ratio` först för att få en övre "
"gräns."

msgid ""
"Caution: The result of a :meth:`ratio` call may depend on the order of the "
"arguments. For instance::"
msgstr ""
"Varning för detta: Resultatet av ett :meth:`ratio`-anrop kan bero på "
"argumentens ordning. Till exempel::"

msgid ""
">>> SequenceMatcher(None, 'tide', 'diet').ratio()\n"
"0.25\n"
">>> SequenceMatcher(None, 'diet', 'tide').ratio()\n"
"0.5"
msgstr ""
">>> SequenceMatcher(None, 'tidvatten', 'diet').ratio()\n"
"0.25\n"
">>> SequenceMatcher(None, 'diet', 'tidvatten').ratio()\n"
"0.5"

msgid "Return an upper bound on :meth:`ratio` relatively quickly."
msgstr "Återge en övre gräns för :meth:`ratio` relativt snabbt."

msgid "Return an upper bound on :meth:`ratio` very quickly."
msgstr "Returnera en övre gräns för :meth:`ratio` mycket snabbt."

msgid ""
"The three methods that return the ratio of matching to total characters can "
"give different results due to differing levels of approximation, although :"
"meth:`~SequenceMatcher.quick_ratio` and :meth:`~SequenceMatcher."
"real_quick_ratio` are always at least as large as :meth:`~SequenceMatcher."
"ratio`:"
msgstr ""
"De tre metoder som returnerar förhållandet mellan matchande och totala "
"tecken kan ge olika resultat på grund av olika approximationsnivåer, även "
"om :meth:`~SequenceMatcher.quick_ratio` och :meth:`~SequenceMatcher."
"real_quick_ratio` alltid är minst lika stora som :meth:`~SequenceMatcher."
"ratio`:"

msgid "SequenceMatcher Examples"
msgstr "Exempel på SequenceMatcher"

msgid "This example compares two strings, considering blanks to be \"junk\":"
msgstr ""
"I det här exemplet jämförs två strängar, där blanksteg betraktas som "
"\"skräp\":"

msgid ""
":meth:`~SequenceMatcher.ratio` returns a float in [0, 1], measuring the "
"similarity of the sequences.  As a rule of thumb, a :meth:`~SequenceMatcher."
"ratio` value over 0.6 means the sequences are close matches:"
msgstr ""
":meth:`~SequenceMatcher.ratio` returnerar en float i [0, 1], som mäter "
"likheten mellan sekvenserna.  Som en tumregel innebär ett :meth:"
"`~SequenceMatcher.ratio`-värde över 0,6 att sekvenserna är nära matchningar:"

msgid ""
"If you're only interested in where the sequences match, :meth:"
"`~SequenceMatcher.get_matching_blocks` is handy:"
msgstr ""
"Om du bara är intresserad av var sekvenserna matchar är :meth:"
"`~SequenceMatcher.get_matching_blocks` praktiskt:"

msgid ""
"Note that the last tuple returned by :meth:`~SequenceMatcher."
"get_matching_blocks` is always a dummy, ``(len(a), len(b), 0)``, and this is "
"the only case in which the last tuple element (number of elements matched) "
"is ``0``."
msgstr ""
"Observera att den sista tupeln som returneras av :meth:`~SequenceMatcher."
"get_matching_blocks` alltid är en dummy, ``(len(a), len(b), 0)``, och detta "
"är det enda fallet där det sista tupelelementet (antal matchade element) är "
"``0``."

msgid ""
"If you want to know how to change the first sequence into the second, use :"
"meth:`~SequenceMatcher.get_opcodes`:"
msgstr ""
"Om du vill veta hur du ändrar den första sekvensen till den andra använder "
"du :meth:`~SequenceMatcher.get_opcodes`:"

msgid ""
"The :func:`get_close_matches` function in this module which shows how simple "
"code building on :class:`SequenceMatcher` can be used to do useful work."
msgstr ""
"Funktionen :func:`get_close_matches` i denna modul visar hur enkel kod som "
"bygger på :class:`SequenceMatcher` kan användas för att göra användbart "
"arbete."

msgid ""
"`Simple version control recipe <https://code.activestate.com/recipes/576729-"
"simple-version-control/>`_ for a small application built with :class:"
"`SequenceMatcher`."
msgstr ""
"``Enkelt recept för versionshantering <https://code.activestate.com/"
"recipes/576729-simple-version-control/>`_ för en liten applikation byggd "
"med :class:`SequenceMatcher`."

msgid "Differ Objects"
msgstr "Skillnad mellan objekt"

msgid ""
"Note that :class:`Differ`\\ -generated deltas make no claim to be "
"**minimal** diffs. To the contrary, minimal diffs are often counter-"
"intuitive, because they synch up anywhere possible, sometimes accidental "
"matches 100 pages apart. Restricting synch points to contiguous matches "
"preserves some notion of locality, at the occasional cost of producing a "
"longer diff."
msgstr ""
"Observera att :class:`Differ` -genererade deltan inte gör anspråk på att "
"vara **minimala** differenser. Tvärtom är minimala skillnader ofta "
"kontraintuitiva, eftersom de synkroniserar överallt där det är möjligt, "
"ibland oavsiktliga matchningar med 100 sidors mellanrum. Genom att begränsa "
"synkroniseringspunkterna till sammanhängande matchningar bevaras en viss "
"lokalitet, men ibland till priset av en längre diff."

msgid "The :class:`Differ` class has this constructor:"
msgstr "Klassen :class:`Differ` har denna konstruktor:"

msgid ""
"Optional keyword parameters *linejunk* and *charjunk* are for filter "
"functions (or ``None``):"
msgstr ""
"De valfria nyckelordsparametrarna *linejunk* och *charjunk* är för "
"filterfunktioner (eller ``None``):"

msgid ""
"*linejunk*: A function that accepts a single string argument, and returns "
"true if the string is junk.  The default is ``None``, meaning that no line "
"is considered junk."
msgstr ""
"*linejunk*: En funktion som accepterar ett enda strängargument och "
"returnerar true om strängen är skräp.  Standardvärdet är ``None``, vilket "
"innebär att ingen rad betraktas som skräp."

msgid ""
"*charjunk*: A function that accepts a single character argument (a string of "
"length 1), and returns true if the character is junk. The default is "
"``None``, meaning that no character is considered junk."
msgstr ""
"*charjunk*: En funktion som accepterar ett enda teckenargument (en sträng "
"med längden 1) och returnerar true om tecknet är skräp. Standardvärdet är "
"``None``, vilket innebär att inget tecken betraktas som skräp."

msgid ""
"These junk-filtering functions speed up matching to find differences and do "
"not cause any differing lines or characters to be ignored.  Read the "
"description of the :meth:`~SequenceMatcher.find_longest_match` method's "
"*isjunk* parameter for an explanation."
msgstr ""
"Dessa skräpfiltreringsfunktioner påskyndar matchningen för att hitta "
"skillnader och gör inte att några avvikande rader eller tecken ignoreras.  "
"Läs beskrivningen av :meth:`~SequenceMatcher.find_longest_match`-metodens "
"parameter *isjunk* för en förklaring."

msgid ""
":class:`Differ` objects are used (deltas generated) via a single method:"
msgstr ":class:`Differ`-objekt används (deltan genereras) via en enda metod:"

msgid ""
"Compare two sequences of lines, and generate the delta (a sequence of lines)."
msgstr ""
"Jämför två sekvenser av linjer och generera deltaet (en sekvens av linjer)."

msgid ""
"Each sequence must contain individual single-line strings ending with "
"newlines.  Such sequences can be obtained from the :meth:`~io.IOBase."
"readlines` method of file-like objects.  The delta generated also consists "
"of newline-terminated strings, ready to be printed as-is via the :meth:`~io."
"IOBase.writelines` method of a file-like object."
msgstr ""
"Varje sekvens måste innehålla enskilda enradiga strängar som slutar med nya "
"linjer.  Sådana sekvenser kan erhållas från metoden :meth:`~io.IOBase."
"readlines` för filliknande objekt.  Det genererade deltat består också av "
"strängar som avslutas med nya rader, redo att skrivas ut som de är via "
"metoden :meth:`~io.IOBase.writelines` för ett filliknande objekt."

msgid "Differ Example"
msgstr "Skillnad Exempel"

msgid ""
"This example compares two texts. First we set up the texts, sequences of "
"individual single-line strings ending with newlines (such sequences can also "
"be obtained from the :meth:`~io.IOBase.readlines` method of file-like "
"objects):"
msgstr ""
"I detta exempel jämförs två texter. Först ställer vi in texterna, sekvenser "
"av enskilda enradiga strängar som slutar med nya rader (sådana sekvenser kan "
"också erhållas från :meth:`~io.IOBase.readlines`-metoden för filliknande "
"objekt):"

msgid "Next we instantiate a Differ object:"
msgstr "Därefter instansierar vi ett Differ-objekt:"

msgid ""
"Note that when instantiating a :class:`Differ` object we may pass functions "
"to filter out line and character \"junk.\"  See the :meth:`Differ` "
"constructor for details."
msgstr ""
"Observera att när vi instansierar ett :class:`Differ`-objekt kan vi skicka "
"funktioner för att filtrera bort \"skräp\" i rader och tecken  Se :meth:"
"`Differ`-konstruktören för detaljer."

msgid "Finally, we compare the two:"
msgstr "Slutligen jämför vi de två:"

msgid "``result`` is a list of strings, so let's pretty-print it:"
msgstr "``result`` är en lista med strängar, så låt oss pretty-printa den:"

msgid "As a single multi-line string it looks like this:"
msgstr "Som en enda sträng med flera rader ser det ut så här:"

msgid "A command-line interface to difflib"
msgstr "Ett kommandoradsgränssnitt för difflib"

msgid ""
"This example shows how to use difflib to create a ``diff``-like utility."
msgstr ""
"Detta exempel visar hur man använder difflib för att skapa ett ``diff``-"
"liknande verktyg."

msgid ""
"\"\"\" Command line interface to difflib.py providing diffs in four "
"formats:\n"
"\n"
"* ndiff:    lists every line and highlights interline changes.\n"
"* context:  highlights clusters of changes in a before/after format.\n"
"* unified:  highlights clusters of changes in an inline format.\n"
"* html:     generates side by side comparison with change highlights.\n"
"\n"
"\"\"\"\n"
"\n"
"import sys, os, difflib, argparse\n"
"from datetime import datetime, timezone\n"
"\n"
"def file_mtime(path):\n"
"    t = datetime.fromtimestamp(os.stat(path).st_mtime,\n"
"                               timezone.utc)\n"
"    return t.astimezone().isoformat()\n"
"\n"
"def main():\n"
"\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-c', action='store_true', default=False,\n"
"                        help='Produce a context format diff (default)')\n"
"    parser.add_argument('-u', action='store_true', default=False,\n"
"                        help='Produce a unified format diff')\n"
"    parser.add_argument('-m', action='store_true', default=False,\n"
"                        help='Produce HTML side by side diff '\n"
"                             '(can use -c and -l in conjunction)')\n"
"    parser.add_argument('-n', action='store_true', default=False,\n"
"                        help='Produce a ndiff format diff')\n"
"    parser.add_argument('-l', '--lines', type=int, default=3,\n"
"                        help='Set number of context lines (default 3)')\n"
"    parser.add_argument('fromfile')\n"
"    parser.add_argument('tofile')\n"
"    options = parser.parse_args()\n"
"\n"
"    n = options.lines\n"
"    fromfile = options.fromfile\n"
"    tofile = options.tofile\n"
"\n"
"    fromdate = file_mtime(fromfile)\n"
"    todate = file_mtime(tofile)\n"
"    with open(fromfile) as ff:\n"
"        fromlines = ff.readlines()\n"
"    with open(tofile) as tf:\n"
"        tolines = tf.readlines()\n"
"\n"
"    if options.u:\n"
"        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"    elif options.n:\n"
"        diff = difflib.ndiff(fromlines, tolines)\n"
"    elif options.m:\n"
"        diff = difflib.HtmlDiff().make_file(fromlines,tolines,fromfile,"
"tofile,context=options.c,numlines=n)\n"
"    else:\n"
"        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"\n"
"    sys.stdout.writelines(diff)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""
"\"\"\" Command line interface to difflib.py providing diffs in four "
"formats:\n"
"\n"
"* ndiff:    lists every line and highlights interline changes.\n"
"* context:  highlights clusters of changes in a before/after format.\n"
"* unified:  highlights clusters of changes in an inline format.\n"
"* html:     generates side by side comparison with change highlights.\n"
"\n"
"\"\"\"\n"
"\n"
"import sys, os, difflib, argparse\n"
"from datetime import datetime, timezone\n"
"\n"
"def file_mtime(path):\n"
"    t = datetime.fromtimestamp(os.stat(path).st_mtime,\n"
"                               timezone.utc)\n"
"    return t.astimezone().isoformat()\n"
"\n"
"def main():\n"
"\n"
"    parser = argparse.ArgumentParser()\n"
"    parser.add_argument('-c', action='store_true', default=False,\n"
"                        help='Produce a context format diff (default)')\n"
"    parser.add_argument('-u', action='store_true', default=False,\n"
"                        help='Produce a unified format diff')\n"
"    parser.add_argument('-m', action='store_true', default=False,\n"
"                        help='Produce HTML side by side diff '\n"
"                             '(can use -c and -l in conjunction)')\n"
"    parser.add_argument('-n', action='store_true', default=False,\n"
"                        help='Produce a ndiff format diff')\n"
"    parser.add_argument('-l', '--lines', type=int, default=3,\n"
"                        help='Set number of context lines (default 3)')\n"
"    parser.add_argument('fromfile')\n"
"    parser.add_argument('tofile')\n"
"    options = parser.parse_args()\n"
"\n"
"    n = options.lines\n"
"    fromfile = options.fromfile\n"
"    tofile = options.tofile\n"
"\n"
"    fromdate = file_mtime(fromfile)\n"
"    todate = file_mtime(tofile)\n"
"    with open(fromfile) as ff:\n"
"        fromlines = ff.readlines()\n"
"    with open(tofile) as tf:\n"
"        tolines = tf.readlines()\n"
"\n"
"    if options.u:\n"
"        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"    elif options.n:\n"
"        diff = difflib.ndiff(fromlines, tolines)\n"
"    elif options.m:\n"
"        diff = difflib.HtmlDiff().make_file(fromlines,tolines,fromfile,"
"tofile,context=options.c,numlines=n)\n"
"    else:\n"
"        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, "
"fromdate, todate, n=n)\n"
"\n"
"    sys.stdout.writelines(diff)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"

msgid "ndiff example"
msgstr "ndiff exempel"

msgid "This example shows how to use :func:`difflib.ndiff`."
msgstr "Detta exempel visar hur man använder :func:`difflib.ndiff`."

msgid ""
"\"\"\"ndiff [-q] file1 file2\n"
"    or\n"
"ndiff (-r1 | -r2) < ndiff_output > file1_or_file2\n"
"\n"
"Print a human-friendly file difference report to stdout.  Both inter-\n"
"and intra-line differences are noted.  In the second form, recreate file1\n"
"(-r1) or file2 (-r2) on stdout, from an ndiff report on stdin.\n"
"\n"
"In the first form, if -q (\"quiet\") is not specified, the first two lines\n"
"of output are\n"
"\n"
"-: file1\n"
"+: file2\n"
"\n"
"Each remaining line begins with a two-letter code:\n"
"\n"
"    \"- \"    line unique to file1\n"
"    \"+ \"    line unique to file2\n"
"    \"  \"    line common to both files\n"
"    \"? \"    line not present in either input file\n"
"\n"
"Lines beginning with \"? \" attempt to guide the eye to intraline\n"
"differences, and were not present in either input file.  These lines can be\n"
"confusing if the source files contain tab characters.\n"
"\n"
"The first file can be recovered by retaining only lines that begin with\n"
"\"  \" or \"- \", and deleting those 2-character prefixes; use ndiff with -"
"r1.\n"
"\n"
"The second file can be recovered similarly, but by retaining only \"  \" "
"and\n"
"\"+ \" lines; use ndiff with -r2; or, on Unix, the second file can be\n"
"recovered by piping the output through\n"
"\n"
"    sed -n '/^[+ ] /s/^..//p'\n"
"\"\"\"\n"
"\n"
"__version__ = 1, 7, 0\n"
"\n"
"import difflib, sys\n"
"\n"
"def fail(msg):\n"
"    out = sys.stderr.write\n"
"    out(msg + \"\\n\\n\")\n"
"    out(__doc__)\n"
"    return 0\n"
"\n"
"# open a file & return the file object; gripe and return 0 if it\n"
"# couldn't be opened\n"
"def fopen(fname):\n"
"    try:\n"
"        return open(fname)\n"
"    except IOError as detail:\n"
"        return fail(\"couldn't open \" + fname + \": \" + str(detail))\n"
"\n"
"# open two files & spray the diff to stdout; return false iff a problem\n"
"def fcompare(f1name, f2name):\n"
"    f1 = fopen(f1name)\n"
"    f2 = fopen(f2name)\n"
"    if not f1 or not f2:\n"
"        return 0\n"
"\n"
"    a = f1.readlines(); f1.close()\n"
"    b = f2.readlines(); f2.close()\n"
"    for line in difflib.ndiff(a, b):\n"
"        print(line, end=' ')\n"
"\n"
"    return 1\n"
"\n"
"# crack args (sys.argv[1:] is normal) & compare;\n"
"# return false iff a problem\n"
"\n"
"def main(args):\n"
"    import getopt\n"
"    try:\n"
"        opts, args = getopt.getopt(args, \"qr:\")\n"
"    except getopt.error as detail:\n"
"        return fail(str(detail))\n"
"    noisy = 1\n"
"    qseen = rseen = 0\n"
"    for opt, val in opts:\n"
"        if opt == \"-q\":\n"
"            qseen = 1\n"
"            noisy = 0\n"
"        elif opt == \"-r\":\n"
"            rseen = 1\n"
"            whichfile = val\n"
"    if qseen and rseen:\n"
"        return fail(\"can't specify both -q and -r\")\n"
"    if rseen:\n"
"        if args:\n"
"            return fail(\"no args allowed with -r option\")\n"
"        if whichfile in (\"1\", \"2\"):\n"
"            restore(whichfile)\n"
"            return 1\n"
"        return fail(\"-r value must be 1 or 2\")\n"
"    if len(args) != 2:\n"
"        return fail(\"need 2 filename args\")\n"
"    f1name, f2name = args\n"
"    if noisy:\n"
"        print('-:', f1name)\n"
"        print('+:', f2name)\n"
"    return fcompare(f1name, f2name)\n"
"\n"
"# read ndiff output from stdin, and print file1 (which=='1') or\n"
"# file2 (which=='2') to stdout\n"
"\n"
"def restore(which):\n"
"    restored = difflib.restore(sys.stdin.readlines(), which)\n"
"    sys.stdout.writelines(restored)\n"
"\n"
"if __name__ == '__main__':\n"
"    main(sys.argv[1:])\n"
msgstr ""
"\"\"\"ndiff [-q] file1 file2\n"
"    or\n"
"ndiff (-r1 | -r2) < ndiff_output > file1_or_file2\n"
"\n"
"Print a human-friendly file difference report to stdout.  Both inter-\n"
"and intra-line differences are noted.  In the second form, recreate file1\n"
"(-r1) or file2 (-r2) on stdout, from an ndiff report on stdin.\n"
"\n"
"In the first form, if -q (\"quiet\") is not specified, the first two lines\n"
"of output are\n"
"\n"
"-: file1\n"
"+: file2\n"
"\n"
"Each remaining line begins with a two-letter code:\n"
"\n"
"    \"- \"    line unique to file1\n"
"    \"+ \"    line unique to file2\n"
"    \"  \"    line common to both files\n"
"    \"? \"    line not present in either input file\n"
"\n"
"Lines beginning with \"? \" attempt to guide the eye to intraline\n"
"differences, and were not present in either input file.  These lines can be\n"
"confusing if the source files contain tab characters.\n"
"\n"
"The first file can be recovered by retaining only lines that begin with\n"
"\"  \" or \"- \", and deleting those 2-character prefixes; use ndiff with -"
"r1.\n"
"\n"
"The second file can be recovered similarly, but by retaining only \"  \" "
"and\n"
"\"+ \" lines; use ndiff with -r2; or, on Unix, the second file can be\n"
"recovered by piping the output through\n"
"\n"
"    sed -n '/^[+ ] /s/^..//p'\n"
"\"\"\"\n"
"\n"
"__version__ = 1, 7, 0\n"
"\n"
"import difflib, sys\n"
"\n"
"def fail(msg):\n"
"    out = sys.stderr.write\n"
"    out(msg + \"\\n\\n\")\n"
"    out(__doc__)\n"
"    return 0\n"
"\n"
"# open a file & return the file object; gripe and return 0 if it\n"
"# couldn't be opened\n"
"def fopen(fname):\n"
"    try:\n"
"        return open(fname)\n"
"    except IOError as detail:\n"
"        return fail(\"couldn't open \" + fname + \": \" + str(detail))\n"
"\n"
"# open two files & spray the diff to stdout; return false iff a problem\n"
"def fcompare(f1name, f2name):\n"
"    f1 = fopen(f1name)\n"
"    f2 = fopen(f2name)\n"
"    if not f1 or not f2:\n"
"        return 0\n"
"\n"
"    a = f1.readlines(); f1.close()\n"
"    b = f2.readlines(); f2.close()\n"
"    for line in difflib.ndiff(a, b):\n"
"        print(line, end=' ')\n"
"\n"
"    return 1\n"
"\n"
"# crack args (sys.argv[1:] is normal) & compare;\n"
"# return false iff a problem\n"
"\n"
"def main(args):\n"
"    import getopt\n"
"    try:\n"
"        opts, args = getopt.getopt(args, \"qr:\")\n"
"    except getopt.error as detail:\n"
"        return fail(str(detail))\n"
"    noisy = 1\n"
"    qseen = rseen = 0\n"
"    for opt, val in opts:\n"
"        if opt == \"-q\":\n"
"            qseen = 1\n"
"            noisy = 0\n"
"        elif opt == \"-r\":\n"
"            rseen = 1\n"
"            whichfile = val\n"
"    if qseen and rseen:\n"
"        return fail(\"can't specify both -q and -r\")\n"
"    if rseen:\n"
"        if args:\n"
"            return fail(\"no args allowed with -r option\")\n"
"        if whichfile in (\"1\", \"2\"):\n"
"            restore(whichfile)\n"
"            return 1\n"
"        return fail(\"-r value must be 1 or 2\")\n"
"    if len(args) != 2:\n"
"        return fail(\"need 2 filename args\")\n"
"    f1name, f2name = args\n"
"    if noisy:\n"
"        print('-:', f1name)\n"
"        print('+:', f2name)\n"
"    return fcompare(f1name, f2name)\n"
"\n"
"# read ndiff output from stdin, and print file1 (which=='1') or\n"
"# file2 (which=='2') to stdout\n"
"\n"
"def restore(which):\n"
"    restored = difflib.restore(sys.stdin.readlines(), which)\n"
"    sys.stdout.writelines(restored)\n"
"\n"
"if __name__ == '__main__':\n"
"    main(sys.argv[1:])\n"
