# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!unittest.mock` --- getting started"
msgstr ":mod:`!unittest.mock` --- komma igång"

msgid "Using Mock"
msgstr "Använda Mock"

msgid "Mock Patching Methods"
msgstr "Mock Patching-metoder"

msgid "Common uses for :class:`Mock` objects include:"
msgstr "Vanliga användningsområden för :class:`Mock`-objekt inkluderar:"

msgid "Patching methods"
msgstr "Patching-metoder"

msgid "Recording method calls on objects"
msgstr "Inspelning av metodanrop på objekt"

msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr ""
"Du kanske vill ersätta en metod på ett objekt för att kontrollera att den "
"anropas med rätt argument av en annan del av systemet:"

msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods "
"and attributes that allow you to make assertions about how it has been used."
msgstr ""
"När vår mock har använts (``real.method`` i det här exemplet) har den "
"metoder och attribut som gör att du kan göra påståenden om hur den har "
"använts."

msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes "
"a sensible one to use by default."
msgstr ""
"I de flesta av dessa exempel är klasserna :class:`Mock` och :class:"
"`MagicMock` utbytbara. Eftersom ``MagicMock`` är den mer kapabla klassen är "
"det förnuftigt att använda den som standard."

msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"När mocken har anropats sätts dess attribut :attr:`~Mock.called` till "
"``True``. Ännu viktigare är att vi kan använda metoden :meth:`~Mock."
"assert_called_with` eller :meth:`~Mock.assert_called_once_with` för att "
"kontrollera att den anropades med rätt argument."

msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr ""
"Detta exempel testar att ett anrop till ``ProductionClass().method`` "
"resulterar i ett anrop till metoden ``something``:"

msgid "Mock for Method Calls on an Object"
msgstr "Mock för metodanrop på ett objekt"

msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a "
"method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"I det förra exemplet patchade vi en metod direkt på ett objekt för att "
"kontrollera att den anropades korrekt. Ett annat vanligt användningsfall är "
"att skicka ett objekt till en metod (eller någon del av systemet som testas) "
"och sedan kontrollera att det används på rätt sätt."

msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"Den enkla ``ProductionClass`` nedan har en ``closer`` metod. Om den anropas "
"med ett objekt så anropar den ``close`` på det."

msgid ""
"So to test it we need to pass in an object with a ``close`` method and check "
"that it was called correctly."
msgstr ""
"Så för att testa det måste vi skicka in ett objekt med en ``close``-metod "
"och kontrollera att den anropades korrekt."

msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but :meth:`~Mock."
"assert_called_with` will raise a failure exception."
msgstr ""
"Vi behöver inte göra något arbete för att tillhandahålla metoden \"close\" "
"på vår mock. Åtkomst till close skapar den. Så om 'close' inte redan har "
"anropats kommer åtkomst till den i testet att skapa den, men :meth:`~Mock."
"assert_called_with` kommer att ge upphov till ett felaktigt undantag."

msgid "Mocking Classes"
msgstr "Mocking av klasser"

msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"Ett vanligt användningsfall är att mocka ut klasser som instansieras av din "
"kod som testas. När du patchar en klass ersätts den klassen med en mock. "
"Instanser skapas genom att *anropa klassen*. Detta innebär att du kommer åt "
"\"mock-instansen\" genom att titta på returvärdet för den mockade klassen."

msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the "
"mock, so it is configured by modifying the mock :attr:`~Mock."
"return_value`. ::"
msgstr ""
"I exemplet nedan har vi en funktion ``some_function`` som instansierar "
"``Foo`` och anropar en metod på den. Anropet till :func:`patch` ersätter "
"klassen ``Foo`` med en mock. Instansen ``Foo`` är resultatet av anropet av "
"mocken, så den konfigureras genom att modifiera mock :attr:`~Mock."
"return_value`. ::"

msgid ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"
msgstr ""
">>> def någon_funktion():\n"
"... instans = modul.Foo()\n"
"... return instans.metod()\n"
"...\n"
">>> med patch('module.Foo') som mock:\n"
"... instans = mock.return_value\n"
"... instance.method.return_value = 'resultatet'\n"
"... resultat = någon_funktion()\n"
"... assert resultat == 'resultatet'"

msgid "Naming your mocks"
msgstr "Namnge dina mockar"

msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of "
"the mock and can be helpful when the mock appears in test failure messages. "
"The name is also propagated to attributes or methods of the mock:"
msgstr ""
"Det kan vara bra att ge dina mockar ett namn. Namnet visas i mockens repr "
"och kan vara till hjälp när mocken visas i felmeddelanden i tester. Namnet "
"sprids också till attribut eller metoder i mocken:"

msgid "Tracking all Calls"
msgstr "Spåra alla samtal"

msgid ""
"Often you want to track more than a single call to a method. The :attr:"
"`~Mock.mock_calls` attribute records all calls to child attributes of the "
"mock - and also to their children."
msgstr ""
"Ofta vill man spåra mer än ett enda anrop till en metod. Attributet :attr:"
"`~Mock.mock_calls` registrerar alla anrop till barnattribut till mock - och "
"även till deras barn."

msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional calls:"
msgstr ""
"Om du gör ett påstående om ``mock_calls`` och några oväntade metoder har "
"anropats, så kommer påståendet att misslyckas. Detta är användbart eftersom "
"du inte bara hävdar att de anrop du förväntade dig har gjorts, du "
"kontrollerar också att de gjordes i rätt ordning och utan ytterligare anrop:"

msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr ""
"Du använder objektet :data:`call` för att konstruera listor som kan jämföras "
"med ``mock_calls``:"

msgid ""
"However, parameters to calls that return mocks are not recorded, which means "
"it is not possible to track nested calls where the parameters used to create "
"ancestors are important:"
msgstr ""
"Parametrar till anrop som returnerar mocks registreras dock inte, vilket "
"innebär att det inte är möjligt att spåra nästlade anrop där de parametrar "
"som används för att skapa ancestors är viktiga:"

msgid "Setting Return Values and Attributes"
msgstr "Ange returvärden och attribut"

msgid "Setting the return values on a mock object is trivially easy:"
msgstr "Att ställa in returvärdena på ett mock-objekt är trivialt enkelt:"

msgid "Of course you can do the same for methods on the mock:"
msgstr "Naturligtvis kan du göra samma sak för metoder på mock:"

msgid "The return value can also be set in the constructor:"
msgstr "Returvärdet kan också ställas in i konstruktören:"

msgid "If you need an attribute setting on your mock, just do it:"
msgstr ""
"Om du behöver en attributinställning på din mock är det bara att göra det:"

msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"Ibland vill man simulera en mer komplex situation, som till exempel ``mock."
"connection.cursor().execute(\"SELECT 1\")``. Om vi vill att det här anropet "
"ska returnera en lista måste vi konfigurera resultatet av det nästlade "
"anropet."

msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr ""
"Vi kan använda :data:`call` för att konstruera uppsättningen anrop i ett "
"\"kedjeanrop\" som detta för att enkelt kunna hävda det i efterhand:"

msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of "
"calls representing the chained calls."
msgstr ""
"Det är anropet till ``.call_list()`` som förvandlar vårt anropsobjekt till "
"en lista med anrop som representerar de kedjade anropen."

msgid "Raising exceptions with mocks"
msgstr "Utlösande av undantag med mocks"

msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr ""
"Ett användbart attribut är :attr:`~Mock.side_effect`. Om du anger detta till "
"en undantagsklass eller -instans kommer undantaget att uppstå när mocken "
"anropas."

msgid "Side effect functions and iterables"
msgstr "Bieffektsfunktioner och iterabler"

msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` kan också ställas in på en funktion eller en iterabel. "
"Användningsfallet för ``side_effect`` som en iterabel är när din mock kommer "
"att anropas flera gånger och du vill att varje anrop ska returnera ett annat "
"värde. När du ställer in ``side_effect`` till en iterabel returnerar varje "
"anrop till mocken nästa värde från iterabeln:"

msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"För mer avancerade användningsfall, som att dynamiskt variera returvärdena "
"beroende på vad mocken anropas med, kan ``side_effect`` vara en funktion. "
"Funktionen kommer att anropas med samma argument som mock. Det som "
"funktionen returnerar är det som anropet returnerar:"

msgid "Mocking asynchronous iterators"
msgstr "Mocka asynkrona iteratorer"

msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value` "
"attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"Sedan Python 3.8 har ``AsyncMock`` och ``MagicMock`` stöd för att mocka :ref:"
"`async-iterators` genom ``__aiter__``. Attributet :attr:`~Mock.return_value` "
"för ``__aiter__`` kan användas för att ställa in de returvärden som ska "
"användas för iteration."

msgid "Mocking asynchronous context manager"
msgstr "Mocka asynkron kontexthanterare"

msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"Sedan Python 3.8 har ``AsyncMock`` och ``MagicMock`` stöd för att mocka :ref:"
"`async-context-managers` genom ``__aenter__`` och ``__aexit__``. Som "
"standard är ``__aenter__`` och ``__aexit__`` ``AsyncMock`` instanser som "
"returnerar en asynkron funktion."

msgid "Creating a Mock from an Existing Object"
msgstr "Skapa en mock från ett befintligt objekt"

msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later "
"you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"Ett problem med överdriven användning av mocking är att det kopplar dina "
"tester till implementeringen av dina mocks snarare än din riktiga kod. Anta "
"att du har en klass som implementerar ``en viss metod``. I ett test för en "
"annan klass tillhandahåller du en mock av detta objekt som *också* "
"tillhandahåller ``en_metod``. Om du senare refaktoriserar den första "
"klassen, så att den inte längre har ``some_method`` - då kommer dina tester "
"att fortsätta att godkännas trots att din kod nu är trasig!"

msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately "
"without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` låter dig tillhandahålla ett objekt som en specifikation för "
"mocken, med hjälp av nyckelordsargumentet *spec*. Åtkomst till metoder/"
"attribut på mock som inte finns på ditt specifikationsobjekt kommer "
"omedelbart att ge upphov till ett attributfel. Om du ändrar implementeringen "
"av din specifikation kommer tester som använder den klassen att börja "
"misslyckas omedelbart utan att du behöver instansiera klassen i dessa tester."

msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr ""
"Att använda en specifikation möjliggör också en smartare matchning av anrop "
"som görs till mock, oavsett om vissa parametrar skickades som positionella "
"eller namngivna argument:"

msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
"&gt;&gt;&gt; def f(a, b, c): pass\n"
"...\n"
"&gt;&gt;&gt; mock = Mock(spec=f)\n"
"&gt;&gt;&gt; mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
"&gt;&gt;&gt; mock.assert_called_with(a=1, b=2, c=3)"

msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"Om du vill att denna smartare matchning även ska fungera med metodanrop på "
"mocken kan du använda :ref:`auto-speccing <auto-speccing>`."

msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"Om du vill ha en starkare form av specifikation som förhindrar att "
"godtyckliga attribut ställs in och att de hämtas, kan du använda *spec_set* "
"i stället för *spec*."

msgid "Using side_effect to return per file content"
msgstr "Använda side_effect för att returnera innehåll per fil"

msgid ""
":func:`mock_open` is used to patch :func:`open` method. :attr:`~Mock."
"side_effect` can be used to return a new Mock object per call. This can be "
"used to return different contents per file stored in a dictionary::"
msgstr ""
":func:`mock_open` används för att patcha :func:`open` metoden. :attr:`~Mock."
"side_effect` kan användas för att returnera ett nytt Mock-objekt per anrop. "
"Detta kan användas för att returnera olika innehåll per fil som lagras i en "
"ordbok::"

msgid ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""
msgstr ""
"DEFAULT = \"standard\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"fil2\": \"data2\"}\n"
"\n"
"def open_side_effect(namn):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"med patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    med open(\"file1\") som file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    med open(\"file2\") som fil2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    med open(\"file3\") som fil2:\n"
"        assert file2.read() == \"default\""

msgid "Patch Decorators"
msgstr "Patch Dekoratörer"

msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"Med :func:`patch` är det viktigt att du patchar objekt i den namnrymd där de "
"söks upp. Detta är normalt enkelt, men för en snabb guide läs :ref:``where "
"to patch <where-to-patch>``."

msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other "
"tests and cause hard to diagnose problems."
msgstr ""
"Ett vanligt behov i tester är att patcha ett klassattribut eller ett "
"modulattribut, t.ex. att patcha en builtin eller att patcha en klass i en "
"modul för att testa att den instansieras. Moduler och klasser är i praktiken "
"globala, så patchning av dem måste göras ogjord efter testet, annars kommer "
"patchen att finnas kvar i andra tester och orsaka problem som är svåra att "
"diagnostisera."

msgid ""
"mock provides three convenient decorators for this: :func:`patch`, :func:"
"`patch.object` and :func:`patch.dict`. ``patch`` takes a single string, of "
"the form ``package.module.Class.attribute`` to specify the attribute you are "
"patching. It also optionally takes a value that you want the attribute (or "
"class or whatever) to be replaced with. 'patch.object' takes an object and "
"the name of the attribute you would like patched, plus optionally the value "
"to patch it with."
msgstr ""
"mock tillhandahåller tre praktiska dekoratorer för detta: :func:`patch`, :"
"func:`patch.object` och :func:`patch.dict`. ``patch`` tar en enda sträng, av "
"formen ``package.module.Class.attribute`` för att ange det attribut du "
"patchar. Det tar också valfritt ett värde som du vill att attributet (eller "
"klassen eller vad som helst) ska ersättas med. 'patch.object' tar ett objekt "
"och namnet på det attribut som du vill patcha, plus eventuellt det värde som "
"du vill patcha det med."

msgid "``patch.object``::"
msgstr "``patch.objekt``::"

msgid ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> original = NågonKlass.attribut\n"
">>> @patch.object(SomeClass, 'attribut', sentinel.attribut)\n"
"... def test():\n"
"... assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('paket.modul.attribut', sentinel.attribut)\n"
"... def test():\n"
"... från paket.modul import attribut\n"
"... assert attribut är sentinel.attribut\n"
"...\n"
">>> test()"

msgid ""
"If you are patching a module (including :mod:`builtins`) then use :func:"
"`patch` instead of :func:`patch.object`:"
msgstr ""
"Om du patchar en modul (inklusive :mod:`builtins`), använd då :func:`patch` "
"istället för :func:`patch.object`:"

msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr ""
"Modulnamnet kan vara \"prickat\", i formen ``package.module`` om det behövs::"

msgid ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('paket.modul.Klassnamn.attribut', sentinel.attribut)\n"
"... def test():\n"
"... from package.module import Klassnamn\n"
"... assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"

msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "Ett trevligt mönster är att faktiskt dekorera testmetoderna själva:"

msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"Om du vill patcha med en Mock kan du använda :func:`patch` med bara ett "
"argument (eller :func:`patch.object` med två argument). Mocken kommer att "
"skapas åt dig och skickas in i testfunktionen/metoden:"

msgid "You can stack up multiple patch decorators using this pattern::"
msgstr "Du kan stapla upp flera patchdekorationer med detta mönster::"

msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"
msgstr ""
">>> klass MyTest(unittest.TestCase):\n"
"...     @patch('paket.modul.Klassnamn1')\n"
"...     @patch('paket.modul.Klassnamn2')\n"
"... def test_something(self, MockClass2, MockClass1):\n"
"... self.assertIs(paket.modul.Klassnamn1, MockClass1)\n"
"... self.assertIs(paket.modul.Klassnamn2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"

msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"När du nestar patch-dekoratorer skickas mockarna in till den dekorerade "
"funktionen i samma ordning som de tillämpas (den normala *Python*-ordningen "
"som dekoratorer tillämpas). Detta innebär nerifrån och upp, så i exemplet "
"ovan skickas mocken för ``test_module.ClassName2`` in först."

msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Det finns också :func:`patch.dict` för att ställa in värden i en ordbok bara "
"under ett scope och återställa ordboken till dess ursprungliga tillstånd när "
"testet avslutas:"

msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr ""
"``patch``, ``patch.object`` och ``patch.dict`` kan alla användas som "
"kontexthanterare."

msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
"När du använder :func:`patch` för att skapa en mock åt dig kan du få en "
"referens till mocken med hjälp av \"as\"-formen i with-satsen:"

msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used "
"as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"Som ett alternativ kan ``patch``, ``patch.object`` och ``patch.dict`` "
"användas som klassdekoratorer. När de används på det här sättet är det samma "
"sak som att tillämpa dekoratorn individuellt på varje metod vars namn börjar "
"med \"test\"."

msgid "Further Examples"
msgstr "Ytterligare exempel"

msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "Här är några fler exempel på lite mer avancerade scenarier."

msgid "Mocking chained calls"
msgstr "Mocking av kedjade anrop"

msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"Att mocka kedjeanrop är faktiskt enkelt med mock när man väl förstår "
"attributet :attr:`~Mock.return_value`. När en mock anropas för första "
"gången, eller om du hämtar dess ``return_value`` innan den har anropats, "
"skapas en ny :class:`Mock`."

msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"Detta innebär att du kan se hur objektet som returneras från ett anrop till "
"ett mockat objekt har använts genom att fråga ut mocken ``return_value``:"

msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr ""
"Härifrån är det ett enkelt steg att konfigurera och sedan göra påståenden om "
"kedjeanrop. Ett annat alternativ är förstås att skriva sin kod på ett mer "
"testbart sätt från början..."

msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "Anta att vi har en kod som ser ut ungefär så här:"

msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"Om vi antar att ``BackendProvider`` redan är väl testad, hur testar vi då "
"``method()``? Specifikt vill vi testa att kodavsnittet ``# more code`` "
"använder svarsobjektet på rätt sätt."

msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"Eftersom denna kedja av anrop görs från ett instansattribut kan vi ap-patcha "
"attributet ``backend`` på en ``Something``-instans. I detta speciella fall "
"är vi bara intresserade av returvärdet från det sista anropet till "
"``start_call`` så vi har inte mycket konfiguration att göra. Låt oss anta "
"att objektet som returneras är \"filliknande\", så vi kommer att se till att "
"vårt svarsobjekt använder den inbyggda :func:`open` som dess ``spec``."

msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"För att göra detta skapar vi en mock-instans som vår mock-backend och skapar "
"ett mock-svarsobjekt för det. För att ställa in svaret som returvärde för "
"det slutliga ``start_call`` kan vi göra så här::"

msgid ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = mock_response"
msgstr ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = mock_response"

msgid ""
"We can do that in a slightly nicer way using the :meth:`~Mock."
"configure_mock` method to directly set the return value for us::"
msgstr ""
"Vi kan göra det på ett lite trevligare sätt genom att använda metoden :meth:"
"`~Mock.configure_mock` för att direkt ställa in returvärdet åt oss::"

msgid ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"
msgstr ""
">>> något = Något()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"

msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr ""
"Med dessa kan vi sätta upp \"mock backend\" på plats och göra det riktiga "
"anropet::"

msgid ""
">>> something.backend = mock_backend\n"
">>> something.method()"
msgstr ""
">>> något.backend = mock_backend\n"
">>> något.metod()"

msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"Med hjälp av :attr:`~Mock.mock_calls` kan vi kontrollera det kedjade anropet "
"med ett enda assert. Ett kedjeanrop är flera anrop i en kodrad, så det "
"kommer att finnas flera poster i ``mock_calls``. Vi kan använda :meth:`call."
"call_list` för att skapa denna lista över anrop åt oss::"

msgid ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"
msgstr ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> anrop_lista = kedjad.anrop_lista()\n"
">>> assert mock_backend.mock_calls == call_list"

msgid "Partial mocking"
msgstr "Delvis mocking"

msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` to "
"return a known date, but I didn't want to prevent the code under test from "
"creating new date objects. Unfortunately :class:`datetime.date` is written "
"in C, and so I couldn't just monkey-patch out the static :meth:`datetime."
"date.today` method."
msgstr ""
"I vissa tester ville jag mocka ut ett anrop till :meth:`datetime.date.today` "
"för att returnera ett känt datum, men jag ville inte hindra koden under test "
"från att skapa nya datumobjekt. Tyvärr är :class:`datetime.date` skriven i "
"C, och därför kunde jag inte bara monkey-patcha ut den statiska :meth:"
"`datetime.date.today`-metoden."

msgid ""
"I found a simple way of doing this that involved effectively wrapping the "
"date class with a mock, but passing through calls to the constructor to the "
"real class (and returning real instances)."
msgstr ""
"Jag hittade ett enkelt sätt att göra detta som innebar att effektivt linda "
"in datumklassen med en mock, men passera genom anrop till konstruktören till "
"den riktiga klassen (och returnera riktiga instanser)."

msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`~Mock.side_effect` attribute on "
"the mock date class is then set to a lambda function that returns a real "
"date. When the mock date class is called a real date will be constructed and "
"returned by ``side_effect``. ::"
msgstr ""
"Här används :func:`patch decorator <patch>` för att mocka ut klassen "
"``date`` i den modul som testas. Attributet :attr:`~Mock.side_effect` på "
"mock date-klassen sätts sedan till en lambda-funktion som returnerar ett "
"riktigt datum. När mock date-klassen anropas kommer ett verkligt datum att "
"konstrueras och returneras av ``side_effect``. ::"

msgid ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"
msgstr ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"

msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"Observera att vi inte patchar :class:`datetime.date` globalt, vi patchar "
"``date`` i modulen som *använder* den. Se :ref:`var man patchar <where-to-"
"patch>`."

msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"När ``date.today()`` anropas returneras ett känt datum, men anrop till "
"``date(...)``-konstruktorn returnerar fortfarande normala datum. Utan detta "
"kan det hända att du måste beräkna ett förväntat resultat med exakt samma "
"algoritm som den kod som testas, vilket är ett klassiskt anti-mönster för "
"testning."

msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr ""
"Anrop till datumkonstruktören registreras i ``mock_date``-attributen "
"(``call_count`` och vänner), vilket också kan vara användbart för dina "
"tester."

msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"Ett alternativt sätt att hantera mocking dates, eller andra inbyggda "
"klasser, diskuteras i `det här blogginlägget <https://williambert."
"online/2011/07/how-to-unit-testing-in-django-with-mocking-and-patching/>`_."

msgid "Mocking a Generator Method"
msgstr "Mocka en generatormetod"

msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr ""
"En Python-generator är en funktion eller metod som använder :keyword:`yield`-"
"satsen för att returnera en serie värden när den itereras över [#]_."

msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a :class:"
"`MagicMock`."
msgstr ""
"En generatormetod/funktion anropas för att returnera generatorobjektet. Det "
"är generatorobjektet som sedan itereras över. Protokollmetoden för iteration "
"är :meth:`~container.__iter__`, så vi kan mocka detta med hjälp av en :class:"
"`MagicMock`."

msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr ""
"Här är en exempelklass med en \"iter\"-metod som implementerats som en "
"generator:"

msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr ""
"Hur skulle vi mocka den här klassen, och i synnerhet dess \"iter\"-metod?"

msgid ""
"To configure the values returned from the iteration (implicit in the call "
"to :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr ""
"För att konfigurera de värden som returneras från iterationen (implicit i "
"anropet till :class:`list`) måste vi konfigurera det objekt som returneras "
"av anropet till ``foo.iter()``."

msgid ""
"There are also generator expressions and more `advanced uses <http://www."
"dabeaz.com/coroutines/index.html>`_ of generators, but we aren't concerned "
"about them here. A very good introduction to generators and how powerful "
"they are is: `Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_."
msgstr ""
"Det finns också generatoruttryck och mer \"avancerade användningar\" <http://"
"www.dabeaz.com/coroutines/index.html>`_ av generatorer, men det är inget vi "
"ska ägna oss åt här. En mycket bra introduktion till generatorer och hur "
"kraftfulla de är finns i: `Generator Tricks for Systems Programmers <http://"
"www.dabeaz.com/generators/>`_."

msgid "Applying the same patch to every test method"
msgstr "Tillämpa samma patch på alla testmetoder"

msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"Om du vill ha flera patchar på plats för flera testmetoder är det uppenbara "
"sättet att tillämpa patchdekoratorerna på varje metod. Detta kan kännas som "
"en onödig upprepning. Istället kan du använda :func:`patch` (i alla dess "
"olika former) som en klassdekorator. Detta applicerar patcharna på alla "
"testmetoder i klassen. En testmetod identifieras av metoder vars namn börjar "
"med ``test``::"

msgid ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"
msgstr ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"... def test_one(self, MockSomeClass):\n"
"... self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"... def test_two(self, MockSomeClass):\n"
"... self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"... def not_a_test(self):\n"
"... return 'något'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'något'"

msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"Ett alternativt sätt att hantera patchar är att använda :ref:`start-and-"
"stop`. Dessa gör att du kan flytta patchningen till dina metoder ``setUp`` "
"och ``tearDown``. ::"

msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> klass MyTest(unittest.TestCase):\n"
"... def setUp(self):\n"
"... self.patcher = patch('mymodule.foo')\n"
"... self.mock_foo = self.patcher.start()\n"
"...\n"
"... def test_foo(self):\n"
"... self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"... def tearDown(self):\n"
"... self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"

msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Om du använder den här tekniken måste du se till att patchningen \"ångras\" "
"genom att anropa ``stop``. Det här kan vara krångligare än man tror, för om "
"ett undantag uppstår i setUp så anropas inte tearDown. :meth:`unittest."
"TestCase.addCleanup` gör det här enklare::"

msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> klass MyTest(unittest.TestCase):\n"
"... def setUp(self):\n"
"... patcher = patch('mymodule.foo')\n"
"... self.addCleanup(patcher.stop)\n"
"... self.mock_foo = patcher.start()\n"
"...\n"
"... def test_foo(self):\n"
"... self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"

msgid "Mocking Unbound Methods"
msgstr "Spottning av obundna metoder"

msgid ""
"Whilst writing tests today I needed to patch an *unbound method* (patching "
"the method on the class rather than on the instance). I needed self to be "
"passed in as the first argument because I want to make asserts about which "
"objects were calling this particular method. The issue is that you can't "
"patch with a mock for this, because if you replace an unbound method with a "
"mock it doesn't become a bound method when fetched from the instance, and so "
"it doesn't get self passed in. The workaround is to patch the unbound method "
"with a real function instead. The :func:`patch` decorator makes it so simple "
"to patch out methods with a mock that having to create a real function "
"becomes a nuisance."
msgstr ""
"När jag skrev tester idag behövde jag patcha en *obunden metod* (patcha "
"metoden på klassen snarare än på instansen). Jag behövde self som första "
"argument eftersom jag vill göra asserts om vilka objekt som anropar just den "
"här metoden. Problemet är att du inte kan patcha med en mock för detta, för "
"om du ersätter en obunden metod med en mock blir den inte en bunden metod "
"när den hämtas från instansen, och därför får den inte self passerat in. "
"Lösningen är att patcha den obundna metoden med en riktig funktion istället. "
"Dekoratorn :func:`patch` gör det så enkelt att patcha ut metoder med en mock "
"att det blir ett irritationsmoment att behöva skapa en riktig funktion."

msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what I wanted:"
msgstr ""
"Om du skickar ``autospec=True`` till patch så gör den patchningen med ett "
"*verkligt* funktionsobjekt. Detta funktionsobjekt har samma signatur som det "
"som det ersätter, men delegerar till en mock under huven. Du får fortfarande "
"din mock automatiskt skapad på exakt samma sätt som tidigare. Vad det "
"innebär är dock att om du använder den för att lappa ut en obunden metod på "
"en klass kommer den mockade funktionen att förvandlas till en bunden metod "
"om den hämtas från en instans. Det kommer att ha ``self`` passerat in som "
"det första argumentet, vilket är precis vad jag ville ha:"

msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"Om vi inte använder ``autospec=True`` så patchas den obundna metoden ut med "
"en Mock-instans istället, och anropas inte med ``self``."

msgid "Checking multiple calls with mock"
msgstr "Kontroll av flera anrop med mock"

msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr ""
"mock har ett bra API för att göra påståenden om hur dina mock-objekt används."

msgid ""
"If your mock is only being called once you can use the :meth:`~Mock."
"assert_called_once_with` method that also asserts that the :attr:`~Mock."
"call_count` is one."
msgstr ""
"Om din mock bara anropas en gång kan du använda metoden :meth:`~Mock."
"assert_called_once_with` som också försäkrar att :attr:`~Mock.call_count` är "
"ett."

msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use :"
"attr:`~Mock.call_args_list`:"
msgstr ""
"Både ``assert_called_with`` och ``assert_called_once_with`` gör påståenden "
"om det *senaste* anropet. Om din mock kommer att anropas flera gånger och du "
"vill göra påståenden om *alla* dessa anrop kan du använda :attr:`~Mock."
"call_args_list`:"

msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
"Med hjälpmedlet :data:`call` är det enkelt att göra påståenden om dessa "
"anrop. Du kan bygga upp en lista över förväntade anrop och jämföra den med "
"``call_args_list``. Detta ser anmärkningsvärt likt ut som repr av "
"``call_args_list``:"

msgid "Coping with mutable arguments"
msgstr "Att hantera föränderliga argument"

msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were "
"when the mock was called."
msgstr ""
"En annan situation är sällsynt, men kan bita dig, är när din mock anropas "
"med mutabla argument. ``call_args`` och ``call_args_list`` lagrar "
"*referenser* till argumenten. Om argumenten muteras av koden som testas kan "
"du inte längre göra påståenden om vad värdena var när mocken anropades."

msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr ""
"Här är lite exempelkod som visar problemet. Föreställ dig följande "
"funktioner definierade i 'mymodule'::"

msgid ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"First frob and then clear val\"\n"
"    frob(val)\n"
"    val.clear()"
msgstr ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"Först frob och sedan clear val\"\n"
"    frob(val)\n"
"    val.clear()"

msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr ""
"När vi försöker testa att ``grob`` anropar ``frob`` med rätt argument, se "
"vad som händer::"

msgid ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"
msgstr ""
">>> med patch('mymodule.frob') som mock_frob:\n"
"... val = {6}\n"
"... mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (senaste anropet senast):\n"
"    ...\n"
"AssertionError: Förväntat: (({6},)), {})\n"
"Anropades med: ((set(),), {})"

msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr ""
"En möjlighet skulle kunna vara att mock kopierar de argument du skickar in. "
"Detta skulle då kunna orsaka problem om du gör påståenden som förlitar sig "
"på objektidentitet för jämlikhet."

msgid ""
"Here's one solution that uses the :attr:`~Mock.side_effect` functionality. "
"If you provide a ``side_effect`` function for a mock then ``side_effect`` "
"will be called with the same args as the mock. This gives us an opportunity "
"to copy the arguments and store them for later assertions. In this example "
"I'm using *another* mock to store the arguments so that I can use the mock "
"methods for doing the assertion. Again a helper function sets this up for "
"me. ::"
msgstr ""
"Här är en lösning som använder :attr:`~Mock.side_effect`-funktionaliteten. "
"Om du tillhandahåller en ``side_effect``-funktion för en mock så kommer "
"``side_effect`` att anropas med samma args som mocken. Detta ger oss en "
"möjlighet att kopiera argumenten och lagra dem för senare påståenden. I det "
"här exemplet använder jag *en annan* mock för att lagra argumenten så att "
"jag kan använda mock-metoderna för att göra påståendet. Återigen ställer en "
"hjälpfunktion in detta åt mig ::"

msgid ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"
msgstr ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"

msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a "
"new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"``copy_call_args`` anropas med den mock som kommer att anropas. Den "
"returnerar en ny mock som vi gör assertionen på. Funktionen ``side_effect`` "
"gör en kopia av args och anropar vår ``new_mock`` med kopian."

msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"Om din mock bara ska användas en gång finns det ett enklare sätt att "
"kontrollera argumenten vid den punkt de anropas. Du kan helt enkelt göra "
"kontrollen inuti en ``side_effect``-funktion."

msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or :class:"
"`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. Here's "
"an example implementation:"
msgstr ""
"Ett alternativt tillvägagångssätt är att skapa en subklass av :class:`Mock` "
"eller :class:`MagicMock` som kopierar (med :func:`copy.deepcopy`) "
"argumenten. Här är ett exempel på en implementation:"

msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"När du subklassar ``Mock`` eller ``MagicMock`` kommer alla dynamiskt skapade "
"attribut och ``return_value`` att använda din subklass automatiskt. Det "
"betyder att alla barn till en ``CopyingMock`` också kommer att ha typen "
"``CopyingMock``."

msgid "Nesting Patches"
msgstr "Nästande lappar"

msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you "
"can end up with nested with statements indenting further and further to the "
"right::"
msgstr ""
"Att använda patch som en kontexthanterare är trevligt, men om du gör flera "
"patchar kan du sluta med nästlade med uttalanden som indenteras längre och "
"längre åt höger::"

msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> klass MyTest(unittest.TestCase):\n"
"...\n"
"... def test_foo(self):\n"
"... med patch('mymodule.Foo') som mock_foo:\n"
"... med patch('mymodule.Bar') som mock_bar:\n"
"... med patch('mymodule.Spam') som mock_spam:\n"
"... assert mymodule.Foo är mock_foo\n"
"... assert mymodule.Bar är mock_bar\n"
"... assert mymodule.Spam är mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo är original"

msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"Med unittest ``cleanup`` funktioner och :ref:``start-and-stop`` kan vi uppnå "
"samma effekt utan den nästlade indragningen. En enkel hjälpmetod, "
"``create_patch``, sätter patchen på plats och returnerar den skapade mocken "
"för oss::"

msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> klass MyTest(unittest.TestCase):\n"
"...\n"
"... def create_patch(self, name):\n"
"... patcher = patch(name)\n"
"... sak = patcher.start()\n"
"... self.addCleanup(patcher.stop)\n"
"... returnera sak\n"
"...\n"
"... def test_foo(self):\n"
"... mock_foo = self.create_patch('mymodule.Foo')\n"
"... mock_bar = self.create_patch('mymodule.Bar')\n"
"... mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"... assert mymodule.Foo är mock_foo\n"
"... assert mymodule.Bar är mock_bar\n"
"... assert mymodule.Spam är mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo är original"

msgid "Mocking a dictionary with MagicMock"
msgstr "Mocka en ordbok med MagicMock"

msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr ""
"Du kanske vill låtsas vara en ordbok eller ett annat containerobjekt och "
"registrera all åtkomst till det samtidigt som det fortfarande beter sig som "
"en ordbok."

msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary, "
"and using :data:`~Mock.side_effect` to delegate dictionary access to a real "
"underlying dictionary that is under our control."
msgstr ""
"Vi kan göra detta med :class:`MagicMock`, som kommer att bete sig som en "
"ordbok, och använda :data:`~Mock.side_effect` för att delegera "
"ordboksåtkomst till en verklig underliggande ordbok som är under vår "
"kontroll."

msgid ""
"When the :meth:`~object.__getitem__` and :meth:`~object.__setitem__` methods "
"of our ``MagicMock`` are called (normal dictionary access) then "
"``side_effect`` is called with the key (and in the case of ``__setitem__`` "
"the value too). We can also control what is returned."
msgstr ""
"När metoderna :meth:`~object.__getitem__` och :meth:`~object.__setitem__` i "
"vår ``MagicMock`` anropas (normal dictionary access) så anropas "
"``side_effect`` med nyckeln (och i fallet ``__setitem__`` även värdet). Vi "
"kan också kontrollera vad som returneras."

msgid ""
"After the ``MagicMock`` has been used we can use attributes like :data:"
"`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"Efter att ``MagicMock`` har använts kan vi använda attribut som :data:`~Mock."
"call_args_list` för att hävda hur ordlistan användes:"

msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr ""
"Ett alternativ till att använda ``MagicMock`` är att använda ``Mock`` och "
"*endast* tillhandahålla de magiska metoder som du specifikt vill ha:"

msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"Ett *tredje* alternativ är att använda ``MagicMock`` men skicka in ``dict`` "
"som *spec* (eller *spec_set*) argument så att den ``MagicMock`` som skapas "
"endast har magiska metoder för ordböcker tillgängliga:"

msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError` "
"if you try to access a key that doesn't exist."
msgstr ""
"Med dessa bieffektsfunktioner på plats kommer ``mock`` att bete sig som en "
"vanlig ordbok men registrera åtkomsten. Den ger till och med upphov till "
"ett :exc:`KeyError` om du försöker komma åt en nyckel som inte finns."

msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr ""
"När den har använts kan du göra påståenden om åtkomsten med hjälp av de "
"vanliga mock-metoderna och -attributen:"

msgid "Mock subclasses and their attributes"
msgstr "Mock-subklasser och deras attribut"

msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr ""
"Det finns olika anledningar till varför du kanske vill underklassa :class:"
"`Mock`. En anledning kan vara att lägga till hjälpmetoder. Här är ett fånigt "
"exempel:"

msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"Standardbeteendet för ``Mock``-instanser är att attribut och returvärden är "
"av samma typ som den mock de är åtkomliga på. Detta säkerställer att "
"``Mock``-attribut är ``Mocks`` och ``MagicMock``-attribut är ``MagicMocks`` "
"[#]_. Så om du subklassar för att lägga till hjälpmetoder så kommer de också "
"att vara tillgängliga på attributen och returvärdet mock av instanser av din "
"subklass."

msgid ""
"Sometimes this is inconvenient. For example, `one user <https://code.google."
"com/archive/p/mock/issues/105>`_ is subclassing mock to created a `Twisted "
"adaptor <https://twisted.org/documents/11.0.0/api/twisted.python.components."
"html>`_. Having this applied to attributes too actually causes errors."
msgstr ""
"Ibland är detta obekvämt. Till exempel, `en användare <https://code.google."
"com/archive/p/mock/issues/105>`_ subklassar mock för att skapa en `Twisted "
"adapter <https://twisted.org/documents/11.0.0/api/twisted.python.components."
"html>`_. Att ha detta tillämpat på attribut också orsakar faktiskt fel."

msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent "
"your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock`` (i alla dess varianter) använder en metod som heter "
"``_get_child_mock`` för att skapa dessa \"sub-mocks\" för attribut och "
"returvärden. Du kan förhindra att din subklass används för attribut genom "
"att åsidosätta den här metoden. Signaturen är att den tar godtyckliga "
"nyckelordsargument (``**kwargs``) som sedan skickas till mock-konstruktören:"

msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable "
"methods."
msgstr ""
"Ett undantag från denna regel är de icke-kallbara mockarna. Attributen "
"använder den anropsbara varianten eftersom icke anropsbara mocks annars inte "
"skulle kunna ha anropsbara metoder."

msgid "Mocking imports with patch.dict"
msgstr "Mocking-import med patch.dict"

msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""
"En situation där mocking kan vara svårt är när du har en lokal import inuti "
"en funktion. Dessa är svårare att mocka eftersom de inte använder ett objekt "
"från modulens namnrymd som vi kan patcha ut."

msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways than "
"an unconditional local import (store the module as a class or module "
"attribute and only do the import on first use)."
msgstr ""
"I allmänhet bör lokal import undvikas. De görs ibland för att förhindra "
"cirkulära beroenden, för vilka det *vanligtvis* finns ett mycket bättre sätt "
"att lösa problemet (refaktorisera koden) eller för att förhindra \"up front-"
"kostnader\" genom att fördröja importen. Detta kan också lösas på bättre "
"sätt än en ovillkorlig lokal import (lagra modulen som ett klass- eller "
"modulattribut och gör bara importen vid första användningen)."

msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in ``sys.modules``, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"Bortsett från det finns det ett sätt att använda ``mock`` för att påverka "
"resultatet av en import. Import hämtar ett *objekt* från ordlistan :data:"
"`sys.modules`. Observera att det hämtar ett *objekt*, som inte behöver vara "
"en modul. Om du importerar en modul för första gången resulterar det i att "
"ett modulobjekt läggs in i ``sys.modules``, så när du importerar något får "
"du vanligtvis en modul tillbaka. Detta behöver dock inte vara fallet."

msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"Detta innebär att du kan använda :func:`patch.dict` för att *tillfälligt* "
"sätta en mock på plats i :data:`sys.modules`. Alla importer medan den här "
"patchen är aktiv kommer att hämta mocken. När patchen är klar (den "
"dekorerade funktionen avslutas, with-satsens kropp är klar eller ``patcher."
"stop()`` anropas) kommer det som fanns där tidigare att återställas på ett "
"säkert sätt."

msgid "Here's an example that mocks out the 'fooble' module."
msgstr "Här är ett exempel som låtsas vara modulen \"fooble\"."

msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"Som du kan se lyckas ``import fooble``, men vid avslut finns det ingen "
"`fooble` kvar i :data:`sys.modules`."

msgid "This also works for the ``from module import name`` form:"
msgstr "Detta fungerar också för formuläret ``från modulens importnamn``:"

msgid "With slightly more work you can also mock package imports:"
msgstr "Med lite mer arbete kan du också mocka paketimport:"

msgid "Tracking order of calls and less verbose call assertions"
msgstr "Spårning av anropsordning och mindre verbala anropsutlåtanden"

msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects, "
"however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
"Klassen :class:`Mock` låter dig spåra *ordningen* på metodanropen på dina "
"mock-objekt genom attributet :attr:`~Mock.method_calls`. Detta tillåter dig "
"inte att spåra ordningen på anrop mellan separata mock-objekt, men vi kan "
"använda :attr:`~Mock.mock_calls` för att uppnå samma effekt."

msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an "
"arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be "
"recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"Eftersom attrapper spårar anrop till barnattrapper i ``mock_calls``, och "
"åtkomst till ett godtyckligt attribut hos en attrapp skapar en barnattrapp, "
"kan vi skapa våra separata attrapper från en förälder. Anrop till dessa barn "
"mock kommer då alla att registreras, i ordning, i ``mock_calls`` av "
"föräldern:"

msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr ""
"Vi kan sedan hävda anropen, inklusive ordningen, genom att jämföra med "
"attributet ``mock_calls`` på manager mock:"

msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"Om ``patch`` skapar, och sätter på plats, dina mockar så kan du koppla dem "
"till en manager mock med hjälp av :meth:`~Mock.attach_mock` metoden. Efter "
"att ha bifogat anrop kommer att spelas in i ``mock_calls`` av chefen. ::"

msgid ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"
msgstr ""
"&gt;&gt;&gt; manager = MagicMock()\n"
"&gt;&gt;&gt; med patch('mymodule.Class1') som MockClass1:\n"
"... med patch('mymodule.Class2') som MockClass2:\n"
"... manager.attach_mock(MockClass1, 'MockClass1')\n"
"... manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
"&gt;&gt;&gt; manager.mock_calls\n"
"[anrop.MockClass1(),\n"
"anrop.MockClass1().foo(),\n"
"anrop.MockClass2(),\n"
"call.MockClass2().bar()]"

msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the :meth:`~Mock."
"assert_has_calls` method. This takes a list of calls (constructed with the :"
"data:`call` object). If that sequence of calls are in :attr:`~Mock."
"mock_calls` then the assert succeeds."
msgstr ""
"Om många anrop har gjorts, men du bara är intresserad av en viss sekvens av "
"dem, är ett alternativ att använda metoden :meth:`~Mock.assert_has_calls`. "
"Denna tar en lista med anrop (konstruerad med :data:`call`-objektet). Om den "
"sekvensen av anrop finns i :attr:`~Mock.mock_calls` så lyckas assert."

msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls "
"that have been made to the mock, the assert still succeeds."
msgstr ""
"Trots att de kedjade anropen ``m.one().two().three()`` inte är de enda anrop "
"som har gjorts till mock, lyckas ändå assert."

msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"Ibland kan en mock ha flera anrop till sig, och du är bara intresserad av "
"att försäkra dig om *vissa* av dessa anrop. Du kanske inte ens bryr dig om "
"ordningen. I det här fallet kan du skicka ``any_order=True`` till "
"``assert_has_calls``:"

msgid "More complex argument matching"
msgstr "Mer komplex argumentmatchning"

msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr ""
"Genom att använda samma grundläggande koncept som :data:`ANY` kan vi "
"implementera matchare för att göra mer komplexa påståenden om objekt som "
"används som argument till mocks."

msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need "
"to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these "
"attributes for us."
msgstr ""
"Anta att vi förväntar oss att ett objekt ska skickas till en mock som som "
"standard jämför lika baserat på objektidentitet (vilket är Python-standarden "
"för användardefinierade klasser). För att använda :meth:`~Mock."
"assert_called_with` skulle vi behöva skicka in exakt samma objekt. Om vi "
"bara är intresserade av några av attributen för detta objekt kan vi skapa en "
"matchare som kontrollerar dessa attribut åt oss."

msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr ""
"I det här exemplet kan du se hur ett \"vanligt\" anrop till "
"``assert_called_with`` inte är tillräckligt:"

msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr "En jämförelsefunktion för vår klass ``Foo`` kan se ut ungefär så här:"

msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr ""
"Och ett matchningsobjekt som kan använda jämförelsefunktioner som denna för "
"sin jämlikhetsoperation skulle se ut ungefär så här:"

msgid "Putting all this together:"
msgstr "Om vi lägger ihop allt detta:"

msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher`` "
"equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is "
"raised:"
msgstr ""
"``Matcher`` instansieras med vår jämförelsefunktion och ``Foo``-objektet som "
"vi vill jämföra mot. I ``assert_called_with`` kommer ``Matcher`` equality-"
"metoden att anropas, vilket jämför objektet som mocken anropades med mot det "
"som vi skapade vår matcher med. Om de matchar så går ``assert_called_with`` "
"igenom, och om de inte gör det så uppstår ett :exc:`AssertionError`:"

msgid ""
"With a bit of tweaking you could have the comparison function raise the :exc:"
"`AssertionError` directly and provide a more useful failure message."
msgstr ""
"Med lite finjusteringar kan du få jämförelsefunktionen att lyfta :exc:"
"`AssertionError` direkt och ge ett mer användbart felmeddelande."

msgid ""
"As of version 1.5, the Python testing library `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ provides similar functionality, that may be "
"useful here, in the form of its equality matcher (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
msgstr ""
"Från och med version 1.5 tillhandahåller Python-testbiblioteket `PyHamcrest "
"<https://pyhamcrest.readthedocs.io/>`_ liknande funktionalitet, som kan vara "
"användbar här, i form av dess jämlikhetsmatchning (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
