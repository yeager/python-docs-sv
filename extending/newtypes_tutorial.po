# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Defining Extension Types: Tutorial"
msgstr "Definiera typer av tillägg: Handledning"

msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` "
"and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before you "
"can get started.  This document is a gentle introduction to the topic."
msgstr ""
"Python tillåter skribenten av en C-tilläggsmodul att definiera nya typer som "
"kan manipuleras från Python-kod, ungefär som de inbyggda typerna :class:"
"`str` och :class:`list`.  Koden för alla tilläggstyper följer ett mönster, "
"men det finns några detaljer som du behöver förstå innan du kan komma "
"igång.  Detta dokument är en lätt introduktion till ämnet."

msgid "The Basics"
msgstr "Grunderna"

msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type :c:"
"expr:`PyObject*`, which serves as a \"base type\" for all Python objects. "
"The :c:type:`PyObject` structure itself only contains the object's :term:"
"`reference count` and a pointer to the object's \"type object\". This is "
"where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on "
"an object, a method called, or it is multiplied by another object.  These C "
"functions are called \"type methods\"."
msgstr ""
"Körningsprogrammet :term:`CPython` ser alla Python-objekt som variabler av "
"typen :c:expr:`PyObject*`, som fungerar som en \"bastyp\" för alla Python-"
"objekt. Själva :c:type:`PyObject`-strukturen innehåller bara objektets :term:"
"`referensantal` och en pekare till objektets \"typobjekt\". Det är här det "
"händer; typobjektet avgör vilka (C)-funktioner som anropas av tolken när t."
"ex. ett attribut slås upp på ett objekt, en metod anropas eller det "
"multipliceras med ett annat objekt.  Dessa C-funktioner kallas "
"\"typmetoder\"."

msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr ""
"Om du vill definiera en ny förlängningstyp måste du alltså skapa ett nytt "
"typobjekt."

msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`!Custom` inside a "
"C extension module :mod:`!custom`:"
msgstr ""
"Den här typen av saker kan bara förklaras med exempel, så här är en minimal, "
"men komplett, modul som definierar en ny typ med namnet :class:`!Custom` "
"inuti en C-tilläggsmodul :mod:`!custom`:"

msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the :c:func:"
"`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"Det vi visar här är det traditionella sättet att definiera *statiska* "
"förlängningstyper.  Det bör vara tillräckligt för de flesta "
"användningsområden.  C API tillåter också att definiera heap-allokerade "
"tilläggstyper med hjälp av funktionen :c:func:`PyType_FromSpec`, som inte "
"behandlas i denna handledning."

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    /* Type-specific fields go here. */\n"
"} CustomObject;\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    // Just use this while using static types\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#inkludera <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyObject_Huvud\n"
"    /* Typspecifika fält hamnar här. */\n"
"} Anpassat objekt;\n"
"\n"
"statisk PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"anpassad.anpassad\",\n"
"    .tp_doc = PyDoc_STR(\"Anpassade objekt\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};\n"
"\n"
"statisk int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        returnera -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    // Använd bara detta när du använder statiska typer\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"statisk PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"anpassad\",\n"
"    .m_doc = \"Exempelmodul som skapar en tilläggstyp.\",\n"
"    .m_size = 0,\n"
"    .m_slots = anpassade_modul_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr ""
"Nu är det en hel del att ta in på en gång, men förhoppningsvis kommer bitar "
"att verka bekanta från föregående kapitel.  Den här filen definierar tre "
"saker:"

msgid ""
"What a :class:`!Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`!Custom` instance."
msgstr ""
"Vad ett :class:`!Custom` **objekt** innehåller: detta är strukturen "
"``CustomObject``, som allokeras en gång för varje :class:`!Custom`-instans."

msgid ""
"How the :class:`!Custom` **type** behaves: this is the ``CustomType`` "
"struct, which defines a set of flags and function pointers that the "
"interpreter inspects when specific operations are requested."
msgstr ""
"Hur :class:`!Custom` **type** beter sig: detta är ``CustomType``-strukturen, "
"som definierar en uppsättning flaggor och funktionspoängare som tolken "
"inspekterar när specifika operationer begärs."

msgid ""
"How to define and execute the :mod:`!custom` module: this is the "
"``PyInit_custom`` function and the associated ``custom_module`` struct for "
"defining the module, and the ``custom_module_exec`` function to set up a "
"fresh module object."
msgstr ""
"Hur man definierar och kör :mod:`!custom`-modulen: detta är funktionen "
"``PyInit_custom`` och den tillhörande ``custom_module``-strukturen för att "
"definiera modulen, och funktionen ``custom_module_exec`` för att skapa ett "
"nytt modulobjekt."

msgid "The first bit is::"
msgstr "Den första biten är::"

msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} CustomObject;"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} Anpassat objekt;"

msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of "
"type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_TYPE` "
"and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in :ref:`debug "
"builds <debug-build>`."
msgstr ""
"Det här är vad ett Custom-objekt kommer att innehålla.  ``PyObject_HEAD`` är "
"obligatoriskt i början av varje objektstruktur och definierar ett fält som "
"heter ``ob_base`` av typen :c:type:`PyObject`, som innehåller en pekare till "
"ett typobjekt och ett referensantal (dessa kan nås med hjälp av makrot :c:"
"macro:`Py_TYPE` respektive :c:macro:`Py_REFCNT`).  Anledningen till makrot "
"är att abstrahera bort layouten och att möjliggöra ytterligare fält i :ref:"
"`debug builds <debug-build>`."

msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
"Det finns inget semikolon ovan efter makrot :c:macro:`PyObject_HEAD`. Var "
"försiktig med att lägga till ett av misstag: vissa kompilatorer kommer att "
"klaga."

msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"Naturligtvis lagrar objekt i allmänhet ytterligare data utöver standard "
"``PyObject_HEAD``; här är till exempel definitionen för standard Python-"
"flottor::"

msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    double ob_fval;\n"
"} PyFloatObject;"
msgstr ""
"typedef struct {\n"
"    PyObjekt_Huvud\n"
"    dubbel ob_fval;\n"
"} PyFloatObject;"

msgid "The second bit is the definition of the type object. ::"
msgstr "Den andra biten är definitionen av typen objekt. ::"

msgid ""
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};"
msgstr ""
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Anpassade objekt\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT,\n"
"    .tp_new = PyType_GenericNew,\n"
"};"

msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr ""
"Vi rekommenderar att man använder C99-stil för angivna initialiserare enligt "
"ovan, för att undvika att lista alla :c:type:`PyTypeObject`-fält som man "
"inte bryr sig om och även för att undvika att bry sig om fältens "
"deklarationsordning."

msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many "
"more :ref:`fields <type-structs>` than the definition above.  The remaining "
"fields will be filled with zeros by the C compiler, and it's common practice "
"to not specify them explicitly unless you need them."
msgstr ""
"Den faktiska definitionen av :c:type:`PyTypeObject` i :file:`object.h` har "
"många fler :ref:`fields <type-structs>` än definitionen ovan.  De "
"återstående fälten kommer att fyllas med nollor av C-kompilatorn, och det är "
"vanligt att inte ange dem explicit om du inte behöver dem."

msgid "We're going to pick it apart, one field at a time::"
msgstr "Vi kommer att plocka isär det, ett fält i taget::"

msgid ".ob_base = PyVarObject_HEAD_INIT(NULL, 0)"
msgstr ".ob_base = PyVarObject_HEAD_INIT(NULL, 0)"

msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr ""
"Denna rad är en obligatorisk boilerplate för att initiera fältet ``ob_base`` "
"som nämns ovan. ::"

msgid ".tp_name = \"custom.Custom\","
msgstr ".tp_name = \"custom.Custom\","

msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr ""
"Namnet på vår typ.  Detta kommer att visas i standardtextrepresentationen av "
"våra objekt och i vissa felmeddelanden, till exempel:"

msgid ""
">>> \"\" + custom.Custom()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: can only concatenate str (not \"custom.Custom\") to str"
msgstr ""
"&gt;&gt;&gt; \"\" + anpassad.anpassad()\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: kan bara konkatenera str (inte \"custom.Custom\") till str"

msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:`!"
"custom` and the type is :class:`!Custom`, so we set the type name to :class:"
"`!custom.Custom`. Using the real dotted import path is important to make "
"your type compatible with the :mod:`pydoc` and :mod:`pickle` modules. ::"
msgstr ""
"Observera att namnet är ett punktformat namn som innehåller både modulnamnet "
"och namnet på typen i modulen. Modulen i det här fallet är :mod:`!custom` "
"och typen är :class:`!Custom`, så vi sätter typnamnet till :class:`!custom."
"Custom`. Att använda den riktiga prickade importvägen är viktigt för att "
"göra din typ kompatibel med modulerna :mod:`pydoc` och :mod:`pickle`. ::"

msgid ""
".tp_basicsize = sizeof(CustomObject),\n"
".tp_itemsize = 0,"
msgstr ""
".tp_basicsize = sizeof(CustomObject),\n"
".tp_itemsize = 0,"

msgid ""
"This is so that Python knows how much memory to allocate when creating new :"
"class:`!Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
"Detta för att Python ska veta hur mycket minne som ska allokeras när nya :"
"class:`!Custom`-instanser skapas. :c:member:`~PyTypeObject.tp_itemsize` "
"används endast för objekt med variabel storlek och ska annars vara noll."

msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~type.__bases__`, or else it will "
"not be able to call your type's :meth:`~object.__new__` method without "
"getting an error.  You can avoid this problem by ensuring that your type has "
"a larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""
"Om du vill att din typ ska vara subklassbar från Python, och din typ har "
"samma :c:member:`~PyTypeObject.tp_basicsize` som sin bastyp, kan du få "
"problem med multipelt arv.  En Python-subklass av din typ måste lista din "
"typ först i sin :attr:`~type.__bases__`, annars kommer den inte att kunna "
"anropa din typs :meth:`~object.__new__`-metod utan att få ett fel.  Du kan "
"undvika det här problemet genom att se till att din typ har ett större värde "
"för :c:member:`~PyTypeObject.tp_basicsize` än vad dess bastyp har.  För det "
"mesta kommer detta att vara sant ändå, eftersom antingen din bastyp kommer "
"att vara :class:`object`, eller så kommer du att lägga till datamedlemmar "
"till din bastyp och därför öka dess storlek."

msgid "We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::"
msgstr "Vi sätter klassflaggorna till :c:macro:`Py_TPFLAGS_DEFAULT`. ::"

msgid ".tp_flags = Py_TPFLAGS_DEFAULT,"
msgstr ".tp_flags = Py_TPFLAGS_DEFAULT,"

msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members, "
"you will need to OR the corresponding flags."
msgstr ""
"Alla typer bör inkludera denna konstant i sina flaggor.  Den aktiverar alla "
"medlemmar som definierats fram till åtminstone Python 3.3.  Om du behöver "
"ytterligare medlemmar måste du OR motsvarande flaggor."

msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr ""
"Vi tillhandahåller en dokumentsträng för typen i :c:member:`~PyTypeObject."
"tp_doc`. ::"

msgid ".tp_doc = PyDoc_STR(\"Custom objects\"),"
msgstr ".tp_doc = PyDoc_STR(\"Anpassade objekt\"),"

msgid ""
"To enable object creation, we have to provide a :c:member:`~PyTypeObject."
"tp_new` handler.  This is the equivalent of the Python method :meth:`~object."
"__new__`, but has to be specified explicitly.  In this case, we can just use "
"the default implementation provided by the API function :c:func:"
"`PyType_GenericNew`. ::"
msgstr ""
"För att möjliggöra skapandet av objekt måste vi tillhandahålla en :c:member:"
"`~PyTypeObject.tp_new`-hanterare.  Detta är motsvarigheten till Python-"
"metoden :meth:`~object.__new__`, men måste specificeras explicit.  I det här "
"fallet kan vi bara använda standardimplementeringen som tillhandahålls av "
"API-funktionen :c:func:`PyType_GenericNew`. ::"

msgid ".tp_new = PyType_GenericNew,"
msgstr ".tp_new = PyType_GenericNew,"

msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`!custom_module_exec`::"
msgstr ""
"Allt annat i filen bör vara bekant, förutom en del kod i :c:func:`!"
"custom_module_exec`::"

msgid ""
"if (PyType_Ready(&CustomType) < 0) {\n"
"    return -1;\n"
"}"
msgstr ""
"if (PyType_Ready(&CustomType) < 0) {\n"
"    returnera -1;\n"
"}"

msgid ""
"This initializes the :class:`!Custom` type, filling in a number of members "
"to the appropriate default values, including :c:member:`~PyObject.ob_type` "
"that we initially set to ``NULL``. ::"
msgstr ""
"Detta initierar typen :class:`!Custom` och fyller i ett antal medlemmar med "
"lämpliga standardvärden, inklusive :c:member:`~PyObject.ob_type` som vi "
"ursprungligen satte till ``NULL``. ::"

msgid ""
"if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\n"
"    return -1;\n"
"}"
msgstr ""
"if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) {\n"
"    return -1;\n"
"}"

msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`!Custom` instances by calling the :class:`!Custom` class:"
msgstr ""
"Detta lägger till typen i modulens ordlista.  Detta gör att vi kan skapa :"
"class:`!Custom`-instanser genom att anropa :class:`!Custom`-klassen:"

msgid ""
">>> import custom\n"
">>> mycustom = custom.Custom()"
msgstr ""
">>> import custom\n"
">>> mycustom = custom.Custom()"

msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c`,"
msgstr ""
"Nu är det klart!  Allt som återstår är att bygga den; lägg ovanstående kod i "
"en fil som heter :file:`custom.c`,"

msgid ""
"[build-system]\n"
"requires = [\"setuptools\"]\n"
"build-backend = \"setuptools.build_meta\"\n"
"\n"
"[project]\n"
"name = \"custom\"\n"
"version = \"1\"\n"
msgstr ""
"[byggsystem]\n"
"kräver = [\"setuptools\"]\n"
"bygg-backend = \"setuptools.build_meta\"\n"
"\n"
"[projekt]\n"
"namn = \"anpassad\"\n"
"version = \"1\"\n"

msgid "in a file called :file:`pyproject.toml`, and"
msgstr "i en fil som heter :file:`pyproject.toml`, och"

msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[Extension(\"custom\", [\"custom.c\"])])"
msgstr ""
"from setuptools import Tillägg, setup\n"
"setup(ext_modules=[Tillägg(\"custom\", [\"custom.c\"]))])"

msgid "in a file called :file:`setup.py`; then typing"
msgstr "i en fil som heter :file:`setup.py`; sedan skriver du"

msgid "$ python -m pip install ."
msgstr "$ python -m pip installera ."

msgid ""
"in a shell should produce a file :file:`custom.so` in a subdirectory and "
"install it; now fire up Python --- you should be able to ``import custom`` "
"and play around with ``Custom`` objects."
msgstr ""
"i ett skal bör producera en fil :file:`custom.so` i en underkatalog och "
"installera den; starta nu Python --- du bör kunna ``importera custom`` och "
"leka med ``Custom``-objekt."

msgid "That wasn't so hard, was it?"
msgstr "Det var väl inte så svårt, eller hur?"

msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""
"Naturligtvis är den nuvarande Custom-typen ganska ointressant. Den har inga "
"data och gör ingenting. Den kan inte ens underklassificeras."

msgid "Adding data and methods to the Basic example"
msgstr "Lägga till data och metoder i Basic-exemplet"

msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:`!"
"custom2` that adds these capabilities:"
msgstr ""
"Låt oss utöka grundexemplet för att lägga till data och metoder.  Låt oss "
"också göra typen användbar som basklass. Vi skapar en ny modul, :mod:`!"
"custom2`, som lägger till dessa funktioner:"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_XSETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_XSETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom2.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom2\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom2(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#include <Python.h> #include <stddef.h> /* för offsetof()\n"
"#include <stddef.h> /* för offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_Huvud\n"
"    PyObject *first; /* förnamn */\n"
"    PyObject *last; /* efternamn */\n"
"    int nummer;\n"
"} CustomObject;\n"
"\n"
"statiskt void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(själv>första);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"statiskt PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"statisk int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &själv->nummer))\n"
"        return -1;\n"
"\n"
"    if (första) {\n"
"        Py_XSETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (sista) {\n"
"        Py_XSETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"förnamn\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,"
"\"efternamn\"}, {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"efternamn\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"anpassat nummer\"},\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statiskt PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        returnera NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        returnera NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Eget_namn, METH_NOARGS,\n"
"     \"Returnera namnet genom att kombinera för- och efternamn\"\n"
"    },\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statisk PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom2.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Anpassade objekt\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Egen_ny,\n"
"    .tp_init = Anpassad_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Anpassad_members,\n"
"    .tp_methods = Custom_methods,\n"
"};\n"
"\n"
"statisk int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        returnera -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"statisk PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"anpassad2\",\n"
"    .m_doc = \"Exempelmodul som skapar en tilläggstyp.\",\n"
"    .m_size = 0,\n"
"    .m_slots = anpassade_modul_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom2(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

msgid "This version of the module has a number of changes."
msgstr "Denna version av modulen har ett antal ändringar."

msgid ""
"The  :class:`!Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""
"Typen :class:`!Custom` har nu tre dataattribut i sin C-struktur, *first*, "
"*last* och *number*.  Variablerna *first* och *last* är Python-strängar som "
"innehåller för- och efternamn.  Attributet *number* är ett heltal i C."

msgid "The object structure is updated accordingly::"
msgstr "Objektstrukturen uppdateras i enlighet med detta::"

msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;"
msgstr ""
"typedef struct {\n"
"    PyObject_Huvud\n"
"    PyObject *first; /* förnamn */\n"
"    PyObject *last; /* efternamn */\n"
"    int nummer;\n"
"} CustomObject;"

msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"Eftersom vi nu har data att hantera måste vi vara mer försiktiga med "
"objektallokering och -deallokering.  Vi behöver åtminstone en metod för "
"avallokering::"

msgid ""
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"statiskt void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(själv>första);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}"

msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "som är tilldelad :c:member:`~PyTypeObject.tp_dealloc` member::"

msgid ".tp_dealloc = Custom_dealloc,"
msgstr ".tp_dealloc = Anpassad_dealloc,"

msgid ""
"This method first clears the reference counts of the two Python attributes. :"
"c:func:`Py_XDECREF` correctly handles the case where its argument is "
"``NULL`` (which might happen here if ``tp_new`` failed midway).  It then "
"calls the :c:member:`~PyTypeObject.tp_free` member of the object's type "
"(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that the "
"object's type might not be :class:`!CustomType`, because the object may be "
"an instance of a subclass."
msgstr ""
"Denna metod rensar först referensräkningarna för de två Python-attributen. :"
"c:func:`Py_XDECREF` hanterar korrekt fallet där dess argument är ``NULL`` "
"(vilket kan hända här om ``tp_new`` misslyckades halvvägs).  Den anropar "
"sedan :c:member:`~PyTypeObject.tp_free`-medlemmen av objektets typ (beräknad "
"av ``Py_TYPE(self)``) för att frigöra objektets minne.  Observera att "
"objektets typ kanske inte är :class:`!CustomType`, eftersom objektet kan "
"vara en instans av en underklass."

msgid ""
"The explicit cast to ``CustomObject *`` above is needed because we defined "
"``Custom_dealloc`` to take a ``PyObject *`` argument, as the ``tp_dealloc`` "
"function pointer expects to receive a ``PyObject *`` argument. By assigning "
"to the ``tp_dealloc`` slot of a type, we declare that it can only be called "
"with instances of our ``CustomObject`` class, so the cast to ``(CustomObject "
"*)`` is safe. This is object-oriented polymorphism, in C!"
msgstr ""
"Den uttryckliga castningen till ``CustomObject *`` ovan behövs eftersom vi "
"definierade ``Custom_dealloc`` att ta ett ``PyObject *`` argument, eftersom "
"``tp_dealloc`` funktionspekaren förväntar sig att ta emot ett ``PyObject *`` "
"argument. Genom att tilldela ``tp_dealloc`` slot till en typ, deklarerar vi "
"att den endast kan anropas med instanser av vår ``CustomObject`` klass, så "
"castet till ``(CustomObject *)`` är säkert. Detta är objektorienterad "
"polymorfism, i C!"

msgid ""
"In existing code, or in previous versions of this tutorial, you might see "
"similar functions take a pointer to the subtype object structure "
"(``CustomObject*``) directly, like this::"
msgstr ""
"I befintlig kod, eller i tidigare versioner av denna handledning, kan du se "
"liknande funktioner som tar en pekare till subtypens objektstruktur "
"(``CustomObject*``) direkt, så här::"

msgid ""
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"...\n"
".tp_dealloc = (destructor) Custom_dealloc,"
msgstr ""
"Custom_dealloc(CustomObject *self)\n"
"{\n"
"    Py_XDECREF(själv>första);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free((PyObject *) self);\n"
"}\n"
"...\n"
".tp_dealloc = (destructor) Custom_dealloc,"

msgid ""
"This does the same thing on all architectures that CPython supports, but "
"according to the C standard, it invokes undefined behavior."
msgstr ""
"Detta gör samma sak på alla arkitekturer som CPython stöder, men enligt C-"
"standarden ger det upphov till ett odefinierat beteende."

msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr ""
"Vi vill se till att för- och efternamn initialiseras till tomma strängar, så "
"vi tillhandahåller en ``tp_new``-implementering::"

msgid ""
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"Custom_new(PyTypeObject *typ, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = PyUnicode_FromString(\"\");\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->last = PyUnicode_FromString(\"\");\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}"

msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "och installera den i :c:member:`~PyTypeObject.tp_new` member::"

msgid ".tp_new = Custom_new,"
msgstr ".tp_new = Anpassad_ny,"

msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the :meth:"
"`~object.__new__` method. It is not required to define a ``tp_new`` member, "
"and indeed many extension types will simply reuse :c:func:"
"`PyType_GenericNew` as done in the first version of the :class:`!Custom` "
"type above.  In this case, we use the ``tp_new`` handler to initialize the "
"``first`` and ``last`` attributes to non-``NULL`` default values."
msgstr ""
"Hanteraren ``tp_new`` är ansvarig för att skapa (i motsats till att "
"initialisera) objekt av typen.  Den exponeras i Python som metoden :meth:"
"`~object.__new__`. Det är inte nödvändigt att definiera en ``tp_new``-"
"medlem, och många tilläggstyper kommer helt enkelt att återanvända :c:func:"
"`PyType_GenericNew`` som i den första versionen av :class:`!Custom`-typen "
"ovan.  I det här fallet använder vi hanteraren ``tp_new`` för att initiera "
"attributen ``first`` och ``last`` till standardvärden som inte är ``NULL``."

msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when "
"the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they "
"often ignore the arguments, leaving the argument handling to initializer (a."
"k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"``tp_new`` får den typ som instansieras (inte nödvändigtvis ``CustomType``, "
"om en underklass instansieras) och eventuella argument som skickades när "
"typen anropades, och förväntas returnera den instans som skapats.  "
"``tp_new``-hanterare accepterar alltid positions- och nyckelordsargument, "
"men de ignorerar ofta argumenten och lämnar argumenthanteringen till "
"initialiseringsmetoder (a.k.a. ``tp_init`` i C eller ``__init__`` i Python)."

msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do "
"it itself."
msgstr ""
"``tp_new`` bör inte anropa ``tp_init`` explicit, eftersom tolken kommer att "
"göra det själv."

msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr ""
"Implementationen ``tp_new`` anropar :c:member:`~PyTypeObject.tp_alloc` för "
"att allokera minne::"

msgid "self = (CustomObject *) type->tp_alloc(type, 0);"
msgstr "self = (CustomObject *) type->tp_alloc(type, 0);"

msgid ""
"Since memory allocation may fail, we must check the :c:member:`~PyTypeObject."
"tp_alloc` result against ``NULL`` before proceeding."
msgstr ""
"Eftersom minnesallokering kan misslyckas måste vi kontrollera :c:member:"
"`~PyTypeObject.tp_alloc`-resultatet mot ``NULL`` innan vi fortsätter."

msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""
"Vi har inte fyllt :c:member:`~PyTypeObject.tp_alloc`-platsen själva. "
"Istället fyller :c:func:`PyType_Ready` den åt oss genom att ärva den från "
"vår basklass, som är :class:`object` som standard.  De flesta typer använder "
"standardallokeringsstrategin."

msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:`~object."
"__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"Om du skapar en kooperativ :c:member:`~PyTypeObject.tp_new` (en som anropar "
"en bastyps :c:member:`~PyTypeObject.tp_new` eller :meth:`~object.__new__`), "
"får du *inte* försöka avgöra vilken metod som ska anropas med hjälp av "
"metodresolutionsordning vid körning.  Bestäm alltid statiskt vilken typ du "
"ska anropa, och anropa dess :c:member:`~PyTypeObject.tp_new` direkt, eller "
"via ``type->tp_base->tp_new``.  Om du inte gör detta kan det hända att "
"Python-subklasser av din typ som också ärver från andra Python-definierade "
"klasser inte fungerar korrekt. (Specifikt kanske du inte kan skapa instanser "
"av sådana subklasser utan att få ett :exc:`TypeError`)"

msgid ""
"We also define an initialization function which accepts arguments to provide "
"initial values for our instance::"
msgstr ""
"Vi definierar också en initialiseringsfunktion som accepterar argument för "
"att tillhandahålla initiala värden för vår instans::"

msgid ""
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|OOi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &själv->nummer))\n"
"        return -1;\n"
"\n"
"    if (första) {\n"
"        tmp = själv>första;\n"
"        Py_INCREF(första);\n"
"        själv>första = första;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    if (sista) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(sista);\n"
"        self->last = sista;\n"
"        Py_XDECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"

msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "genom att fylla :c:member:`~PyTypeObject.tp_init` slot. ::"

msgid ".tp_init = Custom_init,"
msgstr ".tp_init = Custom_init,"

msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`~object.__init__` method.  It is used to initialize an object after it's "
"created.  Initializers always accept positional and keyword arguments, and "
"they should return either ``0`` on success or ``-1`` on error."
msgstr ""
"Slotten :c:member:`~PyTypeObject.tp_init` exponeras i Python som metoden :"
"meth:`~object.__init__`.  Den används för att initiera ett objekt efter att "
"det har skapats.  Initialiserare accepterar alltid positionella argument och "
"nyckelordsargument, och de bör returnera antingen ``0`` vid framgång eller "
"``-1`` vid fel."

msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`~object.__init__` on unpickled instances).  It can also be "
"called multiple times.  Anyone can call the :meth:`!__init__` method on our "
"objects.  For this reason, we have to be extra careful when assigning the "
"new attribute values.  We might be tempted, for example to assign the "
"``first`` member like this::"
msgstr ""
"Till skillnad från ``tp_new``-hanteraren finns det ingen garanti för att "
"``tp_init`` anropas överhuvudtaget (till exempel anropar modulen :mod:"
"`pickle` som standard inte :meth:`~object.__init__` på instanser som inte "
"har plockats upp).  Den kan också anropas flera gånger.  Vem som helst kan "
"anropa metoden :meth:`!__init__` på våra objekt.  Av denna anledning måste "
"vi vara extra försiktiga när vi tilldelar de nya attributvärdena.  Vi kan t."
"ex. frestas att tilldela ``first``-medlemmen så här::"

msgid ""
"if (first) {\n"
"    Py_XDECREF(self->first);\n"
"    Py_INCREF(first);\n"
"    self->first = first;\n"
"}"
msgstr ""
"if (första) {\n"
"    Py_XDECREF(själv>först);\n"
"    Py_INCREF(första);\n"
"    self->first = första;\n"
"}"

msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could detach the :term:`thread state "
"<attached thread state>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""
"Men detta skulle vara riskabelt.  Vår typ begränsar inte typen av den "
"``första`` medlemmen, så det kan vara vilken typ av objekt som helst.  Det "
"skulle kunna ha en destruktor som gör att kod exekveras som försöker komma "
"åt ``first``-medlemmen; eller så skulle den destruktorn kunna koppla bort :"
"term:``thread state <attached thread state>`` och låta godtycklig kod köras "
"i andra trådar som kommer åt och modifierar vårt objekt."

msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr ""
"För att vara paranoid och skydda oss mot denna möjlighet omplacerar vi "
"nästan alltid medlemmar innan vi minskar deras referensantal.  När behöver "
"vi inte göra detta?"

msgid "when we absolutely know that the reference count is greater than 1;"
msgstr "när vi absolut vet att referensantalet är större än 1;"

msgid ""
"when we know that deallocation of the object [#]_ will neither detach the :"
"term:`thread state <attached thread state>` nor cause any calls back into "
"our type's code;"
msgstr ""
"när vi vet att deallokering av objektet [#]_ varken kommer att ta bort :term:"
"`thread state <attached thread state>` eller orsaka några anrop tillbaka "
"till vår typs kod;"

msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler on a type which doesn't support cyclic garbage "
"collection [#]_."
msgstr ""
"vid dekrementering av ett referensantal i en :c:member:`~PyTypeObject."
"tp_dealloc`-hanterare på en typ som inte stöder cyklisk skräpinsamling [#]_."

msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"Vi vill exponera våra instansvariabler som attribut. Det finns ett antal "
"olika sätt att göra det på. Det enklaste sättet är att definiera "
"medlemsdefinitioner::"

msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"first name\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"last name\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"first\", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,\n"
"     \"förnamn\"},\n"
"    {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,"
"\"efternamn\"}, {\"last\", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,\n"
"     \"efternamn\"},\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"anpassat nummer\"},\n"
"    {NULL} /* Sentinel */\n"
"};"

msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr ""
"och placera definitionerna i :c:member:`~PyTypeObject.tp_members` slot::"

msgid ".tp_members = Custom_members,"
msgstr ".tp_members = Anpassade_medlemmar,"

msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"Varje medlemsdefinition har ett medlemsnamn, typ, offset, åtkomstflaggor och "
"dokumentationssträng.  Se avsnittet :ref:`Generic-Attribute-Management` "
"nedan för mer information."

msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"``NULL``.  Even though we can make sure the members are initialized to non-"
"``NULL`` values, the members can be set to ``NULL`` if the attributes are "
"deleted."
msgstr ""
"En nackdel med detta tillvägagångssätt är att det inte ger något sätt att "
"begränsa de typer av objekt som kan tilldelas Python-attributen.  Vi "
"förväntar oss att för- och efternamn ska vara strängar, men alla Python-"
"objekt kan tilldelas. Dessutom kan attributen tas bort genom att C-pekarna "
"sätts till ``NULL``.  Även om vi kan se till att medlemmarna initialiseras "
"till värden som inte är ``NULL``, kan medlemmarna sättas till ``NULL`` om "
"attributen raderas."

msgid ""
"We define a single method, :meth:`!Custom.name`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr ""
"Vi definierar en enda metod, :meth:`!Custom.name`, som matar ut objektets "
"namn som en sammankoppling av för- och efternamn. ::"

msgid ""
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        return NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        return NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (self->first == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"first\");\n"
"        returnera NULL;\n"
"    }\n"
"    if (self->last == NULL) {\n"
"        PyErr_SetString(PyExc_AttributeError, \"last\");\n"
"        returnera NULL;\n"
"    }\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}"

msgid ""
"The method is implemented as a C function that takes a :class:`!Custom` (or :"
"class:`!Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need "
"to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""
"Metoden är implementerad som en C-funktion som tar en instans av :class:`!"
"Custom` (eller :class:`!Custom` subclass) som första argument.  Metoder tar "
"alltid en instans som första argument. Metoder tar ofta positionella "
"argument och nyckelordsargument också, men i det här fallet tar vi inga och "
"behöver inte acceptera en tupel med positionella argument eller en ordbok "
"med nyckelordsargument. Denna metod är likvärdig med Python-metoden:"

msgid ""
"def name(self):\n"
"    return \"%s %s\" % (self.first, self.last)"
msgstr ""
"def namn(self):\n"
"    return \"%s %s\" % (self.first, self.last)"

msgid ""
"Note that we have to check for the possibility that our :attr:`!first` and :"
"attr:`!last` members are ``NULL``.  This is because they can be deleted, in "
"which case they are set to ``NULL``.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
"Observera att vi måste kontrollera om våra medlemmar :attr:`!first` och :"
"attr:`!last` är ``NULL``.  Detta beror på att de kan raderas, i vilket fall "
"de sätts till ``NULL``.  Det vore bättre att förhindra radering av dessa "
"attribut och att begränsa attributvärdena till strängar.  Vi ska se hur man "
"gör det i nästa avsnitt."

msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr ""
"Nu när vi har definierat metoden måste vi skapa en matris med "
"metoddefinitioner::"

msgid ""
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"statisk PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Eget_namn, METH_NOARGS,\n"
"     \"Returnera namnet genom att kombinera för- och efternamn\"\n"
"    },\n"
"    {NULL} /* Sentinel */\n"
"};"

msgid ""
"(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the "
"method is expecting no arguments other than *self*)"
msgstr ""
"(notera att vi använde :c:macro:`METH_NOARGS`-flaggan för att ange att "
"metoden inte förväntar sig några andra argument än *self*)"

msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "och tilldela den till :c:member:`~PyTypeObject.tp_methods` slot::"

msgid ".tp_methods = Custom_methods,"
msgstr ".tp_methods = Anpassade_metoder,"

msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions "
"about the type of the object being created or used, so all we need to do is "
"to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"Slutligen ska vi göra vår typ användbar som basklass för underklassning.  Vi "
"har hittills skrivit våra metoder noggrant så att de inte gör några "
"antaganden om typen av det objekt som skapas eller används, så allt vi "
"behöver göra är att lägga till :c:macro:`Py_TPFLAGS_BASETYPE` till vår "
"klassflaggdefinition::"

msgid ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,"
msgstr ".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,"

msgid ""
"We rename :c:func:`!PyInit_custom` to :c:func:`!PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""
"Vi byter namn på :c:func:`!PyInit_custom` till :c:func:`!PyInit_custom2`, "
"uppdaterar modulnamnet i struct:en :c:type:`PyModuleDef` och uppdaterar det "
"fullständiga klassnamnet i struct:en :c:type:`PyTypeObject`."

msgid "Finally, we update our :file:`setup.py` file to include the new module,"
msgstr ""
"Slutligen uppdaterar vi vår :file:`setup.py`-fil så att den inkluderar den "
"nya modulen,"

msgid ""
"from setuptools import Extension, setup\n"
"setup(ext_modules=[\n"
"    Extension(\"custom\", [\"custom.c\"]),\n"
"    Extension(\"custom2\", [\"custom2.c\"]),\n"
"])"
msgstr ""
"from setuptools import Förlängning, setup\n"
"setup(ext_modules=[\n"
"    Extension(\"custom\", [\"custom.c\"]),\n"
"    Extension(\"custom2\", [\"custom2.c\"]),\n"
"])"

msgid "and then we re-install so that we can ``import custom2``:"
msgstr "och sedan installerar vi om så att vi kan ``importera custom2``:"

msgid "Providing finer control over data attributes"
msgstr "Tillhandahåller finare kontroll över dataattribut"

msgid ""
"In this section, we'll provide finer control over how the :attr:`!first` "
"and :attr:`!last` attributes are set in the :class:`!Custom` example. In the "
"previous version of our module, the instance variables :attr:`!first` and :"
"attr:`!last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"I det här avsnittet ska vi ge finare kontroll över hur attributen :attr:`!"
"first` och :attr:`!last` anges i exemplet :class:`!Custom`. I den tidigare "
"versionen av vår modul kunde instansvariablerna :attr:`!first` och :attr:`!"
"last` sättas till icke-strängvärden eller till och med raderas. Vi vill se "
"till att dessa attribut alltid innehåller strängar."

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(self->first);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom3.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom3\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom3(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#include <Python.h> #include <stddef.h> /* för offsetof()\n"
"#include <stddef.h> /* för offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_Huvud\n"
"    PyObject *first; /* förnamn */\n"
"    PyObject *last; /* efternamn */\n"
"    int nummer;\n"
"} CustomObject;\n"
"\n"
"statiskt void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_XDECREF(själv>första);\n"
"    Py_XDECREF(self->last);\n"
"    Py_TYPE(self)->tp_free(self);\n"
"}\n"
"\n"
"statiskt PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"statisk int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &själv->nummer))\n"
"        return -1;\n"
"\n"
"    if (första) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"anpassat nummer\"},\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statiskt PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"statisk int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (värde == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Det går inte att ta bort det "
"första attributet\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"Det första attributvärdet måste vara en "
"sträng\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"statiskt PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"statisk int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (värde == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Det går inte att ta bort det "
"sista attributet\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"Det sista attributvärdet måste vara en sträng\");\n"
"        return -1;\n"
"    }\n"
"    Py_SETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"förnamn\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"efternamn\", NULL},\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statiskt PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Eget_namn, METH_NOARGS,\n"
"     \"Returnera namnet genom att kombinera för- och efternamn\"\n"
"    },\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statisk PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom3.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Anpassade objekt\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_new = Egen_ny,\n"
"    .tp_init = Anpassad_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_members = Anpassad_members,\n"
"    .tp_methods = Egna_metoder,\n"
"    .tp_getset = Egna_getsetters,\n"
"};\n"
"\n"
"statisk int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        returnera -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"statisk PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"anpassad3\",\n"
"    .m_doc = \"Exempelmodul som skapar en tilläggstyp.\",\n"
"    .m_size = 0,\n"
"    .m_slots = anpassade_modul_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom3(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

msgid ""
"To provide greater control, over the :attr:`!first` and :attr:`!last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`!first` attribute::"
msgstr ""
"För att ge större kontroll över attributen :attr:`!first` och :attr:`!last` "
"använder vi anpassade getter- och setter-funktioner.  Här är funktionerna "
"för att hämta och ställa in attributet :attr:`!first`::"

msgid ""
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_INCREF(self->first);\n"
"    return self->first;\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    PyObject *tmp;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    tmp = self->first;\n"
"    Py_INCREF(value);\n"
"    self->first = value;\n"
"    Py_DECREF(tmp);\n"
"    return 0;\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_INCREF(self->first);\n"
"    return self->first;\n"
"}\n"
"\n"
"statisk int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    PyObject *tmp;\n"
"    if (värde == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Det går inte att ta bort det "
"första attributet\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"Det första attributvärdet måste vara en "
"sträng\");\n"
"        return -1;\n"
"    }\n"
"    tmp = själv>första;\n"
"    Py_INCREF(värde);\n"
"    self->first = värde;\n"
"    Py_DECREF(tmp);\n"
"    return 0;\n"
"}"

msgid ""
"The getter function is passed a :class:`!Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the "
"getter and setter. This could, for example, be used to allow a single set of "
"getter and setter functions that decide the attribute to get or set based on "
"data in the closure.)"
msgstr ""
"Getter-funktionen får ett :class:`!Custom`-objekt och en \"closure\", som är "
"en void-pekare.  I det här fallet ignoreras closure.  (Closure stöder en "
"avancerad användning där definitionsdata skickas till getter- och "
"setterfunktionerna. Detta kan t.ex. användas för att tillåta en enda "
"uppsättning getter- och setterfunktioner som bestämmer vilket attribut som "
"ska hämtas eller sättas baserat på data i closure)"

msgid ""
"The setter function is passed the :class:`!Custom` object, the new value, "
"and the closure.  The new value may be ``NULL``, in which case the attribute "
"is being deleted.  In our setter, we raise an error if the attribute is "
"deleted or if its new value is not a string."
msgstr ""
"Setter-funktionen får :class:`!Custom`-objektet, det nya värdet och "
"avslutningen.  Det nya värdet kan vara ``NULL``, i vilket fall attributet "
"tas bort.  I vår setter ger vi ett felmeddelande om attributet raderas eller "
"om det nya värdet inte är en sträng."

msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "Vi skapar en array av :c:type:`PyGetSetDef`-strukturer::"

msgid ""
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"statisk PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"förnamn\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"efternamn\", NULL},\n"
"    {NULL} /* Sentinel */\n"
"};"

msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "och registrera den i :c:member:`~PyTypeObject.tp_getset` slot::"

msgid ".tp_getset = Custom_getsetters,"
msgstr ".tp_getset = Anpassade_getsetters,"

msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"``NULL``."
msgstr ""
"Det sista objektet i en :c:type:`PyGetSetDef`-struktur är den \"closure\" "
"som nämns ovan.  I det här fallet använder vi inte en closure, så vi skickar "
"bara ``NULL``."

msgid "We also remove the member definitions for these attributes::"
msgstr "Vi tar också bort medlemsdefinitionerna för dessa attribut::"

msgid ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"anpassat nummer\"},\n"
"    {NULL} /* Sentinel */\n"
"};"

msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr ""
"Vi måste också uppdatera :c:member:`~PyTypeObject.tp_init`-handlaren så att "
"den bara tillåter strängar [#]_ att skickas::"

msgid ""
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        tmp = self->first;\n"
"        Py_INCREF(first);\n"
"        self->first = first;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    if (last) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(last);\n"
"        self->last = last;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL, *tmp;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &själv->nummer))\n"
"        return -1;\n"
"\n"
"    if (första) {\n"
"        tmp = själv>första;\n"
"        Py_INCREF(första);\n"
"        själv>första = första;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    if (sista) {\n"
"        tmp = self->last;\n"
"        Py_INCREF(sista);\n"
"        self->last = last;\n"
"        Py_DECREF(tmp);\n"
"    }\n"
"    return 0;\n"
"}"

msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never ``NULL`` so we can remove checks for ``NULL`` values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"Med dessa ändringar kan vi försäkra oss om att medlemmarna ``first`` och "
"``last`` aldrig är ``NULL`` så vi kan ta bort kontroller för ``NULL``-värden "
"i nästan alla fall. Detta innebär att de flesta :c:func:`Py_XDECREF`-anrop "
"kan konverteras till :c:func:`Py_DECREF`-anrop.  Det enda stället där vi "
"inte kan ändra dessa anrop är i implementationen av ``tp_dealloc``, där det "
"finns en möjlighet att initialiseringen av dessa medlemmar misslyckades i "
"``tp_new``."

msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr ""
"Vi byter också namn på modulinitialiseringsfunktionen och modulnamnet i "
"initialiseringsfunktionen, som vi gjorde tidigare, och vi lägger till en "
"extra definition i filen :file:`setup.py`."

msgid "Supporting cyclic garbage collection"
msgstr "Stöd för cyklisk skräpinsamling"

msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that "
"can identify unneeded objects even when their reference counts are not zero. "
"This can happen when objects are involved in cycles.  For example, consider:"
msgstr ""
"Python har en :term:``cyklisk garbage collector (GC) <garbage collection>`` "
"som kan identifiera onödiga objekt även när deras referensantal inte är "
"noll. Detta kan hända när objekt är involverade i cykler.  Tänk till exempel "
"på:"

msgid ""
">>> l = []\n"
">>> l.append(l)\n"
">>> del l"
msgstr ""
">>> l = []\n"
">>> l.lägg till(l)\n"
">>> del l"

msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""
"I det här exemplet skapar vi en lista som innehåller sig själv. När vi tar "
"bort den har den fortfarande en referens från sig själv. Dess referensantal "
"sjunker inte till noll. Lyckligtvis kommer Pythons cykliska skräpsamlare så "
"småningom att räkna ut att listan är skräp och frigöra den."

msgid ""
"In the second version of the :class:`!Custom` example, we allowed any kind "
"of object to be stored in the :attr:`!first` or :attr:`!last` attributes "
"[#]_. Besides, in the second and third versions, we allowed subclassing :"
"class:`!Custom`, and subclasses may add arbitrary attributes.  For any of "
"those two reasons, :class:`!Custom` objects can participate in cycles:"
msgstr ""
"I den andra versionen av exemplet :class:`!Custom` tillät vi att alla typer "
"av objekt lagrades i attributen :attr:`!first` eller :attr:`!last` [#]_. "
"Dessutom, i den andra och tredje versionen, tillät vi underklassning av :"
"class:`!Custom`, och underklasser kan lägga till godtyckliga attribut.  Av "
"någon av dessa två anledningar kan :class:`!Custom`-objekt delta i cykler:"

msgid ""
">>> import custom3\n"
">>> class Derived(custom3.Custom): pass\n"
"...\n"
">>> n = Derived()\n"
">>> n.some_attribute = n"
msgstr ""
">>> import custom3\n"
">>> class Avledda(custom3.Custom): pass\n"
"...\n"
">>> n = Avledd()\n"
">>> n.some_attribute = n"

msgid ""
"To allow a :class:`!Custom` instance participating in a reference cycle to "
"be properly detected and collected by the cyclic GC, our :class:`!Custom` "
"type needs to fill two additional slots and to enable a flag that enables "
"these slots:"
msgstr ""
"För att en :class:`!Custom`-instans som deltar i en referenscykel ska kunna "
"upptäckas och samlas in på rätt sätt av den cykliska GC:n, måste vår :class:"
"`!Custom`-typ fylla två ytterligare slots och aktivera en flagga som "
"aktiverar dessa slots:"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"#include <stddef.h> /* for offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_HEAD\n"
"    PyObject *first; /* first name */\n"
"    PyObject *last;  /* last name */\n"
"    int number;\n"
"} CustomObject;\n"
"\n"
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            return NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"static int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &self->number))\n"
"        return -1;\n"
"\n"
"    if (first) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"custom number\"},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"static int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the first "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The first attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"static int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (value == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Cannot delete the last "
"attribute\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"The last attribute value must be a string\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"first name\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"last name\", NULL},\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Custom_name, METH_NOARGS,\n"
"     \"Return the name, combining the first and last name\"\n"
"    },\n"
"    {NULL}  /* Sentinel */\n"
"};\n"
"\n"
"static PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom4.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Custom objects\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | "
"Py_TPFLAGS_HAVE_GC,\n"
"    .tp_new = Custom_new,\n"
"    .tp_init = Custom_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_traverse = Custom_traverse,\n"
"    .tp_clear = Custom_clear,\n"
"    .tp_members = Custom_members,\n"
"    .tp_methods = Custom_methods,\n"
"    .tp_getset = Custom_getsetters,\n"
"};\n"
"\n"
"static int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"custom4\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = custom_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom4(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#include <Python.h> #include <stddef.h> /* för offsetof()\n"
"#include <stddef.h> /* för offsetof() */\n"
"\n"
"typedef struct {\n"
"    PyObject_Huvud\n"
"    PyObject *first; /* förnamn */\n"
"    PyObject *last; /* efternamn */\n"
"    int nummer;\n"
"} CustomObject;\n"
"\n"
"statisk int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(själv>första);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"statisk int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(själv>första);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}\n"
"\n"
"statiskt void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}\n"
"\n"
"statisk PyObject* Custom_new(PyTypeObject\n"
"Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self;\n"
"    self = (CustomObject *) type->tp_alloc(type, 0);\n"
"    if (self != NULL) {\n"
"        self->first = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->first == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->last = Py_GetConstant(Py_CONSTANT_EMPTY_STR);\n"
"        if (self->last == NULL) {\n"
"            Py_DECREF(self);\n"
"            returnera NULL;\n"
"        }\n"
"        self->number = 0;\n"
"    }\n"
"    return (PyObject *) self;\n"
"}\n"
"\n"
"statisk int\n"
"Custom_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    static char *kwlist[] = {\"first\", \"last\", \"number\", NULL};\n"
"    PyObject *first = NULL, *last = NULL;\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|UUUi\", kwlist,\n"
"                                     &first, &last,\n"
"                                     &själv->nummer))\n"
"        return -1;\n"
"\n"
"    if (första) {\n"
"        Py_SETREF(self->first, Py_NewRef(first));\n"
"    }\n"
"    if (last) {\n"
"        Py_SETREF(self->last, Py_NewRef(last));\n"
"    }\n"
"    return 0;\n"
"}\n"
"\n"
"static PyMemberDef Custom_members[] = {\n"
"    {\"number\", Py_T_INT, offsetof(CustomObject, number), 0,\n"
"     \"anpassat nummer\"},\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statiskt PyObject *\n"
"Custom_getfirst(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->first);\n"
"}\n"
"\n"
"statisk int\n"
"Custom_setfirst(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (värde == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Det går inte att ta bort det "
"första attributet\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"Det första attributvärdet måste vara en "
"sträng\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->first, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"statiskt PyObject *\n"
"Custom_getlast(PyObject *op, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return Py_NewRef(self->last);\n"
"}\n"
"\n"
"statisk int\n"
"Custom_setlast(PyObject *op, PyObject *value, void *closure)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    if (värde == NULL) {\n"
"        PyErr_SetString(PyExc_TypeError, \"Det går inte att ta bort det "
"sista attributet\");\n"
"        return -1;\n"
"    }\n"
"    if (!PyUnicode_Check(value)) {\n"
"        PyErr_SetString(PyExc_TypeError,\n"
"                        \"Det sista attributvärdet måste vara en sträng\");\n"
"        return -1;\n"
"    }\n"
"    Py_XSETREF(self->last, Py_NewRef(value));\n"
"    return 0;\n"
"}\n"
"\n"
"static PyGetSetDef Custom_getsetters[] = {\n"
"    {\"first\", Custom_getfirst, Custom_setfirst,\n"
"     \"förnamn\", NULL},\n"
"    {\"last\", Custom_getlast, Custom_setlast,\n"
"     \"efternamn\", NULL},\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statiskt PyObject *\n"
"Custom_name(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    return PyUnicode_FromFormat(\"%S %S\", self->first, self->last);\n"
"}\n"
"\n"
"static PyMethodDef Custom_methods[] = {\n"
"    {\"name\", Eget_namn, METH_NOARGS,\n"
"     \"Returnera namnet genom att kombinera för- och efternamn\"\n"
"    },\n"
"    {NULL} /* Sentinel */\n"
"};\n"
"\n"
"statisk PyTypeObject CustomType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"custom4.Custom\",\n"
"    .tp_doc = PyDoc_STR(\"Anpassade objekt\"),\n"
"    .tp_basicsize = sizeof(CustomObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | "
"Py_TPFLAGS_HAVE_GC,\n"
"    .tp_new = Anpassad_ny,\n"
"    .tp_init = Anpassad_init,\n"
"    .tp_dealloc = Custom_dealloc,\n"
"    .tp_traverse = Egen_traverse,\n"
"    .tp_clear = Egen_clear,\n"
"    .tp_members = Anpassad_members,\n"
"    .tp_methods = Egna_metoder,\n"
"    .tp_getset = Egna_getsetters,\n"
"};\n"
"\n"
"statisk int\n"
"custom_module_exec(PyObject *m)\n"
"{\n"
"    if (PyType_Ready(&CustomType) < 0) {\n"
"        returnera -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"Custom\", (PyObject *) &CustomType) < 0) "
"{\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot custom_module_slots[] = {\n"
"    {Py_mod_exec, custom_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"statisk PyModuleDef custom_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"anpassad4\",\n"
"    .m_doc = \"Exempelmodul som skapar en tilläggstyp.\",\n"
"    .m_size = 0,\n"
"    .m_slots = anpassade_modul_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_custom4(void)\n"
"{\n"
"    return PyModuleDef_Init(&custom_module);\n"
"}\n"

msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr ""
"För det första låter traversalmetoden den cykliska GC:n veta om underobjekt "
"som kan delta i cykler::"

msgid ""
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    int vret;\n"
"    if (self->first) {\n"
"        vret = visit(self->first, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    if (self->last) {\n"
"        vret = visit(self->last, arg);\n"
"        if (vret != 0)\n"
"            return vret;\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    int vret;\n"
"    if (själv>första) {\n"
"        vret = visit(self->first, arg);\n"
"        if (vret != 0)\n"
"            returnera vret;\n"
"    }\n"
"    if (själv>sist) {\n"
"        vret = besök(själv>sist, arg);\n"
"        om (vret != 0)\n"
"            returnera vret;\n"
"    }\n"
"    return 0;\n"
"}"

msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`!visit` function, which is passed to the traversal method. The :c:func:"
"`!visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""
"För varje subobjekt som kan delta i cykler måste vi anropa funktionen :c:"
"func:`!visit`, som skickas till traversalmetoden. Funktionen :c:func:`!"
"visit` tar som argument subobjektet och det extra argumentet *arg* som "
"skickas till traversalmetoden.  Den returnerar ett heltalsvärde som måste "
"returneras om det inte är noll."

msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""
"Python tillhandahåller ett :c:func:`Py_VISIT`-makro som automatiserar anrop "
"av visitfunktioner.  Med :c:func:`Py_VISIT` kan vi minimera mängden "
"boilerplate i ``Custom_traverse``::"

msgid ""
"static int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(self->first);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"Custom_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_VISIT(själv>första);\n"
"    Py_VISIT(self->last);\n"
"    return 0;\n"
"}"

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""
"Implementationen :c:member:`~PyTypeObject.tp_traverse` måste namnge sina "
"argument exakt *visit* och *arg* för att kunna använda :c:func:`Py_VISIT`."

msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr ""
"För det andra måste vi tillhandahålla en metod för att rensa alla "
"underobjekt som kan delta i cycles::"

msgid ""
"static int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(self->first);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"Custom_clear(PyObject *op)\n"
"{\n"
"    CustomObject *self = (CustomObject *) op;\n"
"    Py_CLEAR(själv>första);\n"
"    Py_CLEAR(self->last);\n"
"    return 0;\n"
"}"

msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on "
"the attribute before setting it to ``NULL``, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""
"Lägg märke till användningen av makrot :c:func:`Py_CLEAR`.  Det är det "
"rekommenderade och säkra sättet att rensa dataattribut av godtyckliga typer "
"samtidigt som deras referensantal dekrementeras.  Om du istället skulle "
"anropa :c:func:`Py_XDECREF` på attributet innan du sätter det till ``NULL``, "
"finns det en möjlighet att attributets destruktor skulle anropa tillbaka "
"till kod som läser attributet igen (*särskilt* om det finns en "
"referenscykel)."

msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr "Du kan emulera :c:func:`Py_CLEAR` genom att skriva::"

msgid ""
"PyObject *tmp;\n"
"tmp = self->first;\n"
"self->first = NULL;\n"
"Py_XDECREF(tmp);"
msgstr ""
"PyObject *tmp;\n"
"tmp = själv>första;\n"
"self->first = NULL;\n"
"Py_XDECREF(tmp);"

msgid ""
"Nevertheless, it is much easier and less error-prone to always use :c:func:"
"`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize at the "
"expense of robustness!"
msgstr ""
"Det är dock mycket enklare och mindre felbenäget att alltid använda :c:func:"
"`Py_CLEAR` när man tar bort ett attribut.  Försök inte mikrooptimera på "
"bekostnad av robusthet!"

msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using :c:func:"
"`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""
"Deallokatorn ``Custom_dealloc`` kan anropa godtycklig kod när attribut "
"rensas.  Det betyder att den cirkulära GC kan utlösas inuti funktionen. "
"Eftersom GC antar att referensantalet inte är noll måste vi spåra objektet "
"från GC genom att anropa :c:func:`PyObject_GC_UnTrack` innan vi rensar "
"medlemmar. Här är vår reimplementerade deallocator som använder :c:func:"
"`PyObject_GC_UnTrack` och ``Custom_clear``::"

msgid ""
"static void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}"
msgstr ""
"statiskt void\n"
"Custom_dealloc(PyObject *op)\n"
"{\n"
"    PyObject_GC_UnTrack(op);\n"
"    (void)Custom_clear(op);\n"
"    Py_TYPE(op)->tp_free(op);\n"
"}"

msgid ""
"Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""
"Slutligen lägger vi till flaggan :c:macro:`Py_TPFLAGS_HAVE_GC` i klassen "
"flags::"

msgid ""
".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,"
msgstr ""
".tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,"

msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify "
"them for cyclic garbage collection.  Most extensions will use the versions "
"automatically provided."
msgstr ""
"Det är i stort sett allt.  Om vi hade skrivit egna :c:member:`~PyTypeObject."
"tp_alloc`- eller :c:member:`~PyTypeObject.tp_free`-hanterare, skulle vi "
"behöva modifiera dem för cyklisk skräpinsamling.  De flesta tillägg kommer "
"att använda de versioner som automatiskt tillhandahålls."

msgid "Subclassing other types"
msgstr "Underklassificering av andra typer"

msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""
"Det är möjligt att skapa nya tilläggstyper som härrör från befintliga typer. "
"Det är lättast att ärva från de inbyggda typerna, eftersom ett tillägg "
"enkelt kan använda de :c:type:`PyTypeObject` som det behöver. Det kan vara "
"svårt att dela dessa :c:type:`PyTypeObject`-strukturer mellan "
"tilläggsmoduler."

msgid ""
"In this example we will create a :class:`!SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`!increment` method "
"that increases an internal counter:"
msgstr ""
"I det här exemplet skapar vi en :class:`!SubList`-typ som ärver från den "
"inbyggda :class:`list`-typen. Den nya typen kommer att vara helt kompatibel "
"med vanliga listor, men kommer att ha en ytterligare :meth:`!increment`-"
"metod som ökar en intern räknare:"

msgid ""
">>> import sublist\n"
">>> s = sublist.SubList(range(3))\n"
">>> s.extend(s)\n"
">>> print(len(s))\n"
"6\n"
">>> print(s.increment())\n"
"1\n"
">>> print(s.increment())\n"
"2"
msgstr ""
">>> import sublist\n"
">>> s = sublist.SubList(range(3))\n"
">>> s.extend(s)\n"
">>> print(len(s))\n"
"6\n"
">>> print(s.increment())\n"
"1\n"
">>> print(s.increment())\n"
"2"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;\n"
"\n"
"static PyObject *\n"
"SubList_increment(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    self->state++;\n"
"    return PyLong_FromLong(self->state);\n"
"}\n"
"\n"
"static PyMethodDef SubList_methods[] = {\n"
"    {\"increment\", SubList_increment, METH_NOARGS,\n"
"     PyDoc_STR(\"increment state counter\")},\n"
"    {NULL},\n"
"};\n"
"\n"
"static int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}\n"
"\n"
"static PyTypeObject SubListType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"sublist.SubList\",\n"
"    .tp_doc = PyDoc_STR(\"SubList objects\"),\n"
"    .tp_basicsize = sizeof(SubListObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_init = SubList_init,\n"
"    .tp_methods = SubList_methods,\n"
"};\n"
"\n"
"static int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot sublist_module_slots[] = {\n"
"    {Py_mod_exec, sublist_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static PyModuleDef sublist_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"sublist\",\n"
"    .m_doc = \"Example module that creates an extension type.\",\n"
"    .m_size = 0,\n"
"    .m_slots = sublist_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    return PyModuleDef_Init(&sublist_module);\n"
"}\n"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#inkludera <Python.h>\n"
"\n"
"typedef struct {\n"
"    PyListObject-lista;\n"
"    int tillstånd;\n"
"} SubListObject;\n"
"\n"
"statiskt PyObject *\n"
"SubList_increment(PyObject *op, PyObject *Py_UNUSED(dummy))\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    self->state++;\n"
"    return PyLong_FromLong(self->state);\n"
"}\n"
"\n"
"static PyMethodDef SubList_methods[] = {\n"
"    {\"increment\", SubList_increment, METH_NOARGS,\n"
"     PyDoc_STR(\"inkrementera tillståndsräknare\")},\n"
"    {NULL},\n"
"};\n"
"\n"
"statisk int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}\n"
"\n"
"statiskt PyTypeObject SubListType = {\n"
"    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"sublist.SubList\",\n"
"    .tp_doc = PyDoc_STR(\"SubList-objekt\"),\n"
"    .tp_basicsize = sizeof(SubListObject),\n"
"    .tp_itemsize = 0,\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
"    .tp_init = SubList_init,\n"
"    .tp_methods = SubList_methods,\n"
"};\n"
"\n"
"statisk int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot sublist_module_slots[] = {\n"
"    {Py_mod_exec, sublist_module_exec},\n"
"    {Py_mod_multiple_interpreters, "
"Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"statisk PyModuleDef sublist_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"sublist\",\n"
"    .m_doc = \"Exempelmodul som skapar en tilläggstyp.\",\n"
"    .m_size = 0,\n"
"    .m_slots = sublist_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_sublist(void)\n"
"{\n"
"    return PyModuleDef_Init(&sublist_module);\n"
"}\n"

msgid ""
"As you can see, the source code closely resembles the :class:`!Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""
"Som du kan se är källkoden mycket lik :class:`!Custom`-exemplen i tidigare "
"avsnitt. Vi kommer att bryta ner de viktigaste skillnaderna mellan dem. ::"

msgid ""
"typedef struct {\n"
"    PyListObject list;\n"
"    int state;\n"
"} SubListObject;"
msgstr ""
"typedef struct {\n"
"    PyListObject lista;\n"
"    int tillstånd;\n"
"} SubListObject;"

msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""
"Den primära skillnaden för objekt av härledd typ är att objektstrukturen för "
"bastypen måste vara det första värdet.  Bastypen kommer redan att innehålla :"
"c:func:`PyObject_HEAD` i början av sin struktur."

msgid ""
"When a Python object is a :class:`!SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""
"När ett Python-objekt är en :class:`!SubList`-instans, kan dess ``PyObject "
"*``-pekare säkert kastas till både ``PyListObject *`` och ``SubListObject "
"*``::"

msgid ""
"static int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"SubList_init(PyObject *op, PyObject *args, PyObject *kwds)\n"
"{\n"
"    SubListObject *self = (SubListObject *) op;\n"
"    if (PyList_Type.tp_init(op, args, kwds) < 0)\n"
"        return -1;\n"
"    self->state = 0;\n"
"    return 0;\n"
"}"

msgid ""
"We see above how to call through to the :meth:`~object.__init__` method of "
"the base type."
msgstr ""
"Vi ser ovan hur man anropar till :meth:`~object.__init__`-metoden för "
"bastypen."

msgid ""
"This pattern is important when writing a type with custom :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` members.  "
"The :c:member:`~PyTypeObject.tp_new` handler should not actually create the "
"memory for the object with its :c:member:`~PyTypeObject.tp_alloc`, but let "
"the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"Detta mönster är viktigt när man skriver en typ med anpassade :c:member:"
"`~PyTypeObject.tp_new` och :c:member:`~PyTypeObject.tp_dealloc`-medlemmar.  "
"Hanteraren :c:member:`~PyTypeObject.tp_new` ska inte skapa minnet för "
"objektet med sin :c:member:`~PyTypeObject.tp_alloc`, utan låta basklassen "
"hantera det genom att anropa sin egen :c:member:`~PyTypeObject.tp_new`."

msgid ""
"The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject."
"tp_base` specifying the type's concrete base class.  Due to cross-platform "
"compiler issues, you can't fill that field directly with a reference to :c:"
"type:`PyList_Type`; it should be done in the :c:data:`Py_mod_exec` function::"
msgstr ""
"Strukturen :c:type:`PyTypeObject` stöder en :c:member:`~PyTypeObject."
"tp_base` som anger typens konkreta basklass.  På grund av kompilatorproblem "
"mellan plattformar kan du inte fylla i det fältet direkt med en referens "
"till :c:type:`PyList_Type`; det bör göras i funktionen :c:data:"
"`Py_mod_exec`::"

msgid ""
"static int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"sublist_module_exec(PyObject *m)\n"
"{\n"
"    SubListType.tp_base = &PyList_Type;\n"
"    if (PyType_Ready(&SubListType) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    if (PyModule_AddObjectRef(m, \"SubList\", (PyObject *) &SubListType) < "
"0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the :c:member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- the allocation function "
"from the base type will be inherited."
msgstr ""
"Innan :c:func:`PyType_Ready` anropas måste typstrukturen ha :c:member:"
"`~PyTypeObject.tp_base` slot ifylld.  När vi härleder en befintlig typ är "
"det inte nödvändigt att fylla i :c:member:`~PyTypeObject.tp_alloc` med :c:"
"func:`PyType_GenericNew` -- allokeringsfunktionen från bastypen kommer att "
"ärvas."

msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`!Custom` examples."
msgstr ""
"Därefter anropas :c:func:`PyType_Ready` och typobjektet läggs till i modulen "
"på samma sätt som i de grundläggande :class:`!Custom`-exemplen."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr ""
"Detta är sant när vi vet att objektet är en grundläggande typ, som en sträng "
"eller en float."

msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""
"Vi förlitade oss på detta i :c:member:`~PyTypeObject.tp_dealloc`-hanteraren "
"i det här exemplet, eftersom vår typ inte stöder garbage collection."

msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""
"Vi vet nu att den första och den sista medlemmen är strängar, så vi kanske "
"kan vara mindre försiktiga med att minska deras referensantal, men vi "
"accepterar instanser av strängunderklasser.  Även om deallokering av normala "
"strängar inte kommer att ringa tillbaka till våra objekt, kan vi inte "
"garantera att deallokering av en instans av en strängunderklass inte kommer "
"att anropa tillbaka till våra objekt."

msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
"Även med våra attribut begränsade till stränginstanser kan användaren skicka "
"godtyckliga :class:`str`-subklasser och därför fortfarande skapa "
"referenscykler."
