# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!struct` --- Interpret bytes as packed binary data"
msgstr ":mod:`!struct` --- Tolka byte som packad binärdata"

msgid "**Source code:** :source:`Lib/struct.py`"
msgstr "**Källkod:** :source:`Lib/struct.py`"

msgid ""
"This module converts between Python values and C structs represented as "
"Python :class:`bytes` objects.  Compact :ref:`format strings <struct-format-"
"strings>` describe the intended conversions to/from Python values. The "
"module's functions and objects can be used for two largely distinct "
"applications, data exchange with external sources (files or network "
"connections), or data transfer between the Python application and the C "
"layer."
msgstr ""
"Denna modul konverterar mellan Python-värden och C-strukturer representerade "
"som Python :class:`bytes`-objekt.  Kompakta :ref:`formatsträngar <struct-"
"format-strings>` beskriver de avsedda konverteringarna till/från Python-"
"värden. Modulens funktioner och objekt kan användas för två vitt skilda "
"tillämpningar, datautbyte med externa källor (filer eller "
"nätverksanslutningar) eller dataöverföring mellan Python-applikationen och C-"
"lagret."

msgid ""
"When no prefix character is given, native mode is the default. It packs or "
"unpacks data based on the platform and compiler on which the Python "
"interpreter was built. The result of packing a given C struct includes pad "
"bytes which maintain proper alignment for the C types involved; similarly, "
"alignment is taken into account when unpacking.  In contrast, when "
"communicating data between external sources, the programmer is responsible "
"for defining byte ordering and padding between elements. See :ref:`struct-"
"alignment` for details."
msgstr ""
"När inget prefixtecken anges är native-läge standard. Det packar eller "
"packar upp data baserat på den plattform och kompilator som Python-tolken "
"byggdes på. Resultatet av att packa en given C-struktur inkluderar padbytes "
"som upprätthåller korrekt inriktning för de involverade C-typerna; på samma "
"sätt beaktas inriktningen vid uppackning.  När data kommuniceras mellan "
"externa källor är det däremot programmeraren som ansvarar för att definiera "
"byteordning och utfyllnad mellan element. Se :ref:`struct-alignment` för mer "
"information."

msgid ""
"Several :mod:`struct` functions (and methods of :class:`Struct`) take a "
"*buffer* argument.  This refers to objects that implement the :ref:"
"`bufferobjects` and provide either a readable or read-writable buffer.  The "
"most common types used for that purpose are :class:`bytes` and :class:"
"`bytearray`, but many other types that can be viewed as an array of bytes "
"implement the buffer protocol, so that they can be read/filled without "
"additional copying from a :class:`bytes` object."
msgstr ""
"Flera :mod:`struct`-funktioner (och metoder i :class:`Struct`) tar ett "
"*buffer*-argument.  Detta hänvisar till objekt som implementerar :ref:"
"`bufferobjects` och tillhandahåller antingen en läsbar eller en skrivbar "
"buffert.  De vanligaste typerna som används för detta ändamål är :class:"
"`bytes` och :class:`bytearray`, men många andra typer som kan ses som en "
"array av bytes implementerar buffertprotokollet, så att de kan läsas/fyllas "
"utan ytterligare kopiering från ett :class:`bytes`-objekt."

msgid "Functions and Exceptions"
msgstr "Funktioner och undantag"

msgid "The module defines the following exception and functions:"
msgstr "Modulen definierar följande undantag och funktioner:"

msgid ""
"Exception raised on various occasions; argument is a string describing what "
"is wrong."
msgstr ""
"Undantag som tas upp vid olika tillfällen; argumentet är en sträng som "
"beskriver vad som är fel."

msgid ""
"Return a bytes object containing the values *v1*, *v2*, ... packed according "
"to the format string *format*.  The arguments must match the values required "
"by the format exactly."
msgstr ""
"Returnerar ett bytesobjekt som innehåller värdena *v1*, *v2*, ... packade "
"enligt formatsträngen *format*.  Argumenten måste exakt matcha de värden som "
"krävs av formatet."

msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *format* and "
"write the packed bytes into the writable buffer *buffer* starting at "
"position *offset*.  Note that *offset* is a required argument."
msgstr ""
"Packa värdena *v1*, *v2*, ... enligt formatsträngen *format* och skriv de "
"packade bytena till den skrivbara bufferten *buffer* med start vid position "
"*offset*.  Observera att *offset* är ett obligatoriskt argument."

msgid ""
"Unpack from the buffer *buffer* (presumably packed by ``pack(format, ...)``) "
"according to the format string *format*.  The result is a tuple even if it "
"contains exactly one item.  The buffer's size in bytes must match the size "
"required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Packar upp från bufferten *buffer* (förmodligen packad med "
"``pack(format, ...)``) enligt formatsträngen *format*.  Resultatet är en "
"tupel även om den innehåller exakt ett objekt.  Buffertens storlek i bytes "
"måste matcha den storlek som krävs av formatet, vilket återspeglas av :func:"
"`calcsize`."

msgid ""
"Unpack from *buffer* starting at position *offset*, according to the format "
"string *format*.  The result is a tuple even if it contains exactly one "
"item.  The buffer's size in bytes, starting at position *offset*, must be at "
"least the size required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Packar upp från *buffer* med start vid position *offset*, enligt "
"formatsträngen *format*.  Resultatet är en tupel även om den innehåller "
"exakt ett objekt.  Buffertens storlek i byte, med start vid position "
"*offset*, måste vara minst den storlek som krävs av formatet, vilket "
"återspeglas av :func:`calcsize`."

msgid ""
"Iteratively unpack from the buffer *buffer* according to the format string "
"*format*.  This function returns an iterator which will read equally sized "
"chunks from the buffer until all its contents have been consumed.  The "
"buffer's size in bytes must be a multiple of the size required by the "
"format, as reflected by :func:`calcsize`."
msgstr ""
"Iterativ uppackning från bufferten *buffer* enligt formatsträngen *format*.  "
"Denna funktion returnerar en iterator som läser lika stora bitar från "
"bufferten tills allt dess innehåll har förbrukats.  Buffertens storlek i "
"bytes måste vara en multipel av den storlek som krävs av formatet, vilket "
"återspeglas av :func:`calcsize`."

msgid "Each iteration yields a tuple as specified by the format string."
msgstr "Varje iteration ger en tupel som specificeras av formatsträngen."

msgid ""
"Return the size of the struct (and hence of the bytes object produced by "
"``pack(format, ...)``) corresponding to the format string *format*."
msgstr ""
"Returnerar storleken på struct (och därmed bytesobjektet som produceras av "
"``pack(format, ...)``) som motsvarar formatsträngen *format*."

msgid "Format Strings"
msgstr "Format Strängar"

msgid ""
"Format strings describe the data layout when packing and unpacking data.  "
"They are built up from :ref:`format characters<format-characters>`, which "
"specify the type of data being packed/unpacked.  In addition, special "
"characters control the :ref:`byte order, size and alignment<struct-"
"alignment>`. Each format string consists of an optional prefix character "
"which describes the overall properties of the data and one or more format "
"characters which describe the actual data values and padding."
msgstr ""
"Formatsträngar beskriver datalayouten vid packning och uppackning av data.  "
"De är uppbyggda av :ref:`formattecken<format-characters>`, som anger vilken "
"typ av data som ska packas/packas upp.  Dessutom styr specialtecken :ref:"
"`byteordning, storlek och inriktning<struct-alignment>`. Varje formatsträng "
"består av ett valfritt prefixtecken som beskriver de övergripande "
"egenskaperna hos data och ett eller flera formattecken som beskriver de "
"faktiska datavärdena och utfyllnaden."

msgid "Byte Order, Size, and Alignment"
msgstr "Byteordning, storlek och inriktning"

msgid ""
"By default, C types are represented in the machine's native format and byte "
"order, and properly aligned by skipping pad bytes if necessary (according to "
"the rules used by the C compiler). This behavior is chosen so that the bytes "
"of a packed struct correspond exactly to the memory layout of the "
"corresponding C struct. Whether to use native byte ordering and padding or "
"standard formats depends on the application."
msgstr ""
"Som standard representeras C-typer i maskinens ursprungliga format och "
"byteordning, och justeras korrekt genom att hoppa över padbytes om det "
"behövs (enligt de regler som används av C-kompilatorn). Detta beteende är "
"valt så att bytena i en packad struktur exakt motsvarar minneslayouten för "
"motsvarande C-struktur. Huruvida man ska använda inbyggd byteordning och "
"padding eller standardformat beror på applikationen."

msgid ""
"Alternatively, the first character of the format string can be used to "
"indicate the byte order, size and alignment of the packed data, according to "
"the following table:"
msgstr ""
"Alternativt kan det första tecknet i formatsträngen användas för att ange "
"byteordning, storlek och justering av de paketerade data, enligt följande "
"tabell:"

msgid "Character"
msgstr "Tecken"

msgid "Byte order"
msgstr "Byte-ordning"

msgid "Size"
msgstr "Storlek"

msgid "Alignment"
msgstr "Justering"

msgid "``@``"
msgstr "``@``"

msgid "native"
msgstr "infödd"

msgid "``=``"
msgstr "``=``"

msgid "standard"
msgstr "standard"

msgid "none"
msgstr "ingen"

msgid "``<``"
msgstr "``<``"

msgid "little-endian"
msgstr "liten-endian"

msgid "``>``"
msgstr "``>``"

msgid "big-endian"
msgstr "stor-endian"

msgid "``!``"
msgstr "``!``"

msgid "network (= big-endian)"
msgstr "nätverk (= big-endian)"

msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr "Om det första tecknet inte är något av dessa, antas ``'@'``."

msgid ""
"The number 1023 (``0x3ff`` in hexadecimal) has the following byte "
"representations:"
msgstr ""
"Siffran 1023 (``0x3ff`` i hexadecimal) har följande byte representationer:"

msgid "``03 ff`` in big-endian (``>``)"
msgstr "``03 ff`` i big-endian (``>``)"

msgid "``ff 03`` in little-endian (``<``)"
msgstr "``ff 03`` i little-endian (``<``)"

msgid "Python example:"
msgstr "Python exempel:"

msgid ""
"Native byte order is big-endian or little-endian, depending on the host "
"system. For example, Intel x86, AMD64 (x86-64), and Apple M1 are little-"
"endian; IBM z and many legacy architectures are big-endian. Use :data:`sys."
"byteorder` to check the endianness of your system."
msgstr ""
"Den inbyggda byteordningen är big-endian eller little-endian, beroende på "
"värdsystemet. Till exempel är Intel x86, AMD64 (x86-64) och Apple M1 little-"
"endian, medan IBM z och många äldre arkitekturer är big-endian. Använd :data:"
"`sys.byteorder` för att kontrollera om ditt system är endianskt."

msgid ""
"Native size and alignment are determined using the C compiler's ``sizeof`` "
"expression.  This is always combined with native byte order."
msgstr ""
"Ursprunglig storlek och inriktning bestäms med hjälp av C-kompilatorns "
"``sizeof``-uttryck.  Detta kombineras alltid med inbyggd byteordning."

msgid ""
"Standard size depends only on the format character;  see the table in the :"
"ref:`format-characters` section."
msgstr ""
"Standardstorleken beror endast på formattecknet; se tabellen i avsnittet :"
"ref:`format-characters`."

msgid ""
"Note the difference between ``'@'`` and ``'='``: both use native byte order, "
"but the size and alignment of the latter is standardized."
msgstr ""
"Observera skillnaden mellan ``'@'`` och ``'='``: båda använder inbyggd "
"byteordning, men storleken och inriktningen för den senare är standardiserad."

msgid ""
"The form ``'!'`` represents the network byte order which is always big-"
"endian as defined in `IETF RFC 1700 <IETF RFC 1700_>`_."
msgstr ""
"Formen ``'!'`` representerar nätverkets byteordning som alltid är big-endian "
"enligt definitionen i `IETF RFC 1700 <IETF RFC 1700_>`_."

msgid ""
"There is no way to indicate non-native byte order (force byte-swapping); use "
"the appropriate choice of ``'<'`` or ``'>'``."
msgstr ""
"Det finns inget sätt att ange en icke inhemsk byteordning (tvinga fram "
"bytebyte); använd det lämpliga valet av ``'<'`` eller ``'>'``."

msgid "Notes:"
msgstr "Anteckningar:"

msgid ""
"Padding is only automatically added between successive structure members. No "
"padding is added at the beginning or the end of the encoded struct."
msgstr ""
"Padding läggs bara automatiskt till mellan på varandra följande "
"strukturmedlemmar. Ingen utfyllnad läggs till i början eller slutet av den "
"kodade strukturen."

msgid ""
"No padding is added when using non-native size and alignment, e.g. with '<', "
"'>', '=', and '!'."
msgstr ""
"Ingen utfyllnad läggs till när man använder icke-nativ storlek och "
"justering, t.ex. med \"<\", \">\", \"=\" och \"!\"."

msgid ""
"To align the end of a structure to the alignment requirement of a particular "
"type, end the format with the code for that type with a repeat count of "
"zero.  See :ref:`struct-examples`."
msgstr ""
"För att anpassa slutet av en struktur till anpassningskravet för en viss "
"typ, avsluta formatet med koden för den typen med ett upprepningsantal på "
"noll.  Se :ref:`strukturexempel`."

msgid "Format Characters"
msgstr "Format tecken"

msgid ""
"Format characters have the following meaning; the conversion between C and "
"Python values should be obvious given their types.  The 'Standard size' "
"column refers to the size of the packed value in bytes when using standard "
"size; that is, when the format string starts with one of ``'<'``, ``'>'``, "
"``'!'`` or ``'='``.  When using native size, the size of the packed value is "
"platform-dependent."
msgstr ""
"Formattecken har följande betydelse; konverteringen mellan C- och Python-"
"värden bör vara uppenbar med tanke på deras typer.  Kolumnen "
"\"Standardstorlek\" avser storleken på det packade värdet i byte vid "
"användning av standardstorlek, det vill säga när formatsträngen börjar med "
"något av ``'<'``, ``'>'``, ``'!'`` eller ``'='``.  Vid användning av native-"
"storlek är storleken på det packade värdet plattformsberoende."

msgid "Format"
msgstr "Format"

msgid "C Type"
msgstr "C Typ"

msgid "Python type"
msgstr "Python-typ"

msgid "Standard size"
msgstr "Standardstorlek"

msgid "Notes"
msgstr "Anteckningar"

msgid "``x``"
msgstr "``x``"

msgid "pad byte"
msgstr "pad byte"

msgid "no value"
msgstr "inget värde"

msgid "\\(7)"
msgstr "\\(7)"

msgid "``c``"
msgstr "``c``"

msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

msgid "bytes of length 1"
msgstr "byte med längd 1"

msgid "1"
msgstr "1"

msgid "``b``"
msgstr "``b``"

msgid ":c:expr:`signed char`"
msgstr ":c:expr:`signed char`"

msgid "integer"
msgstr "heltal"

msgid "\\(1), \\(2)"
msgstr "\\(1), \\(2)"

msgid "``B``"
msgstr "``B``"

msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

msgid "\\(2)"
msgstr "\\(2)"

msgid "``?``"
msgstr "``?``"

msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

msgid "bool"
msgstr "bool"

msgid "\\(1)"
msgstr "\\(1)"

msgid "``h``"
msgstr "``h``"

msgid ":c:expr:`short`"
msgstr ":c:expr:`kort`"

msgid "2"
msgstr "2"

msgid "``H``"
msgstr "``H``"

msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

msgid "``i``"
msgstr "``i``"

msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

msgid "4"
msgstr "4"

msgid "``I``"
msgstr "``I``"

msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

msgid "``l``"
msgstr "``l``"

msgid ":c:expr:`long`"
msgstr ":c:expr:`lång`"

msgid "``L``"
msgstr "``L``"

msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

msgid "``q``"
msgstr "``q``"

msgid ":c:expr:`long long`"
msgstr ":c:expr:`lång lång`"

msgid "8"
msgstr "8"

msgid "``Q``"
msgstr "``Q``"

msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

msgid "``n``"
msgstr "``n``"

msgid ":c:type:`ssize_t`"
msgstr ":c:typ:`ssize_t`"

msgid "\\(3)"
msgstr "\\(3)"

msgid "``N``"
msgstr "``N``"

msgid ":c:type:`size_t`"
msgstr ":c:typ:`storlek_t`"

msgid "``e``"
msgstr "``e``"

msgid "\\(6)"
msgstr "\\(6)"

msgid "float"
msgstr "flyt"

msgid "\\(4)"
msgstr "\\(4)"

msgid "``f``"
msgstr "``f``"

msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

msgid "``d``"
msgstr "``d``"

msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

msgid "``F``"
msgstr "``F``"

msgid ":c:expr:`float complex`"
msgstr ":c:expr:`flöde komplex`"

msgid "complex"
msgstr "komplex"

msgid "\\(10)"
msgstr "\\(10)"

msgid "``D``"
msgstr "``D``"

msgid ":c:expr:`double complex`"
msgstr ":c:expr:`dubbel komplex`"

msgid "16"
msgstr "16"

msgid "``s``"
msgstr "``s``"

msgid ":c:expr:`char[]`"
msgstr ":c:expr:`char[]`"

msgid "bytes"
msgstr "byte"

msgid "\\(9)"
msgstr "\\(9)"

msgid "``p``"
msgstr "``p``"

msgid "\\(8)"
msgstr "\\(8)"

msgid "``P``"
msgstr "``P``"

msgid ":c:expr:`void \\*`"
msgstr ":c:expr:`void \\*``"

msgid "\\(5)"
msgstr "\\(5)"

msgid "Added support for the ``'n'`` and ``'N'`` formats."
msgstr "Lagt till stöd för formaten ``'n`` och ``'N``."

msgid "Added support for the ``'e'`` format."
msgstr "Stöd för formatet ``'e'`` har lagts till."

msgid "Added support for the ``'F'`` and ``'D'`` formats."
msgstr "Stöd för formaten ``'F`` och ``'D`` har lagts till."

msgid ""
"The ``'?'`` conversion code corresponds to the :c:expr:`_Bool` type defined "
"by C standards since C99.  In standard mode, it is represented by one byte."
msgstr ""
"Konverteringskoden ``'?'`` motsvarar typen :c:expr:`_Bool` som definieras av "
"C-standarder sedan C99.  I standardläge representeras den av en byte."

msgid ""
"When attempting to pack a non-integer using any of the integer conversion "
"codes, if the non-integer has a :meth:`~object.__index__` method then that "
"method is called to convert the argument to an integer before packing."
msgstr ""
"När du försöker packa ett icke-integertal med någon av koderna för "
"heltalskonvertering, om icke-integertalet har en :meth:`~object.__index__`-"
"metod, anropas den metoden för att konvertera argumentet till ett heltal "
"före packning."

msgid "Added use of the :meth:`~object.__index__` method for non-integers."
msgstr ""
"Lagt till användning av metoden :meth:`~object.__index__` för icke-"
"integraler."

msgid ""
"The ``'n'`` and ``'N'`` conversion codes are only available for the native "
"size (selected as the default or with the ``'@'`` byte order character). For "
"the standard size, you can use whichever of the other integer formats fits "
"your application."
msgstr ""
"Konverteringskoderna ``'n'`` och ``'N'`` är endast tillgängliga för den "
"ursprungliga storleken (vald som standard eller med byteordningstecknet "
"``'@'``). För standardstorleken kan du använda vilket som helst av de andra "
"heltalsformaten som passar din applikation."

msgid ""
"For the ``'f'``, ``'d'`` and ``'e'`` conversion codes, the packed "
"representation uses the IEEE 754 binary32, binary64 or binary16 format (for "
"``'f'``, ``'d'`` or ``'e'`` respectively), regardless of the floating-point "
"format used by the platform."
msgstr ""
"För konverteringskoderna ``'f'``, ``'d'`` och ``'e'`` använder den packade "
"representationen IEEE 754-formatet binary32, binary64 eller binary16 (för "
"``'f'``, ``'d'`` respektive ``'e'``), oavsett vilket flyttalsformat som "
"används av plattformen."

msgid ""
"The ``'P'`` format character is only available for the native byte ordering "
"(selected as the default or with the ``'@'`` byte order character). The byte "
"order character ``'='`` chooses to use little- or big-endian ordering based "
"on the host system. The struct module does not interpret this as native "
"ordering, so the ``'P'`` format is not available."
msgstr ""
"Formattecknet ``'P'`` är endast tillgängligt för den ursprungliga "
"byteordningen (vald som standard eller med byteordningstecknet ``'@'``). "
"Byteordningstecknet ``'='`` väljer att använda little- eller big-endian-"
"ordning baserat på värdsystemet. Struct-modulen tolkar inte detta som "
"inbyggd ordning, så formatet ``'P'`` är inte tillgängligt."

msgid ""
"The IEEE 754 binary16 \"half precision\" type was introduced in the 2008 "
"revision of the `IEEE 754 standard <ieee 754 standard_>`_. It has a sign "
"bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), "
"and can represent numbers between approximately ``6.1e-05`` and ``6.5e+04`` "
"at full precision. This type is not widely supported by C compilers: on a "
"typical machine, an unsigned short can be used for storage, but not for math "
"operations. See the Wikipedia page on the `half-precision floating-point "
"format <half precision format_>`_ for more information."
msgstr ""
"Typen IEEE 754 binary16 \"half precision\" introducerades i 2008 års "
"revision av `IEEE 754-standarden <ieee 754 standard_>`_. Den har en "
"teckenbit, en 5-bitars exponent och 11-bitars precision (med 10 bitar "
"explicit lagrade) och kan representera tal mellan cirka ``6,1e-05`` och "
"``6,5e+04`` med full precision. Denna typ stöds inte allmänt av C-"
"kompilatorer: på en typisk maskin kan en osignerad kort användas för "
"lagring, men inte för matematiska operationer. Se Wikipedia-sidan om `half-"
"precision floating-point format <half precision format_>`_ för mer "
"information."

msgid "When packing, ``'x'`` inserts one NUL byte."
msgstr "Vid packning infogar ``'x'`` en NUL-byte."

msgid ""
"The ``'p'`` format character encodes a \"Pascal string\", meaning a short "
"variable-length string stored in a *fixed number of bytes*, given by the "
"count. The first byte stored is the length of the string, or 255, whichever "
"is smaller.  The bytes of the string follow.  If the string passed in to :"
"func:`pack` is too long (longer than the count minus 1), only the leading "
"``count-1`` bytes of the string are stored.  If the string is shorter than "
"``count-1``, it is padded with null bytes so that exactly count bytes in all "
"are used.  Note that for :func:`unpack`, the ``'p'`` format character "
"consumes ``count`` bytes, but that the string returned can never contain "
"more than 255 bytes."
msgstr ""
"Formattecknet ``'p'`` kodar en \"Pascal-sträng\", dvs. en kort sträng med "
"variabel längd som lagras i ett *fixerat antal byte*, som anges av count. "
"Den första byten som lagras är strängens längd eller 255, beroende på vilket "
"som är minst.  Därefter följer strängens byte.  Om strängen som skickas "
"till :func:`pack` är för lång (längre än count minus 1), lagras endast de "
"första ``count-1`` bytena i strängen.  Om strängen är kortare än ``count-1`` "
"fylls den på med nollbytes så att exakt count-bytes används.  Observera att "
"för :func:`unpack` förbrukar formattecknet ``'p'`` ``count`` bytes, men att "
"strängen som returneras aldrig kan innehålla mer än 255 bytes."

msgid ""
"For the ``'s'`` format character, the count is interpreted as the length of "
"the bytes, not a repeat count like for the other format characters; for "
"example, ``'10s'`` means a single 10-byte string mapping to or from a single "
"Python byte string, while ``'10c'`` means 10 separate one byte character "
"elements (e.g., ``cccccccccc``) mapping to or from ten different Python byte "
"objects. (See :ref:`struct-examples` for a concrete demonstration of the "
"difference.) If a count is not given, it defaults to 1.  For packing, the "
"string is truncated or padded with null bytes as appropriate to make it fit. "
"For unpacking, the resulting bytes object always has exactly the specified "
"number of bytes.  As a special case, ``'0s'`` means a single, empty string "
"(while ``'0c'`` means 0 characters)."
msgstr ""
"För formattecknet ``'s'`` tolkas antalet som längden på bytena, inte som ett "
"upprepningsantal som för de andra formattecknen; till exempel betyder "
"``'10s'`` en enda 10-bytessträng som mappar till eller från en enda Python-"
"bytesträng, medan ``'10c'`` betyder 10 separata en-bytes teckenelement (t."
"ex. ``cccccccccccc``) som mappar till eller från tio olika Python-"
"byteobjekt. (Se :ref:`struct-examples` för en konkret demonstration av "
"skillnaden.) Om ett antal inte anges är standardvärdet 1.  Vid packning "
"trunkeras strängen eller fylls på med nollbytes på lämpligt sätt för att den "
"ska få plats. Vid uppackning har det resulterande bytes-objektet alltid "
"exakt det angivna antalet bytes.  Som ett specialfall betyder ``'0s'`` en "
"enda, tom sträng (medan ``'0c'`` betyder 0 tecken)."

msgid ""
"For the ``'F'`` and ``'D'`` format characters, the packed representation "
"uses the IEEE 754 binary32 and binary64 format for components of the complex "
"number, regardless of the floating-point format used by the platform. Note "
"that complex types (``F`` and ``D``) are available unconditionally, despite "
"complex types being an optional feature in C. As specified in the C11 "
"standard, each complex type is represented by a two-element C array "
"containing, respectively, the real and imaginary parts."
msgstr ""
"För formattecknen ``'F`` och ``'D`` använder den packade representationen "
"IEEE 754 binary32- och binary64-formatet för komponenter i det komplexa "
"talet, oavsett vilket flyttalsformat som används av plattformen. Observera "
"att komplexa typer (``F`` och ``D``) är tillgängliga villkorslöst, trots att "
"komplexa typer är en valfri funktion i C. Enligt specifikationen i C11-"
"standarden representeras varje komplex typ av en C-array med två element som "
"innehåller den reella respektive imaginära delen."

msgid ""
"A format character may be preceded by an integral repeat count.  For "
"example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr ""
"Ett formattecken kan föregås av ett helt upprepningsantal.  Till exempel "
"betyder formatsträngen ``'4h'`` exakt samma sak som ``'hhhh'``."

msgid ""
"Whitespace characters between formats are ignored; a count and its format "
"must not contain whitespace though."
msgstr ""
"Whitespace-tecken mellan format ignoreras; ett count och dess format får "
"dock inte innehålla whitespace."

msgid ""
"When packing a value ``x`` using one of the integer formats (``'b'``, "
"``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, ``'L'``, ``'q'``, "
"``'Q'``), if ``x`` is outside the valid range for that format then :exc:"
"`struct.error` is raised."
msgstr ""
"När du packar ett värde ``x`` med ett av heltalsformaten (``'b'``, ``'B'``, "
"``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, ``'L'``, ``'q'``, ``'Q'``), om "
"``x`` är utanför det giltiga intervallet för det formatet, kommer :exc:"
"`struct.error` att visas."

msgid ""
"Previously, some of the integer formats wrapped out-of-range values and "
"raised :exc:`DeprecationWarning` instead of :exc:`struct.error`."
msgstr ""
"Tidigare har vissa av heltalsformaten paketerat värden utanför intervallet "
"och gett upphov till :exc:`DeprecationWarning` istället för :exc:`struct."
"error`."

msgid ""
"For the ``'?'`` format character, the return value is either :const:`True` "
"or :const:`False`. When packing, the truth value of the argument object is "
"used. Either 0 or 1 in the native or standard bool representation will be "
"packed, and any non-zero value will be ``True`` when unpacking."
msgstr ""
"För formattecknet ``'?'`` är returvärdet antingen :const:`True` eller :const:"
"`False`. Vid packning används argumentobjektets sanningsvärde. Antingen 0 "
"eller 1 i den ursprungliga eller standard bool-representationen kommer att "
"packas, och alla värden som inte är noll kommer att vara ``True`` vid "
"uppackning."

msgid "Examples"
msgstr "Exempel"

msgid ""
"Native byte order examples (designated by the ``'@'`` format prefix or lack "
"of any prefix character) may not match what the reader's machine produces as "
"that depends on the platform and compiler."
msgstr ""
"Exempel på inbyggd byteordning (som betecknas med formatprefixet ``'@'`` "
"eller avsaknad av prefixtecken) kanske inte stämmer överens med vad läsarens "
"maskin producerar eftersom det beror på plattform och kompilator."

msgid ""
"Pack and unpack integers of three different sizes, using big endian "
"ordering::"
msgstr ""
"Packa och packa upp heltal av tre olika storlekar, med big endian-ordning::"

msgid ""
">>> from struct import *\n"
">>> pack(\">bhl\", 1, 2, 3)\n"
"b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03'\n"
">>> unpack('>bhl', b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03')\n"
"(1, 2, 3)\n"
">>> calcsize('>bhl')\n"
"7"
msgstr ""
">>> from struct import *\n"
">>> pack(\">bhl\", 1, 2, 3)\n"
"b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03'\n"
">>> unpack('>bhl', b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03')\n"
"(1, 2, 3)\n"
">>> calcsize('>bhl')\n"
"7"

msgid "Attempt to pack an integer which is too large for the defined field::"
msgstr ""
"Försök att packa ett heltal som är för stort för det definierade fältet::"

msgid ""
">>> pack(\">h\", 99999)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"struct.error: 'h' format requires -32768 <= number <= 32767"
msgstr ""
"&gt;&gt;&gt; pack(\"&gt;h\", 99999)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"struct.error: 'h'-formatet kräver -32768 &lt;= tal &lt;= 32767"

msgid ""
"Demonstrate the difference between ``'s'`` and ``'c'`` format characters::"
msgstr "Demonstrera skillnaden mellan formattecknen ``'s'`` och ``'c'``::"

msgid ""
">>> pack(\"@ccc\", b'1', b'2', b'3')\n"
"b'123'\n"
">>> pack(\"@3s\", b'123')\n"
"b'123'"
msgstr ""
">>> pack(\"@ccc\", b'1', b'2', b'3')\n"
"b'123'\n"
">>> pack(\"@3s\", b'123')\n"
"b'123'"

msgid ""
"Unpacked fields can be named by assigning them to variables or by wrapping "
"the result in a named tuple::"
msgstr ""
"Ouppackade fält kan namnges genom att de tilldelas variabler eller genom att "
"resultatet förpackas i en namngiven tupel::"

msgid ""
">>> record = b'raymond   \\x32\\x12\\x08\\x01\\x08'\n"
">>> name, serialnum, school, gradelevel = unpack('<10sHHb', record)\n"
"\n"
">>> from collections import namedtuple\n"
">>> Student = namedtuple('Student', 'name serialnum school gradelevel')\n"
">>> Student._make(unpack('<10sHHb', record))\n"
"Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)"
msgstr ""
">>> record = b'raymond \\x32\\x12\\x08\\x01\\x08'\n"
">>> namn, serienummer, skola, betygsnivå = unpack('<10sHHb', record)\n"
"\n"
">>> from collections import namedtuple\n"
">>> Student = namedtuple('Student', 'namn serienummer skola gradnivå')\n"
">>> Student._make(unpack('<10sHHb', record))\n"
"Student(name=b'raymond ', serialnum=4658, school=264, gradelevel=8)"

msgid ""
"The ordering of format characters may have an impact on size in native mode "
"since padding is implicit. In standard mode, the user is responsible for "
"inserting any desired padding. Note in the first ``pack`` call below that "
"three NUL bytes were added after the packed ``'#'`` to align the following "
"integer on a four-byte boundary. In this example, the output was produced on "
"a little endian machine::"
msgstr ""
"Ordningsföljden på formattecknen kan påverka storleken i native-läge "
"eftersom utfyllnaden är implicit. I standardläge är användaren ansvarig för "
"att infoga önskad utfyllnad. Notera i det första ``pack``-anropet nedan att "
"tre NUL-bytes lades till efter den packade ``'#'`` för att anpassa följande "
"heltal till en gräns på fyra byte. I det här exemplet producerades utdata på "
"en little endian-maskin::"

msgid ""
">>> pack('@ci', b'#', 0x12131415)\n"
"b'#\\x00\\x00\\x00\\x15\\x14\\x13\\x12'\n"
">>> pack('@ic', 0x12131415, b'#')\n"
"b'\\x15\\x14\\x13\\x12#'\n"
">>> calcsize('@ci')\n"
"8\n"
">>> calcsize('@ic')\n"
"5"
msgstr ""
">>> pack('@ci', b'#', 0x12131415)\n"
"b'#\\x00\\x00\\x00\\x15\\x14\\x13\\x12'\n"
">>> pack('@ic', 0x12131415, b'#')\n"
"b'\\x15\\x14\\x13\\x12#'\n"
">>> calcsize('@ci')\n"
"8\n"
">>> beräkna storlek('@ic')\n"
"5"

msgid ""
"The following format ``'llh0l'`` results in two pad bytes being added at the "
"end, assuming the platform's longs are aligned on 4-byte boundaries::"
msgstr ""
"Följande format ``'llh0l'`` resulterar i att två padbytes läggs till i "
"slutet, förutsatt att plattformens longs är inriktade på 4-bytegränser::"

msgid ""
">>> pack('@llh0l', 1, 2, 3)\n"
"b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\\x00'"
msgstr ""
">>> pack('@llh0l', 1, 2, 3)\n"
"b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\\x00'"

msgid "Module :mod:`array`"
msgstr "Modul :mod:`array`"

msgid "Packed binary storage of homogeneous data."
msgstr "Packad binär lagring av homogena data."

msgid "Module :mod:`json`"
msgstr "Modul :mod:`json`"

msgid "JSON encoder and decoder."
msgstr "JSON-kodare och -avkodare."

msgid "Module :mod:`pickle`"
msgstr "Modul :mod:`pickle`"

msgid "Python object serialization."
msgstr "Serialisering av Python-objekt."

msgid "Applications"
msgstr "Ansökningar"

msgid ""
"Two main applications for the :mod:`struct` module exist, data interchange "
"between Python and C code within an application or another application "
"compiled using the same compiler (:ref:`native formats<struct-native-"
"formats>`), and data interchange between applications using agreed upon data "
"layout (:ref:`standard formats<struct-standard-formats>`).  Generally "
"speaking, the format strings constructed for these two domains are distinct."
msgstr ""
"Det finns två huvudsakliga användningsområden för modulen :mod:`struct`, "
"datautbyte mellan Python- och C-kod inom ett program eller ett annat program "
"som kompilerats med samma kompilator (:ref:`native formats<struct-native-"
"formats>`), och datautbyte mellan program som använder en överenskommen "
"datalayout (:ref:`standard formats<struct-standard-formats>`).  Generellt "
"sett är formatsträngarna som konstrueras för dessa två domäner olika."

msgid "Native Formats"
msgstr "Ursprungliga format"

msgid ""
"When constructing format strings which mimic native layouts, the compiler "
"and machine architecture determine byte ordering and padding. In such cases, "
"the ``@`` format character should be used to specify native byte ordering "
"and data sizes.  Internal pad bytes are normally inserted automatically.  It "
"is possible that a zero-repeat format code will be needed at the end of a "
"format string to round up to the correct byte boundary for proper alignment "
"of consecutive chunks of data."
msgstr ""
"Vid konstruktion av formatsträngar som efterliknar inbyggda layouter "
"bestämmer kompilatorn och maskinarkitekturen byteordning och utfyllnad. I "
"sådana fall bör formattecknet ``@`` användas för att ange byteordning och "
"datastorlek.  Interna padbytes infogas normalt automatiskt.  Det är möjligt "
"att en formatkod med noll upprepningar behövs i slutet av en formatsträng "
"för att avrunda till rätt bytegräns för korrekt justering av på varandra "
"följande datapaket."

msgid ""
"Consider these two simple examples (on a 64-bit, little-endian machine)::"
msgstr ""
"Tänk på dessa två enkla exempel (på en 64-bitars, little-endian-maskin)::"

msgid ""
">>> calcsize('@lhl')\n"
"24\n"
">>> calcsize('@llh')\n"
"18"
msgstr ""
">>> calcsize('@lhl')\n"
"24\n"
">>> kalkylstorlek('@llh')\n"
"18"

msgid ""
"Data is not padded to an 8-byte boundary at the end of the second format "
"string without the use of extra padding.  A zero-repeat format code solves "
"that problem::"
msgstr ""
"Data fylls inte ut till en 8-bytesgräns i slutet av den andra formatsträngen "
"utan att extra utfyllnad används.  En formatkod med noll upprepningar löser "
"det problemet::"

msgid ""
">>> calcsize('@llh0l')\n"
"24"
msgstr ""
">>> calcsize('@llh0l')\n"
"24"

msgid ""
"The ``'x'`` format code can be used to specify the repeat, but for native "
"formats it is better to use a zero-repeat format like ``'0l'``."
msgstr ""
"Formatkoden ``'x'`` kan användas för att ange upprepningen, men för inbyggda "
"format är det bättre att använda ett format med noll upprepning som ``'0l'``."

msgid ""
"By default, native byte ordering and alignment is used, but it is better to "
"be explicit and use the ``'@'`` prefix character."
msgstr ""
"Som standard används inbyggd byteordning och justering, men det är bättre "
"att vara tydlig och använda prefixtecknet ``'@'``."

msgid "Standard Formats"
msgstr "Standardformat"

msgid ""
"When exchanging data beyond your process such as networking or storage, be "
"precise.  Specify the exact byte order, size, and alignment.  Do not assume "
"they match the native order of a particular machine. For example, network "
"byte order is big-endian, while many popular CPUs are little-endian.  By "
"defining this explicitly, the user need not care about the specifics of the "
"platform their code is running on. The first character should typically be "
"``<`` or ``>`` (or ``!``).  Padding is the responsibility of the "
"programmer.  The zero-repeat format character won't work.  Instead, the user "
"must explicitly add ``'x'`` pad bytes where needed.  Revisiting the examples "
"from the previous section, we have::"
msgstr ""
"När du utbyter data utanför din process, t.ex. nätverk eller lagring, ska du "
"vara exakt.  Ange den exakta byteordningen, storleken och inriktningen.  "
"Anta inte att de matchar den ursprungliga ordningen för en viss maskin. Till "
"exempel är byteordningen i nätverk big-endian, medan många populära "
"processorer är little-endian.  Genom att definiera detta explicit behöver "
"användaren inte bry sig om detaljerna i den plattform som deras kod körs på. "
"Det första tecknet bör normalt vara ``<`` eller ``>`` (eller ``!``).  "
"Utfyllnad är programmerarens ansvar.  Formattecknet med noll upprepningar "
"fungerar inte.  Istället måste användaren uttryckligen lägga till ``'x'`` "
"padbytes där det behövs.  Om vi återgår till exemplen från föregående "
"avsnitt har vi::"

msgid ""
">>> calcsize('<qh6xq')\n"
"24\n"
">>> pack('<qh6xq', 1, 2, 3) == pack('@lhl', 1, 2, 3)\n"
"True\n"
">>> calcsize('@llh')\n"
"18\n"
">>> pack('@llh', 1, 2, 3) == pack('<qqh', 1, 2, 3)\n"
"True\n"
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"24\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"True"
msgstr ""
">>> calcsize('<qh6xq')\n"
"24\n"
">>> pack('<qh6xq', 1, 2, 3) == pack('@lhl', 1, 2, 3)\n"
"Sant\n"
">>> beräkna storlek('@llh')\n"
"18\n"
">>> pack('@llh', 1, 2, 3) == pack('<qqh', 1, 2, 3)\n"
"Sant\n"
">>> beräkna storlek('<qqh6x')\n"
"24\n"
">>> beräkna storlek('@llh0l')\n"
"24\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"Sant"

msgid ""
"The above results (executed on a 64-bit machine) aren't guaranteed to match "
"when executed on different machines.  For example, the examples below were "
"executed on a 32-bit machine::"
msgstr ""
"Det är inte säkert att resultaten ovan (som kördes på en 64-bitars maskin) "
"stämmer överens när de körs på andra maskiner.  Exemplen nedan kördes till "
"exempel på en 32-bitars maskin::"

msgid ""
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"12\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"False"
msgstr ""
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"12\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"Falsk"

msgid "Classes"
msgstr "Klasser"

msgid "The :mod:`struct` module also defines the following type:"
msgstr "Modulen :mod:`struct` definierar också följande typ:"

msgid ""
"Return a new Struct object which writes and reads binary data according to "
"the format string *format*.  Creating a ``Struct`` object once and calling "
"its methods is more efficient than calling module-level functions with the "
"same format since the format string is only compiled once."
msgstr ""
"Returnerar ett nytt Struct-objekt som skriver och läser binära data enligt "
"formatsträngen *format*.  Att skapa ett ``Struct``-objekt en gång och anropa "
"dess metoder är mer effektivt än att anropa funktioner på modulnivå med "
"samma format eftersom formatsträngen bara kompileras en gång."

msgid ""
"The compiled versions of the most recent format strings passed to the module-"
"level functions are cached, so programs that use only a few format strings "
"needn't worry about reusing a single :class:`Struct` instance."
msgstr ""
"De kompilerade versionerna av de senaste formatsträngarna som skickas till "
"modulnivåfunktionerna cachas, så program som bara använder ett fåtal "
"formatsträngar behöver inte oroa sig för att återanvända en enda :class:"
"`Struct`-instans."

msgid "Compiled Struct objects support the following methods and attributes:"
msgstr "Kompilerade Struct-objekt har stöd för följande metoder och attribut:"

msgid ""
"Identical to the :func:`pack` function, using the compiled format. "
"(``len(result)`` will equal :attr:`size`.)"
msgstr ""
"Identisk med funktionen :func:`pack`, med det kompilerade formatet. "
"(``len(result)`` kommer att motsvara :attr:`size`.)"

msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr ""
"Identisk med funktionen :func:`pack_into`, med det kompilerade formatet."

msgid ""
"Identical to the :func:`unpack` function, using the compiled format. The "
"buffer's size in bytes must equal :attr:`size`."
msgstr ""
"Identisk med funktionen :func:`unpack`, men använder det kompilerade "
"formatet. Buffertens storlek i bytes måste vara lika med :attr:`size`."

msgid ""
"Identical to the :func:`unpack_from` function, using the compiled format. "
"The buffer's size in bytes, starting at position *offset*, must be at least :"
"attr:`size`."
msgstr ""
"Identisk med funktionen :func:`unpack_from`, men använder det kompilerade "
"formatet. Buffertens storlek i byte, med start vid position *offset*, måste "
"vara minst :attr:`size`."

msgid ""
"Identical to the :func:`iter_unpack` function, using the compiled format. "
"The buffer's size in bytes must be a multiple of :attr:`size`."
msgstr ""
"Identisk med funktionen :func:`iter_unpack`, men använder det kompilerade "
"formatet. Buffertens storlek i bytes måste vara en multipel av :attr:`size`."

msgid "The format string used to construct this Struct object."
msgstr "Den formatsträng som användes för att konstruera detta Struct-objekt."

msgid "The format string type is now :class:`str` instead of :class:`bytes`."
msgstr "Formatsträngstypen är nu :class:`str` istället för :class:`bytes`."

msgid ""
"The calculated size of the struct (and hence of the bytes object produced by "
"the :meth:`pack` method) corresponding to :attr:`format`."
msgstr ""
"Den beräknade storleken på struct (och därmed på bytesobjektet som "
"produceras av metoden :meth:`pack`) som motsvarar :attr:`format`."

msgid "The *repr()* of structs has changed.  It is now:"
msgstr "*repr()* för structs har ändrats.  Det är det nu:"

msgid "C"
msgstr "C"

msgid "structures"
msgstr "strukturer"

msgid "packing"
msgstr "packning"

msgid "binary"
msgstr "binär"

msgid "data"
msgstr "data"

msgid "@ (at)"
msgstr "@ (vid)"

msgid "in struct format strings"
msgstr "i struct-format strängar"

msgid "= (equals)"
msgstr "= (lika med)"

msgid "< (less)"
msgstr "< (mindre)"

msgid "> (greater)"
msgstr "> (större)"

msgid "! (exclamation)"
msgstr "! (utrop)"

msgid "? (question mark)"
msgstr "? (frågetecken)"
