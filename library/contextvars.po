# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!contextvars` --- Context Variables"
msgstr ":mod:`!contextvars` --- Kontextvariabler"

msgid ""
"This module provides APIs to manage, store, and access context-local state.  "
"The :class:`~contextvars.ContextVar` class is used to declare and work with "
"*Context Variables*.  The :func:`~contextvars.copy_context` function and "
"the :class:`~contextvars.Context` class should be used to manage the current "
"context in asynchronous frameworks."
msgstr ""
"Denna modul tillhandahåller API:er för att hantera, lagra och komma åt "
"kontextlokalt tillstånd.  Klassen :class:`~contextvars.ContextVar` används "
"för att deklarera och arbeta med *kontextvariabler*.  Funktionen :func:"
"`~contextvars.copy_context` och klassen :class:`~contextvars.Context` bör "
"användas för att hantera den aktuella kontexten i asynkrona ramverk."

msgid ""
"Context managers that have state should use Context Variables instead of :"
"func:`threading.local` to prevent their state from bleeding to other code "
"unexpectedly, when used in concurrent code."
msgstr ""
"Kontexthanterare som har tillstånd bör använda kontextvariabler istället "
"för :func:`threading.local` för att förhindra att deras tillstånd oväntat "
"sprids till annan kod när de används i samtidig kod."

msgid "See also :pep:`567` for additional details."
msgstr "Se även :pep:`567` för ytterligare information."

msgid "Context Variables"
msgstr "Variabler för kontext"

msgid "This class is used to declare a new Context Variable, e.g.::"
msgstr "Denna klass används för att deklarera en ny kontextvariabel, t.ex.::"

msgid "var: ContextVar[int] = ContextVar('var', default=42)"
msgstr "var: ContextVar[int] = ContextVar('var', default=42)"

msgid ""
"The required *name* parameter is used for introspection and debug purposes."
msgstr ""
"Den obligatoriska parametern *name* används för introspektion och felsökning."

msgid ""
"The optional keyword-only *default* parameter is returned by :meth:"
"`ContextVar.get` when no value for the variable is found in the current "
"context."
msgstr ""
"Den valfria parametern *default*, som endast innehåller nyckelord, "
"returneras av :meth:`ContextVar.get` när inget värde för variabeln hittas i "
"den aktuella kontexten."

msgid ""
"**Important:** Context Variables should be created at the top module level "
"and never in closures.  :class:`Context` objects hold strong references to "
"context variables which prevents context variables from being properly "
"garbage collected."
msgstr ""
"**Viktigt:** Kontextvariabler ska skapas på den översta modulnivån och "
"aldrig i avslutningar. :class:`Context`-objekt innehåller starka referenser "
"till kontextvariabler vilket förhindrar att kontextvariablerna samlas in på "
"rätt sätt."

msgid "The name of the variable.  This is a read-only property."
msgstr "Namnet på variabeln.  Detta är en skrivskyddad egenskap."

msgid "Return a value for the context variable for the current context."
msgstr "Returnerar ett värde för kontextvariabeln för den aktuella kontexten."

msgid ""
"If there is no value for the variable in the current context, the method "
"will:"
msgstr ""
"Om det inte finns något värde för variabeln i det aktuella sammanhanget "
"kommer metoden att göra det:"

msgid ""
"return the value of the *default* argument of the method, if provided; or"
msgstr ""
"returnera värdet för metodens *standard*-argument, om ett sådant har "
"angetts; eller"

msgid ""
"return the default value for the context variable, if it was created with "
"one; or"
msgstr ""
"returnera standardvärdet för kontextvariabeln, om den skapades med ett "
"sådant; eller"

msgid "raise a :exc:`LookupError`."
msgstr "skapa ett :exc:`LookupError`."

msgid ""
"Call to set a new value for the context variable in the current context."
msgstr ""
"Anrop för att ange ett nytt värde för kontextvariabeln i den aktuella "
"kontexten."

msgid ""
"The required *value* argument is the new value for the context variable."
msgstr ""
"Det obligatoriska argumentet *value* är det nya värdet för kontextvariabeln."

msgid ""
"Returns a :class:`~contextvars.Token` object that can be used to restore the "
"variable to its previous value via the :meth:`ContextVar.reset` method."
msgstr ""
"Returnerar ett :class:`~contextvars.Token`-objekt som kan användas för att "
"återställa variabeln till dess tidigare värde via metoden :meth:`ContextVar."
"reset`."

msgid ""
"Reset the context variable to the value it had before the :meth:`ContextVar."
"set` that created the *token* was used."
msgstr ""
"Återställer kontextvariabeln till det värde den hade innan :meth:`ContextVar."
"set` som skapade *token* användes."

msgid "For example::"
msgstr "Till exempel::"

msgid ""
"var = ContextVar('var')\n"
"\n"
"token = var.set('new value')\n"
"# code that uses 'var'; var.get() returns 'new value'.\n"
"var.reset(token)\n"
"\n"
"# After the reset call the var has no value again, so\n"
"# var.get() would raise a LookupError."
msgstr ""
"var = ContextVar('var')\n"
"\n"
"token = var.set('new value')\n"
"# code that uses 'var'; var.get() returns 'new value'.\n"
"var.reset(token)\n"
"\n"
"# After the reset call the var has no value again, so\n"
"# var.get() would raise a LookupError."

msgid ""
"*Token* objects are returned by the :meth:`ContextVar.set` method. They can "
"be passed to the :meth:`ContextVar.reset` method to revert the value of the "
"variable to what it was before the corresponding *set*."
msgstr ""
"*Token*-objekt returneras av metoden :meth:`ContextVar.set`. De kan skickas "
"till metoden :meth:`ContextVar.reset` för att återställa variabelns värde "
"till vad det var före motsvarande *set*."

msgid ""
"The token supports :ref:`context manager protocol <context-managers>` to "
"restore the corresponding context variable value at the exit from :keyword:"
"`with` block::"
msgstr ""
"Token stöder :ref:``context manager protocol <context-managers>`` för att "
"återställa motsvarande kontextvariabelvärde vid utgången från :keyword:"
"`with` block::"

msgid ""
"var = ContextVar('var', default='default value')\n"
"\n"
"with var.set('new value'):\n"
"    assert var.get() == 'new value'\n"
"\n"
"assert var.get() == 'default value'"
msgstr ""
"var = ContextVar('var', default='default value')\n"
"\n"
"with var.set('new value'):\n"
"    assert var.get() == 'new value'\n"
"\n"
"assert var.get() == 'default value'"

msgid "Added support for usage as a context manager."
msgstr "Stöd för användning som kontexthanterare har lagts till."

msgid ""
"A read-only property.  Points to the :class:`ContextVar` object that created "
"the token."
msgstr ""
"En skrivskyddad egenskap.  Pekar på det :class:`ContextVar`-objekt som "
"skapade token."

msgid ""
"A read-only property.  Set to the value the variable had before the :meth:"
"`ContextVar.set` method call that created the token. It points to :attr:"
"`Token.MISSING` if the variable was not set before the call."
msgstr ""
"En skrivskyddad egenskap.  Ställs in till det värde variabeln hade före "
"metodanropet :meth:`ContextVar.set` som skapade token. Den pekar på :attr:"
"`Token.MISSING` om variabeln inte var inställd före anropet."

msgid "A marker object used by :attr:`Token.old_value`."
msgstr "Ett markörobjekt som används av :attr:`Token.old_value`."

msgid "Manual Context Management"
msgstr "Manuell kontexthantering"

msgid "Returns a copy of the current :class:`~contextvars.Context` object."
msgstr ""
"Returnerar en kopia av det aktuella :class:`~contextvars.Context`-objektet."

msgid ""
"The following snippet gets a copy of the current context and prints all "
"variables and their values that are set in it::"
msgstr ""
"Följande utdrag hämtar en kopia av den aktuella kontexten och skriver ut "
"alla variabler och deras värden som har angetts i den::"

msgid ""
"ctx: Context = copy_context()\n"
"print(list(ctx.items()))"
msgstr ""
"ctx: Context = copy_context()\n"
"print(list(ctx.items()))"

msgid ""
"The function has an *O*\\ (1) complexity, i.e. works equally fast for "
"contexts with a few context variables and for contexts that have a lot of "
"them."
msgstr ""
"Funktionen har en *O*\\ (1) komplexitet, dvs. den arbetar lika snabbt för "
"kontexter med ett fåtal kontextvariabler som för kontexter med många."

msgid "A mapping of :class:`ContextVars <ContextVar>` to their values."
msgstr "En mappning av :class:`ContextVars <ContextVar>` till deras värden."

msgid ""
"``Context()`` creates an empty context with no values in it. To get a copy "
"of the current context use the :func:`~contextvars.copy_context` function."
msgstr ""
"``Context()`` skapar en tom kontext utan några värden i den. För att få en "
"kopia av den aktuella kontexten används funktionen :func:`~contextvars."
"copy_context`."

msgid ""
"Each thread has its own effective stack of :class:`!Context` objects.  The :"
"term:`current context` is the :class:`!Context` object at the top of the "
"current thread's stack.  All :class:`!Context` objects in the stacks are "
"considered to be *entered*."
msgstr ""
"Varje tråd har sin egen effektiva stack av :class:`!Context`-objekt.  Den :"
"term:`aktuella kontexten` är det :class:`!Context`-objekt som ligger överst "
"i den aktuella trådens stack.  Alla :class:`!Context`-objekt i staplarna "
"anses vara *inmatade*."

msgid ""
"*Entering* a context, which can be done by calling its :meth:`~Context.run` "
"method, makes the context the current context by pushing it onto the top of "
"the current thread's context stack."
msgstr ""
"*När man går in i* en kontext, vilket kan göras genom att anropa dess :meth:"
"`~Context.run`-metod, blir kontexten den aktuella kontexten genom att den "
"läggs överst i den aktuella trådens kontextstapel."

msgid ""
"*Exiting* from the current context, which can be done by returning from the "
"callback passed to the :meth:`~Context.run` method, restores the current "
"context to what it was before the context was entered by popping the context "
"off the top of the context stack."
msgstr ""
"*När du lämnar* den aktuella kontexten, vilket kan göras genom att återvända "
"från den återuppringning som skickades till metoden :meth:`~Context.run`, "
"återställs den aktuella kontexten till vad den var innan kontexten angavs "
"genom att kontexten flyttas från toppen av kontextstapeln."

msgid ""
"Since each thread has its own context stack, :class:`ContextVar` objects "
"behave in a similar fashion to :func:`threading.local` when values are "
"assigned in different threads."
msgstr ""
"Eftersom varje tråd har sin egen kontextstack, beter sig :class:`ContextVar`-"
"objekt på ett liknande sätt som :func:`threading.local` när värden tilldelas "
"i olika trådar."

msgid ""
"Attempting to enter an already entered context, including contexts entered "
"in other threads, raises a :exc:`RuntimeError`."
msgstr ""
"Försök att ange en redan angiven kontext, inklusive kontexter som angetts i "
"andra trådar, ger upphov till ett :exc:`RuntimeError`."

msgid "After exiting a context, it can later be re-entered (from any thread)."
msgstr ""
"När du har lämnat ett sammanhang kan du senare gå in i det igen (från vilken "
"tråd som helst)."

msgid ""
"Any changes to :class:`ContextVar` values via the :meth:`ContextVar.set` "
"method are recorded in the current context.  The :meth:`ContextVar.get` "
"method returns the value associated with the current context.  Exiting a "
"context effectively reverts any changes made to context variables while the "
"context was entered (if needed, the values can be restored by re-entering "
"the context)."
msgstr ""
"Alla ändringar av :class:`ContextVar`-värden via metoden :meth:`ContextVar."
"set` registreras i den aktuella kontexten.  Metoden :meth:`ContextVar.get` "
"returnerar det värde som är associerat med den aktuella kontexten.  När en "
"kontext avslutas återställs alla ändringar som gjorts i kontextvariablerna "
"när kontexten öppnades (vid behov kan värdena återställas genom att "
"kontexten öppnas på nytt)."

msgid "Context implements the :class:`collections.abc.Mapping` interface."
msgstr "Kontexten implementerar gränssnittet :class:`collections.abc.Mapping`."

msgid ""
"Enters the Context, executes ``callable(*args, **kwargs)``, then exits the "
"Context.  Returns *callable*'s return value, or propagates an exception if "
"one occurred."
msgstr ""
"Går in i kontexten, utför ``callable(*args, **kwargs)`` och går sedan ut ur "
"kontexten.  Returnerar *callable*:s returvärde, eller sprider ett undantag "
"om ett sådant inträffat."

msgid "Example:"
msgstr "Exempel:"

msgid ""
"import contextvars\n"
"\n"
"var = contextvars.ContextVar('var')\n"
"var.set('spam')\n"
"print(var.get())  # 'spam'\n"
"\n"
"ctx = contextvars.copy_context()\n"
"\n"
"def main():\n"
"    # 'var' was set to 'spam' before\n"
"    # calling 'copy_context()' and 'ctx.run(main)', so:\n"
"    print(var.get())  # 'spam'\n"
"    print(ctx[var])  # 'spam'\n"
"\n"
"    var.set('ham')\n"
"\n"
"    # Now, after setting 'var' to 'ham':\n"
"    print(var.get())  # 'ham'\n"
"    print(ctx[var])  # 'ham'\n"
"\n"
"# Any changes that the 'main' function makes to 'var'\n"
"# will be contained in 'ctx'.\n"
"ctx.run(main)\n"
"\n"
"# The 'main()' function was run in the 'ctx' context,\n"
"# so changes to 'var' are contained in it:\n"
"print(ctx[var])  # 'ham'\n"
"\n"
"# However, outside of 'ctx', 'var' is still set to 'spam':\n"
"print(var.get())  # 'spam'"
msgstr ""
"import contextvars\n"
"\n"
"var = contextvars.ContextVar('var')\n"
"var.set('spam')\n"
"print(var.get())  # 'spam'\n"
"\n"
"ctx = contextvars.copy_context()\n"
"\n"
"def main():\n"
"    # 'var' was set to 'spam' before\n"
"    # calling 'copy_context()' and 'ctx.run(main)', so:\n"
"    print(var.get())  # 'spam'\n"
"    print(ctx[var])  # 'spam'\n"
"\n"
"    var.set('ham')\n"
"\n"
"    # Now, after setting 'var' to 'ham':\n"
"    print(var.get())  # 'ham'\n"
"    print(ctx[var])  # 'ham'\n"
"\n"
"# Any changes that the 'main' function makes to 'var'\n"
"# will be contained in 'ctx'.\n"
"ctx.run(main)\n"
"\n"
"# The 'main()' function was run in the 'ctx' context,\n"
"# so changes to 'var' are contained in it:\n"
"print(ctx[var])  # 'ham'\n"
"\n"
"# However, outside of 'ctx', 'var' is still set to 'spam':\n"
"print(var.get())  # 'spam'"

msgid "Return a shallow copy of the context object."
msgstr "Returnerar en ytlig kopia av kontextobjektet."

msgid ""
"Return ``True`` if the *context* has a value for *var* set; return ``False`` "
"otherwise."
msgstr ""
"Returnerar ``True`` om *kontexten* har ett värde för *var* inställt; "
"returnerar ``False`` annars."

msgid ""
"Return the value of the *var* :class:`ContextVar` variable. If the variable "
"is not set in the context object, a :exc:`KeyError` is raised."
msgstr ""
"Returnerar värdet på variabeln *var* :class:`ContextVar`. Om variabeln inte "
"är inställd i context-objektet, uppstår ett :exc:`KeyError`."

msgid ""
"Return the value for *var* if *var* has the value in the context object.  "
"Return *default* otherwise.  If *default* is not given, return ``None``."
msgstr ""
"Returnerar värdet för *var* om *var* har värdet i kontextobjektet.  "
"Returnerar annars *default*.  Om *default* inte anges, returneras ``None``."

msgid "Return an iterator over the variables stored in the context object."
msgstr ""
"Returnerar en iterator över de variabler som finns lagrade i kontextobjektet."

msgid "Return the number of variables set in the context object."
msgstr "Returnerar antalet variabler som ställts in i kontextobjektet."

msgid "Return a list of all variables in the context object."
msgstr "Returnerar en lista över alla variabler i kontextobjektet."

msgid "Return a list of all variables' values in the context object."
msgstr "Returnerar en lista över alla variablers värden i kontextobjektet."

msgid ""
"Return a list of 2-tuples containing all variables and their values in the "
"context object."
msgstr ""
"Returnerar en lista med 2-tuples som innehåller alla variabler och deras "
"värden i kontextobjektet."

msgid "asyncio support"
msgstr "stöd för asyncio"

msgid ""
"Context variables are natively supported in :mod:`asyncio` and are ready to "
"be used without any extra configuration.  For example, here is a simple echo "
"server, that uses a context variable to make the address of a remote client "
"available in the Task that handles that client::"
msgstr ""
"Kontextvariabler stöds inbyggt i :mod:`asyncio` och är redo att användas "
"utan någon extra konfiguration.  Här är till exempel en enkel ekoserver som "
"använder en kontextvariabel för att göra adressen till en fjärrklient "
"tillgänglig i den Task som hanterar den klienten::"

msgid ""
"import asyncio\n"
"import contextvars\n"
"\n"
"client_addr_var = contextvars.ContextVar('client_addr')\n"
"\n"
"def render_goodbye():\n"
"    # The address of the currently handled client can be accessed\n"
"    # without passing it explicitly to this function.\n"
"\n"
"    client_addr = client_addr_var.get()\n"
"    return f'Good bye, client @ {client_addr}\\r\\n'.encode()\n"
"\n"
"async def handle_request(reader, writer):\n"
"    addr = writer.transport.get_extra_info('socket').getpeername()\n"
"    client_addr_var.set(addr)\n"
"\n"
"    # In any code that we call is now possible to get\n"
"    # client's address by calling 'client_addr_var.get()'.\n"
"\n"
"    while True:\n"
"        line = await reader.readline()\n"
"        print(line)\n"
"        if not line.strip():\n"
"            break\n"
"\n"
"    writer.write(b'HTTP/1.1 200 OK\\r\\n')  # status line\n"
"    writer.write(b'\\r\\n')  # headers\n"
"    writer.write(render_goodbye())  # body\n"
"    writer.close()\n"
"\n"
"async def main():\n"
"    srv = await asyncio.start_server(\n"
"        handle_request, '127.0.0.1', 8081)\n"
"\n"
"    async with srv:\n"
"        await srv.serve_forever()\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# To test it you can use telnet or curl:\n"
"#     telnet 127.0.0.1 8081\n"
"#     curl 127.0.0.1:8081"
msgstr ""
"import asyncio\n"
"import contextvars\n"
"\n"
"client_addr_var = contextvars.ContextVar('client_addr')\n"
"\n"
"def render_goodbye():\n"
"    # The address of the currently handled client can be accessed\n"
"    # without passing it explicitly to this function.\n"
"\n"
"    client_addr = client_addr_var.get()\n"
"    return f'Good bye, client @ {client_addr}\\r\\n'.encode()\n"
"\n"
"async def handle_request(reader, writer):\n"
"    addr = writer.transport.get_extra_info('socket').getpeername()\n"
"    client_addr_var.set(addr)\n"
"\n"
"    # In any code that we call is now possible to get\n"
"    # client's address by calling 'client_addr_var.get()'.\n"
"\n"
"    while True:\n"
"        line = await reader.readline()\n"
"        print(line)\n"
"        if not line.strip():\n"
"            break\n"
"\n"
"    writer.write(b'HTTP/1.1 200 OK\\r\\n')  # status line\n"
"    writer.write(b'\\r\\n')  # headers\n"
"    writer.write(render_goodbye())  # body\n"
"    writer.close()\n"
"\n"
"async def main():\n"
"    srv = await asyncio.start_server(\n"
"        handle_request, '127.0.0.1', 8081)\n"
"\n"
"    async with srv:\n"
"        await srv.serve_forever()\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# To test it you can use telnet or curl:\n"
"#     telnet 127.0.0.1 8081\n"
"#     curl 127.0.0.1:8081"
