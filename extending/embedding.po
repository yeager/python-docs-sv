# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Embedding Python in Another Application"
msgstr "Bädda in Python i en annan applikation"

msgid ""
"The previous chapters discussed how to extend Python, that is, how to extend "
"the functionality of Python by attaching a library of C functions to it.  It "
"is also possible to do it the other way around: enrich your C/C++ "
"application by embedding Python in it.  Embedding provides your application "
"with the ability to implement some of the functionality of your application "
"in Python rather than C or C++. This can be used for many purposes; one "
"example would be to allow users to tailor the application to their needs by "
"writing some scripts in Python.  You can also use it yourself if some of the "
"functionality can be written in Python more easily."
msgstr ""
"I de föregående kapitlen diskuterades hur man utökar Python, det vill säga "
"hur man utökar Pythons funktionalitet genom att koppla ett bibliotek med C-"
"funktioner till det.  Det är också möjligt att göra tvärtom: berika din C/C+"
"+-applikation genom att bädda in Python i den.  Inbäddning ger din "
"applikation möjlighet att implementera en del av funktionaliteten i din "
"applikation i Python snarare än i C eller C++. Detta kan användas för många "
"ändamål; ett exempel skulle kunna vara att låta användarna skräddarsy "
"applikationen efter sina behov genom att skriva några skript i Python.  Du "
"kan också använda det själv om en del av funktionaliteten lättare kan "
"skrivas i Python."

msgid ""
"Embedding Python is similar to extending it, but not quite.  The difference "
"is that when you extend Python, the main program of the application is still "
"the Python interpreter, while if you embed Python, the main program may have "
"nothing to do with Python --- instead, some parts of the application "
"occasionally call the Python interpreter to run some Python code."
msgstr ""
"Att bädda in Python liknar att utöka det, men inte riktigt.  Skillnaden är "
"att när du utökar Python är applikationens huvudprogram fortfarande Python-"
"tolken, medan om du bäddar in Python kanske huvudprogrammet inte har något "
"att göra med Python --- istället kallar vissa delar av applikationen ibland "
"Python-tolken för att köra lite Python-kod."

msgid ""
"So if you are embedding Python, you are providing your own main program.  "
"One of the things this main program has to do is initialize the Python "
"interpreter.  At the very least, you have to call the function :c:func:"
"`Py_Initialize`.  There are optional calls to pass command line arguments to "
"Python.  Then later you can call the interpreter from any part of the "
"application."
msgstr ""
"Så om du bäddar in Python tillhandahåller du ditt eget huvudprogram.  En av "
"de saker som detta huvudprogram måste göra är att initiera Python-tolken.  "
"Åtminstone måste du anropa funktionen :c:func:`Py_Initialize`.  Det finns "
"valfria anrop för att skicka kommandoradsargument till Python.  Senare kan "
"du anropa tolken från vilken del som helst av programmet."

msgid ""
"There are several different ways to call the interpreter: you can pass a "
"string containing Python statements to :c:func:`PyRun_SimpleString`, or you "
"can pass a stdio file pointer and a file name (for identification in error "
"messages only) to :c:func:`PyRun_SimpleFile`.  You can also call the lower-"
"level operations described in the previous chapters to construct and use "
"Python objects."
msgstr ""
"Det finns flera olika sätt att anropa tolken: du kan skicka en sträng som "
"innehåller Python-satser till :c:func:`PyRun_SimpleString`, eller så kan du "
"skicka en stdio-filpekare och ett filnamn (endast för identifiering i "
"felmeddelanden) till :c:func:`PyRun_SimpleFile`.  Du kan också anropa de "
"operationer på lägre nivå som beskrivs i de föregående kapitlen för att "
"konstruera och använda Python-objekt."

msgid ":ref:`c-api-index`"
msgstr ":ref:`c-api-index`"

msgid ""
"The details of Python's C interface are given in this manual. A great deal "
"of necessary information can be found here."
msgstr ""
"Detaljerna i Pythons C-gränssnitt beskrivs i den här handboken. En stor del "
"av den nödvändiga informationen finns här."

msgid "Very High Level Embedding"
msgstr "Inbäddning på mycket hög nivå"

msgid ""
"The simplest form of embedding Python is the use of the very high level "
"interface. This interface is intended to execute a Python script without "
"needing to interact with the application directly. This can for example be "
"used to perform some operation on a file. ::"
msgstr ""
"Den enklaste formen av Python-inbäddning är att använda ett gränssnitt på "
"mycket hög nivå. Detta gränssnitt är avsett att exekvera ett Python-skript "
"utan att behöva interagera med applikationen direkt. Detta kan t.ex. "
"användas för att utföra någon operation på en fil:"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* optional but recommended */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, "
"argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    PyRun_SimpleString(\"from time import time,ctime\\n\"\n"
"                       \"print('Today is', ctime(time()))\\n\");\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        exit(120);\n"
"    }\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#inkludera <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* valfritt men rekommenderas */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, "
"argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto undantag;\n"
"    }\n"
"\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        gå till undantaget;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    PyRun_SimpleString(\"from time import time,ctime\\n\"\n"
"                       \"print('Idag är', ctime(time()))\\n\");\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        exit(120);\n"
"    }\n"
"    return 0;\n"
"\n"
"  undantag:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"

msgid ""
"``#define PY_SSIZE_T_CLEAN`` was used to indicate that ``Py_ssize_t`` should "
"be used in some APIs instead of ``int``. It is not necessary since Python "
"3.13, but we keep it here for backward compatibility. See :ref:`arg-parsing-"
"string-and-buffers` for a description of this macro."
msgstr ""
"``#define PY_SSIZE_T_CLEAN`` användes för att indikera att ``Py_ssize_t`` "
"skulle användas i vissa API:er istället för ``int``. Det är inte nödvändigt "
"sedan Python 3.13, men vi behåller det här för bakåtkompatibilitet. Se :ref:"
"`arg-parsing-string-and-buffers` för en beskrivning av detta makro."

msgid ""
"Setting :c:member:`PyConfig.program_name` should be called before :c:func:"
"`Py_InitializeFromConfig` to inform the interpreter about paths to Python "
"run-time libraries.  Next, the Python interpreter is initialized with :c:"
"func:`Py_Initialize`, followed by the execution of a hard-coded Python "
"script that prints the date and time.  Afterwards, the :c:func:"
"`Py_FinalizeEx` call shuts the interpreter down, followed by the end of the "
"program.  In a real program, you may want to get the Python script from "
"another source, perhaps a text-editor routine, a file, or a database.  "
"Getting the Python code from a file can better be done by using the :c:func:"
"`PyRun_SimpleFile` function, which saves you the trouble of allocating "
"memory space and loading the file contents."
msgstr ""
"Inställningen :c:member:`PyConfig.program_name` bör anropas före :c:func:"
"`Py_InitializeFromConfig` för att informera tolken om sökvägar till Pythons "
"run-time-bibliotek.  Därefter initieras Python-tolken med :c:func:"
"`Py_Initialize`, följt av exekveringen av ett hårdkodat Python-skript som "
"skriver ut datum och tid.  Därefter stänger anropet :c:func:`Py_FinalizeEx` "
"av tolken, följt av slutet på programmet.  I ett riktigt program kanske du "
"vill hämta Python-skriptet från en annan källa, kanske en "
"textredigeringsrutin, en fil eller en databas.  Det är lättare att hämta "
"Python-koden från en fil genom att använda funktionen :c:func:"
"`PyRun_SimpleFile`, som sparar dig besväret med att allokera minnesutrymme "
"och ladda filens innehåll."

msgid "Beyond Very High Level Embedding: An overview"
msgstr "Bortom inbäddning på mycket hög nivå: En översikt"

msgid ""
"The high level interface gives you the ability to execute arbitrary pieces "
"of Python code from your application, but exchanging data values is quite "
"cumbersome to say the least. If you want that, you should use lower level "
"calls. At the cost of having to write more C code, you can achieve almost "
"anything."
msgstr ""
"Högnivågränssnittet ger dig möjlighet att exekvera godtyckliga bitar av "
"Python-kod från din applikation, men att utbyta datavärden är minst sagt "
"besvärligt. Om du vill ha det bör du använda anrop på lägre nivå. På "
"bekostnad av att behöva skriva mer C-kod kan du uppnå nästan vad som helst."

msgid ""
"It should be noted that extending Python and embedding Python is quite the "
"same activity, despite the different intent. Most topics discussed in the "
"previous chapters are still valid. To show this, consider what the extension "
"code from Python to C really does:"
msgstr ""
"Det bör noteras att utöka Python och bädda in Python är ganska samma "
"aktivitet, trots den olika avsikten. De flesta ämnen som diskuterats i de "
"tidigare kapitlen är fortfarande giltiga. För att visa detta kan du fundera "
"på vad förlängningskoden från Python till C verkligen gör:"

msgid "Convert data values from Python to C,"
msgstr "Konvertera datavärden från Python till C,"

msgid "Perform a function call to a C routine using the converted values, and"
msgstr ""
"Utföra ett funktionsanrop till en C-rutin med hjälp av de konverterade "
"värdena, och"

msgid "Convert the data values from the call from C to Python."
msgstr "Konvertera datavärdena från anropet från C till Python."

msgid "When embedding Python, the interface code does:"
msgstr "Vid inbäddning av Python gör gränssnittskoden det:"

msgid "Convert data values from C to Python,"
msgstr "Konvertera datavärden från C till Python,"

msgid ""
"Perform a function call to a Python interface routine using the converted "
"values, and"
msgstr ""
"Utföra ett funktionsanrop till en Python-gränssnittsrutin med hjälp av de "
"konverterade värdena, och"

msgid "Convert the data values from the call from Python to C."
msgstr "Konvertera datavärdena från anropet från Python till C."

msgid ""
"As you can see, the data conversion steps are simply swapped to accommodate "
"the different direction of the cross-language transfer. The only difference "
"is the routine that you call between both data conversions. When extending, "
"you call a C routine, when embedding, you call a Python routine."
msgstr ""
"Som du kan se byts datakonverteringsstegen helt enkelt ut för att passa den "
"olika riktningen för överföringen mellan språken. Den enda skillnaden är den "
"rutin som du anropar mellan de båda datakonverteringarna. Vid förlängning "
"anropar du en C-rutin, vid inbäddning anropar du en Python-rutin."

msgid ""
"This chapter will not discuss how to convert data from Python to C and vice "
"versa.  Also, proper use of references and dealing with errors is assumed to "
"be understood.  Since these aspects do not differ from extending the "
"interpreter, you can refer to earlier chapters for the required information."
msgstr ""
"Detta kapitel kommer inte att diskutera hur man konverterar data från Python "
"till C och vice versa.  Även korrekt användning av referenser och hantering "
"av fel förutsätts vara förstått.  Eftersom dessa aspekter inte skiljer sig "
"från att utöka tolken, kan du hänvisa till tidigare kapitel för den "
"information som krävs."

msgid "Pure Embedding"
msgstr "Ren inbäddning"

msgid ""
"The first program aims to execute a function in a Python script. Like in the "
"section about the very high level interface, the Python interpreter does not "
"directly interact with the application (but that will change in the next "
"section)."
msgstr ""
"Det första programmet syftar till att exekvera en funktion i ett Python-"
"skript. Precis som i avsnittet om gränssnittet på mycket hög nivå "
"interagerar Python-tolken inte direkt med programmet (men det kommer att "
"ändras i nästa avsnitt)."

msgid "The code to run a function defined in a Python script is:"
msgstr "Koden för att köra en funktion som definieras i ett Python-skript är:"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyObject *pName, *pModule, *pFunc;\n"
"    PyObject *pArgs, *pValue;\n"
"    int i;\n"
"\n"
"    if (argc < 3) {\n"
"        fprintf(stderr,\"Usage: call pythonfile funcname [args]\\n\");\n"
"        return 1;\n"
"    }\n"
"\n"
"    Py_Initialize();\n"
"    pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"    /* Error checking of pName left out */\n"
"\n"
"    pModule = PyImport_Import(pName);\n"
"    Py_DECREF(pName);\n"
"\n"
"    if (pModule != NULL) {\n"
"        pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"        /* pFunc is a new reference */\n"
"\n"
"        if (pFunc && PyCallable_Check(pFunc)) {\n"
"            pArgs = PyTuple_New(argc - 3);\n"
"            for (i = 0; i < argc - 3; ++i) {\n"
"                pValue = PyLong_FromLong(atoi(argv[i + 3]));\n"
"                if (!pValue) {\n"
"                    Py_DECREF(pArgs);\n"
"                    Py_DECREF(pModule);\n"
"                    fprintf(stderr, \"Cannot convert argument\\n\");\n"
"                    return 1;\n"
"                }\n"
"                /* pValue reference stolen here: */\n"
"                PyTuple_SetItem(pArgs, i, pValue);\n"
"            }\n"
"            pValue = PyObject_CallObject(pFunc, pArgs);\n"
"            Py_DECREF(pArgs);\n"
"            if (pValue != NULL) {\n"
"                printf(\"Result of call: %ld\\n\", PyLong_AsLong(pValue));\n"
"                Py_DECREF(pValue);\n"
"            }\n"
"            else {\n"
"                Py_DECREF(pFunc);\n"
"                Py_DECREF(pModule);\n"
"                PyErr_Print();\n"
"                fprintf(stderr,\"Call failed\\n\");\n"
"                return 1;\n"
"            }\n"
"        }\n"
"        else {\n"
"            if (PyErr_Occurred())\n"
"                PyErr_Print();\n"
"            fprintf(stderr, \"Cannot find function \\\"%s\\\"\\n\", "
"argv[2]);\n"
"        }\n"
"        Py_XDECREF(pFunc);\n"
"        Py_DECREF(pModule);\n"
"    }\n"
"    else {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Failed to load \\\"%s\\\"\\n\", argv[1]);\n"
"        return 1;\n"
"    }\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        return 120;\n"
"    }\n"
"    return 0;\n"
"}\n"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#inkludera <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyObject *pName, *pModule, *pFunc;\n"
"    PyObject *pArgs, *pValue;\n"
"    int i;\n"
"\n"
"    if (argc < 3) {\n"
"        fprintf(stderr,\"Användning: anropa pythonfil funcname "
"[args]\\n\");\n"
"        return 1;\n"
"    }\n"
"\n"
"    Py_Initialize();\n"
"    pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"    /* Felkontroll av pName utelämnad */\n"
"\n"
"    pModule = PyImport_Import(pName);\n"
"    Py_DECREF(pName);\n"
"\n"
"    if (pModule != NULL) {\n"
"        pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"        /* pFunc är en ny referens */\n"
"\n"
"        if (pFunc && PyCallable_Check(pFunc)) {\n"
"            pArgs = PyTuple_New(argc - 3);\n"
"            for (i = 0; i < argc - 3; ++i) {\n"
"                pValue = PyLong_FromLong(atoi(argv[i + 3]));\n"
"                if (!pValue) {\n"
"                    Py_DECREF(pArgs);\n"
"                    Py_DECREF(pModule);\n"
"                    fprintf(stderr, \"Kan inte konvertera argument\\n\");\n"
"                    return 1;\n"
"                }\n"
"                /* pValue-referensen stulen här: */\n"
"                PyTuple_SetItem(pArgs, i, pValue);\n"
"            }\n"
"            pValue = PyObject_CallObject(pFunc, pArgs);\n"
"            Py_DECREF(pArgs);\n"
"            if (pValue != NULL) {\n"
"                printf(\"Resultat av anrop: %ld\\n\", "
"PyLong_AsLong(pValue));\n"
"                Py_DECREF(pValue);\n"
"            }\n"
"            else {\n"
"                Py_DECREF(pFunc);\n"
"                Py_DECREF(pModule);\n"
"                PyErr_Print();\n"
"                fprintf(stderr,\"Anropet misslyckades\\n\");\n"
"                return 1;\n"
"            }\n"
"        }\n"
"        annat {\n"
"            if (PyErr_Occurred())\n"
"                PyErr_Print();\n"
"            fprintf(stderr, \"Kan inte hitta funktionen \\\"%s\\\"\\n\", "
"argv[2]);\n"
"        }\n"
"        Py_XDECREF(pFunc);\n"
"        Py_DECREF(pModule);\n"
"    }\n"
"    else {\n"
"        PyErr_Print();\n"
"        fprintf(stderr,\"Misslyckades med att ladda \\\"%s\\\"\\n\", "
"argv[1]);\n"
"        return 1;\n"
"    }\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        return 120;\n"
"    }\n"
"    return 0;\n"
"}\n"

msgid ""
"This code loads a Python script using ``argv[1]``, and calls the function "
"named in ``argv[2]``.  Its integer arguments are the other values of the "
"``argv`` array.  If you :ref:`compile and link <compiling>` this program "
"(let's call the finished executable :program:`call`), and use it to execute "
"a Python script, such as:"
msgstr ""
"Den här koden laddar ett Python-skript med hjälp av ``argv[1]`` och anropar "
"funktionen som namnges i ``argv[2]``.  Dess heltalsargument är de andra "
"värdena i ``argv``-arrayen.  Om du :ref:`kompilerar och länkar <compiling>` "
"detta program (låt oss kalla den färdiga körbara filen :program:`call`), och "
"använder den för att köra ett Python-skript, t.ex:"

msgid ""
"def multiply(a,b):\n"
"    print(\"Will compute\", a, \"times\", b)\n"
"    c = 0\n"
"    for i in range(0, a):\n"
"        c = c + b\n"
"    return c"
msgstr ""
"def multiplicera(a,b):\n"
"    print(\"Beräknar\", a, \"gånger\", b)\n"
"    c = 0\n"
"    för i i intervallet(0, a):\n"
"        c = c + b\n"
"    returnerar c"

msgid "then the result should be:"
msgstr "då borde resultatet bli:"

msgid ""
"$ call multiply multiply 3 2\n"
"Will compute 3 times 2\n"
"Result of call: 6"
msgstr ""
"$ samtal multiplicera multiplicera 3 2\n"
"Beräknar 3 gånger 2\n"
"Resultatet av anropet: 6"

msgid ""
"Although the program is quite large for its functionality, most of the code "
"is for data conversion between Python and C, and for error reporting.  The "
"interesting part with respect to embedding Python starts with ::"
msgstr ""
"Även om programmet är ganska stort för sin funktionalitet, är det mesta av "
"koden för datakonvertering mellan Python och C, och för felrapportering.  "
"Den intressanta delen när det gäller inbäddning av Python börjar med ::"

msgid ""
"Py_Initialize();\n"
"pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"/* Error checking of pName left out */\n"
"pModule = PyImport_Import(pName);"
msgstr ""
"Py_Initialize();\n"
"pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"/* Felkontroll av pName utelämnad */\n"
"pModule = PyImport_Import(pName);"

msgid ""
"After initializing the interpreter, the script is loaded using :c:func:"
"`PyImport_Import`.  This routine needs a Python string as its argument, "
"which is constructed using the :c:func:`PyUnicode_DecodeFSDefault` data "
"conversion routine. ::"
msgstr ""
"Efter initiering av tolken laddas skriptet med hjälp av :c:func:"
"`PyImport_Import`.  Denna rutin behöver en Python-sträng som sitt argument, "
"vilken konstrueras med hjälp av datakonverteringsrutinen :c:func:"
"`PyUnicode_DecodeFSDefault`. ::"

msgid ""
"pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"/* pFunc is a new reference */\n"
"\n"
"if (pFunc && PyCallable_Check(pFunc)) {\n"
"    ...\n"
"}\n"
"Py_XDECREF(pFunc);"
msgstr ""
"pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"/* pFunc är en ny referens */\n"
"\n"
"if (pFunc && PyCallable_Check(pFunc)) {\n"
"    ...\n"
"}\n"
"Py_XDECREF(pFunc);"

msgid ""
"Once the script is loaded, the name we're looking for is retrieved using :c:"
"func:`PyObject_GetAttrString`.  If the name exists, and the object returned "
"is callable, you can safely assume that it is a function.  The program then "
"proceeds by constructing a tuple of arguments as normal.  The call to the "
"Python function is then made with::"
msgstr ""
"När skriptet har laddats hämtas det namn vi letar efter med hjälp av :c:func:"
"`PyObject_GetAttrString`.  Om namnet finns och objektet som returneras är "
"anropsbart kan man lugnt anta att det är en funktion.  Programmet fortsätter "
"sedan med att konstruera en tupel av argument som normalt.  Anropet till "
"Python-funktionen görs sedan med::"

msgid "pValue = PyObject_CallObject(pFunc, pArgs);"
msgstr "pValue = PyObject_CallObject(pFunc, pArgs);"

msgid ""
"Upon return of the function, ``pValue`` is either ``NULL`` or it contains a "
"reference to the return value of the function.  Be sure to release the "
"reference after examining the value."
msgstr ""
"När funktionen returneras är ``pValue`` antingen ``NULL`` eller så "
"innehåller den en referens till funktionens returvärde.  Var noga med att "
"släppa referensen efter att ha undersökt värdet."

msgid "Extending Embedded Python"
msgstr "Utökning av inbäddad Python"

msgid ""
"Until now, the embedded Python interpreter had no access to functionality "
"from the application itself.  The Python API allows this by extending the "
"embedded interpreter.  That is, the embedded interpreter gets extended with "
"routines provided by the application. While it sounds complex, it is not so "
"bad.  Simply forget for a while that the application starts the Python "
"interpreter.  Instead, consider the application to be a set of subroutines, "
"and write some glue code that gives Python access to those routines, just "
"like you would write a normal Python extension.  For example::"
msgstr ""
"Fram till nu har den inbäddade Python-tolken inte haft tillgång till "
"funktionalitet från själva applikationen.  Python API tillåter detta genom "
"att utöka den inbäddade tolken.  Det vill säga, den inbäddade tolken utökas "
"med rutiner som tillhandahålls av applikationen. Även om det låter "
"komplicerat är det inte så illa.  Glöm bara för ett tag att applikationen "
"startar Python-tolken.  Betrakta istället applikationen som en uppsättning "
"underrutiner och skriv lite limkod som ger Python tillgång till dessa "
"rutiner, precis som du skulle skriva ett vanligt Python-tillägg.  Till "
"exempel::"

msgid ""
"static int numargs=0;\n"
"\n"
"/* Return the number of arguments of the application command line */\n"
"static PyObject*\n"
"emb_numargs(PyObject *self, PyObject *args)\n"
"{\n"
"    if(!PyArg_ParseTuple(args, \":numargs\"))\n"
"        return NULL;\n"
"    return PyLong_FromLong(numargs);\n"
"}\n"
"\n"
"static PyMethodDef emb_module_methods[] = {\n"
"    {\"numargs\", emb_numargs, METH_VARARGS,\n"
"     \"Return the number of arguments received by the process.\"},\n"
"    {NULL, NULL, 0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef emb_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"emb\",\n"
"    .m_size = 0,\n"
"    .m_methods = emb_module_methods,\n"
"};\n"
"\n"
"static PyObject*\n"
"PyInit_emb(void)\n"
"{\n"
"    return PyModuleDef_Init(&emb_module);\n"
"}"
msgstr ""
"statisk int numargs=0;\n"
"\n"
"/* Returnerar antalet argument i programmets kommandorad */\n"
"statiskt PyObject*\n"
"emb_numargs(PyObject *self, PyObject *args)\n"
"{\n"
"    if(!PyArg_ParseTuple(args, \":numargs\"))\n"
"        returnera NULL;\n"
"    return PyLong_FromLong(numargs);\n"
"}\n"
"\n"
"static PyMethodDef emb_module_methods[] = {\n"
"    {\"numargs\", emb_numargs, METH_VARARGS,\n"
"     \"Returnera antalet argument som processen har tagit emot.\"},\n"
"    {NULL, NULL, 0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef emb_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"emb\",\n"
"    .m_size = 0,\n"
"    .m_methods = emb_module_methods,\n"
"};\n"
"\n"
"statiskt PyObject*\n"
"PyInit_emb(void)\n"
"{\n"
"    return PyModuleDef_Init(&emb_module);\n"
"}"

msgid ""
"Insert the above code just above the :c:func:`main` function. Also, insert "
"the following two statements before the call to :c:func:`Py_Initialize`::"
msgstr ""
"Infoga ovanstående kod precis ovanför funktionen :c:func:`main`. Infoga "
"också följande två satser före anropet till :c:func:`Py_Initialize`::"

msgid ""
"numargs = argc;\n"
"PyImport_AppendInittab(\"emb\", &PyInit_emb);"
msgstr ""
"numargs = argc;\n"
"PyImport_AppendInittab(\"emb\", &PyInit_emb);"

msgid ""
"These two lines initialize the ``numargs`` variable, and make the :func:`!"
"emb.numargs` function accessible to the embedded Python interpreter. With "
"these extensions, the Python script can do things like"
msgstr ""
"Dessa två rader initierar variabeln ``numargs`` och gör funktionen :func:`!"
"emb.numargs`` tillgänglig för den inbäddade Python-tolken. Med dessa tillägg "
"kan Python-skriptet göra saker som"

msgid ""
"import emb\n"
"print(\"Number of arguments\", emb.numargs())"
msgstr ""
"import emb\n"
"print(\"Number of arguments\", emb.numargs())"

msgid ""
"In a real application, the methods will expose an API of the application to "
"Python."
msgstr ""
"I en verklig applikation kommer metoderna att exponera ett API för "
"applikationen till Python."

msgid "Embedding Python in C++"
msgstr "Inbäddning av Python i C++"

msgid ""
"It is also possible to embed Python in a C++ program; precisely how this is "
"done will depend on the details of the C++ system used; in general you will "
"need to write the main program in C++, and use the C++ compiler to compile "
"and link your program.  There is no need to recompile Python itself using C+"
"+."
msgstr ""
"Det är också möjligt att bädda in Python i ett C++-program; exakt hur detta "
"görs beror på detaljerna i det C++-system som används; i allmänhet måste du "
"skriva huvudprogrammet i C++ och använda C++-kompilatorn för att kompilera "
"och länka ditt program.  Det finns inget behov av att kompilera om Python "
"själv med hjälp av C++."

msgid "Compiling and Linking under Unix-like systems"
msgstr "Kompilering och länkning under Unix-liknande system"

msgid ""
"It is not necessarily trivial to find the right flags to pass to your "
"compiler (and linker) in order to embed the Python interpreter into your "
"application, particularly because Python needs to load library modules "
"implemented as C dynamic extensions (:file:`.so` files) linked against it."
msgstr ""
"Det är inte nödvändigtvis trivialt att hitta rätt flaggor att skicka till "
"din kompilator (och länkare) för att bädda in Python-tolken i din "
"applikation, särskilt eftersom Python måste ladda biblioteksmoduler som "
"implementeras som dynamiska C-tillägg (:file:`.so`-filer) länkade mot den."

msgid ""
"To find out the required compiler and linker flags, you can execute the :"
"file:`python{X.Y}-config` script which is generated as part of the "
"installation process (a :file:`python3-config` script may also be "
"available).  This script has several options, of which the following will be "
"directly useful to you:"
msgstr ""
"För att ta reda på vilka kompilator- och länkarflaggor som krävs kan du köra "
"skriptet :file:`python{X.Y}-config` som genereras som en del av "
"installationsprocessen (ett skript :file:`python3-config` kan också finnas "
"tillgängligt).  Detta skript har flera alternativ, av vilka följande kommer "
"att vara direkt användbara för dig:"

msgid ""
"``pythonX.Y-config --cflags`` will give you the recommended flags when "
"compiling:"
msgstr ""
"``pythonX.Y-config --cflags`` kommer att ge dig de rekommenderade flaggorna "
"vid kompilering:"

msgid ""
"$ /opt/bin/python3.11-config --cflags\n"
"-I/opt/include/python3.11 -I/opt/include/python3.11 -Wsign-compare  -DNDEBUG "
"-g -fwrapv -O3 -Wall"
msgstr ""
"$ /opt/bin/python3.11-config --cflags\n"
"-I/opt/include/python3.11 -I/opt/include/python3.11 -Wsign-compare -DNDEBUG -"
"g -fwrapv -O3 -Wall"

msgid ""
"``pythonX.Y-config --ldflags --embed`` will give you the recommended flags "
"when linking:"
msgstr ""
"``pythonX.Y-config --ldflags --embed`` kommer att ge dig de rekommenderade "
"flaggorna när du länkar:"

msgid ""
"$ /opt/bin/python3.11-config --ldflags --embed\n"
"-L/opt/lib/python3.11/config-3.11-x86_64-linux-gnu -L/opt/lib -lpython3.11 -"
"lpthread -ldl  -lutil -lm"
msgstr ""
"$ /opt/bin/python3.11-config --ldflags --embed\n"
"-L/opt/lib/python3.11/config-3.11-x86_64-linux-gnu -L/opt/lib -lpython3.11 -"
"lpthread -ldl -lutil -lm"

msgid ""
"To avoid confusion between several Python installations (and especially "
"between the system Python and your own compiled Python), it is recommended "
"that you use the absolute path to :file:`python{X.Y}-config`, as in the "
"above example."
msgstr ""
"För att undvika förväxling mellan olika Python-installationer (och särskilt "
"mellan systemets Python och ditt eget kompilerade Python) rekommenderas att "
"du använder den absoluta sökvägen till :file:`python{X.Y}-config`, som i "
"exemplet ovan."

msgid ""
"If this procedure doesn't work for you (it is not guaranteed to work for all "
"Unix-like platforms; however, we welcome :ref:`bug reports <reporting-"
"bugs>`) you will have to read your system's documentation about dynamic "
"linking and/or examine Python's :file:`Makefile` (use :func:`sysconfig."
"get_makefile_filename` to find its location) and compilation options.  In "
"this case, the :mod:`sysconfig` module is a useful tool to programmatically "
"extract the configuration values that you will want to combine together.  "
"For example:"
msgstr ""
"Om den här proceduren inte fungerar för dig (det är inte garanterat att den "
"fungerar för alla Unix-liknande plattformar; vi välkomnar dock :ref:`bug "
"reports <reporting-bugs>`) måste du läsa ditt systems dokumentation om "
"dynamisk länkning och/eller undersöka Pythons :file:`Makefile` (använd :func:"
"`sysconfig.get_makefile_filename` för att hitta dess plats) och "
"kompileringsalternativ.  I det här fallet är modulen :mod:`sysconfig` ett "
"användbart verktyg för att programmatiskt extrahera de konfigurationsvärden "
"som du vill kombinera tillsammans.  Till exempel"

msgid ""
">>> import sysconfig\n"
">>> sysconfig.get_config_var('LIBS')\n"
"'-lpthread -ldl  -lutil'\n"
">>> sysconfig.get_config_var('LINKFORSHARED')\n"
"'-Xlinker -export-dynamic'"
msgstr ""
">>> import sysconfig\n"
">>> sysconfig.get_config_var('LIBS')\n"
"'-lpthread -ldl -lutil'\n"
">>> sysconfig.get_config_var('LINKFORSHARED')\n"
"'-Xlinker -export-dynamisk'"
