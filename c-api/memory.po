# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Memory Management"
msgstr "Minneshantering"

msgid "Overview"
msgstr "Översikt"

msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Minneshantering i Python innebär en privat hög som innehåller alla Python-"
"objekt och datastrukturer. Hanteringen av denna privata hög sköts internt av "
"*Pythons minneshanterare*.  Pythons minneshanterare har olika komponenter "
"som hanterar olika aspekter av dynamisk lagringshantering, t.ex. delning, "
"segmentering, förallokering eller cachning."

msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"På den lägsta nivån ser en råminnesallokerare till att det finns "
"tillräckligt med utrymme i den privata heapen för att lagra alla Python-"
"relaterade data genom att interagera med operativsystemets minneshanterare. "
"Utöver råminnesallokeringen arbetar flera objektspecifika allokeringar på "
"samma hög och implementerar olika minneshanteringspolicyer som är anpassade "
"till varje objekttyps särdrag. Exempelvis hanteras heltalsobjekt annorlunda "
"i heapen än strängar, tupler eller dictionaries eftersom heltal innebär "
"olika lagringskrav och avvägningar mellan hastighet och utrymme. Pythons "
"minneshanterare delegerar således en del av arbetet till de objektspecifika "
"allokeringarna, men ser till att de senare arbetar inom gränserna för den "
"privata heapen."

msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other "
"internal buffers is performed on demand by the Python memory manager through "
"the Python/C API functions listed in this document."
msgstr ""
"Det är viktigt att förstå att hanteringen av Pythons heap utförs av tolken "
"själv och att användaren inte har någon kontroll över den, även om de "
"regelbundet manipulerar objektpekare till minnesblock inuti heapen.  "
"Allokeringen av heaputrymme för Python-objekt och andra interna buffertar "
"utförs på begäran av Pythons minneshanterare genom de Python/C API-"
"funktioner som listas i detta dokument."

msgid ""
"To avoid memory corruption, extension writers should never try to operate on "
"Python objects with the functions exported by the C library: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  This will "
"result in  mixed calls between the C allocator and the Python memory manager "
"with fatal consequences, because they implement different algorithms and "
"operate on different heaps.  However, one may safely allocate and release "
"memory blocks with the C library allocator for individual purposes, as shown "
"in the following example::"
msgstr ""
"För att undvika minneskorruption bör författare av tillägg aldrig försöka "
"använda Python-objekt med de funktioner som exporteras av C-biblioteket: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` och :c:func:`free`.  "
"Detta kommer att resultera i blandade anrop mellan C-allokatorn och Pythons "
"minneshanterare med fatala konsekvenser, eftersom de implementerar olika "
"algoritmer och arbetar på olika heaps.  Man kan dock på ett säkert sätt "
"allokera och frigöra minnesblock med C-bibliotekets allokator för "
"individuella ändamål, som visas i följande exempel::"

msgid ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Do some I/O operation involving buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* malloc'ed */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* för I/O */\n"
"\n"
"om (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Gör någon I/O-operation som involverar buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* malloc'ed */\n"
"returnera res;"

msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"I det här exemplet hanteras minnesbegäran för I/O-bufferten av C-"
"bibliotekets allokator. Pythons minneshanterare är endast involverad i "
"allokeringen av bytesobjektet som returneras som ett resultat."

msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used "
"exclusively for internal, highly specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"I de flesta situationer är det dock rekommenderat att allokera minne från "
"Pythons heap, just för att den senare står under kontroll av Pythons "
"minneshanterare. Detta krävs till exempel när tolken utökas med nya "
"objekttyper skrivna i C. En annan anledning till att använda Python-heapen "
"är önskan att *informera* Pythons minneshanterare om minnesbehoven i "
"tilläggsmodulen. Även när det begärda minnet uteslutande används för "
"interna, mycket specifika ändamål, leder delegeringen av alla "
"minnesförfrågningar till Pythons minneshanterare till att tolken får en mer "
"exakt bild av sitt minnesavtryck som helhet. Följaktligen kan Pythons "
"minneshanterare under vissa omständigheter utlösa lämpliga åtgärder, t.ex. "
"sopsortering, minneskomprimering eller andra förebyggande åtgärder. "
"Observera att genom att använda C-bibliotekets allokator som visas i "
"föregående exempel, undgår det allokerade minnet för I/O-bufferten helt "
"Pythons minneshanterare."

msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the "
"memory allocators used by Python."
msgstr ""
"Miljövariabeln :envvar:`PYTHONMALLOC` kan användas för att konfigurera de "
"minnesallokatorer som används av Python."

msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"Miljövariabeln :envvar:`PYTHONMALLOCSTATS` kan användas för att skriva ut "
"statistik för :ref:`pymalloc memory allocator <pymalloc>` varje gång en ny "
"pymalloc-objektarena skapas och vid avstängning."

msgid "Allocator Domains"
msgstr "Domäner för allokering"

msgid ""
"All allocating functions belong to one of three different \"domains\" (see "
"also :c:type:`PyMemAllocatorDomain`). These domains represent different "
"allocation strategies and are optimized for different purposes. The specific "
"details on how every domain allocates memory or what internal functions each "
"domain calls is considered an implementation detail, but for debugging "
"purposes a simplified table can be found at :ref:`here <default-memory-"
"allocators>`. The APIs used to allocate and free a block of memory must be "
"from the same domain. For example, :c:func:`PyMem_Free` must be used to free "
"memory allocated using :c:func:`PyMem_Malloc`."
msgstr ""
"Alla allokeringsfunktioner tillhör en av tre olika \"domäner\" (se även :c:"
"type:`PyMemAllocatorDomain`). Dessa domäner representerar olika "
"allokeringsstrategier och är optimerade för olika ändamål. De specifika "
"detaljerna om hur varje domän allokerar minne eller vilka interna funktioner "
"som varje domän anropar anses vara en implementationsdetalj, men för "
"felsökningsändamål finns en förenklad tabell på :ref:`here <default-memory-"
"allocators>`. De API:er som används för att allokera och frigöra ett "
"minnesblock måste vara från samma domän. Till exempel måste :c:func:"
"`PyMem_Free` användas för att frigöra minne som allokerats med :c:func:"
"`PyMem_Malloc`."

msgid "The three allocation domains are:"
msgstr "De tre tilldelningsdomänerna är:"

msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where the "
"allocator can operate without an :term:`attached thread state`. The memory "
"is requested directly from the system. See :ref:`Raw Memory Interface <raw-"
"memoryinterface>`."
msgstr ""
"Rå domän: avsedd för allokering av minne för allmänna minnesbuffertar där "
"allokeringen *måste* gå till systemets allokator eller där allokatorn kan "
"fungera utan ett :term:`attached thread state`. Minnet begärs direkt från "
"systemet. Se :ref:``Raw Memory Interface <raw-memoryinterface>`."

msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed with "
"an :term:`attached thread state`. The memory is taken from the Python "
"private heap. See :ref:`Memory Interface <memoryinterface>`."
msgstr ""
"\"Mem\"-domän: avsedd för allokering av minne för Python-buffertar och "
"allmänna minnesbuffertar där allokeringen måste utföras med en :term:"
"`attached thread state`. Minnet tas från Pythons privata heap. Se :ref:"
"``Memory Interface <memoryinterface>`."

msgid ""
"Object domain: intended for allocating memory for Python objects. The memory "
"is taken from the Python private heap. See :ref:`Object allocators "
"<objectinterface>`."
msgstr ""
"Objektdomän: avsedd för att allokera minne för Python-objekt. Minnet tas "
"från Pythons privata heap. Se :ref:`Objektallokatorer <objectinterface>`."

msgid ""
"The :term:`free-threaded <free threading>` build requires that only Python "
"objects are allocated using the \"object\" domain and that all Python "
"objects are allocated using that domain. This differs from the prior Python "
"versions, where this was only a best practice and not a hard requirement."
msgstr ""
"Bygget :term:``free-threaded <free threading>` kräver att endast Python-"
"objekt allokeras med hjälp av domänen \"object\" och att alla Python-objekt "
"allokeras med hjälp av den domänen. Detta skiljer sig från de tidigare "
"Python-versionerna, där detta endast var en bästa praxis och inte ett hårt "
"krav."

msgid ""
"For example, buffers (non-Python objects) should be allocated using :c:func:"
"`PyMem_Malloc`, :c:func:`PyMem_RawMalloc`, or :c:func:`malloc`, but not :c:"
"func:`PyObject_Malloc`."
msgstr ""
"Till exempel bör buffertar (icke-Python-objekt) allokeras med :c:func:"
"`PyMem_Malloc`, :c:func:`PyMem_RawMalloc` eller :c:func:`malloc`, men inte "
"med :c:func:`PyObject_Malloc`."

msgid "See :ref:`Memory Allocation APIs <free-threaded-memory-allocation>`."
msgstr "Se :ref:`Memory Allocation APIs <free-threaded-memory-allocation>`."

msgid "Raw Memory Interface"
msgstr "Gränssnitt för råminne"

msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, so a :term:`thread state` does not need to be :"
"term:`attached <attached thread state>`."
msgstr ""
"Följande funktionsuppsättningar är omslag till systemallokatorn. Dessa "
"funktioner är tråd-säkra, så en :term:`thread state` behöver inte vara :term:"
"`attached <attached thread state>`."

msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the "
"following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`!free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when "
"requesting zero bytes."
msgstr ""
":ref:``standard rå minnesallokering <default-memory-allocators>`` använder "
"följande funktioner: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"och :c:func:`!free`; anropa ``malloc(1)`` (eller ``calloc(1, 1)``) när du "
"begär noll byte."

msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"Allokerar *n* byte och returnerar en pekare av typen :c:expr:`void*` till "
"det allokerade minnet, eller ``NULL`` om begäran misslyckas."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"En begäran om noll bytes returnerar en distinkt pekare som inte är ``NULL`` "
"om möjligt, som om ``PyMem_RawMalloc(1)`` hade anropats istället. Minnet "
"kommer inte att ha initialiserats på något sätt."

msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:expr:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"Allokerar *nelem* element vars storlek i byte är *elsize* och returnerar en "
"pekare av typen :c:expr:`void*` till det allokerade minnet, eller ``NULL`` "
"om begäran misslyckas. Minnet initialiseras till nollor."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Om man begär noll element eller element med storleken noll bytes returneras "
"en distinkt icke-``NULL`` pekare om möjligt, som om ``PyMem_RawCalloc(1, "
"1)`` hade anropats istället."

msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Ändrar storlek på minnesblocket som pekas ut av *p* till *n* byte. "
"Innehållet kommer att vara oförändrat till det minsta av den gamla och den "
"nya storleken."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Om *p* är ``NULL`` motsvarar anropet ``PyMem_RawMalloc(n)``; om *n* är lika "
"med noll ändras minnesblockets storlek men det frigörs inte och den "
"returnerade pekaren är inte ``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:func:"
"`PyMem_RawCalloc`."
msgstr ""
"Om inte *p* är ``NULL`` måste den ha returnerats av ett tidigare anrop till :"
"c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` eller :c:func:"
"`PyMem_RawCalloc`."

msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Om begäran misslyckas returnerar :c:func:`PyMem_RawRealloc` ``NULL`` och *p* "
"förblir en giltig pekare till det föregående minnesområdet."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:"
"func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Frigör minnesblocket som pekas ut av *p*, vilket måste ha returnerats av ett "
"tidigare anrop till :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` "
"eller :c:func:`PyMem_RawCalloc`.  Annars, eller om ``PyMem_RawFree(p)`` har "
"anropats tidigare, uppstår ett odefinierat beteende."

msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Om *p* är ``NULL`` utförs ingen åtgärd."

msgid "Memory Interface"
msgstr "Minnesgränssnitt"

msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating "
"and releasing memory from the Python heap."
msgstr ""
"Följande funktionsuppsättningar, som är modellerade efter ANSI C-standarden, "
"men som specificerar beteendet när noll byte begärs, är tillgängliga för att "
"allokera och frigöra minne från Pythons heap."

msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"I :ref:``default memory allocator <default-memory-allocators>` används :ref:"
"`pymalloc memory allocator <pymalloc>`."

msgid ""
"There must be an :term:`attached thread state` when using these functions."
msgstr ""
"Det måste finnas en :term:`attached thread state` när dessa funktioner "
"används."

msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"Standardallokeraren är nu pymalloc istället för system :c:func:`malloc`."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"En begäran om noll bytes returnerar en distinkt pekare som inte är ``NULL`` "
"om möjligt, som om ``PyMem_Malloc(1)`` hade anropats istället. Minnet kommer "
"inte att ha initialiserats på något sätt."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Om man begär noll element eller element med storleken noll bytes returneras "
"en distinkt icke-``NULL`` pekare om möjligt, som om ``PyMem_Calloc(1, 1)`` "
"hade anropats istället."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Om *p* är ``NULL`` motsvarar anropet ``PyMem_Malloc(n)``; om *n* är lika med "
"noll ändras minnesblockets storlek men det frigörs inte och den returnerade "
"pekaren är inte ``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"Om inte *p* är ``NULL`` måste den ha returnerats av ett tidigare anrop till :"
"c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` eller :c:func:`PyMem_Calloc`."

msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Om begäran misslyckas returnerar :c:func:`PyMem_Realloc` ``NULL`` och *p* "
"förblir en giltig pekare till det föregående minnesområdet."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:"
"`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called before, "
"undefined behavior occurs."
msgstr ""
"Frigör minnesblocket som pekas ut av *p*, vilket måste ha returnerats av ett "
"tidigare anrop till :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` eller :c:"
"func:`PyMem_Calloc`.  Annars, eller om ``PyMem_Free(p)`` har anropats "
"tidigare, uppstår ett odefinierat beteende."

msgid ""
"The following type-oriented macros are provided for convenience.  Note  that "
"*TYPE* refers to any C type."
msgstr ""
"Följande typorienterade makron tillhandahålls för enkelhetens skull.  "
"Observera att *TYPE* hänvisar till vilken C-typ som helst."

msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to ``TYPE*``.  The memory will not have "
"been initialized in any way."
msgstr ""
"Samma som :c:func:`PyMem_Malloc`, men allokerar ``(n * sizeof(TYPE))`` bytes "
"minne.  Returnerar en pekare som kastas till ``TYPE*``.  Minnet kommer inte "
"att ha initialiserats på något sätt."

msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to ``TYPE*``. On return, *p* "
"will be a pointer to the new memory area, or ``NULL`` in the event of "
"failure."
msgstr ""
"Samma som :c:func:`PyMem_Realloc`, men minnesblocket ändras till ``(n * "
"sizeof(TYPE))`` bytes.  Returnerar en pekare som kastats till ``TYPE*``. Vid "
"retur kommer *p* att vara en pekare till det nya minnesområdet, eller "
"``NULL`` i händelse av fel."

msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original "
"value of *p* to avoid losing memory when handling errors."
msgstr ""
"Detta är ett C preprocessormakro; *p* är alltid återtilldelad.  Spara "
"originalvärdet för *p* för att undvika minnesförlust vid felhantering."

msgid "Same as :c:func:`PyMem_Free`."
msgstr "Samma som :c:func:`PyMem_Free`."

msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Dessutom finns följande makrouppsättningar för att anropa Pythons "
"minnesallokator direkt, utan att involvera C API-funktionerna som listas "
"ovan. Observera dock att användningen av dessa inte bevarar binär "
"kompatibilitet mellan olika Python-versioner och därför inte rekommenderas i "
"tilläggsmoduler."

msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(storlek)``"

msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(typ, storlek)```"

msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, storlek)```"

msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, typ, storlek)```"

msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

msgid "Object allocators"
msgstr "Objektallokatorer"

msgid ""
"There is no guarantee that the memory returned by these allocators can be "
"successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""
"Det finns ingen garanti för att det minne som returneras av dessa "
"allokeringsfunktioner framgångsrikt kan kastas till ett Python-objekt när "
"man avlyssnar allokeringsfunktionerna i den här domänen med de metoder som "
"beskrivs i avsnittet :ref:``Customize Memory Allocators <customize-memory-"
"allocators>``."

msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"I :ref:``default object allocator <default-memory-allocators>` används :ref:"
"``pymalloc memory allocator <pymalloc>`."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Om noll bytes begärs returneras en distinkt icke-``NULL`` pekare om möjligt, "
"som om ``PyObject_Malloc(1)`` hade anropats istället. Minnet kommer inte att "
"ha initialiserats på något sätt."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Om man begär noll element eller element med storleken noll bytes returneras "
"en distinkt icke-``NULL`` pekare om möjligt, som om ``PyObject_Calloc(1, "
"1)`` hade anropats istället."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Om *p* är ``NULL`` motsvarar anropet ``PyObject_Malloc(n)``; om *n* är lika "
"med noll ändras minnesblockets storlek men det frigörs inte och den "
"returnerade pekaren är inte ``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:func:"
"`PyObject_Calloc`."
msgstr ""
"Om inte *p* är ``NULL`` måste den ha returnerats av ett tidigare anrop till :"
"c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` eller :c:func:"
"`PyObject_Calloc`."

msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Om begäran misslyckas returnerar :c:func:`PyObject_Realloc` ``NULL`` och *p* "
"förblir en giltig pekare till det tidigare minnesområdet."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:"
"func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Frigör minnesblocket som pekas ut av *p*, vilket måste ha returnerats av ett "
"tidigare anrop till :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` "
"eller :c:func:`PyObject_Calloc`.  Annars, eller om ``PyObject_Free(p)`` har "
"anropats tidigare, uppstår ett odefinierat beteende."

msgid ""
"Do not call this directly to free an object's memory; call the type's :c:"
"member:`~PyTypeObject.tp_free` slot instead."
msgstr ""
"Anropa inte detta direkt för att frigöra ett objekts minne; anropa istället "
"typens :c:member:`~PyTypeObject.tp_free` slot."

msgid ""
"Do not use this for memory allocated by :c:macro:`PyObject_GC_New` or :c:"
"macro:`PyObject_GC_NewVar`; use :c:func:`PyObject_GC_Del` instead."
msgstr ""
"Använd inte detta för minne som allokerats av :c:macro:`PyObject_GC_New` "
"eller :c:macro:`PyObject_GC_NewVar`; använd istället :c:func:"
"`PyObject_GC_Del`."

msgid ""
":c:func:`PyObject_GC_Del` is the equivalent of this function for memory "
"allocated by types that support garbage collection."
msgstr ""
":c:func:`PyObject_GC_Del` är motsvarigheten till denna funktion för minne "
"som allokerats av typer som stöder garbage collection."

msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

msgid ":c:macro:`PyObject_New`"
msgstr ":c:makro:`PyObject_New`"

msgid ":c:macro:`PyObject_NewVar`"
msgstr ":c:makro:`PyObject_NewVar`"

msgid ":c:func:`PyType_GenericAlloc`"
msgstr ":c:func:`PyType_GenericAlloc`"

msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

msgid "Default Memory Allocators"
msgstr "Standard minnesallokatorer"

msgid "Default memory allocators:"
msgstr "Standardminnesallokatorer:"

msgid "Configuration"
msgstr "Konfiguration"

msgid "Name"
msgstr "Namn"

msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

msgid "Release build"
msgstr "Release-version"

msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

msgid "``malloc``"
msgstr "``malloc``"

msgid "``pymalloc``"
msgstr "``pymalloc``"

msgid "Debug build"
msgstr "Felsök byggnaden"

msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

msgid "``malloc`` + debug"
msgstr "``malloc`` + felsökning"

msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + felsökning"

msgid "Release build, without pymalloc"
msgstr "Release-version, utan pymalloc"

msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

msgid "Debug build, without pymalloc"
msgstr "Felsökning, utan pymalloc"

msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

msgid "Legend:"
msgstr "Legend:"

msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "Namn: värde för miljövariabeln :envvar:`PYTHONMALLOC`."

msgid ""
"``malloc``: system allocators from the standard C library, C functions: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``: systemallokatorer från standard C-biblioteket, C-funktioner: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` och :c:func:`free`."

msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`pymalloc minnesallokering <pymalloc>`."

msgid ""
"``mimalloc``: :ref:`mimalloc memory allocator <mimalloc>`.  The pymalloc "
"allocator will be used if mimalloc support isn't available."
msgstr ""
"``mimalloc``: :ref:``mimalloc minnesallokator <mimalloc>`.  Allokeraren "
"pymalloc kommer att användas om stöd för mimalloc inte finns tillgängligt."

msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators <pymem-"
"debug-hooks>`."
msgstr ""
"\"+ debug\": med :ref:`debugkrokar på Pythons minnesallokatorer <pymem-debug-"
"hooks>`."

msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr "\"Debug build\": :ref:`Python byggs i felsökningsläge <debug-build>`."

msgid "Customize Memory Allocators"
msgstr "Anpassa minnesfördelare"

msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Struktur som används för att beskriva en minnesblocksallokering. Strukturen "
"har följande fält:"

msgid "Field"
msgstr "Fält"

msgid "Meaning"
msgstr "Betydelse"

msgid "``void *ctx``"
msgstr "``void *ctx``"

msgid "user context passed as first argument"
msgstr "användarkontext som skickas som första argument"

msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)```"

msgid "allocate a memory block"
msgstr "allokera ett minnesblock"

msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)```"

msgid "allocate a memory block initialized with zeros"
msgstr "allokera ett minnesblock som initieras med nollor"

msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)```"

msgid "allocate or resize a memory block"
msgstr "allokera eller ändra storlek på ett minnesblock"

msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)```"

msgid "free a memory block"
msgstr "frigöra ett minnesblock"

msgid ""
"The :c:type:`!PyMemAllocator` structure was renamed to :c:type:"
"`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
"Strukturen :c:type:`!PyMemAllocator` döptes om till :c:type:"
"`PyMemAllocatorEx` och ett nytt fält ``calloc`` lades till."

msgid "Enum used to identify an allocator domain. Domains:"
msgstr "Enum som används för att identifiera en allokeringsdomän. Domäner:"

msgid "Functions:"
msgstr "Funktioner:"

msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

msgid "Get the memory block allocator of the specified domain."
msgstr "Hämta minnesblockstilldelaren för den angivna domänen."

msgid "Set the memory block allocator of the specified domain."
msgstr "Ställ in minnesblocksallokeringen för den angivna domänen."

msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"Den nya allokeraren måste returnera en distinkt pekare som inte är ``NULL`` "
"när den begär noll bytes."

msgid ""
"For the :c:macro:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: a :term:`thread state` is not :term:`attached <attached thread state>` "
"when the allocator is called."
msgstr ""
"För domänen :c:macro:`PYMEM_DOMAIN_RAW` måste allokeraren vara tråd-säker: "
"ett :term:`thread state` är inte :term:`attached <attached thread state>` "
"när allokeraren anropas."

msgid ""
"For the remaining domains, the allocator must also be thread-safe: the "
"allocator may be called in different interpreters that do not share a :term:"
"`GIL`."
msgstr ""
"För de återstående domänerna måste allokeraren också vara tråd-säker: "
"allokeraren kan anropas i olika tolkare som inte delar en :term:`GIL`."

msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the "
"debug hooks on top on the new allocator."
msgstr ""
"Om den nya allokeringsenheten inte är en hook (anropar inte den föregående "
"allokeringsenheten) måste funktionen :c:func:`PyMem_SetupDebugHooks` anropas "
"för att installera om debughooks ovanpå den nya allokeringsenheten."

msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python "
"with PyPreConfig <c-preinit>`."
msgstr ""
"Se även :c:member:`PyPreConfig.allocator` och :ref:`Preinitialisera Python "
"med PyPreConfig <c-preinit>`."

msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ":c:func:`PyMem_SetAllocator` har följande kontrakt:"

msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before :c:func:"
"`Py_InitializeFromConfig` to install a custom memory allocator. There are no "
"restrictions over the installed allocator other than the ones imposed by the "
"domain (for instance, the Raw Domain allows the allocator to be called "
"without an :term:`attached thread state`). See :ref:`the section on "
"allocator domains <allocator-domains>` for more information."
msgstr ""
"Den kan anropas efter :c:func:`Py_PreInitialize` och före :c:func:"
"`Py_InitializeFromConfig` för att installera en anpassad minnesallokering. "
"Det finns inga andra begränsningar för den installerade allokatorn än de som "
"domänen inför (till exempel tillåter Raw Domain att allokatorn anropas utan "
"en :term:`attached thread state`). Se :ref:``avsnittet om allokeringsdomäner "
"<allocator-domains>` för mer information."

msgid ""
"If called after Python has finish initializing (after :c:func:"
"`Py_InitializeFromConfig` has been called) the allocator **must** wrap the "
"existing allocator. Substituting the current allocator for some other "
"arbitrary one is **not supported**."
msgstr ""
"Om den anropas efter att Python har slutfört initialiseringen (efter att :c:"
"func:`Py_InitializeFromConfig` har anropats) måste allokatorn **omhölja** "
"den befintliga allokatorn. Att ersätta den aktuella allokatorn med någon "
"annan godtycklig allokator stöds **inte**."

msgid "All allocators must be thread-safe."
msgstr "Alla allokatorer måste vara trådsäkra."

msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-hooks>` "
"to detect memory errors."
msgstr ""
"Installera :ref:`debug-krokar i Pythons minnesallokatorer <pymem-debug-"
"hooks>` för att upptäcka minnesfel."

msgid "Debug hooks on the Python memory allocators"
msgstr "Felsökningskrokar på Pythons minnesallokatorer"

msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the :c:func:"
"`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""
"När :ref:`Python byggs i felsökningsläge <debug-build>`, anropas funktionen :"
"c:func:`PyMem_SetupDebugHooks` vid :ref:`Pythons förinitialisering <c-"
"preinit>` för att ställa in felsökningskrokar på Pythons minnesallokatorer "
"för att upptäcka minnesfel."

msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install debug "
"hooks on a Python compiled in release mode (ex: ``PYTHONMALLOC=debug``)."
msgstr ""
"Miljövariabeln :envvar:`PYTHONMALLOC` kan användas för att installera debug-"
"krokar på ett Python som kompilerats i release-läge (ex: "
"``PYTHONMALLOC=debug``)."

msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug hooks "
"after calling :c:func:`PyMem_SetAllocator`."
msgstr ""
"Funktionen :c:func:`PyMem_SetupDebugHooks` kan användas för att ställa in "
"debug-krokar efter anrop av :c:func:`PyMem_SetAllocator`."

msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte "
"``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by \"forbidden "
"bytes\" filled with the byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strings of "
"these bytes are unlikely to be valid addresses, floats, or ASCII strings."
msgstr ""
"Dessa debughooks fyller dynamiskt allokerade minnesblock med speciella, "
"igenkännbara bitmönster. Nytilldelat minne fylls med bytena ``0xCD`` "
"(``PYMEM_CLEANBYTE``), frigjort minne fylls med bytena ``0xDD`` "
"(``PYMEM_DEADBYTE``). Minnesblock omges av \"förbjudna byte\" som fylls med "
"byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strängar av dessa byte är sannolikt "
"inte giltiga adresser, flyttal eller ASCII-strängar."

msgid "Runtime checks:"
msgstr "Kontroll av körtid:"

msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"Upptäck API-överträdelser. Detektera till exempel om :c:func:`PyObject_Free` "
"anropas på ett minnesblock som allokerats av :c:func:`PyMem_Malloc`."

msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "Detekterar skrivning före buffertens början (bufferten underflödar)."

msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "Detektera skrivning efter slutet av bufferten (buffer overflow)."

msgid ""
"Check that there is an :term:`attached thread state` when allocator "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) "
"and :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are "
"called."
msgstr ""
"Kontrollera att det finns en :term:`attached thread state` när "
"allokeringsfunktioner i domänerna :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:"
"`PyObject_Malloc`) och :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:"
"`PyMem_Malloc`) anropas."

msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the "
"memory block was traced."
msgstr ""
"Vid fel använder debug-krokarna modulen :mod:`tracemalloc` för att få en "
"spårning av var ett minnesblock allokerades. Spårningen visas bara om :mod:"
"`tracemalloc` spårar Python-minnesallokeringar och minnesblocket spårades."

msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each "
"block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function "
"(``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs "
"from a Python slice):"
msgstr ""
"Låt *S* = ``sizeof(size_t)``. ``2*S`` bytes läggs till i vardera änden av "
"varje block om *N* bytes som begärs.  Minneslayouten ser ut så här, där p "
"representerar adressen som returneras av en malloc-liknande eller realloc-"
"liknande funktion (``p[i:j]`` betyder byteskivan från ``*(p+i)`` inklusive "
"upp till ``*(p+j)`` exklusive; observera att behandlingen av negativa index "
"skiljer sig från en Python-skiva):"

msgid "``p[-2*S:-S]``"
msgstr "``p[-2*S:-S]```"

msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian (easier "
"to read in a memory dump)."
msgstr ""
"Antal bytes som ursprungligen begärdes.  Detta är en size_t, big-endian "
"(lättare att läsa i en minnesdump)."

msgid "``p[-S]``"
msgstr "``p[-S]```"

msgid "API identifier (ASCII character):"
msgstr "API-identifierare (ASCII-tecken):"

msgid "``'r'`` for :c:macro:`PYMEM_DOMAIN_RAW`."
msgstr "``'r'`` för :c:makro:`PYMEM_DOMAIN_RAW`."

msgid "``'m'`` for :c:macro:`PYMEM_DOMAIN_MEM`."
msgstr "``'m'`` för :c:macro:`PYMEM_DOMAIN_MEM`."

msgid "``'o'`` for :c:macro:`PYMEM_DOMAIN_OBJ`."
msgstr "``'o'`` för :c:makro:`PYMEM_DOMAIN_OBJ`."

msgid "``p[-S+1:0]``"
msgstr "``p[-S+1:0]``"

msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr ""
"Kopior av PYMEM_FORBIDDENBYTE.  Används för att fånga upp underskrivna och "
"underlästa filer."

msgid "``p[0:N]``"
msgstr "``p[0:N]```"

msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch "
"reference to uninitialized memory.  When a realloc-like function is called "
"requesting a larger memory block, the new excess bytes are also filled with "
"PYMEM_CLEANBYTE.  When a free-like function is called, these are overwritten "
"with PYMEM_DEADBYTE, to catch reference to freed memory.  When a realloc- "
"like function is called requesting a smaller memory block, the excess old "
"bytes are also filled with PYMEM_DEADBYTE."
msgstr ""
"Det begärda minnet fylls med kopior av PYMEM_CLEANBYTE, som används för att "
"fånga upp referenser till oinitialiserat minne.  När en realloc-liknande "
"funktion anropas och begär ett större minnesblock fylls även de nya "
"överflödiga byte med PYMEM_CLEANBYTE.  När en free-liknande funktion anropas "
"skrivs dessa över med PYMEM_DEADBYTE, för att fånga referenser till frigjort "
"minne.  När en realloc-liknande funktion anropas och begär ett mindre "
"minnesblock, fylls även de överflödiga gamla bytena med PYMEM_DEADBYTE."

msgid "``p[N:N+S]``"
msgstr "``p[N:N+S]``"

msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr ""
"Kopior av PYMEM_FORBIDDENBYTE.  Används för att fånga upp överskrivningar "
"och läsningar."

msgid "``p[N+S:N+2*S]``"
msgstr "``p[N+S:N+2*S]``"

msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined by "
"default)."
msgstr ""
"Används endast om makrot ``PYMEM_DEBUG_SERIALNO`` är definierat (inte "
"definierat som standard)."

msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or realloc-"
"like function.  Big-endian :c:type:`size_t`.  If \"bad memory\" is detected "
"later, the serial number gives an excellent way to set a breakpoint on the "
"next run, to capture the instant at which this block was passed out.  The "
"static function bumpserialno() in obmalloc.c is the only place the serial "
"number is incremented, and exists so you can set such a breakpoint easily."
msgstr ""
"Ett serienummer som ökas med 1 vid varje anrop till en malloc-liknande eller "
"realloc-liknande funktion.  Big-endian :c:type:`size_t`.  Om \"dåligt "
"minne\" upptäcks senare är serienumret ett utmärkt sätt att sätta en "
"brytpunkt vid nästa körning, för att fånga ögonblicket då detta block "
"skickades ut.  Den statiska funktionen bumpserialno() i obmalloc.c är det "
"enda stället där serienumret ökas, och den finns för att du enkelt ska kunna "
"sätta en sådan brytpunkt."

msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been altered, "
"diagnostic output is written to stderr, and the program is aborted via "
"Py_FatalError().  The other main failure mode is provoking a memory error "
"when a program reads up one of the special bit patterns and tries to use it "
"as an address.  If you get in a debugger then and look at the object, you're "
"likely to see that it's entirely filled with PYMEM_DEADBYTE (meaning freed "
"memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is "
"getting used)."
msgstr ""
"En realloc-liknande eller free-liknande funktion kontrollerar först att "
"PYMEM_FORBIDDENBYTE-bytena i varje ände är intakta.  Om de har ändrats "
"skrivs en diagnostisk utdata till stderr och programmet avbryts via "
"Py_FatalError().  Det andra huvudsakliga felet är att provocera fram ett "
"minnesfel när ett program läser upp ett av de speciella bitmönstren och "
"försöker använda det som en adress.  Om du då går in i en debugger och "
"tittar på objektet kommer du sannolikt att se att det är helt fyllt med "
"PYMEM_DEADBYTE (vilket betyder att frigjort minne används) eller "
"PYMEM_CLEANBYTE (vilket betyder att oinitialiserat minne används)."

msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use :mod:"
"`tracemalloc` to get the traceback where a memory block was allocated. The "
"debug hooks now also check if there is an :term:`attached thread state` when "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` and :c:macro:`PYMEM_DOMAIN_MEM` "
"domains are called."
msgstr ""
"Funktionen :c:func:`PyMem_SetupDebugHooks` fungerar nu även på Python som "
"kompilerats i release-läge.  Vid fel använder debuggkrokarna nu :mod:"
"`tracemalloc` för att få en spårning av var ett minnesblock allokerades. "
"Debuggkrokarna kontrollerar nu också om det finns en :term:`attached thread "
"state` när funktioner i domänerna :c:macro:`PYMEM_DOMAIN_OBJ` och :c:macro:"
"`PYMEM_DOMAIN_MEM` anropas."

msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been replaced with ``0xCD``, "
"``0xDD`` and ``0xFD`` to use the same values than Windows CRT debug "
"``malloc()`` and ``free()``."
msgstr ""
"Bytemönstren ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"och ``0xFB`` (``PYMEM_FORBIDDENBYTE``) har ersatts med ``0xCD``, ``0xDD`` "
"och ``0xFD`` för att använda samma värden som Windows CRT debug ``malloc()`` "
"och ``free()``."

msgid "The pymalloc allocator"
msgstr "Allokeringsverktyget pymalloc"

msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of either 256 KiB on 32-bit platforms or 1 MiB "
"on 64-bit platforms. It falls back to :c:func:`PyMem_RawMalloc` and :c:func:"
"`PyMem_RawRealloc` for allocations larger than 512 bytes."
msgstr ""
"Python har en *pymalloc*-allokering som är optimerad för små objekt (mindre "
"eller lika med 512 byte) med kort livslängd. Den använder minnesmappningar "
"som kallas \"arenor\" med en fast storlek på antingen 256 KiB på 32-bitars "
"plattformar eller 1 MiB på 64-bitars plattformar. Den faller tillbaka till :"
"c:func:`PyMem_RawMalloc` och :c:func:`PyMem_RawRealloc` för allokeringar "
"större än 512 byte."

msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and :c:macro:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"*pymalloc* är :ref:`standardallokering <default-memory-allocators>` för "
"domänerna :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) och :c:"
"macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`)."

msgid "The arena allocator uses the following functions:"
msgstr "Arenaallokeringen använder sig av följande funktioner:"

msgid ":c:func:`!VirtualAlloc` and :c:func:`!VirtualFree` on Windows,"
msgstr ":c:func:`!VirtualAlloc` och :c:func:`!VirtualFree` i Windows,"

msgid ":c:func:`!mmap` and :c:func:`!munmap` if available,"
msgstr ":c:func:`!mmap` och :c:func:`!munmap` om tillgängliga,"

msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` och :c:func:`free` annars."

msgid ""
"This allocator is disabled if Python is configured with the :option:`--"
"without-pymalloc` option. It can also be disabled at runtime using the :"
"envvar:`PYTHONMALLOC` environment variable (ex: ``PYTHONMALLOC=malloc``)."
msgstr ""
"Denna allokator inaktiveras om Python konfigureras med alternativet :option:"
"`--without-pymalloc`. Den kan också inaktiveras under körning med hjälp av "
"miljövariabeln :envvar:`PYTHONMALLOC` (ex: ``PYTHONMALLOC=malloc``)."

msgid ""
"Typically, it makes sense to disable the pymalloc allocator when building "
"Python with AddressSanitizer (:option:`--with-address-sanitizer`) which "
"helps uncover low level bugs within the C code."
msgstr ""
"Vanligtvis är det vettigt att inaktivera allokeringsverktyget pymalloc när "
"man bygger Python med AddressSanitizer (:option:`--with-address-sanitizer`), "
"vilket hjälper till att upptäcka lågnivåbuggar i C-koden."

msgid "Customize pymalloc Arena Allocator"
msgstr "Anpassa pymalloc Arena Allocator"

msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Struktur som används för att beskriva en arenaallokering. Strukturen har tre "
"fält:"

msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)```"

msgid "allocate an arena of size bytes"
msgstr "allokera en arena av storleken bytes"

msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)```"

msgid "free an arena"
msgstr "frigöra en arena"

msgid "Get the arena allocator."
msgstr "Hämta arenans allokeringsenhet."

msgid "Set the arena allocator."
msgstr "Ställ in arenaallokeringen."

msgid "The mimalloc allocator"
msgstr "Allokeringsverktyget mimalloc"

msgid ""
"Python supports the mimalloc allocator when the underlying platform support "
"is available. mimalloc \"is a general purpose allocator with excellent "
"performance characteristics. Initially developed by Daan Leijen for the "
"runtime systems of the Koka and Lean languages.\""
msgstr ""
"Python stöder allokatorn mimalloc när den underliggande plattformens stöd är "
"tillgängligt. mimalloc \"är en allokator för allmänt ändamål med utmärkta "
"prestandaegenskaper. Den utvecklades ursprungligen av Daan Leijen för "
"körtidssystemen för språken Koka och Lean.\""

msgid "tracemalloc C API"
msgstr "tracemalloc C API"

msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Spåra ett allokerat minnesblock i modulen :mod:`tracemalloc`."

msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Returnera ``0`` vid framgång, returnera ``-1`` vid fel (misslyckades med att "
"allokera minne för att lagra spårningen). Returnerar ``-2`` om tracemalloc "
"är inaktiverat."

msgid "If memory block is already tracked, update the existing trace."
msgstr "Om minnesblocket redan är spårat, uppdatera den befintliga spårningen."

msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Ta bort spårningen av ett allokerat minnesblock i modulen :mod:"
"`tracemalloc`. Gör ingenting om blocket inte spårades."

msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr ""
"Returnerar ``-2`` om tracemalloc är inaktiverat, annars returneras ``0``."

msgid "Examples"
msgstr "Exempel"

msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function "
"set::"
msgstr ""
"Här är exemplet från avsnitt :ref:`memoryoverview`, omskrivet så att I/O-"
"bufferten allokeras från Pythons heap med hjälp av den första funktionen "
"set::"

msgid ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_Malloc */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* för I/O */\n"
"\n"
"om (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Gör någon I/O-operation som involverar buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allokerad med PyMem_Malloc */\n"
"returnera res;"

msgid "The same code using the type-oriented function set::"
msgstr "Samma kod med hjälp av den typorienterade funktionen set::"

msgid ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_New */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* för I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Gör någon I/O-operation som involverar buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allokeras med PyMem_New */\n"
"returnera res;"

msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two "
"different allocators operating on different heaps. ::"
msgstr ""
"Observera att i de två exemplen ovan manipuleras bufferten alltid via "
"funktioner som tillhör samma uppsättning. Det är faktiskt nödvändigt att "
"använda samma minnes-API-familj för ett visst minnesblock, så att risken för "
"att blanda olika allokatorer reduceras till ett minimum. Följande kodsekvens "
"innehåller två fel, varav det ena är märkt som *dödligt* eftersom det "
"blandar två olika allokatorer som arbetar på olika heaps. ::"

msgid ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */\n"
"free(buf2);       /* Right -- allocated via malloc() */\n"
"free(buf1);       /* Fatal -- should be PyMem_Free()  */"
msgstr ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3); /* Fel -- borde vara PyMem_Free() */\n"
"free(buf2); /* Rätt -- allokerad via malloc() */\n"
"free(buf1); /* Fatalt -- bör vara PyMem_Free() */"

msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with :c:macro:"
"`PyObject_New`, :c:macro:`PyObject_NewVar` and :c:func:`PyObject_Free`."
msgstr ""
"Förutom de funktioner som syftar till att hantera råa minnesblock från "
"Pythons heap allokeras och frigörs objekt i Python med :c:macro:"
"`PyObject_New`, :c:macro:`PyObject_NewVar` och :c:func:`PyObject_Free`."

msgid ""
"These will be explained in the next chapter on defining and implementing new "
"object types in C."
msgstr ""
"Dessa kommer att förklaras i nästa kapitel om att definiera och implementera "
"nya objekttyper i C."

msgid "malloc (C function)"
msgstr "malloc (C-funktion)"

msgid "calloc (C function)"
msgstr "calloc (C-funktion)"

msgid "realloc (C function)"
msgstr "realloc (C-funktion)"

msgid "free (C function)"
msgstr "fri (C-funktion)"
