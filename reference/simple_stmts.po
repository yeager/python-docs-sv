# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-19 14:18+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Simple statements"
msgstr ""

msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""

msgid "Expression statements"
msgstr ""

msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""

msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""

msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""

msgid "Assignment statements"
msgstr ""

msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""

msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""

msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""

msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""

msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""

msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""

msgid "Else:"
msgstr ""

msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""

msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""

msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""

msgid "If the target is an identifier (name):"
msgstr ""

msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""

msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""

msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""

msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""

msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""

msgid ""
"class Cls:\n"
"    x = 3             # class variable\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"
msgstr ""

msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""

msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""

msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""

msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/value pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""

msgid ""
"For user-defined objects, the :meth:`~object.__setitem__` method is called "
"with appropriate arguments."
msgstr ""

msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""

msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""

msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""

msgid ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i is updated, then x[i] is updated\n"
"print(x)"
msgstr ""

msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ""

msgid "The specification for the ``*target`` feature."
msgstr ""

msgid "Augmented assignment statements"
msgstr ""

msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""

msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""

msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""

msgid ""
"An augmented assignment statement like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""

msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""

msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""

msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""

msgid "Annotated assignment statements"
msgstr ""

msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""

msgid ""
"The difference from normal :ref:`assignment` is that only a single target is "
"allowed."
msgstr ""

msgid ""
"The assignment target is considered \"simple\" if it consists of a single "
"name that is not enclosed in parentheses. For simple assignment targets, if "
"in class or module scope, the annotations are gathered in a lazily "
"evaluated :ref:`annotation scope <annotation-scopes>`. The annotations can "
"be evaluated using the :attr:`~object.__annotations__` attribute of a class "
"or module, or using the facilities in the :mod:`annotationlib` module."
msgstr ""

msgid ""
"If the assignment target is not simple (an attribute, subscript node, or "
"parenthesized name), the annotation is never evaluated."
msgstr ""

msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""

msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment as if there was no annotation present. If the right hand "
"side is not present for an expression target, then the interpreter evaluates "
"the target except for the last :meth:`~object.__setitem__` or :meth:`~object."
"__setattr__` call."
msgstr ""

msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ""

msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""

msgid ":pep:`484` - Type hints"
msgstr ""

msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""

msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""

msgid ""
"Annotations are now lazily evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`. If the assignment target is not simple, annotations "
"are never evaluated."
msgstr ""

msgid "The :keyword:`!assert` statement"
msgstr ""

msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""

msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr ""

msgid ""
"if __debug__:\n"
"    if not expression: raise AssertionError"
msgstr ""

msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""

msgid ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"
msgstr ""

msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable ``__debug__`` is ``True`` under normal "
"circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an :"
"keyword:`assert` statement when optimization is requested at compile time.  "
"Note that it is unnecessary to include the source code for the expression "
"that failed in the error message; it will be displayed as part of the stack "
"trace."
msgstr ""

msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""

msgid "The :keyword:`!pass` statement"
msgstr ""

msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""

msgid ""
"def f(arg): pass    # a function that does nothing (yet)\n"
"\n"
"class C: pass       # a class with no methods (yet)"
msgstr ""

msgid "The :keyword:`!del` statement"
msgstr ""

msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""

msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""

msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""

msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""

msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""

msgid "The :keyword:`!return` statement"
msgstr ""

msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""

msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""

msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""

msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""

msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""

msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""

msgid "The :keyword:`!yield` statement"
msgstr ""

msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The ``yield`` statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""

msgid ""
"yield <expr>\n"
"yield from <expr>"
msgstr ""

msgid "are equivalent to the yield expression statements ::"
msgstr ""

msgid ""
"(yield <expr>)\n"
"(yield from <expr>)"
msgstr ""

msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using :keyword:`yield` in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""

msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""

msgid "The :keyword:`!raise` statement"
msgstr ""

msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that "
"is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""

msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""

msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""

msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`~BaseException.__traceback__` "
"attribute. You can create an exception and set your own traceback in one "
"step using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""

msgid "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"
msgstr ""

msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`~BaseException.__cause__` attribute (which is "
"writable). If the expression is an exception class, the class will be "
"instantiated and the resulting exception instance will be attached to the "
"raised exception as the :attr:`!__cause__` attribute. If the raised "
"exception is not handled, both exceptions will be printed:"
msgstr ""

msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"
msgstr ""

msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an :"
"keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`~BaseException.__context__` attribute:"
msgstr ""

msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"
msgstr ""

msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause:"
msgstr ""

msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"
msgstr ""

msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""

msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ""

msgid ""
"Added the :attr:`~BaseException.__suppress_context__` attribute to suppress "
"automatic display of the exception context."
msgstr ""

msgid ""
"If the traceback of the active exception is modified in an :keyword:`except` "
"clause, a subsequent ``raise`` statement re-raises the exception with the "
"modified traceback. Previously, the exception was re-raised with the "
"traceback it had when it was caught."
msgstr ""

msgid "The :keyword:`!break` statement"
msgstr ""

msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""

msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""

msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""

msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""

msgid "The :keyword:`!continue` statement"
msgstr ""

msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""

msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""

msgid "The :keyword:`!import` statement"
msgstr ""

msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""

msgid "find a module, loading and initializing it if necessary"
msgstr ""

msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""

msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""

msgid ""
"The details of the first step, finding and loading modules, are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""

msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""

msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""

msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""

msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""

msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ""

msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""

msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""

msgid "check if the imported module has an attribute by that name"
msgstr ""

msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""

msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr ""

msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""

msgid "Examples::"
msgstr ""

msgid ""
"import foo                 # foo imported and bound locally\n"
"import foo.bar.baz         # foo, foo.bar, and foo.bar.baz imported, foo "
"bound locally\n"
"import foo.bar.baz as fbb  # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as fbb\n"
"from foo.bar import baz    # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as baz\n"
"from foo import attr       # foo imported and foo.attr bound as attr"
msgstr ""

msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""

msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""

msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""

msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""

msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""

msgid "Future statements"
msgstr ""

msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""

msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""

msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""

msgid "the module docstring (if any),"
msgstr ""

msgid "comments,"
msgstr ""

msgid "blank lines, and"
msgstr ""

msgid "other future statements."
msgstr ""

msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr ""

msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""

msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""

msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""

msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""

msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""

msgid "Note that there is nothing special about the statement::"
msgstr ""

msgid "import __future__ [as name]"
msgstr ""

msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""

msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`!M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""

msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""

msgid ":pep:`236` - Back to the __future__"
msgstr ""

msgid "The original proposal for the __future__ mechanism."
msgstr ""

msgid "The :keyword:`!global` statement"
msgstr ""

msgid ""
"The :keyword:`global` statement causes the listed identifiers to be "
"interpreted as globals. It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""

msgid ""
"The :keyword:`global` statement applies to the entire scope of a function or "
"class body. A :exc:`SyntaxError` is raised if a variable is used or assigned "
"to prior to its global declaration in the scope."
msgstr ""

msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""

msgid "The :keyword:`!nonlocal` statement"
msgstr ""

msgid ""
"When the definition of a function or class is nested (enclosed) within the "
"definitions of other functions, its nonlocal scopes are the local scopes of "
"the enclosing functions. The :keyword:`nonlocal` statement causes the listed "
"identifiers to refer to names previously bound in nonlocal scopes. It allows "
"encapsulated code to rebind such nonlocal identifiers.  If a name is bound "
"in more than one nonlocal scope, the nearest binding is used. If a name is "
"not bound in any nonlocal scope, or if there is no nonlocal scope, a :exc:"
"`SyntaxError` is raised."
msgstr ""

msgid ""
"The :keyword:`nonlocal` statement applies to the entire scope of a function "
"or class body. A :exc:`SyntaxError` is raised if a variable is used or "
"assigned to prior to its nonlocal declaration in the scope."
msgstr ""

msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ""

msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ""

msgid ""
"**Programmer's note:** :keyword:`nonlocal` is a directive to the parser and "
"applies only to code parsed along with it.  See the note for the :keyword:"
"`global` statement."
msgstr ""

msgid "The :keyword:`!type` statement"
msgstr ""

msgid ""
"The :keyword:`!type` statement declares a type alias, which is an instance "
"of :class:`typing.TypeAliasType`."
msgstr ""

msgid "For example, the following statement creates a type alias::"
msgstr ""

msgid "type Point = tuple[float, float]"
msgstr ""

msgid "This code is roughly equivalent to::"
msgstr ""

msgid ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"
msgstr ""

msgid ""
"``annotation-def`` indicates an :ref:`annotation scope <annotation-scopes>`, "
"which behaves mostly like a function, but with several small differences."
msgstr ""

msgid ""
"The value of the type alias is evaluated in the annotation scope. It is not "
"evaluated when the type alias is created, but only when the value is "
"accessed through the type alias's :attr:`!__value__` attribute (see :ref:"
"`lazy-evaluation`). This allows the type alias to refer to names that are "
"not yet defined."
msgstr ""

msgid ""
"Type aliases may be made generic by adding a :ref:`type parameter list <type-"
"params>` after the name. See :ref:`generic-type-aliases` for more."
msgstr ""

msgid ":keyword:`!type` is a :ref:`soft keyword <soft-keywords>`."
msgstr ""

msgid ":pep:`695` - Type Parameter Syntax"
msgstr ""

msgid ""
"Introduced the :keyword:`!type` statement and syntax for generic classes and "
"functions."
msgstr ""

msgid "simple"
msgstr ""

msgid "statement"
msgstr ""

msgid "expression"
msgstr ""

msgid "list"
msgstr ""

msgid "built-in function"
msgstr ""

msgid "repr"
msgstr ""

msgid "object"
msgstr ""

msgid "None"
msgstr ""

msgid "string"
msgstr ""

msgid "conversion"
msgstr ""

msgid "output"
msgstr ""

msgid "standard"
msgstr ""

msgid "writing"
msgstr ""

msgid "values"
msgstr ""

msgid "procedure"
msgstr ""

msgid "call"
msgstr ""

msgid "= (equals)"
msgstr ""

msgid "assignment statement"
msgstr ""

msgid "assignment"
msgstr ""

msgid "binding"
msgstr ""

msgid "name"
msgstr ""

msgid "rebinding"
msgstr ""

msgid "mutable"
msgstr ""

msgid "attribute"
msgstr ""

msgid "target"
msgstr ""

msgid ", (comma)"
msgstr ""

msgid "in target list"
msgstr ""

msgid "* (asterisk)"
msgstr ""

msgid "in assignment target list"
msgstr ""

msgid "[] (square brackets)"
msgstr ""

msgid "() (parentheses)"
msgstr ""

msgid "destructor"
msgstr ""

msgid "subscription"
msgstr ""

msgid "sequence"
msgstr ""

msgid "mapping"
msgstr ""

msgid "dictionary"
msgstr ""

msgid "slicing"
msgstr ""

msgid "augmented"
msgstr ""

msgid "assignment, augmented"
msgstr ""

msgid "+="
msgstr ""

msgid "augmented assignment"
msgstr ""

msgid "-="
msgstr ""

msgid "*="
msgstr ""

msgid "/="
msgstr ""

msgid "%="
msgstr ""

msgid "&="
msgstr ""

msgid "^="
msgstr ""

msgid "|="
msgstr ""

msgid "**="
msgstr ""

msgid "//="
msgstr ""

msgid ">>="
msgstr ""

msgid "<<="
msgstr ""

msgid "annotated"
msgstr ""

msgid "assignment, annotated"
msgstr ""

msgid ": (colon)"
msgstr ""

msgid "annotated variable"
msgstr ""

msgid "assert"
msgstr ""

msgid "debugging"
msgstr ""

msgid "assertions"
msgstr ""

msgid "expression list"
msgstr ""

msgid "__debug__"
msgstr ""

msgid "exception"
msgstr ""

msgid "AssertionError"
msgstr ""

msgid "pass"
msgstr ""

msgid "null"
msgstr ""

msgid "operation"
msgstr ""

msgid "del"
msgstr ""

msgid "deletion"
msgstr ""

msgid "global"
msgstr ""

msgid "unbinding"
msgstr ""

msgid "return"
msgstr ""

msgid "function"
msgstr ""

msgid "definition"
msgstr ""

msgid "class"
msgstr ""

msgid "keyword"
msgstr ""

msgid "finally"
msgstr ""

msgid "yield"
msgstr ""

msgid "generator"
msgstr ""

msgid "iterator"
msgstr ""

msgid "StopIteration"
msgstr ""

msgid "raise"
msgstr ""

msgid "raising"
msgstr ""

msgid "__traceback__ (exception attribute)"
msgstr ""

msgid "traceback"
msgstr ""

msgid "chaining"
msgstr ""

msgid "__cause__ (exception attribute)"
msgstr ""

msgid "__context__ (exception attribute)"
msgstr ""

msgid "break"
msgstr ""

msgid "for"
msgstr ""

msgid "while"
msgstr ""

msgid "loop"
msgstr ""

msgid "else"
msgstr ""

msgid "loop control"
msgstr ""

msgid "continue"
msgstr ""

msgid "import"
msgstr ""

msgid "module"
msgstr ""

msgid "importing"
msgstr ""

msgid "from"
msgstr ""

msgid "as"
msgstr ""

msgid "ImportError"
msgstr ""

msgid "import statement"
msgstr ""

msgid "__all__ (optional module attribute)"
msgstr ""

msgid "relative"
msgstr ""

msgid "future"
msgstr ""

msgid "__future__"
msgstr ""

msgid "future statement"
msgstr ""

msgid "identifier list"
msgstr ""

msgid "exec"
msgstr ""

msgid "eval"
msgstr ""

msgid "compile"
msgstr ""

msgid "nonlocal"
msgstr ""

msgid "type"
msgstr ""
