# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Extending Python with C or C++"
msgstr "Utöka Python med C eller C++"

msgid ""
"It is quite easy to add new built-in modules to Python, if you know how to "
"program in C.  Such :dfn:`extension modules` can do two things that can't be "
"done directly in Python: they can implement new built-in object types, and "
"they can call C library functions and system calls."
msgstr ""
"Det är ganska enkelt att lägga till nya inbyggda moduler till Python, om du "
"vet hur man programmerar i C. Sådana :dfn:`extension modules` kan göra två "
"saker som inte kan göras direkt i Python: de kan implementera nya inbyggda "
"objekttyper, och de kan anropa C-biblioteksfunktioner och systemanrop."

msgid ""
"To support extensions, the Python API (Application Programmers Interface) "
"defines a set of functions, macros and variables that provide access to most "
"aspects of the Python run-time system.  The Python API is incorporated in a "
"C source file by including the header ``\"Python.h\"``."
msgstr ""
"För att stödja tillägg definierar Python API (Application Programmers "
"Interface) en uppsättning funktioner, makron och variabler som ger tillgång "
"till de flesta aspekter av Pythons runtime-system.  Python API införlivas i "
"en C-källfil genom att inkludera rubriken ``\"Python.h\"``."

msgid ""
"The compilation of an extension module depends on its intended use as well "
"as on your system setup; details are given in later chapters."
msgstr ""
"Sammanställningen av en tilläggsmodul beror på hur den ska användas och på "
"hur systemet är uppbyggt; mer information om detta finns i senare kapitel."

msgid ""
"The C extension interface is specific to CPython, and extension modules do "
"not work on other Python implementations.  In many cases, it is possible to "
"avoid writing C extensions and preserve portability to other "
"implementations. For example, if your use case is calling C library "
"functions or system calls, you should consider using the :mod:`ctypes` "
"module or the `cffi <https://cffi.readthedocs.io/>`_ library rather than "
"writing custom C code. These modules let you write Python code to interface "
"with C code and are more portable between implementations of Python than "
"writing and compiling a C extension module."
msgstr ""
"Gränssnittet för C-tillägg är specifikt för CPython, och tilläggsmoduler "
"fungerar inte på andra Python-implementeringar.  I många fall är det möjligt "
"att undvika att skriva C-tillägg och bevara portabiliteten till andra "
"implementationer. Om ditt användningsområde till exempel är att anropa C-"
"biblioteksfunktioner eller systemanrop, bör du överväga att använda :mod:"
"`ctypes`-modulen eller biblioteket `cffi <https://cffi.readthedocs.io/>`_ i "
"stället för att skriva egen C-kod. Med dessa moduler kan du skriva Python-"
"kod för gränssnitt med C-kod och de är mer portabla mellan olika "
"implementationer av Python än att skriva och kompilera en C-tilläggsmodul."

msgid "A Simple Example"
msgstr "Ett enkelt exempel"

msgid ""
"Let's create an extension module called ``spam`` (the favorite food of Monty "
"Python fans...) and let's say we want to create a Python interface to the C "
"library function :c:func:`system` [#]_. This function takes a null-"
"terminated character string as argument and returns an integer.  We want "
"this function to be callable from Python as follows:"
msgstr ""
"Låt oss skapa en tilläggsmodul som heter ``spam`` (Monty Python-fansens "
"favoritmat...) och låt oss säga att vi vill skapa ett Python-gränssnitt till "
"C-bibliotekets funktion :c:func:`system` [#]_. Denna funktion tar en "
"nollavslutad teckensträng som argument och returnerar ett heltal.  Vi vill "
"att denna funktion ska kunna anropas från Python enligt följande:"

msgid ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"
msgstr ""
">>> import spam\n"
">>> status = spam.system(\"ls -l\")"

msgid ""
"Begin by creating a file :file:`spammodule.c`.  (Historically, if a module "
"is called ``spam``, the C file containing its implementation is called :file:"
"`spammodule.c`; if the module name is very long, like ``spammify``, the "
"module name can be just :file:`spammify.c`.)"
msgstr ""
"Börja med att skapa en fil :file:`spammodule.c`.  (Historiskt sett, om en "
"modul heter ``spam``, heter C-filen som innehåller dess implementation :file:"
"`spammodule.c`; om modulnamnet är mycket långt, som ``spammify``, kan "
"modulnamnet bara vara :file:`spammify.c`)"

msgid "The first two lines of our file can be::"
msgstr "De två första raderna i vår fil kan vara::"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#inkludera <Python.h>"

msgid ""
"which pulls in the Python API (you can add a comment describing the purpose "
"of the module and a copyright notice if you like)."
msgstr ""
"som hämtar Python API (du kan lägga till en kommentar som beskriver syftet "
"med modulen och ett upphovsrättsmeddelande om du vill)."

msgid ""
"Since Python may define some pre-processor definitions which affect the "
"standard headers on some systems, you *must* include :file:`Python.h` before "
"any standard headers are included."
msgstr ""
"Eftersom Python kan definiera vissa preprocessordefinitioner som påverkar "
"standardrubrikerna på vissa system, måste du *inkludera* :file:`Python.h` "
"innan några standardrubriker inkluderas."

msgid ""
"``#define PY_SSIZE_T_CLEAN`` was used to indicate that ``Py_ssize_t`` should "
"be used in some APIs instead of ``int``. It is not necessary since Python "
"3.13, but we keep it here for backward compatibility. See :ref:`arg-parsing-"
"string-and-buffers` for a description of this macro."
msgstr ""
"``#define PY_SSIZE_T_CLEAN`` användes för att indikera att ``Py_ssize_t`` "
"skulle användas i vissa API:er istället för ``int``. Det är inte nödvändigt "
"sedan Python 3.13, men vi behåller det här för bakåtkompatibilitet. Se :ref:"
"`arg-parsing-string-and-buffers` för en beskrivning av detta makro."

msgid ""
"All user-visible symbols defined by :file:`Python.h` have a prefix of ``Py`` "
"or ``PY``, except those defined in standard header files. For convenience, "
"and since they are used extensively by the Python interpreter, ``\"Python."
"h\"`` includes a few standard header files: ``<stdio.h>``, ``<string.h>``, "
"``<errno.h>``, and ``<stdlib.h>``.  If the latter header file does not exist "
"on your system, it declares the functions :c:func:`malloc`, :c:func:`free` "
"and :c:func:`realloc` directly."
msgstr ""
"Alla användarsynliga symboler som definieras av :file:`Python.h` har "
"prefixet ``Py`` eller ``PY``, utom de som definieras i standardhuvudfiler. "
"För enkelhetens skull, och eftersom de används flitigt av Python-tolken, "
"innehåller ``\"Python.h\"`` några standardheaderfiler: ``<stdio.h>``, "
"``<string.h>``, ``<errno.h>`` och ``<stdlib.h>`.  Om den senare huvudfilen "
"inte finns på ditt system, deklarerar den funktionerna :c:func:`malloc`, :c:"
"func:`free` och :c:func:`realloc` direkt."

msgid ""
"The next thing we add to our module file is the C function that will be "
"called when the Python expression ``spam.system(string)`` is evaluated "
"(we'll see shortly how it ends up being called)::"
msgstr ""
"Nästa sak vi lägger till i vår modulfil är den C-funktion som kommer att "
"anropas när Python-uttrycket ``spam.system(string)`` utvärderas (vi ska "
"snart se hur den kommer att anropas)::"

msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *kommando;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        returnera NULL;\n"
"    sts = system(kommando);\n"
"    return PyLong_FromLong(sts);\n"
"}"

msgid ""
"There is a straightforward translation from the argument list in Python (for "
"example, the single expression ``\"ls -l\"``) to the arguments passed to the "
"C function.  The C function always has two arguments, conventionally named "
"*self* and *args*."
msgstr ""
"Det finns en enkel översättning från argumentlistan i Python (t.ex. det "
"enkla uttrycket ``\"ls -l\"``) till de argument som skickas till C-"
"funktionen.  C-funktionen har alltid två argument, konventionellt benämnda "
"*self* och *args*."

msgid ""
"The *self* argument points to the module object for module-level functions; "
"for a method it would point to the object instance."
msgstr ""
"Argumentet *self* pekar på modulobjektet för funktioner på modulnivå; för en "
"metod skulle det peka på objektinstansen."

msgid ""
"The *args* argument will be a pointer to a Python tuple object containing "
"the arguments.  Each item of the tuple corresponds to an argument in the "
"call's argument list.  The arguments are Python objects --- in order to do "
"anything with them in our C function we have to convert them to C values.  "
"The function :c:func:`PyArg_ParseTuple` in the Python API checks the "
"argument types and converts them to C values.  It uses a template string to "
"determine the required types of the arguments as well as the types of the C "
"variables into which to store the converted values.  More about this later."
msgstr ""
"Argumentet *args* kommer att vara en pekare till ett Python-tuple-objekt som "
"innehåller argumenten.  Varje post i tupeln motsvarar ett argument i "
"anropets argumentlista.  Argumenten är Python-objekt --- för att kunna göra "
"något med dem i vår C-funktion måste vi konvertera dem till C-värden.  "
"Funktionen :c:func:`PyArg_ParseTuple` i Python API kontrollerar "
"argumenttyperna och konverterar dem till C-värden.  Den använder en "
"mallsträng för att bestämma de nödvändiga typerna av argumenten samt typerna "
"av de C-variabler som de konverterade värdena ska lagras i.  Mer om detta "
"senare."

msgid ""
":c:func:`PyArg_ParseTuple` returns true (nonzero) if all arguments have the "
"right type and its components have been stored in the variables whose "
"addresses are passed.  It returns false (zero) if an invalid argument list "
"was passed.  In the latter case it also raises an appropriate exception so "
"the calling function can return ``NULL`` immediately (as we saw in the "
"example)."
msgstr ""
":c:func:`PyArg_ParseTuple` returnerar true (icke-noll) om alla argument har "
"rätt typ och dess komponenter har lagrats i de variabler vars adresser "
"skickas.  Den returnerar false (noll) om en ogiltig argumentlista har "
"skickats.  I det senare fallet ger den också upphov till ett lämpligt "
"undantag så att den anropande funktionen kan returnera ``NULL`` omedelbart "
"(som vi såg i exemplet)."

msgid "Intermezzo: Errors and Exceptions"
msgstr "Intermezzo: Fel och undantag"

msgid ""
"An important convention throughout the Python interpreter is the following: "
"when a function fails, it should set an exception condition and return an "
"error value (usually ``-1`` or a ``NULL`` pointer).  Exception information "
"is stored in three members of the interpreter's thread state.  These are "
"``NULL`` if there is no exception.  Otherwise they are the C equivalents of "
"the members of the Python tuple returned by :meth:`sys.exc_info`.  These are "
"the exception type, exception instance, and a traceback object.  It is "
"important to know about them to understand how errors are passed around."
msgstr ""
"En viktig konvention i hela Python-tolken är följande: när en funktion "
"misslyckas ska den ställa in ett undantagsvillkor och returnera ett felvärde "
"(vanligtvis ``-1`` eller en ``NULL``-pekare).  Undantagsinformation lagras i "
"tre medlemmar av tolkens trådtillstånd.  Dessa är ``NULL`` om det inte finns "
"något undantag.  Annars är de C-ekvivalenter till medlemmarna i Python-"
"tupeln som returneras av :meth:`sys.exc_info`.  Dessa är undantagstypen, "
"undantagsinstansen och ett traceback-objekt.  Det är viktigt att känna till "
"dem för att förstå hur fel skickas runt."

msgid ""
"The Python API defines a number of functions to set various types of "
"exceptions."
msgstr ""
"Python API definierar ett antal funktioner för att ställa in olika typer av "
"undantag."

msgid ""
"The most common one is :c:func:`PyErr_SetString`.  Its arguments are an "
"exception object and a C string.  The exception object is usually a "
"predefined object like :c:data:`PyExc_ZeroDivisionError`.  The C string "
"indicates the cause of the error and is converted to a Python string object "
"and stored as the \"associated value\" of the exception."
msgstr ""
"Den vanligaste är :c:func:`PyErr_SetString`.  Dess argument är ett "
"undantagsobjekt och en C-sträng.  Undantagsobjektet är vanligtvis ett "
"fördefinierat objekt som :c:data:`PyExc_ZeroDivisionError`.  C-strängen "
"anger orsaken till felet och konverteras till ett Python-strängobjekt och "
"lagras som det \"associerade värdet\" för undantaget."

msgid ""
"Another useful function is :c:func:`PyErr_SetFromErrno`, which only takes an "
"exception argument and constructs the associated value by inspection of the "
"global variable :c:data:`errno`.  The most general function is :c:func:"
"`PyErr_SetObject`, which takes two object arguments, the exception and its "
"associated value.  You don't need to :c:func:`Py_INCREF` the objects passed "
"to any of these functions."
msgstr ""
"En annan användbar funktion är :c:func:`PyErr_SetFromErrno`, som bara tar "
"ett undantagsargument och konstruerar det associerade värdet genom "
"inspektion av den globala variabeln :c:data:`errno`.  Den mest allmänna "
"funktionen är :c:func:`PyErr_SetObject`, som tar två objektargument, "
"undantaget och dess associerade värde.  Du behöver inte :c:func:`Py_INCREF` "
"de objekt som skickas till någon av dessa funktioner."

msgid ""
"You can test non-destructively whether an exception has been set with :c:"
"func:`PyErr_Occurred`.  This returns the current exception object, or "
"``NULL`` if no exception has occurred.  You normally don't need to call :c:"
"func:`PyErr_Occurred` to see whether an error occurred in a function call, "
"since you should be able to tell from the return value."
msgstr ""
"Du kan testa icke-destruktivt om ett undantag har ställts in med :c:func:"
"`PyErr_Occurred`.  Detta returnerar det aktuella undantagsobjektet, eller "
"``NULL`` om inget undantag har inträffat.  Du behöver normalt inte anropa :c:"
"func:`PyErr_Occurred` för att se om ett fel inträffade i ett funktionsanrop, "
"eftersom du bör kunna se det från returvärdet."

msgid ""
"When a function *f* that calls another function *g* detects that the latter "
"fails, *f* should itself return an error value (usually ``NULL`` or "
"``-1``).  It should *not* call one of the ``PyErr_*`` functions --- one has "
"already been called by *g*. *f*'s caller is then supposed to also return an "
"error indication to *its* caller, again *without* calling ``PyErr_*``, and "
"so on --- the most detailed cause of the error was already reported by the "
"function that first detected it.  Once the error reaches the Python "
"interpreter's main loop, this aborts the currently executing Python code and "
"tries to find an exception handler specified by the Python programmer."
msgstr ""
"När en funktion *f* som anropar en annan funktion *g* upptäcker att den "
"senare misslyckas, bör *f* själv returnera ett felvärde (vanligtvis ``NULL`` "
"eller ``-1``).  Den ska *inte* anropa någon av funktionerna ``PyErr_*`` --- "
"en sådan har redan anropats av *g*. *f*:s anropare ska sedan också returnera "
"en felindikation till *sin* anropare, återigen *utan* att anropa "
"``PyErr_*``, och så vidare --- den mest detaljerade orsaken till felet "
"rapporterades redan av den funktion som först upptäckte det.  När felet når "
"Python-tolkens huvudslinga avbryter denna den Python-kod som för närvarande "
"körs och försöker hitta en undantagshanterare som specificerats av Python-"
"programmeraren."

msgid ""
"(There are situations where a module can actually give a more detailed error "
"message by calling another ``PyErr_*`` function, and in such cases it is "
"fine to do so.  As a general rule, however, this is not necessary, and can "
"cause information about the cause of the error to be lost: most operations "
"can fail for a variety of reasons.)"
msgstr ""
"(Det finns situationer där en modul faktiskt kan ge ett mer detaljerat "
"felmeddelande genom att anropa en annan ``PyErr_*``-funktion, och i sådana "
"fall är det bra att göra det.  Som en allmän regel är detta dock inte "
"nödvändigt och kan leda till att information om orsaken till felet går "
"förlorad: de flesta operationer kan misslyckas av olika skäl)"

msgid ""
"To ignore an exception set by a function call that failed, the exception "
"condition must be cleared explicitly by calling :c:func:`PyErr_Clear`.  The "
"only time C code should call :c:func:`PyErr_Clear` is if it doesn't want to "
"pass the error on to the interpreter but wants to handle it completely by "
"itself (possibly by trying something else, or pretending nothing went wrong)."
msgstr ""
"Om du vill ignorera ett undantag som skapats av ett funktionsanrop som "
"misslyckades måste undantagsvillkoret rensas explicit genom att anropa :c:"
"func:`PyErr_Clear`.  Den enda gången C-kod bör anropa :c:func:`PyErr_Clear` "
"är om den inte vill skicka felet vidare till tolken utan vill hantera det "
"helt själv (eventuellt genom att prova något annat eller låtsas att inget "
"gick fel)."

msgid ""
"Every failing :c:func:`malloc` call must be turned into an exception --- the "
"direct caller of :c:func:`malloc` (or :c:func:`realloc`) must call :c:func:"
"`PyErr_NoMemory` and return a failure indicator itself.  All the object-"
"creating functions (for example, :c:func:`PyLong_FromLong`) already do this, "
"so this note is only relevant to those who call :c:func:`malloc` directly."
msgstr ""
"Varje misslyckat anrop av :c:func:`malloc` måste förvandlas till ett "
"undantag --- den som direkt anropar :c:func:`malloc` (eller :c:func:"
"`realloc`) måste anropa :c:func:`PyErr_NoMemory` och själv returnera en "
"felindikator.  Alla objektskapande funktioner (t.ex. :c:func:"
"`PyLong_FromLong`) gör redan detta, så denna anmärkning är bara relevant för "
"dem som anropar :c:func:`malloc` direkt."

msgid ""
"Also note that, with the important exception of :c:func:`PyArg_ParseTuple` "
"and friends, functions that return an integer status usually return a "
"positive value or zero for success and ``-1`` for failure, like Unix system "
"calls."
msgstr ""
"Observera också att, med det viktiga undantaget :c:func:`PyArg_ParseTuple` "
"och vänner, funktioner som returnerar en heltalsstatus vanligtvis returnerar "
"ett positivt värde eller noll för framgång och ``-1`` för misslyckande, som "
"Unix systemanrop."

msgid ""
"Finally, be careful to clean up garbage (by making :c:func:`Py_XDECREF` or :"
"c:func:`Py_DECREF` calls for objects you have already created) when you "
"return an error indicator!"
msgstr ""
"Slutligen, var noga med att rensa bort skräp (genom att göra :c:func:"
"`Py_XDECREF` eller :c:func:`Py_DECREF` anrop för objekt som du redan har "
"skapat) när du returnerar en felindikator!"

msgid ""
"The choice of which exception to raise is entirely yours.  There are "
"predeclared C objects corresponding to all built-in Python exceptions, such "
"as :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course, "
"you should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError` "
"to mean that a file couldn't be opened (that should probably be :c:data:"
"`PyExc_OSError`). If something's wrong with the argument list, the :c:func:"
"`PyArg_ParseTuple` function usually raises :c:data:`PyExc_TypeError`.  If "
"you have an argument whose value must be in a particular range or must "
"satisfy other conditions, :c:data:`PyExc_ValueError` is appropriate."
msgstr ""
"Valet av vilket undantag som ska tas upp är helt och hållet ditt.  Det finns "
"fördeklarerade C-objekt som motsvarar alla inbyggda Python-undantag, till "
"exempel :c:data:`PyExc_ZeroDivisionError`, som du kan använda direkt. "
"Naturligtvis bör du välja undantag klokt --- använd inte :c:data:"
"`PyExc_TypeError` för att betyda att en fil inte kunde öppnas (det borde "
"förmodligen vara :c:data:`PyExc_OSError`). Om något är fel med "
"argumentlistan ger funktionen :c:func:`PyArg_ParseTuple` vanligtvis :c:data:"
"`PyExc_TypeError`.  Om du har ett argument vars värde måste ligga inom ett "
"visst intervall eller måste uppfylla andra villkor, är :c:data:"
"`PyExc_ValueError` lämplig."

msgid ""
"You can also define a new exception that is unique to your module. The "
"simplest way to do this is to declare a static global object variable at the "
"beginning of the file::"
msgstr ""
"Du kan också definiera ett nytt undantag som är unikt för din modul. Det "
"enklaste sättet att göra detta är att deklarera en statisk global "
"objektvariabel i början av filen::"

msgid "static PyObject *SpamError = NULL;"
msgstr "statiskt PyObject *SpamError = NULL;"

msgid ""
"and initialize it by calling :c:func:`PyErr_NewException` in the module's :c:"
"data:`Py_mod_exec` function (:c:func:`!spam_module_exec`)::"
msgstr ""
"och initiera den genom att anropa :c:func:`PyErr_NewException` i modulens :c:"
"data:`Py_mod_exec`-funktion (:c:func:`!spam_module_exec`)::"

msgid "SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);"
msgstr "SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);"

msgid ""
"Since :c:data:`!SpamError` is a global variable, it will be overwitten every "
"time the module is reinitialized, when the :c:data:`Py_mod_exec` function is "
"called."
msgstr ""
"Eftersom :c:data:`!SpamError` är en global variabel kommer den att skrivas "
"över varje gång modulen initieras på nytt, när funktionen :c:data:"
"`Py_mod_exec` anropas."

msgid ""
"For now, let's avoid the issue: we will block repeated initialization by "
"raising an :py:exc:`ImportError`::"
msgstr ""
"För tillfället undviker vi problemet: vi blockerar upprepade "
"initialiseringar genom att skapa ett :py:exc:`ImportError`::"

msgid ""
"static PyObject *SpamError = NULL;\n"
"\n"
"static int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    if (SpamError != NULL) {\n"
"        PyErr_SetString(PyExc_ImportError,\n"
"                        \"cannot initialize spam module more than once\");\n"
"        return -1;\n"
"    }\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    if (PyModule_AddObjectRef(m, \"SpamError\", SpamError) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot spam_module_slots[] = {\n"
"    {Py_mod_exec, spam_module_exec},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    .m_size = 0,  // non-negative\n"
"    .m_slots = spam_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"
msgstr ""
"statiskt PyObject *SpamError = NULL;\n"
"\n"
"statisk int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    if (SpamError != NULL) {\n"
"        PyErr_SetString(PyExc_ImportError,\n"
"                        \"kan inte initiera spammodulen mer än en gång\");\n"
"        return -1;\n"
"    }\n"
"    SpamError = PyErr_NewException(\"spam.error\", NULL, NULL);\n"
"    if (PyModule_AddObjectRef(m, \"SpamError\", SpamError) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"static PyModuleDef_Slot spam_module_slots[] = {\n"
"    {Py_mod_exec, spam_module_exec},\n"
"    {0, NULL}\n"
"};\n"
"\n"
"statisk struct PyModuleDef spam_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"spam\",\n"
"    .m_size = 0, // icke-negativ\n"
"    .m_slots = spam_module_slots,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"

msgid ""
"Note that the Python name for the exception object is :exc:`!spam.error`.  "
"The :c:func:`PyErr_NewException` function may create a class with the base "
"class being :exc:`Exception` (unless another class is passed in instead of "
"``NULL``), described in :ref:`bltin-exceptions`."
msgstr ""
"Observera att Python-namnet för undantagsobjektet är :exc:`!spam.error`.  "
"Funktionen :c:func:`PyErr_NewException` kan skapa en klass med basklassen :"
"exc:`Exception` (om inte en annan klass anges istället för ``NULL``), som "
"beskrivs i :ref:`bltin-exceptions`."

msgid ""
"Note also that the :c:data:`!SpamError` variable retains a reference to the "
"newly created exception class; this is intentional!  Since the exception "
"could be removed from the module by external code, an owned reference to the "
"class is needed to ensure that it will not be discarded, causing :c:data:`!"
"SpamError` to become a dangling pointer. Should it become a dangling "
"pointer, C code which raises the exception could cause a core dump or other "
"unintended side effects."
msgstr ""
"Notera också att variabeln :c:data:`!SpamError` behåller en referens till "
"den nyskapade undantagsklassen; detta är avsiktligt!  Eftersom undantaget "
"kan tas bort från modulen av extern kod, behövs en ägd referens till klassen "
"för att säkerställa att den inte kasseras, vilket gör att :c:data:`!"
"SpamError` blir en dinglande pekare. Om den blir en dinglande pekare kan C-"
"kod som väcker undantaget orsaka en kärndump eller andra oavsiktliga "
"bieffekter."

msgid ""
"For now, the :c:func:`Py_DECREF` call to remove this reference is missing. "
"Even when the Python interpreter shuts down, the global :c:data:`!SpamError` "
"variable will not be garbage-collected. It will \"leak\". We did, however, "
"ensure that this will happen at most once per process."
msgstr ""
"För tillfället saknas :c:func:`Py_DECREF`-anropet för att ta bort denna "
"referens. Även när Python-tolken stängs av kommer den globala :c:data:`!"
"SpamError`-variabeln inte att samlas in. Den kommer att \"läcka\". Vi har "
"dock försäkrat oss om att detta kommer att ske högst en gång per process."

msgid ""
"We discuss the use of :c:macro:`PyMODINIT_FUNC` as a function return type "
"later in this sample."
msgstr ""
"Vi diskuterar användningen av :c:macro:`PyMODINIT_FUNC` som funktionens "
"returtyp senare i detta exempel."

msgid ""
"The :exc:`!spam.error` exception can be raised in your extension module "
"using a call to :c:func:`PyErr_SetString` as shown below::"
msgstr ""
"Undantaget :exc:`!spam.error` kan skapas i din tilläggsmodul med hjälp av "
"ett anrop till :c:func:`PyErr_SetString` enligt nedan::"

msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = system(command);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"System command failed\");\n"
"        return NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *kommando;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        returnera NULL;\n"
"    sts = system(kommando);\n"
"    if (sts < 0) {\n"
"        PyErr_SetString(SpamError, \"Systemkommando misslyckades\");\n"
"        returnera NULL;\n"
"    }\n"
"    return PyLong_FromLong(sts);\n"
"}"

msgid "Back to the Example"
msgstr "Tillbaka till exemplet"

msgid ""
"Going back to our example function, you should now be able to understand "
"this statement::"
msgstr ""
"Om vi går tillbaka till vår exempelfunktion bör du nu kunna förstå detta "
"uttalande::"

msgid ""
"if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"    return NULL;"
msgstr ""
"if (!PyArg_ParseTuple(args, \"s\", &kommando))\n"
"    returnera NULL;"

msgid ""
"It returns ``NULL`` (the error indicator for functions returning object "
"pointers) if an error is detected in the argument list, relying on the "
"exception set by :c:func:`PyArg_ParseTuple`.  Otherwise the string value of "
"the argument has been copied to the local variable :c:data:`!command`.  This "
"is a pointer assignment and you are not supposed to modify the string to "
"which it points (so in Standard C, the variable :c:data:`!command` should "
"properly be declared as ``const char *command``)."
msgstr ""
"Den returnerar ``NULL`` (felindikatorn för funktioner som returnerar "
"objektpekare) om ett fel upptäcks i argumentlistan och förlitar sig på "
"undantaget som anges av :c:func:`PyArg_ParseTuple`.  Annars har argumentets "
"strängvärde kopierats till den lokala variabeln :c:data:`!command`.  Detta "
"är en pekartilldelning och det är inte meningen att du ska ändra strängen "
"som den pekar på (så i Standard C bör variabeln :c:data:`!command` korrekt "
"deklareras som ``const char *command``)."

msgid ""
"The next statement is a call to the Unix function :c:func:`system`, passing "
"it the string we just got from :c:func:`PyArg_ParseTuple`::"
msgstr ""
"Nästa sats är ett anrop till Unix-funktionen :c:func:`system` och skickar "
"den strängen som vi just fick från :c:func:`PyArg_ParseTuple`::"

msgid "sts = system(command);"
msgstr "sts = system(kommando);"

msgid ""
"Our :func:`!spam.system` function must return the value of :c:data:`!sts` as "
"a Python object.  This is done using the function :c:func:"
"`PyLong_FromLong`. ::"
msgstr ""
"Vår funktion :func:`!spam.system` måste returnera värdet av :c:data:`!sts` "
"som ett Python-objekt.  Detta görs med hjälp av funktionen :c:func:"
"`PyLong_FromLong`. ::"

msgid "return PyLong_FromLong(sts);"
msgstr "return PyLong_FromLong(m);"

msgid ""
"In this case, it will return an integer object.  (Yes, even integers are "
"objects on the heap in Python!)"
msgstr ""
"I det här fallet kommer det att returnera ett heltalsobjekt.  (Ja, även "
"heltal är objekt på heapen i Python!)"

msgid ""
"If you have a C function that returns no useful argument (a function "
"returning :c:expr:`void`), the corresponding Python function must return "
"``None``.   You need this idiom to do so (which is implemented by the :c:"
"macro:`Py_RETURN_NONE` macro)::"
msgstr ""
"Om du har en C-funktion som inte returnerar något användbart argument (en "
"funktion som returnerar :c:expr:`void`), måste motsvarande Python-funktion "
"returnera ``None``.   Du behöver detta idiom för att göra det (som "
"implementeras av :c:macro:`Py_RETURN_NONE` macro)::"

msgid ""
"Py_INCREF(Py_None);\n"
"return Py_None;"
msgstr ""
"Py_INCREF(Py_None);\n"
"returnera Py_None;"

msgid ""
":c:data:`Py_None` is the C name for the special Python object ``None``.  It "
"is a genuine Python object rather than a ``NULL`` pointer, which means "
"\"error\" in most contexts, as we have seen."
msgstr ""
":c:data:`Py_None` är C-namnet för det speciella Python-objektet ``None``.  "
"Det är ett äkta Python-objekt snarare än en ``NULL``-pekare, som betyder "
"\"fel\" i de flesta sammanhang, som vi har sett."

msgid "The Module's Method Table and Initialization Function"
msgstr "Modulens metodtabell och initialiseringsfunktion"

msgid ""
"I promised to show how :c:func:`!spam_system` is called from Python "
"programs. First, we need to list its name and address in a \"method table\"::"
msgstr ""
"Jag lovade att visa hur :c:func:`!spam_system` anropas från Python-program. "
"Först måste vi lista dess namn och adress i en \"metodtabell\"::"

msgid ""
"static PyMethodDef spam_methods[] = {\n"
"    ...\n"
"    {\"system\",  spam_system, METH_VARARGS,\n"
"     \"Execute a shell command.\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Sentinel */\n"
"};"
msgstr ""
"statisk PyMethodDef spam_methods[] = {\n"
"    ...\n"
"    {\"system\", spam_system, METH_VARARGS,\n"
"     \"Utför ett shell-kommando.\"},\n"
"    ...\n"
"    {NULL, NULL, 0, NULL}        /* Sentinel */\n"
"};"

msgid ""
"Note the third entry (``METH_VARARGS``).  This is a flag telling the "
"interpreter the calling convention to be used for the C function.  It should "
"normally always be ``METH_VARARGS`` or ``METH_VARARGS | METH_KEYWORDS``; a "
"value of ``0`` means that an obsolete variant of :c:func:`PyArg_ParseTuple` "
"is used."
msgstr ""
"Lägg märke till den tredje posten (``METH_VARARGS``).  Detta är en flagga "
"som talar om för tolken vilken anropskonvention som ska användas för C-"
"funktionen.  Den bör normalt alltid vara ``METH_VARARGS`` eller "
"``METH_VARARGS | METH_KEYWORDS``; ett värde på ``0`` betyder att en "
"föråldrad variant av :c:func:`PyArg_ParseTuple` används."

msgid ""
"When using only ``METH_VARARGS``, the function should expect the Python-"
"level parameters to be passed in as a tuple acceptable for parsing via :c:"
"func:`PyArg_ParseTuple`; more information on this function is provided below."
msgstr ""
"När endast ``METH_VARARGS`` används bör funktionen förvänta sig att "
"parametrarna på Python-nivå skickas in som en tupel som kan tolkas via :c:"
"func:`PyArg_ParseTuple`; mer information om denna funktion finns nedan."

msgid ""
"The :c:macro:`METH_KEYWORDS` bit may be set in the third field if keyword "
"arguments should be passed to the function.  In this case, the C function "
"should accept a third ``PyObject *`` parameter which will be a dictionary of "
"keywords. Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments "
"to such a function."
msgstr ""
"Bit :c:macro:`METH_KEYWORDS` kan sättas i det tredje fältet om "
"nyckelordsargument skall skickas till funktionen.  I detta fall bör C-"
"funktionen acceptera en tredje ``PyObject *`` parameter som kommer att vara "
"en ordbok med nyckelord. Använd :c:func:`PyArg_ParseTupleAndKeywords` för "
"att analysera argumenten till en sådan funktion."

msgid ""
"The method table must be referenced in the module definition structure::"
msgstr "Metodtabellen måste refereras till i modulens definitionsstruktur::"

msgid ""
"static struct PyModuleDef spam_module = {\n"
"    ...\n"
"    .m_methods = spam_methods,\n"
"    ...\n"
"};"
msgstr ""
"static struct PyModuleDef spam_module = {\n"
"    ...\n"
"    .m_methods = spam_methods,\n"
"    ...\n"
"};"

msgid ""
"This structure, in turn, must be passed to the interpreter in the module's "
"initialization function.  The initialization function must be named :c:func:"
"`!PyInit_name`, where *name* is the name of the module, and should be the "
"only non-\\ ``static`` item defined in the module file::"
msgstr ""
"Denna struktur måste i sin tur skickas till tolken i modulens "
"initialiseringsfunktion.  Initialiseringsfunktionen måste heta :c:func:`!"
"PyInit_name`, där *name* är modulens namn, och bör vara det enda icke-"
"statiska objektet som definieras i modulfilen::"

msgid ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"
msgstr ""
"PyMODINIT_FUNC\n"
"PyInit_spam(void)\n"
"{\n"
"    return PyModuleDef_Init(&spam_module);\n"
"}"

msgid ""
"Note that :c:macro:`PyMODINIT_FUNC` declares the function as ``PyObject *`` "
"return type, declares any special linkage declarations required by the "
"platform, and for C++ declares the function as ``extern \"C\"``."
msgstr ""
"Observera att :c:macro:`PyMODINIT_FUNC` deklarerar funktionen som ``PyObject "
"*`` returtyp, deklarerar eventuella speciella länkdeklarationer som krävs av "
"plattformen, och för C++ deklarerar funktionen som ``extern \"C\"``."

msgid ""
":c:func:`!PyInit_spam` is called when each interpreter imports its module :"
"mod:`!spam` for the first time.  (See below for comments about embedding "
"Python.) A pointer to the module definition must be returned via :c:func:"
"`PyModuleDef_Init`, so that the import machinery can create the module and "
"store it in ``sys.modules``."
msgstr ""
":c:func:`!PyInit_spam` anropas när varje tolk importerar sin modul :mod:`!"
"spam` för första gången.  (Se nedan för kommentarer om inbäddning av "
"Python.) En pekare till moduldefinitionen måste returneras via :c:func:"
"`PyModuleDef_Init`, så att importmaskineriet kan skapa modulen och lagra den "
"i ``sys.modules``."

msgid ""
"When embedding Python, the :c:func:`!PyInit_spam` function is not called "
"automatically unless there's an entry in the :c:data:`PyImport_Inittab` "
"table. To add the module to the initialization table, use :c:func:"
"`PyImport_AppendInittab`, optionally followed by an import of the module::"
msgstr ""
"Vid inbäddning av Python anropas inte funktionen :c:func:`!PyInit_spam` "
"automatiskt om det inte finns en post i tabellen :c:data:`PyImport_Inittab`. "
"För att lägga till modulen i initialiseringstabellen, använd :c:func:"
"`PyImport_AppendInittab`, eventuellt följt av en import av modulen::"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* Add a built-in module, before Py_Initialize */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: could not extend in-built modules "
"table\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Pass argv[0] to the Python interpreter */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, "
"argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    /* Initialize the Python interpreter.  Required.\n"
"       If this step fails, it will be a fatal error. */\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    /* Optionally import the module; alternatively,\n"
"       import can be deferred until the embedded script\n"
"       imports it. */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    // ... use Python C API here ...\n"
"\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* Add a built-in module, before Py_Initialize */\n"
"    if (PyImport_AppendInittab(\"spam\", PyInit_spam) == -1) {\n"
"        fprintf(stderr, \"Error: could not extend in-built modules "
"table\\n\");\n"
"        exit(1);\n"
"    }\n"
"\n"
"    /* Pass argv[0] to the Python interpreter */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, "
"argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    /* Initialize the Python interpreter.  Required.\n"
"       If this step fails, it will be a fatal error. */\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    /* Optionally import the module; alternatively,\n"
"       import can be deferred until the embedded script\n"
"       imports it. */\n"
"    PyObject *pmodule = PyImport_ImportModule(\"spam\");\n"
"    if (!pmodule) {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Error: could not import module 'spam'\\n\");\n"
"    }\n"
"\n"
"    // ... use Python C API here ...\n"
"\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"

msgid ""
"If you declare a global variable or a local static one, the module may "
"experience unintended side-effects on re-initialisation, for example when "
"removing entries from ``sys.modules`` or importing compiled modules into "
"multiple interpreters within a process (or following a :c:func:`fork` "
"without an intervening :c:func:`exec`). If module state is not yet fully :"
"ref:`isolated <isolating-extensions-howto>`, authors should consider marking "
"the module as having no support for subinterpreters (via :c:macro:"
"`Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED`)."
msgstr ""
"Om du deklarerar en global variabel eller en lokal statisk variabel kan "
"modulen få oavsiktliga bieffekter vid ominitialisering, till exempel när du "
"tar bort poster från ``sys.modules`` eller importerar kompilerade moduler "
"till flera tolkar inom en process (eller efter en :c:func:`fork`` utan en "
"mellanliggande :c:func:`exec``). Om modultillståndet ännu inte är helt :ref:"
"`isolerat <isolating-extensions-howto>`, bör författare överväga att markera "
"modulen som att den inte har stöd för undertolkare (via :c:macro:"
"`Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED`)."

msgid ""
"A more substantial example module is included in the Python source "
"distribution as :file:`Modules/xxlimited.c`.  This file may be used as a "
"template or simply read as an example."
msgstr ""
"En mer omfattande exempelmodul ingår i Python-källdistributionen som :file:"
"`Modules/xxlimited.c`.  Denna fil kan användas som en mall eller helt enkelt "
"läsas som ett exempel."

msgid "Compilation and Linkage"
msgstr "Sammanställning och länkning"

msgid ""
"There are two more things to do before you can use your new extension: "
"compiling and linking it with the Python system.  If you use dynamic "
"loading, the details may depend on the style of dynamic loading your system "
"uses; see the chapters about building extension modules (chapter :ref:"
"`building`) and additional information that pertains only to building on "
"Windows (chapter :ref:`building-on-windows`) for more information about this."
msgstr ""
"Det finns ytterligare två saker att göra innan du kan använda ditt nya "
"tillägg: att kompilera och länka det med Python-systemet.  Om du använder "
"dynamisk laddning kan detaljerna bero på vilken typ av dynamisk laddning "
"ditt system använder; se kapitlen om att bygga tilläggsmoduler (kapitel :ref:"
"`building`) och ytterligare information som endast gäller för att bygga på "
"Windows (kapitel :ref:`building-on-windows`) för mer information om detta."

msgid ""
"If you can't use dynamic loading, or if you want to make your module a "
"permanent part of the Python interpreter, you will have to change the "
"configuration setup and rebuild the interpreter.  Luckily, this is very "
"simple on Unix: just place your file (:file:`spammodule.c` for example) in "
"the :file:`Modules/` directory of an unpacked source distribution, add a "
"line to the file :file:`Modules/Setup.local` describing your file:"
msgstr ""
"Om du inte kan använda dynamisk laddning, eller om du vill göra din modul "
"till en permanent del av Python-tolken, måste du ändra "
"konfigurationsinställningarna och bygga om tolken.  Lyckligtvis är detta "
"mycket enkelt på Unix: placera bara din fil (:file:`spammodule.c` till "
"exempel) i katalogen :file:`Modules/` i en uppackad källkodsdistribution, "
"lägg till en rad i filen :file:`Modules/Setup.local` som beskriver din fil:"

msgid "spam spammodule.o"
msgstr "skräppost spammodule.o"

msgid ""
"and rebuild the interpreter by running :program:`make` in the toplevel "
"directory.  You can also run :program:`make` in the :file:`Modules/` "
"subdirectory, but then you must first rebuild :file:`Makefile` there by "
"running ':program:`make` Makefile'.  (This is necessary each time you change "
"the :file:`Setup` file.)"
msgstr ""
"och bygga om tolken genom att köra :program:`make` i toplevel-katalogen.  Du "
"kan också köra :program:`make` i underkatalogen :file:`Modules/`, men då "
"måste du först bygga om :file:`Makefile` där genom att köra ':program:`make` "
"Makefile'.  (Detta är nödvändigt varje gång du ändrar filen :file:`Setup`)"

msgid ""
"If your module requires additional libraries to link with, these can be "
"listed on the line in the configuration file as well, for instance:"
msgstr ""
"Om din modul kräver ytterligare bibliotek att länka med kan dessa också "
"anges på raden i konfigurationsfilen, till exempel:"

msgid "spam spammodule.o -lX11"
msgstr "spam spammodule.o -lX11"

msgid "Calling Python Functions from C"
msgstr "Anropa Python-funktioner från C"

msgid ""
"So far we have concentrated on making C functions callable from Python.  The "
"reverse is also useful: calling Python functions from C. This is especially "
"the case for libraries that support so-called \"callback\" functions.  If a "
"C interface makes use of callbacks, the equivalent Python often needs to "
"provide a callback mechanism to the Python programmer; the implementation "
"will require calling the Python callback functions from a C callback.  Other "
"uses are also imaginable."
msgstr ""
"Hittills har vi koncentrerat oss på att göra C-funktioner anropsbara från "
"Python.  Det omvända är också användbart: att anropa Python-funktioner från "
"C. Detta är särskilt fallet för bibliotek som stöder så kallade \"callback\"-"
"funktioner.  Om ett C-gränssnitt använder sig av callbacks behöver "
"motsvarande Python ofta tillhandahålla en callback-mekanism till Python-"
"programmeraren; implementeringen kräver att Pythons callback-funktioner "
"anropas från en C-callback.  Andra användningsområden är också tänkbara."

msgid ""
"Fortunately, the Python interpreter is easily called recursively, and there "
"is a standard interface to call a Python function.  (I won't dwell on how to "
"call the Python parser with a particular string as input --- if you're "
"interested, have a look at the implementation of the :option:`-c` command "
"line option in :file:`Modules/main.c` from the Python source code.)"
msgstr ""
"Lyckligtvis är det lätt att anropa Python-tolken rekursivt och det finns ett "
"standardgränssnitt för att anropa en Python-funktion.  (Jag ska inte "
"uppehålla mig vid hur man anropar Python-parsern med en viss sträng som "
"indata --- om du är intresserad kan du titta på implementeringen av "
"kommandoradsalternativet :option:`-c` i :file:`Modules/main.c` från Pythons "
"källkod)"

msgid ""
"Calling a Python function is easy.  First, the Python program must somehow "
"pass you the Python function object.  You should provide a function (or some "
"other interface) to do this.  When this function is called, save a pointer "
"to the Python function object (be careful to :c:func:`Py_INCREF` it!) in a "
"global variable --- or wherever you see fit. For example, the following "
"function might be part of a module definition::"
msgstr ""
"Att anropa en Python-funktion är enkelt.  Först måste Python-programmet på "
"något sätt skicka Python-funktionsobjektet till dig.  Du bör tillhandahålla "
"en funktion (eller något annat gränssnitt) för att göra detta.  När denna "
"funktion anropas sparar du en pekare till Python-funktionsobjektet (var noga "
"med att :c:func:`Py_INCREF` det!) i en global variabel --- eller var du "
"vill. Till exempel kan följande funktion vara en del av en moduldefinition::"

msgid ""
"static PyObject *my_callback = NULL;\n"
"\n"
"static PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *result = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"parameter must be "
"callable\");\n"
"            return NULL;\n"
"        }\n"
"        Py_XINCREF(temp);         /* Add a reference to new callback */\n"
"        Py_XDECREF(my_callback);  /* Dispose of previous callback */\n"
"        my_callback = temp;       /* Remember new callback */\n"
"        /* Boilerplate to return \"None\" */\n"
"        Py_INCREF(Py_None);\n"
"        result = Py_None;\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"statiskt PyObject *my_callback = NULL;\n"
"\n"
"statiskt PyObject *\n"
"my_set_callback(PyObject *dummy, PyObject *args)\n"
"{\n"
"    PyObject *resultat = NULL;\n"
"    PyObject *temp;\n"
"\n"
"    if (PyArg_ParseTuple(args, \"O:set_callback\", &temp)) {\n"
"        if (!PyCallable_Check(temp)) {\n"
"            PyErr_SetString(PyExc_TypeError, \"parametern måste vara "
"anropsbar\");\n"
"            returnera NULL;\n"
"        }\n"
"        Py_XINCREF(temp); /* Lägg till en referens till den nya "
"återuppringningen */\n"
"        Py_XDECREF(my_callback); /* Avyttra föregående anrop */\n"
"        my_callback = temp; /* Kom ihåg det nya anropet */\n"
"        /* Boilerplate för att returnera \"None\" */\n"
"        Py_INCREF(Py_None);\n"
"        resultat = Py_None;\n"
"    }\n"
"    returnera resultat;\n"
"}"

msgid ""
"This function must be registered with the interpreter using the :c:macro:"
"`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The :"
"c:func:`PyArg_ParseTuple` function and its arguments are documented in "
"section :ref:`parsetuple`."
msgstr ""
"Denna funktion måste registreras hos tolken med hjälp av flaggan :c:macro:"
"`METH_VARARGS`; detta beskrivs i avsnitt :ref:`methodtable`.  Funktionen :c:"
"func:`PyArg_ParseTuple` och dess argument finns dokumenterade i avsnitt :ref:"
"`parsetuple`."

msgid ""
"The macros :c:func:`Py_XINCREF` and :c:func:`Py_XDECREF` increment/decrement "
"the reference count of an object and are safe in the presence of ``NULL`` "
"pointers (but note that *temp* will not be  ``NULL`` in this context).  More "
"info on them in section :ref:`refcounts`."
msgstr ""
"Makrot :c:func:`Py_XINCREF` och :c:func:`Py_XDECREF` ökar/de minskar "
"referensantalet för ett objekt och är säkra i närvaro av ``NULL``pekare (men "
"observera att *temp* inte kommer att vara ``NULL`` i detta sammanhang).  Mer "
"information om dem finns i avsnittet :ref:`refcounts`."

msgid ""
"Later, when it is time to call the function, you call the C function :c:func:"
"`PyObject_CallObject`.  This function has two arguments, both pointers to "
"arbitrary Python objects: the Python function, and the argument list.  The "
"argument list must always be a tuple object, whose length is the number of "
"arguments.  To call the Python function with no arguments, pass in ``NULL``, "
"or an empty tuple; to call it with one argument, pass a singleton tuple. :c:"
"func:`Py_BuildValue` returns a tuple when its format string consists of zero "
"or more format codes between parentheses.  For example::"
msgstr ""
"Senare, när det är dags att anropa funktionen, anropar du C-funktionen :c:"
"func:`PyObject_CallObject`.  Denna funktion har två argument, båda pekare "
"till godtyckliga Python-objekt: Python-funktionen och argumentlistan.  "
"Argumentlistan måste alltid vara ett tuple-objekt, vars längd är antalet "
"argument.  För att anropa Python-funktionen utan argument, skicka in "
"``NULL``, eller en tom tupel; för att anropa den med ett argument, skicka en "
"singleton-tupel. :c:func:`Py_BuildValue` returnerar en tupel när dess "
"formatsträng består av noll eller flera formatkoder mellan parenteser.  Till "
"exempel::"

msgid ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *result;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* Time to call the callback */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"
msgstr ""
"int arg;\n"
"PyObject *arglist;\n"
"PyObject *resultat;\n"
"...\n"
"arg = 123;\n"
"...\n"
"/* Dags att anropa återuppringningen */\n"
"arglist = Py_BuildValue(\"(i)\", arg);\n"
"resultat = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);"

msgid ""
":c:func:`PyObject_CallObject` returns a Python object pointer: this is the "
"return value of the Python function.  :c:func:`PyObject_CallObject` is "
"\"reference-count-neutral\" with respect to its arguments.  In the example a "
"new tuple was created to serve as the argument list, which is :c:func:"
"`Py_DECREF`\\ -ed immediately after the :c:func:`PyObject_CallObject` call."
msgstr ""
":c:func:`PyObject_CallObject` returnerar en Python-objektpekare: detta är "
"Python-funktionens returvärde. :c:func:`PyObject_CallObject` är "
"\"referensräkningsneutral\" med avseende på sina argument.  I exemplet "
"skapades en ny tupel för att fungera som argumentlista, som :c:func:"
"`Py_DECREF` -ed omedelbart efter anropet av :c:func:`PyObject_CallObject`."

msgid ""
"The return value of :c:func:`PyObject_CallObject` is \"new\": either it is a "
"brand new object, or it is an existing object whose reference count has been "
"incremented.  So, unless you want to save it in a global variable, you "
"should somehow :c:func:`Py_DECREF` the result, even (especially!) if you are "
"not interested in its value."
msgstr ""
"Returvärdet för :c:func:`PyObject_CallObject` är \"nytt\": antingen är det "
"ett helt nytt objekt, eller så är det ett befintligt objekt vars "
"referensantal har ökats.  Så om du inte vill spara det i en global variabel "
"bör du på något sätt :c:func:`Py_DECREF` resultatet, även (särskilt!) om du "
"inte är intresserad av dess värde."

msgid ""
"Before you do this, however, it is important to check that the return value "
"isn't ``NULL``.  If it is, the Python function terminated by raising an "
"exception. If the C code that called :c:func:`PyObject_CallObject` is called "
"from Python, it should now return an error indication to its Python caller, "
"so the interpreter can print a stack trace, or the calling Python code can "
"handle the exception. If this is not possible or desirable, the exception "
"should be cleared by calling :c:func:`PyErr_Clear`.  For example::"
msgstr ""
"Innan du gör detta är det dock viktigt att kontrollera att returvärdet inte "
"är ``NULL``.  Om det är det, avslutas Python-funktionen med ett undantag. Om "
"C-koden som anropade :c:func:`PyObject_CallObject` anropas från Python, bör "
"den nu returnera en felindikation till sin Python-anropare, så att tolken "
"kan skriva ut en stack trace, eller så att den anropande Python-koden kan "
"hantera undantaget. Om detta inte är möjligt eller önskvärt, bör undantaget "
"rensas genom att anropa :c:func:`PyErr_Clear`.  Till exempel::"

msgid ""
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"...use result...\n"
"Py_DECREF(result);"
msgstr ""
"if (resultat == NULL)\n"
"    return NULL; /* Skicka felet tillbaka */\n"
"...använd resultatet...\n"
"Py_DECREF(resultat);"

msgid ""
"Depending on the desired interface to the Python callback function, you may "
"also have to provide an argument list to :c:func:`PyObject_CallObject`.  In "
"some cases the argument list is also provided by the Python program, through "
"the same interface that specified the callback function.  It can then be "
"saved and used in the same manner as the function object.  In other cases, "
"you may have to construct a new tuple to pass as the argument list.  The "
"simplest way to do this is to call :c:func:`Py_BuildValue`.  For example, if "
"you want to pass an integral event code, you might use the following code::"
msgstr ""
"Beroende på det önskade gränssnittet till Pythons återuppringningsfunktion "
"kan du också behöva tillhandahålla en argumentlista till :c:func:"
"`PyObject_CallObject`.  I vissa fall tillhandahålls argumentlistan också av "
"Python-programmet, genom samma gränssnitt som specificerade callback-"
"funktionen.  Den kan då sparas och användas på samma sätt som "
"funktionsobjektet.  I andra fall kan du behöva konstruera en ny tupel att "
"skicka som argumentlista.  Det enklaste sättet att göra detta är att anropa :"
"c:func:`Py_BuildValue`.  Om du t.ex. vill skicka en integrerad händelsekod "
"kan du använda följande kod::"

msgid ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", eventcode);\n"
"result = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""
"PyObject *arglist;\n"
"...\n"
"arglist = Py_BuildValue(\"(l)\", händelsekod);\n"
"resultat = PyObject_CallObject(my_callback, arglist);\n"
"Py_DECREF(arglist);\n"
"if (resultat == NULL)\n"
"    return NULL; /* Skicka felet tillbaka */\n"
"/* Här kan du kanske använda resultatet */\n"
"Py_DECREF(resultat);"

msgid ""
"Note the placement of ``Py_DECREF(arglist)`` immediately after the call, "
"before the error check!  Also note that strictly speaking this code is not "
"complete: :c:func:`Py_BuildValue` may run out of memory, and this should be "
"checked."
msgstr ""
"Notera placeringen av ``Py_DECREF(arglist)`` omedelbart efter anropet, före "
"felkontrollen!  Observera också att denna kod inte är komplett i strikt "
"mening: :c:func:`Py_BuildValue` kan få slut på minne, och detta bör "
"kontrolleras."

msgid ""
"You may also call a function with keyword arguments by using :c:func:"
"`PyObject_Call`, which supports arguments and keyword arguments.  As in the "
"above example, we use :c:func:`Py_BuildValue` to construct the dictionary. ::"
msgstr ""
"Du kan också anropa en funktion med nyckelordsargument genom att använda :c:"
"func:`PyObject_Call`, som stöder argument och nyckelordsargument.  Som i "
"exemplet ovan använder vi :c:func:`Py_BuildValue` för att konstruera "
"ordlistan. ::"

msgid ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"name\", val);\n"
"result = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (result == NULL)\n"
"    return NULL; /* Pass error back */\n"
"/* Here maybe use the result */\n"
"Py_DECREF(result);"
msgstr ""
"PyObject *dict;\n"
"...\n"
"dict = Py_BuildValue(\"{s:i}\", \"namn\", val);\n"
"resultat = PyObject_Call(my_callback, NULL, dict);\n"
"Py_DECREF(dict);\n"
"if (resultat == NULL)\n"
"    return NULL; /* Skicka felet tillbaka */\n"
"/* Här kan du kanske använda resultatet */\n"
"Py_DECREF(resultat);"

msgid "Extracting Parameters in Extension Functions"
msgstr "Extrahera parametrar i tilläggsfunktioner"

msgid "The :c:func:`PyArg_ParseTuple` function is declared as follows::"
msgstr "Funktionen :c:func:`PyArg_ParseTuple` deklareras enligt följande::"

msgid "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"
msgstr "int PyArg_ParseTuple(PyObject *arg, const char *format, ...);"

msgid ""
"The *arg* argument must be a tuple object containing an argument list passed "
"from Python to a C function.  The *format* argument must be a format string, "
"whose syntax is explained in :ref:`arg-parsing` in the Python/C API "
"Reference Manual.  The remaining arguments must be addresses of variables "
"whose type is determined by the format string."
msgstr ""
"Argumentet *arg* måste vara ett tuple-objekt som innehåller en argumentlista "
"som skickas från Python till en C-funktion.  Argumentet *format* måste vara "
"en formatsträng, vars syntax förklaras i :ref:`arg-parsing` i Python/C API "
"Reference Manual.  De återstående argumenten måste vara adresser till "
"variabler vars typ bestäms av formatsträngen."

msgid ""
"Note that while :c:func:`PyArg_ParseTuple` checks that the Python arguments "
"have the required types, it cannot check the validity of the addresses of C "
"variables passed to the call: if you make mistakes there, your code will "
"probably crash or at least overwrite random bits in memory.  So be careful!"
msgstr ""
"Observera att medan :c:func:`PyArg_ParseTuple` kontrollerar att Python-"
"argumenten har de nödvändiga typerna, kan den inte kontrollera giltigheten "
"av adresserna för C-variabler som skickas till anropet: om du gör misstag "
"där kommer din kod förmodligen att krascha eller åtminstone skriva över "
"slumpmässiga bitar i minnet.  Så var försiktig!"

msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""
"Observera att alla Python-objektreferenser som tillhandahålls till den som "
"anropar är *lånade* referenser; minska inte deras referensantal!"

msgid "Some example calls::"
msgstr "Några exempel på samtal::"

msgid ""
"int ok;\n"
"int i, j;\n"
"long k, l;\n"
"const char *s;\n"
"Py_ssize_t size;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* No arguments */\n"
"    /* Python call: f() */"
msgstr ""
"int ok;\n"
"int i, j;\n"
"lång k, l;\n"
"konst char *s;\n"
"Py_ssize_t storlek;\n"
"\n"
"ok = PyArg_ParseTuple(args, \"\"); /* Inga argument */\n"
"    /* Python-anrop: f() */"

msgid ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* A string */\n"
"    /* Possible Python call: f('whoops!') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"s\", &s); /* En sträng */\n"
"    /* Möjligt Python-anrop: f('whoops!') */"

msgid ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Two longs and a string "
"*/\n"
"    /* Possible Python call: f(1, 2, 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"lls\", &k, &l, &s); /* Två longs och en sträng "
"*/\n"
"    /* Möjligt Python-anrop: f(1, 2, 'tre') */"

msgid ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* A pair of ints and a string, whose size is also returned */\n"
"    /* Possible Python call: f((1, 2), 'three') */"
msgstr ""
"ok = PyArg_ParseTuple(args, \"(ii)s#\", &i, &j, &s, &size);\n"
"    /* Ett par ints och en sträng, vars storlek också returneras */\n"
"    /* Möjligt Python-anrop: f((1, 2), 'tre') */"

msgid ""
"{\n"
"    const char *file;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* A string, and optionally another string and an integer */\n"
"    /* Possible Python calls:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"
msgstr ""
"{\n"
"    const char *file;\n"
"    const char *mode = \"r\";\n"
"    int bufsize = 0;\n"
"    ok = PyArg_ParseTuple(args, \"s|si\", &file, &mode, &bufsize);\n"
"    /* En sträng, och eventuellt en annan sträng och ett heltal */\n"
"    /* Möjliga Python-anrop:\n"
"       f('spam')\n"
"       f('spam', 'w')\n"
"       f('spam', 'wb', 100000) */\n"
"}"

msgid ""
"{\n"
"    int left, top, right, bottom, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* A rectangle and a point */\n"
"    /* Possible Python call:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"
msgstr ""
"{\n"
"    int vänster, topp, höger, botten, h, v;\n"
"    ok = PyArg_ParseTuple(args, \"((ii)(ii))(ii)\",\n"
"             &left, &top, &right, &bottom, &h, &v);\n"
"    /* En rektangel och en punkt */\n"
"    /* Möjligt Python-anrop:\n"
"       f(((0, 0), (400, 300)), (10, 10)) */\n"
"}"

msgid ""
"{\n"
"    Py_complex c;\n"
"    ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n"
"    /* a complex, also providing a function name for errors */\n"
"    /* Possible Python call: myfunction(1+2j) */\n"
"}"
msgstr ""
"{\n"
"    Py_komplex c;\n"
"    ok = PyArg_ParseTuple(args, \"D:myfunction\", &c);\n"
"    /* ett komplex, som också tillhandahåller ett funktionsnamn för fel */\n"
"    /* Möjligt Python-anrop: myfunction(1+2j) */\n"
"}"

msgid "Keyword Parameters for Extension Functions"
msgstr "Nyckelordsparametrar för tilläggsfunktioner"

msgid ""
"The :c:func:`PyArg_ParseTupleAndKeywords` function is declared as follows::"
msgstr ""
"Funktionen :c:func:`PyArg_ParseTupleAndKeywords` deklareras enligt följande::"

msgid ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char * const "
"*kwlist, ...);"
msgstr ""
"int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,\n"
"                                const char *format, char * const "
"*kwlist, ...);"

msgid ""
"The *arg* and *format* parameters are identical to those of the :c:func:"
"`PyArg_ParseTuple` function.  The *kwdict* parameter is the dictionary of "
"keywords received as the third parameter from the Python runtime.  The "
"*kwlist* parameter is a ``NULL``-terminated list of strings which identify "
"the parameters; the names are matched with the type information from "
"*format* from left to right.  On success, :c:func:"
"`PyArg_ParseTupleAndKeywords` returns true, otherwise it returns false and "
"raises an appropriate exception."
msgstr ""
"Parametrarna *arg* och *format* är identiska med dem i funktionen :c:func:"
"`PyArg_ParseTuple`.  Parametern *kwdict* är den ordbok med nyckelord som tas "
"emot som tredje parameter från Pythons runtime.  Parametern *kwlist* är en "
"``NULL``-avslutad lista med strängar som identifierar parametrarna; namnen "
"matchas med typinformationen från *format* från vänster till höger.  Vid "
"framgång returnerar :c:func:`PyArg_ParseTupleAndKeywords` true, annars "
"returnerar den false och ger upphov till ett lämpligt undantag."

msgid ""
"Nested tuples cannot be parsed when using keyword arguments!  Keyword "
"parameters passed in which are not present in the *kwlist* will cause :exc:"
"`TypeError` to be raised."
msgstr ""
"Nästlade tupler kan inte analyseras när nyckelordsargument används!  "
"Nyckelordsparametrar som skickas in och som inte finns i *kwlist* kommer att "
"orsaka :exc:`TypeError`."

msgid ""
"Here is an example module which uses keywords, based on an example by Geoff "
"Philbrick (philbrick@hks.com)::"
msgstr ""
"Här är ett exempel på en modul som använder nyckelord, baserat på ett "
"exempel av Geoff Philbrick (philbrick@hks.com)::"

msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"static PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"    int voltage;\n"
"    const char *state = \"a stiff\";\n"
"    const char *action = \"voom\";\n"
"    const char *type = \"Norwegian Blue\";\n"
"\n"
"    static char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", "
"NULL};\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"                                     &voltage, &state, &action, &type))\n"
"        return NULL;\n"
"\n"
"    printf(\"-- This parrot wouldn't %s if you put %i Volts through it."
"\\n\",\n"
"           action, voltage);\n"
"    printf(\"-- Lovely plumage, the %s -- It's %s!\\n\", type, state);\n"
"\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"    /* The cast of the function is necessary since PyCFunction values\n"
"     * only take two PyObject* parameters, and keywdarg_parrot() takes\n"
"     * three.\n"
"     */\n"
"    {\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | "
"METH_KEYWORDS,\n"
"     \"Print a lovely skit to standard output.\"},\n"
"    {NULL, NULL, 0, NULL}   /* sentinel */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdarg_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"keywdarg\",\n"
"    .m_size = 0,\n"
"    .m_methods = keywdarg_methods,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"    return PyModuleDef_Init(&keywdarg_module);\n"
"}"
msgstr ""
"#definiera PY_SSIZE_T_CLEAN\n"
"#inkludera <Python.h>\n"
"\n"
"statiskt PyObject *\n"
"keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)\n"
"{\n"
"    int spänning;\n"
"    const char *state = \"en styv\";\n"
"    const char *action = \"voom\";\n"
"    const char *type = \"norsk blå\";\n"
"\n"
"    static char *kwlist[] = {\"voltage\", \"state\", \"action\", \"type\", "
"NULL};\n"
"\n"
"    if (!PyArg_ParseTupleAndKeywords(args, keywds, \"i|sss\", kwlist,\n"
"                                     &voltage, &state, &action, &type))\n"
"        returneras NULL;\n"
"\n"
"    printf(\"-- Den här papegojan skulle inte %s om du satte %i volt genom "
"den.\\n\",\n"
"           åtgärd, spänning);\n"
"    printf(\"-- Vacker fjäderdräkt, den %s -- Den är %s!\\n\", typ, "
"tillstånd);\n"
"\n"
"    Py_RETURN_NONE;\n"
"}\n"
"\n"
"static PyMethodDef keywdarg_methods[] = {\n"
"    /* Castningen av funktionen är nödvändig eftersom PyCFunction-värden\n"
"     * bara tar två PyObject* parametrar och keywdarg_parrot() tar tre\n"
"     * tre.\n"
"     */\n"
"    {\"parrot\", (PyCFunction)(void(*)(void))keywdarg_parrot, METH_VARARGS | "
"METH_KEYWORDS,\n"
"     \"Skriv ut en vacker sketch till standardutmatningen.\"},\n"
"    {NULL, NULL, 0, NULL}   /* sentinel */\n"
"};\n"
"\n"
"static struct PyModuleDef keywdarg_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"keywdarg\",\n"
"    .m_size = 0,\n"
"    .m_methods = keywdarg_methods,\n"
"};\n"
"\n"
"PyMODINIT_FUNC\n"
"PyInit_keywdarg(void)\n"
"{\n"
"    return PyModuleDef_Init(&keywdarg_module);\n"
"}"

msgid "Building Arbitrary Values"
msgstr "Att bygga godtyckliga värden"

msgid ""
"This function is the counterpart to :c:func:`PyArg_ParseTuple`.  It is "
"declared as follows::"
msgstr ""
"Denna funktion är motsvarigheten till :c:func:`PyArg_ParseTuple`.  Den "
"deklareras på följande sätt::"

msgid "PyObject *Py_BuildValue(const char *format, ...);"
msgstr "PyObject *Py_BuildValue(const char *format, ...);"

msgid ""
"It recognizes a set of format units similar to the ones recognized by :c:"
"func:`PyArg_ParseTuple`, but the arguments (which are input to the function, "
"not output) must not be pointers, just values.  It returns a new Python "
"object, suitable for returning from a C function called from Python."
msgstr ""
"Den känner igen en uppsättning formatenheter som liknar dem som känns igen "
"av :c:func:`PyArg_ParseTuple`, men argumenten (som är indata till "
"funktionen, inte utdata) får inte vara pekare, bara värden.  Den returnerar "
"ett nytt Python-objekt, lämpligt för att returnera från en C-funktion som "
"anropas från Python."

msgid ""
"One difference with :c:func:`PyArg_ParseTuple`: while the latter requires "
"its first argument to be a tuple (since Python argument lists are always "
"represented as tuples internally), :c:func:`Py_BuildValue` does not always "
"build a tuple.  It builds a tuple only if its format string contains two or "
"more format units. If the format string is empty, it returns ``None``; if it "
"contains exactly one format unit, it returns whatever object is described by "
"that format unit.  To force it to return a tuple of size 0 or one, "
"parenthesize the format string."
msgstr ""
"En skillnad med :c:func:`PyArg_ParseTuple`: medan den senare kräver att dess "
"första argument är en tupel (eftersom Python-argumentlistor alltid "
"representeras som tuplar internt), bygger :c:func:`Py_BuildValue` inte "
"alltid en tupel.  Den bygger en tupel endast om dess formatsträng innehåller "
"två eller fler formatenheter. Om formatsträngen är tom returnerar den "
"``None``; om den innehåller exakt en formatenhet returnerar den det objekt "
"som beskrivs av den formatenheten.  Om du vill tvinga den att returnera en "
"tupel av storlek 0 eller ett, sätter du formatsträngen i parentes."

msgid ""
"Examples (to the left the call, to the right the resulting Python value):"
msgstr ""
"Exempel (till vänster anropet, till höger det resulterande Python-värdet):"

msgid ""
"Py_BuildValue(\"\")                        None\n"
"Py_BuildValue(\"i\", 123)                  123\n"
"Py_BuildValue(\"iii\", 123, 456, 789)      (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hello\")              'hello'\n"
"Py_BuildValue(\"y\", \"hello\")              b'hello'\n"
"Py_BuildValue(\"ss\", \"hello\", \"world\")    ('hello', 'world')\n"
"Py_BuildValue(\"s#\", \"hello\", 4)          'hell'\n"
"Py_BuildValue(\"y#\", \"hello\", 4)          b'hell'\n"
"Py_BuildValue(\"()\")                      ()\n"
"Py_BuildValue(\"(i)\", 123)                (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456)          (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456)         (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456)         [123, 456]\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456)    {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))"
msgstr ""
"Py_BuildValue(\"\") Ingen\n"
"Py_BuildValue(\"i\", 123) 123\n"
"Py_BuildValue(\"iii\", 123, 456, 789) (123, 456, 789)\n"
"Py_BuildValue(\"s\", \"hallå\") 'hallå'\n"
"Py_BuildValue(\"y\", \"hallå\") b'hallå'\n"
"Py_BuildValue(\"ss\", \"hallå\", \"värld\") (\"hallå\", \"värld\")\n"
"Py_BuildValue(\"s#\", \"hallå\", 4) 'helvete'\n"
"Py_BuildValue(\"y#\", \"hallå\", 4) b'helvete'\n"
"Py_BuildValue(\"()\") ()\n"
"Py_BuildValue(\"(i)\", 123) (123,)\n"
"Py_BuildValue(\"(ii)\", 123, 456) (123, 456)\n"
"Py_BuildValue(\"(i,i)\", 123, 456) (123, 456)\n"
"Py_BuildValue(\"[i,i]\", 123, 456) [123, 456] Py_BuildValue(\"[i,i]\", 123, "
"456)\n"
"Py_BuildValue(\"{s:i,s:i}\",\n"
"              \"abc\", 123, \"def\", 456) {'abc': 123, 'def': 456}\n"
"Py_BuildValue(\"((ii)(ii)) (ii)\",\n"
"              1, 2, 3, 4, 5, 6) (((1, 2), (3, 4)), (5, 6))"

msgid "Reference Counts"
msgstr "Referensräkningar"

msgid ""
"In languages like C or C++, the programmer is responsible for dynamic "
"allocation and deallocation of memory on the heap.  In C, this is done using "
"the functions :c:func:`malloc` and :c:func:`free`.  In C++, the operators "
"``new`` and ``delete`` are used with essentially the same meaning and we'll "
"restrict the following discussion to the C case."
msgstr ""
"I språk som C eller C++ är programmeraren ansvarig för dynamisk allokering "
"och avallokering av minne på heapen.  I C görs detta med hjälp av "
"funktionerna :c:func:`malloc` och :c:func:`free`.  I C++ används "
"operatorerna ``new`` och ``delete`` med i stort sett samma innebörd och vi "
"kommer att begränsa följande diskussion till C-fallet."

msgid ""
"Every block of memory allocated with :c:func:`malloc` should eventually be "
"returned to the pool of available memory by exactly one call to :c:func:"
"`free`. It is important to call :c:func:`free` at the right time.  If a "
"block's address is forgotten but :c:func:`free` is not called for it, the "
"memory it occupies cannot be reused until the program terminates.  This is "
"called a :dfn:`memory leak`.  On the other hand, if a program calls :c:func:"
"`free` for a block and then continues to use the block, it creates a "
"conflict with reuse of the block through another :c:func:`malloc` call.  "
"This is called :dfn:`using freed memory`. It has the same bad consequences "
"as referencing uninitialized data --- core dumps, wrong results, mysterious "
"crashes."
msgstr ""
"Varje minnesblock som allokerats med :c:func:`malloc` bör så småningom "
"återföras till poolen av tillgängligt minne genom exakt ett anrop till :c:"
"func:`free`. Det är viktigt att anropa :c:func:`free` vid rätt tidpunkt.  Om "
"adressen till ett block glöms bort men :c:func:`free` inte anropas för det, "
"kan det minne som det upptar inte återanvändas förrän programmet avslutas.  "
"Detta kallas för en :dfn:`minnesläcka`.  Å andra sidan, om ett program "
"anropar :c:func:`free` för ett block och sedan fortsätter att använda "
"blocket, skapar det en konflikt med återanvändning av blocket genom ett "
"annat :c:func:`malloc`-anrop.  Detta kallas :dfn:`using freed memory`. Det "
"har samma dåliga konsekvenser som att referera till oinitialiserade data --- "
"kärndumpar, felaktiga resultat, mystiska krascher."

msgid ""
"Common causes of memory leaks are unusual paths through the code.  For "
"instance, a function may allocate a block of memory, do some calculation, "
"and then free the block again.  Now a change in the requirements for the "
"function may add a test to the calculation that detects an error condition "
"and can return prematurely from the function.  It's easy to forget to free "
"the allocated memory block when taking this premature exit, especially when "
"it is added later to the code.  Such leaks, once introduced, often go "
"undetected for a long time: the error exit is taken only in a small fraction "
"of all calls, and most modern machines have plenty of virtual memory, so the "
"leak only becomes apparent in a long-running process that uses the leaking "
"function frequently.  Therefore, it's important to prevent leaks from "
"happening by having a coding convention or strategy that minimizes this kind "
"of errors."
msgstr ""
"Vanliga orsaker till minnesläckage är ovanliga vägar genom koden.  En "
"funktion kan t.ex. allokera ett minnesblock, göra en beräkning och sedan "
"frigöra blocket igen.  Nu kan en ändring i kraven för funktionen lägga till "
"ett test i beräkningen som upptäcker ett feltillstånd och kan återvända i "
"förtid från funktionen.  Det är lätt att glömma att frigöra det allokerade "
"minnesblocket när man gör denna för tidiga exit, särskilt när det läggs till "
"senare i koden.  När sådana läckor väl har uppstått går de ofta oupptäckta "
"under lång tid: felreturen sker bara i en liten del av alla anrop, och de "
"flesta moderna maskiner har gott om virtuellt minne, så läckan blir bara "
"uppenbar i en långvarig process som använder den läckande funktionen ofta.  "
"Därför är det viktigt att förhindra att läckor uppstår genom att ha en "
"kodningskonvention eller strategi som minimerar den här typen av fel."

msgid ""
"Since Python makes heavy use of :c:func:`malloc` and :c:func:`free`, it "
"needs a strategy to avoid memory leaks as well as the use of freed memory.  "
"The chosen method is called :dfn:`reference counting`.  The principle is "
"simple: every object contains a counter, which is incremented when a "
"reference to the object is stored somewhere, and which is decremented when a "
"reference to it is deleted. When the counter reaches zero, the last "
"reference to the object has been deleted and the object is freed."
msgstr ""
"Eftersom Python använder sig mycket av :c:func:`malloc` och :c:func:`free`, "
"behöver det en strategi för att undvika minnesläckor och användning av "
"frigjort minne.  Den valda metoden kallas :dfn:`referensräkning`.  Principen "
"är enkel: varje objekt innehåller en räknare, som ökas när en referens till "
"objektet lagras någonstans, och som minskas när en referens till det tas "
"bort. När räknaren når noll har den sista referensen till objektet raderats "
"och objektet är frigjort."

msgid ""
"An alternative strategy is called :dfn:`automatic garbage collection`. "
"(Sometimes, reference counting is also referred to as a garbage collection "
"strategy, hence my use of \"automatic\" to distinguish the two.)  The big "
"advantage of automatic garbage collection is that the user doesn't need to "
"call :c:func:`free` explicitly.  (Another claimed advantage is an "
"improvement in speed or memory usage --- this is no hard fact however.)  The "
"disadvantage is that for C, there is no truly portable automatic garbage "
"collector, while reference counting can be implemented portably (as long as "
"the functions :c:func:`malloc` and :c:func:`free` are available --- which "
"the C Standard guarantees). Maybe some day a sufficiently portable automatic "
"garbage collector will be available for C. Until then, we'll have to live "
"with reference counts."
msgstr ""
"En alternativ strategi kallas :dfn:`automatic garbage collection`. (Ibland "
"kallas referensräkning också för en skräpinsamlingsstrategi, därav min "
"användning av \"automatisk\" för att skilja de två åt)  Den stora fördelen "
"med automatisk garbage collection är att användaren inte behöver anropa :c:"
"func:`free` explicit.  (En annan påstådd fördel är en förbättring av "
"hastighet eller minnesanvändning --- detta är dock inget hårt faktum.)  "
"Nackdelen är att det för C inte finns någon verkligt portabel automatisk "
"garbage collector, medan referensräkning kan implementeras portabelt (så "
"länge funktionerna :c:func:`malloc` och :c:func:`free` är tillgängliga --- "
"vilket C-standarden garanterar). Kanske kommer en dag en tillräckligt "
"portabel automatisk skräpsamlare att finnas tillgänglig för C. Till dess får "
"vi leva med referensräkning."

msgid ""
"While Python uses the traditional reference counting implementation, it also "
"offers a cycle detector that works to detect reference cycles.  This allows "
"applications to not worry about creating direct or indirect circular "
"references; these are the weakness of garbage collection implemented using "
"only reference counting.  Reference cycles consist of objects which contain "
"(possibly indirect) references to themselves, so that each object in the "
"cycle has a reference count which is non-zero.  Typical reference counting "
"implementations are not able to reclaim the memory belonging to any objects "
"in a reference cycle, or referenced from the objects in the cycle, even "
"though there are no further references to the cycle itself."
msgstr ""
"Python använder den traditionella referensräkningsimplementeringen, men "
"erbjuder också en cykeldetektor som upptäcker referenscykler.  Detta gör att "
"applikationer inte behöver oroa sig för att skapa direkta eller indirekta "
"cirkulära referenser; dessa är svagheten hos skräpsamling som implementeras "
"med endast referensräkning.  Referenscykler består av objekt som innehåller "
"(eventuellt indirekta) referenser till sig själva, så att varje objekt i "
"cykeln har ett referensantal som inte är noll.  Typiska implementationer av "
"referensräkning kan inte återta det minne som tillhör något objekt i en "
"referenscykel, eller som refereras från objekten i cykeln, även om det inte "
"finns några ytterligare referenser till själva cykeln."

msgid ""
"The cycle detector is able to detect garbage cycles and can reclaim them. "
"The :mod:`gc` module exposes a way to run the detector (the :func:`~gc."
"collect` function), as well as configuration interfaces and the ability to "
"disable the detector at runtime."
msgstr ""
"Cykeldetektorn kan upptäcka skräpcykler och kan återta dem. Modulen :mod:"
"`gc` exponerar ett sätt att köra detektorn (funktionen :func:`~gc.collect`), "
"samt konfigurationsgränssnitt och möjligheten att inaktivera detektorn vid "
"körning."

msgid "Reference Counting in Python"
msgstr "Referensräkning i Python"

msgid ""
"There are two macros, ``Py_INCREF(x)`` and ``Py_DECREF(x)``, which handle "
"the incrementing and decrementing of the reference count. :c:func:"
"`Py_DECREF` also frees the object when the count reaches zero. For "
"flexibility, it doesn't call :c:func:`free` directly --- rather, it makes a "
"call through a function pointer in the object's :dfn:`type object`.  For "
"this purpose (and others), every object also contains a pointer to its type "
"object."
msgstr ""
"Det finns två makron, ``Py_INCREF(x)`` och ``Py_DECREF(x)``, som hanterar "
"inkrementering och dekrementering av referensantalet. :c:func:`Py_DECREF` "
"frigör också objektet när antalet når noll. För flexibilitetens skull "
"anropar den inte :c:func:`free` direkt --- utan den gör ett anrop via en "
"funktionspekare i objektets :dfn:`type object`.  För detta ändamål (och "
"andra) innehåller varje objekt också en pekare till sitt typobjekt."

msgid ""
"The big question now remains: when to use ``Py_INCREF(x)`` and "
"``Py_DECREF(x)``? Let's first introduce some terms.  Nobody \"owns\" an "
"object; however, you can :dfn:`own a reference` to an object.  An object's "
"reference count is now defined as the number of owned references to it.  The "
"owner of a reference is responsible for calling :c:func:`Py_DECREF` when the "
"reference is no longer needed.  Ownership of a reference can be "
"transferred.  There are three ways to dispose of an owned reference: pass it "
"on, store it, or call :c:func:`Py_DECREF`. Forgetting to dispose of an owned "
"reference creates a memory leak."
msgstr ""
"Nu återstår den stora frågan: när ska man använda ``Py_INCREF(x)`` och "
"``Py_DECREF(x)``? Låt oss först introducera några termer.  Ingen \"äger\" "
"ett objekt, men du kan :dfn:`äga en referens` till ett objekt.  Ett objekts "
"referensantal definieras nu som antalet ägda referenser till det.  Ägaren "
"till en referens är ansvarig för att anropa :c:func:`Py_DECREF` när "
"referensen inte längre behövs.  Äganderätten till en referens kan "
"överföras.  Det finns tre sätt att göra sig av med en ägd referens: skicka "
"den vidare, lagra den eller anropa :c:func:`Py_DECREF`. Om man glömmer att "
"göra sig av med en ägd referens uppstår en minnesläcka."

msgid ""
"It is also possible to :dfn:`borrow` [#]_ a reference to an object.  The "
"borrower of a reference should not call :c:func:`Py_DECREF`.  The borrower "
"must not hold on to the object longer than the owner from which it was "
"borrowed. Using a borrowed reference after the owner has disposed of it "
"risks using freed memory and should be avoided completely [#]_."
msgstr ""
"Det är också möjligt att :dfn:`låna` [#]_ en referens till ett objekt.  "
"Låntagaren av en referens bör inte anropa :c:func:`Py_DECREF`.  Låntagaren "
"får inte behålla objektet längre än ägaren från vilken det lånades. Att "
"använda en lånad referens efter att ägaren har gjort sig av med den riskerar "
"att använda frigjort minne och bör undvikas helt [#]_."

msgid ""
"The advantage of borrowing over owning a reference is that you don't need to "
"take care of disposing of the reference on all possible paths through the "
"code --- in other words, with a borrowed reference you don't run the risk of "
"leaking when a premature exit is taken.  The disadvantage of borrowing over "
"owning is that there are some subtle situations where in seemingly correct "
"code a borrowed reference can be used after the owner from which it was "
"borrowed has in fact disposed of it."
msgstr ""
"Fördelen med att låna en referens jämfört med att äga den är att du inte "
"behöver ta hand om referensen på alla möjliga vägar genom koden --- med "
"andra ord, med en lånad referens löper du inte risken att läcka när en för "
"tidig exit tas.  Nackdelen med att låna i stället för att äga är att det "
"finns vissa subtila situationer där en lånad referens i till synes korrekt "
"kod kan användas efter att ägaren som den lånades från i själva verket har "
"gjort sig av med den."

msgid ""
"A borrowed reference can be changed into an owned reference by calling :c:"
"func:`Py_INCREF`.  This does not affect the status of the owner from which "
"the reference was borrowed --- it creates a new owned reference, and gives "
"full owner responsibilities (the new owner must dispose of the reference "
"properly, as well as the previous owner)."
msgstr ""
"En lånad referens kan ändras till en ägd referens genom att anropa :c:func:"
"`Py_INCREF`.  Detta påverkar inte statusen för den ägare från vilken "
"referensen lånades --- det skapar en ny ägd referens och ger ägaren fullt "
"ansvar (den nya ägaren måste göra sig av med referensen på rätt sätt, liksom "
"den tidigare ägaren)."

msgid "Ownership Rules"
msgstr "Regler för ägande"

msgid ""
"Whenever an object reference is passed into or out of a function, it is part "
"of the function's interface specification whether ownership is transferred "
"with the reference or not."
msgstr ""
"När en objektreferens skickas in i eller ut ur en funktion är det en del av "
"funktionens gränssnittsspecifikation om äganderätten överförs med referensen "
"eller inte."

msgid ""
"Most functions that return a reference to an object pass on ownership with "
"the reference.  In particular, all functions whose function it is to create "
"a new object, such as :c:func:`PyLong_FromLong` and :c:func:`Py_BuildValue`, "
"pass ownership to the receiver.  Even if the object is not actually new, you "
"still receive ownership of a new reference to that object.  For instance, :c:"
"func:`PyLong_FromLong` maintains a cache of popular values and can return a "
"reference to a cached item."
msgstr ""
"De flesta funktioner som returnerar en referens till ett objekt skickar "
"äganderätten vidare med referensen.  I synnerhet alla funktioner vars "
"funktion är att skapa ett nytt objekt, till exempel :c:func:"
"`PyLong_FromLong` och :c:func:`Py_BuildValue`, överför äganderätten till "
"mottagaren.  Även om objektet egentligen inte är nytt, får du ändå "
"äganderätten till en ny referens till objektet.  Till exempel upprätthåller :"
"c:func:`PyLong_FromLong` en cache av populära värden och kan returnera en "
"referens till ett cachat objekt."

msgid ""
"Many functions that extract objects from other objects also transfer "
"ownership with the reference, for instance :c:func:"
"`PyObject_GetAttrString`.  The picture is less clear, here, however, since a "
"few common routines are exceptions: :c:func:`PyTuple_GetItem`, :c:func:"
"`PyList_GetItem`, :c:func:`PyDict_GetItem`, and :c:func:"
"`PyDict_GetItemString` all return references that you borrow from the tuple, "
"list or dictionary."
msgstr ""
"Många funktioner som extraherar objekt från andra objekt överför också "
"äganderätten med referensen, till exempel :c:func:`PyObject_GetAttrString`.  "
"Här är bilden dock inte lika tydlig eftersom några vanliga rutiner utgör "
"undantag: :c:func:`PyTuple_GetItem`, :c:func:`PyList_GetItem`, :c:func:"
"`PyDict_GetItem` och :c:func:`PyDict_GetItemString` returnerar alla "
"referenser som du lånar från tupeln, listan eller ordboken."

msgid ""
"The function :c:func:`PyImport_AddModule` also returns a borrowed reference, "
"even though it may actually create the object it returns: this is possible "
"because an owned reference to the object is stored in ``sys.modules``."
msgstr ""
"Funktionen :c:func:`PyImport_AddModule` returnerar också en lånad referens, "
"även om den faktiskt kan skapa det objekt den returnerar: detta är möjligt "
"eftersom en ägd referens till objektet lagras i ``sys.modules``."

msgid ""
"When you pass an object reference into another function, in general, the "
"function borrows the reference from you --- if it needs to store it, it will "
"use :c:func:`Py_INCREF` to become an independent owner.  There are exactly "
"two important exceptions to this rule: :c:func:`PyTuple_SetItem` and :c:func:"
"`PyList_SetItem`.  These functions take over ownership of the item passed to "
"them --- even if they fail!  (Note that :c:func:`PyDict_SetItem` and friends "
"don't take over ownership --- they are \"normal.\")"
msgstr ""
"När du skickar en objektreferens till en annan funktion lånar funktionen i "
"allmänhet referensen från dig --- om den behöver lagra den kommer den att "
"använda :c:func:`Py_INCREF` för att bli en oberoende ägare.  Det finns exakt "
"två viktiga undantag från denna regel: :c:func:`PyTuple_SetItem` och :c:func:"
"`PyList_SetItem`.  Dessa funktioner tar över ägandet av det objekt som "
"skickas till dem --- även om de misslyckas!  (Observera att :c:func:"
"`PyDict_SetItem` och vänner inte tar över ägandet --- de är \"normala.\")"

msgid ""
"When a C function is called from Python, it borrows references to its "
"arguments from the caller.  The caller owns a reference to the object, so "
"the borrowed reference's lifetime is guaranteed until the function returns.  "
"Only when such a borrowed reference must be stored or passed on, it must be "
"turned into an owned reference by calling :c:func:`Py_INCREF`."
msgstr ""
"När en C-funktion anropas från Python lånar den referenser till sina "
"argument från den som anropar.  Den som anropar äger en referens till "
"objektet, så den lånade referensens livstid är garanterad tills funktionen "
"returneras.  Endast när en sådan lånad referens måste lagras eller skickas "
"vidare, måste den omvandlas till en ägd referens genom att anropa :c:func:"
"`Py_INCREF`."

msgid ""
"The object reference returned from a C function that is called from Python "
"must be an owned reference --- ownership is transferred from the function to "
"its caller."
msgstr ""
"Den objektreferens som returneras från en C-funktion som anropas från Python "
"måste vara en ägd referens --- ägandet överförs från funktionen till den som "
"anropar."

msgid "Thin Ice"
msgstr "Tunn is"

msgid ""
"There are a few situations where seemingly harmless use of a borrowed "
"reference can lead to problems.  These all have to do with implicit "
"invocations of the interpreter, which can cause the owner of a reference to "
"dispose of it."
msgstr ""
"Det finns några situationer där en till synes harmlös användning av en lånad "
"referens kan leda till problem.  Dessa har alla att göra med implicita anrop "
"av tolken, vilket kan leda till att ägaren av en referens gör sig av med den."

msgid ""
"The first and most important case to know about is using :c:func:`Py_DECREF` "
"on an unrelated object while borrowing a reference to a list item.  For "
"instance::"
msgstr ""
"Det första och viktigaste fallet att känna till är att använda :c:func:"
"`Py_DECREF` på ett orelaterat objekt medan man lånar en referens till ett "
"listobjekt.  Till exempel::"

msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""
"void\n"
"bug(PyObject *lista)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    PyList_SetItem(lista, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"

msgid ""
"This function first borrows a reference to ``list[0]``, then replaces "
"``list[1]`` with the value ``0``, and finally prints the borrowed reference. "
"Looks harmless, right?  But it's not!"
msgstr ""
"Den här funktionen lånar först en referens till ``list[0]``, ersätter sedan "
"``list[1]`` med värdet ``0`` och skriver slutligen ut den lånade referensen. "
"Ser ofarligt ut, eller hur?  Men det är det inte!"

msgid ""
"Let's follow the control flow into :c:func:`PyList_SetItem`.  The list owns "
"references to all its items, so when item 1 is replaced, it has to dispose "
"of the original item 1.  Now let's suppose the original item 1 was an "
"instance of a user-defined class, and let's further suppose that the class "
"defined a :meth:`!__del__` method.  If this class instance has a reference "
"count of 1, disposing of it will call its :meth:`!__del__` method."
msgstr ""
"Låt oss följa kontrollflödet in i :c:func:`PyList_SetItem`.  Listan äger "
"referenser till alla sina objekt, så när objekt 1 ersätts måste den göra sig "
"av med det ursprungliga objektet 1.  Låt oss nu anta att det ursprungliga "
"objektet 1 var en instans av en användardefinierad klass, och låt oss vidare "
"anta att klassen definierade en :meth:`!__del__`-metod.  Om denna "
"klassinstans har ett referensantal på 1, kommer dess :meth:`!__del__`-metod "
"att anropas när den kasseras."

msgid ""
"Since it is written in Python, the :meth:`!__del__` method can execute "
"arbitrary Python code.  Could it perhaps do something to invalidate the "
"reference to ``item`` in :c:func:`!bug`?  You bet!  Assuming that the list "
"passed into :c:func:`!bug` is accessible to the :meth:`!__del__` method, it "
"could execute a statement to the effect of ``del list[0]``, and assuming "
"this was the last reference to that object, it would free the memory "
"associated with it, thereby invalidating ``item``."
msgstr ""
"Eftersom den är skriven i Python kan metoden :meth:`!__del__` exekvera "
"godtycklig Python-kod.  Kan den kanske göra något för att ogiltigförklara "
"referensen till ``item`` i :c:func:`!bug`?  Det kan du ge dig på!  Förutsatt "
"att listan som skickas till :c:func:`!bug` är tillgänglig för metoden :meth:"
"`!__del__`, skulle den kunna utföra ett uttalande med effekten ``del "
"list[0]``, och förutsatt att detta var den sista referensen till det "
"objektet, skulle den frigöra minnet som är associerat med det, och därmed "
"ogiltigförklara ``item``."

msgid ""
"The solution, once you know the source of the problem, is easy: temporarily "
"increment the reference count.  The correct version of the function reads::"
msgstr ""
"Lösningen, när du väl känner till källan till problemet, är enkel: öka "
"referensantalet tillfälligt.  Den korrekta versionen av funktionen lyder::"

msgid ""
"void\n"
"no_bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(list, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(item, stdout, 0);\n"
"    Py_DECREF(item);\n"
"}"
msgstr ""
"ogiltigt\n"
"no_bug(PyObject *lista)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"\n"
"    Py_INCREF(item);\n"
"    PyList_SetItem(lista, 1, PyLong_FromLong(0L));\n"
"    PyObject_Print(objekt, stdout, 0);\n"
"    Py_DECREF(objekt);\n"
"}"

msgid ""
"This is a true story.  An older version of Python contained variants of this "
"bug and someone spent a considerable amount of time in a C debugger to "
"figure out why his :meth:`!__del__` methods would fail..."
msgstr ""
"Det här är en sann historia.  En äldre version av Python innehöll varianter "
"av denna bugg och någon tillbringade en avsevärd tid i en C-debugger för att "
"räkna ut varför hans :meth:`!__del__`-metoder misslyckades..."

msgid ""
"The second case of problems with a borrowed reference is a variant involving "
"threads.  Normally, multiple threads in the Python interpreter can't get in "
"each other's way, because there is a :term:`global lock <global interpreter "
"lock>` protecting Python's entire object space. However, it is possible to "
"temporarily release this lock using the macro :c:macro:"
"`Py_BEGIN_ALLOW_THREADS`, and to re-acquire it using :c:macro:"
"`Py_END_ALLOW_THREADS`.  This is common around blocking I/O calls, to let "
"other threads use the processor while waiting for the I/O to complete. "
"Obviously, the following function has the same problem as the previous one::"
msgstr ""
"Det andra fallet av problem med en lånad referens är en variant som "
"involverar trådar.  Normalt kan flera trådar i Python-tolken inte komma i "
"vägen för varandra, eftersom det finns ett :term:`globalt lås <global "
"interpreter lock>` som skyddar hela Pythons objektutrymme. Det är dock "
"möjligt att tillfälligt frigöra detta lås med hjälp av makrot :c:macro:"
"`Py_BEGIN_ALLOW_THREADS`, och att återta det med hjälp av :c:macro:"
"`Py_END_ALLOW_THREADS`.  Detta är vanligt vid blockerande I/O-anrop, för att "
"låta andra trådar använda processorn medan de väntar på att I/O ska "
"slutföras. Uppenbarligen har följande funktion samma problem som den "
"föregående::"

msgid ""
"void\n"
"bug(PyObject *list)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...some blocking I/O call...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"
msgstr ""
"void\n"
"bug(PyObject *lista)\n"
"{\n"
"    PyObject *item = PyList_GetItem(list, 0);\n"
"    Py_BEGIN_ALLOW_THREADS\n"
"    ...något blockerande I/O-anrop...\n"
"    Py_END_ALLOW_THREADS\n"
"    PyObject_Print(item, stdout, 0); /* BUG! */\n"
"}"

msgid "NULL Pointers"
msgstr "NULL-pekare"

msgid ""
"In general, functions that take object references as arguments do not expect "
"you to pass them ``NULL`` pointers, and will dump core (or cause later core "
"dumps) if you do so.  Functions that return object references generally "
"return ``NULL`` only to indicate that an exception occurred.  The reason for "
"not testing for ``NULL`` arguments is that functions often pass the objects "
"they receive on to other function --- if each function were to test for "
"``NULL``, there would be a lot of redundant tests and the code would run "
"more slowly."
msgstr ""
"I allmänhet förväntar sig inte funktioner som tar objektreferenser som "
"argument att du ska skicka ``NULL``-pekare till dem, och de kommer att dumpa "
"kärnan (eller orsaka senare dumpningar av kärnan) om du gör det.  Funktioner "
"som returnerar objektreferenser returnerar i allmänhet ``NULL`` endast för "
"att indikera att ett undantag inträffat.  Anledningen till att man inte "
"testar för ``NULL``-argument är att funktioner ofta skickar de objekt de tar "
"emot vidare till andra funktioner --- om varje funktion skulle testa för "
"``NULL`` skulle det finnas många överflödiga tester och koden skulle gå "
"långsammare."

msgid ""
"It is better to test for ``NULL`` only at the \"source:\" when a pointer "
"that may be ``NULL`` is received, for example, from :c:func:`malloc` or from "
"a function that may raise an exception."
msgstr ""
"Det är bättre att testa för ``NULL`` endast vid \"källan:\" när en pekare "
"som kan vara ``NULL`` tas emot, till exempel från :c:func:`malloc` eller "
"från en funktion som kan ge upphov till ett undantag."

msgid ""
"The macros :c:func:`Py_INCREF` and :c:func:`Py_DECREF` do not check for "
"``NULL`` pointers --- however, their variants :c:func:`Py_XINCREF` and :c:"
"func:`Py_XDECREF` do."
msgstr ""
"Makron :c:func:`Py_INCREF` och :c:func:`Py_DECREF` kontrollerar inte för "
"``NULL`` pekare --- men det gör däremot deras varianter :c:func:`Py_XINCREF` "
"och :c:func:`Py_XDECREF`."

msgid ""
"The macros for checking for a particular object type (``Pytype_Check()``) "
"don't check for ``NULL`` pointers --- again, there is much code that calls "
"several of these in a row to test an object against various different "
"expected types, and this would generate redundant tests.  There are no "
"variants with ``NULL`` checking."
msgstr ""
"Makron för att kontrollera en viss objekttyp (``Pytype_Check()``) "
"kontrollerar inte för ``NULL`` pekare --- återigen, det finns mycket kod som "
"anropar flera av dessa i rad för att testa ett objekt mot olika olika "
"förväntade typer, och detta skulle generera överflödiga tester.  Det finns "
"inga varianter med ``NULL`` kontroll."

msgid ""
"The C function calling mechanism guarantees that the argument list passed to "
"C functions (``args`` in the examples) is never ``NULL`` --- in fact it "
"guarantees that it is always a tuple [#]_."
msgstr ""
"C-funktionens anropsmekanism garanterar att den argumentlista som skickas "
"till C-funktioner (``args`` i exemplen) aldrig är ``NULL`` --- i själva "
"verket garanterar den att den alltid är en tupel [#]_."

msgid ""
"It is a severe error to ever let a ``NULL`` pointer \"escape\" to the Python "
"user."
msgstr ""
"Det är ett allvarligt fel att någonsin låta en ``NULL``-pekare \"fly\" till "
"Python-användaren."

msgid "Writing Extensions in C++"
msgstr "Skriva tillägg i C++"

msgid ""
"It is possible to write extension modules in C++.  Some restrictions apply.  "
"If the main program (the Python interpreter) is compiled and linked by the C "
"compiler, global or static objects with constructors cannot be used.  This "
"is not a problem if the main program is linked by the C++ compiler.  "
"Functions that will be called by the Python interpreter (in particular, "
"module initialization functions) have to be declared using ``extern \"C\"``. "
"It is unnecessary to enclose the Python header files in ``extern \"C\" {...}"
"`` --- they use this form already if the symbol ``__cplusplus`` is defined "
"(all recent C++ compilers define this symbol)."
msgstr ""
"Det är möjligt att skriva tilläggsmoduler i C++.  Vissa begränsningar "
"gäller.  Om huvudprogrammet (Python-tolken) kompileras och länkas av en C-"
"kompilator kan globala eller statiska objekt med konstruktörer inte "
"användas.  Detta är inte ett problem om huvudprogrammet länkas av C++-"
"kompilatorn.  Funktioner som kommer att anropas av Python-tolken (i "
"synnerhet modulinitialiseringsfunktioner) måste deklareras med hjälp av "
"``extern \"C\"``. Det är onödigt att bifoga Pythons headerfiler i ``extern "
"\"C\" {...}`` --- de använder denna form redan om symbolen ``__cplusplus`` "
"är definierad (alla nyare C++-kompilatorer definierar denna symbol)."

msgid "Providing a C API for an Extension Module"
msgstr "Tillhandahålla ett C API för en tilläggsmodul"

msgid ""
"Many extension modules just provide new functions and types to be used from "
"Python, but sometimes the code in an extension module can be useful for "
"other extension modules. For example, an extension module could implement a "
"type \"collection\" which works like lists without order. Just like the "
"standard Python list type has a C API which permits extension modules to "
"create and manipulate lists, this new collection type should have a set of C "
"functions for direct manipulation from other extension modules."
msgstr ""
"Många tilläggsmoduler tillhandahåller bara nya funktioner och typer som kan "
"användas från Python, men ibland kan koden i en tilläggsmodul vara användbar "
"för andra tilläggsmoduler. Till exempel kan en tilläggsmodul implementera en "
"typ \"collection\" som fungerar som listor utan ordning. Precis som Pythons "
"standardtyp list har ett C-API som tillåter tilläggsmoduler att skapa och "
"manipulera listor, bör denna nya samlingstyp ha en uppsättning C-funktioner "
"för direkt manipulation från andra tilläggsmoduler."

msgid ""
"At first sight this seems easy: just write the functions (without declaring "
"them ``static``, of course), provide an appropriate header file, and "
"document the C API. And in fact this would work if all extension modules "
"were always linked statically with the Python interpreter. When modules are "
"used as shared libraries, however, the symbols defined in one module may not "
"be visible to another module. The details of visibility depend on the "
"operating system; some systems use one global namespace for the Python "
"interpreter and all extension modules (Windows, for example), whereas others "
"require an explicit list of imported symbols at module link time (AIX is one "
"example), or offer a choice of different strategies (most Unices). And even "
"if symbols are globally visible, the module whose functions one wishes to "
"call might not have been loaded yet!"
msgstr ""
"Vid första anblicken verkar detta enkelt: skriv bara funktionerna "
"(naturligtvis utan att deklarera dem som \"statiska\"), tillhandahåll en "
"lämplig header-fil och dokumentera C API. Och det skulle faktiskt fungera om "
"alla tilläggsmoduler alltid länkades statiskt med Python-tolken. När moduler "
"används som delade bibliotek kan det dock hända att de symboler som "
"definieras i en modul inte är synliga för en annan modul. Detaljerna kring "
"synlighet beror på operativsystemet; vissa system använder ett globalt "
"namnområde för Python-tolken och alla tilläggsmoduler (Windows, till "
"exempel), medan andra kräver en explicit lista över importerade symboler vid "
"modullänkning (AIX är ett exempel), eller erbjuder ett urval av olika "
"strategier (de flesta Unices). Och även om symbolerna är globalt synliga är "
"det inte säkert att den modul vars funktioner man vill anropa har laddats in "
"än!"

msgid ""
"Portability therefore requires not to make any assumptions about symbol "
"visibility. This means that all symbols in extension modules should be "
"declared ``static``, except for the module's initialization function, in "
"order to avoid name clashes with other extension modules (as discussed in "
"section :ref:`methodtable`). And it means that symbols that *should* be "
"accessible from other extension modules must be exported in a different way."
msgstr ""
"Portabilitet kräver därför att man inte gör några antaganden om symbolers "
"synlighet. Detta innebär att alla symboler i tilläggsmoduler bör deklareras "
"``statiska``, med undantag för modulens initialiseringsfunktion, för att "
"undvika namnkrockar med andra tilläggsmoduler (vilket diskuteras i avsnitt :"
"ref:`methodtable`). Och det innebär att symboler som *bör* vara åtkomliga "
"från andra tilläggsmoduler måste exporteras på ett annat sätt."

msgid ""
"Python provides a special mechanism to pass C-level information (pointers) "
"from one extension module to another one: Capsules. A Capsule is a Python "
"data type which stores a pointer (:c:expr:`void \\*`).  Capsules can only be "
"created and accessed via their C API, but they can be passed around like any "
"other Python object. In particular,  they can be assigned to a name in an "
"extension module's namespace. Other extension modules can then import this "
"module, retrieve the value of this name, and then retrieve the pointer from "
"the Capsule."
msgstr ""
"Python tillhandahåller en speciell mekanism för att skicka information på C-"
"nivå (pekare) från en tilläggsmodul till en annan: Kapslar. En Capsule är en "
"Python-datatyp som lagrar en pekare (:c:expr:`void \\*`).  Kapslar kan bara "
"skapas och nås via deras C API, men de kan skickas runt som vilket annat "
"Python-objekt som helst. I synnerhet kan de tilldelas ett namn i en "
"tilläggsmoduls namnrymd. Andra tilläggsmoduler kan sedan importera den här "
"modulen, hämta värdet på det här namnet och sedan hämta pekaren från Capsule."

msgid ""
"There are many ways in which Capsules can be used to export the C API of an "
"extension module. Each function could get its own Capsule, or all C API "
"pointers could be stored in an array whose address is published in a "
"Capsule. And the various tasks of storing and retrieving the pointers can be "
"distributed in different ways between the module providing the code and the "
"client modules."
msgstr ""
"Det finns många sätt att använda kapslar för att exportera C API för en "
"tilläggsmodul. Varje funktion kan få sin egen Capsule, eller så kan alla C "
"API-pekare lagras i en array vars adress publiceras i en Capsule. Och de "
"olika uppgifterna för att lagra och hämta pekarna kan fördelas på olika sätt "
"mellan modulen som tillhandahåller koden och klientmodulerna."

msgid ""
"Whichever method you choose, it's important to name your Capsules properly. "
"The function :c:func:`PyCapsule_New` takes a name parameter (:c:expr:`const "
"char \\*`); you're permitted to pass in a ``NULL`` name, but we strongly "
"encourage you to specify a name.  Properly named Capsules provide a degree "
"of runtime type-safety; there is no feasible way to tell one unnamed Capsule "
"from another."
msgstr ""
"Oavsett vilken metod du väljer är det viktigt att namnge dina kapslar på "
"rätt sätt. Funktionen :c:func:`PyCapsule_New` tar emot en namnparameter (:c:"
"expr:`const char \\*`); du får skicka in ett ``NULL`` namn, men vi "
"uppmuntrar dig starkt att ange ett namn.  Korrekt namngivna kapslar ger en "
"viss grad av typsäkerhet under körning; det finns inget genomförbart sätt "
"att skilja en namnlös kapsel från en annan."

msgid ""
"In particular, Capsules used to expose C APIs should be given a name "
"following this convention::"
msgstr ""
"I synnerhet bör kapslar som används för att exponera C API:er ges ett namn "
"enligt följande konvention::"

msgid "modulename.attributename"
msgstr "modulename.attributnamn"

msgid ""
"The convenience function :c:func:`PyCapsule_Import` makes it easy to load a "
"C API provided via a Capsule, but only if the Capsule's name matches this "
"convention.  This behavior gives C API users a high degree of certainty that "
"the Capsule they load contains the correct C API."
msgstr ""
"Bekvämlighetsfunktionen :c:func:`PyCapsule_Import` gör det enkelt att ladda "
"ett C API som tillhandahålls via en Capsule, men bara om Capsulens namn "
"matchar denna konvention.  Detta beteende ger C API-användare en hög grad av "
"säkerhet att den Capsule de laddar innehåller rätt C API."

msgid ""
"The following example demonstrates an approach that puts most of the burden "
"on the writer of the exporting module, which is appropriate for commonly "
"used library modules. It stores all C API pointers (just one in the "
"example!) in an array of :c:expr:`void` pointers which becomes the value of "
"a Capsule. The header file corresponding to the module provides a macro that "
"takes care of importing the module and retrieving its C API pointers; client "
"modules only have to call this macro before accessing the C API."
msgstr ""
"Följande exempel visar ett tillvägagångssätt som lägger det mesta av bördan "
"på författaren av den exporterande modulen, vilket är lämpligt för vanliga "
"biblioteksmoduler. Den lagrar alla C API-pekare (bara en i exemplet!) i en "
"array av :c:expr:`void`-pekare som blir värdet på en Capsule. Headerfilen "
"som motsvarar modulen innehåller ett makro som tar hand om att importera "
"modulen och hämta dess C API-pekare; klientmoduler behöver bara anropa detta "
"makro innan de får tillgång till C API."

msgid ""
"The exporting module is a modification of the :mod:`!spam` module from "
"section :ref:`extending-simpleexample`. The function :func:`!spam.system` "
"does not call the C library function :c:func:`system` directly, but a "
"function :c:func:`!PySpam_System`, which would of course do something more "
"complicated in reality (such as adding \"spam\" to every command). This "
"function :c:func:`!PySpam_System` is also exported to other extension "
"modules."
msgstr ""
"Den exporterande modulen är en modifiering av :mod:`!spam`-modulen från "
"avsnitt :ref:`extending-simpleexample`. Funktionen :func:`!spam.system` "
"anropar inte C-bibliotekets funktion :c:func:`system` direkt, utan en "
"funktion :c:func:`!PySpam_System`, som naturligtvis skulle göra något mer "
"komplicerat i verkligheten (som att lägga till \"spam\" till varje "
"kommando). Denna funktion :c:func:`!PySpam_System` exporteras också till "
"andra tilläggsmoduler."

msgid ""
"The function :c:func:`!PySpam_System` is a plain C function, declared "
"``static`` like everything else::"
msgstr ""
"Funktionen :c:func:`!PySpam_System` är en vanlig C-funktion, deklarerad "
"``static`` som allt annat::"

msgid ""
"static int\n"
"PySpam_System(const char *command)\n"
"{\n"
"    return system(command);\n"
"}"
msgstr ""
"statisk int\n"
"PySpam_System(const char *kommando)\n"
"{\n"
"    return system(kommando);\n"
"}"

msgid "The function :c:func:`!spam_system` is modified in a trivial way::"
msgstr "Funktionen :c:func:`!spam_system` modifieras på ett trivialt sätt::"

msgid ""
"static PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *command;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        return NULL;\n"
"    sts = PySpam_System(command);\n"
"    return PyLong_FromLong(sts);\n"
"}"
msgstr ""
"statiskt PyObject *\n"
"spam_system(PyObject *self, PyObject *args)\n"
"{\n"
"    const char *kommando;\n"
"    int sts;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"s\", &command))\n"
"        returnera NULL;\n"
"    sts = PySpam_System(kommando);\n"
"    return PyLong_FromLong(sts);\n"
"}"

msgid "In the beginning of the module, right after the line ::"
msgstr "I början av modulen, direkt efter raden ::"

msgid "#include <Python.h>"
msgstr "#inkludera <Python.h>"

msgid "two more lines must be added::"
msgstr "ytterligare två rader måste läggas till::"

msgid ""
"#define SPAM_MODULE\n"
"#include \"spammodule.h\""
msgstr ""
"#definiera SPAM_MODULE\n"
"#inkludera \"spammodule.h\""

msgid ""
"The ``#define`` is used to tell the header file that it is being included in "
"the exporting module, not a client module. Finally, the module's :c:data:"
"`mod_exec <Py_mod_exec>` function must take care of initializing the C API "
"pointer array::"
msgstr ""
"``#define`` används för att tala om för headerfilen att den ingår i den "
"exporterande modulen, inte i en klientmodul. Slutligen måste modulens "
"funktion :c:data:`mod_exec <Py_mod_exec>` ta hand om initialiseringen av C "
"API-pekaren array::"

msgid ""
"static int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    static void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    /* Initialize the C API pointer array */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* Create a Capsule containing the API pointer array's address */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", "
"NULL);\n"
"\n"
"    if (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"spam_module_exec(PyObject *m)\n"
"{\n"
"    statiskt void *PySpam_API[PySpam_API_pointers];\n"
"    PyObject *c_api_object;\n"
"\n"
"    /* Initialisera C API-pekararrayen */\n"
"    PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;\n"
"\n"
"    /* Skapa en kapsel som innehåller API-pekararrayens adress */\n"
"    c_api_object = PyCapsule_New((void *)PySpam_API, \"spam._C_API\", "
"NULL);\n"
"\n"
"    if (PyModule_Add(m, \"_C_API\", c_api_object) < 0) {\n"
"        return -1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

msgid ""
"Note that ``PySpam_API`` is declared ``static``; otherwise the pointer array "
"would disappear when :c:func:`!PyInit_spam` terminates!"
msgstr ""
"Observera att ``PySpam_API`` är deklarerat ``statiskt``; annars skulle "
"pekararrayen försvinna när :c:func:`!PyInit_spam` avslutas!"

msgid ""
"The bulk of the work is in the header file :file:`spammodule.h`, which looks "
"like this::"
msgstr ""
"Huvuddelen av arbetet ligger i header-filen :file:`spammodule.h`, som ser ut "
"så här::"

msgid ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* Header file for spammodule */\n"
"\n"
"/* C API functions */\n"
"#define PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *command)\n"
"\n"
"/* Total number of C API pointers */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* This section is used when compiling spammodule.c */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* This section is used in modules that use spammodule's API */\n"
"\n"
"static void **PySpam_API;\n"
"\n"
"#define PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) "
"PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* Return -1 on error, 0 on success.\n"
" * PyCapsule_Import will set an exception if there's an error.\n"
" */\n"
"static int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"
msgstr ""
"#ifndef Py_SPAMMODULE_H\n"
"#define Py_SPAMMODULE_H\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"/* Huvudfil för spammodul */\n"
"\n"
"/* C API-funktioner */\n"
"#definiera PySpam_System_NUM 0\n"
"#define PySpam_System_RETURN int\n"
"#define PySpam_System_PROTO (const char *kommando)\n"
"\n"
"/* Totalt antal C API-pekare */\n"
"#define PySpam_API_pointers 1\n"
"\n"
"\n"
"#ifdef SPAM_MODULE\n"
"/* Detta avsnitt används vid kompilering av spammodule.c */\n"
"\n"
"static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;\n"
"\n"
"#else\n"
"/* Detta avsnitt används i moduler som använder spammodules API */\n"
"\n"
"statiskt void **PySpam_API;\n"
"\n"
"#definiera PySpam_System \\\n"
" (*(PySpam_System_RETURN (*)PySpam_System_PROTO) "
"PySpam_API[PySpam_System_NUM])\n"
"\n"
"/* Returnerar -1 vid fel, 0 vid framgång.\n"
" * PyCapsule_Import kommer att sätta ett undantag om det finns ett fel.\n"
" */\n"
"statisk int\n"
"import_spam(void)\n"
"{\n"
"    PySpam_API = (void **)PyCapsule_Import(\"spam._C_API\", 0);\n"
"    return (PySpam_API != NULL) ? 0 : -1;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* !defined(Py_SPAMMODULE_H) */"

msgid ""
"All that a client module must do in order to have access to the function :c:"
"func:`!PySpam_System` is to call the function (or rather macro) :c:func:`!"
"import_spam` in its :c:data:`mod_exec <Py_mod_exec>` function::"
msgstr ""
"Allt som en klientmodul behöver göra för att få tillgång till funktionen :c:"
"func:`!PySpam_System` är att anropa funktionen (eller snarare makrot) :c:"
"func:`!import_spam` i sin :c:data:`mod_exec <Py_mod_exec>`-funktion::"

msgid ""
"static int\n"
"client_module_exec(PyObject *m)\n"
"{\n"
"    if (import_spam() < 0) {\n"
"        return -1;\n"
"    }\n"
"    /* additional initialization can happen here */\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"client_module_exec(PyObject *m)\n"
"{\n"
"    if (import_spam() < 0) {\n"
"        returnerar -1;\n"
"    }\n"
"    /* ytterligare initialisering kan ske här */\n"
"    return 0;\n"
"}"

msgid ""
"The main disadvantage of this approach is that the file :file:`spammodule.h` "
"is rather complicated. However, the basic structure is the same for each "
"function that is exported, so it has to be learned only once."
msgstr ""
"Den största nackdelen med detta tillvägagångssätt är att filen :file:"
"`spammodule.h` är ganska komplicerad. Grundstrukturen är dock densamma för "
"varje funktion som exporteras, så den behöver bara läras in en gång."

msgid ""
"Finally it should be mentioned that Capsules offer additional functionality, "
"which is especially useful for memory allocation and deallocation of the "
"pointer stored in a Capsule. The details are described in the Python/C API "
"Reference Manual in the section :ref:`capsules` and in the implementation of "
"Capsules (files :file:`Include/pycapsule.h` and :file:`Objects/pycapsule.c` "
"in the Python source code distribution)."
msgstr ""
"Slutligen bör det nämnas att Capsules erbjuder ytterligare funktionalitet, "
"som är särskilt användbar för minnesallokering och deallokering av pekaren "
"som lagras i en Capsule. Detaljerna beskrivs i Python/C API Reference Manual "
"i avsnittet :ref:`capsules` och i implementationen av Capsules (filerna :"
"file:`Include/pycapsule.h` och :file:`Objects/pycapsule.c` i Pythons "
"källkodsdistribution)."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"An interface for this function already exists in the standard module :mod:"
"`os` --- it was chosen as a simple and straightforward example."
msgstr ""
"Ett gränssnitt för denna funktion finns redan i standardmodulen :mod:`os` "
"--- den valdes som ett enkelt och okomplicerat exempel."

msgid ""
"The metaphor of \"borrowing\" a reference is not completely correct: the "
"owner still has a copy of the reference."
msgstr ""
"Metaforen med att \"låna\" en referens är inte helt korrekt: ägaren har "
"fortfarande en kopia av referensen."

msgid ""
"Checking that the reference count is at least 1 **does not work** --- the "
"reference count itself could be in freed memory and may thus be reused for "
"another object!"
msgstr ""
"Att kontrollera att referensantalet är minst 1 **fungerar inte** --- själva "
"referensantalet kan finnas i det frigjorda minnet och kan därmed "
"återanvändas för ett annat objekt!"

msgid ""
"These guarantees don't hold when you use the \"old\" style calling "
"convention --- this is still found in much existing code."
msgstr ""
"Dessa garantier gäller inte när du använder den \"gamla\" anropskonventionen "
"--- detta finns fortfarande i mycket befintlig kod."

msgid "PyObject_CallObject (C function)"
msgstr "PyObject_CallObject (C-funktion)"

msgid "PyArg_ParseTuple (C function)"
msgstr "PyArg_ParseTuple (C-funktion)"

msgid "PyArg_ParseTupleAndKeywords (C function)"
msgstr "PyArg_ParseTupleAndKeywords (C-funktion)"

msgid "Philbrick, Geoff"
msgstr "Philbrick, Geoff"
