# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Input and Output"
msgstr "Inmatning och utmatning"

msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. This "
"chapter will discuss some of the possibilities."
msgstr ""
"Det finns flera sätt att presentera utdata från ett program; data kan "
"skrivas ut i en läsbar form eller skrivas till en fil för framtida "
"användning. I detta kapitel diskuteras några av dessa möjligheter."

msgid "Fancier Output Formatting"
msgstr "Mer avancerad utmatningsformatering"

msgid ""
"So far we've encountered two ways of writing values: *expression statements* "
"and the :func:`print` function.  (A third way is using the :meth:`~io."
"TextIOBase.write` method of file objects; the standard output file can be "
"referenced as ``sys.stdout``. See the Library Reference for more information "
"on this.)"
msgstr ""
"Hittills har vi stött på två sätt att skriva värden: *uttryckssatser* och "
"funktionen :func:`print`.  (Ett tredje sätt är att använda metoden :meth:"
"`~io.TextIOBase.write` för filobjekt; standardutdatafilen kan refereras till "
"som ``sys.stdout``. Se biblioteksreferensen för mer information om detta)"

msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"Ofta vill du ha mer kontroll över formateringen av dina utdata än att bara "
"skriva ut mellanslagsseparerade värden. Det finns flera sätt att formatera "
"utdata."

msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string with "
"``f`` or ``F`` before the opening quotation mark or triple quotation mark. "
"Inside this string, you can write a Python expression between ``{`` and ``}"
"`` characters that can refer to variables or literal values."
msgstr ""
"För att använda :ref:``formaterade stränglitteraler <tut-f-strings>`, börja "
"en sträng med ``f`` eller ``F`` före det inledande citattecknet eller "
"trippelcitationstecknet. Inuti denna sträng kan du skriva ett Python-uttryck "
"mellan tecknen ``{`` och ``}`` som kan referera till variabler eller "
"bokstavliga värden."

msgid ""
">>> year = 2016\n"
">>> event = 'Referendum'\n"
">>> f'Results of the {year} {event}'\n"
"'Results of the 2016 Referendum'"
msgstr ""
">>> år = 2016\n"
">>> händelse = 'Folkomröstning'\n"
">>> f'Resultat av {year} {event}'\n"
"\"Resultat av folkomröstningen 2016"

msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll also "
"need to provide the information to be formatted. In the following code block "
"there are two examples of how to format variables:"
msgstr ""
"Metoden :meth:`str.format` för strängar kräver mer manuellt arbete.  Du "
"kommer fortfarande att använda ``{`` och ``}`` för att markera var en "
"variabel ska ersättas och kan ge detaljerade formateringsdirektiv, men du "
"måste också tillhandahålla den information som ska formateras. I följande "
"kodblock finns två exempel på hur man formaterar variabler:"

msgid ""
">>> yes_votes = 42_572_654\n"
">>> total_votes = 85_705_149\n"
">>> percentage = yes_votes / total_votes\n"
">>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)\n"
"' 42572654 YES votes  49.67%'"
msgstr ""
">>> ja_röster = 42_572_654\n"
">>> totalt antal röster = 85_705_149\n"
">>> procent = ja_röster / totala_röster\n"
">>> '{:-9} JA-röster {:2.2%}'.format(yes_votes, procent)\n"
"' 42572654 JA-röster 49,67%'"

msgid ""
"Notice how the ``yes_votes`` are padded with spaces and a negative sign only "
"for negative numbers. The example also prints ``percentage`` multiplied by "
"100, with 2 decimal places and followed by a percent sign (see :ref:"
"`formatspec` for details)."
msgstr ""
"Lägg märke till hur ``yes_votes`` fylls i med mellanslag och ett negativt "
"tecken endast för negativa tal. I exemplet skrivs även ``procent`` ut "
"multiplicerat med 100, med 2 decimaler och följt av ett procenttecken (se :"
"ref:`formatspec` för detaljer)."

msgid ""
"Finally, you can do all the string handling yourself by using string slicing "
"and concatenation operations to create any layout you can imagine.  The "
"string type has some methods that perform useful operations for padding "
"strings to a given column width."
msgstr ""
"Slutligen kan du göra all stränghantering själv genom att använda "
"strängskärning och konkatenering för att skapa vilken layout du än kan tänka "
"dig.  Strängtypen har några metoder som utför användbara operationer för att "
"fylla ut strängar till en given kolumnbredd."

msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string with "
"the :func:`repr` or :func:`str` functions."
msgstr ""
"Om du inte behöver några avancerade utdata utan bara vill ha en snabb "
"visning av några variabler för felsökning kan du konvertera valfritt värde "
"till en sträng med funktionerna :func:`repr` eller :func:`str`."

msgid ""
"The :func:`str` function is meant to return representations of values which "
"are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a :exc:"
"`SyntaxError` if there is no equivalent syntax).  For objects which don't "
"have a particular representation for human consumption, :func:`str` will "
"return the same value as :func:`repr`.  Many values, such as numbers or "
"structures like lists and dictionaries, have the same representation using "
"either function.  Strings, in particular, have two distinct representations."
msgstr ""
"Funktionen :func:`str` är tänkt att returnera representationer av värden som "
"är någorlunda läsbara för människor, medan :func:`repr` är tänkt att "
"generera representationer som kan läsas av tolken (eller tvinga fram ett :"
"exc:`SyntaxError` om det inte finns någon motsvarande syntax).  För objekt "
"som inte har en särskild representation för mänsklig konsumtion, kommer :"
"func:`str` att returnera samma värde som :func:`repr`.  Många värden, t.ex. "
"tal eller strukturer som listor och ordböcker, har samma representation med "
"båda funktionerna.  Strängar, i synnerhet, har två olika representationer."

msgid "Some examples::"
msgstr "Några exempel::"

msgid ""
">>> s = 'Hello, world.'\n"
">>> str(s)\n"
"'Hello, world.'\n"
">>> repr(s)\n"
"\"'Hello, world.'\"\n"
">>> str(1/7)\n"
"'0.14285714285714285'\n"
">>> x = 10 * 3.25\n"
">>> y = 200 * 200\n"
">>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n"
">>> print(s)\n"
"The value of x is 32.5, and y is 40000...\n"
">>> # The repr() of a string adds string quotes and backslashes:\n"
">>> hello = 'hello, world\\n'\n"
">>> hellos = repr(hello)\n"
">>> print(hellos)\n"
"'hello, world\\n'\n"
">>> # The argument to repr() may be any Python object:\n"
">>> repr((x, y, ('spam', 'eggs')))\n"
"\"(32.5, 40000, ('spam', 'eggs'))\""
msgstr ""
">>> s = \"Hej, världen\n"
">>> str(s)\n"
"\"Hej, världen\n"
">>> repr(s)\n"
"\"'Hej, världen.'\"\n"
">>> str(1/7)\n"
"'0.14285714285714285'\n"
">>> x = 10 * 3.25\n"
">>> y = 200 * 200\n"
">>> s = 'Värdet på x är ' + repr(x) + ', och y är ' + repr(y) + '...'\n"
">>> print(s)\n"
"Värdet på x är 32,5 och y är 40000...\n"
">>> # repr() av en sträng lägger till strängcitat och backslash:\n"
">>> hallå = 'hallå, världen\\n'\n"
">>> hellos = repr(hello)\n"
">>> print(hellos)\n"
"'hej, världen\\n'\n"
">>> # Argumentet till repr() kan vara vilket Python-objekt som helst:\n"
">>> repr((x, y, ('spam', 'ägg')))\n"
"\"(32,5, 40000, ('spam', 'ägg'))\""

msgid ""
"The :mod:`string` module also contains support for so-called :ref:`$-strings "
"<template-strings-pep292>` that offer yet another way to substitute values "
"into strings, using placeholders like ``$x`` and replacing them with values "
"from a dictionary. This syntax is easy to use, although it offers much less "
"control of the formatting."
msgstr ""
"Modulen :mod:`string` innehåller också stöd för så kallade :ref:`$-strings "
"<template-strings-pep292>` som erbjuder ännu ett sätt att ersätta värden i "
"strängar, genom att använda platshållare som ``$x`` och ersätta dem med "
"värden från en ordbok. Den här syntaxen är enkel att använda, även om den "
"ger mycket mindre kontroll över formateringen."

msgid "Formatted String Literals"
msgstr "Formaterade strängbokstäver"

msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by "
"prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
":ref:`Formaterade stränglitteraler <f-strings>` (även kallade f-strängar i "
"korthet) låter dig inkludera värdet av Python-uttryck inuti en sträng genom "
"att prefixera strängen med ``f`` eller ``F`` och skriva uttryck som "
"``{expression}``."

msgid ""
"An optional format specifier can follow the expression. This allows greater "
"control over how the value is formatted. The following example rounds pi to "
"three places after the decimal::"
msgstr ""
"En valfri formatspecifikator kan följa efter uttrycket. Detta ger större "
"kontroll över hur värdet formateras. I följande exempel avrundas pi till tre "
"ställen efter decimalen::"

msgid ""
">>> import math\n"
">>> print(f'The value of pi is approximately {math.pi:.3f}.')\n"
"The value of pi is approximately 3.142."
msgstr ""
">>> import math\n"
">>> print(f'The value of pi is approximately {math.pi:.3f}.')\n"
"The value of pi is approximately 3.142."

msgid ""
"Passing an integer after the ``':'`` will cause that field to be a minimum "
"number of characters wide.  This is useful for making columns line up. ::"
msgstr ""
"Om du skickar ett heltal efter ``':'`` blir fältet minst ett antal tecken "
"brett.  Detta är användbart för att få kolumner att rada upp sig. ::"

msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n"
">>> for name, phone in table.items():\n"
"...     print(f'{name:10} ==> {phone:10d}')\n"
"...\n"
"Sjoerd     ==>       4127\n"
"Jack       ==>       4098\n"
"Dcab       ==>       7678"
msgstr ""
">>> tabell = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n"
">>> for name, phone in table.items():\n"
"... print(f'{name:10} ==> {phone:10d}')\n"
"...\n"
"Sjoerd ==> 4127\n"
"Jack ==> 4098\n"
"Dcab ==> 7678"

msgid ""
"Other modifiers can be used to convert the value before it is formatted. ``'!"
"a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and ``'!r'`` "
"applies :func:`repr`::"
msgstr ""
"Andra modifierare kan användas för att konvertera värdet innan det "
"formateras. ``'!a'`` tillämpar :func:`ascii`, ``'!s'`` tillämpar :func:"
"`str`, och ``'!r'`` tillämpar :func:`repr`::"

msgid ""
">>> animals = 'eels'\n"
">>> print(f'My hovercraft is full of {animals}.')\n"
"My hovercraft is full of eels.\n"
">>> print(f'My hovercraft is full of {animals!r}.')\n"
"My hovercraft is full of 'eels'."
msgstr ""
">>> djur = 'ålar'\n"
">>> print(f'Min svävare är full av {animals}.')\n"
"Min svävare är full av ålar.\n"
">>> print(f'Min svävare är full av {animals!r}.')\n"
"Min svävare är full av 'ålar'."

msgid ""
"The ``=`` specifier can be used to expand an expression to the text of the "
"expression, an equal sign, then the representation of the evaluated "
"expression:"
msgstr ""
"Specificeraren ``=`` kan användas för att expandera ett uttryck till texten "
"i uttrycket, ett likhetstecken och sedan representationen av det utvärderade "
"uttrycket:"

msgid ""
"See :ref:`self-documenting expressions <bpo-36817-whatsnew>` for more "
"information on the ``=`` specifier. For a reference on these format "
"specifications, see the reference guide for the :ref:`formatspec`."
msgstr ""
"Se :ref:``self-documenting expressions <bpo-36817-whatsnew>` för mer "
"information om ``=`` specifikatorn. För en referens om dessa "
"formatspecifikationer, se referensguiden för :ref:`formatspec`."

msgid "The String format() Method"
msgstr "Metoden String format()"

msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr "Grundläggande användning av metoden :meth:`str.format` ser ut så här::"

msgid ""
">>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\n"
"We are the knights who say \"Ni!\""
msgstr ""
">>> print('Vi är de {} som säger \"{}!\"'.format('riddare', 'Ni'))\n"
"Vi är riddarna som säger \"Ni!\""

msgid ""
"The brackets and characters within them (called format fields) are replaced "
"with the objects passed into the :meth:`str.format` method.  A number in the "
"brackets can be used to refer to the position of the object passed into the :"
"meth:`str.format` method. ::"
msgstr ""
"Parenteserna och tecknen inom dem (som kallas formatfält) ersätts med de "
"objekt som skickas till metoden :meth:`str.format`.  Ett tal inom parentes "
"kan användas för att referera till positionen för det objekt som skickas "
"till metoden :meth:`str.format`. ::"

msgid ""
">>> print('{0} and {1}'.format('spam', 'eggs'))\n"
"spam and eggs\n"
">>> print('{1} and {0}'.format('spam', 'eggs'))\n"
"eggs and spam"
msgstr ""
">>> print('{0} och {1}'.format('spam', 'ägg'))\n"
"skräppost och ägg\n"
">>> print('{1} och {0}'.format('spam', 'ägg'))\n"
"ägg och skräppost"

msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their values "
"are referred to by using the name of the argument. ::"
msgstr ""
"Om nyckelordsargument används i metoden :meth:`str.format` refereras till "
"deras värden genom att använda argumentets namn. ::"

msgid ""
">>> print('This {food} is {adjective}.'.format(\n"
"...       food='spam', adjective='absolutely horrible'))\n"
"This spam is absolutely horrible."
msgstr ""
">>> print('Den här {food} är {adjective}.'.format(\n"
"... mat='skräppost', adjektiv='helt fruktansvärt'))\n"
"Detta skräppost är helt fruktansvärt."

msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "Positions- och nyckelordsargument kan kombineras godtyckligt::"

msgid ""
">>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n"
"...                                                    other='Georg'))\n"
"The story of Bill, Manfred, and Georg."
msgstr ""
">>> print('Berättelsen om {0}, {1} och {other}.'.format('Bill', 'Manfred',\n"
"... annan='Georg'))\n"
"Berättelsen om Bill, Manfred och Georg."

msgid ""
"If you have a really long format string that you don't want to split up, it "
"would be nice if you could reference the variables to be formatted by name "
"instead of by position.  This can be done by simply passing the dict and "
"using square brackets ``'[]'`` to access the keys. ::"
msgstr ""
"Om du har en riktigt lång formatsträng som du inte vill dela upp, skulle det "
"vara bra om du kunde referera till variablerna som ska formateras med namn "
"istället för med position.  Detta kan göras genom att helt enkelt skicka "
"dict och använda hakparenteser ``'[]'`` för att komma åt nycklarna. ::"

msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n"
"...       'Dcab: {0[Dcab]:d}'.format(table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""
">>> tabell = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n"
"...       'Dcab: {0[Dcab]:d}'.format(tabell))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"

msgid ""
"This could also be done by passing the ``table`` dictionary as keyword "
"arguments with the ``**`` notation. ::"
msgstr ""
"Detta kan också göras genom att skicka ``table``-ordlistan som "
"nyckelordsargument med ``**``-notationen. ::"

msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'."
"format(**table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""
">>> tabell = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'."
"format(**table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"

msgid ""
"This is particularly useful in combination with the built-in function :func:"
"`vars`, which returns a dictionary containing all local variables::"
msgstr ""
"Detta är särskilt användbart i kombination med den inbyggda funktionen :func:"
"`vars`, som returnerar en ordbok som innehåller alla lokala variabler::"

msgid ""
">>> table = {k: str(v) for k, v in vars().items()}\n"
">>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n"
">>> print(message.format(**table))\n"
"__name__: __main__; __doc__: None; __package__: None; __loader__: ..."
msgstr ""
">>> table = {k: str(v) for k, v in vars().items()} >>> message = \"\"."
"join([f'{k}: ' + '{' + k + '};' for k in table.keys()])\n"
">>> meddelande = \"\".join([f'{k}: ' + '{' + k +'};' for k in table."
"keys()])\n"
">>> print(meddelande.format(**tabell))\n"
"__namn__: __main__; __doc__: None; __package__: None; __loader__: ..."

msgid ""
"As an example, the following lines produce a tidily aligned set of columns "
"giving integers and their squares and cubes::"
msgstr ""
"Som exempel kan nämnas att följande rader ger en välordnad uppsättning "
"kolumner med heltal och deras kvadrater och kuber::"

msgid ""
">>> for x in range(1, 11):\n"
"...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"
msgstr ""
">>> för x i intervall(1, 11):\n"
"... print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n"
"...\n"
" 1 1 1\n"
" 2 4 8\n"
" 3 9 27\n"
" 4 16 64\n"
" 5 25 125\n"
" 6 36 216\n"
" 7 49 343\n"
" 8 64 512\n"
" 9 81 729\n"
"10 100 1000"

msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see :"
"ref:`formatstrings`."
msgstr ""
"För en fullständig översikt över strängformatering med :meth:`str.format`, "
"se :ref:`formatstrings`."

msgid "Manual String Formatting"
msgstr "Manuell strängformatering"

msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr "Här är samma tabell med kvadrater och kuber, formaterad manuellt::"

msgid ""
">>> for x in range(1, 11):\n"
"...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n"
"...     # Note use of 'end' on previous line\n"
"...     print(repr(x*x*x).rjust(4))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"
msgstr ""
">>> för x i intervall(1, 11):\n"
"... print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n"
"...     # Notera användningen av 'end' på föregående rad\n"
"... print(repr(x*x*x).rjust(4))\n"
"...\n"
" 1 1 1\n"
" 2 4 8\n"
" 3 9 27\n"
" 4 16 64\n"
" 5 25 125\n"
" 6 36 216\n"
" 7 49 343\n"
" 8 64 512\n"
" 9 81 729\n"
"10 100 1000"

msgid ""
"(Note that the one space between each column was added by the way :func:"
"`print` works: it always adds spaces between its arguments.)"
msgstr ""
"(Observera att ett mellanslag mellan varje kolumn lades till på grund av "
"hur :func:`print` fungerar: den lägger alltid till mellanslag mellan sina "
"argument)"

msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string in a "
"field of a given width by padding it with spaces on the left. There are "
"similar methods :meth:`str.ljust` and :meth:`str.center`. These methods do "
"not write anything, they just return a new string. If the input string is "
"too long, they don't truncate it, but return it unchanged; this will mess up "
"your column lay-out but that's usually better than the alternative, which "
"would be lying about a value. (If you really want truncation you can always "
"add a slice operation, as in ``x.ljust(n)[:n]``.)"
msgstr ""
"Metoden :meth:`str.rjust` för strängobjekt högerjusterar en sträng i ett "
"fält med en given bredd genom att fylla ut den med mellanslag till vänster. "
"Det finns liknande metoder :meth:`str.ljust` och :meth:`str.center`. Dessa "
"metoder skriver inte något, de returnerar bara en ny sträng. Om "
"indatasträngen är för lång trunkerar de den inte utan returnerar den "
"oförändrad; detta kommer att röra till din kolumnlayout men det är "
"vanligtvis bättre än alternativet, vilket skulle vara att ljuga om ett "
"värde. (Om du verkligen vill ha trunkering kan du alltid lägga till en slice-"
"operation, som i ``x.ljust(n)[:n]``)"

msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string on "
"the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"Det finns en annan metod, :meth:`str.zfill`, som fyller ut en numerisk "
"sträng till vänster med nollor.  Den förstår sig på plus- och minustecken::"

msgid ""
">>> '12'.zfill(5)\n"
"'00012'\n"
">>> '-3.14'.zfill(7)\n"
"'-003.14'\n"
">>> '3.14159265359'.zfill(5)\n"
"'3.14159265359'"
msgstr ""
">>> '12'.zfill(5)\n"
"'00012'\n"
">>> '-3,14'.zfill(7)\n"
"'-003.14'\n"
">>> '3.14159265359'.zfill(5)\n"
"'3.14159265359'"

msgid "Old string formatting"
msgstr "Gammal strängformatering"

msgid ""
"The % operator (modulo) can also be used for string formatting. Given "
"``format % values`` (where *format* is a string), ``%`` conversion "
"specifications in *format* are replaced with zero or more elements of "
"*values*. This operation is commonly known as string interpolation. For "
"example::"
msgstr ""
"% operatorn (modulo) kan också användas för strängformatering. Givet "
"``format % värden`` (där *format* är en sträng), ersätts ``%`` "
"konverteringsspecifikationer i *format* med noll eller flera element i "
"*värden*. Denna operation är allmänt känd som stränginterpolation. Till "
"exempel::"

msgid ""
">>> import math\n"
">>> print('The value of pi is approximately %5.3f.' % math.pi)\n"
"The value of pi is approximately 3.142."
msgstr ""
">>> import math\n"
">>> print('The value of pi is approximately %5.3f.' % math.pi)\n"
"The value of pi is approximately 3.142."

msgid ""
"More information can be found in the :ref:`old-string-formatting` section."
msgstr "Mer information finns i avsnittet :ref:`old-string-formatting`."

msgid "Reading and Writing Files"
msgstr "Läsa och skriva filer"

msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used with "
"two positional arguments and one keyword argument: ``open(filename, mode, "
"encoding=None)``"
msgstr ""
":func:`open` returnerar ett :term:`file-objekt`, och används oftast med två "
"positionella argument och ett nyckelordsargument: ``open(filnamn, mode, "
"encoding=None)``"

msgid ">>> f = open('workfile', 'w', encoding=\"utf-8\")"
msgstr ">>> f = open('workfile', 'w', encoding=\"utf-8\")"

msgid ""
"The first argument is a string containing the filename.  The second argument "
"is another string containing a few characters describing the way in which "
"the file will be used.  *mode* can be ``'r'`` when the file will only be "
"read, ``'w'`` for only writing (an existing file with the same name will be "
"erased), and ``'a'`` opens the file for appending; any data written to the "
"file is automatically added to the end.  ``'r+'`` opens the file for both "
"reading and writing. The *mode* argument is optional; ``'r'`` will be "
"assumed if it's omitted."
msgstr ""
"Det första argumentet är en sträng som innehåller filnamnet.  Det andra "
"argumentet är en annan sträng som innehåller några tecken som beskriver hur "
"filen ska användas.  *mode* kan vara ``'r'`` om filen bara ska läsas, "
"``'w'`` om den bara ska skrivas (en befintlig fil med samma namn raderas), "
"och ``'a'`` öppnar filen för tillägg; all data som skrivs till filen läggs "
"automatiskt till i slutet.  ``'r+'`` öppnar filen för både läsning och "
"skrivning. Argumentet *mode* är valfritt; ``'r'`` kommer att antas om det "
"utelämnas."

msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"*encoding*. If *encoding* is not specified, the default is platform "
"dependent (see :func:`open`). Because UTF-8 is the modern de-facto standard, "
"``encoding=\"utf-8\"`` is recommended unless you know that you need to use a "
"different encoding. Appending a ``'b'`` to the mode opens the file in :dfn:"
"`binary mode`. Binary mode data is read and written as :class:`bytes` "
"objects. You can not specify *encoding* when opening file in binary mode."
msgstr ""
"Normalt öppnas filer i :dfn:`text mode`, vilket innebär att du läser och "
"skriver strängar från och till filen, som är kodade i en specifik "
"*encoding*. Om *encoding* inte anges är standardinställningen "
"plattformsberoende (se :func:`open`). Eftersom UTF-8 är den moderna de-facto-"
"standarden rekommenderas ``encoding=\"utf-8\"`` om du inte vet att du "
"behöver använda en annan kodning. Genom att lägga till ``'b'`` till mode "
"öppnas filen i :dfn:`binary mode`. Data i binärt läge läses och skrivs som :"
"class:`bytes`-objekt. Du kan inte ange *kodning* när du öppnar en fil i "
"binärt läge."

msgid ""
"In text mode, the default when reading is to convert platform-specific line "
"endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  When "
"writing in text mode, the default is to convert occurrences of ``\\n`` back "
"to platform-specific line endings.  This behind-the-scenes modification to "
"file data is fine for text files, but will corrupt binary data like that in :"
"file:`JPEG` or :file:`EXE` files.  Be very careful to use binary mode when "
"reading and writing such files."
msgstr ""
"I textläge är standardinställningen vid läsning att konvertera "
"plattformsspecifika radavslutningar (``\\n`` på Unix, ``\\r\\n`` på Windows) "
"till bara ``\\n``.  När du skriver i textläge är standardinställningen att "
"konvertera förekomster av ``\\n`` tillbaka till plattformsspecifika "
"radavslut.  Denna bakomliggande modifiering av fildata är bra för textfiler, "
"men kommer att korrumpera binära data som i :file:`JPEG`- eller :file:`EXE`-"
"filer.  Var mycket försiktig med att använda binärt läge när du läser och "
"skriver sådana filer."

msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after its "
"suite finishes, even if an exception is raised at some point.  Using :"
"keyword:`!with` is also much shorter than writing equivalent :keyword:"
"`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"Det är god praxis att använda nyckelordet :keyword:`with` när man hanterar "
"filobjekt.  Fördelen är att filen stängs på rätt sätt när dess svit är klar, "
"även om ett undantag uppstår vid något tillfälle.  Att använda :keyword:`!"
"with` är också mycket kortare än att skriva motsvarande :keyword:`try`- :"
"keyword:`finally`-block::"

msgid ""
">>> with open('workfile', encoding=\"utf-8\") as f:\n"
"...     read_data = f.read()\n"
"\n"
">>> # We can check that the file has been automatically closed.\n"
">>> f.closed\n"
"True"
msgstr ""
">>> med open('workfile', encoding=\"utf-8\") som f:\n"
"... read_data = f.read()\n"
"\n"
">>> # Vi kan kontrollera att filen har stängts automatiskt.\n"
">>> f.closed\n"
"Sant"

msgid ""
"If you're not using the :keyword:`with` keyword, then you should call ``f."
"close()`` to close the file and immediately free up any system resources "
"used by it."
msgstr ""
"Om du inte använder nyckelordet :keyword:`with` bör du anropa ``f.close()`` "
"för att stänga filen och omedelbart frigöra alla systemresurser som används "
"av den."

msgid ""
"Calling ``f.write()`` without using the :keyword:`!with` keyword or calling "
"``f.close()`` **might** result in the arguments of ``f.write()`` not being "
"completely written to the disk, even if the program exits successfully."
msgstr ""
"Anrop av ``f.write()`` utan att använda nyckelordet :keyword:`!with` eller "
"anrop av ``f.close()`` **kan** resultera i att argumenten i ``f.write()`` "
"inte skrivs ut fullständigt till disken, även om programmet avslutas "
"framgångsrikt."

msgid ""
"After a file object is closed, either by a :keyword:`with` statement or by "
"calling ``f.close()``, attempts to use the file object will automatically "
"fail. ::"
msgstr ""
"När ett filobjekt har stängts, antingen genom en :keyword:`with`-sats eller "
"genom att anropa ``f.close()``, kommer försök att använda filobjektet "
"automatiskt att misslyckas. ::"

msgid ""
">>> f.close()\n"
">>> f.read()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: I/O operation on closed file."
msgstr ""
"&gt;&gt;&gt; f.stäng()\n"
"&gt;&gt;&gt; f.read()\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"ValueError (värdefel): I/O-operation på stängd fil."

msgid "Methods of File Objects"
msgstr "Metoder för filobjekt"

msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr ""
"I resten av exemplen i det här avsnittet förutsätts att ett filobjekt med "
"namnet ``f`` redan har skapats."

msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some quantity "
"of data and returns it as a string (in text mode) or bytes object (in binary "
"mode). *size* is an optional numeric argument.  When *size* is omitted or "
"negative, the entire contents of the file will be read and returned; it's "
"your problem if the file is twice as large as your machine's memory. "
"Otherwise, at most *size* characters (in text mode) or *size* bytes (in "
"binary mode) are read and returned. If the end of the file has been reached, "
"``f.read()`` will return an empty string (``''``).  ::"
msgstr ""
"För att läsa en fils innehåll, anropa ``f.read(size)``, som läser en viss "
"mängd data och returnerar den som en sträng (i textläge) eller ett "
"bytesobjekt (i binärt läge). *size* är ett valfritt numeriskt argument.  När "
"*size* utelämnas eller är negativt kommer hela filens innehåll att läsas och "
"returneras; det är ditt problem om filen är dubbelt så stor som din maskins "
"minne. Annars läses och returneras högst *size* tecken (i textläge) eller "
"*size* byte (i binärt läge). Om slutet av filen har nåtts kommer ``f."
"read()`` att returnera en tom sträng (``''``).  ::"

msgid ""
">>> f.read()\n"
"'This is the entire file.\\n'\n"
">>> f.read()\n"
"''"
msgstr ""
">>> f.read()\n"
"'Detta är hela filen.\\n'\n"
">>> f.read()\n"
"''"

msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the last "
"line of the file if the file doesn't end in a newline.  This makes the "
"return value unambiguous; if ``f.readline()`` returns an empty string, the "
"end of the file has been reached, while a blank line is represented by "
"``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` läser en enda rad från filen; ett tecken för ny rad "
"(``\\n``) lämnas i slutet av strängen och utelämnas endast på den sista "
"raden i filen om filen inte slutar med en ny rad.  Detta gör returvärdet "
"otvetydigt; om ``f.readline()`` returnerar en tom sträng har slutet på filen "
"nåtts, medan en tom rad representeras av ``'\\n'``, en sträng som bara "
"innehåller en enda ny rad. ::"

msgid ""
">>> f.readline()\n"
"'This is the first line of the file.\\n'\n"
">>> f.readline()\n"
"'Second line of the file\\n'\n"
">>> f.readline()\n"
"''"
msgstr ""
">>> f.readline()\n"
"'Detta är den första raden i filen.\\n'\n"
">>> f.readline()\n"
"'Andra raden i filen\\n'\n"
">>> f.readline()\n"
"''"

msgid ""
"For reading lines from a file, you can loop over the file object. This is "
"memory efficient, fast, and leads to simple code::"
msgstr ""
"För att läsa rader från en fil kan du loopa över filobjektet. Detta är "
"minnessnålt, snabbt och leder till enkel kod::"

msgid ""
">>> for line in f:\n"
"...     print(line, end='')\n"
"...\n"
"This is the first line of the file.\n"
"Second line of the file"
msgstr ""
">>> för rad i f:\n"
"... print(rad, end='')\n"
"...\n"
"Detta är den första raden i filen.\n"
"Andra raden i filen"

msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr ""
"Om du vill läsa alla rader i en fil i en lista kan du också använda "
"``list(f)`` eller ``f.readlines()``."

msgid ""
"``f.write(string)`` writes the contents of *string* to the file, returning "
"the number of characters written. ::"
msgstr ""
"```f.write(string)``` skriver innehållet i *string* till filen och "
"returnerar antalet tecken som skrivits. ::"

msgid ""
">>> f.write('This is a test\\n')\n"
"15"
msgstr ""
">>> f.write('Detta är ett test\\n')\n"
"15"

msgid ""
"Other types of objects need to be converted -- either to a string (in text "
"mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"Andra typer av objekt måste konverteras - antingen till en sträng (i "
"textläge) eller till ett bytesobjekt (i binärt läge) - innan de skrivs::"

msgid ""
">>> value = ('the answer', 42)\n"
">>> s = str(value)  # convert the tuple to string\n"
">>> f.write(s)\n"
"18"
msgstr ""
">>> värde = ('svaret', 42)\n"
">>> s = str(värde) # konvertera tupeln till sträng\n"
">>> f.write(s)\n"
"18"

msgid ""
"``f.tell()`` returns an integer giving the file object's current position in "
"the file represented as number of bytes from the beginning of the file when "
"in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` returnerar ett heltal som anger filobjektets aktuella position "
"i filen representerat som antal byte från början av filen i binärläge och "
"ett opakt tal i textläge."

msgid ""
"To change the file object's position, use ``f.seek(offset, whence)``.  The "
"position is computed from adding *offset* to a reference point; the "
"reference point is selected by the *whence* argument.  A *whence* value of 0 "
"measures from the beginning of the file, 1 uses the current file position, "
"and 2 uses the end of the file as the reference point.  *whence* can be "
"omitted and defaults to 0, using the beginning of the file as the reference "
"point. ::"
msgstr ""
"Om du vill ändra filobjektets position använder du ``f.seek(offset, "
"whence)``.  Positionen beräknas genom att lägga till *offset* till en "
"referenspunkt; referenspunkten väljs med argumentet *whence*.  Ett *whence*-"
"värde på 0 mäter från början av filen, 1 använder den aktuella filpositionen "
"och 2 använder slutet av filen som referenspunkt.  *whence* kan utelämnas "
"och har standardvärdet 0, vilket innebär att filens början används som "
"referenspunkt. ::"

msgid ""
">>> f = open('workfile', 'rb+')\n"
">>> f.write(b'0123456789abcdef')\n"
"16\n"
">>> f.seek(5)      # Go to the 6th byte in the file\n"
"5\n"
">>> f.read(1)\n"
"b'5'\n"
">>> f.seek(-3, 2)  # Go to the 3rd byte before the end\n"
"13\n"
">>> f.read(1)\n"
"b'd'"
msgstr ""
">>> f = open('workfile', 'rb+')\n"
">>> f.write(b'0123456789abcdef')\n"
"16\n"
">>> f.seek(5) # Gå till den 6:e byten i filen\n"
"5\n"
">>> f.read(1)\n"
"b'5'\n"
">>> f.seek(-3, 2) # Gå till den 3:e byten före slutet\n"
"13\n"
">>> f.read(1)\n"
"b'd'"

msgid ""
"In text files (those opened without a ``b`` in the mode string), only seeks "
"relative to the beginning of the file are allowed (the exception being "
"seeking to the very file end with ``seek(0, 2)``) and the only valid "
"*offset* values are those returned from the ``f.tell()``, or zero. Any other "
"*offset* value produces undefined behaviour."
msgstr ""
"I textfiler (som öppnas utan ``b`` i lägessträngen) tillåts endast sökningar "
"relativt början av filen (undantaget är sökning till slutet av filen med "
"``seek(0, 2)``) och de enda giltiga *offset*-värdena är de som returneras "
"från ``f.tell()``, eller noll. Alla andra *offset*-värden ger ett "
"odefinierat beteende."

msgid ""
"File objects have some additional methods, such as :meth:`~io.IOBase.isatty` "
"and :meth:`~io.IOBase.truncate` which are less frequently used; consult the "
"Library Reference for a complete guide to file objects."
msgstr ""
"Filobjekt har några ytterligare metoder, t.ex. :meth:`~io.IOBase.isatty` "
"och :meth:`~io.IOBase.truncate` som används mindre ofta; se Library "
"Reference för en fullständig guide till filobjekt."

msgid "Saving structured data with :mod:`json`"
msgstr "Spara strukturerad data med :mod:`json`"

msgid ""
"Strings can easily be written to and read from a file.  Numbers take a bit "
"more effort, since the :meth:`~io.TextIOBase.read` method only returns "
"strings, which will have to be passed to a function like :func:`int`, which "
"takes a string like ``'123'`` and returns its numeric value 123.  When you "
"want to save more complex data types like nested lists and dictionaries, "
"parsing and serializing by hand becomes complicated."
msgstr ""
"Strängar kan enkelt skrivas till och läsas från en fil.  Siffror kräver lite "
"mer ansträngning, eftersom metoden :meth:`~io.TextIOBase.read` bara "
"returnerar strängar, som måste skickas till en funktion som :func:`int`, som "
"tar en sträng som ``'123'`` och returnerar dess numeriska värde 123.  När du "
"vill spara mer komplexa datatyper som nästlade listor och lexikon blir det "
"komplicerat att parsa och serialisera för hand."

msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular data "
"interchange format called `JSON (JavaScript Object Notation) <https://json."
"org>`_.  The standard module called :mod:`json` can take Python data "
"hierarchies, and convert them to string representations; this process is "
"called :dfn:`serializing`.  Reconstructing the data from the string "
"representation is called :dfn:`deserializing`.  Between serializing and "
"deserializing, the string representing the object may have been stored in a "
"file or data, or sent over a network connection to some distant machine."
msgstr ""
"I stället för att användarna ständigt måste skriva och felsöka kod för att "
"spara komplicerade datatyper i filer, kan du med Python använda det populära "
"datautbytesformatet `JSON (JavaScript Object Notation) <https://json."
"org>`_.  Standardmodulen som kallas :mod:`json` kan ta Python-datahierarkier "
"och konvertera dem till strängrepresentationer; denna process kallas :dfn:"
"`serializing`.  Att rekonstruera data från strängrepresentationen kallas :"
"dfn:`deserializing`.  Mellan serialisering och deserialisering kan strängen "
"som representerar objektet ha lagrats i en fil eller data, eller skickats "
"över en nätverksanslutning till någon avlägsen maskin."

msgid ""
"The JSON format is commonly used by modern applications to allow for data "
"exchange.  Many programmers are already familiar with it, which makes it a "
"good choice for interoperability."
msgstr ""
"JSON-formatet används ofta av moderna applikationer för att möjliggöra "
"datautbyte.  Många programmerare är redan bekanta med det, vilket gör det "
"till ett bra val för interoperabilitet."

msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr ""
"Om du har ett objekt ``x`` kan du visa dess JSON-strängrepresentation med en "
"enkel kodrad::"

msgid ""
">>> import json\n"
">>> x = [1, 'simple', 'list']\n"
">>> json.dumps(x)\n"
"'[1, \"simple\", \"list\"]'"
msgstr ""
">>> import json\n"
">>> x = [1, 'enkel', 'lista']\n"
">>> json.dumps(x)\n"
"'[1, \"enkel\", \"lista\"]''"

msgid ""
"Another variant of the :func:`~json.dumps` function, called :func:`~json."
"dump`, simply serializes the object to a :term:`text file`.  So if ``f`` is "
"a :term:`text file` object opened for writing, we can do this::"
msgstr ""
"En annan variant av funktionen :func:`~json.dumps`, som kallas :func:`~json."
"dump`, serialiserar helt enkelt objektet till en :term:`textfil`.  Så om "
"``f`` är ett :term:`text file`-objekt som är öppet för skrivning kan vi göra "
"så här::"

msgid "json.dump(x, f)"
msgstr "json.dump(x, f)"

msgid ""
"To decode the object again, if ``f`` is a :term:`binary file` or :term:`text "
"file` object which has been opened for reading::"
msgstr ""
"För att avkoda objektet igen, om ``f`` är ett :term:`binärfil`- eller :term:"
"`textfil`-objekt som har öppnats för läsning::"

msgid "x = json.load(f)"
msgstr "x = json.load(f)"

msgid ""
"JSON files must be encoded in UTF-8. Use ``encoding=\"utf-8\"`` when opening "
"JSON file as a :term:`text file` for both of reading and writing."
msgstr ""
"JSON-filer måste vara kodade i UTF-8. Använd ``encoding=\"utf-8\"`` när du "
"öppnar JSON-filen som en :term:`textfil` för både läsning och skrivning."

msgid ""
"This simple serialization technique can handle lists and dictionaries, but "
"serializing arbitrary class instances in JSON requires a bit of extra "
"effort. The reference for the :mod:`json` module contains an explanation of "
"this."
msgstr ""
"Denna enkla serialiseringsteknik kan hantera listor och ordböcker, men "
"serialisering av godtyckliga klassinstanser i JSON kräver lite extra "
"ansträngning. Referensen för modulen :mod:`json` innehåller en förklaring av "
"detta."

msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - pickle-modulen"

msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows the "
"serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: deserializing "
"pickle data coming from an untrusted source can execute arbitrary code, if "
"the data was crafted by a skilled attacker."
msgstr ""
"I motsats till :ref:`JSON <tut-json>` är *pickle* ett protokoll som tillåter "
"serialisering av godtyckligt komplexa Python-objekt.  Som sådant är det "
"specifikt för Python och kan inte användas för att kommunicera med "
"applikationer skrivna på andra språk.  Det är också osäkert som standard: "
"deserialisering av pickle-data som kommer från en icke betrodd källa kan "
"exekvera godtycklig kod om data har skapats av en skicklig angripare."

msgid "formatted string literal"
msgstr "formaterad sträng bokstavlig"

msgid "interpolated string literal"
msgstr "interpolerad sträng bokstavlig"

msgid "string"
msgstr "sträng"

msgid "formatted literal"
msgstr "formaterad bokstav"

msgid "interpolated literal"
msgstr "interpolerad bokstavlig"

msgid "f-string"
msgstr "f-sträng"

msgid "fstring"
msgstr "fsträng"

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "open"
msgstr "öppen"

msgid "object"
msgstr "objekt"

msgid "file"
msgstr "fil"

msgid "module"
msgstr "modul"

msgid "json"
msgstr "json"
