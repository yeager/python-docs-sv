# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "The Python Profilers"
msgstr "Python-profiler"

msgid "**Source code:** :source:`Lib/profile.py` and :source:`Lib/pstats.py`"
msgstr "**Källkod:** :source:`Lib/profile.py` och :source:`Lib/pstats.py`"

msgid "Introduction to the profilers"
msgstr "Introduktion till profileringsverktygen"

msgid ""
":mod:`cProfile` and :mod:`profile` provide :dfn:`deterministic profiling` of "
"Python programs. A :dfn:`profile` is a set of statistics that describes how "
"often and for how long various parts of the program executed. These "
"statistics can be formatted into reports via the :mod:`pstats` module."
msgstr ""
":mod:`cProfile` och :mod:`profile` ger :dfn:`deterministisk profilering` av "
"Python-program. En :dfn:`profile` är en uppsättning statistik som beskriver "
"hur ofta och hur länge olika delar av programmet kördes. Denna statistik kan "
"formateras till rapporter via modulen :mod:`pstats`."

msgid ""
"The Python standard library provides two different implementations of the "
"same profiling interface:"
msgstr ""
"Pythons standardbibliotek tillhandahåller två olika implementeringar av "
"samma profileringsgränssnitt:"

msgid ""
":mod:`cProfile` is recommended for most users; it's a C extension with "
"reasonable overhead that makes it suitable for profiling long-running "
"programs.  Based on :mod:`lsprof`, contributed by Brett Rosen and Ted "
"Czotter."
msgstr ""
":mod:`cProfile` rekommenderas för de flesta användare; det är ett C-tillägg "
"med rimlig overhead som gör det lämpligt för profilering av långkörande "
"program.  Baserat på :mod:`lsprof`, med bidrag från Brett Rosen och Ted "
"Czotter."

msgid ""
":mod:`profile`, a pure Python module whose interface is imitated by :mod:"
"`cProfile`, but which adds significant overhead to profiled programs. If "
"you're trying to extend the profiler in some way, the task might be easier "
"with this module.  Originally designed and written by Jim Roskind."
msgstr ""
":mod:`profile`, en ren Python-modul vars gränssnitt imiteras av :mod:"
"`cProfile`, men som lägger till betydande overhead till profilerade program. "
"Om du försöker utöka profileraren på något sätt kan uppgiften vara enklare "
"med den här modulen.  Ursprungligen designad och skriven av Jim Roskind."

msgid ""
"The profiler modules are designed to provide an execution profile for a "
"given program, not for benchmarking purposes (for that, there is :mod:"
"`timeit` for reasonably accurate results).  This particularly applies to "
"benchmarking Python code against C code: the profilers introduce overhead "
"for Python code, but not for C-level functions, and so the C code would seem "
"faster than any Python one."
msgstr ""
"Profilermodulerna är utformade för att ge en exekveringsprofil för ett visst "
"program, inte för benchmarking (för det finns :mod:`timeit` för rimligt "
"exakta resultat).  Detta gäller särskilt för benchmarking av Python-kod mot "
"C-kod: profilerarna introducerar overhead för Python-kod, men inte för "
"funktioner på C-nivå, och därför skulle C-koden verka snabbare än någon "
"Python-kod."

msgid "Instant User's Manual"
msgstr "Användarmanual för Instant"

msgid ""
"This section is provided for users that \"don't want to read the manual.\" "
"It provides a very brief overview, and allows a user to rapidly perform "
"profiling on an existing application."
msgstr ""
"Det här avsnittet är avsett för användare som \"inte vill läsa manualen\" "
"Det ger en mycket kort översikt och gör det möjligt för en användare att "
"snabbt utföra profilering på en befintlig applikation."

msgid "To profile a function that takes a single argument, you can do::"
msgstr ""
"För att profilera en funktion som tar ett enda argument kan du göra så här::"

msgid ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")')"
msgstr ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")')"

msgid ""
"(Use :mod:`profile` instead of :mod:`cProfile` if the latter is not "
"available on your system.)"
msgstr ""
"(Använd :mod:`profile` i stället för :mod:`cProfile` om den senare inte "
"finns tillgänglig i ditt system)"

msgid ""
"The above action would run :func:`re.compile` and print profile results like "
"the following::"
msgstr ""
"Ovanstående åtgärd skulle köra :func:`re.compile` och skriva ut "
"profilresultat som följande::"

msgid ""
"      214 function calls (207 primitive calls) in 0.002 seconds\n"
"\n"
"Ordered by: cumulative time\n"
"\n"
"ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n"
"     1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}\n"
"     1    0.000    0.000    0.001    0.001 <string>:1(<module>)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:250(compile)\n"
"     1    0.000    0.000    0.001    0.001 __init__.py:289(_compile)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:759(compile)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:937(parse)\n"
"     1    0.000    0.000    0.000    0.000 _compiler.py:598(_code)\n"
"     1    0.000    0.000    0.000    0.000 _parser.py:435(_parse_sub)"
msgstr ""
"      214 funktionsanrop (207 primitiva anrop) på 0,002 sekunder\n"
"\n"
"Ordnad efter: kumulativ tid\n"
"\n"
"ncalls tottime percall cumtime percall filnamn:lineno(funktion)\n"
"     1 0,000 0,000 0,002 0,002 {inbyggd metod builtins.exec}\n"
"     1 0,000 0,000 0,001 0,001 <string>:1(<module>)\n"
"     1 0,000 0,000 0,001 0,001 __init__.py:250(kompilera)\n"
"     1 0,000 0,000 0,001 0,001 __init__.py:289(_kompilering)\n"
"     1 0,000 0,000 0,000 0,000 _compiler.py:759(kompilera)\n"
"     1 0,000 0,000 0,000 0,000 _parser.py:937(parse)\n"
"     1 0,000 0,000 0,000 0,000 _compiler.py:598(_code)\n"
"     1 0,000 0,000 0,000 0,000 0,000 _parser.py:435(_parse_sub)"

msgid ""
"The first line indicates that 214 calls were monitored.  Of those calls, 207 "
"were :dfn:`primitive`, meaning that the call was not induced via recursion. "
"The next line: ``Ordered by: cumulative time`` indicates the output is "
"sorted by the ``cumtime`` values. The column headings include:"
msgstr ""
"Den första raden visar att 214 anrop övervakades.  Av dessa anrop var 207 :"
"dfn:`primitive`, vilket betyder att anropet inte inducerades via rekursion. "
"Nästa rad: ``Ordered by: cumulative time`` anger att utdata är sorterade "
"efter ``cumtime``-värdena. Kolumnrubrikerna inkluderar:"

msgid "ncalls"
msgstr "ncalls"

msgid "for the number of calls."
msgstr "för antalet samtal."

msgid "tottime"
msgstr "tottid"

msgid ""
"for the total time spent in the given function (and excluding time made in "
"calls to sub-functions)"
msgstr ""
"för den totala tid som tillbringats i den givna funktionen (och exklusive "
"tid för anrop till underfunktioner)"

msgid "percall"
msgstr "per telefon"

msgid "is the quotient of ``tottime`` divided by ``ncalls``"
msgstr "är kvoten av ``tottime`` dividerat med ``ncalls``"

msgid "cumtime"
msgstr "cumtime"

msgid ""
"is the cumulative time spent in this and all subfunctions (from invocation "
"till exit). This figure is accurate *even* for recursive functions."
msgstr ""
"är den ackumulerade tid som använts i denna och alla underfunktioner (från "
"anrop till avslut). Denna siffra är korrekt *även* för rekursiva funktioner."

msgid "is the quotient of ``cumtime`` divided by primitive calls"
msgstr "är kvoten av ``cumtime`` dividerat med primitiva anrop"

msgid "filename:lineno(function)"
msgstr "filnamn:lineno(funktion)"

msgid "provides the respective data of each function"
msgstr "tillhandahåller respektive data för varje funktion"

msgid ""
"When there are two numbers in the first column (for example ``3/1``), it "
"means that the function recursed.  The second value is the number of "
"primitive calls and the former is the total number of calls.  Note that when "
"the function does not recurse, these two values are the same, and only the "
"single figure is printed."
msgstr ""
"När det finns två siffror i den första kolumnen (t.ex. ``3/1``) betyder det "
"att funktionen recursade.  Det andra värdet är antalet primitiva anrop och "
"det första är det totala antalet anrop.  Observera att när funktionen inte "
"recurserar är dessa två värden desamma och endast den enda siffran skrivs ut."

msgid ""
"Instead of printing the output at the end of the profile run, you can save "
"the results to a file by specifying a filename to the :func:`run` function::"
msgstr ""
"I stället för att skriva ut resultatet i slutet av profilkörningen kan du "
"spara resultatet i en fil genom att ange ett filnamn i funktionen :func:"
"`run`::"

msgid ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")', 'restats')"
msgstr ""
"import cProfile\n"
"import re\n"
"cProfile.run('re.compile(\"foo|bar\")', 'restats')"

msgid ""
"The :class:`pstats.Stats` class reads profile results from a file and "
"formats them in various ways."
msgstr ""
"Klassen :class:`pstats.Stats` läser in profilresultat från en fil och "
"formaterar dem på olika sätt."

msgid ""
"The files :mod:`cProfile` and :mod:`profile` can also be invoked as a script "
"to profile another script.  For example::"
msgstr ""
"Filerna :mod:`cProfile` och :mod:`profile` kan också användas som ett skript "
"för att profilera ett annat skript.  Till exempel::"

msgid ""
"python -m cProfile [-o output_file] [-s sort_order] (-m module | myscript.py)"
msgstr ""
"python -m cProfile [-o output_file] [-s sort_order] (-m modul | myscript.py)"

msgid "Writes the profile results to a file instead of to stdout."
msgstr "Skriver profilresultaten till en fil i stället för till stdout."

msgid ""
"Specifies one of the :func:`~pstats.Stats.sort_stats` sort values to sort "
"the output by. This only applies when :option:`-o <cProfile -o>` is not "
"supplied."
msgstr ""
"Anger ett av sorteringsvärdena i :func:`~pstats.Stats.sort_stats` för att "
"sortera utdata efter. Detta gäller endast när :option:`-o <cProfile -o>` "
"inte anges."

msgid "Specifies that a module is being profiled instead of a script."
msgstr "Anger att det är en modul som profileras i stället för ett skript."

msgid "Added the ``-m`` option to :mod:`cProfile`."
msgstr "Alternativet ``-m`` lades till i :mod:`cProfile`."

msgid "Added the ``-m`` option to :mod:`profile`."
msgstr "Alternativet ``-m`` lades till i :mod:`profile`."

msgid ""
"The :mod:`pstats` module's :class:`~pstats.Stats` class has a variety of "
"methods for manipulating and printing the data saved into a profile results "
"file::"
msgstr ""
"Modulen :mod:`pstats` klass :class:`~pstats.Stats` har en mängd olika "
"metoder för att manipulera och skriva ut data som sparats i en "
"profilresultatfil::"

msgid ""
"import pstats\n"
"from pstats import SortKey\n"
"p = pstats.Stats('restats')\n"
"p.strip_dirs().sort_stats(-1).print_stats()"
msgstr ""
"import pstats\n"
"from pstats import SortKey\n"
"p = pstats.Stats('restats')\n"
"p.strip_dirs().sort_stats(-1).print_stats()"

msgid ""
"The :meth:`~pstats.Stats.strip_dirs` method removed the extraneous path from "
"all the module names. The :meth:`~pstats.Stats.sort_stats` method sorted all "
"the entries according to the standard module/line/name string that is "
"printed. The :meth:`~pstats.Stats.print_stats` method printed out all the "
"statistics.  You might try the following sort calls::"
msgstr ""
"Metoden :meth:`~pstats.Stats.strip_dirs` tog bort den främmande sökvägen "
"från alla modulnamn. Metoden :meth:`~pstats.Stats.sort_stats` sorterade alla "
"poster enligt den standardsträng för modul/rad/namn som skrivs ut. Metoden :"
"meth:`~pstats.Stats.print_stats` skrev ut all statistik.  Du kan prova "
"följande sorteringsanrop::"

msgid ""
"p.sort_stats(SortKey.NAME)\n"
"p.print_stats()"
msgstr ""
"p.sort_stats(SortKey.NAME)\n"
"p.print_stats()"

msgid ""
"The first call will actually sort the list by function name, and the second "
"call will print out the statistics.  The following are some interesting "
"calls to experiment with::"
msgstr ""
"Det första anropet sorterar faktiskt listan efter funktionsnamn och det "
"andra anropet skriver ut statistiken.  Följande är några intressanta anrop "
"att experimentera med::"

msgid "p.sort_stats(SortKey.CUMULATIVE).print_stats(10)"
msgstr "p.sort_stats(SortKey.CUMULATIVE).print_stats(10)"

msgid ""
"This sorts the profile by cumulative time in a function, and then only "
"prints the ten most significant lines.  If you want to understand what "
"algorithms are taking time, the above line is what you would use."
msgstr ""
"Detta sorterar profilen efter kumulativ tid i en funktion och skriver sedan "
"bara ut de tio mest betydelsefulla raderna.  Om du vill förstå vilka "
"algoritmer som tar tid är det raden ovan som du ska använda."

msgid ""
"If you were looking to see what functions were looping a lot, and taking a "
"lot of time, you would do::"
msgstr ""
"Om du ville se vilka funktioner som loopade mycket och tog mycket tid, "
"skulle du göra::"

msgid "p.sort_stats(SortKey.TIME).print_stats(10)"
msgstr "p.sort_stats(SortKey.TIME).print_stats(10)"

msgid ""
"to sort according to time spent within each function, and then print the "
"statistics for the top ten functions."
msgstr ""
"för att sortera efter tidsåtgång inom varje funktion och sedan skriva ut "
"statistiken för de tio bästa funktionerna."

msgid "You might also try::"
msgstr "Du kan också prova::"

msgid "p.sort_stats(SortKey.FILENAME).print_stats('__init__')"
msgstr "p.sort_stats(SortKey.FILENAME).print_stats('__init__')"

msgid ""
"This will sort all the statistics by file name, and then print out "
"statistics for only the class init methods (since they are spelled with "
"``__init__`` in them).  As one final example, you could try::"
msgstr ""
"Detta sorterar all statistik efter filnamn och skriver sedan ut statistik "
"för endast klassens init-metoder (eftersom de stavas med ``__init__`` i "
"sig).  Som ett sista exempel kan du prova::"

msgid "p.sort_stats(SortKey.TIME, SortKey.CUMULATIVE).print_stats(.5, 'init')"
msgstr "p.sort_stats(SortKey.TIME, SortKey.CUMULATIVE).print_stats(.5, 'init')"

msgid ""
"This line sorts statistics with a primary key of time, and a secondary key "
"of cumulative time, and then prints out some of the statistics. To be "
"specific, the list is first culled down to 50% (re: ``.5``) of its original "
"size, then only lines containing ``init`` are maintained, and that sub-sub-"
"list is printed."
msgstr ""
"Denna rad sorterar statistik med en primär nyckel för tid och en sekundär "
"nyckel för kumulativ tid, och skriver sedan ut en del av statistiken. För "
"att vara specifik, gallras listan först ner till 50% (re: ``.5``) av sin "
"ursprungliga storlek, sedan behålls endast rader som innehåller ``init``, "
"och den under-sub-listan skrivs ut."

msgid ""
"If you wondered what functions called the above functions, you could now "
"(``p`` is still sorted according to the last criteria) do::"
msgstr ""
"Om du undrade vilka funktioner som kallade ovanstående funktioner, kan du nu "
"(``p`` är fortfarande sorterad enligt det sista kriteriet) göra::"

msgid "p.print_callers(.5, 'init')"
msgstr "p.print_callers(.5, 'init')"

msgid "and you would get a list of callers for each of the listed functions."
msgstr ""
"och du får en lista över personer som ringer för var och en av de listade "
"funktionerna."

msgid ""
"If you want more functionality, you're going to have to read the manual, or "
"guess what the following functions do::"
msgstr ""
"Om du vill ha fler funktioner måste du läsa manualen eller gissa vad "
"följande funktioner gör::"

msgid ""
"p.print_callees()\n"
"p.add('restats')"
msgstr ""
"p.print_callees()\n"
"p.add('restats')"

msgid ""
"Invoked as a script, the :mod:`pstats` module is a statistics browser for "
"reading and examining profile dumps.  It has a simple line-oriented "
"interface (implemented using :mod:`cmd`) and interactive help."
msgstr ""
"Modulen :mod:`pstats` anropas som ett skript och är en statistikbläddrare "
"för läsning och granskning av profildumpar.  Den har ett enkelt "
"linjeorienterat gränssnitt (implementerat med hjälp av :mod:`cmd`) och "
"interaktiv hjälp."

msgid ":mod:`profile` and :mod:`cProfile` Module Reference"
msgstr ":mod:`profile` och :mod:`cProfile` Modulreferens"

msgid ""
"Both the :mod:`profile` and :mod:`cProfile` modules provide the following "
"functions:"
msgstr ""
"Både modulerna :mod:`profile` och :mod:`cProfile` innehåller följande "
"funktioner:"

msgid ""
"This function takes a single argument that can be passed to the :func:`exec` "
"function, and an optional file name.  In all cases this routine executes::"
msgstr ""
"Denna funktion tar ett enda argument som kan skickas till :func:`exec`-"
"funktionen, och ett valfritt filnamn.  I samtliga fall exekveras denna "
"rutin::"

msgid "exec(command, __main__.__dict__, __main__.__dict__)"
msgstr "exec(kommando, __main__.__dict__, __main__.__dict__)"

msgid ""
"and gathers profiling statistics from the execution. If no file name is "
"present, then this function automatically creates a :class:`~pstats.Stats` "
"instance and prints a simple profiling report. If the sort value is "
"specified, it is passed to this :class:`~pstats.Stats` instance to control "
"how the results are sorted."
msgstr ""
"och samlar in profileringsstatistik från körningen. Om det inte finns något "
"filnamn skapar funktionen automatiskt en :class:`~pstats.Stats`-instans och "
"skriver ut en enkel profileringsrapport. Om sorteringsvärdet anges skickas "
"det till denna :class:`~pstats.Stats`-instans för att styra hur resultaten "
"ska sorteras."

msgid ""
"This function is similar to :func:`run`, with added arguments to supply the "
"globals and locals mappings for the *command* string. This routine executes::"
msgstr ""
"Den här funktionen liknar :func:`run`, med extra argument för att ange "
"mappningarna för globals och locals för *command*-strängen. Den här rutinen "
"exekverar::"

msgid "exec(command, globals, locals)"
msgstr "exec(kommando, globals, locals)"

msgid "and gathers profiling statistics as in the :func:`run` function above."
msgstr "och samlar in profileringsstatistik som i funktionen :func:`run` ovan."

msgid ""
"This class is normally only used if more precise control over profiling is "
"needed than what the :func:`cProfile.run` function provides."
msgstr ""
"Den här klassen används normalt bara om det behövs mer exakt kontroll över "
"profileringen än vad funktionen :func:`cProfile.run` ger."

msgid ""
"A custom timer can be supplied for measuring how long code takes to run via "
"the *timer* argument. This must be a function that returns a single number "
"representing the current time. If the number is an integer, the *timeunit* "
"specifies a multiplier that specifies the duration of each unit of time. For "
"example, if the timer returns times measured in thousands of seconds, the "
"time unit would be ``.001``."
msgstr ""
"En egen timer kan tillhandahållas för att mäta hur lång tid det tar för "
"koden att köras via argumentet *timer*. Detta måste vara en funktion som "
"returnerar ett enda tal som representerar den aktuella tiden. Om talet är "
"ett heltal anger *timeunit* en multiplikator som anger varaktigheten för "
"varje tidsenhet. Om timern t.ex. returnerar tider som mäts i tusendelar av "
"sekunder, är tidsenheten ``.001``."

msgid ""
"Directly using the :class:`Profile` class allows formatting profile results "
"without writing the profile data to a file::"
msgstr ""
"Genom att direkt använda klassen :class:`Profile` kan du formatera "
"profilresultat utan att skriva profildata till en fil::"

msgid ""
"import cProfile, pstats, io\n"
"from pstats import SortKey\n"
"pr = cProfile.Profile()\n"
"pr.enable()\n"
"# ... do something ...\n"
"pr.disable()\n"
"s = io.StringIO()\n"
"sortby = SortKey.CUMULATIVE\n"
"ps = pstats.Stats(pr, stream=s).sort_stats(sortby)\n"
"ps.print_stats()\n"
"print(s.getvalue())"
msgstr ""
"import cProfile, pstats, io\n"
"från pstats import SortKey\n"
"pr = cProfile.profil()\n"
"pr.enable()\n"
"# ... gör något ...\n"
"pr.disable()\n"
"s = io.StringIO()\n"
"sortby = SortKey.CUMULATIVE\n"
"ps = pstats.Stats(pr, stream=s).sort_stats(sortby)\n"
"ps.print_stats()\n"
"print(s.getvalue())"

msgid ""
"The :class:`Profile` class can also be used as a context manager (supported "
"only in :mod:`cProfile` module. see :ref:`typecontextmanager`)::"
msgstr ""
"Klassen :class:`Profile` kan också användas som en kontexthanterare (stöds "
"endast i modulen :mod:`cProfile`. se :ref:`typecontextmanager`)::"

msgid ""
"import cProfile\n"
"\n"
"with cProfile.Profile() as pr:\n"
"    # ... do something ...\n"
"\n"
"    pr.print_stats()"
msgstr ""
"import cProfile\n"
"\n"
"med cProfile.Profile() som pr:\n"
"    # ... gör något ...\n"
"\n"
"    pr.print_stats()"

msgid "Added context manager support."
msgstr "Stöd för kontexthanterare har lagts till."

msgid "Start collecting profiling data. Only in :mod:`cProfile`."
msgstr "Börja samla in profileringsdata. Endast i :mod:`cProfile`."

msgid "Stop collecting profiling data. Only in :mod:`cProfile`."
msgstr "Sluta samla in profileringsdata. Endast i :mod:`cProfile`."

msgid ""
"Stop collecting profiling data and record the results internally as the "
"current profile."
msgstr ""
"Sluta samla in profileringsdata och registrera resultaten internt som den "
"aktuella profilen."

msgid ""
"Create a :class:`~pstats.Stats` object based on the current profile and "
"print the results to stdout."
msgstr ""
"Skapa ett :class:`~pstats.Stats`-objekt baserat på den aktuella profilen och "
"skriv ut resultaten till stdout."

msgid ""
"The *sort* parameter specifies the sorting order of the displayed "
"statistics. It accepts a single key or a tuple of keys to enable multi-level "
"sorting, as in :func:`Stats.sort_stats <pstats.Stats.sort_stats>`."
msgstr ""
"Parametern *sort* anger sorteringsordningen för den statistik som visas. Den "
"accepterar en enda nyckel eller en tupel av nycklar för att möjliggöra "
"sortering på flera nivåer, som i :func:`Stats.sort_stats <pstats.Stats."
"sort_stats>`."

msgid ":meth:`~Profile.print_stats` now accepts a tuple of keys."
msgstr ":meth:`~Profile.print_stats` accepterar nu en tupel av nycklar."

msgid "Write the results of the current profile to *filename*."
msgstr "Skriv resultatet av den aktuella profilen till *filnamn*."

msgid "Profile the cmd via :func:`exec`."
msgstr "Profilera cmd:n via :func:`exec`."

msgid ""
"Profile the cmd via :func:`exec` with the specified global and local "
"environment."
msgstr ""
"Profilera cmd via :func:`exec` med den angivna globala och lokala miljön."

msgid "Profile ``func(*args, **kwargs)``"
msgstr "Profil ``func(*args, **kwargs)``"

msgid ""
"Note that profiling will only work if the called command/function actually "
"returns.  If the interpreter is terminated (e.g. via a :func:`sys.exit` call "
"during the called command/function execution) no profiling results will be "
"printed."
msgstr ""
"Observera att profileringen endast fungerar om det anropade kommandot/"
"funktionen faktiskt returneras.  Om tolken avslutas (t.ex. via ett :func:"
"`sys.exit`-anrop under exekveringen av det anropade kommandot/funktionen) "
"kommer inga profileringsresultat att skrivas ut."

msgid "The :class:`Stats` Class"
msgstr "Klassen :class:`Stats"

msgid ""
"Analysis of the profiler data is done using the :class:`~pstats.Stats` class."
msgstr ""
"Analys av profileringsdata görs med hjälp av klassen :class:`~pstats.Stats`."

msgid ""
"This class constructor creates an instance of a \"statistics object\" from a "
"*filename* (or list of filenames) or from a :class:`Profile` instance. "
"Output will be printed to the stream specified by *stream*."
msgstr ""
"Denna klasskonstruktor skapar en instans av ett \"statistikobjekt\" från ett "
"*filnamn* (eller en lista med filnamn) eller från en :class:`Profile`-"
"instans. Utdata kommer att skrivas ut till den ström som anges av *stream*."

msgid ""
"The file selected by the above constructor must have been created by the "
"corresponding version of :mod:`profile` or :mod:`cProfile`.  To be specific, "
"there is *no* file compatibility guaranteed with future versions of this "
"profiler, and there is no compatibility with files produced by other "
"profilers, or the same profiler run on a different operating system.  If "
"several files are provided, all the statistics for identical functions will "
"be coalesced, so that an overall view of several processes can be considered "
"in a single report.  If additional files need to be combined with data in an "
"existing :class:`~pstats.Stats` object, the :meth:`~pstats.Stats.add` method "
"can be used."
msgstr ""
"Den fil som väljs av ovanstående konstruktör måste ha skapats av motsvarande "
"version av :mod:`profile` eller :mod:`cProfile`.  För att vara specifik, det "
"finns *ingen* garanterad filkompatibilitet med framtida versioner av denna "
"profilerare, och det finns ingen kompatibilitet med filer som producerats av "
"andra profilerare, eller samma profilerare som körs på ett annat "
"operativsystem.  Om flera filer tillhandahålls kommer all statistik för "
"identiska funktioner att sammanställas, så att en övergripande bild av flera "
"processer kan beaktas i en enda rapport.  Om ytterligare filer behöver "
"kombineras med data i ett befintligt :class:`~pstats.Stats`-objekt, kan "
"metoden :meth:`~pstats.Stats.add` användas."

msgid ""
"Instead of reading the profile data from a file, a :class:`cProfile.Profile` "
"or :class:`profile.Profile` object can be used as the profile data source."
msgstr ""
"I stället för att läsa profildata från en fil kan ett :class:`cProfile."
"Profile`- eller :class:`profile.Profile`-objekt användas som profildatakälla."

msgid ":class:`Stats` objects have the following methods:"
msgstr ":class:`Stats`-objekt har följande metoder:"

msgid ""
"This method for the :class:`Stats` class removes all leading path "
"information from file names.  It is very useful in reducing the size of the "
"printout to fit within (close to) 80 columns.  This method modifies the "
"object, and the stripped information is lost.  After performing a strip "
"operation, the object is considered to have its entries in a \"random\" "
"order, as it was just after object initialization and loading. If :meth:"
"`~pstats.Stats.strip_dirs` causes two function names to be indistinguishable "
"(they are on the same line of the same filename, and have the same function "
"name), then the statistics for these two entries are accumulated into a "
"single entry."
msgstr ""
"Den här metoden för klassen :class:`Stats` tar bort all inledande "
"sökvägsinformation från filnamn.  Det är mycket användbart för att minska "
"storleken på utskriften så att den ryms inom (nära) 80 kolumner.  Den här "
"metoden ändrar objektet och den borttagna informationen går förlorad.  Efter "
"att ha utfört en strippning anses objektet ha sina poster i en "
"\"slumpmässig\" ordning, som den var precis efter initialisering och "
"laddning av objektet. Om :meth:`~pstats.Stats.strip_dirs` gör att två "
"funktionsnamn inte går att skilja åt (de står på samma rad i samma filnamn "
"och har samma funktionsnamn), ackumuleras statistiken för dessa två poster "
"till en enda post."

msgid ""
"This method of the :class:`Stats` class accumulates additional profiling "
"information into the current profiling object.  Its arguments should refer "
"to filenames created by the corresponding version of :func:`profile.run` or :"
"func:`cProfile.run`. Statistics for identically named (re: file, line, name) "
"functions are automatically accumulated into single function statistics."
msgstr ""
"Denna metod i klassen :class:`Stats` ackumulerar ytterligare "
"profileringsinformation i det aktuella profileringsobjektet.  Dess argument "
"bör referera till filnamn som skapats av motsvarande version av :func:"
"`profile.run` eller :func:`cProfile.run`. Statistik för identiskt namngivna "
"(re: fil, rad, namn) funktioner ackumuleras automatiskt till statistik för "
"en enda funktion."

msgid ""
"Save the data loaded into the :class:`Stats` object to a file named "
"*filename*.  The file is created if it does not exist, and is overwritten if "
"it already exists.  This is equivalent to the method of the same name on "
"the :class:`profile.Profile` and :class:`cProfile.Profile` classes."
msgstr ""
"Spara data som laddats i objektet :class:`Stats` till en fil med namnet "
"*filnamn*.  Filen skapas om den inte finns, och skrivs över om den redan "
"finns.  Detta är likvärdigt med metoden med samma namn i klasserna :class:"
"`profile.Profile` och :class:`cProfile.Profile`."

msgid ""
"This method modifies the :class:`Stats` object by sorting it according to "
"the supplied criteria.  The argument can be either a string or a SortKey "
"enum identifying the basis of a sort (example: ``'time'``, ``'name'``, "
"``SortKey.TIME`` or ``SortKey.NAME``). The SortKey enums argument have "
"advantage over the string argument in that it is more robust and less error "
"prone."
msgstr ""
"Denna metod modifierar :class:`Stats`-objektet genom att sortera det enligt "
"de angivna kriterierna.  Argumentet kan vara antingen en sträng eller ett "
"SortKey-enum som identifierar grunden för en sortering (exempel: ``'time'``, "
"``'name'``, ``SortKey.TIME`` eller ``SortKey.NAME``). Argumentet SortKey "
"enums har en fördel jämfört med strängargumentet genom att det är mer robust "
"och mindre felbenäget."

msgid ""
"When more than one key is provided, then additional keys are used as "
"secondary criteria when there is equality in all keys selected before them.  "
"For example, ``sort_stats(SortKey.NAME, SortKey.FILE)`` will sort all the "
"entries according to their function name, and resolve all ties (identical "
"function names) by sorting by file name."
msgstr ""
"När mer än en nyckel anges används ytterligare nycklar som sekundära "
"kriterier när det råder likhet mellan alla nycklar som valts före dem.  "
"Exempelvis sorterar ``sort_stats(SortKey.NAME, SortKey.FILE)`` alla poster "
"efter deras funktionsnamn och löser alla oavgjorda frågor (identiska "
"funktionsnamn) genom att sortera efter filnamn."

msgid ""
"For the string argument, abbreviations can be used for any key names, as "
"long as the abbreviation is unambiguous."
msgstr ""
"För strängargumentet kan förkortningar användas för alla nyckelnamn, så "
"länge förkortningen är entydig."

msgid "The following are the valid string and SortKey:"
msgstr "Följande är giltiga strängar och SortKey:"

msgid "Valid String Arg"
msgstr "Giltig sträng Arg"

msgid "Valid enum Arg"
msgstr "Giltig enum Arg"

msgid "Meaning"
msgstr "Betydelse"

msgid "``'calls'``"
msgstr "```samtal```"

msgid "SortKey.CALLS"
msgstr "SortKey.CALLS"

msgid "call count"
msgstr "antal samtal"

msgid "``'cumulative'``"
msgstr "``'kumulativ'```"

msgid "SortKey.CUMULATIVE"
msgstr "SortKey.KUMULATIV"

msgid "cumulative time"
msgstr "kumulativ tid"

msgid "``'cumtime'``"
msgstr "``'cumtime'```"

msgid "N/A"
msgstr "N/A"

msgid "``'file'``"
msgstr "``'fil'```"

msgid "file name"
msgstr "filnamn"

msgid "``'filename'``"
msgstr "``'filnamn'```"

msgid "SortKey.FILENAME"
msgstr "SortKey.FILENAME"

msgid "``'module'``"
msgstr "``'modul'```"

msgid "``'ncalls'``"
msgstr "``'ncalls'```"

msgid "``'pcalls'``"
msgstr "``'pcalls'```"

msgid "SortKey.PCALLS"
msgstr "Sorteringsnyckel.PCALLS"

msgid "primitive call count"
msgstr "antal primitiva samtal"

msgid "``'line'``"
msgstr "``'linje'```"

msgid "SortKey.LINE"
msgstr "Sorteringsnyckel.LINJE"

msgid "line number"
msgstr "radnummer"

msgid "``'name'``"
msgstr "``'namn'```"

msgid "SortKey.NAME"
msgstr "Sorteringsnyckel.namn"

msgid "function name"
msgstr "funktionsnamn"

msgid "``'nfl'``"
msgstr "``'nfl'```"

msgid "SortKey.NFL"
msgstr "Sorteringsnyckel.NFL"

msgid "name/file/line"
msgstr "namn/fil/rad"

msgid "``'stdname'``"
msgstr "``'stdname'```"

msgid "SortKey.STDNAME"
msgstr "SortKey.STDNAME"

msgid "standard name"
msgstr "standardnamn"

msgid "``'time'``"
msgstr "``'tid'```"

msgid "SortKey.TIME"
msgstr "Sorteringsnyckel.TIME"

msgid "internal time"
msgstr "intern tid"

msgid "``'tottime'``"
msgstr "``'tottime'```"

msgid ""
"Note that all sorts on statistics are in descending order (placing most time "
"consuming items first), where as name, file, and line number searches are in "
"ascending order (alphabetical). The subtle distinction between ``SortKey."
"NFL`` and ``SortKey.STDNAME`` is that the standard name is a sort of the "
"name as printed, which means that the embedded line numbers get compared in "
"an odd way.  For example, lines 3, 20, and 40 would (if the file names were "
"the same) appear in the string order 20, 3 and 40. In contrast, ``SortKey."
"NFL`` does a numeric compare of the line numbers. In fact, "
"``sort_stats(SortKey.NFL)`` is the same as ``sort_stats(SortKey.NAME, "
"SortKey.FILENAME, SortKey.LINE)``."
msgstr ""
"Observera att alla sorteringar av statistik är i fallande ordning (de mest "
"tidskrävande först), medan sökningar efter namn, filer och radnummer är i "
"stigande ordning (alfabetisk). Den subtila skillnaden mellan ``SortKey.NFL`` "
"och ``SortKey.STDNAME`` är att standardnamnet är en sortering av namnet som "
"det skrivs ut, vilket innebär att de inbäddade radnumren jämförs på ett udda "
"sätt.  Till exempel skulle raderna 3, 20 och 40 (om filnamnen var desamma) "
"visas i strängordningen 20, 3 och 40. Däremot gör ``SortKey.NFL`` en "
"numerisk jämförelse av radnumren. I själva verket är ``Sort_stats(SortKey."
"NFL)`` samma sak som ``Sort_stats(SortKey.NAME, SortKey.FILENAME, SortKey."
"LINE)``."

msgid ""
"For backward-compatibility reasons, the numeric arguments ``-1``, ``0``, "
"``1``, and ``2`` are permitted.  They are interpreted as ``'stdname'``, "
"``'calls'``, ``'time'``, and ``'cumulative'`` respectively.  If this old "
"style format (numeric) is used, only one sort key (the numeric key) will be "
"used, and additional arguments will be silently ignored."
msgstr ""
"Av bakåtkompatibilitetsskäl är de numeriska argumenten ``-1``, ``0``, ``1`` "
"och ``2`` tillåtna.  De tolkas som ``'stdname'``, ``'calls'``, ``'time'`` "
"respektive ``'cumulative'``.  Om detta gamla format (numeriskt) används, "
"kommer endast en sorteringsnyckel (den numeriska nyckeln) att användas, och "
"ytterligare argument kommer att ignoreras."

msgid "Added the SortKey enum."
msgstr "Enumret SortKey har lagts till."

msgid ""
"This method for the :class:`Stats` class reverses the ordering of the basic "
"list within the object.  Note that by default ascending vs descending order "
"is properly selected based on the sort key of choice."
msgstr ""
"Denna metod för klassen :class:`Stats` reverserar ordningen på grundlistan i "
"objektet.  Observera att som standard väljs stigande eller fallande ordning "
"korrekt baserat på den valda sorteringsnyckeln."

msgid ""
"This method for the :class:`Stats` class prints out a report as described in "
"the :func:`profile.run` definition."
msgstr ""
"Denna metod för klassen :class:`Stats` skriver ut en rapport enligt "
"beskrivningen i definitionen :func:`profile.run`."

msgid ""
"The order of the printing is based on the last :meth:`~pstats.Stats."
"sort_stats` operation done on the object (subject to caveats in :meth:"
"`~pstats.Stats.add` and :meth:`~pstats.Stats.strip_dirs`)."
msgstr ""
"Ordningen på utskriften baseras på den senaste :meth:`~pstats.Stats."
"sort_stats`-operationen som gjordes på objektet (med förbehåll för förbehåll "
"i :meth:`~pstats.Stats.add` och :meth:`~pstats.Stats.strip_dirs`)."

msgid ""
"The arguments provided (if any) can be used to limit the list down to the "
"significant entries.  Initially, the list is taken to be the complete set of "
"profiled functions.  Each restriction is either an integer (to select a "
"count of lines), or a decimal fraction between 0.0 and 1.0 inclusive (to "
"select a percentage of lines), or a string that will interpreted as a "
"regular expression (to pattern match the standard name that is printed). If "
"several restrictions are provided, then they are applied sequentially. For "
"example::"
msgstr ""
"De argument som anges (om sådana finns) kan användas för att begränsa listan "
"till de viktigaste posterna.  Inledningsvis antas listan vara den "
"fullständiga uppsättningen profilerade funktioner.  Varje begränsning är "
"antingen ett heltal (för att välja ett antal rader), ett decimaltal mellan "
"0,0 och 1,0 (för att välja en procentandel av raderna) eller en sträng som "
"tolkas som ett reguljärt uttryck (för att mönstermatcha det standardnamn som "
"skrivs ut). Om flera begränsningar anges tillämpas de sekventiellt. Till "
"exempel::"

msgid "print_stats(.1, 'foo:')"
msgstr "print_stats(.1, 'foo:')"

msgid ""
"would first limit the printing to first 10% of list, and then only print "
"functions that were part of filename :file:`.\\*foo:`.  In contrast, the "
"command::"
msgstr ""
"skulle först begränsa utskriften till den första 10% of-listan och sedan "
"bara skriva ut funktioner som ingick i filnamnet :file:`.\\*foo:`.  I "
"motsats till detta skulle kommandot::"

msgid "print_stats('foo:', .1)"
msgstr "print_stats('foo:', .1)"

msgid ""
"would limit the list to all functions having file names :file:`.\\*foo:`, "
"and then proceed to only print the first 10% of them."
msgstr ""
"skulle begränsa listan till alla funktioner som har filnamnen :file:`.\\*foo:"
"`, och sedan bara skriva ut de första 10% of dem."

msgid ""
"This method for the :class:`Stats` class prints a list of all functions that "
"called each function in the profiled database.  The ordering is identical to "
"that provided by :meth:`~pstats.Stats.print_stats`, and the definition of "
"the restricting argument is also identical.  Each caller is reported on its "
"own line.  The format differs slightly depending on the profiler that "
"produced the stats:"
msgstr ""
"Denna metod för klassen :class:`Stats` skriver ut en lista över alla "
"funktioner som anropade varje funktion i den profilerade databasen.  "
"Ordningen är identisk med den som tillhandahålls av :meth:`~pstats.Stats."
"print_stats`, och definitionen av det begränsande argumentet är också "
"identisk.  Varje uppringare rapporteras på en egen rad.  Formatet skiljer "
"sig något beroende på vilken profilerare som producerade statistiken:"

msgid ""
"With :mod:`profile`, a number is shown in parentheses after each caller to "
"show how many times this specific call was made.  For convenience, a second "
"non-parenthesized number repeats the cumulative time spent in the function "
"at the right."
msgstr ""
"Med :mod:`profile` visas ett tal inom parentes efter varje uppringare för "
"att visa hur många gånger just detta uppringande gjordes.  För enkelhetens "
"skull upprepar en andra siffra utan parentes den sammanlagda tid som "
"tillbringats i funktionen till höger."

msgid ""
"With :mod:`cProfile`, each caller is preceded by three numbers: the number "
"of times this specific call was made, and the total and cumulative times "
"spent in the current function while it was invoked by this specific caller."
msgstr ""
"Med :mod:`cProfile` föregås varje anrop av tre siffror: antalet gånger som "
"det specifika anropet gjordes och den totala och kumulativa tid som "
"spenderades i den aktuella funktionen när den anropades av den specifika "
"anroparen."

msgid ""
"This method for the :class:`Stats` class prints a list of all function that "
"were called by the indicated function.  Aside from this reversal of "
"direction of calls (re: called vs was called by), the arguments and ordering "
"are identical to the :meth:`~pstats.Stats.print_callers` method."
msgstr ""
"Denna metod för klassen :class:`Stats` skriver ut en lista över alla "
"funktioner som anropades av den angivna funktionen.  Bortsett från denna "
"omkastning av anropens riktning (re: called vs was called by) är argumenten "
"och ordningen identiska med metoden :meth:`~pstats.Stats.print_callers`."

msgid ""
"This method returns an instance of StatsProfile, which contains a mapping of "
"function names to instances of FunctionProfile. Each FunctionProfile "
"instance holds information related to the function's profile such as how "
"long the function took to run, how many times it was called, etc..."
msgstr ""
"Denna metod returnerar en instans av StatsProfile, som innehåller en "
"mappning av funktionsnamn till instanser av FunctionProfile. Varje "
"FunctionProfile-instans innehåller information som är relaterad till "
"funktionens profil, t.ex. hur lång tid det tog för funktionen att köras, hur "
"många gånger den anropades osv."

msgid ""
"Added the following dataclasses: StatsProfile, FunctionProfile. Added the "
"following function: get_stats_profile."
msgstr ""
"Lade till följande dataklasser: StatsProfile, FunctionProfile. Följande "
"funktion lades till: get_stats_profile."

msgid "What Is Deterministic Profiling?"
msgstr "Vad är deterministisk profilering?"

msgid ""
":dfn:`Deterministic profiling` is meant to reflect the fact that all "
"*function call*, *function return*, and *exception* events are monitored, "
"and precise timings are made for the intervals between these events (during "
"which time the user's code is executing).  In contrast, :dfn:`statistical "
"profiling` (which is not done by this module) randomly samples the effective "
"instruction pointer, and deduces where time is being spent.  The latter "
"technique traditionally involves less overhead (as the code does not need to "
"be instrumented), but provides only relative indications of where time is "
"being spent."
msgstr ""
":dfn:`Deterministic profiling` är tänkt att återspegla det faktum att alla "
"händelser av typen *funktionsanrop*, *funktionsretur* och *undantag* "
"övervakas och att exakta tidsangivelser görs för intervallen mellan dessa "
"händelser (under vilken tid användarens kod exekveras).  Vid :dfn:"
"`statistical profiling` (som inte görs av den här modulen) görs däremot "
"slumpmässiga stickprov på den effektiva instruktionspekaren och man drar "
"slutsatser om var tiden spenderas.  Den senare tekniken innebär "
"traditionellt mindre overhead (eftersom koden inte behöver instrumenteras), "
"men ger bara relativa indikationer på var tiden spenderas."

msgid ""
"In Python, since there is an interpreter active during execution, the "
"presence of instrumented code is not required in order to do deterministic "
"profiling. Python automatically provides a :dfn:`hook` (optional callback) "
"for each event. In addition, the interpreted nature of Python tends to add "
"so much overhead to execution, that deterministic profiling tends to only "
"add small processing overhead in typical applications.  The result is that "
"deterministic profiling is not that expensive, yet provides extensive run "
"time statistics about the execution of a Python program."
msgstr ""
"I Python, eftersom det finns en tolk som är aktiv under exekveringen, krävs "
"det inte att det finns instrumenterad kod för att göra en deterministisk "
"profilering. Python tillhandahåller automatiskt en :dfn:`hook` (valfri "
"callback) för varje händelse. Dessutom tenderar Pythons tolkade natur att "
"lägga till så mycket overhead till exekveringen att deterministisk "
"profilering tenderar att bara lägga till liten bearbetningsoverhead i "
"typiska applikationer.  Resultatet är att deterministisk profilering inte är "
"särskilt dyr, men ändå ger omfattande körtidsstatistik om körningen av ett "
"Python-program."

msgid ""
"Call count statistics can be used to identify bugs in code (surprising "
"counts), and to identify possible inline-expansion points (high call "
"counts).  Internal time statistics can be used to identify \"hot loops\" "
"that should be carefully optimized.  Cumulative time statistics should be "
"used to identify high level errors in the selection of algorithms.  Note "
"that the unusual handling of cumulative times in this profiler allows "
"statistics for recursive implementations of algorithms to be directly "
"compared to iterative implementations."
msgstr ""
"Statistik över antal anrop kan användas för att identifiera buggar i koden "
"(överraskande antal anrop) och för att identifiera möjliga punkter för "
"inline-expansion (högt antal anrop).  Intern tidsstatistik kan användas för "
"att identifiera \"heta loopar\" som bör optimeras noggrant.  Kumulativ "
"tidsstatistik bör användas för att identifiera högnivåfel i valet av "
"algoritmer.  Observera att den ovanliga hanteringen av kumulativa tider i "
"den här profileraren gör att statistik för rekursiva implementeringar av "
"algoritmer kan jämföras direkt med iterativa implementeringar."

msgid "Limitations"
msgstr "Begränsningar"

msgid ""
"One limitation has to do with accuracy of timing information. There is a "
"fundamental problem with deterministic profilers involving accuracy.  The "
"most obvious restriction is that the underlying \"clock\" is only ticking at "
"a rate (typically) of about .001 seconds.  Hence no measurements will be "
"more accurate than the underlying clock.  If enough measurements are taken, "
"then the \"error\" will tend to average out. Unfortunately, removing this "
"first error induces a second source of error."
msgstr ""
"En begränsning har att göra med noggrannheten i tidsinformationen. Det finns "
"ett grundläggande problem med deterministiska profilerare som rör "
"noggrannhet.  Den mest uppenbara begränsningen är att den underliggande "
"\"klockan\" bara tickar med en hastighet (typiskt) på cirka 0,001 sekunder.  "
"Därför kommer inga mätningar att vara mer exakta än den underliggande "
"klockan.  Om tillräckligt många mätningar görs tenderar \"felet\" att jämna "
"ut sig. Om man tar bort detta första fel uppstår tyvärr en andra felkälla."

msgid ""
"The second problem is that it \"takes a while\" from when an event is "
"dispatched until the profiler's call to get the time actually *gets* the "
"state of the clock.  Similarly, there is a certain lag when exiting the "
"profiler event handler from the time that the clock's value was obtained "
"(and then squirreled away), until the user's code is once again executing.  "
"As a result, functions that are called many times, or call many functions, "
"will typically accumulate this error. The error that accumulates in this "
"fashion is typically less than the accuracy of the clock (less than one "
"clock tick), but it *can* accumulate and become very significant."
msgstr ""
"Det andra problemet är att det \"tar ett tag\" från det att en händelse "
"skickas till dess att profilerarens anrop för att få tiden faktiskt *får* "
"klockans tillstånd.  På samma sätt finns det en viss fördröjning när man "
"lämnar profileringshändelsehanteraren från det att klockans värde erhölls "
"(och sedan gömdes undan) tills användarens kod återigen körs.  Därför kommer "
"funktioner som anropas många gånger, eller som anropar många funktioner, "
"vanligtvis att ackumulera detta fel. Felet som ackumuleras på detta sätt är "
"vanligtvis mindre än klockans noggrannhet (mindre än ett klockslag), men det "
"*kan* ackumuleras och bli mycket betydande."

msgid ""
"The problem is more important with :mod:`profile` than with the lower-"
"overhead :mod:`cProfile`.  For this reason, :mod:`profile` provides a means "
"of calibrating itself for a given platform so that this error can be "
"probabilistically (on the average) removed. After the profiler is "
"calibrated, it will be more accurate (in a least square sense), but it will "
"sometimes produce negative numbers (when call counts are exceptionally low, "
"and the gods of probability work against you :-). )  Do *not* be alarmed by "
"negative numbers in the profile.  They should *only* appear if you have "
"calibrated your profiler, and the results are actually better than without "
"calibration."
msgstr ""
"Problemet är större med :mod:`profile` än med den mindre avancerade :mod:"
"`cProfile`.  Av denna anledning tillhandahåller :mod:`profile` ett sätt att "
"kalibrera sig själv för en given plattform så att detta fel kan tas bort på "
"ett probabilistiskt sätt (i genomsnitt). När profileraren har kalibrerats "
"kommer den att vara mer exakt (i minsta kvadrat-led), men den kommer ibland "
"att producera negativa siffror (när antalet anrop är exceptionellt lågt och "
"sannolikhetens gudar arbetar emot dig :-). )  Låt dig *inte* skrämmas av "
"negativa siffror i profilen.  De ska *endast* visas om du har kalibrerat din "
"profilerare och resultaten faktiskt är bättre än utan kalibrering."

msgid "Calibration"
msgstr "Kalibrering"

msgid ""
"The profiler of the :mod:`profile` module subtracts a constant from each "
"event handling time to compensate for the overhead of calling the time "
"function, and socking away the results.  By default, the constant is 0. The "
"following procedure can be used to obtain a better constant for a given "
"platform (see :ref:`profile-limitations`). ::"
msgstr ""
"Profileraren i modulen :mod:`profile` subtraherar en konstant från varje "
"händelsehanteringstid för att kompensera för omkostnaderna för att anropa "
"tidsfunktionen och lagra resultaten.  Som standard är konstanten 0. Följande "
"procedur kan användas för att få en bättre konstant för en viss plattform "
"(se :ref:`profile-limitations`). ::"

msgid ""
"import profile\n"
"pr = profile.Profile()\n"
"for i in range(5):\n"
"    print(pr.calibrate(10000))"
msgstr ""
"import profile\n"
"pr = profile.Profile()\n"
"for i in range(5):\n"
"    print(pr.calibrate(10000))"

msgid ""
"The method executes the number of Python calls given by the argument, "
"directly and again under the profiler, measuring the time for both. It then "
"computes the hidden overhead per profiler event, and returns that as a "
"float.  For example, on a 1.8Ghz Intel Core i5 running macOS, and using "
"Python's time.process_time() as the timer, the magical number is about "
"4.04e-6."
msgstr ""
"Metoden kör det antal Python-anrop som anges i argumentet, direkt och igen "
"under profileraren, och mäter tiden för båda. Den beräknar sedan den dolda "
"overhead per profileringshändelse och returnerar den som en float.  Till "
"exempel, på en 1,8 GHz Intel Core i5 som kör macOS och använder Pythons time."
"process_time() som timer, är det magiska talet cirka 4,04e-6."

msgid ""
"The object of this exercise is to get a fairly consistent result. If your "
"computer is *very* fast, or your timer function has poor resolution, you "
"might have to pass 100000, or even 1000000, to get consistent results."
msgstr ""
"Syftet med den här övningen är att få ett någorlunda konsekvent resultat. Om "
"din dator är *mycket* snabb, eller om din timerfunktion har dålig "
"upplösning, kan du behöva passera 100000, eller till och med 1000000, för "
"att få konsekventa resultat."

msgid ""
"When you have a consistent answer, there are three ways you can use it::"
msgstr "När du har ett konsekvent svar kan du använda det på tre sätt::"

msgid ""
"import profile\n"
"\n"
"# 1. Apply computed bias to all Profile instances created hereafter.\n"
"profile.Profile.bias = your_computed_bias\n"
"\n"
"# 2. Apply computed bias to a specific Profile instance.\n"
"pr = profile.Profile()\n"
"pr.bias = your_computed_bias\n"
"\n"
"# 3. Specify computed bias in instance constructor.\n"
"pr = profile.Profile(bias=your_computed_bias)"
msgstr ""
"importprofil\n"
"\n"
"# 1. Tillämpa beräknad bias på alla profilinstanser som skapas hädanefter.\n"
"profile.Profile.bias = din_beräknade_bias\n"
"\n"
"# 2. Tillämpa beräknad förspänning på en specifik profilinstans.\n"
"pr = profile.Profile()\n"
"pr.bias = din_beräknade_bias\n"
"\n"
"# 3. Ange beräknad förspänning i instansens konstruktör.\n"
"pr = profile.Profile(bias=din_beräknade_bias)"

msgid ""
"If you have a choice, you are better off choosing a smaller constant, and "
"then your results will \"less often\" show up as negative in profile "
"statistics."
msgstr ""
"Om du har ett val är det bättre att du väljer en mindre konstant, och då "
"kommer dina resultat \"mindre ofta\" att visa sig vara negativa i "
"profilstatistiken."

msgid "Using a custom timer"
msgstr "Använda en anpassad timer"

msgid ""
"If you want to change how current time is determined (for example, to force "
"use of wall-clock time or elapsed process time), pass the timing function "
"you want to the :class:`Profile` class constructor::"
msgstr ""
"Om du vill ändra hur aktuell tid bestäms (t.ex. för att tvinga fram "
"användning av väggklockans tid eller förfluten processtid), skickar du den "
"tidsfunktion du vill ha till :class:`Profile`-klassens konstruktör::"

msgid "pr = profile.Profile(your_time_func)"
msgstr "pr = profil.Profil(din_tid_func)"

msgid ""
"The resulting profiler will then call ``your_time_func``. Depending on "
"whether you are using :class:`profile.Profile` or :class:`cProfile.Profile`, "
"``your_time_func``'s return value will be interpreted differently:"
msgstr ""
"Den resulterande profileraren kommer sedan att anropa ``your_time_func``. "
"Beroende på om du använder :class:`profile.Profile` eller :class:`cProfile."
"Profile`, kommer ``your_time_func``'s returvärde att tolkas på olika sätt:"

msgid ":class:`profile.Profile`"
msgstr ":class:`profile.Profile`"

msgid ""
"``your_time_func`` should return a single number, or a list of numbers whose "
"sum is the current time (like what :func:`os.times` returns).  If the "
"function returns a single time number, or the list of returned numbers has "
"length 2, then you will get an especially fast version of the dispatch "
"routine."
msgstr ""
"``your_time_func`` bör returnera ett enda tal, eller en lista med tal vars "
"summa är den aktuella tiden (som vad :func:`os.times` returnerar).  Om "
"funktionen returnerar ett enda tidsnummer, eller om listan med returnerade "
"nummer har längden 2, får du en särskilt snabb version av sändningsrutinen."

msgid ""
"Be warned that you should calibrate the profiler class for the timer "
"function that you choose (see :ref:`profile-calibration`).  For most "
"machines, a timer that returns a lone integer value will provide the best "
"results in terms of low overhead during profiling.  (:func:`os.times` is "
"*pretty* bad, as it returns a tuple of floating-point values).  If you want "
"to substitute a better timer in the cleanest fashion, derive a class and "
"hardwire a replacement dispatch method that best handles your timer call, "
"along with the appropriate calibration constant."
msgstr ""
"Tänk på att du bör kalibrera profileringsklassen för den timerfunktion du "
"väljer (se :ref:`profile-calibration`).  För de flesta maskiner kommer en "
"timer som returnerar ett ensamt heltalsvärde att ge de bästa resultaten när "
"det gäller låg overhead under profileringen.  (:func:`os.times` är *ganska* "
"dålig, eftersom den returnerar en tupel av flyttalsvärden).  Om du vill byta "
"ut en bättre timer på det renaste sättet, härled en klass och hårdkoppla en "
"ersättande dispatch-metod som bäst hanterar ditt timeranrop, tillsammans med "
"lämplig kalibreringskonstant."

msgid ":class:`cProfile.Profile`"
msgstr ":class:`cProfile.Profile`"

msgid ""
"``your_time_func`` should return a single number.  If it returns integers, "
"you can also invoke the class constructor with a second argument specifying "
"the real duration of one unit of time.  For example, if "
"``your_integer_time_func`` returns times measured in thousands of seconds, "
"you would construct the :class:`Profile` instance as follows::"
msgstr ""
"``your_time_func`` bör returnera ett enda tal.  Om den returnerar heltal kan "
"du också anropa klasskonstruktören med ett andra argument som anger den "
"verkliga varaktigheten för en tidsenhet.  Om till exempel "
"``your_integer_time_func`` returnerar tider som mäts i tusentals sekunder, "
"skulle du konstruera :class:`Profile`-instansen på följande sätt::"

msgid "pr = cProfile.Profile(your_integer_time_func, 0.001)"
msgstr "pr = cProfile.Profile(din_integer_tid_func, 0,001)"

msgid ""
"As the :class:`cProfile.Profile` class cannot be calibrated, custom timer "
"functions should be used with care and should be as fast as possible.  For "
"the best results with a custom timer, it might be necessary to hard-code it "
"in the C source of the internal :mod:`!_lsprof` module."
msgstr ""
"Eftersom klassen :class:`cProfile.Profile` inte kan kalibreras, bör "
"anpassade timerfunktioner användas med försiktighet och vara så snabba som "
"möjligt.  För bästa resultat med en egen timer kan det vara nödvändigt att "
"hårdkoda den i C-källan för den interna :mod:`!_lsprof`-modulen."

msgid ""
"Python 3.3 adds several new functions in :mod:`time` that can be used to "
"make precise measurements of process or wall-clock time. For example, see :"
"func:`time.perf_counter`."
msgstr ""
"Python 3.3 lägger till flera nya funktioner i :mod:`time` som kan användas "
"för att göra exakta mätningar av process- eller väggklocktid. Se till "
"exempel :func:`time.perf_counter`."

msgid "deterministic profiling"
msgstr "deterministisk profilering"

msgid "profiling, deterministic"
msgstr "profilering, deterministisk"
