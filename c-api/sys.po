# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Operating System Utilities"
msgstr "Verktyg för operativsystem"

msgid ""
"Return the file system representation for *path*. If the object is a :class:"
"`str` or :class:`bytes` object, then a new :term:`strong reference` is "
"returned. If the object implements the :class:`os.PathLike` interface, then :"
"meth:`~os.PathLike.__fspath__` is returned as long as it is a :class:`str` "
"or :class:`bytes` object. Otherwise :exc:`TypeError` is raised and ``NULL`` "
"is returned."
msgstr ""
"Returnerar filsystemets representation för *path*. Om objektet är ett :class:"
"`str`- eller :class:`bytes`-objekt returneras en ny :term:`strong "
"reference`. Om objektet implementerar gränssnittet :class:`os.PathLike`, "
"returneras :meth:`~os.PathLike.__fspath__` så länge det är ett :class:`str` "
"eller :class:`bytes` objekt. Annars genereras :exc:`TypeError` och ``NULL`` "
"returneras."

msgid ""
"Return true (nonzero) if the standard I/O file *fp* with name *filename* is "
"deemed interactive.  This is the case for files for which "
"``isatty(fileno(fp))`` is true.  If the :c:member:`PyConfig.interactive` is "
"non-zero, this function also returns true if the *filename* pointer is "
"``NULL`` or if the name is equal to one of the strings ``'<stdin>'`` or "
"``'???'``."
msgstr ""
"Returnerar true (icke-noll) om standard I/O-filen *fp* med namnet *filnamn* "
"anses vara interaktiv.  Detta är fallet för filer för vilka "
"``isatty(fileno(fp))`` är true.  Om :c:member:`PyConfig.interactive` är icke-"
"noll, returnerar denna funktion också true om pekaren *filnamn* är ``NULL`` "
"eller om namnet är lika med en av strängarna ``'<stdin>'`` eller ``'???'``."

msgid "This function must not be called before Python is initialized."
msgstr "Denna funktion får inte anropas innan Python har initialiserats."

msgid ""
"Function to prepare some internal state before a process fork.  This should "
"be called before calling :c:func:`fork` or any similar function that clones "
"the current process. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Funktion för att förbereda ett internt tillstånd före en processgaffel.  "
"Denna funktion bör anropas innan :c:func:`fork` eller någon liknande "
"funktion som klonar den aktuella processen anropas. Endast tillgänglig på "
"system där :c:func:`fork` är definierad."

msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_BeforeFork()``."
msgstr ""
"C :c:func:`fork`-anropet bör endast göras från :ref:`\"main\"-tråden <fork-"
"and-threads>` (av :ref:`\"main\"-tolken <sub-interpreter-support>`).  "
"Detsamma gäller för ``PyOS_BeforeFork()``."

msgid ""
"Function to update some internal state after a process fork.  This should be "
"called from the parent process after calling :c:func:`fork` or any similar "
"function that clones the current process, regardless of whether process "
"cloning was successful. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Funktion för att uppdatera något internt tillstånd efter en processgaffel.  "
"Denna funktion bör anropas från den överordnade processen efter anrop av :c:"
"func:`fork` eller någon liknande funktion som klonar den aktuella processen, "
"oavsett om processkloningen lyckades eller inte. Endast tillgängligt på "
"system där :c:func:`fork` är definierad."

msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Parent()``."
msgstr ""
"C :c:func:`fork`-anropet bör endast göras från :ref:`\"main\"-tråden <fork-"
"and-threads>` (av :ref:`\"main\"-tolken <sub-interpreter-support>`).  "
"Detsamma gäller för ``PyOS_AfterFork_Parent()``."

msgid ""
"Function to update internal interpreter state after a process fork. This "
"must be called from the child process after calling :c:func:`fork`, or any "
"similar function that clones the current process, if there is any chance the "
"process will call back into the Python interpreter. Only available on "
"systems where :c:func:`fork` is defined."
msgstr ""
"Funktion för att uppdatera tolkens interna tillstånd efter en "
"processförgrening. Denna funktion måste anropas från barnprocessen efter "
"anrop av :c:func:`fork`, eller någon liknande funktion som klonar den "
"aktuella processen, om det finns någon risk att processen kommer att anropa "
"Python-tolken igen. Endast tillgängligt på system där :c:func:`fork` är "
"definierad."

msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Child()``."
msgstr ""
"C :c:func:`fork`-anropet bör endast göras från :ref:`\"main\"-tråden <fork-"
"and-threads>` (av :ref:`\"main\"-tolken <sub-interpreter-support>`).  "
"Detsamma gäller för ``PyOS_AfterFork_Child()``."

msgid ""
":func:`os.register_at_fork` allows registering custom Python functions to be "
"called by :c:func:`PyOS_BeforeFork()`, :c:func:`PyOS_AfterFork_Parent` and  :"
"c:func:`PyOS_AfterFork_Child`."
msgstr ""
":func:`os.register_at_fork` tillåter registrering av anpassade Python-"
"funktioner som ska anropas av :c:func:`PyOS_BeforeFork()`, :c:func:"
"`PyOS_AfterFork_Parent` och :c:func:`PyOS_AfterFork_Child`."

msgid ""
"Function to update some internal state after a process fork; this should be "
"called in the new process if the Python interpreter will continue to be "
"used. If a new executable is loaded into the new process, this function does "
"not need to be called."
msgstr ""
"Funktion för att uppdatera vissa interna tillstånd efter en processgaffel; "
"denna bör anropas i den nya processen om Python-tolken kommer att fortsätta "
"att användas. Om en ny körbar fil laddas in i den nya processen behöver "
"denna funktion inte anropas."

msgid "This function is superseded by :c:func:`PyOS_AfterFork_Child()`."
msgstr "Denna funktion ersätts av :c:func:`PyOS_AfterFork_Child()`."

msgid ""
"Return true when the interpreter runs out of stack space.  This is a "
"reliable check, but is only available when :c:macro:`!USE_STACKCHECK` is "
"defined (currently on certain versions of Windows using the Microsoft Visual "
"C++ compiler). :c:macro:`!USE_STACKCHECK` will be defined automatically; you "
"should never change the definition in your own code."
msgstr ""
"Returnerar true när tolken har slut på stackutrymme.  Detta är en "
"tillförlitlig kontroll, men är endast tillgänglig när :c:macro:`!"
"USE_STACKCHECK` är definierad (för närvarande på vissa versioner av Windows "
"som använder Microsoft Visual C++-kompilatorn). :c:macro:`!USE_STACKCHECK` "
"definieras automatiskt; du bör aldrig ändra definitionen i din egen kod."

msgid ""
"Return the current signal handler for signal *i*.  This is a thin wrapper "
"around either :c:func:`!sigaction` or :c:func:`!signal`.  Do not call those "
"functions directly!"
msgstr ""
"Returnerar den aktuella signalhanteraren för signal *i*.  Detta är ett tunt "
"omslag runt antingen :c:func:`!sigaction` eller :c:func:`!signal`.  Anropa "
"inte dessa funktioner direkt!"

msgid ""
"Set the signal handler for signal *i* to be *h*; return the old signal "
"handler. This is a thin wrapper around either :c:func:`!sigaction` or :c:"
"func:`!signal`.  Do not call those functions directly!"
msgstr ""
"Ställ in signalhanteraren för signal *i* till att vara *h*; returnera den "
"gamla signalhanteraren. Detta är ett tunt omslag runt antingen :c:func:`!"
"sigaction` eller :c:func:`!signal`.  Anropa inte dessa funktioner direkt!"

msgid ""
"This function should not be called directly: use the :c:type:`PyConfig` API "
"with the :c:func:`PyConfig_SetBytesString` function which ensures that :ref:"
"`Python is preinitialized <c-preinit>`."
msgstr ""
"Denna funktion bör inte anropas direkt: använd :c:type:`PyConfig` API med :c:"
"func:`PyConfig_SetBytesString` funktionen som säkerställer att :ref:`Python "
"är förinitialiserat <c-preinit>`."

msgid ""
"This function must not be called before :ref:`Python is preinitialized <c-"
"preinit>` and so that the LC_CTYPE locale is properly configured: see the :c:"
"func:`Py_PreInitialize` function."
msgstr ""
"Denna funktion får inte anropas innan :ref:`Python är förinitialiserat <c-"
"preinit>` och så att LC_CTYPE locale är korrekt konfigurerad: se :c:func:"
"`Py_PreInitialize` funktionen."

msgid ""
"Decode a byte string from the :term:`filesystem encoding and error handler`. "
"If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, undecodable bytes are decoded as characters in range "
"U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate "
"character, the bytes are escaped using the surrogateescape error handler "
"instead of decoding them."
msgstr ""
"Avkodar en byte-sträng från :term:`filsystemkodning och felhanterare`. Om "
"felhanteraren är :ref:`surrogateescape error handler <surrogateescape>`, "
"avkodas oavkodbara byte som tecken i intervallet U+DC80..U+DCFF; och om en "
"byte-sekvens kan avkodas som ett surrogattecken, escapas byte-sekvensen med "
"hjälp av felhanteraren surrogateescape istället för att avkodas."

msgid ""
"Return a pointer to a newly allocated wide character string, use :c:func:"
"`PyMem_RawFree` to free the memory. If size is not ``NULL``, write the "
"number of wide characters excluding the null character into ``*size``"
msgstr ""
"Returnerar en pekare till en nyligen allokerad bred teckensträng, använd :c:"
"func:`PyMem_RawFree` för att frigöra minnet. Om size inte är ``NULL``, skriv "
"antalet breda tecken exklusive nulltecknet till ``*size``"

msgid ""
"Return ``NULL`` on decoding error or memory allocation error. If *size* is "
"not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or set to "
"``(size_t)-2`` on decoding error."
msgstr ""
"Returnerar ``NULL`` vid avkodningsfel eller minnesallokeringsfel. Om *size* "
"inte är ``NULL``, sätts ``*size`` till ``(size_t)-1`` vid minnesfel eller "
"sätts till ``(size_t)-2`` vid avkodningsfel."

msgid ""
"The :term:`filesystem encoding and error handler` are selected by :c:func:"
"`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and :c:member:"
"`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
"Termen :`filsystem encoding and error handler` väljs av :c:func:"
"`PyConfig_Read`: se :c:member:`~PyConfig.filesystem_encoding` och :c:member:"
"`~PyConfig.filesystem_errors` medlemmar av :c:type:`PyConfig`."

msgid ""
"Decoding errors should never happen, unless there is a bug in the C library."
msgstr ""
"Avkodningsfel ska aldrig inträffa, såvida det inte finns en bugg i C-"
"biblioteket."

msgid ""
"Use the :c:func:`Py_EncodeLocale` function to encode the character string "
"back to a byte string."
msgstr ""
"Använd funktionen :c:func:`Py_EncodeLocale` för att koda tillbaka "
"teckensträngen till en byte-sträng."

msgid ""
"The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and :c:func:"
"`PyUnicode_DecodeLocaleAndSize` functions."
msgstr ""
"Funktionerna :c:func:`PyUnicode_DecodeFSDefaultAndSize` och :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."

msgid ""
"The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode "
"<utf8-mode>`."
msgstr ""
"Funktionen använder nu UTF-8-kodningen i :ref:`Python UTF-8 Mode <utf8-"
"mode>`."

msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:member:"
"`PyPreConfig.legacy_windows_fs_encoding` is zero;"
msgstr ""
"Funktionen använder nu UTF-8-kodning i Windows om :c:member:`PyPreConfig."
"legacy_windows_fs_encoding` är noll;"

msgid ""
"Encode a wide character string to the :term:`filesystem encoding and error "
"handler`. If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, surrogate characters in the range U+DC80..U+DCFF are "
"converted to bytes 0x80..0xFF."
msgstr ""
"Kodar en bred teckensträng till :term:`filsystemkodning och felhanterare`. "
"Om felhanteraren är :ref:`surrogateescape error handler <surrogateescape>`, "
"konverteras surrogattecken i intervallet U+DC80..U+DCFF till byte 0x80..0xFF."

msgid ""
"Return a pointer to a newly allocated byte string, use :c:func:`PyMem_Free` "
"to free the memory. Return ``NULL`` on encoding error or memory allocation "
"error."
msgstr ""
"Returnerar en pekare till en nyligen allokerad byte-sträng, använd :c:func:"
"`PyMem_Free` för att frigöra minnet. Returnerar ``NULL`` vid felkodning "
"eller fel i minnesallokering."

msgid ""
"If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on "
"success,  or set to the index of the invalid character on encoding error."
msgstr ""
"Om error_pos inte är ``NULL``, sätts ``*error_pos`` till ``(size_t)-1`` vid "
"framgång, eller till indexet för det ogiltiga tecknet vid kodningsfel."

msgid ""
"Use the :c:func:`Py_DecodeLocale` function to decode the bytes string back "
"to a wide character string."
msgstr ""
"Använd funktionen :c:func:`Py_DecodeLocale` för att avkoda bytessträngen "
"tillbaka till en bred teckensträng."

msgid ""
"The :c:func:`PyUnicode_EncodeFSDefault` and :c:func:`PyUnicode_EncodeLocale` "
"functions."
msgstr ""
"Funktionerna :c:func:`PyUnicode_EncodeFSDefault` och :c:func:"
"`PyUnicode_EncodeLocale`."

msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:member:"
"`PyPreConfig.legacy_windows_fs_encoding` is zero."
msgstr ""
"Funktionen använder nu UTF-8-kodning i Windows om :c:member:`PyPreConfig."
"legacy_windows_fs_encoding` är noll."

msgid ""
"Similar to :c:func:`!fopen`, but *path* is a Python object and an exception "
"is set on error."
msgstr ""
"Liknar :c:func:`!fopen`, men *path* är ett Python-objekt och ett undantag "
"sätts vid fel."

msgid ""
"*path* must be a :class:`str` object, a :class:`bytes` object, or a :term:"
"`path-like object`."
msgstr ""
"*path* måste vara ett :class:`str`-objekt, ett :class:`bytes`-objekt eller "
"ett :term:`path-like object`."

msgid ""
"On success, return the new file pointer. On error, set an exception and "
"return ``NULL``."
msgstr ""
"Vid framgång returneras den nya filpekaren. Vid fel, sätt ett undantag och "
"returnera ``NULL``."

msgid ""
"The file must be closed by :c:func:`Py_fclose` rather than calling directly :"
"c:func:`!fclose`."
msgstr ""
"Filen måste stängas med :c:func:`Py_fclose` istället för att direkt anropa :"
"c:func:`!fclose`."

msgid "The file descriptor is created non-inheritable (:pep:`446`)."
msgstr "Filbeskrivaren skapas icke-ärftlig (:pep:`446`)."

msgid "The caller must have an :term:`attached thread state`."
msgstr "Den som anropar måste ha en :term:`attached thread state`."

msgid "Close a file that was opened by :c:func:`Py_fopen`."
msgstr "Stäng en fil som öppnades av :c:func:`Py_fopen`."

msgid ""
"On success, return ``0``. On error, return ``EOF`` and ``errno`` is set to "
"indicate the error. In either case, any further access (including another "
"call to :c:func:`Py_fclose`) to the stream results in undefined behavior."
msgstr ""
"Vid framgång returneras ``0``. Vid fel returneras ``EOF`` och ``errno`` "
"sätts för att indikera felet. I båda fallen resulterar all ytterligare "
"åtkomst (inklusive ett annat anrop till :c:func:`Py_fclose`) till strömmen i "
"ett odefinierat beteende."

msgid "System Functions"
msgstr "Systemfunktioner"

msgid ""
"These are utility functions that make functionality from the :mod:`sys` "
"module accessible to C code.  They all work with the current interpreter "
"thread's :mod:`sys` module's dict, which is contained in the internal thread "
"state structure."
msgstr ""
"Dessa är verktygsfunktioner som gör funktionalitet från :mod:`sys`-modulen "
"tillgänglig för C-kod.  De arbetar alla med den aktuella tolktrådens :mod:"
"`sys`-modulens dict, som finns i den interna trådtillståndsstrukturen."

msgid ""
"Return the object *name* from the :mod:`sys` module or ``NULL`` if it does "
"not exist, without setting an exception."
msgstr ""
"Returnerar objektet *namn* från modulen :mod:`sys` eller ``NULL`` om det "
"inte finns, utan att ange ett undantag."

msgid ""
"Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in which "
"case *name* is deleted from the sys module. Returns ``0`` on success, ``-1`` "
"on error."
msgstr ""
"Sätter *namn* i modulen :mod:`sys` till *v* såvida inte *v* är ``NULL``, i "
"vilket fall *namn* tas bort från sys-modulen. Returnerar ``0`` vid framgång, "
"``-1`` vid fel."

msgid ""
"Reset :data:`sys.warnoptions` to an empty list. This function may be called "
"prior to :c:func:`Py_Initialize`."
msgstr ""
"Återställer :data:`sys.warnoptions` till en tom lista. Denna funktion kan "
"anropas före :c:func:`Py_Initialize`."

msgid "Clear :data:`sys.warnoptions` and :data:`!warnings.filters` instead."
msgstr "Rensa :data:`sys.warnoptions` och :data:`!warnings.filters` istället."

msgid ""
"Write the output string described by *format* to :data:`sys.stdout`.  No "
"exceptions are raised, even if truncation occurs (see below)."
msgstr ""
"Skriv ut utdatasträngen som beskrivs av *format* till :data:`sys.stdout`.  "
"Inga undantag görs, även om trunkering sker (se nedan)."

msgid ""
"*format* should limit the total size of the formatted output string to 1000 "
"bytes or less -- after 1000 bytes, the output string is truncated. In "
"particular, this means that no unrestricted \"%s\" formats should occur; "
"these should be limited using \"%.<N>s\" where <N> is a decimal number "
"calculated so that <N> plus the maximum size of other formatted text does "
"not exceed 1000 bytes.  Also watch out for \"%f\", which can print hundreds "
"of digits for very large numbers."
msgstr ""
"*format* bör begränsa den totala storleken på den formaterade utdatasträngen "
"till 1000 byte eller mindre - efter 1000 byte trunkeras utdatasträngen. "
"Detta innebär i synnerhet att inga obegränsade \"%s\" format får förekomma; "
"dessa bör begränsas med hjälp av \"%.<N>s\" där <N> är ett decimaltal som "
"beräknas så att <N> plus den maximala storleken på annan formaterad text "
"inte överstiger 1000 byte.  Se också upp för \"%f\", som kan skriva ut "
"hundratals siffror för mycket stora tal."

msgid ""
"If a problem occurs, or :data:`sys.stdout` is unset, the formatted message "
"is written to the real (C level) *stdout*."
msgstr ""
"Om ett problem uppstår, eller om :data:`sys.stdout` inte är inställd, skrivs "
"det formaterade meddelandet till den riktiga (C-nivå) *stdout*."

msgid ""
"As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Som :c:func:`PySys_WriteStdout`, men skriv till :data:`sys.stderr` eller "
"*stderr* istället."

msgid ""
"Function similar to PySys_WriteStdout() but format the message using :c:func:"
"`PyUnicode_FromFormatV` and don't truncate the message to an arbitrary "
"length."
msgstr ""
"Funktion som liknar PySys_WriteStdout() men formaterar meddelandet med :c:"
"func:`PyUnicode_FromFormatV` och trunkerar inte meddelandet till godtycklig "
"längd."

msgid ""
"As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Som :c:func:`PySys_FormatStdout`, men skriv till :data:`sys.stderr` eller "
"*stderr* istället."

msgid ""
"Return the current dictionary of :option:`-X` options, similarly to :data:"
"`sys._xoptions`.  On error, ``NULL`` is returned and an exception is set."
msgstr ""
"Returnerar den aktuella ordlistan med :option:`-X`-alternativ, på samma sätt "
"som :data:`sys._xoptions`.  Vid fel returneras ``NULL`` och ett undantag "
"anges."

msgid ""
"Raise an auditing event with any active hooks. Return zero for success and "
"non-zero with an exception set on failure."
msgstr ""
"Starta en granskningshändelse med alla aktiva krokar. Returnerar noll vid "
"framgång och icke-noll med en undantagsuppsättning vid misslyckande."

msgid "The *event* string argument must not be *NULL*."
msgstr "Strängargumentet *event* får inte vara *NULL*."

msgid ""
"If any hooks have been added, *format* and other arguments will be used to "
"construct a tuple to pass. Apart from ``N``, the same format characters as "
"used in :c:func:`Py_BuildValue` are available. If the built value is not a "
"tuple, it will be added into a single-element tuple."
msgstr ""
"Om några krokar har lagts till kommer *format* och andra argument att "
"användas för att konstruera en tupel att skicka. Förutom ``N`` finns samma "
"formattecken tillgängliga som används i :c:func:`Py_BuildValue`. Om det "
"byggda värdet inte är en tupel, kommer det att läggas till i en tupel med "
"ett element."

msgid ""
"The ``N`` format option must not be used. It consumes a reference, but since "
"there is no way to know whether arguments to this function will be consumed, "
"using it may cause reference leaks."
msgstr ""
"Formatalternativet ``N`` får inte användas. Det förbrukar en referens, men "
"eftersom det inte finns något sätt att veta om argument till den här "
"funktionen kommer att förbrukas, kan det orsaka referensläckage om det "
"används."

msgid ""
"Note that ``#`` format characters should always be treated as :c:type:"
"`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was defined."
msgstr ""
"Observera att formattecknen ``#`` alltid skall behandlas som :c:type:"
"`Py_ssize_t`, oavsett om ``PY_SSIZE_T_CLEAN`` definierats."

msgid ":func:`sys.audit` performs the same function from Python code."
msgstr ":func:`sys.audit` utför samma funktion från Python-kod."

msgid "See also :c:func:`PySys_AuditTuple`."
msgstr "Se även :c:func:`PySys_AuditTuple`."

msgid ""
"Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an "
"unavoidable deprecation warning was raised."
msgstr ""
"Kräver :c:type:`Py_ssize_t` för ``#`` formattecken. Tidigare gavs en "
"oundviklig deprecation-varning."

msgid ""
"Similar to :c:func:`PySys_Audit`, but pass arguments as a Python object. "
"*args* must be a :class:`tuple`. To pass no arguments, *args* can be *NULL*."
msgstr ""
"Liknar :c:func:`PySys_Audit`, men skickar argument som ett Python-objekt. "
"*args* måste vara en :class:`tuple`. För att inte skicka några argument kan "
"*args* vara *NULL*."

msgid ""
"Append the callable *hook* to the list of active auditing hooks. Return zero "
"on success and non-zero on failure. If the runtime has been initialized, "
"also set an error on failure. Hooks added through this API are called for "
"all interpreters created by the runtime."
msgstr ""
"Lägger till den anropsbara *hook* till listan över aktiva revisionskrokar. "
"Returnerar noll vid framgång och icke-noll vid misslyckande. Om körtiden har "
"initialiserats, ange även ett fel vid misslyckande. Krokar som läggs till "
"via detta API anropas för alla tolkar som skapas av körtiden."

msgid ""
"The *userData* pointer is passed into the hook function. Since hook "
"functions may be called from different runtimes, this pointer should not "
"refer directly to Python state."
msgstr ""
"Pekaren *userData* skickas till hook-funktionen. Eftersom hook-funktioner "
"kan anropas från olika runtimes bör denna pekare inte referera direkt till "
"Python-tillstånd."

msgid ""
"This function is safe to call before :c:func:`Py_Initialize`. When called "
"after runtime initialization, existing audit hooks are notified and may "
"silently abort the operation by raising an error subclassed from :class:"
"`Exception` (other errors will not be silenced)."
msgstr ""
"Denna funktion är säker att anropa före :c:func:`Py_Initialize`. När den "
"anropas efter initialisering under körtid, meddelas befintliga "
"revisionskrokar och kan tyst avbryta operationen genom att skapa ett fel som "
"är underklassat från :class:`Exception` (andra fel tystas inte)."

msgid ""
"The hook function is always called with an :term:`attached thread state` by "
"the Python interpreter that raised the event."
msgstr ""
"Hook-funktionen anropas alltid med en :term:`attached thread state` av den "
"Python-tolk som utlöste händelsen."

msgid ""
"See :pep:`578` for a detailed description of auditing.  Functions in the "
"runtime and standard library that raise events are listed in the :ref:`audit "
"events table <audit-events>`. Details are in each function's documentation."
msgstr ""
"Se :pep:`578` för en detaljerad beskrivning av auditering.  Funktioner i "
"runtime och standardbiblioteket som skapar händelser listas i :ref:``audit "
"events table <audit-events>``. Detaljer finns i dokumentationen för varje "
"funktion."

msgid ""
"If the interpreter is initialized, this function raises an auditing event "
"``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`Exception`, the new hook will not be added "
"and the exception is cleared. As a result, callers cannot assume that their "
"hook has been added unless they control all existing hooks."
msgstr ""
"Om tolken initieras, skapar den här funktionen en granskningshändelse ``sys."
"addaudithook`` utan argument. Om någon befintlig krok ger upphov till ett "
"undantag som härrör från :class:`Exception`, kommer den nya kroken inte att "
"läggas till och undantaget rensas. Följaktligen kan anropare inte anta att "
"deras krok har lagts till om de inte kontrollerar alla befintliga krokar."

msgid ""
"The type of the hook function. *event* is the C string event argument passed "
"to :c:func:`PySys_Audit` or :c:func:`PySys_AuditTuple`. *args* is guaranteed "
"to be a :c:type:`PyTupleObject`. *userData* is the argument passed to "
"PySys_AddAuditHook()."
msgstr ""
"Typ av krokfunktion. *event* är C-strängens händelseargument som skickas "
"till :c:func:`PySys_Audit` eller :c:func:`PySys_AuditTuple`. *args* är "
"garanterat ett :c:type:`PyTupleObject`. *userData* är argumentet som skickas "
"till PySys_AddAuditHook()."

msgid "Process Control"
msgstr "Processtyrning"

msgid ""
"Print a fatal error message and kill the process.  No cleanup is performed. "
"This function should only be invoked when a condition is detected that would "
"make it dangerous to continue using the Python interpreter; e.g., when the "
"object administration appears to be corrupted.  On Unix, the standard C "
"library function :c:func:`!abort` is called which will attempt to produce a :"
"file:`core` file."
msgstr ""
"Skriv ut ett fatalt felmeddelande och avsluta processen.  Ingen upprensning "
"utförs. Denna funktion bör endast anropas när ett tillstånd upptäcks som "
"skulle göra det farligt att fortsätta använda Python-tolken, t.ex. när "
"objektadministrationen verkar vara skadad.  På Unix anropas standard C-"
"biblioteksfunktionen :c:func:`!abort` som kommer att försöka producera en :"
"file:`core`-fil."

msgid ""
"The ``Py_FatalError()`` function is replaced with a macro which logs "
"automatically the name of the current function, unless the "
"``Py_LIMITED_API`` macro is defined."
msgstr ""
"Funktionen ``Py_FatalError()`` ersätts med ett makro som automatiskt loggar "
"namnet på den aktuella funktionen, såvida inte makrot ``Py_LIMITED_API`` är "
"definierat."

msgid "Log the function name automatically."
msgstr "Loggar funktionsnamnet automatiskt."

msgid ""
"Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then calls "
"the standard C library function ``exit(status)``.  If :c:func:"
"`Py_FinalizeEx` indicates an error, the exit status is set to 120."
msgstr ""
"Avsluta den aktuella processen.  Detta anropar :c:func:`Py_FinalizeEx` och "
"anropar sedan standard C-biblioteksfunktionen ``exit(status)``.  Om :c:func:"
"`Py_FinalizeEx` indikerar ett fel, sätts utgångsstatusen till 120."

msgid "Errors from finalization no longer ignored."
msgstr "Fel från slutförande ignoreras inte längre."

msgid ""
"Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The "
"cleanup function will be called with no arguments and should return no "
"value.  At most 32 cleanup functions can be registered.  When the "
"registration is successful, :c:func:`Py_AtExit` returns ``0``; on failure, "
"it returns ``-1``.  The cleanup function registered last is called first. "
"Each cleanup function will be called at most once.  Since Python's internal "
"finalization will have completed before the cleanup function, no Python APIs "
"should be called by *func*."
msgstr ""
"Registrera en rensningsfunktion som ska anropas av :c:func:`Py_FinalizeEx`.  "
"Rensningsfunktionen kommer att anropas utan argument och bör inte returnera "
"något värde.  Högst 32 rensningsfunktioner kan registreras.  När "
"registreringen lyckas returnerar :c:func:`Py_AtExit` ``0``; om den "
"misslyckas returnerar den ``-1``.  Den rensningsfunktion som registrerades "
"sist anropas först. Varje rensningsfunktion kommer att anropas högst en "
"gång.  Eftersom Pythons interna avslutning kommer att ha slutförts före "
"rensningsfunktionen, bör inga Python API:er anropas av *func*."

msgid ":c:func:`PyUnstable_AtExit` for passing a ``void *data`` argument."
msgstr ""
":c:func:`PyUnstable_AtExit` för att skicka ett ``void *data`` argument."

msgid "USE_STACKCHECK (C macro)"
msgstr "USE_STACKCHECK (C-makro)"

msgid "abort (C function)"
msgstr "abort (C-funktion)"

msgid "Py_FinalizeEx (C function)"
msgstr "Py_FinalizeEx (C-funktion)"

msgid "exit (C function)"
msgstr "exit (C-funktion)"

msgid "cleanup functions"
msgstr "uppstädningsfunktioner"
