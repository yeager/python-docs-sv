# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!http.client` --- HTTP protocol client"
msgstr ":mod:`!http.client` --- Klient för HTTP-protokoll"

msgid "**Source code:** :source:`Lib/http/client.py`"
msgstr "**Källkod:** :source:`Lib/http/client.py`"

msgid ""
"This module defines classes that implement the client side of the HTTP and "
"HTTPS protocols.  It is normally not used directly --- the module :mod:"
"`urllib.request` uses it to handle URLs that use HTTP and HTTPS."
msgstr ""
"Den här modulen definierar klasser som implementerar klientsidan av HTTP- "
"och HTTPS-protokollen.  Den används normalt inte direkt --- modulen :mod:"
"`urllib.request` använder den för att hantera webbadresser som använder HTTP "
"och HTTPS."

msgid ""
"The `Requests package <https://requests.readthedocs.io/en/latest/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"Paketet `Requests <https://requests.readthedocs.io/en/latest/>`_ "
"rekommenderas för ett HTTP-klientgränssnitt på högre nivå."

msgid ""
"HTTPS support is only available if Python was compiled with SSL support "
"(through the :mod:`ssl` module)."
msgstr ""
"HTTPS-stöd är endast tillgängligt om Python kompilerades med SSL-stöd (genom "
"modulen :mod:`ssl`)."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid "The module provides the following classes:"
msgstr "Modulen innehåller följande klasser:"

msgid ""
"An :class:`HTTPConnection` instance represents one transaction with an HTTP "
"server.  It should be instantiated by passing it a host and optional port "
"number.  If no port number is passed, the port is extracted from the host "
"string if it has the form ``host:port``, else the default HTTP port (80) is "
"used.  If the optional *timeout* parameter is given, blocking operations "
"(like connection attempts) will timeout after that many seconds (if it is "
"not given, the global default timeout setting is used). The optional "
"*source_address* parameter may be a tuple of a (host, port) to use as the "
"source address the HTTP connection is made from. The optional *blocksize* "
"parameter sets the buffer size in bytes for sending a file-like message body."
msgstr ""
"En :class:`HTTPConnection`-instans representerar en transaktion med en HTTP-"
"server.  Den bör instansieras genom att den får en värd och ett valfritt "
"portnummer.  Om inget portnummer anges extraheras porten från värdsträngen "
"om den har formen ``host:port``, annars används HTTP-standardporten (80).  "
"Om den valfria parametern *timeout* anges kommer blockerande operationer "
"(som anslutningsförsök) att timeoutas efter det antalet sekunder (om den "
"inte anges används den globala standardinställningen för timeout). Den "
"valfria parametern *source_address* kan vara en tupel av en (host, port) som "
"ska användas som källadress för HTTP-anslutningen. Den valfria parametern "
"*blocksize* anger buffertstorleken i byte för att skicka en filliknande "
"meddelandekropp."

msgid ""
"For example, the following calls all create instances that connect to the "
"server at the same host and port::"
msgstr ""
"Följande anrop skapar t.ex. alla instanser som ansluter till servern på "
"samma värd och port::"

msgid ""
">>> h1 = http.client.HTTPConnection('www.python.org')\n"
">>> h2 = http.client.HTTPConnection('www.python.org:80')\n"
">>> h3 = http.client.HTTPConnection('www.python.org', 80)\n"
">>> h4 = http.client.HTTPConnection('www.python.org', 80, timeout=10)"
msgstr ""
">>> h1 = http.client.HTTPConnection('www.python.org')\n"
">>> h2 = http.client.HTTPConnection('www.python.org:80')\n"
">>> h3 = http.client.HTTPConnection('www.python.org', 80)\n"
">>> h4 = http.client.HTTPConnection('www.python.org', 80, timeout=10)"

msgid "*source_address* was added."
msgstr "*source_address* har lagts till."

msgid ""
"The  *strict* parameter was removed. HTTP 0.9-style \"Simple Responses\" are "
"no longer supported."
msgstr ""
"Parametern *strict* har tagits bort. HTTP 0.9-stil \"Simple Responses\" "
"stöds inte längre."

msgid "*blocksize* parameter was added."
msgstr "*blocksize*-parametern har lagts till."

msgid ""
"A subclass of :class:`HTTPConnection` that uses SSL for communication with "
"secure servers.  Default port is ``443``.  If *context* is specified, it "
"must be a :class:`ssl.SSLContext` instance describing the various SSL "
"options."
msgstr ""
"En underklass till :class:`HTTPConnection` som använder SSL för "
"kommunikation med säkra servrar.  Standardporten är ``443``.  Om *context* "
"anges måste det vara en instans av :class:`ssl.SSLContext` som beskriver de "
"olika SSL-alternativen."

msgid "Please read :ref:`ssl-security` for more information on best practices."
msgstr "Läs :ref:`ssl-security` för mer information om bästa praxis."

msgid "*source_address*, *context* and *check_hostname* were added."
msgstr "*source_address*, *context* och *check_hostname* har lagts till."

msgid ""
"This class now supports HTTPS virtual hosts if possible (that is, if :const:"
"`ssl.HAS_SNI` is true)."
msgstr ""
"Den här klassen stöder nu virtuella HTTPS-värdar om möjligt (dvs. om :const:"
"`ssl.HAS_SNI` är true)."

msgid ""
"The *strict* parameter was removed. HTTP 0.9-style \"Simple Responses\" are "
"no longer supported."
msgstr ""
"Parametern *strict* har tagits bort. HTTP 0.9-stil \"Simple Responses\" "
"stöds inte längre."

msgid ""
"This class now performs all the necessary certificate and hostname checks by "
"default. To revert to the previous, unverified, behavior :func:`!ssl."
"_create_unverified_context` can be passed to the *context* parameter."
msgstr ""
"Den här klassen utför nu alla nödvändiga certifikat- och värdnamnskontroller "
"som standard. För att återgå till det tidigare, overifierade, beteendet kan :"
"func:`!ssl._create_unverified_context` skickas till parametern *context*."

msgid ""
"This class now enables TLS 1.3 :attr:`ssl.SSLContext.post_handshake_auth` "
"for the default *context* or when *cert_file* is passed with a custom "
"*context*."
msgstr ""
"Den här klassen aktiverar nu TLS 1.3 :attr:`ssl.SSLContext."
"post_handshake_auth` för standard *kontext* eller när *cert_file* skickas "
"med en anpassad *kontext*."

msgid ""
"This class now sends an ALPN extension with protocol indicator ``http/1.1`` "
"when no *context* is given. Custom *context* should set ALPN protocols with :"
"meth:`~ssl.SSLContext.set_alpn_protocols`."
msgstr ""
"Denna klass skickar nu ett ALPN-tillägg med protokollindikatorn ``http/1.1`` "
"när ingen *kontext* ges. Anpassad *kontext* bör ställa in ALPN-protokoll "
"med :meth:`~ssl.SSLContext.set_alpn_protocols`."

msgid ""
"The deprecated *key_file*, *cert_file* and *check_hostname* parameters have "
"been removed."
msgstr ""
"De föråldrade parametrarna *key_file*, *cert_file* och *check_hostname* har "
"tagits bort."

msgid ""
"Class whose instances are returned upon successful connection.  Not "
"instantiated directly by user."
msgstr ""
"Klass vars instanser returneras vid lyckad anslutning.  Instansieras inte "
"direkt av användaren."

msgid ""
"The *strict* parameter was removed. HTTP 0.9 style \"Simple Responses\" are "
"no longer supported."
msgstr ""
"Parametern *strict* har tagits bort. HTTP 0.9-stil \"Simple Responses\" "
"stöds inte längre."

msgid "This module provides the following function:"
msgstr "Denna modul har följande funktioner:"

msgid ""
"Parse the headers from a file pointer *fp* representing a HTTP request/"
"response. The file has to be a :class:`~io.BufferedIOBase` reader (i.e. not "
"text) and must provide a valid :rfc:`2822` style header."
msgstr ""
"Analysera rubrikerna från en filpekare *fp* som representerar en HTTP-"
"begäran/-svar. Filen måste vara en :class:`~io.BufferedIOBase`-läsare (dvs. "
"inte text) och måste tillhandahålla en giltig :rfc:`2822`-stilrubrik."

msgid ""
"This function returns an instance of :class:`http.client.HTTPMessage` that "
"holds the header fields, but no payload (the same as :attr:`HTTPResponse."
"msg` and :attr:`http.server.BaseHTTPRequestHandler.headers`). After "
"returning, the file pointer *fp* is ready to read the HTTP body."
msgstr ""
"Denna funktion returnerar en instans av :class:`http.client.HTTPMessage` som "
"innehåller rubrikfälten, men ingen nyttolast (samma som :attr:`HTTPResponse."
"msg` och :attr:`http.server.BaseHTTPRequestHandler.headers`). Efter att ha "
"återvänt är filpekaren *fp* redo att läsa HTTP-kroppen."

msgid ""
":meth:`parse_headers` does not parse the start-line of a HTTP message; it "
"only parses the ``Name: value`` lines. The file has to be ready to read "
"these field lines, so the first line should already be consumed before "
"calling the function."
msgstr ""
":meth:`parse_headers` analyserar inte startraden i ett HTTP-meddelande; den "
"analyserar endast raderna ``Name: value``. Filen måste vara redo att läsa "
"dessa fältrader, så den första raden bör redan ha använts innan funktionen "
"anropas."

msgid "The following exceptions are raised as appropriate:"
msgstr "Följande undantag tas upp i tillämpliga fall:"

msgid ""
"The base class of the other exceptions in this module.  It is a subclass of :"
"exc:`Exception`."
msgstr ""
"Basklassen för de andra undantagen i denna modul.  Den är en underklass "
"till :exc:`Exception`."

msgid "A subclass of :exc:`HTTPException`."
msgstr "En underklass till :exc:`HTTPException`."

msgid ""
"A subclass of :exc:`HTTPException`, raised if a port is given and is either "
"non-numeric or empty."
msgstr ""
"En underklass till :exc:`HTTPException`, som uppstår om en port anges och "
"den antingen är icke-numerisk eller tom."

msgid "A subclass of :exc:`ImproperConnectionState`."
msgstr "En underklass av :exc:`ImproperConnectionState`."

msgid ""
"A subclass of :exc:`HTTPException`.  Raised if a server responds with a HTTP "
"status code that we don't understand."
msgstr ""
"En underklass till :exc:`HTTPException`.  Uppstår om en server svarar med en "
"HTTP-statuskod som vi inte förstår."

msgid ""
"A subclass of :exc:`HTTPException`.  Raised if an excessively long line is "
"received in the HTTP protocol from the server."
msgstr ""
"En underklass till :exc:`HTTPException`.  Utlöses om en alltför lång rad tas "
"emot i HTTP-protokollet från servern."

msgid ""
"A subclass of :exc:`ConnectionResetError` and :exc:`BadStatusLine`.  Raised "
"by :meth:`HTTPConnection.getresponse` when the attempt to read the response "
"results in no data read from the connection, indicating that the remote end "
"has closed the connection."
msgstr ""
"En underklass till :exc:`ConnectionResetError` och :exc:`BadStatusLine`.  "
"Utlöses av :meth:`HTTPConnection.getresponse` när försöket att läsa svaret "
"resulterar i att inga data läses från anslutningen, vilket indikerar att "
"fjärranslutningen har stängt anslutningen."

msgid "Previously, :exc:`BadStatusLine`\\ ``('')`` was raised."
msgstr "Tidigare skapades :exc:`BadStatusLine````('')``."

msgid "The constants defined in this module are:"
msgstr "De konstanter som definieras i denna modul är:"

msgid "The default port for the HTTP protocol (always ``80``)."
msgstr "Standardporten för HTTP-protokollet (alltid ``80``)."

msgid "The default port for the HTTPS protocol (always ``443``)."
msgstr "Standardporten för HTTPS-protokollet (alltid ``443``)."

msgid "This dictionary maps the HTTP 1.1 status codes to the W3C names."
msgstr "Denna ordbok mappar HTTP 1.1-statuskoderna till W3C-namnen."

msgid ""
"Example: ``http.client.responses[http.client.NOT_FOUND]`` is ``'Not Found'``."
msgstr ""
"Exempel: ``http.client.responses[http.client.NOT_FOUND]`` är ``\"Not "
"Found\"``."

msgid ""
"See :ref:`http-status-codes` for a list of HTTP status codes that are "
"available in this module as constants."
msgstr ""
"Se :ref:`http-status-codes` för en lista över HTTP-statuskoder som finns "
"tillgängliga i den här modulen som konstanter."

msgid "HTTPConnection Objects"
msgstr "HTTPC-anslutningsobjekt"

msgid ":class:`HTTPConnection` instances have the following methods:"
msgstr ":class:`HTTPConnection`-instanser har följande metoder:"

msgid ""
"This will send a request to the server using the HTTP request method "
"*method* and the request URI *url*. The provided *url* must be an absolute "
"path to conform with :rfc:`RFC 2616 §5.1.2 <2616#section-5.1.2>` (unless "
"connecting to an HTTP proxy server or using the ``OPTIONS`` or ``CONNECT`` "
"methods)."
msgstr ""
"Detta skickar en begäran till servern med HTTP-begärandemetoden *method* och "
"begärans URI *url*. Den angivna *url* måste vara en absolut sökväg för att "
"överensstämma med :rfc:`RFC 2616 §5.1.2 <2616#section-5.1.2>` (om du inte "
"ansluter till en HTTP-proxyserver eller använder metoderna ``OPTIONS`` eller "
"``CONNECT``)."

msgid ""
"If *body* is specified, the specified data is sent after the headers are "
"finished.  It may be a :class:`str`, a :term:`bytes-like object`, an open :"
"term:`file object`, or an iterable of :class:`bytes`.  If *body* is a "
"string, it is encoded as ISO-8859-1, the default for HTTP.  If it is a bytes-"
"like object, the bytes are sent as is.  If it is a :term:`file object`, the "
"contents of the file is sent; this file object should support at least the "
"``read()`` method.  If the file object is an instance of :class:`io."
"TextIOBase`, the data returned by the ``read()`` method will be encoded as "
"ISO-8859-1, otherwise the data returned by ``read()`` is sent as is.  If "
"*body* is an iterable, the elements of the iterable are sent as is until the "
"iterable is exhausted."
msgstr ""
"Om *body* anges skickas den angivna datan efter att rubrikerna är klara.  "
"Det kan vara en :class:`str`, ett :term:`bytes-liknande objekt`, ett öppet :"
"term:`file-objekt` eller en iterabel av :class:`bytes`.  Om *body* är en "
"sträng kodas den som ISO-8859-1, vilket är standard för HTTP.  Om det är ett "
"bytesliknande objekt skickas bytena som de är.  Om det är ett :term:"
"`filobjekt`, skickas innehållet i filen; detta filobjekt bör åtminstone "
"stödja metoden ``read()``.  Om filobjektet är en instans av :class:`io."
"TextIOBase`, kommer de data som returneras av metoden ``read()`` att kodas "
"som ISO-8859-1, annars skickas de data som returneras av ``read()`` som de "
"är.  Om *body* är en iterabel skickas elementen i iterabeln som de är tills "
"iterabeln är uttömd."

msgid ""
"The *headers* argument should be a mapping of extra HTTP headers to send "
"with the request. A :rfc:`Host header <2616#section-14.23>` must be provided "
"to conform with :rfc:`RFC 2616 §5.1.2 <2616#section-5.1.2>` (unless "
"connecting to an HTTP proxy server or using the ``OPTIONS`` or ``CONNECT`` "
"methods)."
msgstr ""
"Argumentet *headers* bör vara en mappning av extra HTTP-rubriker som ska "
"skickas med begäran. En :rfc:`Host header <2616#section-14.23>` måste "
"tillhandahållas för att överensstämma med :rfc:`RFC 2616 §5.1.2 "
"<2616#section-5.1.2>` (såvida man inte ansluter till en HTTP-proxyserver "
"eller använder metoderna ``OPTIONS`` eller ``CONNECT``)."

msgid ""
"If *headers* contains neither Content-Length nor Transfer-Encoding, but "
"there is a request body, one of those header fields will be added "
"automatically.  If *body* is ``None``, the Content-Length header is set to "
"``0`` for methods that expect a body (``PUT``, ``POST``, and ``PATCH``).  If "
"*body* is a string or a bytes-like object that is not also a :term:`file "
"<file object>`, the Content-Length header is set to its length.  Any other "
"type of *body* (files and iterables in general) will be chunk-encoded, and "
"the Transfer-Encoding header will automatically be set instead of Content-"
"Length."
msgstr ""
"Om *headers* varken innehåller Content-Length eller Transfer-Encoding, men "
"det finns en request body, kommer ett av dessa header-fält att läggas till "
"automatiskt.  Om *body* är ``None``, sätts Content-Length-huvudet till ``0`` "
"för metoder som förväntar sig en body (``PUT``, ``POST`` och ``PATCH``).  Om "
"*body* är en sträng eller ett bytesliknande objekt som inte också är en :"
"term:`file <file object>`, sätts Content-Length-huvudet till dess längd.  "
"Alla andra typer av *body* (filer och iterabler i allmänhet) kommer att "
"chunk-kodas, och Transfer-Encoding-huvudet kommer automatiskt att anges "
"istället för Content-Length."

msgid ""
"The *encode_chunked* argument is only relevant if Transfer-Encoding is "
"specified in *headers*.  If *encode_chunked* is ``False``, the "
"HTTPConnection object assumes that all encoding is handled by the calling "
"code.  If it is ``True``, the body will be chunk-encoded."
msgstr ""
"Argumentet *encode_chunked* är endast relevant om Transfer-Encoding anges i "
"*headers*.  Om *encode_chunked* är ``False``, antar HTTPConnection-objektet "
"att all kodning hanteras av den anropande koden.  Om det är ``True`` kommer "
"kroppen att vara chunk-kodad."

msgid ""
"For example, to perform a ``GET`` request to ``https://docs.python.org/3/``::"
msgstr ""
"Till exempel, för att utföra en ``GET`` begäran till ``https://docs.python."
"org/3/``::"

msgid ""
">>> import http.client\n"
">>> host = \"docs.python.org\"\n"
">>> conn = http.client.HTTPSConnection(host)\n"
">>> conn.request(\"GET\", \"/3/\", headers={\"Host\": host})\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"200 OK"
msgstr ""
">>> import http.client\n"
">>> host = \"docs.python.org\"\n"
">>> conn = http.client.HTTPSConnection(host)\n"
">>> conn.request(\"GET\", \"/3/\", headers={\"Host\": host})\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"200 OK"

msgid ""
"Chunked transfer encoding has been added to the HTTP protocol version 1.1.  "
"Unless the HTTP server is known to handle HTTP 1.1, the caller must either "
"specify the Content-Length, or must pass a :class:`str` or bytes-like object "
"that is not also a file as the body representation."
msgstr ""
"Chunked transfer encoding har lagts till i HTTP-protokollet version 1.1.  Om "
"inte HTTP-servern är känd för att hantera HTTP 1.1, måste anroparen antingen "
"ange Content-Length eller skicka ett :class:`str` eller bytes-liknande "
"objekt som inte också är en fil som body-representation."

msgid "*body* can now be an iterable."
msgstr "*body* kan nu vara en iterabel."

msgid ""
"If neither Content-Length nor Transfer-Encoding are set in *headers*, file "
"and iterable *body* objects are now chunk-encoded. The *encode_chunked* "
"argument was added. No attempt is made to determine the Content-Length for "
"file objects."
msgstr ""
"Om varken Content-Length eller Transfer-Encoding anges i *headers* är fil- "
"och iterable-objekten *body* nu chunk-kodade. Argumentet *encode_chunked* "
"har lagts till. Det görs inga försök att fastställa Content-Length för "
"filobjekt."

msgid ""
"Should be called after a request is sent to get the response from the "
"server. Returns an :class:`HTTPResponse` instance."
msgstr ""
"Bör anropas efter att en begäran har skickats för att få svaret från "
"servern. Returnerar en instans av :class:`HTTPResponse`."

msgid ""
"Note that you must have read the whole response before you can send a new "
"request to the server."
msgstr ""
"Observera att du måste ha läst hela svaret innan du kan skicka en ny begäran "
"till servern."

msgid ""
"If a :exc:`ConnectionError` or subclass is raised, the :class:"
"`HTTPConnection` object will be ready to reconnect when a new request is "
"sent."
msgstr ""
"Om ett :exc:`ConnectionError` eller underklass uppstår, kommer :class:"
"`HTTPConnection`-objektet att vara redo att återansluta när en ny begäran "
"skickas."

msgid ""
"Set the debugging level.  The default debug level is ``0``, meaning no "
"debugging output is printed.  Any value greater than ``0`` will cause all "
"currently defined debug output to be printed to stdout.  The ``debuglevel`` "
"is passed to any new :class:`HTTPResponse` objects that are created."
msgstr ""
"Ställer in felsökningsnivån.  Standardnivån för felsökning är ``0``, vilket "
"innebär att inga felsökningsresultat skrivs ut.  Alla värden som är större "
"än ``0`` gör att all debug-utdata som för närvarande är definierad skrivs ut "
"till stdout.  Debuggnivån skickas till alla nya :class:`HTTPResponse`-objekt "
"som skapas."

msgid ""
"Set the host and the port for HTTP Connect Tunnelling. This allows running "
"the connection through a proxy server."
msgstr ""
"Ange värd och port för HTTP Connect Tunnelling. Detta gör det möjligt att "
"köra anslutningen via en proxyserver."

msgid ""
"The *host* and *port* arguments specify the endpoint of the tunneled "
"connection (i.e. the address included in the CONNECT request, *not* the "
"address of the proxy server)."
msgstr ""
"Argumenten *host* och *port* anger slutpunkten för den tunnlade anslutningen "
"(dvs. den adress som ingår i CONNECT-begäran, *inte* proxyserverns adress)."

msgid ""
"The *headers* argument should be a mapping of extra HTTP headers to send "
"with the CONNECT request."
msgstr ""
"Argumentet *headers* bör vara en mappning av extra HTTP-rubriker som ska "
"skickas med CONNECT-begäran."

msgid ""
"As HTTP/1.1 is used for HTTP CONNECT tunnelling request, `as per the RFC "
"<https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6>`_, a HTTP "
"``Host:`` header must be provided, matching the authority-form of the "
"request target provided as the destination for the CONNECT request. If a "
"HTTP ``Host:`` header is not provided via the headers argument, one is "
"generated and transmitted automatically."
msgstr ""
"Eftersom HTTP/1.1 används för HTTP CONNECT-tunnelförfrågningar, `enligt RFC "
"<https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6>`_, måste en "
"HTTP ``Host:``-rubrik tillhandahållas, som matchar auktoritetsformen för det "
"förfrågningsmål som anges som destination för CONNECT-förfrågan. Om en HTTP "
"``Host:`` header inte tillhandahålls via argumentet headers, genereras och "
"överförs en header automatiskt."

msgid ""
"For example, to tunnel through a HTTPS proxy server running locally on port "
"8080, we would pass the address of the proxy to the :class:`HTTPSConnection` "
"constructor, and the address of the host that we eventually want to reach to "
"the :meth:`~HTTPConnection.set_tunnel` method::"
msgstr ""
"Om vi till exempel vill skapa en tunnel genom en HTTPS-proxyserver som körs "
"lokalt på port 8080, skickar vi adressen till proxyn till :class:"
"`HTTPSConnection`-konstruktören och adressen till den värd som vi så "
"småningom vill nå till :meth:`~HTTPConnection.set_tunnel`-metoden::"

msgid ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"localhost\", 8080)\n"
">>> conn.set_tunnel(\"www.python.org\")\n"
">>> conn.request(\"HEAD\",\"/index.html\")"
msgstr ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"localhost\", 8080)\n"
">>> conn.set_tunnel(\"www.python.org\")\n"
">>> conn.request(\"HEAD\",\"/index.html\")"

msgid ""
"HTTP CONNECT tunnelling requests use protocol HTTP/1.1, upgraded from "
"protocol HTTP/1.0. ``Host:`` HTTP headers are mandatory for HTTP/1.1, so one "
"will be automatically generated and transmitted if not provided in the "
"headers argument."
msgstr ""
"HTTP CONNECT-tunnelförfrågningar använder protokoll HTTP/1.1, uppgraderat "
"från protokoll HTTP/1.0. ``Host:`` HTTP-rubriker är obligatoriska för "
"HTTP/1.1, så en kommer automatiskt att genereras och överföras om den inte "
"anges i argumentet headers."

msgid ""
"Returns a dictionary with the headers of the response received from the "
"proxy server to the CONNECT request."
msgstr ""
"Returnerar en ordbok med rubrikerna i svaret från proxyservern på CONNECT-"
"begäran."

msgid "If the CONNECT request was not sent, the method returns ``None``."
msgstr "Om CONNECT-begäran inte skickades returnerar metoden ``None``."

msgid ""
"Connect to the server specified when the object was created.  By default, "
"this is called automatically when making a request if the client does not "
"already have a connection."
msgstr ""
"Anslut till den server som angavs när objektet skapades.  Som standard "
"anropas detta automatiskt när en begäran görs om klienten inte redan har en "
"anslutning."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``http.client.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``http.client.connect`` med "
"argumenten ``self``, ``host``, ``port``."

msgid "Close the connection to the server."
msgstr "Stäng anslutningen till servern."

msgid "Buffer size in bytes for sending a file-like message body."
msgstr "Buffertstorlek i bytes för att skicka en filliknande meddelandekropp."

msgid ""
"As an alternative to using the :meth:`~HTTPConnection.request` method "
"described above, you can also send your request step by step, by using the "
"four functions below."
msgstr ""
"Som ett alternativ till att använda metoden :meth:`~HTTPConnection.request` "
"som beskrivs ovan kan du också skicka din begäran steg för steg genom att "
"använda de fyra funktionerna nedan."

msgid ""
"This should be the first call after the connection to the server has been "
"made. It sends a line to the server consisting of the *method* string, the "
"*url* string, and the HTTP version (``HTTP/1.1``).  To disable automatic "
"sending of ``Host:`` or ``Accept-Encoding:`` headers (for example to accept "
"additional content encodings), specify *skip_host* or *skip_accept_encoding* "
"with non-False values."
msgstr ""
"Detta bör vara det första anropet efter att anslutningen till servern har "
"upprättats. Det skickar en rad till servern som består av *method*-strängen, "
"*url*-strängen och HTTP-versionen (``HTTP/1.1``).  För att inaktivera "
"automatisk sändning av ``Host:`` eller ``Accept-Encoding:``-rubriker (till "
"exempel för att acceptera ytterligare innehållskodningar), ange *skip_host* "
"eller *skip_accept_encoding* med icke-falska värden."

msgid ""
"Send an :rfc:`822`\\ -style header to the server.  It sends a line to the "
"server consisting of the header, a colon and a space, and the first "
"argument.  If more arguments are given, continuation lines are sent, each "
"consisting of a tab and an argument."
msgstr ""
"Skicka en header i stil med :rfc:`822` till servern.  Det skickar en rad "
"till servern som består av rubriken, ett kolon och ett mellanslag samt det "
"första argumentet.  Om fler argument anges skickas fortsättningsrader, var "
"och en bestående av en tabb och ett argument."

msgid ""
"Send a blank line to the server, signalling the end of the headers. The "
"optional *message_body* argument can be used to pass a message body "
"associated with the request."
msgstr ""
"Skicka en tom rad till servern för att markera slutet på sidhuvudet. Det "
"valfria argumentet *message_body* kan användas för att skicka en "
"meddelandekod som är kopplad till begäran."

msgid ""
"If *encode_chunked* is ``True``, the result of each iteration of "
"*message_body* will be chunk-encoded as specified in :rfc:`7230`, Section "
"3.3.1.  How the data is encoded is dependent on the type of *message_body*.  "
"If *message_body* implements the :ref:`buffer interface <bufferobjects>` the "
"encoding will result in a single chunk. If *message_body* is a :class:"
"`collections.abc.Iterable`, each iteration of *message_body* will result in "
"a chunk.  If *message_body* is a :term:`file object`, each call to ``."
"read()`` will result in a chunk. The method automatically signals the end of "
"the chunk-encoded data immediately after *message_body*."
msgstr ""
"Om *encode_chunked* är ``True`` kommer resultatet av varje iteration av "
"*message_body* att chunk-kodas enligt specifikationen i :rfc:`7230`, avsnitt "
"3.3.1.  Hur data kodas beror på vilken typ av *message_body* som används.  "
"Om *message_body* implementerar :ref:`buffer interface <bufferobjects>` "
"kommer kodningen att resultera i en enda chunk. Om *message_body* är en :"
"class:`collections.abc.Iterable` kommer varje iteration av *message_body* "
"att resultera i en chunk.  Om *message_body* är en :term:`file object`, "
"kommer varje anrop till ``.read()`` att resultera i en chunk. Metoden "
"signalerar automatiskt slutet på de chunk-kodade data omedelbart efter "
"*message_body*."

msgid ""
"Due to the chunked encoding specification, empty chunks yielded by an "
"iterator body will be ignored by the chunk-encoder. This is to avoid "
"premature termination of the read of the request by the target server due to "
"malformed encoding."
msgstr ""
"På grund av specifikationen för chunked-kodning ignoreras tomma chunks som "
"genereras av en iteratorkropp av chunk-kodaren. Detta för att undvika att "
"målservern avslutar läsningen av begäran i förtid på grund av felaktig "
"kodning."

msgid "Added chunked encoding support and the *encode_chunked* parameter."
msgstr ""
"Stöd för chunked-kodning och parametern *encode_chunked* har lagts till."

msgid ""
"Send data to the server.  This should be used directly only after the :meth:"
"`endheaders` method has been called and before :meth:`getresponse` is called."
msgstr ""
"Skicka data till servern.  Detta bör användas direkt först efter att "
"metoden :meth:`endheaders` har anropats och innan :meth:`getresponse` "
"anropas."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``http.client.send`` with "
"arguments ``self``, ``data``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``http.client.send`` med "
"argumenten ``self``, ``data``."

msgid "HTTPResponse Objects"
msgstr "HTTPResponse Objekt"

msgid ""
"An :class:`HTTPResponse` instance wraps the HTTP response from the server.  "
"It provides access to the request headers and the entity body.  The response "
"is an iterable object and can be used in a with statement."
msgstr ""
"En :class:`HTTPResponse`-instans omsluter HTTP-svaret från servern.  Den ger "
"tillgång till begärans rubriker och entitetens kropp.  Svaret är ett "
"itererbart objekt och kan användas i en with-sats."

msgid ""
"The :class:`io.BufferedIOBase` interface is now implemented and all of its "
"reader operations are supported."
msgstr ""
"Gränssnittet :class:`io.BufferedIOBase` är nu implementerat och alla dess "
"läsoperationer stöds."

msgid "Reads and returns the response body, or up to the next *amt* bytes."
msgstr "Läser och returnerar svarstexten, eller upp till nästa *amt* byte."

msgid ""
"Reads up to the next len(b) bytes of the response body into the buffer *b*. "
"Returns the number of bytes read."
msgstr ""
"Läser upp till nästa len(b) byte av svarstexten i bufferten *b*. Returnerar "
"antalet lästa byte."

msgid ""
"Return the value of the header *name*, or *default* if there is no header "
"matching *name*.  If there is more than one  header with the name *name*, "
"return all of the values joined by ', '.  If *default* is any iterable other "
"than a single string, its elements are similarly returned joined by commas."
msgstr ""
"Returnerar värdet för rubriken *name*, eller *default* om det inte finns "
"någon rubrik som matchar *name*.  Om det finns mer än en header med namnet "
"*name*, returneras alla värden sammanfogade med ', '.  Om *default* är någon "
"annan iterabel än en enda sträng returneras dess element på samma sätt med "
"kommatecken."

msgid "Return a list of (header, value) tuples."
msgstr "Returnerar en lista med (header, value)-tupler."

msgid "Return the ``fileno`` of the underlying socket."
msgstr "Returnerar ``fileno`` för det underliggande uttaget."

msgid ""
"A :class:`http.client.HTTPMessage` instance containing the response "
"headers.  :class:`http.client.HTTPMessage` is a subclass of :class:`email."
"message.Message`."
msgstr ""
"En instans av :class:`http.client.HTTPMessage` som innehåller "
"svarshuvudena. :class:`http.client.HTTPMessage` är en underklass av :class:"
"`email.message.Message`."

msgid ""
"HTTP protocol version used by server.  10 for HTTP/1.0, 11 for HTTP/1.1."
msgstr ""
"HTTP-protokollversion som används av servern.  10 för HTTP/1.0, 11 för "
"HTTP/1.1."

msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr ""
"URL för den hämtade resursen, används vanligen för att avgöra om en "
"omdirigering följdes."

msgid ""
"Headers of the response in the form of an :class:`email.message."
"EmailMessage` instance."
msgstr ""
"Svarets rubriker i form av en instans av :class:`email.message.EmailMessage`."

msgid "Status code returned by server."
msgstr "Statuskod som returneras av servern."

msgid "Reason phrase returned by server."
msgstr "Orsaksfras som returneras av servern."

msgid ""
"A debugging hook.  If :attr:`debuglevel` is greater than zero, messages will "
"be printed to stdout as the response is read and parsed."
msgstr ""
"En felsökningskrok.  Om :attr:`debuglevel` är större än noll kommer "
"meddelanden att skrivas ut till stdout när svaret läses och analyseras."

msgid "Is ``True`` if the stream is closed."
msgstr "Är ``True`` om strömmen är stängd."

msgid "Deprecated in favor of :attr:`~HTTPResponse.url`."
msgstr "Föråldrad till förmån för :attr:`~HTTPResponse.url`."

msgid "Deprecated in favor of :attr:`~HTTPResponse.headers`."
msgstr "Föråldrad till förmån för :attr:`~HTTPResponse.headers`."

msgid "Deprecated in favor of :attr:`~HTTPResponse.status`."
msgstr "Föråldrad till förmån för :attr:`~HTTPResponse.status`."

msgid "Examples"
msgstr "Exempel"

msgid "Here is an example session that uses the ``GET`` method::"
msgstr "Här är ett exempel på en session som använder metoden ``GET``::"

msgid ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"www.python.org\")\n"
">>> conn.request(\"GET\", \"/\")\n"
">>> r1 = conn.getresponse()\n"
">>> print(r1.status, r1.reason)\n"
"200 OK\n"
">>> data1 = r1.read()  # This will return entire content.\n"
">>> # The following example demonstrates reading data in chunks.\n"
">>> conn.request(\"GET\", \"/\")\n"
">>> r1 = conn.getresponse()\n"
">>> while chunk := r1.read(200):\n"
"...     print(repr(chunk))\n"
"b'<!doctype html>\\n<!--[if\"...\n"
"...\n"
">>> # Example of an invalid request\n"
">>> conn = http.client.HTTPSConnection(\"docs.python.org\")\n"
">>> conn.request(\"GET\", \"/parrot.spam\")\n"
">>> r2 = conn.getresponse()\n"
">>> print(r2.status, r2.reason)\n"
"404 Not Found\n"
">>> data2 = r2.read()\n"
">>> conn.close()"
msgstr ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"www.python.org\")\n"
">>> conn.request(\"GET\", \"/\")\n"
">>> r1 = conn.getresponse()\n"
">>> print(r1.status, r1.reason)\n"
"200 OK\n"
">>> data1 = r1.read()  # This will return entire content.\n"
">>> # The following example demonstrates reading data in chunks.\n"
">>> conn.request(\"GET\", \"/\")\n"
">>> r1 = conn.getresponse()\n"
">>> while chunk := r1.read(200):\n"
"...     print(repr(chunk))\n"
"b'<!doctype html>\\n<!--[if\"...\n"
"...\n"
">>> # Example of an invalid request\n"
">>> conn = http.client.HTTPSConnection(\"docs.python.org\")\n"
">>> conn.request(\"GET\", \"/parrot.spam\")\n"
">>> r2 = conn.getresponse()\n"
">>> print(r2.status, r2.reason)\n"
"404 Not Found\n"
">>> data2 = r2.read()\n"
">>> conn.close()"

msgid ""
"Here is an example session that uses the ``HEAD`` method.  Note that the "
"``HEAD`` method never returns any data. ::"
msgstr ""
"Här är ett exempel på en session som använder metoden ``HEAD``.  Observera "
"att metoden ``HEAD`` aldrig returnerar några data. ::"

msgid ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"www.python.org\")\n"
">>> conn.request(\"HEAD\", \"/\")\n"
">>> res = conn.getresponse()\n"
">>> print(res.status, res.reason)\n"
"200 OK\n"
">>> data = res.read()\n"
">>> print(len(data))\n"
"0\n"
">>> data == b''\n"
"True"
msgstr ""
">>> import http.client\n"
">>> conn = http.client.HTTPSConnection(\"www.python.org\")\n"
">>> conn.request(\"HEAD\", \"/\")\n"
">>> res = conn.getresponse()\n"
">>> print(res.status, res.reason)\n"
"200 OK\n"
">>> data = res.read()\n"
">>> print(len(data))\n"
"0\n"
">>> data == b''\n"
"True"

msgid "Here is an example session that uses the ``POST`` method::"
msgstr "Här är ett exempel på en session som använder metoden ``POST``::"

msgid ""
">>> import http.client, urllib.parse\n"
">>> params = urllib.parse.urlencode({'@number': 12524, '@type': 'issue', "
"'@action': 'show'})\n"
">>> headers = {\"Content-type\": \"application/x-www-form-urlencoded\",\n"
"...            \"Accept\": \"text/plain\"}\n"
">>> conn = http.client.HTTPConnection(\"bugs.python.org\")\n"
">>> conn.request(\"POST\", \"\", params, headers)\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"302 Found\n"
">>> data = response.read()\n"
">>> data\n"
"b'Redirecting to <a href=\"https://bugs.python.org/issue12524\">https://bugs."
"python.org/issue12524</a>'\n"
">>> conn.close()"
msgstr ""
">>> import http.client, urllib.parse\n"
">>> params = urllib.parse.urlencode({'@number': 12524, '@type': 'issue', "
"'@action': 'show'})\n"
">>> headers = {\"Content-type\": \"application/x-www-form-urlencoded\",\n"
"...            \"Accept\": \"text/plain\"}\n"
">>> conn = http.client.HTTPConnection(\"bugs.python.org\")\n"
">>> conn.request(\"POST\", \"\", params, headers)\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"302 Found\n"
">>> data = response.read()\n"
">>> data\n"
"b'Redirecting to <a href=\"https://bugs.python.org/issue12524\">https://bugs."
"python.org/issue12524</a>'\n"
">>> conn.close()"

msgid ""
"Client side HTTP ``PUT`` requests are very similar to ``POST`` requests. The "
"difference lies only on the server side where HTTP servers will allow "
"resources to be created via ``PUT`` requests. It should be noted that custom "
"HTTP methods are also handled in :class:`urllib.request.Request` by setting "
"the appropriate method attribute. Here is an example session that uses the "
"``PUT`` method::"
msgstr ""
"HTTP ``PUT``-förfrågningar på klientsidan är mycket lika ``POST``-"
"förfrågningar. Skillnaden ligger endast på serversidan där HTTP-servrar "
"tillåter att resurser skapas via ``PUT``-förfrågningar. Det bör noteras att "
"anpassade HTTP-metoder också hanteras i :class:`urllib.request.Request` "
"genom att ställa in lämpligt metodattribut. Här är ett exempel på en session "
"som använder metoden ``PUT``::"

msgid ""
">>> # This creates an HTTP request\n"
">>> # with the content of BODY as the enclosed representation\n"
">>> # for the resource http://localhost:8080/file\n"
"...\n"
">>> import http.client\n"
">>> BODY = \"***filecontents***\"\n"
">>> conn = http.client.HTTPConnection(\"localhost\", 8080)\n"
">>> conn.request(\"PUT\", \"/file\", BODY)\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"200, OK"
msgstr ""
">>> # This creates an HTTP request\n"
">>> # with the content of BODY as the enclosed representation\n"
">>> # for the resource http://localhost:8080/file\n"
"...\n"
">>> import http.client\n"
">>> BODY = \"***filecontents***\"\n"
">>> conn = http.client.HTTPConnection(\"localhost\", 8080)\n"
">>> conn.request(\"PUT\", \"/file\", BODY)\n"
">>> response = conn.getresponse()\n"
">>> print(response.status, response.reason)\n"
"200, OK"

msgid "HTTPMessage Objects"
msgstr "HTTPMessage-objekt"

msgid ""
"An :class:`http.client.HTTPMessage` instance holds the headers from an HTTP "
"response.  It is implemented using the :class:`email.message.Message` class."
msgstr ""
"En :class:`http.client.HTTPMessage`-instans innehåller rubrikerna från ett "
"HTTP-svar.  Den implementeras med hjälp av :class:`email.message.Message`-"
"klassen."

msgid "HTTP"
msgstr "HTTP"

msgid "protocol"
msgstr "protokoll"

msgid "http.client (standard module)"
msgstr "http.client (standardmodul)"

msgid "module"
msgstr "modul"

msgid "urllib.request"
msgstr "urllib.begäran"
