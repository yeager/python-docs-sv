# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Common Object Structures"
msgstr "Vanliga objektstrukturer"

msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Det finns ett stort antal strukturer som används vid definitionen av "
"objekttyper i Python.  I detta avsnitt beskrivs dessa strukturer och hur de "
"används."

msgid "Base object types and macros"
msgstr "Typer av basobjekt och makron"

msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects.  "
"Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"Alla Python-objekt delar i slutändan ett litet antal fält i början av "
"objektets representation i minnet.  Dessa representeras av typerna :c:type:"
"`PyObject` och :c:type:`PyVarObject`, som i sin tur definieras av "
"utvidgningarna av vissa makron som också används, direkt eller indirekt, i "
"definitionen av alla andra Python-objekt.  Ytterligare makron finns under :"
"ref:`referensräkning <countingrefs>`."

msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`."
msgstr ""
"Alla objekttyper är utvidgningar av denna typ.  Detta är en typ som "
"innehåller den information som Python behöver för att behandla en pekare "
"till ett objekt som ett objekt.  I en normal \"release\"-byggnad innehåller "
"den bara objektets referensantal och en pekare till motsvarande typobjekt. "
"Ingenting är faktiskt deklarerat att vara ett :c:type:`PyObject`, men varje "
"pekare till ett Python-objekt kan castas till ett :c:expr:`PyObject*`."

msgid ""
"The members must not be accessed directly; instead use macros such as :c:"
"macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Medlemmarna får inte nås direkt; använd istället makron som :c:macro:"
"`Py_REFCNT` och :c:macro:`Py_TYPE`."

msgid ""
"The object's reference count, as returned by :c:macro:`Py_REFCNT`. Do not "
"use this field directly; instead use functions and macros such as :c:macro:`!"
"Py_REFCNT`, :c:func:`Py_INCREF` and :c:func:`Py_DecRef`."
msgstr ""
"Objektets referensantal, som returneras av :c:macro:`Py_REFCNT`. Använd inte "
"detta fält direkt, utan använd istället funktioner och makron som :c:macro:`!"
"Py_REFCNT`, :c:func:`Py_INCREF` och :c:func:`Py_DecRef`."

msgid ""
"The field type may be different from ``Py_ssize_t``, depending on build "
"configuration and platform."
msgstr ""
"Fälttypen kan skilja sig från ``Py_ssize_t``, beroende på byggkonfiguration "
"och plattform."

msgid ""
"The object's type. Do not use this field directly; use :c:macro:`Py_TYPE` "
"and :c:func:`Py_SET_TYPE` instead."
msgstr ""
"Objektets typ. Använd inte detta fält direkt; använd :c:macro:`Py_TYPE` och :"
"c:func:`Py_SET_TYPE` istället."

msgid ""
"An extension of :c:type:`PyObject` that adds the :c:member:`~PyVarObject."
"ob_size` field. This is intended for objects that have some notion of "
"*length*."
msgstr ""
"En utökning av :c:type:`PyObject` som lägger till fältet :c:member:"
"`~PyVarObject.ob_size`. Detta är avsett för objekt som har någon uppfattning "
"om *längd*."

msgid ""
"As with :c:type:`!PyObject`, the members must not be accessed directly; "
"instead use macros such as :c:macro:`Py_SIZE`, :c:macro:`Py_REFCNT` and :c:"
"macro:`Py_TYPE`."
msgstr ""
"Precis som med :c:type:`!PyObject` får medlemmarna inte nås direkt; använd "
"istället makron som :c:macro:`Py_SIZE`, :c:macro:`Py_REFCNT` och :c:macro:"
"`Py_TYPE`."

msgid ""
"A size field, whose contents should be considered an object's internal "
"implementation detail."
msgstr ""
"Ett storleksfält, vars innehåll bör betraktas som ett objekts interna "
"implementeringsdetaljer."

msgid "Do not use this field directly; use :c:macro:`Py_SIZE` instead."
msgstr "Använd inte detta fält direkt utan använd istället :c:macro:`Py_SIZE`."

msgid ""
"Object creation functions such as :c:func:`PyObject_NewVar` will generally "
"set this field to the requested size (number of items). After creation, "
"arbitrary values can be stored in :c:member:`!ob_size` using :c:macro:"
"`Py_SET_SIZE`."
msgstr ""
"Objektskapande funktioner som :c:func:`PyObject_NewVar` kommer i allmänhet "
"att sätta detta fält till den begärda storleken (antal objekt). Efter "
"skapandet kan godtyckliga värden lagras i :c:member:`!ob_size` med hjälp av :"
"c:macro:`Py_SET_SIZE`."

msgid ""
"To get an object's publicly exposed length, as returned by the Python "
"function :py:func:`len`, use :c:func:`PyObject_Length` instead."
msgstr ""
"För att få ett objekts offentligt exponerade längd, som returneras av Python-"
"funktionen :py:func:`len`, använder du istället :c:func:`PyObject_Length`."

msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Detta är ett makro som används vid deklaration av nya typer som "
"representerar objekt utan varierande längd.  PyObject_HEAD-makrot expanderar "
"till::"

msgid "PyObject ob_base;"
msgstr "PyObject ob_base;"

msgid "See documentation of :c:type:`PyObject` above."
msgstr "Se dokumentation av :c:type:`PyObject` ovan."

msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Detta är ett makro som används vid deklaration av nya typer som "
"representerar objekt med en längd som varierar från instans till instans. "
"Makrot PyObject_VAR_HEAD expanderar till::"

msgid "PyVarObject ob_base;"
msgstr "PyVarObject ob_base;"

msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Se dokumentation av :c:type:`PyVarObject` ovan."

msgid ""
"The base class of all other objects, the same as :class:`object` in Python."
msgstr ""
"Basklassen för alla andra objekt, samma sak som :class:`object` i Python."

msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Testar om *x*-objektet är *y*-objektet, på samma sätt som ``x är y`` i "
"Python."

msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Testar om ett objekt är singleton ``None``, samma sak som ``x is None`` i "
"Python."

msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Testar om ett objekt är ``True`` singleton, på samma sätt som ``x is True`` "
"i Python."

msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Testar om ett objekt är ``False`` singleton, samma sak som ``x is False`` i "
"Python."

msgid "Get the type of the Python object *o*."
msgstr "Hämta typen av Python-objekt *o*."

msgid ""
"The returned reference is :term:`borrowed <borrowed reference>` from *o*. Do "
"not release it with :c:func:`Py_DECREF` or similar."
msgstr ""
"Den returnerade referensen är :term:`borrowed <borrowed reference>` från "
"*o*. Frigör den inte med :c:func:`Py_DECREF` eller liknande."

msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` ändras till en inline statisk funktion. Parametertypen "
"är inte längre :c:expr:`const PyObject*`."

msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Returnerar icke-noll om objektets *o* typ är *type*. Returnerar noll annars. "
"Likvärdig med: ``Py_TYPE(o) == typ``."

msgid ""
"Set the type of object *o* to *type*, without any checking or reference "
"counting."
msgstr ""
"Sätt typen av objekt *o* till *typ*, utan kontroll eller referensräkning."

msgid ""
"This is a very low-level operation. Consider instead setting the Python "
"attribute :attr:`~object.__class__` using :c:func:`PyObject_SetAttrString` "
"or similar."
msgstr ""
"Detta är en operation på mycket låg nivå. Överväg istället att ställa in "
"Python-attributet :attr:`~object.__class__` med hjälp av :c:func:"
"`PyObject_SetAttrString` eller liknande."

msgid ""
"Note that assigning an incompatible type can lead to undefined behavior."
msgstr ""
"Observera att om du tilldelar en inkompatibel typ kan det leda till ett "
"odefinierat beteende."

msgid ""
"If *type* is a :ref:`heap type <heap-types>`, the caller must create a new "
"reference to it. Similarly, if the old type of *o* is a heap type, the "
"caller must release a reference to that type."
msgstr ""
"Om *typ* är en :ref:`heap-typ <heap-types>`, måste anroparen skapa en ny "
"referens till den. På samma sätt, om den gamla typen av *o* är en heap-typ, "
"måste den som anropar frigöra en referens till den typen."

msgid "Get the :c:member:`~PyVarObject.ob_size` field of *o*."
msgstr "Hämta fältet :c:member:`~PyVarObject.ob_size` för *o*."

msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` är ändrad till en inline statisk funktion. "
"Parametertypen är inte längre :c:expr:`const PyVarObject*`."

msgid "Set the :c:member:`~PyVarObject.ob_size` field of *o* to *size*."
msgstr "Sätt fältet :c:member:`~PyVarObject.ob_size` i *o* till *size*."

msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Detta är ett makro som expanderar till initialiseringsvärden för en ny :c:"
"type:`PyObject`-typ.  Detta makro expanderar till::"

msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""
"_PyObjekt_EXTRA_INIT\n"
"1, typ,"

msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` field. "
"This macro expands to::"
msgstr ""
"Detta är ett makro som expanderar till initialiseringsvärden för en ny :c:"
"type:`PyVarObject`-typ, inklusive fältet :c:member:`~PyVarObject.ob_size`. "
"Detta makro expanderar till::"

msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""
"_PyObjekt_EXTRA_INIT\n"
"1, typ, storlek,"

msgid "Implementing functions and methods"
msgstr "Implementering av funktioner och metoder"

msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Typ av funktioner som används för att implementera de flesta Python-"
"kallelser i C. Funktioner av denna typ tar två :c:expr:`PyObject*`-"
"parametrar och returnerar ett sådant värde.  Om returvärdet är ``NULL`` "
"skall ett undantag ha ställts in.  Om det inte är ``NULL`` tolkas "
"returvärdet som returvärdet för funktionen som den exponeras i Python.  "
"Funktionen måste returnera en ny referens."

msgid "The function signature is::"
msgstr "Funktionens signatur är::"

msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"The function signature is::"
msgstr ""
"Typ av de funktioner som används för att implementera Python callables i C "
"med signaturen :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-"
"METH_KEYWORDS>`. Funktionssignaturen är::"

msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Typ av de funktioner som används för att implementera Python callables i C "
"med signaturen :c:macro:`METH_FASTCALL`. Funktionens signatur är::"

msgid ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"
msgstr ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Typ av de funktioner som används för att implementera Python callables i C "
"med signaturen :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. Funktionssignaturen är::"

msgid ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"
msgstr ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *konst *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnamn);"

msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Typ av de funktioner som används för att implementera Python callables i C "
"med signaturen :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS "
"<METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`. Funktionssignaturen är::"

msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *definierande_klass,\n"
"                    PyObject *konst *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnamn)"

msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Struktur som används för att beskriva en metod för en förlängningstyp.  "
"Denna struktur har fyra fält:"

msgid "Name of the method."
msgstr "Namn på metoden."

msgid "Pointer to the C implementation."
msgstr "Pekare till C-implementeringen."

msgid "Flags bits indicating how the call should be constructed."
msgstr "Flaggbitar som anger hur anropet ska konstrueras."

msgid "Points to the contents of the docstring."
msgstr "Pekar på innehållet i dokumentsträngen."

msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":c:member:`~PyMethodDef.ml_meth` är en C-funktionspekare. Funktionerna kan "
"vara av olika typer, men de returnerar alltid :c:expr:`PyObject*`.  Om "
"funktionen inte är av typen :c:type:`PyCFunction`, kommer kompilatorn att "
"kräva en cast i metodtabellen. Även om :c:type:`PyCFunction` definierar den "
"första parametern som :c:expr:`PyObject*`, är det vanligt att "
"metodimplementeringen använder den specifika C-typen för *self*-objektet."

msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ""
"Fältet :c:member:`~PyMethodDef.ml_flags` är ett bitfält som kan innehålla "
"följande flaggor. De enskilda flaggorna anger antingen en anropskonvention "
"eller en bindningskonvention."

msgid "There are these calling conventions:"
msgstr "Det finns dessa samtalskonventioner:"

msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Detta är den typiska anropskonventionen, där metoderna har typen :c:type:"
"`PyCFunction`. Funktionen förväntar sig två :c:expr:`PyObject*`-värden. Det "
"första är *self*-objektet för metoder; för modulfunktioner är det "
"modulobjektet.  Den andra parametern (ofta kallad *args*) är ett tuple-"
"objekt som representerar alla argument. Den här parametern bearbetas "
"vanligtvis med :c:func:`PyArg_ParseTuple` eller :c:func:`PyArg_UnpackTuple`."

msgid ""
"Can only be used in certain combinations with other flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."
msgstr ""
"Kan endast användas i vissa kombinationer med andra flaggor: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` och :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ":c:expr:`METH_VARARGS | METH_KEYWORDS`"

msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Metoder med dessa flaggor måste vara av typen :c:type:"
"`PyCFunctionWithKeywords`. Funktionen förväntar sig tre parametrar: *self*, "
"*args*, *kwargs* där *kwargs* är en dictionary med alla nyckelordsargument "
"eller eventuellt ``NULL`` om det inte finns några nyckelordsargument.  "
"Parametrarna bearbetas vanligtvis med :c:func:`PyArg_ParseTupleAndKeywords`."

msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Snabb anropskonvention som endast stöder positionella argument. Metoderna "
"har typen :c:type:`PyCFunctionFast`. Den första parametern är *self*, den "
"andra parametern är en C-array av :c:expr:`PyObject*`-värden som anger "
"argumenten och den tredje parametern är antalet argument (längden på "
"arrayen)."

msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr "``METH_FASTCALL`` är nu en del av :ref:`stable ABI <stable-abi>`."

msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"

msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
"Utökning av :c:macro:`METH_FASTCALL` som även stöder nyckelordsargument, med "
"metoder av typen :c:type:`PyCFunctionFastWithKeywords`. Nyckelordsargument "
"skickas på samma sätt som i :ref:`vectorcall-protokollet <vectorcall>`: det "
"finns en ytterligare fjärde :c:expr:`PyObject*`-parameter som är en tupel "
"som representerar namnen på nyckelordsargumenten (som garanterat är "
"strängar) eller eventuellt ``NULL`` om det inte finns några nyckelord.  "
"Värdena på nyckelordsargumenten lagras i *args*-arrayen, efter de "
"positionella argumenten."

msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"Kan endast användas i kombination med andra flaggor: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."

msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"

msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of "
"``Py_TYPE(self)``."
msgstr ""
"Utökning av :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` som stöder den *definierande klassen*, det vill säga den "
"klass som innehåller metoden i fråga. Den definierande klassen kan vara en "
"superklass av ``Py_TYPE(self)``."

msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"Metoden måste vara av typen :c:type:`PyCMethod`, på samma sätt som för "
"``METH_FASTCALL | METH_KEYWORDS`` med ``defining_class`` argumentet tillagt "
"efter ``self``."

msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Metoder utan parametrar behöver inte kontrollera om argument ges om de "
"listas med flaggan :c:macro:`METH_NOARGS`.  De måste vara av typen :c:type:"
"`PyCFunction`.  Den första parametern har vanligtvis namnet *self* och "
"innehåller en referens till modulen eller objektinstansen.  I samtliga fall "
"kommer den andra parametern att vara ``NULL``."

msgid ""
"The function must have 2 parameters. Since the second parameter is unused, :"
"c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"Funktionen måste ha 2 parametrar. Eftersom den andra parametern är oanvänd "
"kan :c:macro:`Py_UNUSED` användas för att förhindra en kompilatorvarning."

msgid ""
"Methods with a single object argument can be listed with the :c:macro:"
"`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` with a "
"``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with the "
"*self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"Metoder med ett enda objektargument kan listas med flaggan :c:macro:"
"`METH_O`, istället för att anropa :c:func:`PyArg_ParseTuple` med ett "
"``\"O\"``-argument. De är av typen :c:type:`PyCFunction`, med parametern "
"*self* och en parameter av typen :c:expr:`PyObject*` som representerar det "
"enda argumentet."

msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Dessa två konstanter används inte för att ange anropskonventionen utan "
"bindningen när de används med metoder för klasser.  De får inte användas för "
"funktioner som definieras för moduler.  Högst en av dessa flaggor får vara "
"inställd för en viss metod."

msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"Metoden kommer att få typobjektet som första parameter i stället för en "
"instans av typen.  Detta används för att skapa *klassmetoder*, liknande det "
"som skapas när man använder den inbyggda funktionen :func:`classmethod`."

msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"Metoden får ``NULL`` som första parameter i stället för en instans av "
"typen.  Detta används för att skapa *statiska metoder*, liknande det som "
"skapas när man använder den inbyggda funktionen :func:`staticmethod`."

msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"En annan konstant styr om en metod ska laddas i stället för en annan "
"definition med samma metodnamn."

msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction will "
"be loaded in place of the wrapper object and will co-exist with the slot.  "
"This is helpful because calls to PyCFunctions are optimized more than "
"wrapper object calls."
msgstr ""
"Metoden kommer att laddas i stället för befintliga definitioner.  Utan "
"*METH_COEXIST* är standardinställningen att hoppa över upprepade "
"definitioner.  Eftersom slot-omslag laddas före metodtabellen, skulle till "
"exempel förekomsten av en *sq_contains* slot generera en omslagsmetod med "
"namnet :meth:`~object.__contains__` och förhindra laddning av en motsvarande "
"PyCFunction med samma namn.  Med flaggan definierad kommer PyCFunktionen att "
"laddas i stället för omslutningsobjektet och kommer att samexistera med "
"slotten.  Detta är användbart eftersom anrop till PyCFunktioner optimeras "
"mer än anrop till omslagsobjekt."

msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that "
"*ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""
"Gör *ml* till ett Python :term:`callable`-objekt. Den som anropar måste se "
"till att *ml* överlever :term:`callable`. Vanligtvis är *ml* definierad som "
"en statisk variabel."

msgid ""
"The *self* parameter will be passed as the *self* argument to the C function "
"in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""
"Parametern *self* kommer att skickas som argumentet *self* till C-funktionen "
"i ``ml->ml_meth`` när den anropas. *self* kan vara ``NULL``."

msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""
"Attributet ``__module__`` för objektet :term:`callable` kan ställas in från "
"det givna argumentet *module*. *module* bör vara en Python-sträng, som "
"kommer att användas som namn på den modul som funktionen definieras i. Om "
"den inte är tillgänglig kan den sättas till :const:`None` eller ``NULL``."

msgid ":attr:`function.__module__`"
msgstr ":attr:`funktion.__modul__`"

msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C "
"function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""
"Parametern *cls* kommer att skickas som argumentet *defining_class* till C-"
"funktionen. Måste sättas om :c:macro:`METH_METHOD` är satt på ``ml-"
">ml_flags``."

msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr "Motsvarar ``PyCMethod_New(ml, self, module, NULL)``."

msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr "Motsvarar ``PyCMethod_New(ml, self, NULL, NULL)``."

msgid "Accessing attributes of extension types"
msgstr "Tillgång till attribut för tilläggstyper"

msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member. When defining a class, put a NULL-terminated array of these "
"structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr ""
"Struktur som beskriver ett attribut av en typ som motsvarar en C struct-"
"medlem. När du definierar en klass lägger du in en NULL-terminerad array av "
"dessa strukturer i :c:member:`~PyTypeObject.tp_members` slot."

msgid "Its fields are, in order:"
msgstr "Dess fält är i tur och ordning:"

msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` array."
msgstr ""
"Namnet på medlemmen. Ett NULL-värde markerar slutet på en ``PyMemberDef[]``-"
"array."

msgid "The string should be static, no copy is made of it."
msgstr "Strängen ska vara statisk, ingen kopia görs av den."

msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for the "
"possible values."
msgstr ""
"Typen av medlemmen i C-strukturen. Se :ref:`PyMemberDef-types` för de "
"möjliga värdena."

msgid ""
"The offset in bytes that the member is located on the type’s object struct."
msgstr ""
"Den offset i bytes som medlemmen befinner sig på i typens objektstruktur."

msgid ""
"Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr ""
"Noll eller flera av :ref:`PyMemberDef-flaggorna`, kombinerade med bitvis OR."

msgid ""
"The docstring, or NULL. The string should be static, no copy is made of it. "
"Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr ""
"Dokumentsträngen, eller NULL. Strängen ska vara statisk, ingen kopia görs av "
"den. Vanligtvis definieras den med hjälp av :c:macro:`PyDoc_STR`."

msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, imply :c:macro:"
"`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and legacy :c:macro:"
"`T_OBJECT`) members can be deleted."
msgstr ""
"Som standard (när :c:member:`~PyMemberDef.flags` är ``0``) tillåter "
"medlemmar både läs- och skrivåtkomst. Använd flaggan :c:macro:`Py_READONLY` "
"för skrivskyddad åtkomst. Vissa typer, som :c:macro:`Py_T_STRING`, innebär :"
"c:macro:`Py_READONLY`. Endast :c:macro:`Py_T_OBJECT_EX` (och äldre :c:macro:"
"`T_OBJECT`) medlemmar kan tas bort."

msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member "
"``\"__vectorcalloffset__\"``, corresponding to :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. This member must be defined with "
"``Py_T_PYSSIZET``, and either ``Py_READONLY`` or ``Py_READONLY | "
"Py_RELATIVE_OFFSET``. For example::"
msgstr ""
"För heap-allokerade typer (skapade med :c:func:`PyType_FromSpec` eller "
"liknande) kan ``PyMemberDef`` innehålla en definition för den speciella "
"medlemmen ``\"__vectorcalloffset__\"``, motsvarande :c:member:`~PyTypeObject."
"tp_vectorcall_offset`` i typobjekt. Denna medlem måste definieras med "
"``Py_T_PYSSIZET``, och antingen ``Py_READONLY`` eller ``Py_READONLY | "
"Py_RELATIVE_OFFSET``. Till exempel::"

msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"statisk PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL} /* Sentinel */\n"
"};"

msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr "(Du kan behöva ``#include <stddef.h>`` för :c:func:`!offsetof`.)"

msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` and :c:member:"
"`~PyTypeObject.tp_weaklistoffset` can be defined similarly using "
"``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"and :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""
"De äldre offseten :c:member:`~PyTypeObject.tp_dictoffset` och :c:member:"
"`~PyTypeObject.tp_weaklistoffset` kan definieras på liknande sätt med hjälp "
"av medlemmarna ``\"__dictoffset__\"`` och ``\"__weaklistoffset__\"``, men "
"tillägg uppmuntras starkt att använda :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"och :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` istället."

msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMemberDef`` är alltid tillgänglig. Tidigare krävdes det att man "
"inkluderade ``\"structmember.h\"``."

msgid ""
":c:macro:`Py_RELATIVE_OFFSET` is now allowed for "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` and "
"``\"__weaklistoffset__\"``."
msgstr ""
":c:macro:`Py_RELATIVE_OFFSET` är nu tillåtet för "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` och "
"``\"__weaklistoffset__\"``."

msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Hämtar ett attribut som tillhör objektet på adressen *obj_addr*.  Attributet "
"beskrivs av ``PyMemberDef`` *m*.  Returnerar ``NULL`` vid fel."

msgid ""
"``PyMember_GetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_GetOne`` är alltid tillgänglig. Tidigare krävdes det att man "
"inkluderade ``\"structmember.h\"``."

msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Ställ in ett attribut som tillhör objektet på adressen *obj_addr* till "
"objektet *o*. Attributet som ska ställas in beskrivs av ``PyMemberDef`` "
"*m*.  Returnerar ``0`` om det lyckas och ett negativt värde om det "
"misslyckas."

msgid ""
"``PyMember_SetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_SetOne`` är alltid tillgänglig. Tidigare krävdes det att man "
"inkluderade ``\"structmember.h\"``."

msgid "Member flags"
msgstr "Flaggor för medlemmar"

msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr "Följande flaggor kan användas med :c:member:`PyMemberDef.flags`:"

msgid "Not writable."
msgstr "Ej skrivbar."

msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr ""
"Skicka en ``object.__getattr__`` :ref:`audit event <audit-events>`` före "
"läsning."

msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this ``PyMemberDef`` "
"entry indicates an offset from the subclass-specific data, rather than from "
"``PyObject``."
msgstr ""
"Anger att :c:member:`~PyMemberDef.offset` i denna ``PyMemberDef``-post anger "
"en offset från subklassspecifika data, snarare än från ``PyObject``."

msgid ""
"Can only be used as part of :c:member:`Py_tp_members <PyTypeObject."
"tp_members>` :c:type:`slot <PyType_Slot>` when creating a class using "
"negative :c:member:`~PyType_Spec.basicsize`. It is mandatory in that case."
msgstr ""
"Kan endast användas som en del av :c:member:`Py_tp_members <PyTypeObject."
"tp_members>` :c:type:`slot <PyType_Slot>` när man skapar en klass med "
"negativ :c:member:`~PyType_Spec.basicsize`. Det är obligatoriskt i det "
"fallet."

msgid ""
"This flag is only used in :c:type:`PyType_Slot`. When setting :c:member:"
"`~PyTypeObject.tp_members` during class creation, Python clears it and sets :"
"c:member:`PyMemberDef.offset` to the offset from the ``PyObject`` struct."
msgstr ""
"Denna flagga används endast i :c:type:`PyType_Slot`. När du ställer in :c:"
"member:`~PyTypeObject.tp_members` under skapandet av klassen, rensar Python "
"den och ställer in :c:member:`PyMemberDef.offset` till offset från "
"``PyObject``-strukturen."

msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and :c:macro:`!"
"WRITE_RESTRICTED` macros available with ``#include \"structmember.h\"`` are "
"deprecated. :c:macro:`!READ_RESTRICTED` and :c:macro:`!RESTRICTED` are "
"equivalent to :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` does "
"nothing."
msgstr ""
"Makron :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` och :c:macro:`!"
"WRITE_RESTRICTED` som är tillgängliga med ``#include \"structmember.h\"`` är "
"föråldrade. :c:macro:`!READ_RESTRICTED` och :c:macro:`!RESTRICTED` är "
"likvärdiga med :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` gör "
"ingenting."

msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. The :c:"
"macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The new "
"names are now always available. Previously, these required ``#include "
"\"structmember.h\"``. The header is still available and it provides the old "
"names."
msgstr ""
"Makrot :c:macro:`!READONLY` döptes om till :c:macro:`Py_READONLY`. Makrot :c:"
"macro:`!PY_AUDIT_READ` döptes om med prefixet ``Py_``. De nya namnen är nu "
"alltid tillgängliga. Tidigare krävde dessa ``#include \"structmember.h\"``. "
"Headern är fortfarande tillgänglig och den innehåller de gamla namnen."

msgid "Member types"
msgstr "Typer av medlemmar"

msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, it "
"will be converted to the equivalent Python type. When it is set from Python, "
"it will be converted back to the C type. If that is not possible, an "
"exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""
":c:member:`PyMemberDef.type` kan vara ett av följande makron som motsvarar "
"olika C-typer. När medlemmen används i Python konverteras den till "
"motsvarande Python-typ. När den sätts från Python konverteras den tillbaka "
"till C-typen. Om det inte är möjligt, kommer ett undantag som :exc:"
"`TypeError` eller :exc:`ValueError` att uppstå."

msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using e.g. :"
"keyword:`del` or :py:func:`delattr`."
msgstr ""
"Om inte markerat (D), kan attribut som definieras på detta sätt inte raderas "
"med t.ex. :keyword:`del` eller :py:func:`delattr`."

msgid "Macro name"
msgstr "Namn på makro"

msgid "C type"
msgstr "C-typ"

msgid "Python type"
msgstr "Python-typ"

msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

msgid ":py:class:`int`"
msgstr ":py:class:`int`"

msgid ":c:expr:`short`"
msgstr ":c:expr:`kort`"

msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

msgid ":c:expr:`long`"
msgstr ":c:expr:`lång`"

msgid ":c:expr:`long long`"
msgstr ":c:expr:`lång lång`"

msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

msgid ":c:expr:`Py_ssize_t`"
msgstr ":c:expr:`Py_ssize_t`"

msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

msgid ":py:class:`float`"
msgstr ":py:class:`float`"

msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ":c:expr:`char` (skrivs som 0 eller 1)"

msgid ":py:class:`bool`"
msgstr ":py:class:`bool`"

msgid ":c:expr:`const char *` (*)"
msgstr ":c:expr:`const char *` (*)"

msgid ":py:class:`str` (RO)"
msgstr ":py:class:`str` (RO)"

msgid ":c:expr:`const char[]` (*)"
msgstr ":c:expr:`const char[]` (*)"

msgid ":c:expr:`char` (0-127)"
msgstr ":c:expr:`char` (0-127)"

msgid ":py:class:`str` (**)"
msgstr ":py:class:`str` (**)"

msgid ":c:expr:`PyObject *`"
msgstr ":c:expr:`PyObject *`"

msgid ":py:class:`object` (D)"
msgstr ":py:class:`object` (D)"

msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING` "
"the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` the "
"string is stored directly in the structure."
msgstr ""
"(*): Nollavslutad, UTF8-kodad C-sträng. Med :c:macro:`!Py_T_STRING` är C-"
"representationen en pekare; med :c:macro:`!Py_T_STRING_INPLACE` lagras "
"strängen direkt i strukturen."

msgid "(**): String of length 1. Only ASCII is accepted."
msgstr "(**): Sträng med längden 1. Endast ASCII accepteras."

msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr "(RO): Innebär :c:makro:`Py_READONLY`."

msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. Reading a "
"``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""
"(D): Kan raderas, i vilket fall pekaren sätts till ``NULL``. Att läsa en "
"``NULL`` pekare ger upphov till :py:exc:`AttributeError`."

msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, along "
"with the following deprecated types:"
msgstr ""
"I tidigare versioner var makron endast tillgängliga med ``#include "
"\"structmember.h\"`` och namngavs utan prefixet ``Py_`` (t.ex. som "
"``T_INT``). Headern är fortfarande tillgänglig och innehåller de gamla "
"namnen, tillsammans med följande föråldrade typer:"

msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This results "
"in surprising behavior in Python: deleting the attribute effectively sets it "
"to ``None``."
msgstr ""
"Som ``Py_T_OBJECT_EX``, men ``NULL`` konverteras till ``None``. Detta "
"resulterar i ett överraskande beteende i Python: att ta bort attributet "
"sätter det effektivt till ``None``."

msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr "Alltid ``None``. Måste användas med :c:macro:`Py_READONLY`."

msgid "Defining Getters and Setters"
msgstr "Definiera Getters och Setters"

msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Struktur för att definiera egendomsliknande åtkomst för en typ. Se även "
"beskrivning av :c:member:`PyTypeObject.tp_getset` slot."

msgid "attribute name"
msgstr "attributets namn"

msgid "C function to get the attribute."
msgstr "C-funktion för att få fram attributet."

msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr ""
"Valfri C-funktion för att ställa in eller ta bort attributet. Om ``NULL``, "
"är attributet skrivskyddat."

msgid "optional docstring"
msgstr "valfri dokumentsträng"

msgid ""
"Optional user data pointer, providing additional data for getter and setter."
msgstr ""
"Valfri användardatapekare som tillhandahåller ytterligare data för getter "
"och setter."

msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``):"
msgstr ""
"Funktionen ``get`` tar en :c:expr:`PyObject*`-parameter (instansen) och en "
"användardatapekare (den tillhörande ``closure``):"

msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Den ska returnera en ny referens om den lyckas eller ``NULL`` med ett "
"definierat undantag om den misslyckas."

msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``):"
msgstr ""
"``set`` funktioner tar två :c:expr:`PyObject*` parametrar (instansen och "
"värdet som ska ställas in) och en användardatapekare (den tillhörande "
"``closure``):"

msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"Om attributet ska tas bort är den andra parametern ``NULL``. Bör returnera "
"``0`` vid framgång eller ``-1`` med ett angivet undantag vid misslyckande."

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "classmethod"
msgstr "klassmetod"

msgid "staticmethod"
msgstr "statisk metod"

msgid "READ_RESTRICTED (C macro)"
msgstr "READ_RESTRICTED (C-makro)"

msgid "WRITE_RESTRICTED (C macro)"
msgstr "WRITE_RESTRICTED (C-makro)"

msgid "RESTRICTED (C macro)"
msgstr "BEGRÄNSAD (C-makro)"

msgid "READONLY (C macro)"
msgstr "READONLY (C-makro)"

msgid "T_BYTE (C macro)"
msgstr "T_BYTE (C-makro)"

msgid "T_SHORT (C macro)"
msgstr "T_SHORT (C-makro)"

msgid "T_INT (C macro)"
msgstr "T_INT (C-makro)"

msgid "T_LONG (C macro)"
msgstr "T_LONG (C-makro)"

msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG (C-makro)"

msgid "T_UBYTE (C macro)"
msgstr "T_UBYTE (C-makro)"

msgid "T_USHORT (C macro)"
msgstr "T_USHORT (C-makro)"

msgid "T_UINT (C macro)"
msgstr "T_UINT (C-makro)"

msgid "T_ULONG (C macro)"
msgstr "T_ULONG (C-makro)"

msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGULONG (C-makro)"

msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET (C-makro)"

msgid "T_FLOAT (C macro)"
msgstr "T_FLOAT (C-makro)"

msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE (C-makro)"

msgid "T_BOOL (C macro)"
msgstr "T_BOOL (C-makro)"

msgid "T_CHAR (C macro)"
msgstr "T_CHAR (C-makro)"

msgid "T_STRING (C macro)"
msgstr "T_STRING (C-makro)"

msgid "T_STRING_INPLACE (C macro)"
msgstr "T_STRING_INPLACE (C-makro)"

msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX (C-makro)"

msgid "structmember.h"
msgstr "structmember.h"
