# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Enum HOWTO"
msgstr "Enum HOWTO"

msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:`repr`, "
"grouping, type-safety, and a few other features."
msgstr ""
"Ett :class:`Enum` är en uppsättning symboliska namn som är bundna till unika "
"värden.  De liknar globala variabler, men de erbjuder en mer användbar :func:"
"`repr`, gruppering, typsäkerhet och några andra funktioner."

msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"De är mest användbara när du har en variabel som kan ta ett av ett begränsat "
"urval av värden.  Till exempel veckodagarna::"

msgid ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"
msgstr ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"

msgid "Or perhaps the RGB primary colors::"
msgstr "Eller kanske RGB-primärfärgerna::"

msgid ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"
msgstr ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"

msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"Som du kan se är det lika enkelt att skapa en :class:`Enum` som att skriva "
"en klass som ärver från :class:`Enum` själv."

msgid "Case of Enum Members"
msgstr "Fall med Enum-medlemmar"

msgid ""
"Because Enums are used to represent constants, and to help avoid issues with "
"name clashes between mixin-class methods/attributes and enum names, we "
"strongly recommend using UPPER_CASE names for members, and will be using "
"that style in our examples."
msgstr ""
"Eftersom enumer används för att representera konstanter, och för att undvika "
"namnkrockar mellan metoder/attribut i mixin-klasser och enumnamn, "
"rekommenderar vi starkt att du använder UPPER_CASE-namn för medlemmar, och "
"vi kommer att använda den stilen i våra exempel."

msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"Beroende på enumets karaktär kan en medlems värde vara viktigt eller inte, "
"men i vilket fall som helst kan det värdet användas för att få motsvarande "
"medlem::"

msgid ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"
msgstr ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"

msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr ""
"Som du kan se visar ``repr()`` för en medlem enumnamnet, medlemsnamnet och "
"värdet.  ``str()`` för en medlem visar bara enumnamnet och medlemsnamnet::"

msgid ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"
msgstr ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"

msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "*Typen* av en uppräkningsmedlem är den uppräkning som den tillhör::"

msgid ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"
msgstr ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"

msgid "Enum members have an attribute that contains just their :attr:`!name`::"
msgstr ""
"Enum-medlemmar har ett attribut som bara innehåller deras :attr:`!name`::"

msgid ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"
msgstr ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"

msgid "Likewise, they have an attribute for their :attr:`!value`::"
msgstr "På samma sätt har de ett attribut för sin :attr:`!value`::"

msgid ""
">>> Weekday.WEDNESDAY.value\n"
"3"
msgstr ""
">>> Weekday.WEDNESDAY.value\n"
"3"

msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`~datetime.date.weekday` "
"and :meth:`~datetime.date.isoweekday`. The difference is that one of them "
"counts from 0-6 and the other from 1-7. Rather than keep track of that "
"ourselves we can add a method to the :class:`!Weekday` enum to extract the "
"day from the :class:`~datetime.date` instance and return the matching enum "
"member::"
msgstr ""
"Till skillnad från många språk som behandlar uppräkningar enbart som namn/"
"värde-par, kan Python Enums få beteende tillagt.  Till exempel har :class:"
"`datetime.date` två metoder för att returnera veckodagen: :meth:`~datetime."
"date.weekday` och :meth:`~datetime.date.isoweekday`. Skillnaden är att en av "
"dem räknar från 0-6 och den andra från 1-7. Istället för att hålla reda på "
"det själva kan vi lägga till en metod till :class:`!Weekday` enum för att "
"extrahera dagen från :class:`~datetime.date` instansen och returnera den "
"matchande enum medlemmen::"

msgid ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"
msgstr ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"

msgid "The complete :class:`!Weekday` enum now looks like this::"
msgstr "Den kompletta :class:`!Weekday` enum ser nu ut så här::"

msgid ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"
msgstr ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"

msgid "Now we can find out what today is!  Observe::"
msgstr "Nu kan vi ta reda på vad det är för dag!  Observera::"

msgid ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())\n"
"<Weekday.TUESDAY: 2>"
msgstr ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())\n"
"<Weekday.TUESDAY: 2>"

msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr ""
"Om du läser det här någon annan dag får du naturligtvis se den dagen i "
"stället."

msgid ""
"This :class:`!Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"Denna :class:`!Weekday` enum är bra om vår variabel bara behöver en dag, men "
"vad händer om vi behöver flera?  Vi kanske skriver en funktion för att "
"plotta sysslor under en vecka, och vill inte använda en :class:`list` -- vi "
"kan använda en annan typ av :class:`Enum`::"

msgid ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"
msgstr ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"

msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr ""
"Vi har ändrat två saker: vi ärver från :class:`Flag`, och värdena är alla "
"potenser av 2."

msgid ""
"Just like the original :class:`!Weekday` enum above, we can have a single "
"selection::"
msgstr ""
"Precis som i den ursprungliga :class:`!Weekday` enum ovan kan vi ha ett enda "
"val::"

msgid ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"
msgstr ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"

msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""
"Men :class:`Flag` tillåter oss också att kombinera flera medlemmar i en enda "
"variabel::"

msgid ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"
msgstr ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"

msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "Du kan till och med iterera över en :class:`Flag`-variabel::"

msgid ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"
msgstr ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"

msgid "Okay, let's get some chores set up::"
msgstr "Okej, låt oss göra några sysslor::"

msgid ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday."
"FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"
msgstr ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday."
"FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"

msgid "And a function to display the chores for a given day::"
msgstr "Och en funktion för att visa sysslorna för en viss dag::"

msgid ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"
msgstr ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"

msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto` for the values::"
msgstr ""
"I de fall där medlemmarnas faktiska värden inte spelar någon roll kan du "
"spara dig lite arbete och använda :func:`auto` för värdena::"

msgid ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"
msgstr ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"

msgid "Programmatic access to enumeration members and their attributes"
msgstr "Programmatisk åtkomst till uppräkningsmedlemmar och deras attribut"

msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"Ibland är det användbart att komma åt medlemmar i uppräkningar "
"programmatiskt (t.ex. situationer där ``Color.RED`` inte fungerar eftersom "
"den exakta färgen inte är känd vid programskrivningstillfället).  ``Enum`` "
"tillåter sådan åtkomst::"

msgid ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"
msgstr ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"

msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Om du vill komma åt enum-medlemmar med *namn* använder du item access::"

msgid ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"
msgstr ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"

msgid ""
"If you have an enum member and need its :attr:`!name` or :attr:`!value`::"
msgstr ""
"Om du har en enum-medlem och behöver dess :attr:`!name` eller :attr:`!"
"value`::"

msgid ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"
msgstr ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"

msgid "Duplicating enum members and values"
msgstr "Duplicering av enum-medlemmar och -värden"

msgid "Having two enum members with the same name is invalid::"
msgstr "Att ha två enum-medlemmar med samma namn är ogiltigt:"

msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"

msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"En enum-medlem kan dock ha andra namn associerade med sig.  Givet två poster "
"``A`` och ``B`` med samma värde (och ``A`` definierad först), är ``B`` ett "
"alias för medlemmen ``A``.  By-value lookup av värdet på ``A`` kommer att "
"returnera medlemmen ``A``.  By-name lookup av ``A`` kommer att returnera "
"medlemmen ``A``. By-name lookup av ``B`` kommer också att returnera "
"medlemmen ``A``::"

msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"

msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"Det är inte tillåtet att försöka skapa en medlem med samma namn som ett "
"redan definierat attribut (en annan medlem, en metod etc.) eller att försöka "
"skapa ett attribut med samma namn som en medlem."

msgid "Ensuring unique enumeration values"
msgstr "Säkerställa unika uppräkningsvärden"

msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""
"Som standard tillåter uppräkningar flera namn som alias för samma värde. När "
"detta beteende inte är önskvärt kan du använda :func:`unique` dekoratorn::"

msgid ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"
msgstr ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"

msgid "Using automatic values"
msgstr "Använda automatiska värden"

msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "Om det exakta värdet är oviktigt kan du använda :class:`auto`::"

msgid ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"
msgstr ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"

msgid ""
"The values are chosen by :func:`~Enum._generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Värdena väljs av :func:`~Enum._generate_next_value_`, som kan åsidosättas::"

msgid ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"
msgstr ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"

msgid ""
"The :meth:`~Enum._generate_next_value_` method must be defined before any "
"members."
msgstr ""
"Metoden :meth:`~Enum._generate_next_value_` måste definieras före alla "
"medlemmar."

msgid "Iteration"
msgstr "Iteration"

msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "Iterering över medlemmarna i ett enum ger inte alias::"

msgid ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday."
"THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: "
"64>]"
msgstr ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday."
"THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: "
"64>]"

msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr ""
"Observera att aliasen ``Shape.ALIAS_FOR_SQUARE`` och ``Weekday.WEEKEND`` "
"inte visas."

msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"Specialattributet ``__members__`` är en skrivskyddad ordnad mappning av namn "
"till medlemmar.  Den innehåller alla namn som definieras i uppräkningen, "
"inklusive alias::"

msgid ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"
msgstr ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"

msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"Attributet ``__members__`` kan användas för detaljerad programmatisk åtkomst "
"till uppräkningens medlemmar.  Till exempel, hitta alla alias::"

msgid ""
">>> [name for name, member in Shape.__members__.items() if member.name != "
"name]\n"
"['ALIAS_FOR_SQUARE']"
msgstr ""
">>> [name for name, member in Shape.__members__.items() if member.name != "
"name]\n"
"['ALIAS_FOR_SQUARE']"

msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and "
"no flags set, i.e. ``0``."
msgstr ""
"Alias för flaggor inkluderar värden med flera flaggor inställda, t.ex. "
"``3``, och inga flaggor inställda, t.ex. ``0``."

msgid "Comparisons"
msgstr "Jämförelser"

msgid "Enumeration members are compared by identity::"
msgstr "Uppräkningens medlemmar jämförs med hjälp av identity::"

msgid ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"
msgstr ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"

msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Ordnade jämförelser mellan enumerationsvärden stöds *inte*.  Enum-medlemmar "
"är inte heltal (men se `IntEnum`_ nedan)::"

msgid ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"
msgstr ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"

msgid "Equality comparisons are defined though::"
msgstr "Jämlikhetsjämförelser definieras genom::"

msgid ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"
msgstr ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"

msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Jämförelser mot värden som inte är uppräkningsvärden kommer alltid att "
"jämföra inte lika (återigen, :class:`IntEnum` var uttryckligen utformad för "
"att bete sig annorlunda, se nedan)::"

msgid ""
">>> Color.BLUE == 2\n"
"False"
msgstr ""
">>> Color.BLUE == 2\n"
"False"

msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr ""
"Det är möjligt att ladda om moduler - om en omladdad modul innehåller enumer "
"kommer de att återskapas, och de nya medlemmarna kanske inte är identiska/"
"likvärdiga med de ursprungliga medlemmarna."

msgid "Allowed members and attributes of enumerations"
msgstr "Tillåtna medlemmar och attribut för uppräkningar"

msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"I de flesta av exemplen ovan används heltal för uppräkningsvärden.  Att "
"använda heltal är kort och praktiskt (och tillhandahålls som standard av "
"`Functional API`_), men inte strikt påtvingat.  I de allra flesta "
"användningsfall bryr man sig inte om vad det faktiska värdet på en "
"uppräkning är.  Men om värdet *är* viktigt kan uppräkningar ha godtyckliga "
"värden."

msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Uppräkningar är Python-klasser, och kan ha metoder och specialmetoder som "
"vanligt.  Om vi har den här uppräkningen::"

msgid ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # self is the member here\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # cls here is the enumeration\n"
"...         return cls.HAPPY\n"
"..."
msgstr ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # self is the member here\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # cls here is the enumeration\n"
"...         return cls.HAPPY\n"
"..."

msgid "Then::"
msgstr "Sedan::"

msgid ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"
msgstr ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"

msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`~object."
"__str__`, :meth:`~object.__add__`, etc.), descriptors (methods are also "
"descriptors), and variable names listed in :attr:`~Enum._ignore_`."
msgstr ""
"Reglerna för vad som är tillåtet är följande: namn som börjar och slutar med "
"ett enda understreck är reserverade av enum och kan inte användas; alla "
"andra attribut som definieras inom en uppräkning blir medlemmar av denna "
"uppräkning, med undantag för speciella metoder (:meth:`~object.__str__`, :"
"meth:`~object.__add__`, etc.), deskriptorer (metoder är också deskriptorer) "
"och variabelnamn som anges i :attr:`~Enum._ignore_`."

msgid ""
"Note:  if your enumeration defines :meth:`~object.__new__` and/or :meth:"
"`~object.__init__`, any value(s) given to the enum member will be passed "
"into those methods. See `Planet`_ for an example."
msgstr ""
"Obs: om din uppräkning definierar :meth:`~object.__new__` och/eller :meth:"
"`~object.__init__`, kommer alla värden som ges till enum-medlemmen att "
"skickas till dessa metoder. Se `Planet`_ för ett exempel."

msgid ""
"The :meth:`~object.__new__` method, if defined, is used during creation of "
"the Enum members; it is then replaced by Enum's :meth:`~object.__new__` "
"which is used after class creation for lookup of existing members.  See :ref:"
"`new-vs-init` for more details."
msgstr ""
"Metoden :meth:`~object.__new__`, om den är definierad, används vid skapandet "
"av Enum-medlemmarna; den ersätts sedan av Enums :meth:`~object.__new__` som "
"används efter att klassen skapats för uppslagning av befintliga medlemmar.  "
"Se :ref:`new-vs-init` för mer information."

msgid "Restricted Enum subclassing"
msgstr "Begränsad subklassning av Enum"

msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"En ny :class:`Enum`-klass måste ha en bas-enumklass, upp till en konkret "
"datatyp och så många :class:`object`-baserade mixin-klasser som behövs.  "
"Ordningen på dessa basklasser är::"

msgid ""
"class EnumName([mix-in, ...,] [data-type,] base-enum):\n"
"    pass"
msgstr ""
"class EnumName([mix-in, ...,] [data-type,] base-enum):\n"
"    pass"

msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"Dessutom är subklassning av en uppräkning endast tillåten om uppräkningen "
"inte definierar några medlemmar.  Så detta är förbjudet::"

msgid ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"
msgstr ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"

msgid "But this is allowed::"
msgstr "Men detta är tillåtet::"

msgid ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."
msgstr ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."

msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Att tillåta subklassning av enumerationer som definierar medlemmar skulle "
"leda till ett brott mot några viktiga invarianter av typer och instanser.  Å "
"andra sidan är det vettigt att tillåta att en grupp av uppräkningar delar "
"vissa gemensamma beteenden. (Se `OrderedEnum`_ för ett exempel.)"

msgid "Dataclass support"
msgstr "Stöd för dataklasser"

msgid ""
"When inheriting from a :class:`~dataclasses.dataclass`, the :meth:`~Enum."
"__repr__` omits the inherited class' name.  For example::"
msgstr ""
"Vid arv från en :class:`~dataclasses.dataclass` utelämnar :meth:`~Enum."
"__repr__` den ärvda klassens namn.  Till exempel::"

msgid ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"
msgstr ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"

msgid ""
"Use the :func:`~dataclasses.dataclass` argument ``repr=False`` to use the "
"standard :func:`repr`."
msgstr ""
"Använd :func:`~dataclasses.dataclass`-argumentet ``repr=False`` för att "
"använda standard :func:`repr`."

msgid ""
"Only the dataclass fields are shown in the value area, not the dataclass' "
"name."
msgstr "Endast dataklassens fält visas i värdeområdet, inte dataklassens namn."

msgid ""
"Adding :func:`~dataclasses.dataclass` decorator to :class:`Enum` and its "
"subclasses is not supported. It will not raise any errors, but it will "
"produce very strange results at runtime, such as members being equal to each "
"other::"
msgstr ""
"Att lägga till :func:`~dataclasses.dataclass` dekorator till :class:`Enum` "
"och dess underklasser stöds inte. Det kommer inte att ge upphov till några "
"fel, men det kommer att ge mycket konstiga resultat vid körning, till "
"exempel att medlemmar är lika med varandra::"

msgid ""
">>> @dataclass               # don't do this: it does not make any sense\n"
"... class Color(Enum):\n"
"...    RED = 1\n"
"...    BLUE = 2\n"
"...\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED == Color.BLUE  # problem is here: they should not be equal\n"
"True"
msgstr ""
">>> @dataclass               # don't do this: it does not make any sense\n"
"... class Color(Enum):\n"
"...    RED = 1\n"
"...    BLUE = 2\n"
"...\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED == Color.BLUE  # problem is here: they should not be equal\n"
"True"

msgid "Pickling"
msgstr "Inläggning"

msgid "Enumerations can be pickled and unpickled::"
msgstr "Uppräkningar kan vara inlagda och oinlagda::"

msgid ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"
msgstr ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"

msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"De vanliga restriktionerna för pickling gäller: picklbara enumer måste "
"definieras på den översta nivån i en modul, eftersom unpickling kräver att "
"de kan importeras från den modulen."

msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"Med pickle protocol version 4 är det möjligt att enkelt plocka enumer som är "
"inbäddade i andra klasser."

msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`~object.__reduce_ex__` in the enumeration class.  The default method "
"is by-value, but enums with complicated values may want to use by-name::"
msgstr ""
"Det är möjligt att modifiera hur enum-medlemmar syltas/osyltas genom att "
"definiera :meth:`~object.__reduce_ex__` i enumerationsklassen.  "
"Standardmetoden är by-value, men enumerationer med komplicerade värden "
"kanske vill använda by-name::"

msgid ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"
msgstr ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"

msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr ""
"Att använda by-name för flaggor rekommenderas inte, eftersom icke namngivna "
"alias inte kommer att unpickle."

msgid "Functional API"
msgstr "Funktionellt API"

msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"Klassen :class:`Enum` är anropsbar och tillhandahåller följande funktionella "
"API::"

msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"

msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"Semantiken för detta API liknar :class:`~collections.namedtuple`. Det första "
"argumentet i anropet till :class:`Enum` är namnet på uppräkningen."

msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`!Animal` is equivalent to::"
msgstr ""
"Det andra argumentet är *källan* till uppräkningens medlemsnamn.  Det kan "
"vara en namnsträng separerad med vitt mellanrum, en namnsekvens, en sekvens "
"av 2-tupler med nyckel/värde-par eller en mappning (t.ex. en ordbok) av namn "
"till värden.  De två sista alternativen gör det möjligt att tilldela "
"godtyckliga värden till uppräkningar; de övriga tilldelar automatiskt ökande "
"heltal som börjar med 1 (använd parametern ``start`` för att ange ett annat "
"startvärde).  En ny klass som härrör från :class:`Enum` returneras.  Med "
"andra ord, ovanstående tilldelning till :class:`!Animal` är likvärdig med::"

msgid ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."
msgstr ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."

msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"Anledningen till att startnumret som standard är ``1`` och inte ``0`` är att "
"``0`` är ``False`` i boolesk mening, men som standard utvärderas alla enum-"
"medlemmar till ``True``."

msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"Pickling av uppräkningar som skapats med det funktionella API:et kan vara "
"knepigt eftersom implementeringsdetaljer för ramstacken används för att "
"försöka lista ut vilken modul uppräkningen skapas i (t.ex. kommer det att "
"misslyckas om du använder en verktygsfunktion i en separat modul, och kanske "
"inte heller fungerar på IronPython eller Jython). Lösningen är att ange "
"modulnamnet explicit enligt följande::"

msgid ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"
msgstr ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"

msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Om ``module`` inte anges, och Enum inte kan avgöra vad det är, kommer de nya "
"Enum-medlemmarna inte att vara obearbetbara; för att hålla felen närmare "
"källan kommer bearbetningen att avaktiveras."

msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~type.__qualname__` being set to the location where pickle will be able to "
"find the class.  For example, if the class was made available in class "
"SomeData in the global scope::"
msgstr ""
"Det nya pickle-protokollet 4 förlitar sig också, under vissa omständigheter, "
"på att :attr:`~type.__qualname__` anges till den plats där pickle kan hitta "
"klassen.  Till exempel, om klassen gjordes tillgänglig i klassen SomeData i "
"det globala omfånget::"

msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"

msgid "The complete signature is::"
msgstr "Den fullständiga signaturen är::"

msgid ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"
msgstr ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"

msgid "*value*: What the new enum class will record as its name."
msgstr ""
"*värde*: Det som den nya enumklassen kommer att registrera som sitt namn."

msgid ""
"*names*: The enum members.  This can be a whitespace- or comma-separated "
"string (values will start at 1 unless otherwise specified)::"
msgstr ""
"*namn*: Enumets medlemmar.  Detta kan vara en sträng separerad med blanksteg "
"eller kommatecken (värdena börjar på 1 om inget annat anges)::"

msgid "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"
msgstr "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"

msgid "or an iterator of names::"
msgstr "eller en iterator av namn::"

msgid "['RED', 'GREEN', 'BLUE']"
msgstr "['RED', 'GREEN', 'BLUE']"

msgid "or an iterator of (name, value) pairs::"
msgstr "eller en iterator av (namn, värde)-par::"

msgid "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"
msgstr "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"

msgid "or a mapping::"
msgstr "eller en mappning::"

msgid "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"
msgstr "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"

msgid "*module*: name of module where new enum class can be found."
msgstr "*module*: namn på modul där ny enumklass kan hittas."

msgid "*qualname*: where in module new enum class can be found."
msgstr "*qualname*: var i modulen den nya enumklassen kan hittas."

msgid "*type*: type to mix in to new enum class."
msgstr "*type*: typ att blanda in i ny enumklass."

msgid "*start*: number to start counting at if only names are passed in."
msgstr "*start*: nummer att börja räkna med om endast namn skickas in."

msgid "The *start* parameter was added."
msgstr "Parametern *start* har lagts till."

msgid "Derived Enumerations"
msgstr "Härledda uppräkningar"

msgid "IntEnum"
msgstr "IntEnum"

msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"Den första varianten av :class:`Enum` som tillhandahålls är också en "
"subklass av :class:`int`.  Medlemmar i en :class:`IntEnum` kan jämföras med "
"heltal; i förlängningen kan heltalsuppräkningar av olika typer också "
"jämföras med varandra::"

msgid ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"
msgstr ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"

msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"De kan dock fortfarande inte jämföras med vanliga :class:`Enum`-"
"uppräkningar::"

msgid ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"
msgstr ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"

msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ""
":class:`IntEnum`-värden beter sig som heltal på andra sätt som du kan "
"förvänta dig::"

msgid ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"
msgstr ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"

msgid "StrEnum"
msgstr "StrEnum"

msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"Den andra varianten av :class:`Enum` som tillhandahålls är också en subklass "
"av :class:`str`.  Medlemmar i en :class:`StrEnum` kan jämföras med strängar; "
"i förlängningen kan stränguppräkningar av olika typer också jämföras med "
"varandra."

msgid "IntFlag"
msgstr "IntFlag"

msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""
"Nästa variant av :class:`Enum` som tillhandahålls, :class:`IntFlag`, är "
"också baserad på :class:`int`.  Skillnaden är att :class:`IntFlag`-medlemmar "
"kan kombineras med hjälp av bitvisa operatorer (&, \\|, ^, ~) och resultatet "
"är fortfarande en :class:`IntFlag`-medlem, om möjligt.  Liksom :class:"
"`IntEnum` är :class:`IntFlag`-medlemmar också heltal och kan användas var "
"som helst där en :class:`int` används."

msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"Alla operationer på en :class:`IntFlag`-medlem förutom de bitvisa "
"operationerna kommer att förlora :class:`IntFlag`-medlemskapet."

msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"Bitvisa operationer som resulterar i ogiltiga :class:`IntFlag`-värden kommer "
"att förlora :class:`IntFlag`-medlemskapet.  Se :class:`FlagBoundary` för "
"detaljer."

msgid "Sample :class:`IntFlag` class::"
msgstr "Exempel :class:`IntFlag` klass::"

msgid ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"
msgstr ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"

msgid "It is also possible to name the combinations::"
msgstr "Det är också möjligt att namnge kombinationerna::"

msgid ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"
msgstr ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"

msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"Namngivna kombinationer betraktas som alias.  Alias visas inte under "
"iteration, men kan returneras från by-value-uppslagningar."

msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"En annan viktig skillnad mellan :class:`IntFlag` och :class:`Enum` är att om "
"inga flaggor är inställda (värdet är 0), är dess booleska utvärdering :data:"
"`False`::"

msgid ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"
msgstr ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"

msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"Eftersom :class:`IntFlag`-medlemmar också är underklasser till :class:`int` "
"kan de kombineras med dem (men kan förlora :class:`IntFlag`-medlemskap::"

msgid ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"
msgstr ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"

msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""
"Negationsoperatorn, ``~``, returnerar alltid en :class:`IntFlag`-medlem med "
"ett positivt värde::"

msgid ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"
msgstr ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"

msgid ":class:`IntFlag` members can also be iterated over::"
msgstr ":class:`IntFlag`-medlemmar kan också itereras över::"

msgid ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"
msgstr ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"

msgid "Flag"
msgstr "Flagga"

msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"Den sista variationen är :class:`Flag`.  Liksom :class:`IntFlag` kan :class:"
"`Flag`-medlemmar kombineras med hjälp av bitvisa operatorer (&, \\|, ^, ~).  "
"Till skillnad från :class:`IntFlag` kan de inte kombineras med, eller "
"jämföras mot, någon annan :class:`Flag`-uppräkning, eller :class:`int`.  Det "
"är möjligt att ange värdena direkt, men det rekommenderas att använda :class:"
"`auto` som värde och låta :class:`Flag` välja ett lämpligt värde."

msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Liksom :class:`IntFlag`, om en kombination av :class:`Flag`-medlemmar "
"resulterar i att inga flaggor sätts, är den booleska utvärderingen :data:"
"`False`::"

msgid ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"
msgstr ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"

msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags will not::"
msgstr ""
"Enskilda flaggor bör ha värden som är potenser av två (1, 2, 4, 8, ...), "
"medan kombinationer av flaggor inte kommer att ha det:"

msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"

msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Att ge ett namn till villkoret \"inga flaggor satta\" ändrar inte dess "
"booleska värde::"

msgid ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"
msgstr ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"

msgid ":class:`Flag` members can also be iterated over::"
msgstr ":class:`Flag`-medlemmar kan också itereras över::"

msgid ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"
msgstr ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"

msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"För majoriteten av ny kod rekommenderas :class:`Enum` och :class:`Flag` "
"starkt, eftersom :class:`IntEnum` och :class:`IntFlag` bryter några "
"semantiska löften om en uppräkning (genom att vara jämförbara med heltal, "
"och därmed genom transitivitet till andra orelaterade uppräkningar).  :class:"
"`IntEnum` och :class:`IntFlag` bör endast användas i de fall där :class:"
"`Enum` och :class:`Flag` inte räcker till; till exempel när "
"heltalskonstanter ersätts med uppräkningar, eller för interoperabilitet med "
"andra system."

msgid "Others"
msgstr "Andra"

msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Medan :class:`IntEnum` är en del av :mod:`enum`-modulen, skulle det vara "
"mycket enkelt att implementera oberoende::"

msgid ""
"class IntEnum(int, ReprEnum):   # or Enum instead of ReprEnum\n"
"    pass"
msgstr ""
"class IntEnum(int, ReprEnum):   # or Enum instead of ReprEnum\n"
"    pass"

msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`!FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""
"Detta visar hur liknande härledda uppräkningar kan definieras; till exempel "
"en :class:`!FloatEnum` som blandar in :class:`float` istället för :class:"
"`int`."

msgid "Some rules:"
msgstr "Vissa regler:"

msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before the :class:"
"`Enum` class itself in the sequence of bases, as in the :class:`IntEnum` "
"example above."
msgstr ""
"Vid subklassning av :class:`Enum` måste mix-in-typer visas före själva :"
"class:`Enum`-klassen i bassekvensen, som i exemplet med :class:`IntEnum` "
"ovan."

msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""
"Mix-in-typer måste vara underklassbara. Till exempel är :class:`bool` och :"
"class:`range` inte underklassbara och kommer att ge ett felmeddelande under "
"skapandet av Enum om de används som mix-in-typ."

msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"Medan :class:`Enum` kan ha medlemmar av vilken typ som helst, måste alla "
"medlemmar ha värden av den typen när du blandar in en ytterligare typ, t."
"ex. :class:`int` ovan.  Denna begränsning gäller inte för mix-ins som bara "
"lägger till metoder och inte anger någon annan typ."

msgid ""
"When another data type is mixed in, the :attr:`~Enum.value` attribute is "
"*not the same* as the enum member itself, although it is equivalent and will "
"compare equal."
msgstr ""
"När en annan datatyp blandas in är attributet :attr:`~Enum.value` *inte "
"detsamma* som enum-medlemmen i sig, även om det är likvärdigt och kommer att "
"jämföras lika."

msgid ""
"A ``data type`` is a mixin that defines :meth:`~object.__new__`, or a :class:"
"`~dataclasses.dataclass`"
msgstr ""
"En \"datatyp\" är en mixin som definierar :meth:`~object.__new__`, eller en :"
"class:`~dataclasses.dataclass`"

msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`~object.__str__` and :meth:`~object.__repr__` respectively; other codes "
"(such as ``%i`` or ``%h`` for IntEnum) treat the enum member as its mixed-in "
"type."
msgstr ""
"%-style formatering:  ``%s`` och ``%r`` anropar :class:`Enum`-klassens :meth:"
"`~object.__str__` respektive :meth:`~object.__repr__`; andra koder (som "
"``%i`` eller ``%h`` för IntEnum) behandlar enum-medlemmen som dess mixade "
"typ."

msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`~object.__str__` method."
msgstr ""
":ref:`Formaterade stränglitteraler <f-strings>`, :meth:`str.format`, och :"
"func:`format` kommer att använda enumets :meth:`~object.__str__` metod."

msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`~object.__str__` method has been reset to their data types' :meth:`~object."
"__str__` method."
msgstr ""
"Eftersom :class:`IntEnum`, :class:`IntFlag` och :class:`StrEnum` är "
"utformade för att ersätta befintliga konstanter har deras :meth:`~object."
"__str__`-metod återställts till deras datatypers :meth:`~object.__str__`-"
"metod."

msgid "When to use :meth:`~object.__new__` vs. :meth:`~object.__init__`"
msgstr ""
"När ska man använda :meth:`~object.__new__` vs. :meth:`~object.__init__`"

msgid ""
":meth:`~object.__new__` must be used whenever you want to customize the "
"actual value of the :class:`Enum` member.  Any other modifications may go in "
"either :meth:`~object.__new__` or :meth:`~object.__init__`, with :meth:"
"`~object.__init__` being preferred."
msgstr ""
":meth:`~object.__new__` måste användas när du vill anpassa det faktiska "
"värdet för medlemmen :class:`Enum`.  Alla andra ändringar kan göras i "
"antingen :meth:`~object.__new__` eller :meth:`~object.__init__`, där :meth:"
"`~object.__init__` är att föredra."

msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Om du t.ex. vill skicka flera objekt till konstruktören, men bara vill att "
"ett av dem ska vara värdet::"

msgid ""
">>> class Coordinate(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Coordinate with binary codes that can be indexed by the int code.\n"
"...     \"\"\"\n"
"...     def __new__(cls, value, label, unit):\n"
"...         obj = bytes.__new__(cls, [value])\n"
"...         obj._value_ = value\n"
"...         obj.label = label\n"
"...         obj.unit = unit\n"
"...         return obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Coordinate['PY'])\n"
"Coordinate.PY\n"
"\n"
">>> print(Coordinate(3))\n"
"Coordinate.VY"
msgstr ""
">>> klass Koordinat(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Koordinat med binära koder som kan indexeras med int-koden.\n"
"...     \"\"\"\n"
"... def __new__(cls, värde, etikett, enhet):\n"
"... obj = bytes.__new__(cls, [värde])\n"
"... obj._värde_ = värde\n"
"... obj.label = etikett\n"
"... obj.unit = enhet\n"
"... returnera obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Koordinat['PY'])\n"
"Koordinat.PY\n"
"\n"
">>> print(Koordinat(3))\n"
"Koordinat.VY"

msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly."
msgstr ""
"*Anropa inte ``super().__new__()``, eftersom det är ``__new__`` som bara "
"hittas vid uppslagning; använd i stället datatypen direkt."

msgid "Finer Points"
msgstr "Finare punkter"

msgid "Supported ``__dunder__`` names"
msgstr "Namn som stöds för ``__dunder__``"

msgid ""
":attr:`~enum.EnumType.__members__` is a read-only ordered mapping of "
"``member_name``:``member`` items.  It is only available on the class."
msgstr ""
":attr:`~enum.EnumType.__members__` är en skrivskyddad ordnad mappning av "
"``member_name``:``member`` objekt.  Den är endast tillgänglig för klassen."

msgid ""
":meth:`~object.__new__`, if specified, must create and return the enum "
"members; it is also a very good idea to set the member's :attr:`~Enum."
"_value_` appropriately.  Once all the members are created it is no longer "
"used."
msgstr ""
":meth:`~object.__new__`, om det anges, måste skapa och returnera enum-"
"medlemmarna; det är också en mycket bra idé att ställa in medlemmens :attr:"
"`~Enum._value_` på lämpligt sätt.  När alla medlemmar har skapats används "
"den inte längre."

msgid "Supported ``_sunder_`` names"
msgstr "Namn med stöd för ``_sunder_``"

msgid ":attr:`~Enum._name_` -- name of the member"
msgstr ":attr:`~Enum._name_` -- namnet på medlemmen"

msgid ":attr:`~Enum._value_` -- value of the member; can be set in ``__new__``"
msgstr ""
":attr:`~Enum._value_` -- medlemmens värde; kan ställas in i ``__new__``"

msgid ""
":meth:`~Enum._missing_` -- a lookup function used when a value is not found; "
"may be overridden"
msgstr ""
":meth:`~Enum._missing_` -- en uppslagningsfunktion som används när ett värde "
"inte hittas; kan åsidosättas"

msgid ""
":attr:`~Enum._ignore_` -- a list of names, either as a :class:`list` or a :"
"class:`str`, that will not be transformed into members, and will be removed "
"from the final class"
msgstr ""
":attr:`~Enum._ignore_` -- en lista med namn, antingen som en :class:`list` "
"eller en :class:`str`, som inte kommer att omvandlas till medlemmar och som "
"kommer att tas bort från den slutliga klassen"

msgid ""
":meth:`~Enum._generate_next_value_` -- used to get an appropriate value for "
"an enum member; may be overridden"
msgstr ""
":meth:`~Enum._generate_next_value_` -- används för att få ett lämpligt värde "
"för en enum-medlem; kan åsidosättas"

msgid ""
":meth:`~EnumType._add_alias_` -- adds a new name as an alias to an existing "
"member."
msgstr ""
":meth:`~EnumType._add_alias_` -- lägger till ett nytt namn som alias till en "
"befintlig medlem."

msgid ""
":meth:`~EnumType._add_value_alias_` -- adds a new value as an alias to an "
"existing member.  See `MultiValueEnum`_ for an example."
msgstr ""
":meth:`~EnumType._add_value_alias_` -- lägger till ett nytt värde som ett "
"alias till en befintlig medlem.  Se `MultiValueEnum`_ för ett exempel."

msgid ""
"For standard :class:`Enum` classes the next value chosen is the highest "
"value seen incremented by one."
msgstr ""
"För standardklasserna :class:`Enum` är nästa värde som väljs det högsta "
"värde som setts, ökat med ett."

msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two."
msgstr ""
"För klasserna :class:`Flag` kommer nästa värde som väljs att vara den näst "
"högsta tvåpotensen."

msgid ""
"Prior versions would use the last seen value instead of the highest value."
msgstr ""
"I tidigare versioner användes det senast sedda värdet i stället för det "
"högsta värdet."

msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

msgid "``_ignore_``"
msgstr "``_ignore_``"

msgid "``_add_alias_``, ``_add_value_alias_``"
msgstr "``_add_alias_``, ``_add_value_alias_``"

msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`~Enum._order_` "
"attribute can be provided.  It will be checked against the actual order of "
"the enumeration and raise an error if the two do not match::"
msgstr ""
"För att hjälpa till att hålla Python 2 / Python 3-koden synkroniserad kan "
"ett :attr:`~Enum._order_`-attribut tillhandahållas.  Det kommer att "
"kontrolleras mot den faktiska ordningen i uppräkningen och ge upphov till "
"ett fel om de två inte matchar varandra:"

msgid ""
">>> class Color(Enum):\n"
"...     _order_ = 'RED GREEN BLUE'\n"
"...     RED = 1\n"
"...     BLUE = 3\n"
"...     GREEN = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: member order does not match _order_:\n"
"  ['RED', 'BLUE', 'GREEN']\n"
"  ['RED', 'GREEN', 'BLUE']"
msgstr ""
">>> klass Färg(Enum):\n"
"...     _order_ = 'RÖD GRÖN BLÅ'\n"
"...     RED = 1\n"
"...     BLÅ = 3\n"
"...     GRÖN = 2\n"
"...\n"
"Återkoppling (senaste anropet senast):\n"
"...\n"
"TypeError: medlemsordningen matchar inte _order_:\n"
"  ['RÖD', 'BLÅ', 'GRÖN']\n"
"  ['RÖD', 'GRÖN', 'BLÅ']"

msgid ""
"In Python 2 code the :attr:`~Enum._order_` attribute is necessary as "
"definition order is lost before it can be recorded."
msgstr ""
"I Python 2-koden är attributet :attr:`~Enum._order_` nödvändigt eftersom "
"definitionsordningen går förlorad innan den kan registreras."

msgid "_Private__names"
msgstr "_Private__names"

msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""
":ref:`Privata namn <private-name-mangling>` konverteras inte till enum-"
"medlemmar, utan förblir normala attribut."

msgid "``Enum`` member type"
msgstr "``Enum`` medlemstyp"

msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported; however, in order to avoid name clashes between member "
"names and attributes/methods from mixed-in classes, upper-case names are "
"strongly recommended."
msgstr ""
"Enum-medlemmar är instanser av sin enum-klass och nås normalt som "
"``EnumClass.member``.  I vissa situationer, t.ex. när man skriver ett "
"anpassat enum-beteende, är det användbart att kunna komma åt en medlem "
"direkt från en annan, och detta stöds; för att undvika namnkrockar mellan "
"medlemsnamn och attribut/metoder från blandade klasser rekommenderas dock "
"starkt versaler."

msgid "Creating members that are mixed with other data types"
msgstr "Skapa medlemmar som blandas med andra datatyper"

msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"När man subklassar andra datatyper, t.ex. :class:`int` eller :class:`str`, "
"med :class:`Enum`, skickas alla värden efter ``=`` till datatypens "
"konstruktör.  Till exempel::"

msgid ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # so x='11' and base=16\n"
"...\n"
">>> MyEnum.example.value        # and hex(11) is...\n"
"17"
msgstr ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # so x='11' and base=16\n"
"...\n"
">>> MyEnum.example.value        # and hex(11) is...\n"
"17"

msgid "Boolean value of ``Enum`` classes and members"
msgstr "Booleskt värde för klasser och medlemmar i ``Enum``"

msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"Enumklasser som blandas med icke:class:`Enum`-typer (t.ex. :class:`int`, :"
"class:`str`, etc.) utvärderas enligt den blandade typens regler; annars "
"utvärderas alla medlemmar som :data:`True`.  För att göra din egen enums "
"booleska utvärdering beroende av medlemmens värde, lägg till följande i din "
"klass::"

msgid ""
"def __bool__(self):\n"
"    return bool(self.value)"
msgstr ""
"def __bool__(self):\n"
"    return bool(self.value)"

msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "Vanliga :class:`Enum`-klasser utvärderas alltid som :data:`True`."

msgid "``Enum`` classes with methods"
msgstr "``Enum`` klasser med metoder"

msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""
"Om du ger din enum-underklass extra metoder, som klassen `Planet`_ nedan, "
"kommer dessa metoder att dyka upp i en :func:`dir` för medlemmen, men inte "
"för klassen::"

msgid ""
">>> dir(Planet)\n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', "
"'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)\n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', "
"'surface_gravity', 'value']"
msgstr ""
">>> dir(Planet)\n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', "
"'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)\n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', "
"'surface_gravity', 'value']"

msgid "Combining members of ``Flag``"
msgstr "Kombinerar medlemmar av ``Flag``"

msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""
"Iterering över en kombination av :class:`Flag`-medlemmar kommer endast att "
"returnera de medlemmar som består av en enda bit::"

msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  # named combination\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # not named combination\n"
"<Color.RED|GREEN|BLUE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  # named combination\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # not named combination\n"
"<Color.RED|GREEN|BLUE: 7>"

msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "minutia för \"Flagg\" och \"IntFlagg"

msgid "Using the following snippet for our examples::"
msgstr "Använd följande snutt för våra exempel::"

msgid ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."
msgstr ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."

msgid "the following are true:"
msgstr "följande är sant:"

msgid "single-bit flags are canonical"
msgstr "enbitsflaggor är kanoniska"

msgid "multi-bit and zero-bit flags are aliases"
msgstr "multibit- och nollbitflaggor är alias"

msgid "only canonical flags are returned during iteration::"
msgstr "endast kanoniska flaggor returneras under iteration::"

msgid ""
">>> list(Color.WHITE)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> list(Color.WHITE)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"

msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""
"negering av en flagga eller flagguppsättning ger en ny flagga/"
"flagguppsättning med motsvarande positiva heltalsvärde::"

msgid ""
">>> Color.BLUE\n"
"<Color.BLUE: 4>\n"
"\n"
">>> ~Color.BLUE\n"
"<Color.RED|GREEN: 3>"
msgstr ""
">>> Color.BLUE\n"
"<Color.BLUE: 4>\n"
"\n"
">>> ~Color.BLUE\n"
"<Color.RED|GREEN: 3>"

msgid "names of pseudo-flags are constructed from their members' names::"
msgstr "namn på pseudoflaggor konstrueras från deras medlemmars namn::"

msgid ""
">>> (Color.RED | Color.GREEN).name\n"
"'RED|GREEN'\n"
"\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> (Perm.R & Perm.W).name is None  # effectively Perm(0)\n"
"True"
msgstr ""
">>> (Color.RED | Color.GREEN).name\n"
"'RED|GREEN'\n"
"\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> (Perm.R & Perm.W).name is None  # effectively Perm(0)\n"
"True"

msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr "multi-bit flaggor, aka alias, kan returneras från operationer::"

msgid ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"
msgstr ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"

msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr ""
"kontroll av medlemskap / inneslutning: nollvärdesflaggor anses alltid vara "
"inneslutna::"

msgid ""
">>> Color.BLACK in Color.WHITE\n"
"True"
msgstr ""
">>> Color.BLACK in Color.WHITE\n"
"True"

msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr ""
"annars, endast om alla bitar i en flagga är i den andra flaggan kommer True "
"att returneras::"

msgid ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"
msgstr ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"

msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"Det finns en ny boundary-mekanism som styr hur out-of-range / ogiltiga bitar "
"hanteras: ``STRICT``, ``CONFORM``, ``EJECT`` och ``KEEP``:"

msgid "STRICT --> raises an exception when presented with invalid values"
msgstr ""
"STRICT --> ger upphov till ett undantag när ogiltiga värden presenteras"

msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> förkastar alla ogiltiga bitar"

msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""
"EJECT --> förlorar Flag-status och blir en normal int med det angivna värdet"

msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> behåll de extra bitarna"

msgid "keeps Flag status and extra bits"
msgstr "håller Flaggstatus och extra bitar"

msgid "extra bits do not show up in iteration"
msgstr "extra bitar dyker inte upp i iterationen"

msgid "extra bits do show up in repr() and str()"
msgstr "extra bitar dyker upp i repr() och str()"

msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"Standardvärdet för Flag är ``STRICT``, standardvärdet för ``IntFlag`` är "
"``EJECT`` och standardvärdet för ``_convert_`` är ``KEEP`` (se ``ssl."
"Options`` för ett exempel på när ``KEEP`` behövs)."

msgid "How are Enums and Flags different?"
msgstr "Hur skiljer sig Enums och Flags åt?"

msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"Enum har en egen metaklass som påverkar många aspekter av både härledda :"
"class:`Enum`-klasser och deras instanser (medlemmar)."

msgid "Enum Classes"
msgstr "Enumklasser"

msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`~object.__contains__`, :meth:`~object.__dir__`, :meth:`~object.__iter__` "
"and other methods that allow one to do things with an :class:`Enum` class "
"that fail on a typical class, such as ``list(Color)`` or ``some_enum_var in "
"Color``.  :class:`EnumType` is responsible for ensuring that various other "
"methods on the final :class:`Enum` class are correct (such as :meth:`~object."
"__new__`, :meth:`~object.__getnewargs__`, :meth:`~object.__str__` and :meth:"
"`~object.__repr__`)."
msgstr ""
"Metaklassen :class:`EnumType` ansvarar för att tillhandahålla metoderna :"
"meth:`~object.__contains__`, :meth:`~object.__dir__`, :meth:`~object."
"__iter__` och andra metoder som gör att man kan göra saker med en :class:"
"`Enum`-klass som misslyckas med en vanlig klass, till exempel "
"``list(Color)`` eller ``some_enum_var in Color``.  :class:`EnumType` är "
"ansvarig för att säkerställa att olika andra metoder på den slutliga :class:"
"`Enum` klassen är korrekta (såsom :meth:`~object.__new__`, :meth:`~object."
"__getnewargs__`, :meth:`~object.__str__` och :meth:`~object.__repr__`)."

msgid "Flag Classes"
msgstr "Flaggklasser"

msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value (a.k."
"a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"Flaggor har en utvidgad syn på alias: för att vara kanonisk måste värdet på "
"en flagga vara ett värde i tvåpotens och inte ett duplicerat namn.  Så, "
"utöver :class:`Enum` definitionen av alias, anses en flagga utan värde (a.k."
"a. ``0``) eller med mer än ett tvåpotensvärde (t.ex. ``3``) vara ett alias."

msgid "Enum Members (aka instances)"
msgstr "Enum-medlemmar (även kallade instanser)"

msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`~object.__new__` in place to ensure "
"that no new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Det mest intressanta med enum-medlemmar är att de är singletons. :class:"
"`EnumType` skapar dem alla när den skapar enum-klassen själv, och sätter "
"sedan en anpassad :meth:`~object.__new__` på plats för att säkerställa att "
"inga nya någonsin instansieras genom att endast returnera de befintliga "
"medlemsinstanserna."

msgid "Flag Members"
msgstr "Flaggmedlemmar"

msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr ""
"Flaggmedlemmar kan itereras över precis som i klassen :class:`Flag`, och "
"endast de kanoniska medlemmarna returneras.  Till exempel::"

msgid ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"

msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr "(Observera att ``BLACK``, ``PURPLE`` och ``WHITE`` inte förekommer)"

msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr ""
"Om du inverterar en flaggmedlem returneras motsvarande positiva värde, "
"snarare än ett negativt värde --- till exempel::"

msgid ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"
msgstr ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"

msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr ""
"Flaggmedlemmar har en längd som motsvarar antalet tvåpotensvärden de "
"innehåller.  Till exempel::"

msgid ""
">>> len(Color.PURPLE)\n"
"2"
msgstr ""
">>> len(Color.PURPLE)\n"
"2"

msgid "Enum Cookbook"
msgstr "Enum kokbok"

msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
"Även om :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag` "
"och :class:`IntFlag` förväntas täcka de flesta användningsfall, kan de inte "
"täcka alla.  Här finns recept på några olika typer av uppräkningar som kan "
"användas direkt eller som exempel för att skapa egna."

msgid "Omitting values"
msgstr "Utelämnande av värden"

msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"I många användningsfall bryr man sig inte om vad det faktiska värdet på en "
"uppräkning är. Det finns flera sätt att definiera den här typen av enkla "
"uppräkningar:"

msgid "use instances of :class:`auto` for the value"
msgstr "använda instanser av :class:`auto` för värdet"

msgid "use instances of :class:`object` as the value"
msgstr "använda instanser av :class:`object` som värde"

msgid "use a descriptive string as the value"
msgstr "använda en beskrivande sträng som värde"

msgid ""
"use a tuple as the value and a custom :meth:`~object.__new__` to replace the "
"tuple with an :class:`int` value"
msgstr ""
"använda en tupel som värde och en anpassad :meth:`~object.__new__` för att "
"ersätta tupeln med ett :class:`int`-värde"

msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"Genom att använda någon av dessa metoder signalerar man till användaren att "
"dessa värden inte är viktiga och gör det också möjligt att lägga till, ta "
"bort eller ändra ordning på medlemmar utan att behöva numrera om de "
"återstående medlemmarna."

msgid "Using :class:`auto`"
msgstr "Använda :class:`auto`"

msgid "Using :class:`auto` would look like::"
msgstr "Att använda :class:`auto` skulle se ut så här::"

msgid ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"

msgid "Using :class:`object`"
msgstr "Använda :class:`object`"

msgid "Using :class:`object` would look like::"
msgstr "Att använda :class:`object` skulle se ut så här::"

msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: <object object at 0x...>>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: <object object at 0x...>>"

msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`~object.__repr__`::"
msgstr ""
"Detta är också ett bra exempel på varför du kanske vill skriva din egen :"
"meth:`~object.__repr__`::"

msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"

msgid "Using a descriptive string"
msgstr "Använda en beskrivande sträng"

msgid "Using a string as the value would look like::"
msgstr "Om du använder en sträng som värde skulle det se ut så här::"

msgid ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"

msgid "Using a custom :meth:`~object.__new__`"
msgstr "Använda en anpassad :meth:`~object.__new__``"

msgid "Using an auto-numbering :meth:`~object.__new__` would look like::"
msgstr ""
"Om man använder en automatisk numrering :meth:`~object.__new__` skulle det "
"se ut så här::"

msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"

msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"För att skapa ett mer allmänt ``AutoNumber``, lägg till ``*args`` till "
"signaturen::"

msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # this is the only change from above\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # this is the only change from above\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."

msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"När du sedan ärver från ``AutoNumber`` kan du skriva din egen ``__init__`` "
"för att hantera eventuella extra argument::"

msgid ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # New color, no Pantone code yet!\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"
msgstr ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # New color, no Pantone code yet!\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"

msgid ""
"The :meth:`~object.__new__` method, if defined, is used during creation of "
"the Enum members; it is then replaced by Enum's :meth:`~object.__new__` "
"which is used after class creation for lookup of existing members."
msgstr ""
"Metoden :meth:`~object.__new__`, om den är definierad, används vid skapandet "
"av Enum-medlemmarna; den ersätts sedan av Enums :meth:`~object.__new__` som "
"används efter klassens skapande för uppslagning av befintliga medlemmar."

msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly -- e.g.::"
msgstr ""
"*Anropa inte ``super().__new__()``, eftersom det är ``__new__`` som bara "
"hittas vid uppslagning; använd i stället datatypen direkt -- t.ex.::"

msgid "obj = int.__new__(cls, value)"
msgstr "obj = int.__new__(cls, value)"

msgid "OrderedEnum"
msgstr "BeställdEnum"

msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"En ordnad uppräkning som inte är baserad på :class:`IntEnum` och som därför "
"bibehåller de normala :class:`Enum`-invarianterna (t.ex. att den inte är "
"jämförbar med andra uppräkningar)::"

msgid ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"
msgstr ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"

msgid "DuplicateFreeEnum"
msgstr "DuplikatFriEnum"

msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr ""
"Utlöser ett fel om ett duplicerat medlemsvärde hittas istället för att skapa "
"ett alias::"

msgid ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> "
"%r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"
msgstr ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> "
"%r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"

msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Detta är ett användbart exempel på subklassning av Enum för att lägga till "
"eller ändra andra beteenden samt för att inte tillåta alias.  Om den enda "
"önskade ändringen är att inte tillåta alias kan dekoratorn :func:`unique` "
"användas istället."

msgid "MultiValueEnum"
msgstr "MultiValueEnum"

msgid "Supports having more than one value per member::"
msgstr "Stöder att ha mer än ett värde per medlem::"

msgid ""
">>> class MultiValueEnum(Enum):\n"
"...     def __new__(cls, value, *values):\n"
"...         self = object.__new__(cls)\n"
"...         self._value_ = value\n"
"...         for v in values:\n"
"...             self._add_value_alias_(v)\n"
"...         return self\n"
"...\n"
">>> class DType(MultiValueEnum):\n"
"...     float32 = 'f', 8\n"
"...     double64 = 'd', 9\n"
"...\n"
">>> DType('f')\n"
"<DType.float32: 'f'>\n"
">>> DType(9)\n"
"<DType.double64: 'd'>"
msgstr ""
">>> class MultiValueEnum(Enum):\n"
"...     def __new__(cls, value, *values):\n"
"...         self = object.__new__(cls)\n"
"...         self._value_ = value\n"
"...         for v in values:\n"
"...             self._add_value_alias_(v)\n"
"...         return self\n"
"...\n"
">>> class DType(MultiValueEnum):\n"
"...     float32 = 'f', 8\n"
"...     double64 = 'd', 9\n"
"...\n"
">>> DType('f')\n"
"<DType.float32: 'f'>\n"
">>> DType(9)\n"
"<DType.double64: 'd'>"

msgid "Planet"
msgstr "Planet"

msgid ""
"If :meth:`~object.__new__` or :meth:`~object.__init__` is defined, the value "
"of the enum member will be passed to those methods::"
msgstr ""
"Om :meth:`~object.__new__` eller :meth:`~object.__init__` är definierade, "
"kommer enum-medlemmens värde att skickas till dessa metoder::"

msgid ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"
msgstr ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"

msgid "TimePeriod"
msgstr "TidPeriod"

msgid "An example to show the :attr:`~Enum._ignore_` attribute in use::"
msgstr "Ett exempel som visar hur attributet :attr:`~Enum._ignore_` används::"

msgid ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime."
"timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime."
"timedelta(days=366)>]"
msgstr ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime."
"timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime."
"timedelta(days=366)>]"

msgid "Subclassing EnumType"
msgstr "Underklassificering av EnumType"

msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"Medan de flesta enum-behov kan tillgodoses genom att anpassa :class:`Enum`-"
"subklasser, antingen med klassdekoratorer eller anpassade funktioner, kan :"
"class:`EnumType` subklassas för att ge en annan Enum-upplevelse."
