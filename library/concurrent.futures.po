# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!concurrent.futures` --- Launching parallel tasks"
msgstr ":mod:`!concurrent.futures` --- Starta parallella uppgifter"

msgid ""
"**Source code:** :source:`Lib/concurrent/futures/thread.py`, :source:`Lib/"
"concurrent/futures/process.py`, and :source:`Lib/concurrent/futures/"
"interpreter.py`"
msgstr ""
"**Källkod:** :source:`Lib/concurrent/futures/thread.py`, :source:`Lib/"
"concurrent/futures/process.py`, och :source:`Lib/concurrent/futures/"
"interpreter.py`"

msgid ""
"The :mod:`concurrent.futures` module provides a high-level interface for "
"asynchronously executing callables."
msgstr ""
"Modulen :mod:`concurrent.futures` tillhandahåller ett gränssnitt på hög nivå "
"för asynkron exekvering av anropbara filer."

msgid ""
"The asynchronous execution can be performed with threads, using :class:"
"`ThreadPoolExecutor` or :class:`InterpreterPoolExecutor`, or separate "
"processes, using :class:`ProcessPoolExecutor`. Each implements the same "
"interface, which is defined by the abstract :class:`Executor` class."
msgstr ""
"Den asynkrona exekveringen kan utföras med trådar, med hjälp av :class:"
"`ThreadPoolExecutor` eller :class:`InterpreterPoolExecutor`, eller separata "
"processer, med hjälp av :class:`ProcessPoolExecutor`. Alla implementerar "
"samma gränssnitt, som definieras av den abstrakta klassen :class:`Executor`."

msgid "Availability"
msgstr "Tillgänglighet"

msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Den här modulen fungerar inte eller är inte tillgänglig på WebAssembly. Se :"
"ref:`wasm-availability` för mer information."

msgid "Executor Objects"
msgstr "Exekverande objekt"

msgid ""
"An abstract class that provides methods to execute calls asynchronously.  It "
"should not be used directly, but through its concrete subclasses."
msgstr ""
"En abstrakt klass som tillhandahåller metoder för att exekvera anrop "
"asynkront.  Den bör inte användas direkt, utan genom sina konkreta "
"underklasser."

msgid ""
"Schedules the callable, *fn*, to be executed as ``fn(*args, **kwargs)`` and "
"returns a :class:`Future` object representing the execution of the "
"callable. ::"
msgstr ""
"Schemalägger anropbarheten *fn* så att den exekveras som ``fn(*args, "
"**kwargs)`` och returnerar ett :class:`Future`-objekt som representerar "
"exekveringen av anropbarheten. ::"

msgid ""
"with ThreadPoolExecutor(max_workers=1) as executor:\n"
"    future = executor.submit(pow, 323, 1235)\n"
"    print(future.result())"
msgstr ""
"med ThreadPoolExecutor(max_workers=1) som executor:\n"
"    future = executor.submit(pow, 323, 1235)\n"
"    print(future.result())"

msgid "Similar to :func:`map(fn, *iterables) <map>` except:"
msgstr "Liknar :func:`map(fn, *iterables) <map>` förutom:"

msgid ""
"The *iterables* are collected immediately rather than lazily, unless a "
"*buffersize* is specified to limit the number of submitted tasks whose "
"results have not yet been yielded. If the buffer is full, iteration over the "
"*iterables* pauses until a result is yielded from the buffer."
msgstr ""
"*iterables* samlas in omedelbart och inte slentrianmässigt, såvida inte en "
"*buffersize* har angetts för att begränsa antalet inlämnade uppgifter vars "
"resultat ännu inte har hämtats. Om bufferten är full pausas iterationen över "
"*iterables* tills ett resultat hämtas från bufferten."

msgid ""
"*fn* is executed asynchronously and several calls to *fn* may be made "
"concurrently."
msgstr ""
"*fn* exekveras asynkront och flera anrop till *fn* kan göras samtidigt."

msgid ""
"The returned iterator raises a :exc:`TimeoutError` if :meth:`~iterator."
"__next__` is called and the result isn't available after *timeout* seconds "
"from the original call to :meth:`Executor.map`. *timeout* can be an int or a "
"float.  If *timeout* is not specified or ``None``, there is no limit to the "
"wait time."
msgstr ""
"Den returnerade iteratorn ger upphov till ett :exc:`TimeoutError` om :meth:"
"`~iterator.__next__` anropas och resultatet inte är tillgängligt efter "
"*timeout* sekunder från det ursprungliga anropet till :meth:`Executor.map`. "
"*timeout* kan vara en int eller en float.  Om *timeout* inte anges eller "
"``None``, finns det ingen gräns för väntetiden."

msgid ""
"If a *fn* call raises an exception, then that exception will be raised when "
"its value is retrieved from the iterator."
msgstr ""
"Om ett *fn*-anrop ger upphov till ett undantag, kommer detta undantag att "
"uppstå när dess värde hämtas från iteratorn."

msgid ""
"When using :class:`ProcessPoolExecutor`, this method chops *iterables* into "
"a number of chunks which it submits to the pool as separate tasks.  The "
"(approximate) size of these chunks can be specified by setting *chunksize* "
"to a positive integer.  For very long iterables, using a large value for "
"*chunksize* can significantly improve performance compared to the default "
"size of 1.  With :class:`ThreadPoolExecutor` and :class:"
"`InterpreterPoolExecutor`, *chunksize* has no effect."
msgstr ""
"När :class:`ProcessPoolExecutor` används, delar denna metod upp *iterables* "
"i ett antal bitar som sedan skickas till poolen som separata uppgifter.  Den "
"(ungefärliga) storleken på dessa bitar kan anges genom att *chunksize* sätts "
"till ett positivt heltal.  För mycket långa iterabler kan ett stort värde "
"för *chunksize* förbättra prestandan avsevärt jämfört med standardstorleken "
"1. Med :class:`ThreadPoolExecutor` och :class:`InterpreterPoolExecutor` har "
"*chunksize* ingen effekt."

msgid "Added the *chunksize* parameter."
msgstr "Lagt till parametern *chunksize*."

msgid "Added the *buffersize* parameter."
msgstr "Parametern *buffersize* har lagts till."

msgid ""
"Signal the executor that it should free any resources that it is using when "
"the currently pending futures are done executing.  Calls to :meth:`Executor."
"submit` and :meth:`Executor.map` made after shutdown will raise :exc:"
"`RuntimeError`."
msgstr ""
"Signalerar till exekutorn att den ska frigöra alla resurser som den använder "
"när de aktuella väntande futures är klara med exekveringen.  Anrop till :"
"meth:`Executor.submit` och :meth:`Executor.map` som görs efter nedstängning "
"kommer att ge upphov till :exc:`RuntimeError`."

msgid ""
"If *wait* is ``True`` then this method will not return until all the pending "
"futures are done executing and the resources associated with the executor "
"have been freed.  If *wait* is ``False`` then this method will return "
"immediately and the resources associated with the executor will be freed "
"when all pending futures are done executing.  Regardless of the value of "
"*wait*, the entire Python program will not exit until all pending futures "
"are done executing."
msgstr ""
"Om *wait* är ``True`` kommer denna metod inte att returneras förrän alla "
"väntande futures har exekverats och de resurser som är associerade med "
"exekveraren har frigjorts.  Om *wait* är ``False`` kommer denna metod att "
"returneras omedelbart och resurserna som är associerade med exekveraren "
"kommer att frigöras när alla väntande futures har exekverats.  Oavsett "
"värdet på *wait* kommer hela Python-programmet inte att avslutas förrän alla "
"väntande futures har exekverats."

msgid ""
"If *cancel_futures* is ``True``, this method will cancel all pending futures "
"that the executor has not started running. Any futures that are completed or "
"running won't be cancelled, regardless of the value of *cancel_futures*."
msgstr ""
"Om *cancel_futures* är ``True``, kommer denna metod att avbryta alla "
"väntande futures som exekutören inte har börjat köra. Eventuella terminer "
"som är avslutade eller körs kommer inte att annulleras, oavsett värdet på "
"*cancel_futures*."

msgid ""
"If both *cancel_futures* and *wait* are ``True``, all futures that the "
"executor has started running will be completed prior to this method "
"returning. The remaining futures are cancelled."
msgstr ""
"Om både *cancel_futures* och *wait* är ``True``, kommer alla futures som "
"exekutorn har börjat köra att slutföras innan denna metod återkommer. De "
"återstående futures avbryts."

msgid ""
"You can avoid having to call this method explicitly if you use the :keyword:"
"`with` statement, which will shutdown the :class:`Executor` (waiting as if :"
"meth:`Executor.shutdown` were called with *wait* set to ``True``)::"
msgstr ""
"Du kan undvika att behöva anropa denna metod explicit om du använder :"
"keyword:`with`-satsen, som kommer att stänga av :class:`Executor` (väntar "
"som om :meth:`Executor.shutdown` anropades med *wait* satt till ``True``)::"

msgid ""
"import shutil\n"
"with ThreadPoolExecutor(max_workers=4) as e:\n"
"    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')\n"
"    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')\n"
"    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')\n"
"    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')"
msgstr ""
"import shutil\n"
"with ThreadPoolExecutor(max_workers=4) as e:\n"
"    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')\n"
"    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')\n"
"    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')\n"
"    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')"

msgid "Added *cancel_futures*."
msgstr "Lagt till *cancel_futures*."

msgid "ThreadPoolExecutor"
msgstr "ThreadPool-utförare"

msgid ""
":class:`ThreadPoolExecutor` is an :class:`Executor` subclass that uses a "
"pool of threads to execute calls asynchronously."
msgstr ""
":class:`ThreadPoolExecutor` är en :class:`Executor`-underklass som använder "
"en pool av trådar för att utföra anrop asynkront."

msgid ""
"Deadlocks can occur when the callable associated with a :class:`Future` "
"waits on the results of another :class:`Future`.  For example::"
msgstr ""
"Dödlägen kan uppstå när den anropbara funktionen som är associerad med en :"
"class:`Future` väntar på resultatet av en annan :class:`Future`.  Till "
"exempel::"

msgid ""
"import time\n"
"def wait_on_b():\n"
"    time.sleep(5)\n"
"    print(b.result())  # b will never complete because it is waiting on a.\n"
"    return 5\n"
"\n"
"def wait_on_a():\n"
"    time.sleep(5)\n"
"    print(a.result())  # a will never complete because it is waiting on b.\n"
"    return 6\n"
"\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=2)\n"
"a = executor.submit(wait_on_b)\n"
"b = executor.submit(wait_on_a)"
msgstr ""
"import time\n"
"def wait_on_b():\n"
"    time.sleep(5)\n"
"    print(b.result())  # b will never complete because it is waiting on a.\n"
"    return 5\n"
"\n"
"def wait_on_a():\n"
"    time.sleep(5)\n"
"    print(a.result())  # a will never complete because it is waiting on b.\n"
"    return 6\n"
"\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=2)\n"
"a = executor.submit(wait_on_b)\n"
"b = executor.submit(wait_on_a)"

msgid "And::"
msgstr "Och::"

msgid ""
"def wait_on_future():\n"
"    f = executor.submit(pow, 5, 2)\n"
"    # This will never complete because there is only one worker thread and\n"
"    # it is executing this function.\n"
"    print(f.result())\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=1)\n"
"executor.submit(wait_on_future)"
msgstr ""
"def vänta_på_framtiden():\n"
"    f = executor.submit(pow, 5, 2)\n"
"    # Detta kommer aldrig att slutföras eftersom det bara finns en "
"arbetstråd och\n"
"    # den utför den här funktionen.\n"
"    print(f.resultat())\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=1)\n"
"executor.submit(vänta_på_framtiden)"

msgid ""
"An :class:`Executor` subclass that uses a pool of at most *max_workers* "
"threads to execute calls asynchronously."
msgstr ""
"En :class:`Executor`-underklass som använder en pool med högst *max_workers* "
"trådar för att utföra anrop asynkront."

msgid ""
"All threads enqueued to ``ThreadPoolExecutor`` will be joined before the "
"interpreter can exit. Note that the exit handler which does this is executed "
"*before* any exit handlers added using ``atexit``. This means exceptions in "
"the main thread must be caught and handled in order to signal threads to "
"exit gracefully. For this reason, it is recommended that "
"``ThreadPoolExecutor`` not be used for long-running tasks."
msgstr ""
"Alla trådar som står i kö till ``ThreadPoolExecutor`` kommer att sammanfogas "
"innan tolken kan avslutas. Observera att den exit-hanterare som gör detta "
"exekveras *före* alla exit-hanterare som läggs till med ``atexit``. Detta "
"innebär att undantag i huvudtråden måste fångas upp och hanteras för att "
"kunna signalera till trådarna att de ska avslutas på ett elegant sätt. Av "
"denna anledning rekommenderas det att ``ThreadPoolExecutor`` inte används "
"för långvariga uppgifter."

msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker thread; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently pending "
"jobs will raise a :exc:`~concurrent.futures.thread.BrokenThreadPool`, as "
"well as any attempt to submit more jobs to the pool."
msgstr ""
"*initializer* är en valfri callable som anropas i början av varje "
"arbetstråd; *initargs* är en tupel av argument som skickas till "
"initializern.  Om *initializer* ger upphov till ett undantag kommer alla "
"pågående jobb att ge upphov till en :exc:`~concurrent.futures.thread."
"BrokenThreadPool`, liksom alla försök att skicka fler jobb till poolen."

msgid ""
"If *max_workers* is ``None`` or not given, it will default to the number of "
"processors on the machine, multiplied by ``5``, assuming that :class:"
"`ThreadPoolExecutor` is often used to overlap I/O instead of CPU work and "
"the number of workers should be higher than the number of workers for :class:"
"`ProcessPoolExecutor`."
msgstr ""
"Om *max_workers* är ``None`` eller inte anges, kommer det som standard att "
"vara antalet processorer på maskinen, multiplicerat med ``5``, förutsatt "
"att :class:`ThreadPoolExecutor` ofta används för att överlappa I/O istället "
"för CPU-arbete och antalet workers bör vara högre än antalet workers för :"
"class:`ProcessPoolExecutor`."

msgid ""
"Added the *thread_name_prefix* parameter to allow users to control the :"
"class:`threading.Thread` names for worker threads created by the pool for "
"easier debugging."
msgstr ""
"Parametern *thread_name_prefix* har lagts till så att användare kan styra :"
"class:`threading.Thread-namnen för arbetstrådar som skapas av poolen för "
"enklare felsökning."

msgid "Added the *initializer* and *initargs* arguments."
msgstr "Lagt till argumenten *initializer* och *initargs*."

msgid ""
"Default value of *max_workers* is changed to ``min(32, os.cpu_count() + "
"4)``. This default value preserves at least 5 workers for I/O bound tasks. "
"It utilizes at most 32 CPU cores for CPU bound tasks which release the GIL. "
"And it avoids using very large resources implicitly on many-core machines."
msgstr ""
"Standardvärdet för *max_workers* ändras till ``min(32, os.cpu_count() + "
"4)``. Detta standardvärde bevarar minst 5 arbetare för I/O-bundna uppgifter. "
"Det använder högst 32 CPU-kärnor för CPU-bundna uppgifter som frigör GIL. "
"Och det undviker att använda mycket stora resurser implicit på flerkärniga "
"maskiner."

msgid ""
"ThreadPoolExecutor now reuses idle worker threads before starting "
"*max_workers* worker threads too."
msgstr ""
"ThreadPoolExecutor återanvänder nu inaktiva arbetstrådar innan *max_workers* "
"arbetstrådar också startas."

msgid ""
"Default value of *max_workers* is changed to ``min(32, (os."
"process_cpu_count() or 1) + 4)``."
msgstr ""
"Standardvärdet för *max_workers* ändras till ``min(32, (os."
"process_cpu_count() or 1) + 4)``."

msgid "ThreadPoolExecutor Example"
msgstr "ThreadPoolExecutor Exempel"

msgid ""
"import concurrent.futures\n"
"import urllib.request\n"
"\n"
"URLS = ['http://www.foxnews.com/',\n"
"        'http://www.cnn.com/',\n"
"        'http://europe.wsj.com/',\n"
"        'http://www.bbc.co.uk/',\n"
"        'http://nonexistent-subdomain.python.org/']\n"
"\n"
"# Retrieve a single page and report the URL and contents\n"
"def load_url(url, timeout):\n"
"    with urllib.request.urlopen(url, timeout=timeout) as conn:\n"
"        return conn.read()\n"
"\n"
"# We can use a with statement to ensure threads are cleaned up promptly\n"
"with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n"
"    # Start the load operations and mark each future with its URL\n"
"    future_to_url = {executor.submit(load_url, url, 60): url for url in "
"URLS}\n"
"    for future in concurrent.futures.as_completed(future_to_url):\n"
"        url = future_to_url[future]\n"
"        try:\n"
"            data = future.result()\n"
"        except Exception as exc:\n"
"            print('%r generated an exception: %s' % (url, exc))\n"
"        else:\n"
"            print('%r page is %d bytes' % (url, len(data)))"
msgstr ""
"import concurrent.futures\n"
"import urllib.request\n"
"\n"
"URLS = ['http://www.foxnews.com/',\n"
"        'http://www.cnn.com/',\n"
"        'http://europe.wsj.com/',\n"
"        'http://www.bbc.co.uk/',\n"
"        'http://nonexistent-subdomain.python.org/']\n"
"\n"
"# Retrieve a single page and report the URL and contents\n"
"def load_url(url, timeout):\n"
"    with urllib.request.urlopen(url, timeout=timeout) as conn:\n"
"        return conn.read()\n"
"\n"
"# We can use a with statement to ensure threads are cleaned up promptly\n"
"with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n"
"    # Start the load operations and mark each future with its URL\n"
"    future_to_url = {executor.submit(load_url, url, 60): url for url in "
"URLS}\n"
"    for future in concurrent.futures.as_completed(future_to_url):\n"
"        url = future_to_url[future]\n"
"        try:\n"
"            data = future.result()\n"
"        except Exception as exc:\n"
"            print('%r generated an exception: %s' % (url, exc))\n"
"        else:\n"
"            print('%r page is %d bytes' % (url, len(data)))"

msgid "InterpreterPoolExecutor"
msgstr "Utförare av tolkPool"

msgid ""
"The :class:`InterpreterPoolExecutor` class uses a pool of interpreters to "
"execute calls asynchronously.  It is a :class:`ThreadPoolExecutor` subclass, "
"which means each worker is running in its own thread. The difference here is "
"that each worker has its own interpreter, and runs each task using that "
"interpreter."
msgstr ""
"Klassen :class:`InterpreterPoolExecutor` använder en pool av tolkar för att "
"exekvera anrop asynkront.  Det är en :class:`ThreadPoolExecutor`-underklass, "
"vilket innebär att varje arbetare körs i sin egen tråd. Skillnaden här är "
"att varje arbetare har sin egen tolk och kör varje uppgift med hjälp av den "
"tolken."

msgid ""
"The biggest benefit to using interpreters instead of only threads is true "
"multi-core parallelism.  Each interpreter has its own :term:`Global "
"Interpreter Lock <global interpreter lock>`, so code running in one "
"interpreter can run on one CPU core, while code in another interpreter runs "
"unblocked on a different core."
msgstr ""
"Den största fördelen med att använda tolkar i stället för enbart trådar är "
"den verkliga parallelliteten med flera kärnor.  Varje tolk har sin egen :"
"term:``Global Interpreter Lock <global interpreter lock>``, så kod som körs "
"i en tolk kan köras på en CPU-kärna, medan kod i en annan tolk körs "
"oblockerad på en annan kärna."

msgid ""
"The tradeoff is that writing concurrent code for use with multiple "
"interpreters can take extra effort.  However, this is because it forces you "
"to be deliberate about how and when interpreters interact, and to be "
"explicit about what data is shared between interpreters. This results in "
"several benefits that help balance the extra effort, including true multi-"
"core parallelism,  For example, code written this way can make it easier to "
"reason about concurrency.  Another major benefit is that you don't have to "
"deal with several of the big pain points of using threads, like race "
"conditions."
msgstr ""
"Avvägningen är att det kan kräva extra ansträngning att skriva samtidig kod "
"för användning med flera tolkar.  Detta beror dock på att man tvingas vara "
"medveten om hur och när tolkarna interagerar och att man måste vara tydlig "
"med vilka data som delas mellan tolkarna. Detta resulterar i flera fördelar "
"som hjälper till att balansera den extra ansträngningen, inklusive äkta "
"flerkärnig parallellism, Till exempel kan kod som skrivs på det här sättet "
"göra det lättare att resonera om samtidighet.  En annan stor fördel är att "
"du inte behöver ta itu med flera av de stora smärtpunkterna med att använda "
"trådar, som race conditions."

msgid ""
"Each worker's interpreter is isolated from all the other interpreters. "
"\"Isolated\" means each interpreter has its own runtime state and operates "
"completely independently.  For example, if you redirect :data:`sys.stdout` "
"in one interpreter, it will not be automatically redirected to any other "
"interpreter.  If you import a module in one interpreter, it is not "
"automatically imported in any other.  You would need to import the module "
"separately in interpreter where you need it.  In fact, each module imported "
"in an interpreter is a completely separate object from the same module in a "
"different interpreter, including :mod:`sys`, :mod:`builtins`, and even "
"``__main__``."
msgstr ""
"Varje arbetares tolk är isolerad från alla andra tolkar. \"Isolerad\" "
"betyder att varje tolk har sitt eget runtime-tillstånd och fungerar helt "
"oberoende.  Om du till exempel omdirigerar :data:`sys.stdout` i en tolk, "
"kommer den inte att omdirigeras automatiskt till någon annan tolk.  Om du "
"importerar en modul i en tolk importeras den inte automatiskt i någon annan "
"tolk.  Du måste importera modulen separat i den tolk där du behöver den.  "
"Faktum är att varje modul som importeras i en tolk är ett helt separat "
"objekt från samma modul i en annan tolk, inklusive :mod:`sys`, :mod:"
"`builtins` och till och med ``__main__``."

msgid ""
"Isolation means a mutable object, or other data, cannot be used by more than "
"one interpreter at the same time.  That effectively means interpreters "
"cannot actually share such objects or data.  Instead, each interpreter must "
"have its own copy, and you will have to synchronize any changes between the "
"copies manually.  Immutable objects and data, like the builtin singletons, "
"strings, and tuples of immutable objects, don't have these limitations."
msgstr ""
"Isolering innebär att ett föränderligt objekt, eller andra data, inte kan "
"användas av mer än en tolk samtidigt.  Det innebär i praktiken att tolkarna "
"inte kan dela sådana objekt eller data.  Istället måste varje tolk ha sin "
"egen kopia, och du måste synkronisera eventuella ändringar mellan kopiorna "
"manuellt.  Oföränderliga objekt och data, som de inbyggda singletonerna, "
"strängarna och tuplerna av oföränderliga objekt, har inte dessa "
"begränsningar."

msgid ""
"Communicating and synchronizing between interpreters is most effectively "
"done using dedicated tools, like those proposed in :pep:`734`.  One less "
"efficient alternative is to serialize with :mod:`pickle` and then send the "
"bytes over a shared :mod:`socket <socket>` or :func:`pipe <os.pipe>`."
msgstr ""
"Kommunikation och synkronisering mellan tolkar görs mest effektivt med hjälp "
"av dedikerade verktyg, som de som föreslås i :pep:`734`.  Ett mindre "
"effektivt alternativ är att serialisera med :mod:`pickle` och sedan skicka "
"bytena över en delad :mod:`socket <socket>` eller :func:`pipe <os.pipe>`."

msgid ""
"A :class:`ThreadPoolExecutor` subclass that executes calls asynchronously "
"using a pool of at most *max_workers* threads.  Each thread runs tasks in "
"its own interpreter.  The worker interpreters are isolated from each other, "
"which means each has its own runtime state and that they can't share any "
"mutable objects or other data.  Each interpreter has its own :term:`Global "
"Interpreter Lock <global interpreter lock>`, which means code run with this "
"executor has true multi-core parallelism."
msgstr ""
"En :class:`ThreadPoolExecutor`-underklass som utför anrop asynkront med "
"hjälp av en pool med högst *max_workers* trådar.  Varje tråd kör uppgifter i "
"sin egen tolk.  De arbetande tolkarna är isolerade från varandra, vilket "
"innebär att var och en har sitt eget körtidstillstånd och att de inte kan "
"dela några föränderliga objekt eller andra data.  Varje tolk har sitt eget :"
"term:`Global Interpreter Lock <global interpreter lock>`, vilket innebär att "
"kod som körs med den här exekutorn har äkta parallellitet med flera kärnor."

msgid ""
"The optional *initializer* and *initargs* arguments have the same meaning as "
"for :class:`!ThreadPoolExecutor`: the initializer is run when each worker is "
"created, though in this case it is run in the worker's interpreter.  The "
"executor serializes the *initializer* and *initargs* using :mod:`pickle` "
"when sending them to the worker's interpreter."
msgstr ""
"De valfria argumenten *initializer* och *initargs* har samma betydelse som "
"för :class:`!ThreadPoolExecutor`: initialiseraren körs när varje arbetare "
"skapas, men i det här fallet körs den i arbetarens tolk.  Exekutorn "
"serialiserar *initialiseraren* och *initargs* med :mod:`pickle` när den "
"skickar dem till arbetarens tolk."

msgid ""
"The executor may replace uncaught exceptions from *initializer* with :class:"
"`~concurrent.futures.interpreter.ExecutionFailed`."
msgstr ""
"Exekveraren kan ersätta undantag från *initialiserare* med :class:"
"`~concurrent.futures.interpreter.ExecutionFailed`."

msgid "Other caveats from parent :class:`ThreadPoolExecutor` apply here."
msgstr ""
"Andra varningar från överordnad :class:`ThreadPoolExecutor` gäller här."

msgid ""
":meth:`~Executor.submit` and :meth:`~Executor.map` work like normal, except "
"the worker serializes the callable and arguments using :mod:`pickle` when "
"sending them to its interpreter.  The worker likewise serializes the return "
"value when sending it back."
msgstr ""
":meth:`~Executor.submit` och :meth:`~Executor.map` fungerar som vanligt, "
"förutom att arbetaren serialiserar anropsbarnet och argumenten med :mod:"
"`pickle` när de skickas till dess tolk.  På samma sätt serialiserar "
"arbetaren returvärdet när det skickas tillbaka."

msgid ""
"When a worker's current task raises an uncaught exception, the worker always "
"tries to preserve the exception as-is.  If that is successful then it also "
"sets the ``__cause__`` to a corresponding :class:`~concurrent.futures."
"interpreter.ExecutionFailed` instance, which contains a summary of the "
"original exception. In the uncommon case that the worker is not able to "
"preserve the original as-is then it directly preserves the corresponding :"
"class:`~concurrent.futures.interpreter.ExecutionFailed` instance instead."
msgstr ""
"När en arbetares aktuella uppgift ger upphov till ett undantag som inte "
"fångats upp, försöker arbetaren alltid att bevara undantaget som det är.  Om "
"det lyckas sätts även ``__cause__`` till en motsvarande :class:`~concurrent."
"futures.interpreter.ExecutionFailed`-instans, som innehåller en "
"sammanfattning av det ursprungliga undantaget. I det ovanliga fallet att "
"arbetaren inte kan bevara originalet som det är, bevarar den direkt "
"motsvarande :class:`~concurrent.futures.interpreter.ExecutionFailed`-instans "
"istället."

msgid "ProcessPoolExecutor"
msgstr "ProcessPoolExekutör"

msgid ""
"The :class:`ProcessPoolExecutor` class is an :class:`Executor` subclass that "
"uses a pool of processes to execute calls asynchronously. :class:"
"`ProcessPoolExecutor` uses the :mod:`multiprocessing` module, which allows "
"it to side-step the :term:`Global Interpreter Lock <global interpreter "
"lock>` but also means that only picklable objects can be executed and "
"returned."
msgstr ""
"Klassen :class:`ProcessPoolExecutor` är en underklass till :class:`Executor` "
"som använder en pool av processer för att exekvera anrop asynkront. :class:"
"`ProcessPoolExecutor` använder modulen :mod:`multiprocessing`, vilket gör "
"att den kan kringgå :term:`Global Interpreter Lock <global interpreter "
"lock>`, men innebär också att endast picklbara objekt kan exekveras och "
"returneras."

msgid ""
"The ``__main__`` module must be importable by worker subprocesses. This "
"means that :class:`ProcessPoolExecutor` will not work in the interactive "
"interpreter."
msgstr ""
"Modulen ``__main__`` måste kunna importeras av underprocesser som arbetar. "
"Detta innebär att :class:`ProcessPoolExecutor` inte kommer att fungera i den "
"interaktiva tolken."

msgid ""
"Calling :class:`Executor` or :class:`Future` methods from a callable "
"submitted to a :class:`ProcessPoolExecutor` will result in deadlock."
msgstr ""
"Anrop av :class:`Executor` eller :class:`Future` metoder från en callable "
"som skickats till en :class:`ProcessPoolExecutor` kommer att resultera i "
"deadlock."

msgid ""
"Note that the restrictions on functions and arguments needing to picklable "
"as per :class:`multiprocessing.Process` apply when using :meth:`~Executor."
"submit` and :meth:`~Executor.map` on a :class:`ProcessPoolExecutor`. A "
"function defined in a REPL or a lambda should not be expected to work."
msgstr ""
"Observera att restriktionerna för funktioner och argument som måste kunna "
"betas enligt :class:`multiprocessing.Process` gäller när man använder :meth:"
"`~Executor.submit` och :meth:`~Executor.map` på en :class:"
"`ProcessPoolExecutor`. En funktion som definieras i en REPL eller en lambda "
"bör inte förväntas fungera."

msgid ""
"An :class:`Executor` subclass that executes calls asynchronously using a "
"pool of at most *max_workers* processes.  If *max_workers* is ``None`` or "
"not given, it will default to :func:`os.process_cpu_count`. If *max_workers* "
"is less than or equal to ``0``, then a :exc:`ValueError` will be raised. On "
"Windows, *max_workers* must be less than or equal to ``61``. If it is not "
"then :exc:`ValueError` will be raised. If *max_workers* is ``None``, then "
"the default chosen will be at most ``61``, even if more processors are "
"available. *mp_context* can be a :mod:`multiprocessing` context or ``None``. "
"It will be used to launch the workers. If *mp_context* is ``None`` or not "
"given, the default :mod:`multiprocessing` context is used. See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"En :class:`Executor`-underklass som utför anrop asynkront med hjälp av en "
"pool med högst *max_workers* processer.  Om *max_workers* är ``None`` eller "
"inte anges, kommer det som standard att vara :func:`os.process_cpu_count`. "
"Om *max_workers* är mindre än eller lika med ``0``, så kommer ett :exc:"
"`ValueError` att uppstå. I Windows måste *max_workers* vara mindre än eller "
"lika med ``61``. Om den inte är det kommer ett :exc:`ValueError` att visas. "
"Om *max_workers* är ``None`` kommer standardvärdet att vara högst ``61``, "
"även om fler processorer är tillgängliga. *mp_context* kan vara en :mod:"
"`multiprocessing`-kontext eller ``None``. Det kommer att användas för att "
"starta arbetarna. Om *mp_context* är ``None`` eller inte anges, används "
"standardkontexten :mod:`multiprocessing`. Se :ref:`multiprocessing-start-"
"methods`."

msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker process; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently pending "
"jobs will raise a :exc:`~concurrent.futures.process.BrokenProcessPool`, as "
"well as any attempt to submit more jobs to the pool."
msgstr ""
"*initializer* är en valfri callable som anropas i början av varje "
"arbetsprocess; *initargs* är en tupel av argument som skickas till "
"initializern.  Om *initializer* ger upphov till ett undantag kommer alla "
"pågående jobb att ge upphov till en :exc:`~concurrent.futures.process."
"BrokenProcessPool`, liksom alla försök att skicka fler jobb till poolen."

msgid ""
"*max_tasks_per_child* is an optional argument that specifies the maximum "
"number of tasks a single process can execute before it will exit and be "
"replaced with a fresh worker process. By default *max_tasks_per_child* is "
"``None`` which means worker processes will live as long as the pool. When a "
"max is specified, the \"spawn\" multiprocessing start method will be used by "
"default in absence of a *mp_context* parameter. This feature is incompatible "
"with the \"fork\" start method."
msgstr ""
"*max_tasks_per_child* är ett valfritt argument som anger det maximala "
"antalet uppgifter som en enskild process kan utföra innan den avslutas och "
"ersätts med en ny arbetsprocess. Som standard är *max_tasks_per_child* "
"``None`` vilket innebär att arbetsprocesserna kommer att leva lika länge som "
"poolen. När ett maxvärde anges kommer startmetoden \"spawn\" för "
"multiprocessing att användas som standard om det inte finns någon parameter "
"*mp_context*. Denna funktion är inte kompatibel med startmetoden \"fork\"."

msgid ""
"When one of the worker processes terminates abruptly, a :exc:`~concurrent."
"futures.process.BrokenProcessPool` error is now raised. Previously, "
"behaviour was undefined but operations on the executor or its futures would "
"often freeze or deadlock."
msgstr ""
"När en av arbetsprocesserna avslutas abrupt, genereras nu ett :exc:"
"`~concurrent.futures.process.BrokenProcessPool`-fel. Tidigare var beteendet "
"odefinierat, men operationer på exekveraren eller dess futures frös ofta "
"eller blockerades."

msgid ""
"The *mp_context* argument was added to allow users to control the "
"start_method for worker processes created by the pool."
msgstr ""
"Argumentet *mp_context* lades till för att användare ska kunna styra "
"startmetoden för arbetsprocesser som skapas av poolen."

msgid ""
"The *max_tasks_per_child* argument was added to allow users to control the "
"lifetime of workers in the pool."
msgstr ""
"Argumentet *max_tasks_per_child* lades till så att användarna kan styra "
"livslängden för arbetarna i poolen."

msgid ""
"On POSIX systems, if your application has multiple threads and the :mod:"
"`multiprocessing` context uses the ``\"fork\"`` start method: The :func:`os."
"fork` function called internally to spawn workers may raise a :exc:"
"`DeprecationWarning`. Pass a *mp_context* configured to use a different "
"start method. See the :func:`os.fork` documentation for further explanation."
msgstr ""
"På POSIX-system, om din applikation har flera trådar och :mod:"
"`multiprocessing`-kontexten använder startmetoden ``\"fork\"``: Funktionen :"
"func:`os.fork` som anropas internt för att skapa arbetare kan ge upphov till "
"en :exc:`DeprecationWarning`. Skicka en *mp_context* som är konfigurerad att "
"använda en annan startmetod. Se dokumentationen för :func:`os.fork` för "
"ytterligare förklaring."

msgid ""
"*max_workers* uses :func:`os.process_cpu_count` by default, instead of :func:"
"`os.cpu_count`."
msgstr ""
"*max_workers* använder :func:`os.process_cpu_count` som standard, istället "
"för :func:`os.cpu_count`."

msgid ""
"The default process start method (see :ref:`multiprocessing-start-methods`) "
"changed away from *fork*. If you require the *fork* start method for :class:"
"`ProcessPoolExecutor` you must explicitly pass ``mp_context=multiprocessing."
"get_context(\"fork\")``."
msgstr ""
"Standardmetoden för processstart (se :ref:`multiprocessing-start-methods`) "
"ändrades bort från *fork*. Om du kräver startmetoden *fork* för :class:"
"`ProcessPoolExecutor` måste du uttryckligen skicka "
"``mp_context=multiprocessing.get_context(\"fork\")``."

msgid ""
"Attempt to terminate all living worker processes immediately by calling :"
"meth:`Process.terminate <multiprocessing.Process.terminate>` on each of "
"them. Internally, it will also call :meth:`Executor.shutdown` to ensure that "
"all other resources associated with the executor are freed."
msgstr ""
"Försök att avsluta alla levande arbetsprocesser omedelbart genom att anropa :"
"meth:`Process.terminate <multiprocessing.Process.terminate>` på var och en "
"av dem. Internt kommer den också att anropa :meth:`Executor.shutdown` för "
"att säkerställa att alla andra resurser som är associerade med exekveraren "
"frigörs."

msgid ""
"After calling this method the caller should no longer submit tasks to the "
"executor."
msgstr ""
"Efter anrop av denna metod ska den som anropar inte längre skicka uppdrag "
"till utföraren."

msgid ""
"Attempt to kill all living worker processes immediately by calling :meth:"
"`Process.kill <multiprocessing.Process.kill>` on each of them. Internally, "
"it will also call :meth:`Executor.shutdown` to ensure that all other "
"resources associated with the executor are freed."
msgstr ""
"Försök att döda alla levande arbetsprocesser omedelbart genom att anropa :"
"meth:`Process.kill <multiprocessing.Process.kill>` på var och en av dem. "
"Internt kommer den också att anropa :meth:`Executor.shutdown` för att "
"säkerställa att alla andra resurser som är associerade med exekveraren "
"frigörs."

msgid "ProcessPoolExecutor Example"
msgstr "Exempel på ProcessPoolExecutor"

msgid ""
"import concurrent.futures\n"
"import math\n"
"\n"
"PRIMES = [\n"
"    112272535095293,\n"
"    112582705942171,\n"
"    112272535095293,\n"
"    115280095190773,\n"
"    115797848077099,\n"
"    1099726899285419]\n"
"\n"
"def is_prime(n):\n"
"    if n < 2:\n"
"        return False\n"
"    if n == 2:\n"
"        return True\n"
"    if n % 2 == 0:\n"
"        return False\n"
"\n"
"    sqrt_n = int(math.floor(math.sqrt(n)))\n"
"    for i in range(3, sqrt_n + 1, 2):\n"
"        if n % i == 0:\n"
"            return False\n"
"    return True\n"
"\n"
"def main():\n"
"    with concurrent.futures.ProcessPoolExecutor() as executor:\n"
"        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n"
"            print('%d is prime: %s' % (number, prime))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import concurrent.futures\n"
"import math\n"
"\n"
"PRIMES = [\n"
"    112272535095293,\n"
"    112582705942171,\n"
"    112272535095293,\n"
"    115280095190773,\n"
"    115797848077099,\n"
"    1099726899285419]\n"
"\n"
"def is_prime(n):\n"
"    if n < 2:\n"
"        return False\n"
"    if n == 2:\n"
"        return True\n"
"    if n % 2 == 0:\n"
"        return False\n"
"\n"
"    sqrt_n = int(math.floor(math.sqrt(n)))\n"
"    for i in range(3, sqrt_n + 1, 2):\n"
"        if n % i == 0:\n"
"            return False\n"
"    return True\n"
"\n"
"def main():\n"
"    with concurrent.futures.ProcessPoolExecutor() as executor:\n"
"        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n"
"            print('%d is prime: %s' % (number, prime))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

msgid "Future Objects"
msgstr "Framtida objekt"

msgid ""
"The :class:`Future` class encapsulates the asynchronous execution of a "
"callable. :class:`Future` instances are created by :meth:`Executor.submit`."
msgstr ""
"Klassen :class:`Future` kapslar in den asynkrona exekveringen av en "
"anropsbar. Instanser av :class:`Future` skapas av :meth:`Executor.submit`."

msgid ""
"Encapsulates the asynchronous execution of a callable.  :class:`Future` "
"instances are created by :meth:`Executor.submit` and should not be created "
"directly except for testing."
msgstr ""
"Kapslar in den asynkrona exekveringen av en callable. :class:`Future`-"
"instanser skapas av :meth:`Executor.submit` och bör inte skapas direkt utom "
"för testning."

msgid ""
"Attempt to cancel the call.  If the call is currently being executed or "
"finished running and cannot be cancelled then the method will return "
"``False``, otherwise the call will be cancelled and the method will return "
"``True``."
msgstr ""
"Försök att avbryta anropet.  Om anropet håller på att utföras eller har "
"avslutats och inte kan avbrytas kommer metoden att returnera ``False``, "
"annars kommer anropet att avbrytas och metoden kommer att returnera ``True``."

msgid "Return ``True`` if the call was successfully cancelled."
msgstr "Returnerar ``True`` om samtalet framgångsrikt har avbrutits."

msgid ""
"Return ``True`` if the call is currently being executed and cannot be "
"cancelled."
msgstr ""
"Returnerar ``True`` om anropet håller på att utföras och inte kan avbrytas."

msgid ""
"Return ``True`` if the call was successfully cancelled or finished running."
msgstr "Returnerar ``True`` om anropet framgångsrikt avbröts eller avslutades."

msgid ""
"Return the value returned by the call. If the call hasn't yet completed then "
"this method will wait up to *timeout* seconds.  If the call hasn't completed "
"in *timeout* seconds, then a :exc:`TimeoutError` will be raised. *timeout* "
"can be an int or float.  If *timeout* is not specified or ``None``, there is "
"no limit to the wait time."
msgstr ""
"Returnerar det värde som anropet returnerade. Om anropet ännu inte har "
"slutförts kommer denna metod att vänta upp till *timeout* sekunder.  Om "
"anropet inte har slutförts inom *timeout* sekunder, kommer ett :exc:"
"`TimeoutError` att uppstå. *timeout* kan vara en int eller float.  Om "
"*timeout* inte anges eller om ``None``, finns det ingen gräns för väntetiden."

msgid ""
"If the future is cancelled before completing then :exc:`.CancelledError` "
"will be raised."
msgstr ""
"Om framtiden avbryts innan den har slutförts kommer :exc:`.CancelledError` "
"att tas upp."

msgid ""
"If the call raised an exception, this method will raise the same exception."
msgstr ""
"Om anropet gav upphov till ett undantag kommer denna metod att ge upphov "
"till samma undantag."

msgid ""
"Return the exception raised by the call.  If the call hasn't yet completed "
"then this method will wait up to *timeout* seconds.  If the call hasn't "
"completed in *timeout* seconds, then a :exc:`TimeoutError` will be raised.  "
"*timeout* can be an int or float.  If *timeout* is not specified or "
"``None``, there is no limit to the wait time."
msgstr ""
"Returnerar det undantag som uppstod vid anropet.  Om anropet ännu inte har "
"slutförts kommer denna metod att vänta upp till *timeout* sekunder.  Om "
"anropet inte har slutförts inom *timeout* sekunder, kommer ett :exc:"
"`TimeoutError` att uppstå.  *timeout* kan vara en int eller float.  Om "
"*timeout* inte anges eller om ``None``, finns det ingen gräns för väntetiden."

msgid "If the call completed without raising, ``None`` is returned."
msgstr ""
"Om anropet slutfördes utan att någon fråga ställdes återsänds ``None``."

msgid ""
"Attaches the callable *fn* to the future.  *fn* will be called, with the "
"future as its only argument, when the future is cancelled or finishes "
"running."
msgstr ""
"Kopplar den anropsbara *fn* till framtiden.  *fn* kommer att anropas, med "
"framtiden som enda argument, när framtiden avbryts eller slutar att köras."

msgid ""
"Added callables are called in the order that they were added and are always "
"called in a thread belonging to the process that added them.  If the "
"callable raises an :exc:`Exception` subclass, it will be logged and "
"ignored.  If the callable raises a :exc:`BaseException` subclass, the "
"behavior is undefined."
msgstr ""
"Tillagda anropsbara filer anropas i den ordning de lades till och anropas "
"alltid i en tråd som tillhör den process som lade till dem.  Om "
"anropsbarheten ger upphov till en :exc:`Exception`-subklass loggas den och "
"ignoreras.  Om anropet ger upphov till en subklass av :exc:`BaseException` "
"är beteendet odefinierat."

msgid ""
"If the future has already completed or been cancelled, *fn* will be called "
"immediately."
msgstr ""
"Om framtiden redan har avslutats eller avbrutits, kommer *fn* att anropas "
"omedelbart."

msgid ""
"The following :class:`Future` methods are meant for use in unit tests and :"
"class:`Executor` implementations."
msgstr ""
"Följande :class:`Future`-metoder är avsedda att användas i enhetstester och :"
"class:`Executor`-implementationer."

msgid ""
"This method should only be called by :class:`Executor` implementations "
"before executing the work associated with the :class:`Future` and by unit "
"tests."
msgstr ""
"Denna metod bör endast anropas av :class:`Executor`-implementationer innan "
"de utför det arbete som är associerat med :class:`Future` och av "
"enhetstester."

msgid ""
"If the method returns ``False`` then the :class:`Future` was cancelled, i."
"e. :meth:`Future.cancel` was called and returned ``True``.  Any threads "
"waiting on the :class:`Future` completing (i.e. through :func:`as_completed` "
"or :func:`wait`) will be woken up."
msgstr ""
"Om metoden returnerar ``False`` så avbröts :class:`Future`, dvs :meth:"
"`Future.cancel` anropades och returnerade ``True``.  Alla trådar som väntar "
"på att :class:`Future` ska slutföras (t.ex. genom :func:`as_completed` "
"eller :func:`wait`) kommer att väckas."

msgid ""
"If the method returns ``True`` then the :class:`Future` was not cancelled "
"and has been put in the running state, i.e. calls to :meth:`Future.running` "
"will return ``True``."
msgstr ""
"Om metoden returnerar ``True`` så har :class:`Future` inte avbrutits och har "
"satts i drift, d.v.s. anrop till :meth:`Future.running` kommer att returnera "
"``True``."

msgid ""
"This method can only be called once and cannot be called after :meth:`Future."
"set_result` or :meth:`Future.set_exception` have been called."
msgstr ""
"Denna metod kan bara anropas en gång och kan inte anropas efter att :meth:"
"`Future.set_result` eller :meth:`Future.set_exception` har anropats."

msgid ""
"Sets the result of the work associated with the :class:`Future` to *result*."
msgstr ""
"Ställer in resultatet av det arbete som är associerat med :class:`Future` "
"till *result*."

msgid ""
"This method should only be used by :class:`Executor` implementations and "
"unit tests."
msgstr ""
"Denna metod bör endast användas av :class:`Executor`-implementationer och "
"enhetstester."

msgid ""
"This method raises :exc:`concurrent.futures.InvalidStateError` if the :class:"
"`Future` is already done."
msgstr ""
"Denna metod ger upphov till :exc:`concurrent.futures.InvalidStateError` om :"
"class:`Future` redan är klar."

msgid ""
"Sets the result of the work associated with the :class:`Future` to the :"
"class:`Exception` *exception*."
msgstr ""
"Ställer in resultatet av det arbete som associeras med :class:`Future` till :"
"class:`Exception` *exception*."

msgid "Module Functions"
msgstr "Modulens funktioner"

msgid ""
"Wait for the :class:`Future` instances (possibly created by different :class:"
"`Executor` instances) given by *fs* to complete. Duplicate futures given to "
"*fs* are removed and will be returned only once. Returns a named 2-tuple of "
"sets.  The first set, named ``done``, contains the futures that completed "
"(finished or cancelled futures) before the wait completed.  The second set, "
"named ``not_done``, contains the futures that did not complete (pending or "
"running futures)."
msgstr ""
"Vänta på att :class:`Future`-instanser (eventuellt skapade av olika :class:"
"`Executor`-instanser) som ges av *fs* ska slutföras. Duplicerade futures som "
"ges till *fs* tas bort och returneras endast en gång. Returnerar en "
"namngiven 2-tupel av uppsättningar.  Den första uppsättningen, med namnet "
"``done``, innehåller de futures som slutfördes (finished eller cancelled "
"futures) innan väntan slutfördes.  Den andra uppsättningen, med namnet "
"``not_done``, innehåller de terminer som inte slutfördes (väntande eller "
"pågående terminer)."

msgid ""
"*timeout* can be used to control the maximum number of seconds to wait "
"before returning.  *timeout* can be an int or float.  If *timeout* is not "
"specified or ``None``, there is no limit to the wait time."
msgstr ""
"*timeout* kan användas för att styra det maximala antalet sekunder som ska "
"väntas innan returnering.  *timeout* kan vara en int eller float.  Om "
"*timeout* inte anges eller om ``None``, finns det ingen gräns för väntetiden."

msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* anger när denna funktion ska returnera.  Den måste vara en av "
"följande konstanter:"

msgid "Constant"
msgstr "Konstant"

msgid "Description"
msgstr "Beskrivning"

msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"Funktionen kommer att återkomma när någon framtid avslutas eller avbryts."

msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"Funktionen återkommer när en framtid avslutas genom att ett undantag "
"utlöses. Om ingen framtid ger upphov till ett undantag så är det likvärdigt "
"med :const:`ALL_COMPLETED`."

msgid "The function will return when all futures finish or are cancelled."
msgstr "Funktionen återkommer när alla terminer är avslutade eller avbrutna."

msgid ""
"Returns an iterator over the :class:`Future` instances (possibly created by "
"different :class:`Executor` instances) given by *fs* that yields futures as "
"they complete (finished or cancelled futures). Any futures given by *fs* "
"that are duplicated will be returned once. Any futures that completed "
"before :func:`as_completed` is called will be yielded first.  The returned "
"iterator raises a :exc:`TimeoutError` if :meth:`~iterator.__next__` is "
"called and the result isn't available after *timeout* seconds from the "
"original call to :func:`as_completed`.  *timeout* can be an int or float. If "
"*timeout* is not specified or ``None``, there is no limit to the wait time."
msgstr ""
"Returnerar en iterator över :class:`Future`-instanser (eventuellt skapade av "
"olika :class:`Executor`-instanser) som ges av *fs* som ger futures när de "
"slutförs (färdiga eller avbrutna futures). Alla futures som ges av *fs* och "
"som är duplicerade kommer att returneras en gång. Alla futures som slutförts "
"innan :func:`as_completed` anropas kommer att returneras först.  Den "
"returnerade iteratorn ger upphov till ett :exc:`TimeoutError` om :meth:"
"`~iterator.__next__` anropas och resultatet inte är tillgängligt efter "
"*timeout* sekunder från det ursprungliga anropet till :func:`as_completed`.  "
"*timeout* kan vara en int eller float. Om *timeout* inte anges eller "
"``None``, finns det ingen gräns för väntetiden."

msgid ":pep:`3148` -- futures - execute computations asynchronously"
msgstr ":pep:`3148` -- futures - utföra beräkningar asynkront"

msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr ""
"Förslaget som beskrev denna funktion för inkludering i Pythons "
"standardbibliotek."

msgid "Exception classes"
msgstr "Undantagsklasser"

msgid "Raised when a future is cancelled."
msgstr "Utlöses när en framtid avbryts."

msgid ""
"A deprecated alias of :exc:`TimeoutError`, raised when a future operation "
"exceeds the given timeout."
msgstr ""
"Ett föråldrat alias för :exc:`TimeoutError`, som uppstår när en framtida "
"operation överskrider den angivna tidsgränsen."

msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "Denna klass gjordes till ett alias för :exc:`TimeoutError`."

msgid ""
"Derived from :exc:`RuntimeError`, this exception class is raised when an "
"executor is broken for some reason, and cannot be used to submit or execute "
"new tasks."
msgstr ""
"Denna undantagsklass härstammar från :exc:`RuntimeError` och uppstår när en "
"exekverare av någon anledning inte fungerar och inte kan användas för att "
"skicka in eller utföra nya uppgifter."

msgid ""
"Raised when an operation is performed on a future that is not allowed in the "
"current state."
msgstr ""
"Utlöses när en operation utförs på en future som inte är tillåten i det "
"aktuella tillståndet."

msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor`, this exception class "
"is raised when one of the workers of a :class:`~concurrent.futures."
"ThreadPoolExecutor` has failed initializing."
msgstr ""
"Denna undantagsklass härstammar från :exc:`~concurrent.futures."
"BrokenExecutor` och uppstår när en av arbetarna i en :class:`~concurrent."
"futures.ThreadPoolExecutor` inte har initierats."

msgid ""
"Derived from :exc:`~concurrent.futures.thread.BrokenThreadPool`, this "
"exception class is raised when one of the workers of a :class:`~concurrent."
"futures.InterpreterPoolExecutor` has failed initializing."
msgstr ""
"Denna undantagsklass härstammar från :exc:`~concurrent.futures.thread."
"BrokenThreadPool` och uppstår när en av arbetarna i en :class:`~concurrent."
"futures.InterpreterPoolExecutor` inte har initierats."

msgid ""
"Raised from :class:`~concurrent.futures.InterpreterPoolExecutor` when the "
"given initializer fails or from :meth:`~concurrent.futures.Executor.submit` "
"when there's an uncaught exception from the submitted task."
msgstr ""
"Utlöses från :class:`~concurrent.futures.InterpreterPoolExecutor` när den "
"givna initialiseraren misslyckas eller från :meth:`~concurrent.futures."
"Executor.submit` när det finns ett undantag som inte fångats upp från den "
"inlämnade uppgiften."

msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor` (formerly :exc:"
"`RuntimeError`), this exception class is raised when one of the workers of "
"a :class:`~concurrent.futures.ProcessPoolExecutor` has terminated in a non-"
"clean fashion (for example, if it was killed from the outside)."
msgstr ""
"Denna undantagsklass härstammar från :exc:`~concurrent.futures."
"BrokenExecutor` (tidigare :exc:`RuntimeError`) och uppstår när en av "
"arbetarna i en :class:`~concurrent.futures.ProcessPoolExecutor` har "
"avslutats på ett felaktigt sätt (t.ex. om den dödades från utsidan)."
