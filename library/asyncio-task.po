# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Coroutines and Tasks"
msgstr "Coroutines och Tasks"

msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Detta avsnitt beskriver asyncio-API:er på hög nivå för att arbeta med "
"coroutines och Tasks."

msgid "Coroutines"
msgstr "Coroutines"

msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/coroutines.py`"

msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
"sammanfattning : term:`Coroutines <coroutine>` deklarerade med async/await-"
"syntaxen är det föredragna sättet att skriva asyncio-applikationer.  "
"Följande kodavsnitt skriver till exempel ut \"hello\", väntar 1 sekund och "
"skriver sedan ut \"world\"::"

msgid ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"
msgstr ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"

msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Observera att det inte räcker med att anropa en coroutine för att den ska "
"exekveras::"

msgid ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"
msgstr ""
"&gt;&gt;&gt; main()\n"
"<coroutine object main at 0x1053bb7c8>"

msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"För att faktiskt köra en coroutine tillhandahåller asyncio följande "
"mekanismer:"

msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"Funktionen :func:`asyncio.run` för att köra funktionen \"main()\" på den "
"högsta nivån (se exemplet ovan)"

msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Väntar på en coroutine.  Följande kodavsnitt kommer att skriva ut \"hello\" "
"efter att ha väntat i 1 sekund, och sedan skriva ut \"world\" efter att ha "
"väntat i *ytterligare* 2 sekunder::"

msgid ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"

msgid "Expected output::"
msgstr "Förväntad utgång::"

msgid ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"
msgstr ""
"började kl 17:13:52\n"
"hej\n"
"värld\n"
"avslutat kl. 17:13:55"

msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"Funktionen :func:`asyncio.create_task` för att köra coroutines samtidigt som "
"asyncio :class:`Tasks <Task>`."

msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Låt oss modifiera exemplet ovan och köra två ``say_after`` coroutines "
"*samtidigt*::"

msgid ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Wait until both tasks are completed (should take\n"
"    # around 2 seconds.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    uppgift1 = asyncio.create_task(\n"
"        say_after(1, 'hej'))\n"
"\n"
"    uppgift2 = asyncio.create_task(\n"
"        say_after(2, 'värld'))\n"
"\n"
"    print(f\"startade vid {time.strftime('%X')}\")\n"
"\n"
"    # Vänta tills båda uppgifterna är slutförda (bör ta\n"
"    # cirka 2 sekunder.)\n"
"    vänta uppgift1\n"
"    vänta uppgift2\n"
"\n"
"    print(f\"klar vid {time.strftime('%X')}\")"

msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Observera att den förväntade utdata nu visar att utdraget körs 1 sekund "
"snabbare än tidigare::"

msgid ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"
msgstr ""
"började kl 17:14:32\n"
"hej\n"
"värld\n"
"avslutat kl. 17:14:34"

msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""
"Klassen :class:`asyncio.TaskGroup` ger ett mer modernt alternativ till :func:"
"`create_task`. Med hjälp av detta API blir det sista exemplet::"

msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # The await is implicit when the context manager exits.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    async med asyncio.TaskGroup() som tg:\n"
"        uppgift1 = tg.create_task(\n"
"            say_after(1, 'hej'))\n"
"\n"
"        uppgift2 = tg.create_task(\n"
"            say_after(2, 'värld'))\n"
"\n"
"        print(f\"startade vid {time.strftime('%X')}\")\n"
"\n"
"    # Await är implicit när kontexthanteraren avslutas.\n"
"\n"
"    print(f\"klar vid {time.strftime('%X')}\")"

msgid "The timing and output should be the same as for the previous version."
msgstr ""
"Tidpunkten och resultatet ska vara detsamma som för den tidigare versionen."

msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`."

msgid "Awaitables"
msgstr "Förväntansfulla"

msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Vi säger att ett objekt är ett **awaitable**-objekt om det kan användas i "
"ett :keyword:`await`-uttryck.  Många asyncio API:er är utformade för att "
"acceptera awaitables."

msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Det finns tre huvudtyper av *awaitable*-objekt: **Koroutiner**, "
"**Uppgifter** och **Futures**."

msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Python coroutines är *awaitables* och kan därför väntas från andra "
"coroutines::"

msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nothing happens if we just call \"nested()\".\n"
"    # A coroutine object is created but not awaited,\n"
"    # so it *won't run at all*.\n"
"    nested()  # will raise a \"RuntimeWarning\".\n"
"\n"
"    # Let's do it differently now and await it:\n"
"    print(await nested())  # will print \"42\".\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nothing happens if we just call \"nested()\".\n"
"    # A coroutine object is created but not awaited,\n"
"    # so it *won't run at all*.\n"
"    nested()  # will raise a \"RuntimeWarning\".\n"
"\n"
"    # Let's do it differently now and await it:\n"
"    print(await nested())  # will print \"42\".\n"
"\n"
"asyncio.run(main())"

msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"I den här dokumentationen kan termen \"coroutine\" användas för två "
"närbesläktade begrepp:"

msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "en *coroutine-funktion*: en :keyword:`async def`-funktion;"

msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"ett *koroutinobjekt*: ett objekt som returneras genom anrop av en "
"*koroutinfunktion*."

msgid "Tasks"
msgstr "Uppgifter"

msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Tasks* används för att schemalägga coroutines *samtidigt*."

msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"När en coroutine paketeras in i en *Task* med funktioner som :func:`asyncio."
"create_task` schemaläggs coroutinen automatiskt för att köras snart::"

msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"

msgid "Futures"
msgstr "Terminskontrakt"

msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"En :class:`Future` är ett speciellt **lågnivå** väntande objekt som "
"representerar ett **eventuellt resultat** av en asynkron operation."

msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"När ett Future-objekt är *awaited* betyder det att coroutinen kommer att "
"vänta tills Future-objektet har lösts upp på något annat ställe."

msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Framtida objekt i asyncio behövs för att göra det möjligt att använda "
"callback-baserad kod med async/await."

msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Normalt **finns det inget behov** av att skapa Future-objekt på "
"applikationsnivå."

msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Framtida objekt, som ibland exponeras av bibliotek och vissa asyncio API:er, "
"kan inväntas::"

msgid ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # this is also valid:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"
msgstr ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # detta är också giltigt:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        någon_python_koroutin()\n"
"    )"

msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Ett bra exempel på en lågnivåfunktion som returnerar ett Future-objekt är :"
"meth:`loop.run_in_executor`."

msgid "Creating Tasks"
msgstr "Skapa uppgifter"

msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**Källkod:** :source:`Lib/asyncio/tasks.py`"

msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Packa in *coro* :ref:`coroutine <coroutine>` i en :class:`Task` och "
"schemalägg dess exekvering.  Returnera Task-objektet."

msgid ""
"The full function signature is largely the same as that of the :class:`Task` "
"constructor (or factory) - all of the keyword arguments to this function are "
"passed through to that interface."
msgstr ""
"Den fullständiga funktionssignaturen är i stort sett densamma som för :class:"
"`Task`-konstruktören (eller fabriken) - alla nyckelordsargument till denna "
"funktion skickas vidare till det gränssnittet."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *coro* ska köras i. Den "
"aktuella kontextkopian skapas när ingen *kontext* anges."

msgid ""
"An optional keyword-only *eager_start* argument allows specifying if the "
"task should execute eagerly during the call to create_task, or be scheduled "
"later. If *eager_start* is not passed the mode set by :meth:`loop."
"set_task_factory` will be used."
msgstr ""
"Ett valfritt argument *eager_start*, som endast innehåller nyckelord, gör "
"det möjligt att ange om uppgiften ska utföras ivrigt under anropet till "
"create_task eller schemaläggas senare. Om *eager_start* inte anges kommer "
"det läge som anges av :meth:`loop.set_task_factory` att användas."

msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"Uppgiften utförs i den loop som returneras av :func:`get_running_loop`, :exc:"
"`RuntimeError` uppstår om det inte finns någon loop i den aktuella tråden."

msgid ""
":meth:`asyncio.TaskGroup.create_task` is a new alternative leveraging "
"structural concurrency; it allows for waiting for a group of related tasks "
"with strong safety guarantees."
msgstr ""
":meth:`asyncio.TaskGroup.create_task` är ett nytt alternativ som utnyttjar "
"strukturell samtidighet; det gör det möjligt att vänta på en grupp "
"relaterade uppgifter med starka säkerhetsgarantier."

msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"Spara en referens till resultatet av denna funktion för att undvika att en "
"uppgift försvinner mitt under utförandet. Händelseslingan behåller bara "
"svaga referenser till uppgifter. En uppgift som inte refereras någon "
"annanstans kan när som helst bli skräpinsamlad, till och med innan den är "
"klar. För tillförlitliga \"skjut-och-glöm\"-bakgrundsuppgifter, samla dem i "
"en samling::"

msgid ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Add task to the set. This creates a strong reference.\n"
"    background_tasks.add(task)\n"
"\n"
"    # To prevent keeping references to finished tasks forever,\n"
"    # make each task remove its own reference from the set after\n"
"    # completion:\n"
"    task.add_done_callback(background_tasks.discard)"
msgstr ""
"background_tasks = set()\n"
"\n"
"för i i intervall(10):\n"
"    uppgift = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Lägg till uppgift till uppsättningen. Detta skapar en stark referens.\n"
"    background_tasks.add(uppgift)\n"
"\n"
"    # För att undvika att behålla referenser till avslutade uppgifter för "
"evigt,\n"
"    # varje uppgift ta bort sin egen referens från uppsättningen efter\n"
"    # slutförandet:\n"
"    task.add_done_callback(background_tasks.discard)"

msgid "Added the *name* parameter."
msgstr "Parametern *name* har lagts till."

msgid "Added the *context* parameter."
msgstr "Parametern *context* har lagts till."

msgid "Added the *eager_start* parameter by passing on all *kwargs*."
msgstr ""
"Lade till parametern *eager_start* genom att skicka vidare alla *kwargs*."

msgid "Task Cancellation"
msgstr "Avbokning av uppdrag"

msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""
"Uppgifter kan enkelt och säkert avbrytas. När en uppgift avbryts kommer :exc:"
"`asyncio.CancelledError` att skapas i uppgiften vid nästa tillfälle."

msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. :exc:"
"`asyncio.CancelledError` directly subclasses :exc:`BaseException` so most "
"code will not need to be aware of it."
msgstr ""
"Det rekommenderas att coroutines använder ``try/finally`` block för att "
"robust utföra rensningslogik. Om :exc:`asyncio.CancelledError` fångas "
"explicit, bör det i allmänhet spridas när upprensningen är klar. :exc:"
"`asyncio.CancelledError` underklassar direkt :exc:`BaseException` så den "
"mesta koden behöver inte vara medveten om det."

msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not generally call :"
"meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when suppressing :"
"exc:`asyncio.CancelledError` is truly desired, it is necessary to also call "
"``uncancel()`` to completely remove the cancellation state."
msgstr ""
"De asynciokomponenter som möjliggör strukturerad samtidighet, som :class:"
"`asyncio.TaskGroup` och :func:`asyncio.timeout`, implementeras med hjälp av "
"annullering internt och kan bete sig illa om en coroutine sväljer :exc:"
"`asyncio.CancelledError`. På samma sätt bör användarkod i allmänhet inte "
"anropa :meth:`uncancel <asyncio.Task.uncancel>`. Men i de fall då det "
"verkligen är önskvärt att undertrycka :exc:`asyncio.CancelledError`, är det "
"nödvändigt att också anropa ``uncancel()`` för att helt ta bort "
"annulleringstillståndet."

msgid "Task Groups"
msgstr "Arbetsgrupper"

msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""
"Uppgiftsgrupper kombinerar ett API för skapande av uppgifter med ett bekvämt "
"och tillförlitligt sätt att vänta på att alla uppgifter i gruppen ska bli "
"klara."

msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
"En :ref:``asynkron kontexthanterare <async-context-managers>`` som "
"innehåller en grupp av uppgifter. Uppgifter kan läggas till i gruppen med :"
"meth:`create_task`. Alla uppgifter är väntade när kontexthanteraren avslutas."

msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`. If the task group is inactive (e.g. not yet entered, "
"already finished, or in the process of shutting down), we will close the "
"given ``coro``."
msgstr ""
"Skapa en uppgift i denna uppgiftsgrupp. Signaturen matchar den för :func:"
"`asyncio.create_task`. Om uppgiftsgruppen är inaktiv (t.ex. ännu inte "
"påbörjad, redan avslutad eller håller på att stängas ner), stänger vi den "
"givna ``coro``."

msgid "Close the given coroutine if the task group is not active."
msgstr "Stäng den givna coroutinen om uppgiftsgruppen inte är aktiv."

msgid "Passes on all *kwargs* to :meth:`loop.create_task`"
msgstr "Vidarebefordrar alla *kwargs* till :meth:`loop.create_task`"

msgid "Example::"
msgstr "Exempel::"

msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2."
"result()}\")"
msgstr ""
"async def main():\n"
"    async med asyncio.TaskGroup() som tg:\n"
"        uppgift1 = tg.create_task(någon_coro(...))\n"
"        uppgift2 = tg.create_task(en annan_coro(...))\n"
"    print(f\"Båda uppgifterna har slutförts nu: {task1.result()}, {task2."
"result()}\")"

msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"Satsen ``async with`` väntar på att alla uppgifter i gruppen ska bli klara. "
"Under väntetiden kan nya uppgifter fortfarande läggas till i gruppen (till "
"exempel genom att skicka ``tg`` till en av coroutinerna och anropa ``tg."
"create_task()`` i den coroutinen). När den sista uppgiften har slutförts och "
"``async with``-blocket har avslutats, kan inga nya uppgifter läggas till i "
"gruppen."

msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"Första gången någon av de uppgifter som tillhör gruppen misslyckas med ett "
"annat undantag än :exc:`asyncio.CancelledError`, avbryts de återstående "
"uppgifterna i gruppen. Inga ytterligare uppgifter kan då läggas till i "
"gruppen. Vid denna tidpunkt, om kroppen i ``async with``-satsen fortfarande "
"är aktiv (dvs. :meth:`~object.__aexit__` har inte anropats ännu), avbryts "
"också den uppgift som direkt innehåller ``async with``-satsen. Det "
"resulterande :exc:`asyncio.CancelledError` kommer att avbryta en ``await``, "
"men det kommer inte att bubbla ut från den innehållande ``async with``-"
"satsen."

msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"När alla uppgifter har slutförts, om några uppgifter har misslyckats med ett "
"annat undantag än :exc:`asyncio.CancelledError`, kombineras dessa undantag i "
"en :exc:`ExceptionGroup` eller :exc:`BaseExceptionGroup` (beroende på vad "
"som är lämpligt; se deras dokumentation) som sedan tas upp."

msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"Två basundantag behandlas speciellt: Om någon uppgift misslyckas med :exc:"
"`KeyboardInterrupt` eller :exc:`SystemExit`, avbryter uppgiftsgruppen "
"fortfarande de återstående uppgifterna och väntar på dem, men då återkallas "
"den ursprungliga :exc:`KeyboardInterrupt` eller :exc:`SystemExit` istället "
"för :exc:`ExceptionGroup` eller :exc:`BaseExceptionGroup`."

msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"Om ``async with``-satsens kropp avslutas med ett undantag (så att :meth:"
"`~object.__aexit__` anropas med en undantagsuppsättning), behandlas detta på "
"samma sätt som om en av uppgifterna misslyckades: de återstående uppgifterna "
"avbryts och väntar sedan, och undantag som inte avbryts grupperas i en "
"undantagsgrupp och tas upp. Undantaget som skickas in i :meth:`~object."
"__aexit__`, om det inte är :exc:`asyncio.CancelledError`, ingår också i "
"undantagsgruppen. Samma specialfall görs för :exc:`KeyboardInterrupt` och :"
"exc:`SystemExit` som i föregående stycke."

msgid ""
"Task groups are careful not to mix up the internal cancellation used to "
"\"wake up\" their :meth:`~object.__aexit__` with cancellation requests for "
"the task in which they are running made by other parties. In particular, "
"when one task group is syntactically nested in another, and both experience "
"an exception in one of their child tasks simultaneously, the inner task "
"group will process its exceptions, and then the outer task group will "
"receive another cancellation and process its own exceptions."
msgstr ""
"Uppgiftsgrupper är noga med att inte blanda ihop den interna annullering som "
"används för att \"väcka\" deras :meth:`~object.__aexit__` med andra parters "
"annulleringsbegäran för den uppgift där de körs. I synnerhet när en "
"uppgiftsgrupp är syntaktiskt nästlad i en annan, och båda upplever ett "
"undantag i en av sina underordnade uppgifter samtidigt, kommer den inre "
"uppgiftsgruppen att behandla sina undantag, och sedan kommer den yttre "
"uppgiftsgruppen att få en annan annullering och behandla sina egna undantag."

msgid ""
"In the case where a task group is cancelled externally and also must raise "
"an :exc:`ExceptionGroup`, it will call the parent task's :meth:`~asyncio."
"Task.cancel` method. This ensures that a :exc:`asyncio.CancelledError` will "
"be raised at the next :keyword:`await`, so the cancellation is not lost."
msgstr ""
"I det fall en uppgiftsgrupp avbryts externt och även måste ge upphov till "
"en :exc:`ExceptionGroup`, kommer den att anropa den överordnade uppgiftens :"
"meth:`~asyncio.Task.cancel`-metod. Detta säkerställer att ett :exc:`asyncio."
"CancelledError` kommer att uppstå vid nästa :keyword:`await`, så att "
"annulleringen inte går förlorad."

msgid ""
"Task groups preserve the cancellation count reported by :meth:`asyncio.Task."
"cancelling`."
msgstr ""
"Uppgiftsgrupper behåller antalet avbokningar som rapporteras av :meth:"
"`asyncio.Task.cancelling`."

msgid ""
"Improved handling of simultaneous internal and external cancellations and "
"correct preservation of cancellation counts."
msgstr ""
"Förbättrad hantering av samtidiga interna och externa avbeställningar och "
"korrekt bevarande av antalet avbeställningar."

msgid "Terminating a Task Group"
msgstr "Avsluta en arbetsgrupp"

msgid ""
"While terminating a task group is not natively supported by the standard "
"library, termination can be achieved by adding an exception-raising task to "
"the task group and ignoring the raised exception:"
msgstr ""
"Även om standardbiblioteket inte har något inbyggt stöd för att avsluta en "
"uppgiftsgrupp, kan man göra det genom att lägga till en undantagshöjande "
"uppgift i uppgiftsgruppen och ignorera det undantag som uppstått:"

msgid ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"

msgid "Expected output:"
msgstr "Förväntad utgång:"

msgid ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"
msgstr ""
"Uppgift 1: start\n"
"Uppgift 2: start\n"
"Uppgift 1: klar"

msgid "Sleeping"
msgstr "Sovande"

msgid "Block for *delay* seconds."
msgstr "Blockera i *fördröjning* sekunder."

msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Om *result* anges returneras det till den som anropar när coroutinen "
"avslutas."

msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"```sleep()`` avbryter alltid den aktuella uppgiften, så att andra uppgifter "
"kan köras."

msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Om du ställer in fördröjningen till 0 får du en optimerad väg så att andra "
"uppgifter kan köras. Detta kan användas av funktioner som körs under lång "
"tid för att undvika att blockera händelseslingan under hela funktionsanropet."

msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exempel på coroutine som visar aktuellt datum varannan sekund i 5 sekunder::"

msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    medan True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"

msgid "Removed the *loop* parameter."
msgstr "Parametern *loop* har tagits bort."

msgid "Raises :exc:`ValueError` if *delay* is :data:`~math.nan`."
msgstr "Utlöser :exc:`ValueError` om *delay* är :data:`~math.nan`."

msgid "Running Tasks Concurrently"
msgstr "Köra uppgifter samtidigt"

msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Kör :ref:`awaitable objects <asyncio-awaitables>` i *aws*-sekvensen "
"*samtidigt*."

msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Om någon awaitable i *aws* är en coroutine schemaläggs den automatiskt som "
"en Task."

msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Om alla awaitables har slutförts framgångsrikt är resultatet en aggregerad "
"lista över returnerade värden.  Ordningen på resultatvärdena motsvarar "
"ordningen på awaitables i *aws*."

msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Om *return_exceptions* är ``False`` (standard), kommer det första undantaget "
"som uppstår omedelbart att överföras till den uppgift som väntar på "
"``gather()``.  Andra awaitables i *aws*-sekvensen **avbryts inte** och "
"fortsätter att köras."

msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Om *return_exceptions* är ``True``, behandlas undantag på samma sätt som "
"lyckade resultat och sammanställs i resultatlistan."

msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Om ``gather()`` är *avbruten*, är alla inskickade awaitables (som inte har "
"slutförts ännu) också *avbrutna*."

msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Om någon uppgift eller framtid från *aws*-sekvensen *annulleras*, behandlas "
"den som om den gav upphov till :exc:`CancelledError` -- anropet ``gather()`` "
"annulleras **inte** i detta fall.  Detta för att förhindra att avbrytandet "
"av en inskickad Task/Future orsakar avbrytande av andra Tasks/Futures."

msgid ""
"A new alternative to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`. *TaskGroup* provides stronger "
"safety guarantees than *gather* for scheduling a nesting of subtasks: if a "
"task (or a subtask, a task scheduled by a task) raises an exception, "
"*TaskGroup* will, while *gather* will not, cancel the remaining scheduled "
"tasks)."
msgstr ""
"Ett nytt alternativ för att skapa och köra uppgifter samtidigt och vänta på "
"att de ska slutföras är :class:`asyncio.TaskGroup`. *TaskGroup* ger starkare "
"säkerhetsgarantier än *gather* för schemaläggning av en nestning av "
"underuppgifter: om en uppgift (eller en underuppgift, en uppgift som "
"schemaläggs av en uppgift) ger upphov till ett undantag kommer *TaskGroup*, "
"medan *gather* inte gör det, att avbryta de återstående schemalagda "
"uppgifterna)."

msgid ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"
msgstr ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"

msgid ""
"If *return_exceptions* is false, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Om *return_exceptions* är false, kommer en avbrytning av gather() efter att "
"den har markerats som utförd inte att avbryta några inlämnade awaitables. "
"Till exempel kan gather markeras som utförd efter att ett undantag har "
"spridits till den som anropar, därför kommer inte anrop av ``gather."
"cancel()`` efter att ett undantag har fångats upp (av en av awaitables) från "
"gather att avbryta någon annan awaitable."

msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Om *gather* själv avbryts, sprids avbrottet oavsett *return_exceptions*."

msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""
"Deprecation-varning utfärdas om inga positionella argument anges eller om "
"inte alla positionella argument är Future-liknande objekt och det inte finns "
"någon pågående händelseslinga."

msgid "Eager Task Factory"
msgstr "Eager Task Factory"

msgid "A task factory for eager task execution."
msgstr "En uppgiftsfabrik för ivrig exekvering av uppgifter."

msgid ""
"When using this factory (via :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`), coroutines begin execution "
"synchronously during :class:`Task` construction. Tasks are only scheduled on "
"the event loop if they block. This can be a performance improvement as the "
"overhead of loop scheduling is avoided for coroutines that complete "
"synchronously."
msgstr ""
"När denna fabrik används (via :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`), börjar coroutines exekveras "
"synkront under :class:`Task`-konstruktionen. Uppgifterna schemaläggs endast "
"i händelseslingan om de blockeras. Detta kan förbättra prestandan eftersom "
"overhead för schemaläggning av loopar undviks för coroutines som slutförs "
"synkront."

msgid ""
"A common example where this is beneficial is coroutines which employ caching "
"or memoization to avoid actual I/O when possible."
msgstr ""
"Ett vanligt exempel där detta är fördelaktigt är coroutines som använder "
"caching eller memoization för att undvika faktisk I/O när det är möjligt."

msgid ""
"Immediate execution of the coroutine is a semantic change. If the coroutine "
"returns or raises, the task is never scheduled to the event loop. If the "
"coroutine execution blocks, the task is scheduled to the event loop. This "
"change may introduce behavior changes to existing applications. For example, "
"the application's task execution order is likely to change."
msgstr ""
"Omedelbar exekvering av coroutinen är en semantisk förändring. Om coroutinen "
"returnerar eller höjer, schemaläggs aldrig uppgiften till händelseslingan. "
"Om coroutine-exekveringen blockeras schemaläggs uppgiften till "
"händelseslingan. Denna förändring kan medföra beteendeförändringar i "
"befintliga applikationer. Till exempel kommer applikationens "
"exekveringsordning för uppgifter sannolikt att ändras."

msgid ""
"Create an eager task factory, similar to :func:`eager_task_factory`, using "
"the provided *custom_task_constructor* when creating a new task instead of "
"the default :class:`Task`."
msgstr ""
"Skapa en fabrik för ivriga uppgifter, liknande :func:`eager_task_factory`, "
"som använder den medföljande *custom_task_constructor* när en ny uppgift "
"skapas istället för standard :class:`Task`."

msgid ""
"*custom_task_constructor* must be a *callable* with the signature matching "
"the signature of :class:`Task.__init__ <Task>`. The callable must return a :"
"class:`asyncio.Task`-compatible object."
msgstr ""
"*custom_task_constructor* måste vara en *kallbar* med en signatur som "
"matchar signaturen för :class:`Task.__init__ <Task>`. Anropsbarheten måste "
"returnera ett :class:`asyncio.Task`-kompatibelt objekt."

msgid ""
"This function returns a *callable* intended to be used as a task factory of "
"an event loop via :meth:`loop.set_task_factory(factory) <loop."
"set_task_factory>`)."
msgstr ""
"Denna funktion returnerar en *kallbar* som är avsedd att användas som en "
"uppgiftsfabrik för en händelseslinga via :meth:`loop."
"set_task_factory(factory) <loop.set_task_factory>`)."

msgid "Shielding From Cancellation"
msgstr "Avskärmning från annullering"

msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Skydda ett :ref:`awaitable object <asyncio-awaitables>` från att bli :meth:"
"`cancelled <Task.cancel>`."

msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "Om *aw* är en coroutine schemaläggs den automatiskt som en Task."

msgid "The statement::"
msgstr "Uttalandet::"

msgid ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"
msgstr ""
"uppgift = asyncio.create_task(något())\n"
"res = await shield(uppgift)"

msgid "is equivalent to::"
msgstr "är likvärdig med::"

msgid "res = await something()"
msgstr "res = vänta på något()"

msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*utom* att om coroutinen som innehåller den avbryts, avbryts inte den Task "
"som körs i ``något()``.  Ur ``något()`` synvinkel skedde inte avbrytandet. "
"Även om dess anropare fortfarande avbryts, så ger \"await\"-uttrycket "
"fortfarande upphov till ett :exc:`CancelledError`."

msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Om ``något()`` upphävs på annat sätt (dvs. inifrån sig själv) skulle det "
"också upphäva ``sköld()``."

msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Om man vill ignorera annulleringen helt (rekommenderas inte) bör funktionen "
"``shield()`` kombineras med en try/except-sats enligt följande::"

msgid ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"
msgstr ""
"uppgift = asyncio.create_task(något())\n"
"försök:\n"
"    res = await shield(uppgift)\n"
"except CancelledError:\n"
"    res = Ingen"

msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"Spara en referens till uppgifter som skickas till denna funktion, för att "
"undvika att en uppgift försvinner mitt under utförandet. Händelseslingan "
"behåller bara svaga referenser till uppgifter. En uppgift som inte refereras "
"någon annanstans kan när som helst bli skräpinsamlad, även innan den är klar."

msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""
"Deprecation-varning utfärdas om *aw* inte är ett Future-like-objekt och det "
"inte finns någon pågående händelseslinga."

msgid "Timeouts"
msgstr "Tidsfrister"

msgid ""
"Return an :ref:`asynchronous context manager <async-context-managers>` that "
"can be used to limit the amount of time spent waiting on something."
msgstr ""
"Returnerar en :ref:``asynkron kontexthanterare <async-context-managers>`` "
"som kan användas för att begränsa den tid det tar att vänta på något."

msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* kan antingen vara ``None``, eller ett float/int antal sekunder att "
"vänta. Om *delay* är ``None`` kommer ingen tidsgräns att tillämpas; detta "
"kan vara användbart om fördröjningen är okänd när kontexthanteraren skapas."

msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""
"I båda fallen kan kontexthanteraren omplaneras efter skapandet med hjälp av :"
"meth:`Timeout.reschedule`."

msgid ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"
msgstr ""
"async def main():\n"
"    async med asyncio.timeout(10):\n"
"        await long_running_task()"

msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into a :exc:`TimeoutError` which "
"can be caught and handled."
msgstr ""
"Om ``long_running_task`` tar mer än 10 sekunder att slutföra kommer "
"kontexthanteraren att avbryta den aktuella uppgiften och hantera det "
"resulterande :exc:`asyncio.CancelledError` internt och omvandla det till "
"ett :exc:`TimeoutError` som kan fångas upp och hanteras."

msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into a :exc:`TimeoutError`, which means the :exc:"
"`TimeoutError` can only be caught *outside* of the context manager."
msgstr ""
"Kontexthanteraren :func:`asyncio.timeout` omvandlar :exc:`asyncio."
"CancelledError` till ett :exc:`TimeoutError`, vilket innebär att :exc:"
"`TimeoutError` endast kan fångas *utanför* kontexthanteraren."

msgid "Example of catching :exc:`TimeoutError`::"
msgstr "Exempel på att fånga :exc:`TimeoutError`::"

msgid ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        async med asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"Den långa operationen fick en timeout, men vi har hanterat "
"det.\")\n"
"\n"
"    print(\"Detta uttalande kommer att köras oavsett.\")"

msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""
"Den kontexthanterare som produceras av :func:`asyncio.timeout` kan "
"schemaläggas om till en annan deadline och inspekteras."

msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr ""
"En :ref:``asynkron kontexthanterare <async-context-managers>` för att "
"avbryta försenade coroutines."

msgid ""
"``when`` should be an absolute time at which the context should time out, as "
"measured by the event loop's clock:"
msgstr ""
"``when`` ska vara en absolut tidpunkt då kontexten ska ta slut, mätt med "
"händelseslingans klocka:"

msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "Om ``when`` är ``None`` kommer timeouten aldrig att utlösas."

msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""
"Om ``when < loop.time()``, kommer timeouten att utlösas vid nästa iteration "
"av händelseslingan."

msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr ""
"Returnerar den aktuella tidsfristen, eller ``None`` om den aktuella "
"tidsfristen inte har angetts."

msgid "Reschedule the timeout."
msgstr "Flytta fram timeouten."

msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr ""
"Returnerar om kontexthanteraren har överskridit sin tidsfrist (expired)."

msgid ""
"async def main():\n"
"    try:\n"
"        # We do not know the timeout when starting, so we pass ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # We know the timeout now, so we reschedule it.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        # Vi vet inte timeouten när vi startar, så vi skickar ``None``.\n"
"        async med asyncio.timeout(None) som cm:\n"
"            # Vi känner till tidsgränsen nu, så vi flyttar den.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(ny_deadline)\n"
"\n"
"            await long_running_task()\n"
"    utom TimeoutError:\n"
"        passera\n"
"\n"
"    if cm.expired():\n"
"        print(\"Det ser ut som om vi inte blev klara i tid.\")"

msgid "Timeout context managers can be safely nested."
msgstr "Timeout-kontexthanterare kan säkert nästlas."

msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""
"Liknar :func:`asyncio.timeout`, förutom att *when* är den absoluta tiden för "
"att sluta vänta, eller ``None``."

msgid ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.tid() + 20\n"
"    försök:\n"
"        async med asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"Den långa operationen timade ut, men vi har hanterat det."
"\")\n"
"\n"
"    print(\"Detta uttalande kommer att köras oavsett.\")"

msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Vänta på att *aw* :ref:`awaitable <asyncio-awaitables>` ska slutföras med en "
"timeout."

msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* kan antingen vara ``None`` eller ett float eller int antal "
"sekunder att vänta på.  Om *timeout* är ``None``, blockeras tills framtiden "
"är klar."

msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr ""
"Om en timeout inträffar avbryts uppgiften och :exc:`TimeoutError` visas."

msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"För att undvika uppgiften :meth:`cancellation <Task.cancel>`, linda in den "
"i :func:`shield`."

msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"Funktionen kommer att vänta tills framtiden faktiskt avbryts, så den totala "
"väntetiden kan överstiga *timeout*. Om ett undantag inträffar under "
"annulleringen sprids det."

msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Om väntan avbryts, avbryts också den framtida *aw*."

msgid ""
"async def eternity():\n"
"    # Sleep for one hour\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Wait for at most 1 second\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"
msgstr ""
"async def evighet():\n"
"    # Sova i en timme\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Vänta i högst 1 sekund\n"
"    försök:\n"
"        await asyncio.wait_for(evighet(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Förväntad utgång:\n"
"#\n"
"# timeout!"

msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"När *aw* avbryts på grund av en timeout, väntar ``wait_for`` på att *aw* ska "
"avbrytas.  Tidigare gav det upphov till :exc:`TimeoutError` omedelbart."

msgid "Raises :exc:`TimeoutError` instead of :exc:`asyncio.TimeoutError`."
msgstr "Utlöser :exc:`TimeoutError` istället för :exc:`asyncio.TimeoutError`."

msgid "Waiting Primitives"
msgstr "Primitiva väntetider"

msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"Kör :class:`~asyncio.Future` och :class:`~asyncio.Task`-instanser i *aws*-"
"iterabeln samtidigt och blockera till det villkor som anges av *return_when*."

msgid "The *aws* iterable must not be empty."
msgstr "*aws*-iterabeln får inte vara tom."

msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Returnerar två uppsättningar av Tasks/Futures: ``(utförd, väntande)``."

msgid "Usage::"
msgstr "Användning::"

msgid "done, pending = await asyncio.wait(aws)"
msgstr "done, pending = await asyncio.wait(aws)"

msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (en float eller int), om den anges, kan användas för att styra det "
"maximala antalet sekunder som ska väntas innan återgång."

msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"Observera att denna funktion inte ger upphov till :exc:`TimeoutError`. "
"Futures eller Tasks som inte är klara när timeouten inträffar returneras "
"helt enkelt i den andra uppsättningen."

msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* anger när denna funktion ska returnera.  Den måste vara en av "
"följande konstanter:"

msgid "Constant"
msgstr "Konstant"

msgid "Description"
msgstr "Beskrivning"

msgid "The function will return when any future finishes or is cancelled."
msgstr ""
"Funktionen kommer att återkomma när någon framtid avslutas eller avbryts."

msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"Funktionen återkommer när en framtid avslutas genom att ett undantag "
"utlöses. Om ingen framtid ger upphov till ett undantag så är det likvärdigt "
"med :const:`ALL_COMPLETED`."

msgid "The function will return when all futures finish or are cancelled."
msgstr "Funktionen återkommer när alla terminer är avslutade eller avbrutna."

msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"Till skillnad från :func:`~asyncio.wait_for` avbryter inte ``wait()`` "
"futures när en timeout inträffar."

msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "Det är förbjudet att skicka coroutine-objekt direkt till ``wait()``."

msgid "Added support for generators yielding tasks."
msgstr "Stöd för generatorer som ger uppgifter har lagts till."

msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently. The returned object can be iterated to obtain the results of "
"the awaitables as they finish."
msgstr ""
"Kör :ref:``awaitable objects <asyncio-awaitables>`` i *aws*-iterabeln "
"samtidigt. Det returnerade objektet kan itereras för att få resultaten från "
"awaitables när de avslutas."

msgid ""
"The object returned by ``as_completed()`` can be iterated as an :term:"
"`asynchronous iterator` or a plain :term:`iterator`. When asynchronous "
"iteration is used, the originally-supplied awaitables are yielded if they "
"are tasks or futures. This makes it easy to correlate previously-scheduled "
"tasks with their results. Example::"
msgstr ""
"Objektet som returneras av ``as_completed()`` kan itereras som en :term:"
"`asynkron iterator` eller en vanlig :term:`iterator`. När asynkron iteration "
"används, blir de ursprungligen levererade awaitables yielded om de är tasks "
"eller futures. Detta gör det enkelt att korrelera tidigare schemalagda "
"uppgifter med deras resultat. Exempel::"

msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect is done. The result can be obtained by\n"
"    # awaiting it or calling earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"IPv6 connection established.\")\n"
"    else:\n"
"        print(\"IPv4 connection established.\")"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"uppgifter = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect är klar. Resultatet kan erhållas genom att\n"
"    # vänta på det eller anropa earliest_connect.result()\n"
"    reader, writer = vänta på earliest_connect\n"
"\n"
"    om earliest_connect är ipv6_connect:\n"
"        print(\"IPv6-anslutning upprättad.\")\n"
"    annat:\n"
"        print(\"IPv4-anslutning upprättad.\")"

msgid ""
"During asynchronous iteration, implicitly-created tasks will be yielded for "
"supplied awaitables that aren't tasks or futures."
msgstr ""
"Under asynkron iteration kommer implicit skapade uppgifter att ges för "
"levererade awaitables som inte är uppgifter eller futures."

msgid ""
"When used as a plain iterator, each iteration yields a new coroutine that "
"returns the result or raises the exception of the next completed awaitable. "
"This pattern is compatible with Python versions older than 3.13::"
msgstr ""
"När den används som en vanlig iterator ger varje iteration en ny coroutine "
"som returnerar resultatet eller väcker undantaget för nästa slutförda "
"awaitable. Detta mönster är kompatibelt med Python-versioner äldre än 3.13::"

msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect is not one of the original task objects. It must be\n"
"    # awaited to obtain the result value or raise the exception of the\n"
"    # awaitable that finishes next.\n"
"    reader, writer = await next_connect"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"uppgifter = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect är inte ett av de ursprungliga uppgiftsobjekten. Det "
"måste vara\n"
"    # väntas för att få fram resultatvärdet eller väcka undantag för den\n"
"    # awaitable som avslutas härnäst.\n"
"    reader, writer = vänta på next_connect"

msgid ""
"A :exc:`TimeoutError` is raised if the timeout occurs before all awaitables "
"are done. This is raised by the ``async for`` loop during asynchronous "
"iteration or by the coroutines yielded during plain iteration."
msgstr ""
"Ett :exc:`TimeoutError` uppstår om timeouten inträffar innan alla awaitables "
"är klara. Detta orsakas av ``async for``-loopen under asynkron iteration "
"eller av de coroutines som uppstår under vanlig iteration."

msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""
"Deprecation-varning utfärdas om inte alla awaitable-objekt i *aws*-iterabeln "
"är Future-liknande objekt och det inte finns någon pågående händelseslinga."

msgid ""
"The result can now be used as either an :term:`asynchronous iterator` or as "
"a plain :term:`iterator` (previously it was only a plain iterator)."
msgstr ""
"Resultatet kan nu användas som antingen en :term:`asynkron iterator` eller "
"som en vanlig :term:`iterator` (tidigare var det bara en vanlig iterator)."

msgid "Running in Threads"
msgstr "Löpande i trådar"

msgid "Asynchronously run function *func* in a separate thread."
msgstr "Asynkron körning av funktionen *func* i en separat tråd."

msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Alla \\*args och \\*\\*kwargs som anges för denna funktion skickas direkt "
"till *func*. Dessutom sprids den aktuella :class:`contextvars.Context`, "
"vilket gör att kontextvariabler från händelseslingans tråd kan nås i den "
"separata tråden."

msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Returnera en coroutine som kan inväntas för att få det slutliga resultatet "
"av *func*."

msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""
"Denna coroutine-funktion är främst avsedd att användas för att köra IO-"
"bundna funktioner/metoder som annars skulle blockera händelseslingan om de "
"kördes i huvudtråden. Till exempel::"

msgid ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # Note that time.sleep() can be replaced with any blocking\n"
"    # IO-bound operation, such as file operations.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"
msgstr ""
"def blocking_io():\n"
"    print(f\"starta blockering_io vid {time.strftime('%X')}\")\n"
"    # Observera att time.sleep() kan ersättas med vilken blockerande\n"
"    # IO-bunden operation, t.ex. filoperationer.\n"
"    time.sleep(1)\n"
"    print(f\"blockering_io slutförd vid {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"startade main vid {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"avslutade huvudtråden vid {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Förväntad utgång:\n"
"#\n"
"# startade main kl 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"

msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"Att direkt anropa ``blocking_io()`` i en coroutine skulle blockera "
"händelseslingan under hela dess varaktighet, vilket resulterar i ytterligare "
"1 sekunds körtid. Genom att istället använda ``asyncio.to_thread()`` kan vi "
"köra den i en separat tråd utan att blockera händelseslingan."

msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"På grund av :term:`GIL` kan ``asyncio.to_thread()`` vanligtvis bara användas "
"för att göra IO-bundna funktioner icke-blockerande. Men för tilläggsmoduler "
"som släpper GIL eller alternativa Python-implementationer som inte har "
"någon, kan ``asyncio.to_thread()`` även användas för CPU-bundna funktioner."

msgid "Scheduling From Other Threads"
msgstr "Schemaläggning från andra trådar"

msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "Skicka en coroutine till den angivna händelseslingan.  Tråd-säker."

msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Returnera en :class:`concurrent.futures.Future` för att vänta på resultatet "
"från en annan OS-tråd."

msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Denna funktion är avsedd att anropas från en annan OS-tråd än den där "
"händelseslingan körs.  Exempel::"

msgid ""
"def in_thread(loop: asyncio.AbstractEventLoop) -> None:\n"
"    # Run some blocking IO\n"
"    pathlib.Path(\"example.txt\").write_text(\"hello world\", "
"encoding=\"utf8\")\n"
"\n"
"    # Create a coroutine\n"
"    coro = asyncio.sleep(1, result=3)\n"
"\n"
"    # Submit the coroutine to a given loop\n"
"    future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"    # Wait for the result with an optional timeout argument\n"
"    assert future.result(timeout=2) == 3\n"
"\n"
"async def amain() -> None:\n"
"    # Get the running loop\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Run something in a thread\n"
"    await asyncio.to_thread(in_thread, loop)"
msgstr ""
"def in_thread(loop: asyncio.AbstractEventLoop) -> None:\n"
"    # Kör lite blockerande IO\n"
"    pathlib.Path(\"exempel.txt\").write_text(\"hallå världen\", "
"encoding=\"utf8\")\n"
"\n"
"    # Skapa en coroutine\n"
"    coro = asyncio.sleep(1, resultat=3)\n"
"\n"
"    # Skicka coroutinen till en given loop\n"
"    future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"    # Vänta på resultatet med ett valfritt timeout-argument\n"
"    assert future.result(timeout=2) == 3\n"
"\n"
"async def amain() -> Ingen:\n"
"    # Hämta den pågående slingan\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    # Kör något i en tråd\n"
"    await asyncio.to_thread(in_thread, loop)"

msgid "It's also possible to run the other way around.  Example::"
msgstr "Det är också möjligt att köra tvärtom.  Exempel::"

msgid ""
"@contextlib.contextmanager\n"
"def loop_in_thread() -> Generator[asyncio.AbstractEventLoop]:\n"
"    loop_fut = concurrent.futures.Future[asyncio.AbstractEventLoop]()\n"
"    stop_event = asyncio.Event()\n"
"\n"
"    async def main() -> None:\n"
"        loop_fut.set_result(asyncio.get_running_loop())\n"
"        await stop_event.wait()\n"
"\n"
"    with concurrent.futures.ThreadPoolExecutor(1) as tpe:\n"
"        complete_fut = tpe.submit(asyncio.run, main())\n"
"        for fut in concurrent.futures.as_completed((loop_fut, "
"complete_fut)):\n"
"            if fut is loop_fut:\n"
"                loop = loop_fut.result()\n"
"                try:\n"
"                    yield loop\n"
"                finally:\n"
"                    loop.call_soon_threadsafe(stop_event.set)\n"
"            else:\n"
"                fut.result()\n"
"\n"
"# Create a loop in another thread\n"
"with loop_in_thread() as loop:\n"
"    # Create a coroutine\n"
"    coro = asyncio.sleep(1, result=3)\n"
"\n"
"    # Submit the coroutine to a given loop\n"
"    future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"    # Wait for the result with an optional timeout argument\n"
"    assert future.result(timeout=2) == 3"
msgstr ""
"@kontextlib.kontexthanterare\n"
"def loop_in_thread() -> Generator[asyncio.AbstractEventLoop]:\n"
"    loop_fut = concurrent.futures.Future[asyncio.AbstractEventLoop]()\n"
"    stop_event = asyncio.Event()\n"
"\n"
"    async def main() -> None:\n"
"        loop_fut.set_result(asyncio.get_running_loop())\n"
"        await stop_event.wait()\n"
"\n"
"    med concurrent.futures.ThreadPoolExecutor(1) som tpe:\n"
"        complete_fut = tpe.submit(asyncio.run, main())\n"
"        for fut in concurrent.futures.as_completed((loop_fut, "
"complete_fut)):\n"
"            if fut is loop_fut:\n"
"                loop = loop_fut.result()\n"
"                försök:\n"
"                    ge loop\n"
"                till sist:\n"
"                    loop.call_soon_threadsafe(stop_event.set)\n"
"            else:\n"
"                fut.result()\n"
"\n"
"# Skapa en slinga i en annan tråd\n"
"med loop_in_thread() som loop:\n"
"    # Skapa en coroutine\n"
"    coro = asyncio.sleep(1, resultat=3)\n"
"\n"
"    # Skicka coroutinen till en given slinga\n"
"    future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"    # Vänta på resultatet med ett valfritt timeout-argument\n"
"    assert future.result(timeout=2) == 3"

msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Om ett undantag inträffar i coroutinen kommer den returnerade Future att "
"meddelas.  Den kan också användas för att avbryta uppgiften i "
"händelseslingan::"

msgid ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"
msgstr ""
"försök:\n"
"    resultat = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('Coroutinen tog för lång tid och avbröt uppgiften...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'Coroutinen tog upp ett undantag: {exc!r}')\n"
"else:\n"
"    print(f'Coroutinen returnerade: {result!r}')"

msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Se :ref:``concurrency and multithreading <asyncio-multithreading>` i "
"dokumentationen."

msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"Till skillnad från andra asynciofunktioner kräver den här funktionen att "
"argumentet *loop* skickas explicit."

msgid "Introspection"
msgstr "Introspektion"

msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Returnerar den instans av :class:`Task` som körs för tillfället, eller "
"``None`` om ingen uppgift körs."

msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Om *loop* är ``None`` används :func:`get_running_loop` för att hämta den "
"aktuella loopen."

msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Returnerar en uppsättning ännu inte avslutade :class:`Task`-objekt som körs "
"av slingan."

msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Om *loop* är ``None``, används :func:`get_running_loop` för att hämta "
"aktuell loop."

msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "Returnerar ``True`` om *obj* är ett coroutine-objekt."

msgid "Task Object"
msgstr "Uppgiftsobjekt"

msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Ett :class:`Future-liknande <Future>`-objekt som kör en Python :ref:"
"`coroutine <coroutine>`.  Inte tråd-säkert."

msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Tasks används för att köra coroutines i händelseslingor. Om en coroutine "
"väntar på en Future, avbryter Task exekveringen av coroutinen och väntar på "
"att Future ska slutföras.  När framtiden är *färdig* återupptas exekveringen "
"av den omslutna coroutinen."

msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Eventloops använder kooperativ schemaläggning: en eventloop kör en Task åt "
"gången.  Medan en Task väntar på att en Future ska slutföras, kör "
"eventloopen andra Tasks, callbacks eller utför IO-operationer."

msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Använd högnivåfunktionen :func:`asyncio.create_task` för att skapa Tasks, "
"eller lågnivåfunktionerna :meth:`loop.create_task` eller :func:"
"`ensure_future`.  Manuell instansiering av Tasks avråds."

msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"För att avbryta en pågående Task används metoden :meth:`cancel`.  Om du "
"anropar den kommer uppgiften att kasta ett :exc:`CancelledError` undantag i "
"den omslutna coroutinen.  Om en coroutine väntar på ett Future-objekt under "
"avbrytandet, kommer Future-objektet att avbrytas."

msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` kan användas för att kontrollera om uppgiften avbröts. "
"Metoden returnerar ``True`` om den inlindade coroutinen inte undertryckte :"
"exc:`CancelledError` undantaget och faktiskt avbröts."

msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` ärver från :class:`Future` alla dess API:er utom :meth:"
"`Future.set_result` och :meth:`Future.set_exception`."

msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. If no *context* is "
"provided, the Task copies the current context and later runs its coroutine "
"in the copied context."
msgstr ""
"Ett valfritt argument *context* med endast nyckelord gör det möjligt att "
"ange en anpassad :class:`contextvars.Context` som *coro* ska köras i. Om "
"ingen *kontext* anges kopierar uppgiften den aktuella kontexten och kör "
"senare sin coroutine i den kopierade kontexten."

msgid ""
"An optional keyword-only *eager_start* argument allows eagerly starting the "
"execution of the :class:`asyncio.Task` at task creation time. If set to "
"``True`` and the event loop is running, the task will start executing the "
"coroutine immediately, until the first time the coroutine blocks. If the "
"coroutine returns or raises without blocking, the task will be finished "
"eagerly and will skip scheduling to the event loop."
msgstr ""
"Ett valfritt argument *eager_start* som endast innehåller nyckelord gör det "
"möjligt att ivrigt starta exekveringen av :class:`asyncio.Task` när "
"uppgiften skapas. Om värdet är satt till ``True`` och händelseslingan körs, "
"kommer uppgiften att börja exekvera coroutinen omedelbart, tills första "
"gången coroutinen blockerar. Om coroutinen returnerar eller höjs utan att "
"blockera, kommer uppgiften att slutföras ivrigt och hoppa över "
"schemaläggningen till händelseslingan."

msgid "Added support for the :mod:`contextvars` module."
msgstr "Lagt till stöd för modulen :mod:`contextvars`."

msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"Deprecation-varning utfärdas om *loop* inte anges och det inte finns någon "
"pågående händelseslinga."

msgid "Added the *eager_start* parameter."
msgstr "Parametern *eager_start* har lagts till."

msgid "Return ``True`` if the Task is *done*."
msgstr "Returnerar ``True`` om uppgiften är *done*."

msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"En Task är *färdig* när den omslutna coroutinen antingen returnerade ett "
"värde, utlöste ett undantag eller när Task avbröts."

msgid "Return the result of the Task."
msgstr "Returnera resultatet av uppgiften."

msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Om uppgiften är *utförd* returneras resultatet av den omslutna coroutinen "
"(eller om coroutinen gav upphov till ett undantag, ges det undantaget upp "
"igen)"

msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Om uppgiften har *avbrutits* ger den här metoden upphov till ett :exc:"
"`CancelledError`-undantag."

msgid ""
"If the Task's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Om uppgiftens resultat ännu inte är tillgängligt ger denna metod upphov till "
"ett :exc:`InvalidStateError`-undantag."

msgid "Return the exception of the Task."
msgstr "Returnera undantaget för uppgiften."

msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Om den inkapslade coroutinen gav upphov till ett undantag returneras "
"undantaget.  Om den inkapslade coroutinen returnerades normalt returnerar "
"denna metod ``None``."

msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Om uppgiften inte är *färdig* ännu, ger denna metod upphov till ett :exc:"
"`InvalidStateError`-undantag."

msgid "Add a callback to be run when the Task is *done*."
msgstr "Lägg till en återuppringning som ska köras när uppgiften är *klar*."

msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Denna metod bör endast användas i kod som bygger på återuppringning på låg "
"nivå."

msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Se dokumentationen av :meth:`Future.add_done_callback` för mer information."

msgid "Remove *callback* from the callbacks list."
msgstr "Ta bort *callback* från listan över callbacks."

msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Se dokumentationen av :meth:`Future.remove_done_callback` för mer "
"information."

msgid "Return the list of stack frames for this Task."
msgstr "Returnera listan med stapelramar för denna Task."

msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Om den inkapslade coroutinen inte är klar returneras den stack där den är "
"avbruten.  Om coroutinen har slutförts framgångsrikt eller avbrutits, "
"returneras en tom lista. Om coroutinen avslutades av ett undantag returneras "
"listan med spårningsramar."

msgid "The frames are always ordered from oldest to newest."
msgstr "Ramarna är alltid sorterade från äldst till nyast."

msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Endast en stackram returneras för en avbruten coroutine."

msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"Det valfria argumentet *limit* anger det maximala antalet ramar som ska "
"returneras; som standard returneras alla tillgängliga ramar. Ordningen på "
"listan som returneras skiljer sig åt beroende på om en stack eller en "
"traceback returneras: de nyaste ramarna i en stack returneras, men de äldsta "
"ramarna i en traceback returneras.  (Detta motsvarar beteendet hos traceback-"
"modulen)"

msgid "Print the stack or traceback for this Task."
msgstr "Skriv ut stacken eller traceback för den här uppgiften."

msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Detta ger liknande utdata som traceback-modulen för de ramar som hämtas av :"
"meth:`get_stack`."

msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "Argumentet *limit* skickas direkt till :meth:`get_stack`."

msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr ""
"Argumentet *file* är en I/O-ström som utdata skrivs till; som standard "
"skrivs utdata till :data:`sys.stdout`."

msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Returnerar coroutine-objektet som omsluts av :class:`Task`."

msgid ""
"This will return ``None`` for Tasks which have already completed eagerly. "
"See the :ref:`Eager Task Factory <eager-task-factory>`."
msgstr ""
"Detta kommer att returnera ``None`` för uppgifter som redan har slutförts "
"ivrigt. Se :ref:`Eager Task Factory <eager-task-factory>`."

msgid "Newly added eager task execution means result may be ``None``."
msgstr ""
"Nyligen tillagd ivrig uppgiftsutförande innebär att resultatet kan vara "
"``None``."

msgid ""
"Return the :class:`contextvars.Context` object associated with the task."
msgstr ""
"Returnerar :class:`contextvars.Context`-objektet som är associerat med "
"uppgiften."

msgid "Return the name of the Task."
msgstr "Returnera namnet på uppgiften."

msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Om inget namn uttryckligen har tilldelats uppgiften genererar "
"standardimplementeringen av asyncio-uppgiften ett standardnamn under "
"instantiering."

msgid "Set the name of the Task."
msgstr "Ange namnet på uppgiften."

msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"Argumentet *value* kan vara vilket objekt som helst, som sedan konverteras "
"till en sträng."

msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"I standardimplementeringen av Task kommer namnet att synas i :func:`repr`-"
"utmatningen från ett Task-objekt."

msgid "Request the Task to be cancelled."
msgstr "Begär att uppgiften ska avbrytas."

msgid ""
"If the Task is already *done* or *cancelled*, return ``False``, otherwise, "
"return ``True``."
msgstr ""
"Om uppgiften redan är *utförd* eller *annullerad*, returneras ``False``, "
"annars returneras ``True``."

msgid ""
"The method arranges for a :exc:`CancelledError` exception to be thrown into "
"the wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Metoden ser till att ett :exc:`CancelledError`-undantag kastas in i den "
"omslutna coroutinen vid nästa cykel i händelseslingan."

msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged.  Should the coroutine nevertheless decide to "
"suppress the cancellation, it needs to call :meth:`Task.uncancel` in "
"addition to catching the exception."
msgstr ""
"Coroutinen har sedan en chans att städa upp eller till och med neka begäran "
"genom att undertrycka undantaget med ett :keyword:`try` ... ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Till skillnad från :meth:"
"`Future.cancel` garanterar därför :meth:`Task.cancel` inte att uppgiften "
"kommer att avbrytas, även om det inte är vanligt att helt undertrycka "
"avbrytande och aktivt avråds från detta.  Om coroutinen ändå bestämmer sig "
"för att undertrycka annulleringen måste den anropa :meth:`Task.uncancel` "
"utöver att fånga upp undantaget."

msgid "Added the *msg* parameter."
msgstr "Parametern *msg* har lagts till."

msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr ""
"Parametern ``msg`` sprids från den avbrutna uppgiften till den som väntar på "
"den."

msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"Följande exempel illustrerar hur coroutines kan fånga upp begäran om "
"annullering::"

msgid ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # Wait for 1 hour\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Create a \"cancel_me\" Task\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Wait for 1 second\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"
msgstr ""
"async def cancel_me():\n"
"    print('cancel_me(): före sömn')\n"
"\n"
"    försök:\n"
"        # Vänta i 1 timme\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): avbryt sömn')\n"
"        höja\n"
"    slutligen:\n"
"        print('cancel_me(): efter sömn')\n"
"\n"
"async def main():\n"
"    # Skapa en \"cancel_me\"-uppgift\n"
"    uppgift = asyncio.create_task(cancel_me())\n"
"\n"
"    # Vänta i 1 sekund\n"
"    await asyncio.sleep(1)\n"
"\n"
"    uppgift.avbryt()\n"
"    försök:\n"
"        await uppgift\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me är avbruten nu\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Förväntad utgång:\n"
"#\n"
"# cancel_me(): före sömn\n"
"# cancel_me(): avbryta sömn\n"
"# cancel_me(): efter sömn\n"
"# main(): cancel_me är avbruten nu"

msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Returnerar ``True`` om uppgiften är *annullerad*."

msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"Uppgiften är *avbruten* när avbrytandet begärdes med :meth:`cancel` och den "
"omslutna coroutinen spred undantaget :exc:`CancelledError` som kastades in i "
"den."

msgid "Decrement the count of cancellation requests to this Task."
msgstr "Minska antalet avbokningsbegäranden för den här uppgiften."

msgid "Returns the remaining number of cancellation requests."
msgstr "Returnerar det återstående antalet avbokningsbegäranden."

msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""
"Observera att när en avbruten uppgift har utförts är ytterligare anrop till :"
"meth:`uncancel` ineffektiva."

msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"Den här metoden används av asyncios interna funktioner och förväntas inte "
"användas av slutanvändarkod.  I synnerhet, om en uppgift framgångsrikt "
"avbokas, gör detta att element av strukturerad samtidighet som :ref:"
"`taskgroups` och :func:`asyncio.timeout` kan fortsätta att köras, vilket "
"isolerar avbokningen till respektive strukturerat block. Till exempel::"

msgid ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Structured block affected by the timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # Outer code not affected by the timeout:\n"
"    await unrelated_code()"
msgstr ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async med asyncio.timeout(1):\n"
"            # Strukturerat block som påverkas av timeouten:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"Det uppstod en timeout\")\n"
"    # Yttre kod som inte påverkas av timeouten:\n"
"    await orelaterad_kod()"

msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""
"Medan blocken med ``make_request()`` och ``make_another_request()`` kan "
"avbrytas på grund av timeout, bör ``unrelated_code()`` fortsätta att köras "
"även om timeout inträffar.  Detta implementeras med :meth:`uncancel`. :class:"
"`TaskGroup` kontexthanterare använder :func:`uncancel` på ett liknande sätt."

msgid ""
"If end-user code is, for some reason, suppressing cancellation by catching :"
"exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr ""
"Om slutanvändarkoden av någon anledning undertrycker annullering genom att "
"fånga :exc:`CancelledError`, måste den anropa denna metod för att ta bort "
"annulleringstillståndet."

msgid ""
"When this method decrements the cancellation count to zero, the method "
"checks if a previous :meth:`cancel` call had arranged for :exc:"
"`CancelledError` to be thrown into the task. If it hasn't been thrown yet, "
"that arrangement will be rescinded (by resetting the internal "
"``_must_cancel`` flag)."
msgstr ""
"När den här metoden minskar antalet avbokningar till noll, kontrollerar "
"metoden om ett tidigare :meth:`cancel`-anrop hade ordnat så att :exc:"
"`CancelledError` kunde kastas in i uppgiften. Om det inte har gjorts ännu, "
"kommer det arrangemanget att återkallas (genom att återställa den interna "
"``_must_cancel`` flaggan)."

msgid "Changed to rescind pending cancellation requests upon reaching zero."
msgstr ""
"Ändrad för att återkalla pågående annulleringsförfrågningar när de når noll."

msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""
"Returnerar antalet väntande avbokningsbegäranden till denna uppgift, dvs. "
"antalet anrop till :meth:`cancel` minus antalet anrop till :meth:`uncancel`."

msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"Observera att om detta antal är större än noll men uppgiften fortfarande "
"körs, kommer :meth:`cancelled` fortfarande att returnera ``False``. Detta "
"beror på att detta antal kan sänkas genom att anropa :meth:`uncancel`, "
"vilket kan leda till att uppgiften inte avbryts trots allt om begäran om "
"avbrytande går ner till noll."

msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""
"Den här metoden används av asyncios interna funktioner och förväntas inte "
"användas av slutanvändarkod.  Se :meth:`uncancel` för mer information."
