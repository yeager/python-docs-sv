# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Data Structures"
msgstr "Datastrukturer"

msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"I det här kapitlet beskrivs vissa saker som du redan har lärt dig mer "
"ingående, och några nya saker läggs till."

msgid "More on Lists"
msgstr "Mer om listor"

msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"Datatypen list har några fler metoder.  Här är alla metoder för listobjekt:"

msgid "Add an item to the end of the list.  Similar to ``a[len(a):] = [x]``."
msgstr ""
"Lägger till ett objekt i slutet av listan.  Liknar ``a[len(a):] = [x]``."

msgid ""
"Extend the list by appending all the items from the iterable.  Similar to "
"``a[len(a):] = iterable``."
msgstr ""
"Förläng listan genom att lägga till alla objekt från iterabeln.  Liknar "
"``a[len(a):] = iterabel``."

msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Infoga ett element på en given position.  Det första argumentet är indexet "
"för det element som ska infogas före, så ``a.insert(0, x)`` infogar längst "
"fram i listan, och ``a.insert(len(a), x)`` är likvärdigt med ``a.append(x)``."

msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Tar bort det första objektet från listan vars värde är lika med *x*.  Det "
"ger upphov till ett :exc:`ValueError` om det inte finns något sådant objekt."

msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is "
"outside the list range."
msgstr ""
"Tar bort objektet på den angivna positionen i listan och returnerar det.  Om "
"inget index anges, tar ``a.pop()`` bort och returnerar det sista objektet i "
"listan. Den ger upphov till ett :exc:`IndexError` om listan är tom eller om "
"indexet ligger utanför listintervallet."

msgid "Remove all items from the list.  Similar to ``del a[:]``."
msgstr "Ta bort alla objekt från listan.  Påminner om ``del a[:]``."

msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"Returnerar nollbaserat index i listan för det första objektet vars värde är "
"lika med *x*. Utlöser ett :exc:`ValueError` om det inte finns något sådant "
"objekt."

msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"De valfria argumenten *start* och *end* tolkas som i slice-notationen och "
"används för att begränsa sökningen till en viss delsekvens av listan.  Det "
"returnerade indexet beräknas i förhållande till början av den fullständiga "
"sekvensen i stället för argumentet *start*."

msgid "Return the number of times *x* appears in the list."
msgstr "Returnera antalet gånger *x* förekommer i listan."

msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Sortera objekten i listan på plats (argumenten kan användas för att anpassa "
"sorteringen, se :func:`sorted` för deras förklaring)."

msgid "Reverse the elements of the list in place."
msgstr "Backa tillbaka elementen i listan på plats."

msgid "Return a shallow copy of the list.  Similar to ``a[:]``."
msgstr "Returnerar en ytlig kopia av listan.  Liknar ``a[:]``."

msgid "An example that uses most of the list methods::"
msgstr "Ett exempel som använder de flesta av listans metoder::"

msgid ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"
msgstr ""
">>> frukter = ['apelsin', 'äpple', 'päron', 'banan', 'kiwi', 'äpple', "
"'banan'] >>> frukter\n"
">>> frukter.räkna('äpple')\n"
"2\n"
">>> frukter.räkning('mandarin')\n"
"0\n"
">>> frukt.index('banan')\n"
"3\n"
">>> fruits.index('banana', 4) # Hitta nästa banan med början vid position 4\n"
"6\n"
">>> frukter.omvänd()\n"
">>> frukter\n"
"['banan', 'äpple', 'kiwi', 'banan', 'päron', 'äpple', 'apelsin']\n"
">>> frukt.lägg till('druva')\n"
">>> frukter\n"
"['banan', 'äpple', 'kiwi', 'banan', 'päron', 'äpple', 'apelsin', 'druva']\n"
">>> frukter.sortera()\n"
">>> frukter\n"
"['äpple', 'äpple', 'banan', 'banan', 'druva', 'kiwi', 'apelsin', 'päron']\n"
">>> frukter.pop()\n"
"\"päron"

msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [#]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Du kanske har märkt att metoder som ``insert``, ``remove`` eller ``sort`` "
"som bara ändrar listan inte har något returvärde utskrivet - de returnerar "
"standardvärdet ``None``. [Detta är en designprincip för alla föränderliga "
"datastrukturer i Python."

msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and ``None`` can't be compared to "
"other types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""
"En annan sak som du kanske märker är att inte alla data kan sorteras eller "
"jämföras.  Till exempel sorterar inte ``[None, 'hello', 10]`` eftersom "
"heltal inte kan jämföras med strängar och ``None`` inte kan jämföras med "
"andra typer.  Det finns också vissa typer som inte har någon definierad "
"ordningsrelation.  Till exempel är ``3+4j < 5+7j`` inte en giltig jämförelse."

msgid "Using Lists as Stacks"
msgstr "Använda listor som staplar"

msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`!append`.  To retrieve an "
"item from the top of the stack, use :meth:`!pop` without an explicit index.  "
"For example::"
msgstr ""
"Listmetoderna gör det mycket enkelt att använda en lista som en stapel, där "
"det sista elementet som läggs till är det första elementet som hämtas "
"(\"sist in, först ut\").  För att lägga till ett element överst i stapeln, "
"använd :meth:`!append`.  För att hämta ett objekt från toppen av stacken, "
"använd :meth:`!pop` utan ett explicit index.  Till exempel::"

msgid ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"
msgstr ""
">>> stack = [3, 4, 5]\n"
">>> stack.lägg till(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stapel.pop()\n"
"6\n"
">>> stapel.pop()\n"
"5\n"
">>> stapel\n"
"[3, 4]"

msgid "Using Lists as Queues"
msgstr "Använda listor som köer"

msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"Det är också möjligt att använda en lista som en kö, där det första "
"elementet som läggs till är det första elementet som hämtas (\"först in, "
"först ut\"); listor är dock inte effektiva för detta ändamål.  Det går "
"snabbt att lägga till och ta bort element från slutet av en lista, men det "
"går långsamt att lägga till eller ta bort element från början av en lista "
"(eftersom alla andra element måste flyttas med ett)."

msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"För att implementera en kö, använd :class:`collections.deque` som är "
"utformad för att ha snabba appends och pops från båda ändar.  Till exempel::"

msgid ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"
msgstr ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\") # Terry anländer\n"
">>> queue.append(\"Graham\") # Graham anländer\n"
">>> queue.popleft() # Den första som anländer lämnar nu\n"
"\"Eric\n"
">>> queue.popleft() # Den andre som anländer lämnar nu\n"
"'John'\n"
">>> queue # Återstående kö i ankomstordning\n"
"deque(['Michael', 'Terry', 'Graham'])"

msgid "List Comprehensions"
msgstr "Listförståelse"

msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"List Comprehensions ger ett kortfattat sätt att skapa listor. Vanliga "
"tillämpningar är att skapa nya listor där varje element är resultatet av "
"vissa operationer som tillämpas på varje medlem i en annan sekvens eller "
"iterabel, eller att skapa en undersekvens av de element som uppfyller ett "
"visst villkor."

msgid "For example, assume we want to create a list of squares, like::"
msgstr ""
"Anta till exempel att vi vill skapa en lista med kvadrater, till exempel::"

msgid ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> rutor = []\n"
">>> för x i intervall(10):\n"
"... squares.append(x**2)\n"
"...\n"
">>> rutor\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Observera att detta skapar (eller skriver över) en variabel med namnet ``x`` "
"som fortfarande existerar efter att slingan har avslutats.  Vi kan beräkna "
"listan med kvadrater utan några bieffekter med::"

msgid "squares = list(map(lambda x: x**2, range(10)))"
msgstr "squares = list(map(lambda x: x**2, range(10)))"

msgid "or, equivalently::"
msgstr "eller, på motsvarande sätt::"

msgid "squares = [x**2 for x in range(10)]"
msgstr "squares = [x**2 for x in range(10)]"

msgid "which is more concise and readable."
msgstr "som är mer kortfattad och läsbar."

msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"En list comprehension består av parenteser som innehåller ett uttryck följt "
"av en :keyword:`!for`-klausul, sedan noll eller fler :keyword:`!for`- eller :"
"keyword:`!if`-klausuler.  Resultatet blir en ny lista som är resultatet av "
"utvärderingen av uttrycket i kontexten av :keyword:`!for`- och :keyword:`!"
"if`-klausulerna som följer efter det. Till exempel kombinerar denna listcomp "
"elementen i två listor om de inte är lika::"

msgid ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

msgid "and it's equivalent to::"
msgstr "och det är likvärdigt med::"

msgid ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> kammar = []\n"
">>> för x i [1,2,3]:\n"
"... för y i [3,1,4]:\n"
"... if x != y:\n"
"... combs.append((x, y))\n"
"...\n"
">>> kammar\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"Observera att ordningen på :keyword:`for`- och :keyword:`if`-satserna är "
"densamma i båda dessa utdrag."

msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Om uttrycket är en tupel (t.ex. ``(x, y)`` i föregående exempel) måste det "
"vara inom parentes. ::"

msgid ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # create a new list with the values doubled\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # flatten a list using a listcomp with two 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""
"&gt;&gt;&gt; vec = [-4, -2, 0, 2, 4]\n"
"&gt;&gt;&gt; # skapa en ny lista med de fördubblade värdena\n"
"&gt;&gt;&gt; [x*2 för x i vec]\n"
"[-8, -4, 0, 4, 8]\n"
"&gt;&gt;&gt; # filtrera listan för att utesluta negativa tal\n"
"&gt;&gt;&gt; [x for x in vec if x &gt;= 0]\n"
"[0, 2, 4]\n"
"&gt;&gt;&gt; # tillämpa en funktion på alla element\n"
"&gt;&gt;&gt; [abs(x) för x i vec]\n"
"[4, 2, 0, 2, 4]\n"
"&gt;&gt;&gt; # anropa en metod på varje element\n"
"&gt;&gt;&gt; freshfruit = ['banan', 'loganbär', 'passionsfrukt'] [weapon."
"strip()\n"
"&gt;&gt;&gt; [vapen.strip() för vapen i färskfrukt]\n"
"['banana', 'loganberry', 'passionsfrukt']\n"
"&gt;&gt;&gt; # skapa en lista med 2-tuples som (nummer, kvadrat)\n"
"&gt;&gt;&gt; [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
"&gt;&gt;&gt; # tupeln måste vara parentetisk, annars uppstår ett fel\n"
"&gt;&gt;&gt; [x, x**2 för x i intervall(6)]\n"
"  Fil \"<stdin>\", rad 1\n"
"    [x, x**2 för x i intervall(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: glömde du parenteser runt förståelsemålet?\n"
"&gt;&gt;&gt; # platta till en lista med hjälp av en listcomp med två 'for'\n"
"&gt;&gt;&gt; vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
"&gt;&gt;&gt; [num för elem i vec för num i elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"

msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"Listförståelser kan innehålla komplexa uttryck och nästlade funktioner::"

msgid ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"
msgstr ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"

msgid "Nested List Comprehensions"
msgstr "Förståelse av nästlade listor"

msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"Det första uttrycket i en listkomprehension kan vara vilket godtyckligt "
"uttryck som helst, inklusive en annan listkomprehension."

msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Betrakta följande exempel på en 3x4-matris som implementerats som en lista "
"med 3 listor med längden 4::"

msgid ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"
msgstr ""
">>> matris = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"

msgid "The following list comprehension will transpose rows and columns::"
msgstr "Följande listförståelse kommer att transponera rader och kolumner::"

msgid ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> [[rad[i] för rad i matris] för i i intervall(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

msgid ""
"As we saw in the previous section, the inner list comprehension is evaluated "
"in the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"Som vi såg i föregående avsnitt utvärderas den inre listförståelsen i "
"kontexten för det :keyword:`for` som följer efter den, så det här exemplet "
"är likvärdigt med::"

msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> för i i intervall(4):\n"
"... transposed.append([rad[i] för rad i matris])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

msgid "which, in turn, is the same as::"
msgstr "vilket i sin tur är detsamma som::"

msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> för i i intervall(4):\n"
"...     # följande 3 rader implementerar den nästlade listcomp\n"
"... transponerad_rad = []\n"
"... för rad i matris:\n"
"... transposed_row.append(rad[i])\n"
"... transposed.append(transposed_row)\n"
"...\n"
">>> transponering\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"I den verkliga världen bör du föredra inbyggda funktioner framför komplexa "
"flödesbeskrivningar. Funktionen :func:`zip` skulle göra ett bra jobb för "
"detta användningsfall::"

msgid ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
msgstr ""
">>> list(zip(*matris))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"

msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"Se :ref:`tut-unpacking-arguments` för detaljer om asterisken i den här raden."

msgid "The :keyword:`!del` statement"
msgstr ":nyckelord:`!del`-satsen"

msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`!pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"Det finns ett sätt att ta bort ett objekt från en lista genom att ange dess "
"index istället för dess värde: :keyword:`del` statement.  Detta skiljer sig "
"från metoden :meth:`!pop` som returnerar ett värde.  Satsen :keyword:`!del` "
"kan också användas för att ta bort delar från en lista eller rensa hela "
"listan (vilket vi gjorde tidigare genom att tilldela en tom lista till "
"delen).  Till exempel::"

msgid ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"
msgstr ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"

msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` kan också användas för att radera hela variabler::"

msgid ">>> del a"
msgstr ">>> del a"

msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Att referera till namnet ``a`` i fortsättningen är ett fel (åtminstone tills "
"ett annat värde tilldelas det).  Vi kommer att hitta andra "
"användningsområden för :keyword:`del` senare."

msgid "Tuples and Sequences"
msgstr "Tupler och sekvenser"

msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"Vi såg att listor och strängar har många gemensamma egenskaper, t.ex. "
"indexerings- och skivningsoperationer.  De är två exempel på *sekvens*-"
"datatyper (se :ref:`typesseq`).  Eftersom Python är ett språk under "
"utveckling kan andra sekvensdatatyper komma att läggas till.  Det finns "
"också en annan standardsekvensdatatyp: *tuple*."

msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"En tuple består av ett antal värden som separeras med kommatecken, till "
"exempel::"

msgid ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # Tuples may be nested:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # Tuples are immutable:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # but they can contain mutable objects:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"
msgstr ""
"&gt;&gt;&gt; t = 12345, 54321, \"hej!\n"
"&gt;&gt;&gt; t[0]\n"
"12345\n"
"&gt;&gt;&gt; t\n"
"(12345, 54321, 'hej!')\n"
"&gt;&gt;&gt; # Tuplar kan vara nästlade:\n"
"&gt;&gt;&gt; u = t, (1, 2, 3, 4, 5)\n"
"&gt;&gt;&gt; u\n"
"((12345, 54321, 'hallå!'), (1, 2, 3, 4, 5))\n"
"&gt;&gt;&gt; # Tuplar är oföränderliga:\n"
"&gt;&gt;&gt; t[0] = 88888\n"
"Traceback (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"TypeError: 'tuple'-objektet stöder inte tilldelning av objekt\n"
"&gt;&gt;&gt; # men de kan innehålla mutabla objekt:\n"
"&gt;&gt;&gt; v = ([1, 2, 3], [3, 2, 1])\n"
"&gt;&gt;&gt; v\n"
"([1, 2, 3], [3, 2, 1])"

msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Som du ser är tupler alltid inneslutna i parenteser vid utmatning, så att "
"nästlade tupler tolkas korrekt; de kan matas in med eller utan omgivande "
"parenteser, även om parenteser ofta är nödvändiga ändå (om tupeln är en del "
"av ett större uttryck).  Det är inte möjligt att tilldela de enskilda "
"objekten i en tupel, men det är möjligt att skapa tuplar som innehåller "
"föränderliga objekt, t.ex. listor."

msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"Även om tupler kan tyckas likna listor används de ofta i olika situationer "
"och för olika syften. Tuples är :term:`immutable`, och innehåller vanligtvis "
"en heterogen sekvens av element som nås via uppackning (se senare i detta "
"avsnitt) eller indexering (eller till och med via attribut i fallet :func:"
"`namedtuples <collections.namedtuple>`). Listor är :term:`mutabla`, och "
"deras element är vanligtvis homogena och nås genom att iterera över listan."

msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Ett speciellt problem är konstruktionen av tupler som innehåller 0 eller 1 "
"objekt: syntaxen har några extra finesser för att hantera dessa.  Tomma "
"tupler konstrueras med ett tomt par parenteser; en tupel med ett objekt "
"konstrueras genom att följa ett värde med ett kommatecken (det räcker inte "
"att omsluta ett enda värde med parenteser). Fult, men effektivt.  Till "
"exempel::"

msgid ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"
msgstr ""
"&gt;&gt;&gt; tom = ()\n"
"&gt;&gt;&gt; singleton = 'hello', # <-- note trailing comma\n"
">&gt;&gt; len(empty)\n"
"0\n"
"&gt;&gt;&gt; len(singleton)\n"
"1\n"
"&gt;&gt;&gt; singleton\n"
"('hello',)"

msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"Satsen ``t = 12345, 54321, 'hello!'`` är ett exempel på *tuple packing*: "
"värdena ``12345``, ``54321`` och ``'hello!'`` packas ihop till en tuple. Den "
"omvända operationen är också möjlig::"

msgid ">>> x, y, z = t"
msgstr ">>> x, y, z = t"

msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"Detta kallas, passande nog, *sequence unpacking* och fungerar för alla "
"sekvenser på höger sida.  Sekvensuppackning kräver att det finns lika många "
"variabler på vänster sida om likhetstecknet som det finns element i "
"sekvensen.  Observera att multipel tilldelning egentligen bara är en "
"kombination av tupelpackning och sekvensuppackning."

msgid "Sets"
msgstr "Uppsättningar"

msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python innehåller också en datatyp för *sets*.  En set är en oordnad samling "
"utan duplicerade element.  Grundläggande användningsområden inkluderar "
"medlemskapstestning och eliminering av dubbla poster.  Set-objekt stöder "
"också matematiska operationer som union, intersektion, differens och "
"symmetrisk differens."

msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Curly braces eller funktionen :func:`set` kan användas för att skapa "
"uppsättningar.  Observera: för att skapa en tom uppsättning måste du använda "
"``set()``, inte ``{}``; den senare skapar en tom ordbok, en datastruktur som "
"vi diskuterar i nästa avsnitt."

msgid "Here is a brief demonstration::"
msgstr "Här är en kort demonstration::"

msgid ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # show that duplicates have been "
"removed\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # fast membership testing\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # Demonstrate set operations on unique letters from two words\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # unique letters in a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # letters in a but not in b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # letters in a or b or both\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # letters in both a and b\n"
"{'a', 'c'}\n"
">>> a ^ b                              # letters in a or b but not both\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"
msgstr ""
">>> korg = {'äpple', 'apelsin', 'äpple', 'päron', 'apelsin', 'banan'}\n"
">>> print(korg) # visa att dubbletter har tagits bort\n"
"{'apelsin', 'banan', 'päron', 'äpple'}\n"
">>> 'orange' i korgen # snabb testning av medlemskap\n"
"True\n"
">>> 'crabgrass' i korgen\n"
"False\n"
"\n"
">>> # Demonstrera set-operationer på unika bokstäver från två ord\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = uppsättning('alacazam')\n"
">>> a # unika bokstäver i a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b # bokstäver i a men inte i b\n"
"{'r', 'd', 'b'}\n"
">>> a | b # bokstäver i a eller b eller båda\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b # bokstäver i både a och b\n"
"{'a', 'c'}\n"
">>> a ^ b # bokstäver i a eller b men inte båda\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"

msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"På samma sätt som :ref:`listförståelse <tut-listcomps>`, stöds även "
"setförståelse::"

msgid ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"
msgstr ""
">>> a = {x för x i 'abracadabra' om x inte finns i 'abc'}\n"
">>> a\n"
"{'r', 'd'}"

msgid "Dictionaries"
msgstr "Ordböcker"

msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:`!"
"append` and :meth:`!extend`."
msgstr ""
"En annan användbar datatyp som är inbyggd i Python är *ordboken* (se :ref:"
"`typesmapping`). Ordböcker finns ibland i andra språk som \"associativa "
"minnen\" eller \"associativa matriser\".  Till skillnad från sekvenser, som "
"indexeras av ett talområde, indexeras ordböcker av *nycklar*, som kan vara "
"vilken oföränderlig typ som helst; strängar och tal kan alltid vara "
"nycklar.  Tupler kan användas som nycklar om de bara innehåller strängar, "
"tal eller tupler; om en tupel innehåller något föränderligt objekt, antingen "
"direkt eller indirekt, kan den inte användas som nyckel. Du kan inte använda "
"listor som nycklar, eftersom listor kan ändras på plats med hjälp av "
"indextilldelningar, slice-tilldelningar eller metoder som :meth:`!append` "
"och :meth:`!extend`."

msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"Det är bäst att tänka på en ordbok som en uppsättning *nyckel: värde*-par, "
"med kravet att nycklarna är unika (inom en ordbok). Ett par hakparenteser "
"skapar en tom ordbok: ``{}``. Om du placerar en kommaseparerad lista med "
"nyckel:värde-par inom hakparenteserna läggs de första nyckel:värde-paren "
"till i ordboken; det är också så ordböcker skrivs på utdatasidan."

msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"De viktigaste operationerna i en ordbok är att lagra ett värde med en nyckel "
"och att extrahera värdet med hjälp av nyckeln.  Det är också möjligt att ta "
"bort ett nyckel:värde-par med ``del``. Om du lagrar med en nyckel som redan "
"används, glöms det gamla värdet som är associerat med den nyckeln bort.  Det "
"är ett fel att extrahera ett värde med en icke-existerande nyckel."

msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"Om du utför ``list(d)`` på en ordbok returneras en lista över alla nycklar "
"som används i ordboken, i inmatningsordning (om du vill ha den sorterad "
"använder du ``sorted(d)`` istället). Om du vill kontrollera om en enskild "
"nyckel finns i ordlistan använder du nyckelordet :keyword:`in`."

msgid "Here is a small example using a dictionary::"
msgstr "Här är ett litet exempel med hjälp av en ordbok::"

msgid ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"
msgstr ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{\"jack\": 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorterad(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' i tel\n"
"Sant\n"
">>> 'jack' inte i tel\n"
"Falsk"

msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"Konstruktören :func:`dict` bygger upp lexikon direkt från sekvenser av "
"nyckel-värde-par::"

msgid ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Dessutom kan dict comprehensions användas för att skapa ordböcker från "
"godtyckliga nyckel- och värdeuttryck::"

msgid ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"
msgstr ""
">>> {x: x**2 för x i (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"

msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"När nycklarna är enkla strängar är det ibland enklare att ange par med hjälp "
"av nyckelordsargument::"

msgid ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

msgid "Looping Techniques"
msgstr "Looping-tekniker"

msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"Vid loopning genom lexikon kan nyckeln och motsvarande värde hämtas "
"samtidigt med hjälp av metoden :meth:`~dict.items`. ::"

msgid ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"
msgstr ""
">>> riddare = {'gallahad': 'den rene', 'robin': 'den modige'}\n"
">>> för k, v i knights.items():\n"
"... print(k, v)\n"
"...\n"
"gallahad den renlärige\n"
"robin den modige"

msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"Vid loopning genom en sekvens kan positionsindex och motsvarande värde "
"hämtas samtidigt med hjälp av funktionen :func:`enumerate`. ::"

msgid ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"
msgstr ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"... print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 tå"

msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"För att loopa över två eller flera sekvenser samtidigt kan posterna kopplas "
"ihop med funktionen :func:`zip`. ::"

msgid ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"What is your name?  It is lancelot.\n"
"What is your quest?  It is the holy grail.\n"
"What is your favorite color?  It is blue."
msgstr ""
">>> frågor = ['namn', 'uppdrag', 'favoritfärg'] >>> svar = ['lancelot', 'den "
"heliga graal', 'blå']\n"
">>> svar = ['lancelot', 'den heliga graalen', 'blå']\n"
">>> för q, a i zip(frågor, svar):\n"
"... print('Vad är din {0}?  Det är {1}.'.format(q, a))\n"
"...\n"
"Vad är ditt namn?  Det är lancelot.\n"
"Vad är ditt uppdrag?  Det är den heliga graalen.\n"
"Vilken är din favoritfärg?  Den är blå."

msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"För att loopa över en sekvens i omvänd riktning anger du först sekvensen i "
"framåtriktad riktning och anropar sedan funktionen :func:`reversed`. ::"

msgid ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"
msgstr ""
">>> for i in reversed(range(1, 10, 2)):\n"
"... print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"

msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"För att loopa över en sekvens i sorterad ordning, använd funktionen :func:"
"`sorted` som returnerar en ny sorterad lista medan källan lämnas "
"oförändrad. ::"

msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"
msgstr ""
">>> korg = ['äpple', 'apelsin', 'äpple', 'päron', 'apelsin', 'banan'] >>> i\n"
">>> för i i sorterad(korg):\n"
"... print(i)\n"
"...\n"
"äpple\n"
"äpple\n"
"banan\n"
"apelsin\n"
"apelsin\n"
"päron"

msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"Genom att använda :func:`set` på en sekvens elimineras duplicerade element. "
"Användningen av :func:`sorted` i kombination med :func:`set` över en sekvens "
"är ett idiomatiskt sätt att loopa över unika element i sekvensen i sorterad "
"ordning. ::"

msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"
msgstr ""
">>> korg = ['äpple', 'apelsin', 'äpple', 'päron', 'apelsin', 'banan'] >>> f\n"
">>> for f in sorted(set(korg)):\n"
"... print(f)\n"
"...\n"
"äpple\n"
"banan\n"
"apelsin\n"
"päron"

msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Det är ibland frestande att ändra i en lista medan man går igenom den, men "
"det är ofta enklare och säkrare att skapa en ny lista istället:"

msgid ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"
msgstr ""
">>> import matematik\n"
">>> rådata = [56,2, float('NaN'), 51,7, 55,3, 52,5, float('NaN'), 47,8]\n"
">>> filtrerade_data = []\n"
">>> för värde i rå_data:\n"
"... if not math.isnan(värde):\n"
"... filtrerad_data.append(värde)\n"
"...\n"
">>> filtrerad_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"

msgid "More on Conditions"
msgstr "Mer om villkor"

msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"De villkor som används i ``while`` och ``if``-satser kan innehålla alla "
"operatorer, inte bara jämförelser."

msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"Jämförelseoperatorerna ``in`` och ``not in`` är medlemskapstester som avgör "
"om ett värde finns i (eller inte finns i) en container.  Operatorerna ``is`` "
"och ``is not`` jämför om två objekt verkligen är samma objekt.  Alla "
"jämförelseoperatorer har samma prioritet, som är lägre än för alla numeriska "
"operatorer."

msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Jämförelser kan kedjas.  Till exempel testar ``a < b == c`` om ``a`` är "
"mindre än ``b`` och dessutom om ``b`` är lika med ``c``."

msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"Jämförelser kan kombineras med hjälp av de booleska operatorerna ``och`` och "
"``eller``, och resultatet av en jämförelse (eller av något annat booleskt "
"uttryck) kan negeras med ``not``.  Dessa har lägre prioritet än "
"jämförelseoperatorer; mellan dem har ``not`` högst prioritet och ``or`` "
"lägst, så att ``A och inte B eller C`` är ekvivalent med ``(A och (inte B)) "
"eller C``. Som alltid kan parenteser användas för att uttrycka den önskade "
"sammansättningen."

msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"De booleska operatorerna ``och`` och ``eller`` är så kallade "
"*kortslutningsoperatorer*: deras argument utvärderas från vänster till "
"höger, och utvärderingen avslutas så snart resultatet har bestämts.  Om t."
"ex. ``A`` och ``C`` är sanna men ``B`` är falsk, utvärderar ``A och B och "
"C`` inte uttrycket ``C``.  När en kortslutningsoperator används som ett "
"allmänt värde och inte som en booleansk operator, är returvärdet det senast "
"utvärderade argumentet."

msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"Det är möjligt att tilldela resultatet av en jämförelse eller ett annat "
"booleskt uttryck till en variabel.  Till exempel ::"

msgid ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"
msgstr ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = sträng1 eller sträng2 eller sträng3\n"
">>> non_null\n"
"\"Trondheim"

msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"Observera att i Python, till skillnad från C, måste tilldelning inuti "
"uttryck göras explicit med :ref:`walrus-operatorn <why-can-t-i-use-an-"
"assignment-in-an-expression>``:=``. Detta undviker en vanlig typ av problem "
"som uppstår i C-program: att skriva ``=`` i ett uttryck när ``==`` var "
"avsett."

msgid "Comparing Sequences and Other Types"
msgstr "Jämförelse mellan sekvenser och andra typer"

msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"Sekvensobjekt kan typiskt sett jämföras med andra objekt av samma "
"sekvenstyp. Jämförelsen använder *lexikografisk* ordning: först jämförs de "
"två första objekten, och om de skiljer sig åt avgör detta resultatet av "
"jämförelsen; om de är lika jämförs nästa två objekt, och så vidare tills "
"någon av sekvenserna är uttömd. Om två objekt som ska jämföras själva är "
"sekvenser av samma typ, utförs den lexikografiska jämförelsen rekursivt.  Om "
"alla element i två sekvenser jämförs lika, anses sekvenserna vara lika. Om "
"den ena sekvensen är en initial subsekvens av den andra, är den kortare "
"sekvensen den mindre (lesser).  Lexikografisk ordning för strängar använder "
"Unicodes kodpunktsnummer för att ordna enskilda tecken. Några exempel på "
"jämförelser mellan sekvenser av samma typ::"

msgid ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
msgstr ""
"(1, 2, 3) < (1, 2, 4)\n"
"[1, 2, 3] < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4) < (1, 2, 4)\n"
"(1, 2) < (1, 2, -1)\n"
"(1, 2, 3) == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"

msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Observera att det är lagligt att jämföra objekt av olika typer med ``<`` "
"eller ``>``, förutsatt att objekten har lämpliga jämförelsemetoder.  Till "
"exempel jämförs blandade numeriska typer enligt deras numeriska värde, så 0 "
"är lika med 0,0 osv.  Annars kommer tolken, i stället för att tillhandahålla "
"en godtycklig ordning, att ge upphov till ett :exc:`TypeError`-undantag."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Andra språk kan returnera det muterade objektet, vilket möjliggör "
"metodkedjor, till exempel ``d->insert(\"a\")->remove(\"b\")->sort();``."
