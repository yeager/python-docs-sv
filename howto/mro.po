# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "The Python 2.3 Method Resolution Order"
msgstr "Python 2.3-metodens upplösningsordning"

msgid ""
"This is a historical document, provided as an appendix to the official "
"documentation. The Method Resolution Order discussed here was *introduced* "
"in Python 2.3, but it is still used in later versions -- including Python 3."
msgstr ""
"Detta är ett historiskt dokument, som tillhandahålls som en bilaga till den "
"officiella dokumentationen. Method Resolution Order som diskuteras här "
"*introducerades* i Python 2.3, men den används fortfarande i senare "
"versioner - inklusive Python 3."

msgid "By `Michele Simionato <https://www.phyast.pitt.edu/~micheles/>`__."
msgstr "Av `Michele Simionato <https://www.phyast.pitt.edu/~micheles/>`__."

msgid "Abstract"
msgstr "Abstrakt"

msgid ""
"*This document is intended for Python programmers who want to understand the "
"C3 Method Resolution Order used in Python 2.3. Although it is not intended "
"for newbies, it is quite pedagogical with many worked out examples.  I am "
"not aware of other publicly available documents with the same scope, "
"therefore it should be useful.*"
msgstr ""
"*Detta dokument är avsett för Python-programmerare som vill förstå C3-"
"metoden Resolution Order som används i Python 2.3. Även om det inte är "
"avsett för nybörjare är det ganska pedagogiskt med många utarbetade "
"exempel.  Jag känner inte till andra offentligt tillgängliga dokument med "
"samma omfattning, därför bör det vara användbart.*"

msgid "Disclaimer:"
msgstr "Ansvarsfriskrivning:"

msgid ""
"*I donate this document to the Python Software Foundation, under the Python "
"2.3 license.  As usual in these circumstances, I warn the reader that what "
"follows* should *be correct, but I don't give any warranty.  Use it at your "
"own risk and peril!*"
msgstr ""
"*Jag donerar detta dokument till Python Software Foundation, under Python "
"2.3-licensen.  Som vanligt under dessa omständigheter varnar jag läsaren för "
"att det som följer * bör * vara korrekt, men jag ger ingen garanti.  Använd "
"det på egen risk och fara!*"

msgid "Acknowledgments:"
msgstr "Erkännande:"

msgid ""
"*All the people of the Python mailing list who sent me their support. Paul "
"Foley who pointed out various imprecisions and made me to add the part on "
"local precedence ordering. David Goodger for help with the formatting in "
"reStructuredText. David Mertz for help with the editing. Finally, Guido van "
"Rossum who enthusiastically added this document to the official Python 2.3 "
"home-page.*"
msgstr ""
"*Alla personer på Pythons e-postlista som skickade mig sitt stöd. Paul Foley "
"som påpekade olika felaktigheter och fick mig att lägga till delen om lokal "
"prioritetsordning. David Goodger för hjälp med formateringen i "
"reStructuredText. David Mertz för hjälp med redigeringen. Slutligen, Guido "
"van Rossum som entusiastiskt lade till detta dokument på den officiella "
"Python 2.3-hemsidan.*"

msgid "The beginning"
msgstr "Början"

msgid "*Felix qui potuit rerum cognoscere causas* -- Virgilius"
msgstr "*Felix qui potuit rerum cognoscere causas* -- Virgilius"

msgid ""
"Everything started with a post by Samuele Pedroni to the Python development "
"mailing list [#]_.  In his post, Samuele showed that the Python 2.2 method "
"resolution order is not monotonic and he proposed to replace it with the C3 "
"method resolution order.  Guido agreed with his arguments and therefore now "
"Python 2.3 uses C3.  The C3 method itself has nothing to do with Python, "
"since it was invented by people working on Dylan and it is described in a "
"paper intended for lispers [#]_.  The present paper gives a (hopefully) "
"readable discussion of the C3 algorithm for Pythonistas who want to "
"understand the reasons for the change."
msgstr ""
"Allt började med ett inlägg av Samuele Pedroni till e-postlistan för Python-"
"utveckling [#]_.  I sitt inlägg visade Samuele att Python 2.2-metodens "
"upplösningsordning inte är monoton och han föreslog att den skulle ersättas "
"med C3-metodens upplösningsordning.  Guido höll med om hans argument och "
"därför använder Python 2.3 nu C3.  C3-metoden i sig har inget med Python att "
"göra, eftersom den uppfanns av personer som arbetade med Dylan och beskrivs "
"i ett dokument som är avsett för lispers [#]_.  Den här artikeln ger en "
"(förhoppningsvis) läsbar diskussion av C3-algoritmen för Pythonistas som "
"vill förstå orsakerna till förändringen."

msgid ""
"First of all, let me point out that what I am going to say only applies to "
"the *new style classes* introduced in Python 2.2:  *classic classes* "
"maintain their old method resolution order, depth first and then left to "
"right.  Therefore, there is no breaking of old code for classic classes; and "
"even if in principle there could be breaking of code for Python 2.2 new "
"style classes, in practice the cases in which the C3 resolution order "
"differs from the Python 2.2 method resolution order are so rare that no real "
"breaking of code is expected.  Therefore:"
msgstr ""
"Först och främst vill jag påpeka att det jag ska säga bara gäller de *nya "
"stilklasserna* som introducerades i Python 2.2:  *klassiska klasser* "
"behåller sin gamla metodupplösningsordning, djupet först och sedan vänster "
"till höger.  Därför finns det inget brott mot gammal kod för klassiska "
"klasser; och även om det i princip skulle kunna finnas brott mot kod för "
"Python 2.2 nya stilklasser, är de fall där C3-resolutionsordningen skiljer "
"sig från Python 2.2-metodresolutionsordningen i praktiken så sällsynta att "
"inget verkligt brott mot kod förväntas.  Därför bör följande gälla:"

msgid "*Don't be scared!*"
msgstr "*Var inte rädd!"

msgid ""
"Moreover, unless you make strong use of multiple inheritance and you have "
"non-trivial hierarchies, you don't need to understand the C3 algorithm, and "
"you can easily skip this paper.  On the other hand, if you really want to "
"know how multiple inheritance works, then this paper is for you.  The good "
"news is that things are not as complicated as you might expect."
msgstr ""
"Om du inte använder dig mycket av multipel nedärvning och har icke-triviala "
"hierarkier behöver du inte heller förstå C3-algoritmen, och du kan enkelt "
"hoppa över den här artikeln.  Å andra sidan, om du verkligen vill veta hur "
"multipel arv fungerar, då är det här dokumentet för dig.  Den goda nyheten "
"är att saker och ting inte är så komplicerade som du kanske förväntar dig."

msgid "Let me begin with some basic definitions."
msgstr "Låt mig börja med några grundläggande definitioner."

msgid ""
"Given a class C in a complicated multiple inheritance hierarchy, it is a non-"
"trivial task to specify the order in which methods are overridden, i.e. to "
"specify the order of the ancestors of C."
msgstr ""
"Givet en klass C i en komplicerad hierarki med flera arvsanlag är det en "
"icke-trivial uppgift att ange i vilken ordning metoder åsidosätts, dvs. att "
"ange ordningen på C:s förfäder."

msgid ""
"The list of the ancestors of a class C, including the class itself, ordered "
"from the nearest ancestor to the furthest, is called the class precedence "
"list or the *linearization* of C."
msgstr ""
"Listan över förfäderna till en klass C, inklusive klassen själv, ordnad från "
"den närmaste förfadern till den mest avlägsna, kallas klassens "
"företrädeslista eller *lineariseringen* av C."

msgid ""
"The *Method Resolution Order* (MRO) is the set of rules that construct the "
"linearization.  In the Python literature, the idiom \"the MRO of C\" is also "
"used as a synonymous for the linearization of the class C."
msgstr ""
"*Method Resolution Order* (MRO) är den uppsättning regler som konstruerar "
"linjäriseringen.  I Python-litteraturen används idiomet \"MRO för C\" också "
"som en synonym för linjäriseringen av klassen C."

msgid ""
"For instance, in the case of single inheritance hierarchy, if C is a "
"subclass of C1, and C1 is a subclass of C2, then the linearization of C is "
"simply the list [C, C1 , C2].  However, with multiple inheritance "
"hierarchies, the construction of the linearization is more cumbersome, since "
"it is more difficult to construct a linearization that respects *local "
"precedence ordering* and *monotonicity*."
msgstr ""
"Om C till exempel är en underklass till C1 och C1 är en underklass till C2 i "
"en enkel arvshierarki, är linjäriseringen av C helt enkelt listan [C, C1 , "
"C2].  Men med flera arvshierarkier är konstruktionen av linjäriseringen mer "
"besvärlig, eftersom det är svårare att konstruera en linjärisering som "
"respekterar *lokal prioritetsordning* och *monotonicitet*."

msgid ""
"I will discuss the local precedence ordering later, but I can give the "
"definition of monotonicity here.  A MRO is monotonic when the following is "
"true:  *if C1 precedes C2 in the linearization of C, then C1 precedes C2 in "
"the linearization of any subclass of C*. Otherwise, the innocuous operation "
"of deriving a new class could change the resolution order of methods, "
"potentially introducing very subtle bugs.  Examples where this happens will "
"be shown later."
msgstr ""
"Jag kommer att diskutera den lokala prioritetsordningen senare, men jag kan "
"ge definitionen av monotonicitet här.  En MRO är monoton när följande är "
"sant:  *om C1 föregår C2 i linjäriseringen av C, så föregår C1 C2 i "
"linjäriseringen av någon underklass av C*. I annat fall kan den oskyldiga "
"åtgärden att härleda en ny klass ändra metodernas upplösningsordning, vilket "
"kan leda till mycket subtila buggar.  Exempel där detta händer kommer att "
"visas senare."

msgid ""
"Not all classes admit a linearization.  There are cases, in complicated "
"hierarchies, where it is not possible to derive a class such that its "
"linearization respects all the desired properties."
msgstr ""
"Inte alla klasser tillåter en linjärisering.  Det finns fall, i komplicerade "
"hierarkier, där det inte är möjligt att härleda en klass så att dess "
"linjärisering respekterar alla önskade egenskaper."

msgid "Here I give an example of this situation. Consider the hierarchy"
msgstr "Här ger jag ett exempel på denna situation. Tänk på hierarkin"

msgid ""
"which can be represented with the following inheritance graph, where I have "
"denoted with O the ``object`` class, which is the beginning of any hierarchy "
"for new style classes:"
msgstr ""
"som kan representeras med följande arvsgraf, där jag med O har betecknat "
"klassen ``objekt``, som är början på varje hierarki för nya stilklasser:"

msgid ""
" -----------\n"
"|           |\n"
"|    O      |\n"
"|  /   \\    |\n"
" - X    Y  /\n"
"   |  / | /\n"
"   | /  |/\n"
"   A    B\n"
"   \\   /\n"
"     ?"
msgstr ""
" -----------\n"
"| |\n"
"| O |\n"
"| / \\ |\n"
" - X Y /\n"
"   | / | /\n"
"   | / |/\n"
"   A B\n"
"   \\ /\n"
"     ?"

msgid ""
"In this case, it is not possible to derive a new class C from A and B, since "
"X precedes Y in A, but Y precedes X in B, therefore the method resolution "
"order would be ambiguous in C."
msgstr ""
"I det här fallet är det inte möjligt att härleda en ny klass C från A och B, "
"eftersom X föregår Y i A, men Y föregår X i B, och därför skulle metodens "
"upplösningsordning vara tvetydig i C."

msgid ""
"Python 2.3 raises an exception in this situation (TypeError:  MRO conflict "
"among bases Y, X) forbidding the naive programmer from creating ambiguous "
"hierarchies.  Python 2.2 instead does not raise an exception, but chooses an "
"*ad hoc* ordering (CABXYO in this case)."
msgstr ""
"Python 2.3 gör ett undantag i denna situation (TypeError: MRO conflict among "
"bases Y, X) och förbjuder den naive programmeraren att skapa tvetydiga "
"hierarkier.  Python 2.2 ger istället inte upphov till ett undantag, utan "
"väljer en *ad hoc*-ordning (CABXYO i det här fallet)."

msgid "The C3 Method Resolution Order"
msgstr "C3-metoden Upplösningsorder"

msgid ""
"Let me introduce a few simple notations which will be useful for the "
"following discussion.  I will use the shortcut notation::"
msgstr ""
"Låt mig introducera några enkla notationer som kommer att vara till nytta i "
"den följande diskussionen.  Jag kommer att använda förkortningsnotationen::"

msgid "C1 C2 ... CN"
msgstr "C1 C2 ... CN"

msgid "to indicate the list of classes [C1, C2, ... , CN]."
msgstr "för att ange listan över klasser [C1, C2, ... , CN]."

msgid "The *head* of the list is its first element::"
msgstr "Listans *huvud* är dess första element::"

msgid "head = C1"
msgstr "huvud = C1"

msgid "whereas the *tail* is the rest of the list::"
msgstr "medan *svansen* är resten av listan::"

msgid "tail = C2 ... CN."
msgstr "svans = C2 ... CN."

msgid "I shall also use the notation::"
msgstr "Jag kommer också att använda notationen::"

msgid "C + (C1 C2 ... CN) = C C1 C2 ... CN"
msgstr "C + (C1 C2 ... CN) = C C1 C2 ... CN"

msgid "to denote the sum of the lists [C] + [C1, C2, ... ,CN]."
msgstr "för att beteckna summan av listorna [C] + [C1, C2, ... ,CN]."

msgid "Now I can explain how the MRO works in Python 2.3."
msgstr "Nu kan jag förklara hur MRO fungerar i Python 2.3."

msgid ""
"Consider a class C in a multiple inheritance hierarchy, with C inheriting "
"from the base classes B1, B2, ...  , BN.  We want to compute the "
"linearization L[C] of the class C. The rule is the following:"
msgstr ""
"Betrakta en klass C i en hierarki med flera arvsanlag, där C ärver från "
"basklasserna B1, B2, ...  , BN.  Vi vill beräkna linjäriseringen L[C] för "
"klassen C. Regeln är följande:"

msgid ""
"*the linearization of C is the sum of C plus the merge of the linearizations "
"of the parents and the list of the parents.*"
msgstr ""
"*linjäriseringen av C är summan av C plus sammanslagningen av "
"linjäriseringarna av föräldrarna och listan över föräldrarna.*"

msgid "In symbolic notation::"
msgstr "I symbolisk notation::"

msgid "L[C(B1 ... BN)] = C + merge(L[B1] ... L[BN], B1 ... BN)"
msgstr "L[C(B1 ... BN)] = C + merge(L[B1] ... L[BN], B1 ... BN)"

msgid ""
"In particular, if C is the ``object`` class, which has no parents, the "
"linearization is trivial::"
msgstr ""
"I synnerhet om C är klassen ``objekt``, som inte har några föräldrar, är "
"linjäriseringen trivial::"

msgid "L[object] = object."
msgstr "L[objekt] = objekt."

msgid ""
"However, in general one has to compute the merge according to the following "
"prescription:"
msgstr ""
"I allmänhet måste man dock beräkna sammanslagningen enligt följande recept:"

msgid ""
"*take the head of the first list, i.e L[B1][0]; if this head is not in the "
"tail of any of the other lists, then add it to the linearization of C and "
"remove it from the lists in the merge, otherwise look at the head of the "
"next list and take it, if it is a good head.  Then repeat the operation "
"until all the class are removed or it is impossible to find good heads.  In "
"this case, it is impossible to construct the merge, Python 2.3 will refuse "
"to create the class C and will raise an exception.*"
msgstr ""
"*ta huvudet på den första listan, dvs L[B1][0]; om detta huvud inte finns i "
"svansen på någon av de andra listorna, lägg då till det i linjäriseringen av "
"C och ta bort det från listorna i sammanslagningen, annars titta på huvudet "
"på nästa lista och ta det, om det är ett bra huvud.  Upprepa sedan "
"operationen tills alla klasser är borttagna eller det är omöjligt att hitta "
"bra huvuden.  I det här fallet är det omöjligt att konstruera "
"sammanslagningen, Python 2.3 kommer att vägra att skapa klassen C och kommer "
"att ge upphov till ett undantag.*"

msgid ""
"This prescription ensures that the merge operation *preserves* the ordering, "
"if the ordering can be preserved.  On the other hand, if the order cannot be "
"preserved (as in the example of serious order disagreement discussed above) "
"then the merge cannot be computed."
msgstr ""
"Denna föreskrift säkerställer att sammanslagningsoperationen *bevarar* "
"ordningen, om ordningen kan bevaras.  Å andra sidan, om ordningen inte kan "
"bevaras (som i exemplet med allvarlig oenighet om ordningen som diskuterades "
"ovan) kan sammanslagningen inte beräknas."

msgid ""
"The computation of the merge is trivial if C has only one parent (single "
"inheritance); in this case::"
msgstr ""
"Beräkningen av sammanslagningen är trivial om C bara har en förälder (enkel "
"nedärvning); i detta fall::"

msgid "L[C(B)] = C + merge(L[B],B) = C + L[B]"
msgstr "L[C(B)] = C + merge(L[B],B) = C + L[B]"

msgid ""
"However, in the case of multiple inheritance things are more cumbersome and "
"I don't expect you can understand the rule without a couple of examples ;-)"
msgstr ""
"Men när det gäller multipel arv är saker och ting mer besvärliga och jag "
"förväntar mig inte att du kan förstå regeln utan ett par exempel ;-)"

msgid "Examples"
msgstr "Exempel"

msgid "First example. Consider the following hierarchy:"
msgstr "Första exemplet. Tänk på följande hierarki:"

msgid "In this case the inheritance graph can be drawn as:"
msgstr "I detta fall kan arvsgrafen ritas enligt följande:"

msgid ""
"                          6\n"
"                         ---\n"
"Level 3                 | O |                  (more general)\n"
"                      /  ---  \\\n"
"                     /    |    \\                      |\n"
"                    /     |     \\                     |\n"
"                   /      |      \\                    |\n"
"                  ---    ---    ---                   |\n"
"Level 2        3 | D | 4| E |  | F | 5                |\n"
"                  ---    ---    ---                   |\n"
"                   \\  \\ _ /       |                   |\n"
"                    \\    / \\ _    |                   |\n"
"                     \\  /      \\  |                   |\n"
"                      ---      ---                    |\n"
"Level 1            1 | B |    | C | 2                 |\n"
"                      ---      ---                    |\n"
"                        \\      /                      |\n"
"                         \\    /                      \\ /\n"
"                           ---\n"
"Level 0                 0 | A |                (more specialized)\n"
"                           ---"
msgstr ""
"                          6\n"
"                         ---\n"
"Nivå 3 | O | (mer allmänt)\n"
"                      / --- \\\n"
"                     / | \\ |\n"
"                    / | \\ |\n"
"                   / | \\ |\n"
"                  --- --- --- |\n"
"Nivå 2 3 | D | 4| E | | F | 5 | --- --- --- --- --- --- --- --- ---\n"
"                  --- --- --- |\n"
"                   \\ \\ _ / | |\n"
"                    \\ / \\ _ | |\n"
"                     \\ / \\ | |\n"
"                      --- --- |\n"
"Nivå 1 1 | B | | C | 2\n"
"                      --- --- |\n"
"                        \\ / |\n"
"                         \\ / \\ /\n"
"                           ---\n"
"Nivå 0 0 | A | (mer specialiserad)\n"
"                           ---"

msgid "The linearizations of O,D,E and F are trivial::"
msgstr "Linjäriseringarna av O,D,E och F är triviala::"

msgid ""
"L[O] = O\n"
"L[D] = D O\n"
"L[E] = E O\n"
"L[F] = F O"
msgstr ""
"L[O] = O\n"
"L[D] = D O\n"
"L[E] = E O\n"
"L[F] = F O"

msgid "The linearization of B can be computed as::"
msgstr "Linjäriseringen av B kan beräknas som::"

msgid "L[B] = B + merge(DO, EO, DE)"
msgstr "L[B] = B + sammanslagning(DO, EO, DE)"

msgid ""
"We see that D is a good head, therefore we take it and we are reduced to "
"compute ``merge(O,EO,E)``.  Now O is not a good head, since it is in the "
"tail of the sequence EO.  In this case the rule says that we have to skip to "
"the next sequence.  Then we see that E is a good head; we take it and we are "
"reduced to compute ``merge(O,O)`` which gives O. Therefore::"
msgstr ""
"Vi ser att D är ett bra huvud, därför tar vi det och vi reduceras till att "
"beräkna ``merge(O,EO,E)``.  Nu är O inte ett bra huvud, eftersom det ligger "
"i svansen på sekvensen EO.  I det här fallet säger regeln att vi måste hoppa "
"till nästa sekvens.  Då ser vi att E är ett bra huvud; vi tar det och vi "
"reduceras till att beräkna ``merge(O,O)`` vilket ger O. Därför::"

msgid "L[B] =  B D E O"
msgstr "L[B] = B D E O"

msgid "Using the same procedure one finds::"
msgstr "Genom att använda samma procedur finner man::"

msgid ""
"L[C] = C + merge(DO,FO,DF)\n"
"     = C + D + merge(O,FO,F)\n"
"     = C + D + F + merge(O,O)\n"
"     = C D F O"
msgstr ""
"L[C] = C + merge(DO,FO,DF)\n"
"     = C + D + merge(O,FO,F)\n"
"     = C + D + F + merge(O,O)\n"
"     = C D F O"

msgid "Now we can compute::"
msgstr "Nu kan vi beräkna::"

msgid ""
"L[A] = A + merge(BDEO,CDFO,BC)\n"
"     = A + B + merge(DEO,CDFO,C)\n"
"     = A + B + C + merge(DEO,DFO)\n"
"     = A + B + C + D + merge(EO,FO)\n"
"     = A + B + C + D + E + merge(O,FO)\n"
"     = A + B + C + D + E + F + merge(O,O)\n"
"     = A B C D E F O"
msgstr ""
"L[A] = A + merge(BDEO,CDFO,BC)\n"
"     = A + B + sammanslagning(DEO,CDFO,C)\n"
"     = A + B + C + sammanslagning(DEO,DFO)\n"
"     = A + B + C + D + sammanslagning(EO,FO)\n"
"     = A + B + C + D + E + merge(O,FO)\n"
"     = A + B + C + D + E + F + merge(O,O)\n"
"     = A B C D E F O"

msgid ""
"In this example, the linearization is ordered in a pretty nice way according "
"to the inheritance level, in the sense that lower levels (i.e. more "
"specialized classes) have higher precedence (see the inheritance graph).  "
"However, this is not the general case."
msgstr ""
"I det här exemplet är linjäriseringen ordnad på ett ganska bra sätt enligt "
"arvsnivån, i den meningen att lägre nivåer (dvs. mer specialiserade klasser) "
"har högre prioritet (se arvsgrafen).  Detta är dock inte det generella "
"fallet."

msgid ""
"I leave as an exercise for the reader to compute the linearization for my "
"second example:"
msgstr ""
"Jag lämnar som en övning för läsaren att beräkna linjäriseringen för mitt "
"andra exempel:"

msgid ""
"The only difference with the previous example is the change B(D,E) --> B(E,"
"D); however even such a little modification completely changes the ordering "
"of the hierarchy:"
msgstr ""
"Den enda skillnaden mot föregående exempel är ändringen B(D,E) --> B(E,D), "
"men även en sådan liten ändring förändrar helt hierarkins ordning:"

msgid ""
"                           6\n"
"                          ---\n"
"Level 3                  | O |\n"
"                       /  ---  \\\n"
"                      /    |    \\\n"
"                     /     |     \\\n"
"                    /      |      \\\n"
"                  ---     ---    ---\n"
"Level 2        2 | E | 4 | D |  | F | 5\n"
"                  ---     ---    ---\n"
"                   \\      / \\     /\n"
"                    \\    /   \\   /\n"
"                     \\  /     \\ /\n"
"                      ---     ---\n"
"Level 1            1 | B |   | C | 3\n"
"                      ---     ---\n"
"                       \\       /\n"
"                        \\     /\n"
"                          ---\n"
"Level 0                0 | A |\n"
"                          ---"
msgstr ""
"                           6\n"
"                          ---\n"
"Nivå 3 | O |\n"
"                       / --- \\\n"
"                      / | \\\n"
"                     / | \\\n"
"                    / | \\\n"
"                  --- --- ---\n"
"Nivå 2 2 | E | 4 | D | | F | 5\n"
"                  --- --- ---\n"
"                   \\ / \\ /\n"
"                    \\ / \\ /\n"
"                     \\ / \\ /\n"
"                      --- ---\n"
"Nivå 1 1 | B | | C | 3\n"
"                      --- ---\n"
"                       \\ /\n"
"                        \\ /\n"
"                          ---\n"
"Nivå 0 0 | A |\n"
"                          ---"

msgid ""
"Notice that the class E, which is in the second level of the hierarchy, "
"precedes the class C, which is in the first level of the hierarchy, i.e. E "
"is more specialized than C, even if it is in a higher level."
msgstr ""
"Observera att klassen E, som befinner sig på den andra nivån i hierarkin, "
"föregår klassen C, som befinner sig på den första nivån i hierarkin, dvs E "
"är mer specialiserad än C, även om den befinner sig på en högre nivå."

msgid ""
"A lazy programmer can obtain the MRO directly from Python 2.2, since in this "
"case it coincides with the Python 2.3 linearization.  It is enough to invoke "
"the :meth:`~type.mro` method of class A:"
msgstr ""
"En lat programmerare kan få MRO direkt från Python 2.2, eftersom det i detta "
"fall sammanfaller med Python 2.3-linjäriseringen.  Det räcker med att "
"anropa :meth:`~type.mro`-metoden för klass A:"

msgid ""
"Finally, let me consider the example discussed in the first section, "
"involving a serious order disagreement.  In this case, it is straightforward "
"to compute the linearizations of O, X, Y, A and B:"
msgstr ""
"Låt mig slutligen ta upp det exempel som diskuterades i det första "
"avsnittet, med en allvarlig oenighet om ordern.  I det här fallet är det "
"enkelt att beräkna linjäriseringarna av O, X, Y, A och B:"

msgid ""
"L[O] = 0\n"
"L[X] = X O\n"
"L[Y] = Y O\n"
"L[A] = A X Y O\n"
"L[B] = B Y X O"
msgstr ""
"L[O] = 0\n"
"L[X] = X O\n"
"L[Y] = Y O\n"
"L[A] = A X Y O\n"
"L[B] = B Y X O"

msgid ""
"However, it is impossible to compute the linearization for a class C that "
"inherits from A and B::"
msgstr ""
"Det är dock omöjligt att beräkna linjäriseringen för en klass C som ärver "
"från A och B::"

msgid ""
"L[C] = C + merge(AXYO, BYXO, AB)\n"
"     = C + A + merge(XYO, BYXO, B)\n"
"     = C + A + B + merge(XYO, YXO)"
msgstr ""
"L[C] = C + sammanslagning(AXYO, BYXO, AB)\n"
"     = C + A + sammanslagning(XYO, BYXO, B)\n"
"     = C + A + B + sammanslagning(XYO, YXO)"

msgid ""
"At this point we cannot merge the lists XYO and YXO, since X is in the tail "
"of YXO whereas Y is in the tail of XYO:  therefore there are no good heads "
"and the C3 algorithm stops.  Python 2.3 raises an error and refuses to "
"create the class C."
msgstr ""
"Vid denna punkt kan vi inte slå samman listorna XYO och YXO, eftersom X är i "
"svansen på YXO medan Y är i svansen på XYO: därför finns det inga bra "
"huvuden och C3-algoritmen stannar.  Python 2.3 ger upphov till ett fel och "
"vägrar att skapa klassen C."

msgid "Bad Method Resolution Orders"
msgstr "Bad Method Resolution Order"

msgid ""
"A MRO is *bad* when it breaks such fundamental properties as local "
"precedence ordering and monotonicity.  In this section, I will show that "
"both the MRO for classic classes and the MRO for new style classes in Python "
"2.2 are bad."
msgstr ""
"En MRO är *dålig* när den bryter mot sådana grundläggande egenskaper som "
"lokal prioritetsordning och monotonicitet.  I det här avsnittet ska jag visa "
"att både MRO för klassiska klasser och MRO för new style-klasser i Python "
"2.2 är dåliga."

msgid ""
"It is easier to start with the local precedence ordering.  Consider the "
"following example:"
msgstr ""
"Det är lättare att börja med den lokala prioritetsordningen.  Tänk på "
"följande exempel:"

msgid "with inheritance diagram"
msgstr "med nedärvningsdiagram"

msgid ""
"             O\n"
"             |\n"
"(buy spam)   F\n"
"             | \\\n"
"             | E   (buy eggs)\n"
"             | /\n"
"             G\n"
"\n"
"      (buy eggs or spam ?)"
msgstr ""
"             O\n"
"             |\n"
"(köp skräppost) F\n"
"             | \\\n"
"             | E (köp ägg)\n"
"             | /\n"
"             G\n"
"\n"
"      (köpa ägg eller spam?)"

msgid ""
"We see that class G inherits from F and E, with F *before* E:  therefore we "
"would expect the attribute *G.remember2buy* to be inherited by *F."
"remember2buy* and not by *E.remember2buy*:  nevertheless Python 2.2 gives"
msgstr ""
"Vi ser att klass G ärver från F och E, med F *före* E: därför skulle vi "
"förvänta oss att attributet *G.remember2buy* ärvs av *F.remember2buy* och "
"inte av *E.remember2buy*: ändå ger Python 2.2"

msgid ""
"This is a breaking of local precedence ordering since the order in the local "
"precedence list, i.e. the list of the parents of G, is not preserved in the "
"Python 2.2 linearization of G::"
msgstr ""
"Detta är ett brott mot lokal prioritetsordning eftersom ordningen i den "
"lokala prioritetslistan, dvs. listan över G:s föräldrar, inte bevaras i "
"Python 2.2-linjäriseringen av G::"

msgid "L[G,P22]= G E F object   # F *follows* E"
msgstr "L[G,P22]= G E F objekt # F *följer* E"

msgid ""
"One could argue that the reason why F follows E in the Python 2.2 "
"linearization is that F is less specialized than E, since F is the "
"superclass of E; nevertheless the breaking of local precedence ordering is "
"quite non-intuitive and error prone.  This is particularly true since it is "
"a different from old style classes:"
msgstr ""
"Man skulle kunna hävda att anledningen till att F följer E i Python 2.2-"
"linjäriseringen är att F är mindre specialiserad än E, eftersom F är "
"superklassen till E. Ändå är brytningen av lokal prioritetsordning ganska "
"icke-intuitiv och felbenägen.  Detta är särskilt sant eftersom det skiljer "
"sig från klasser i gammal stil:"

msgid ""
"In this case the MRO is GFEF and the local precedence ordering is preserved."
msgstr ""
"I detta fall är den huvudsakliga bestämmelseorten GFEF och den lokala "
"prioritetsordningen bevaras."

msgid ""
"As a general rule, hierarchies such as the previous one should be avoided, "
"since it is unclear if F should override E or vice-versa. Python 2.3 solves "
"the ambiguity by raising an exception in the creation of class G, "
"effectively stopping the programmer from generating ambiguous hierarchies.  "
"The reason for that is that the C3 algorithm fails when the merge::"
msgstr ""
"Som en allmän regel bör hierarkier som den föregående undvikas, eftersom det "
"är oklart om F ska åsidosätta E eller vice versa. Python 2.3 löser "
"tvetydigheten genom att lyfta ett undantag i skapandet av klass G, vilket "
"effektivt hindrar programmeraren från att generera tvetydiga hierarkier.  "
"Anledningen till detta är att C3-algoritmen misslyckas när merge::"

msgid "merge(FO,EFO,FE)"
msgstr "sammanfoga(FO,EFO,FE)"

msgid ""
"cannot be computed, because F is in the tail of EFO and E is in the tail of "
"FE."
msgstr ""
"kan inte beräknas, eftersom F är i svansen på EFO och E är i svansen på FE."

msgid ""
"The real solution is to design a non-ambiguous hierarchy, i.e. to derive G "
"from E and F (the more specific first) and not from F and E; in this case "
"the MRO is GEF without any doubt."
msgstr ""
"Den verkliga lösningen är att utforma en icke-tvetydig hierarki, dvs. att "
"härleda G från E och F (den mer specifika först) och inte från F och E; i "
"detta fall är MRO utan tvekan GEF."

msgid ""
"           O\n"
"           |\n"
"           F (spam)\n"
"         / |\n"
"(eggs)   E |\n"
"         \\ |\n"
"           G\n"
"             (eggs, no doubt)"
msgstr ""
"           O\n"
"           |\n"
"           F (skräppost)\n"
"         / |\n"
"(ägg) E |\n"
"         \\ |\n"
"           G\n"
"             (ägg, utan tvekan)"

msgid ""
"Python 2.3 forces the programmer to write good hierarchies (or, at least, "
"less error-prone ones)."
msgstr ""
"Python 2.3 tvingar programmeraren att skriva bra hierarkier (eller "
"åtminstone mindre felbenägna sådana)."

msgid ""
"On a related note, let me point out that the Python 2.3 algorithm is smart "
"enough to recognize obvious mistakes, as the duplication of classes in the "
"list of parents:"
msgstr ""
"I sammanhanget vill jag påpeka att Python 2.3-algoritmen är tillräckligt "
"smart för att känna igen uppenbara misstag, t.ex. dubblering av klasser i "
"listan över föräldrar:"

msgid ""
"Python 2.2 (both for classic classes and new style classes) in this "
"situation, would not raise any exception."
msgstr ""
"Python 2.2 (både för klassiska klasser och klasser med ny stil) skulle i "
"denna situation inte ge upphov till något undantag."

msgid ""
"Finally, I would like to point out two lessons we have learned from this "
"example:"
msgstr ""
"Slutligen vill jag peka på två lärdomar som vi har dragit av detta exempel:"

msgid ""
"despite the name, the MRO determines the resolution order of attributes, not "
"only of methods;"
msgstr ""
"trots namnet bestämmer MRO resolutionsordningen för attribut, inte bara för "
"metoder;"

msgid ""
"the default food for Pythonistas is spam !  (but you already knew that ;-)"
msgstr "standardmat för Pythonistas är spam !  (men det visste du redan ;-)"

msgid ""
"Having discussed the issue of local precedence ordering, let me now consider "
"the issue of monotonicity.  My goal is to show that neither the MRO for "
"classic classes nor that for Python 2.2 new style classes is monotonic."
msgstr ""
"Efter att ha diskuterat frågan om lokal prioritetsordning, låt mig nu ta upp "
"frågan om monotonicitet.  Mitt mål är att visa att varken MRO för klassiska "
"klasser eller för Python 2.2 new style classes är monoton."

msgid ""
"To prove that the MRO for classic classes is non-monotonic is rather "
"trivial, it is enough to look at the diamond diagram:"
msgstr ""
"Att bevisa att MRO för klassiska klasser är icke-monoton är ganska trivialt, "
"det räcker med att titta på diamantdiagrammet:"

msgid ""
"   C\n"
"  / \\\n"
" /   \\\n"
"A     B\n"
" \\   /\n"
"  \\ /\n"
"   D"
msgstr ""
"   C\n"
"  / \\\n"
" / \\\n"
"A B\n"
" \\ /\n"
"  \\ /\n"
"   D"

msgid "One easily discerns the inconsistency::"
msgstr "Man kan lätt urskilja inkonsekvensen::"

msgid ""
"L[B,P21] = B C        # B precedes C : B's methods win\n"
"L[D,P21] = D A C B C  # B follows C  : C's methods win!"
msgstr ""
"L[B,P21] = B C # B föregår C : B:s metoder vinner\n"
"L[D,P21] = D A C B C # B följer C : C:s metoder vinner!"

msgid ""
"On the other hand, there are no problems with the Python 2.2 and 2.3 MROs, "
"they give both::"
msgstr ""
"Å andra sidan finns det inga problem med Python 2.2 och 2.3 MRO, de ger "
"båda::"

msgid "L[D] = D A B C"
msgstr "L[D] = D A B C"

msgid ""
"Guido points out in his essay [#]_ that the classic MRO is not so bad in "
"practice, since one can typically avoids diamonds for classic classes. But "
"all new style classes inherit from ``object``, therefore diamonds are "
"unavoidable and inconsistencies shows up in every multiple inheritance graph."
msgstr ""
"Guido påpekar i sin essä [#]_ att den klassiska MRO inte är så illa i "
"praktiken, eftersom man vanligtvis kan undvika diamanter för klassiska "
"klasser. Men alla klasser i ny stil ärver från ``objekt``, därför är "
"diamanter oundvikliga och inkonsekvenser dyker upp i varje multipel arvgraf."

msgid ""
"The MRO of Python 2.2 makes breaking monotonicity difficult, but not "
"impossible.  The following example, originally provided by Samuele Pedroni, "
"shows that the MRO of Python 2.2 is non-monotonic:"
msgstr ""
"MRO i Python 2.2 gör det svårt, men inte omöjligt, att bryta monotonicitet.  "
"Följande exempel, ursprungligen tillhandahållet av Samuele Pedroni, visar "
"att MRO i Python 2.2 är icke-monoton:"

msgid ""
"Here are the linearizations according to the C3 MRO (the reader should "
"verify these linearizations as an exercise and draw the inheritance "
"diagram ;-) ::"
msgstr ""
"Här är linjäriseringarna enligt C3 MRO (läsaren bör verifiera dessa "
"linjäriseringar som en övning och rita arvsdiagrammet ;-) ::"

msgid ""
"L[A] = A O\n"
"L[B] = B O\n"
"L[C] = C O\n"
"L[D] = D O\n"
"L[E] = E O\n"
"L[K1]= K1 A B C O\n"
"L[K2]= K2 D B E O\n"
"L[K3]= K3 D A O\n"
"L[Z] = Z K1 K2 K3 D A B C E O"
msgstr ""
"L[A] = A O\n"
"L[B] = B O\n"
"L[C] = C O\n"
"L[D] = D O\n"
"L[E] = E O\n"
"L[K1]= K1 A B C O\n"
"L[K2]= K2 D B E O\n"
"L[K3]= K3 D A O\n"
"L[Z] = Z K1 K2 K3 D A B C E O"

msgid ""
"Python 2.2 gives exactly the same linearizations for A, B, C, D, E, K1, K2 "
"and K3, but a different linearization for Z::"
msgstr ""
"Python 2.2 ger exakt samma linjäriseringar för A, B, C, D, E, K1, K2 och K3, "
"men en annan linjärisering för Z::"

msgid "L[Z,P22] = Z K1 K3 A K2 D B C E O"
msgstr "L[Z,P22] = Z K1 K3 A K2 D B C E O"

msgid ""
"It is clear that this linearization is *wrong*, since A comes before D "
"whereas in the linearization of K3 A comes *after* D. In other words, in K3 "
"methods derived by D override methods derived by A, but in Z, which still is "
"a subclass of K3, methods derived by A override methods derived by D!  This "
"is a violation of monotonicity.  Moreover, the Python 2.2 linearization of Z "
"is also inconsistent with local precedence ordering, since the local "
"precedence list of the class Z is [K1, K2, K3] (K2 precedes K3), whereas in "
"the linearization of Z K2 *follows* K3.  These problems explain why the 2.2 "
"rule has been dismissed in favor of the C3 rule."
msgstr ""
"Det är uppenbart att denna linjärisering är *felaktig*, eftersom A kommer "
"före D medan A i linjäriseringen av K3 kommer *efter* D. Med andra ord, i K3 "
"åsidosätter metoder som härrör från D metoder som härrör från A, men i Z, "
"som fortfarande är en underklass till K3, åsidosätter metoder som härrör "
"från A metoder som härrör från D!  Detta är ett brott mot monotonicitet.  "
"Dessutom är Python 2.2-linjäriseringen av Z också inkonsekvent med lokal "
"prioritetsordning, eftersom den lokala prioritetslistan för klassen Z är "
"[K1, K2, K3] (K2 föregår K3), medan K2 i linjäriseringen av Z *följer* K3.  "
"Dessa problem förklarar varför 2.2-regeln har avfärdats till förmån för C3-"
"regeln."

msgid "The end"
msgstr "Slutet"

msgid ""
"This section is for the impatient reader, who skipped all the previous "
"sections and jumped immediately to the end.  This section is for the lazy "
"programmer too, who didn't want to exercise her/his brain. Finally, it is "
"for the programmer with some hubris, otherwise s/he would not be reading a "
"paper on the C3 method resolution order in multiple inheritance "
"hierarchies ;-) These three virtues taken all together (and *not* "
"separately) deserve a prize:  the prize is a short Python 2.2 script that "
"allows you to compute the 2.3 MRO without risk to your brain.  Simply change "
"the last line to play with the various examples I have discussed in this "
"paper.::"
msgstr ""
"Detta avsnitt är för den otåliga läsaren, som hoppat över alla tidigare "
"avsnitt och hoppade direkt till slutet.  Det här avsnittet är också för den "
"lata programmeraren, som inte ville träna sin hjärna. Slutligen är det för "
"programmeraren med lite hybris, annars skulle han / hon inte läsa ett papper "
"om C3-metodens upplösningsordning i flera arvshierarkier ;-) Dessa tre "
"dygder tillsammans (och *inte* var för sig) förtjänar ett pris: priset är "
"ett kort Python 2.2-skript som gör att du kan beräkna 2,3 MRO utan risk för "
"din hjärna.  Ändra bara den sista raden för att leka med de olika exemplen "
"som jag har diskuterat i det här dokumentet:::"

msgid ""
"#<mro.py>\n"
"\n"
"\"\"\"C3 algorithm by Samuele Pedroni (with readability enhanced by me)."
"\"\"\"\n"
"\n"
"class __metaclass__(type):\n"
"    \"All classes are metamagically modified to be nicely printed\"\n"
"    __repr__ = lambda cls: cls.__name__\n"
"\n"
"class ex_2:\n"
"    \"Serious order disagreement\" #From Guido\n"
"    class O: pass\n"
"    class X(O): pass\n"
"    class Y(O): pass\n"
"    class A(X,Y): pass\n"
"    class B(Y,X): pass\n"
"    try:\n"
"        class Z(A,B): pass #creates Z(A,B) in Python 2.2\n"
"    except TypeError:\n"
"        pass # Z(A,B) cannot be created in Python 2.3\n"
"\n"
"class ex_5:\n"
"    \"My first example\"\n"
"    class O: pass\n"
"    class F(O): pass\n"
"    class E(O): pass\n"
"    class D(O): pass\n"
"    class C(D,F): pass\n"
"    class B(D,E): pass\n"
"    class A(B,C): pass\n"
"\n"
"class ex_6:\n"
"    \"My second example\"\n"
"    class O: pass\n"
"    class F(O): pass\n"
"    class E(O): pass\n"
"    class D(O): pass\n"
"    class C(D,F): pass\n"
"    class B(E,D): pass\n"
"    class A(B,C): pass\n"
"\n"
"class ex_9:\n"
"    \"Difference between Python 2.2 MRO and C3\" #From Samuele\n"
"    class O: pass\n"
"    class A(O): pass\n"
"    class B(O): pass\n"
"    class C(O): pass\n"
"    class D(O): pass\n"
"    class E(O): pass\n"
"    class K1(A,B,C): pass\n"
"    class K2(D,B,E): pass\n"
"    class K3(D,A): pass\n"
"    class Z(K1,K2,K3): pass\n"
"\n"
"def merge(seqs):\n"
"    print '\\n\\nCPL[%s]=%s' % (seqs[0][0],seqs),\n"
"    res = []; i=0\n"
"    while 1:\n"
"      nonemptyseqs=[seq for seq in seqs if seq]\n"
"      if not nonemptyseqs: return res\n"
"      i+=1; print '\\n',i,'round: candidates...',\n"
"      for seq in nonemptyseqs: # find merge candidates among seq heads\n"
"          cand = seq[0]; print ' ',cand,\n"
"          nothead=[s for s in nonemptyseqs if cand in s[1:]]\n"
"          if nothead: cand=None #reject candidate\n"
"          else: break\n"
"      if not cand: raise \"Inconsistent hierarchy\"\n"
"      res.append(cand)\n"
"      for seq in nonemptyseqs: # remove cand\n"
"          if seq[0] == cand: del seq[0]\n"
"\n"
"def mro(C):\n"
"    \"Compute the class precedence list (mro) according to C3\"\n"
"    return merge([[C]]+map(mro,C.__bases__)+[list(C.__bases__)])\n"
"\n"
"def print_mro(C):\n"
"    print '\\nMRO[%s]=%s' % (C,mro(C))\n"
"    print '\\nP22 MRO[%s]=%s' % (C,C.mro())\n"
"\n"
"print_mro(ex_9.Z)\n"
"\n"
"#</mro.py>"
msgstr ""
"#<mro.py>\n"
"\n"
"\"\"\"C3-algoritm av Samuele Pedroni (med förbättrad läsbarhet av mig)."
"\"\"\"\n"
"\n"
"klass __metaklass__(typ):\n"
"    \"Alla klasser är metamagiskt modifierade för att bli snyggt "
"utskrivna\"\n"
"    __repr__ = lambda cls: cls.__name__\n"
"\n"
"klass ex_2:\n"
"    \"Allvarlig order oenighet\" #Från Guido\n"
"    klass O: pass\n"
"    klass X(O): pass\n"
"    klass Y(O): pass\n"
"    klass A(X,Y): pass\n"
"    klass B(Y,X): pass\n"
"    försök:\n"
"        class Z(A,B): pass #skapar Z(A,B) i Python 2.2\n"
"    except TypeError:\n"
"        pass # Z(A,B) kan inte skapas i Python 2.3\n"
"\n"
"klass ex_5:\n"
"    \"Mitt första exempel\"\n"
"    klass O: pass\n"
"    klass F(O): pass\n"
"    klass E(O): pass\n"
"    klass D(O): pass\n"
"    klass C(D,F): pass\n"
"    klass B(D,E): pass\n"
"    klass A(B,C): pass\n"
"\n"
"klass ex_6:\n"
"    \"Mitt andra exempel\"\n"
"    klass O: pass\n"
"    klass F(O): pass\n"
"    klass E(O): pass\n"
"    klass D(O): pass\n"
"    klass C(D,F): pass\n"
"    klass B(E,D): pass\n"
"    klass A(B,C): pass\n"
"\n"
"klass ex_9:\n"
"    \"Skillnad mellan Python 2.2 MRO och C3\" #Från Samuele\n"
"    klass O: pass\n"
"    klass A(O): pass\n"
"    klass B(O): pass\n"
"    klass C(O): pass\n"
"    klass D(O): pass\n"
"    klass E(O): pass\n"
"    klass K1(A,B,C): godkänd\n"
"    klass K2(D,B,E): pass\n"
"    klass K3(D,A): pass\n"
"    klass Z(K1,K2,K3): pass\n"
"\n"
"def merge(seqs):\n"
"    print '\\n\\nCPL[%s]=%s' % (seqs[0][0],seqs),\n"
"    res = []; i=0\n"
"    medan 1:\n"
"      nonemptyseqs=[seq for seq in seqs if seq]\n"
"      om inte nonemptyseqs: returnera res\n"
"      i+=1; print '\\n',i,'runda: kandidater...',\n"
"      for seq in nonemptyseqs: # hitta sammanslagningskandidater bland seq-"
"huvuden\n"
"          cand = seq[0]; print ' ',cand,\n"
"          nothead=[s for s in nonemptyseqs if cand in s[1:]]]\n"
"          if nothead: cand=None #avvisa kandidat\n"
"          annat: bryt\n"
"      if not cand: raise \"Inkonsekvent hierarki\"\n"
"      res.append(cand)\n"
"      for seq in nonemptyseqs: # ta bort cand\n"
"          if seq[0] == cand: del seq[0]\n"
"\n"
"def mro(C):\n"
"    \"Beräkna klassens prioritetslista (mro) enligt C3\"\n"
"    return merge([[C]]+map(mro,C.__bases__)+[list(C.__bases__)])\n"
"\n"
"def print_mro(C):\n"
"    print '\\nMRO[%s]=%s' % (C,mro(C))\n"
"    print '\\nP22 MRO[%s]=%s' % (C,C.mro())\n"
"\n"
"print_mro(ex_9.Z)\n"
"\n"
"#</mro.py>"

msgid "That's all folks,"
msgstr "Det var allt, gott folk,"

msgid "enjoy !"
msgstr "njut!"

msgid "Resources"
msgstr "Resurser"

msgid ""
"The thread on python-dev started by Samuele Pedroni: https://mail.python.org/"
"pipermail/python-dev/2002-October/029035.html"
msgstr ""
"Tråden på python-dev startad av Samuele Pedroni: https://mail.python.org/"
"pipermail/python-dev/2002-October/029035.html"

msgid ""
"The paper *A Monotonic Superclass Linearization for Dylan*: https://doi."
"org/10.1145/236337.236343"
msgstr ""
"Uppsatsen *A Monotonic Superclass Linearization for Dylan*: https://doi."
"org/10.1145/236337.236343"

msgid ""
"Guido van Rossum's essay, *Unifying types and classes in Python 2.2*: "
"https://web.archive.org/web/20140210194412/http://www.python.org/download/"
"releases/2.2.2/descrintro"
msgstr ""
"Guido van Rossums uppsats, *Unifying types and classes in Python 2.2*: "
"https://web.archive.org/web/20140210194412/http://www.python.org/download/"
"releases/2.2.2/descrintro"
