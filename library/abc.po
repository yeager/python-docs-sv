# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!abc` --- Abstract Base Classes"
msgstr ":mod:`!abc` --- Abstrakta basklasser"

msgid "**Source code:** :source:`Lib/abc.py`"
msgstr "**Källkod:** :source:`Lib/abc.py`"

msgid ""
"This module provides the infrastructure for defining :term:`abstract base "
"classes <abstract base class>` (ABCs) in Python, as outlined in :pep:`3119`; "
"see the PEP for why this was added to Python. (See also :pep:`3141` and the :"
"mod:`numbers` module regarding a type hierarchy for numbers based on ABCs.)"
msgstr ""
"Denna modul tillhandahåller infrastrukturen för att definiera :term:"
"``abstrakta basklasser <abstract base class>`` (ABC) i Python, enligt :pep:"
"`3119`; se PEP:en för varför detta lades till i Python. (Se även :pep:`3141` "
"och modulen :mod:`numbers` angående en typhierarki för tal baserad på ABC)"

msgid ""
"The :mod:`collections` module has some concrete classes that derive from "
"ABCs; these can, of course, be further derived. In addition, the :mod:"
"`collections.abc` submodule has some ABCs that can be used to test whether a "
"class or instance provides a particular interface, for example, if it is :"
"term:`hashable` or if it is a :term:`mapping`."
msgstr ""
"Modulen :mod:`collections` har några konkreta klasser som härstammar från "
"ABC; dessa kan naturligtvis härledas ytterligare. Dessutom har undermodulen :"
"mod:`collections.abc` några ABC som kan användas för att testa om en klass "
"eller instans tillhandahåller ett visst gränssnitt, t.ex. om den är :term:"
"`hashable` eller om den är en :term:`mapping`."

msgid ""
"This module provides the metaclass :class:`ABCMeta` for defining ABCs and a "
"helper class :class:`ABC` to alternatively define ABCs through inheritance:"
msgstr ""
"Denna modul tillhandahåller metaklassen :class:`ABCMeta` för att definiera "
"ABC och en hjälpklass :class:`ABC` för att alternativt definiera ABC genom "
"arv:"

msgid ""
"A helper class that has :class:`ABCMeta` as its metaclass.  With this class, "
"an abstract base class can be created by simply deriving from :class:`!ABC` "
"avoiding sometimes confusing metaclass usage, for example::"
msgstr ""
"En hjälpklass som har :class:`ABCMeta` som sin metaklass.  Med denna klass "
"kan en abstrakt basklass skapas genom att helt enkelt härleda från :class:`!"
"ABC`, vilket undviker ibland förvirrande användning av metaklasser, till "
"exempel::"

msgid ""
"from abc import ABC\n"
"\n"
"class MyABC(ABC):\n"
"    pass"
msgstr ""
"från abc import ABC\n"
"\n"
"klass MyABC(ABC):\n"
"    pass"

msgid ""
"Note that the type of :class:`!ABC` is still :class:`ABCMeta`, therefore "
"inheriting from :class:`!ABC` requires the usual precautions regarding "
"metaclass usage, as multiple inheritance may lead to metaclass conflicts. "
"One may also define an abstract base class by passing the metaclass keyword "
"and using :class:`!ABCMeta` directly, for example::"
msgstr ""
"Observera att typen för :class:`!ABC` fortfarande är :class:`ABCMeta`, och "
"att ärva från :class:`!ABC` kräver därför de vanliga försiktighetsåtgärderna "
"beträffande användning av metaklasser, eftersom flerfaldigt arv kan leda "
"till metaklasskonflikter. Man kan också definiera en abstrakt basklass genom "
"att skicka nyckelordet metaclass och använda :class:`!ABCMeta` direkt, till "
"exempel::"

msgid ""
"from abc import ABCMeta\n"
"\n"
"class MyABC(metaclass=ABCMeta):\n"
"    pass"
msgstr ""
"from abc import ABCMeta\n"
"\n"
"class MyABC(metaclass=ABCMeta):\n"
"    pass"

msgid "Metaclass for defining Abstract Base Classes (ABCs)."
msgstr "Metaklass för att definiera abstrakta basklasser (ABC)."

msgid ""
"Use this metaclass to create an ABC.  An ABC can be subclassed directly, and "
"then acts as a mix-in class.  You can also register unrelated concrete "
"classes (even built-in classes) and unrelated ABCs as \"virtual subclasses\" "
"-- these and their descendants will be considered subclasses of the "
"registering ABC by the built-in :func:`issubclass` function, but the "
"registering ABC won't show up in their MRO (Method Resolution Order) nor "
"will method implementations defined by the registering ABC be callable (not "
"even via :func:`super`). [#]_"
msgstr ""
"Använd denna metaklass för att skapa en ABC.  En ABC kan subklassas direkt "
"och fungerar då som en mix-in klass.  Du kan också registrera orelaterade "
"konkreta klasser (även inbyggda klasser) och orelaterade ABC som \"virtuella "
"underklasser\" -- dessa och deras ättlingar kommer att betraktas som "
"underklasser till den registrerande ABC av den inbyggda :func:`issubclass`-"
"funktionen, men den registrerande ABC kommer inte att dyka upp i deras MRO "
"(Method Resolution Order) och inte heller kommer metodimplementationer som "
"definieras av den registrerande ABC att kunna anropas (inte ens via :func:"
"`super`). [#]_"

msgid ""
"Classes created with a metaclass of :class:`!ABCMeta` have the following "
"method:"
msgstr ""
"Klasser som skapats med en metaklass av :class:`!ABCMeta` har följande metod:"

msgid ""
"Register *subclass* as a \"virtual subclass\" of this ABC. For example::"
msgstr ""
"Registrera *subclass* som en \"virtuell subclass\" av denna ABC. Till "
"exempel::"

msgid ""
"from abc import ABC\n"
"\n"
"class MyABC(ABC):\n"
"    pass\n"
"\n"
"MyABC.register(tuple)\n"
"\n"
"assert issubclass(tuple, MyABC)\n"
"assert isinstance((), MyABC)"
msgstr ""
"från abc import ABC\n"
"\n"
"klass MyABC(ABC):\n"
"    pass\n"
"\n"
"MyABC.register(tuple)\n"
"\n"
"assert issubclass(tuple, MyABC)\n"
"assert isinstance((), MyABC)"

msgid "Returns the registered subclass, to allow usage as a class decorator."
msgstr ""
"Returnerar den registrerade subklassen, så att den kan användas som en "
"klassdekorator."

msgid ""
"To detect calls to :meth:`!register`, you can use the :func:"
"`get_cache_token` function."
msgstr ""
"För att upptäcka anrop till :meth:`!register` kan du använda funktionen :"
"func:`get_cache_token`."

msgid "You can also override this method in an abstract base class:"
msgstr "Du kan också åsidosätta den här metoden i en abstrakt basklass:"

msgid "(Must be defined as a class method.)"
msgstr "(Måste definieras som en klassmetod.)"

msgid ""
"Check whether *subclass* is considered a subclass of this ABC.  This means "
"that you can customize the behavior of :func:`issubclass` further without "
"the need to call :meth:`register` on every class you want to consider a "
"subclass of the ABC.  (This class method is called from the :meth:`~type."
"__subclasscheck__` method of the ABC.)"
msgstr ""
"Kontrollera om *subclass* anses vara en subklass av denna ABC.  Detta "
"innebär att du kan anpassa beteendet hos :func:`issubclass` ytterligare utan "
"att behöva anropa :meth:`register` på varje klass du vill betrakta som en "
"underklass till ABC.  (Denna klassmetod anropas från ABC:s metod :meth:"
"`~type.__subclasscheck__`)"

msgid ""
"This method should return ``True``, ``False`` or :data:`NotImplemented`.  If "
"it returns ``True``, the *subclass* is considered a subclass of this ABC. If "
"it returns ``False``, the *subclass* is not considered a subclass of this "
"ABC, even if it would normally be one.  If it returns :data:`!"
"NotImplemented`, the subclass check is continued with the usual mechanism."
msgstr ""
"Denna metod bör returnera ``True``, ``False`` eller :data:`NotImplemented`.  "
"Om den returnerar ``True``, anses *subclass* vara en subklass av denna ABC. "
"Om den returnerar ``False`` anses *subclass* inte vara en subklass av denna "
"ABC, även om den normalt skulle vara det.  Om den returnerar :data:`!"
"NotImplemented`, fortsätter underklasskontrollen med den vanliga mekanismen."

msgid ""
"For a demonstration of these concepts, look at this example ABC definition::"
msgstr ""
"För en demonstration av dessa begrepp, se detta exempel på ABC-definition::"

msgid ""
"class Foo:\n"
"    def __getitem__(self, index):\n"
"        ...\n"
"    def __len__(self):\n"
"        ...\n"
"    def get_iterator(self):\n"
"        return iter(self)\n"
"\n"
"class MyIterable(ABC):\n"
"\n"
"    @abstractmethod\n"
"    def __iter__(self):\n"
"        while False:\n"
"            yield None\n"
"\n"
"    def get_iterator(self):\n"
"        return self.__iter__()\n"
"\n"
"    @classmethod\n"
"    def __subclasshook__(cls, C):\n"
"        if cls is MyIterable:\n"
"            if any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n"
"                return True\n"
"        return NotImplemented\n"
"\n"
"MyIterable.register(Foo)"
msgstr ""
"klass Foo:\n"
"    def __getitem__(self, index):\n"
"        ...\n"
"    def __len__(self):\n"
"        ...\n"
"    def get_iterator(self):\n"
"        return iter(self)\n"
"\n"
"klass MyIterable(ABC):\n"
"\n"
"    @abstraktmetod\n"
"    def __iter__(self):\n"
"        medan False:\n"
"            yield None\n"
"\n"
"    def get_iterator(self):\n"
"        return self.__iter__()\n"
"\n"
"    @klassmetod\n"
"    def __subclasshook__(cls, C):\n"
"        om cls är MyIterable:\n"
"            if any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n"
"                return True\n"
"        return Inte implementerad\n"
"\n"
"MyIterable.register(Foo)"

msgid ""
"The ABC ``MyIterable`` defines the standard iterable method, :meth:`~object."
"__iter__`, as an abstract method.  The implementation given here can still "
"be called from subclasses.  The :meth:`!get_iterator` method is also part of "
"the ``MyIterable`` abstract base class, but it does not have to be "
"overridden in non-abstract derived classes."
msgstr ""
"ABC ``MyIterable`` definierar standardmetoden för iterable, :meth:`~object."
"__iter__`, som en abstrakt metod.  Den implementation som ges här kan "
"fortfarande anropas från subklasser.  Metoden :meth:`!get_iterator` är också "
"en del av den abstrakta basklassen ``MyIterable``, men den behöver inte "
"åsidosättas i icke-abstrakta härledda klasser."

msgid ""
"The :meth:`__subclasshook__` class method defined here says that any class "
"that has an :meth:`~object.__iter__` method in its :attr:`~object.__dict__` "
"(or in that of one of its base classes, accessed via the :attr:`~type."
"__mro__` list) is considered a ``MyIterable`` too."
msgstr ""
"Klassmetoden :meth:`__subclasshook__` som definieras här säger att alla "
"klasser som har en :meth:`~object.__iter__`-metod i sin :attr:`~object."
"__dict__` (eller i en av dess basklasser, som nås via listan :attr:`~type."
"__mro__`) också betraktas som en ``MyIterable``."

msgid ""
"Finally, the last line makes ``Foo`` a virtual subclass of ``MyIterable``, "
"even though it does not define an :meth:`~object.__iter__` method (it uses "
"the old-style iterable protocol, defined in terms of :meth:`~object.__len__` "
"and :meth:`~object.__getitem__`).  Note that this will not make "
"``get_iterator`` available as a method of ``Foo``, so it is provided "
"separately."
msgstr ""
"Slutligen, den sista raden gör ``Foo`` till en virtuell subklass av "
"``MyIterable``, även om den inte definierar en :meth:`~object.__iter__`-"
"metod (den använder det gamla iterabelprotokollet, definierat i termer av :"
"meth:`~object.__len__` och :meth:`~object.__getitem__`).  Observera att "
"detta inte kommer att göra ``get_iterator`` tillgänglig som en metod i "
"``Foo``, så den tillhandahålls separat."

msgid "The :mod:`!abc` module also provides the following decorator:"
msgstr "Modulen :mod:`!abc` innehåller också följande dekorator:"

msgid "A decorator indicating abstract methods."
msgstr "En dekorator som anger abstrakta metoder."

msgid ""
"Using this decorator requires that the class's metaclass is :class:`ABCMeta` "
"or is derived from it.  A class that has a metaclass derived from :class:`!"
"ABCMeta` cannot be instantiated unless all of its abstract methods and "
"properties are overridden.  The abstract methods can be called using any of "
"the normal 'super' call mechanisms.  :func:`!abstractmethod` may be used to "
"declare abstract methods for properties and descriptors."
msgstr ""
"För att använda denna dekorator krävs att klassens metaklass är :class:"
"`ABCMeta` eller är härledd från den.  En klass som har en metaklass som "
"härrör från :class:`!ABCMeta` kan inte instansieras om inte alla dess "
"abstrakta metoder och egenskaper åsidosätts.  De abstrakta metoderna kan "
"anropas med hjälp av någon av de normala \"super\"-anropsmekanismerna. :func:"
"`!abstractmethod` kan användas för att deklarera abstrakta metoder för "
"egenskaper och deskriptorer."

msgid ""
"Dynamically adding abstract methods to a class, or attempting to modify the "
"abstraction status of a method or class once it is created, are only "
"supported using the :func:`update_abstractmethods` function.  The :func:`!"
"abstractmethod` only affects subclasses derived using regular inheritance; "
"\"virtual subclasses\" registered with the ABC's :meth:`~ABCMeta.register` "
"method are not affected."
msgstr ""
"Att dynamiskt lägga till abstrakta metoder i en klass, eller att försöka "
"ändra abstraktionsstatusen för en metod eller klass när den väl har skapats, "
"stöds endast med funktionen :func:`update_abstractmethods`.  Funktionen :"
"func:`!abstractmethod` påverkar endast underklasser som härletts med hjälp "
"av vanligt arv; \"virtuella underklasser\" som registrerats med ABC:s metod :"
"meth:`~ABCMeta.register` påverkas inte."

msgid ""
"When :func:`!abstractmethod` is applied in combination with other method "
"descriptors, it should be applied as the innermost decorator, as shown in "
"the following usage examples::"
msgstr ""
"När :func:`!abstractmethod` används i kombination med andra metodbeskrivare "
"bör den användas som den innersta dekoratorn, vilket visas i följande "
"användningsexempel::"

msgid ""
"class C(ABC):\n"
"    @abstractmethod\n"
"    def my_abstract_method(self, arg1):\n"
"        ...\n"
"    @classmethod\n"
"    @abstractmethod\n"
"    def my_abstract_classmethod(cls, arg2):\n"
"        ...\n"
"    @staticmethod\n"
"    @abstractmethod\n"
"    def my_abstract_staticmethod(arg3):\n"
"        ...\n"
"\n"
"    @property\n"
"    @abstractmethod\n"
"    def my_abstract_property(self):\n"
"        ...\n"
"    @my_abstract_property.setter\n"
"    @abstractmethod\n"
"    def my_abstract_property(self, val):\n"
"        ...\n"
"\n"
"    @abstractmethod\n"
"    def _get_x(self):\n"
"        ...\n"
"    @abstractmethod\n"
"    def _set_x(self, val):\n"
"        ...\n"
"    x = property(_get_x, _set_x)"
msgstr ""
"klass C(ABC):\n"
"    @abstraktmetod\n"
"    def my_abstract_method(self, arg1):\n"
"        ...\n"
"    @klassmetod\n"
"    @abstraktmetod\n"
"    def my_abstract_classmethod(cls, arg2):\n"
"        ...\n"
"    @statiskmetod\n"
"    @abstraktmetod\n"
"    def my_abstract_staticmethod(arg3):\n"
"        ...\n"
"\n"
"    @egenskap\n"
"    @abstraktmetod\n"
"    def my_abstract_property(self):\n"
"        ...\n"
"    @my_abstract_property.setter\n"
"    @abstraktmetod\n"
"    def my_abstract_property(self, val):\n"
"        ...\n"
"\n"
"    @abstraktmetod\n"
"    def _get_x(self):\n"
"        ...\n"
"    @abstraktmetod\n"
"    def _set_x(self, val):\n"
"        ...\n"
"    x = property(_get_x, _set_x)"

msgid ""
"In order to correctly interoperate with the abstract base class machinery, "
"the descriptor must identify itself as abstract using :attr:`!"
"__isabstractmethod__`. In general, this attribute should be ``True`` if any "
"of the methods used to compose the descriptor are abstract. For example, "
"Python's built-in :class:`property` does the equivalent of::"
msgstr ""
"För att korrekt kunna samverka med den abstrakta basklassens maskineri måste "
"deskriptorn identifiera sig själv som abstrakt med hjälp av :attr:`!"
"__isabstractmethod__`. I allmänhet bör detta attribut vara ``True`` om någon "
"av de metoder som används för att komponera deskriptorn är abstrakt. Till "
"exempel gör Pythons inbyggda :class:`property` motsvarande::"

msgid ""
"class Descriptor:\n"
"    ...\n"
"    @property\n"
"    def __isabstractmethod__(self):\n"
"        return any(getattr(f, '__isabstractmethod__', False) for\n"
"                   f in (self._fget, self._fset, self._fdel))"
msgstr ""
"klassen Descriptor:\n"
"    ...\n"
"    @egenskap\n"
"    def __isabstractmethod__(self):\n"
"        return any(getattr(f, '__isabstractmethod__', False) for\n"
"                   f in (self._fget, self._fset, self._fdel))"

msgid ""
"Unlike Java abstract methods, these abstract methods may have an "
"implementation. This implementation can be called via the :func:`super` "
"mechanism from the class that overrides it.  This could be useful as an end-"
"point for a super-call in a framework that uses cooperative multiple-"
"inheritance."
msgstr ""
"Till skillnad från Javas abstrakta metoder kan dessa abstrakta metoder ha en "
"implementation. Denna implementation kan anropas via :func:`super`-"
"mekanismen från den klass som åsidosätter den.  Detta kan vara användbart "
"som en slutpunkt för ett superanrop i ett ramverk som använder kooperativ "
"multipel nedärvning."

msgid "The :mod:`!abc` module also supports the following legacy decorators:"
msgstr "Modulen :mod:`!abc` har även stöd för följande äldre dekoratorer:"

msgid ""
"It is now possible to use :class:`classmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Det är nu möjligt att använda :class:`classmethod` med :func:"
"`abstractmethod`, vilket gör denna dekorator överflödig."

msgid ""
"A subclass of the built-in :func:`classmethod`, indicating an abstract "
"classmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"En subklass av den inbyggda :func:`classmethod`, vilket indikerar en "
"abstrakt klassmetod. Annars liknar den :func:`abstractmethod`."

msgid ""
"This special case is deprecated, as the :func:`classmethod` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Detta specialfall är inte längre aktuellt, eftersom :func:`classmethod`-"
"dekoratorn nu identifieras korrekt som abstrakt när den tillämpas på en "
"abstrakt metod::"

msgid ""
"class C(ABC):\n"
"    @classmethod\n"
"    @abstractmethod\n"
"    def my_abstract_classmethod(cls, arg):\n"
"        ..."
msgstr ""
"klass C(ABC):\n"
"    @klassmetod\n"
"    @abstraktmetod\n"
"    def my_abstract_classmethod(cls, arg):\n"
"        ..."

msgid ""
"It is now possible to use :class:`staticmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Det är nu möjligt att använda :class:`staticmethod` med :func:"
"`abstractmethod`, vilket gör denna dekorator överflödig."

msgid ""
"A subclass of the built-in :func:`staticmethod`, indicating an abstract "
"staticmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"En subklass av den inbyggda :func:`staticmethod`, vilket indikerar en "
"abstrakt staticmethod. Annars liknar den :func:`abstractmethod`."

msgid ""
"This special case is deprecated, as the :func:`staticmethod` decorator is "
"now correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Detta specialfall är inte längre aktuellt, eftersom :func:`staticmethod`-"
"dekoratorn nu identifieras korrekt som abstrakt när den tillämpas på en "
"abstrakt metod::"

msgid ""
"class C(ABC):\n"
"    @staticmethod\n"
"    @abstractmethod\n"
"    def my_abstract_staticmethod(arg):\n"
"        ..."
msgstr ""
"klass C(ABC):\n"
"    @statiskmetod\n"
"    @abstraktmetod\n"
"    def my_abstract_staticmethod(arg):\n"
"        ..."

msgid ""
"It is now possible to use :class:`property`, :meth:`property.getter`, :meth:"
"`property.setter` and :meth:`property.deleter` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Det är nu möjligt att använda :class:`property`, :meth:`property.getter`, :"
"meth:`property.setter` och :meth:`property.deleter` med :func:"
"`abstractmethod`, vilket gör denna dekorator överflödig."

msgid ""
"A subclass of the built-in :func:`property`, indicating an abstract property."
msgstr ""
"En subklass av den inbyggda :func:`property`, som anger en abstrakt egenskap."

msgid ""
"This special case is deprecated, as the :func:`property` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Detta specialfall är inte längre aktuellt, eftersom :func:`property`-"
"dekoratorn nu identifieras korrekt som abstrakt när den tillämpas på en "
"abstrakt metod::"

msgid ""
"class C(ABC):\n"
"    @property\n"
"    @abstractmethod\n"
"    def my_abstract_property(self):\n"
"        ..."
msgstr ""
"klass C(ABC):\n"
"    @egenskap\n"
"    @abstraktmetod\n"
"    def my_abstract_property(self):\n"
"        ..."

msgid ""
"The above example defines a read-only property; you can also define a read-"
"write abstract property by appropriately marking one or more of the "
"underlying methods as abstract::"
msgstr ""
"I exemplet ovan definieras en skrivskyddad egenskap; du kan också definiera "
"en abstrakt skrivskyddad egenskap genom att på lämpligt sätt markera en "
"eller flera av de underliggande metoderna som abstrakt::"

msgid ""
"class C(ABC):\n"
"    @property\n"
"    def x(self):\n"
"        ...\n"
"\n"
"    @x.setter\n"
"    @abstractmethod\n"
"    def x(self, val):\n"
"        ..."
msgstr ""
"klass C(ABC):\n"
"    @egenskap\n"
"    def x(self):\n"
"        ...\n"
"\n"
"    @x.setter\n"
"    @abstraktmetod\n"
"    def x(self, val):\n"
"        ..."

msgid ""
"If only some components are abstract, only those components need to be "
"updated to create a concrete property in a subclass::"
msgstr ""
"Om endast vissa komponenter är abstrakta, behöver endast dessa komponenter "
"uppdateras för att skapa en konkret egenskap i en underklass::"

msgid ""
"class D(C):\n"
"    @C.x.setter\n"
"    def x(self, val):\n"
"        ..."
msgstr ""
"klass D(C):\n"
"    @C.x.setter\n"
"    def x(self, val):\n"
"        ..."

msgid "The :mod:`!abc` module also provides the following functions:"
msgstr "Modulen :mod:`!abc` innehåller även följande funktioner:"

msgid "Returns the current abstract base class cache token."
msgstr "Returnerar den aktuella cachetoken för abstrakta basklasser."

msgid ""
"The token is an opaque object (that supports equality testing) identifying "
"the current version of the abstract base class cache for virtual subclasses. "
"The token changes with every call to :meth:`ABCMeta.register` on any ABC."
msgstr ""
"Token är ett opakt objekt (som stöder likhetstestning) som identifierar den "
"aktuella versionen av den abstrakta basklassens cache för virtuella "
"underklasser. Token ändras med varje anrop till :meth:`ABCMeta.register` på "
"valfri ABC."

msgid ""
"A function to recalculate an abstract class's abstraction status. This "
"function should be called if a class's abstract methods have been "
"implemented or changed after it was created. Usually, this function should "
"be called from within a class decorator."
msgstr ""
"En funktion för att räkna om en abstrakt klass abstraktionsstatus. Denna "
"funktion bör anropas om en klass abstrakta metoder har implementerats eller "
"ändrats efter att den skapades. Vanligtvis bör denna funktion anropas "
"inifrån en klassdekorator."

msgid "Returns *cls*, to allow usage as a class decorator."
msgstr "Returnerar *cls*, så att den kan användas som en klassdekorator."

msgid "If *cls* is not an instance of :class:`ABCMeta`, does nothing."
msgstr "Om *cls* inte är en instans av :class:`ABCMeta`, gör ingenting."

msgid ""
"This function assumes that *cls*'s superclasses are already updated. It does "
"not update any subclasses."
msgstr ""
"Denna funktion förutsätter att *cls*s superklasser redan är uppdaterade. Den "
"uppdaterar inte några underklasser."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"C++ programmers should note that Python's virtual base class concept is not "
"the same as C++'s."
msgstr ""
"C++-programmerare bör notera att Pythons koncept med virtuella basklasser "
"inte är detsamma som C++:s."
