# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!pathlib` --- Object-oriented filesystem paths"
msgstr ":mod:`!pathlib` --- Objektorienterade sökvägar i filsystemet"

msgid "**Source code:** :source:`Lib/pathlib/`"
msgstr "**Källkod:** :källa:`Lib/pathlib/`"

msgid ""
"This module offers classes representing filesystem paths with semantics "
"appropriate for different operating systems.  Path classes are divided "
"between :ref:`pure paths <pure-paths>`, which provide purely computational "
"operations without I/O, and :ref:`concrete paths <concrete-paths>`, which "
"inherit from pure paths but also provide I/O operations."
msgstr ""
"Den här modulen erbjuder klasser som representerar sökvägar i filsystemet "
"med semantik som passar olika operativsystem.  Sökvägsklasserna är uppdelade "
"i :ref:``pure paths <pure-paths>``, som tillhandahåller rena "
"beräkningsoperationer utan I/O, och :ref:``concrete paths <concrete-"
"paths>``, som ärver från rena sökvägar men även tillhandahåller I/O-"
"operationer."

msgid ""
"Inheritance diagram showing the classes available in pathlib. The\n"
"most basic class is PurePath, which has three direct subclasses:\n"
"PurePosixPath, PureWindowsPath, and Path. Further to these four\n"
"classes, there are two classes that use multiple inheritance:\n"
"PosixPath subclasses PurePosixPath and Path, and WindowsPath\n"
"subclasses PureWindowsPath and Path."
msgstr ""
"Arvsdiagram som visar de klasser som finns i pathlib. Den\n"
"mest grundläggande klassen är PurePath, som har tre direkta underklasser:\n"
"PurePosixPath, PureWindowsPath och Path. Utöver dessa fyra\n"
"klasserna finns det två klasser som använder multipel arv:\n"
"PosixPath underklassar PurePosixPath och Path, och WindowsPath\n"
"underklasserna PureWindowsPath och Path."

msgid ""
"If you've never used this module before or just aren't sure which class is "
"right for your task, :class:`Path` is most likely what you need. It "
"instantiates a :ref:`concrete path <concrete-paths>` for the platform the "
"code is running on."
msgstr ""
"Om du aldrig har använt den här modulen tidigare eller bara är osäker på "
"vilken klass som är rätt för din uppgift, är :class:`Path` troligen vad du "
"behöver. Den instansierar en :ref:``concrete path <concrete-paths>`` för den "
"plattform som koden körs på."

msgid "Pure paths are useful in some special cases; for example:"
msgstr "Rena vägar är användbara i vissa specialfall, t.ex:"

msgid ""
"If you want to manipulate Windows paths on a Unix machine (or vice versa). "
"You cannot instantiate a :class:`WindowsPath` when running on Unix, but you "
"can instantiate :class:`PureWindowsPath`."
msgstr ""
"Om du vill manipulera Windows-sökvägar på en Unix-maskin (eller vice versa). "
"Du kan inte instansiera en :class:`WindowsPath` när du kör på Unix, men du "
"kan instansiera :class:`PureWindowsPath`."

msgid ""
"You want to make sure that your code only manipulates paths without actually "
"accessing the OS. In this case, instantiating one of the pure classes may be "
"useful since those simply don't have any OS-accessing operations."
msgstr ""
"Du vill se till att din kod bara manipulerar sökvägar utan att faktiskt "
"komma åt operativsystemet. I det här fallet kan det vara användbart att "
"instansiera en av de rena klasserna eftersom de helt enkelt inte har några "
"OS-åtkomstoperationer."

msgid ":pep:`428`: The pathlib module -- object-oriented filesystem paths."
msgstr ""
":pep:`428`: Pathlib-modulen -- objektorienterade sökvägar i filsystemet."

msgid ""
"For low-level path manipulation on strings, you can also use the :mod:`os."
"path` module."
msgstr ""
"För lågnivåhantering av sökvägar för strängar kan du också använda modulen :"
"mod:`os.path`."

msgid "Basic use"
msgstr "Grundläggande användning"

msgid "Importing the main class::"
msgstr "Importera huvudklassen::"

msgid ">>> from pathlib import Path"
msgstr ">>> från pathlib import Path"

msgid "Listing subdirectories::"
msgstr "Listning av underkataloger::"

msgid ""
">>> p = Path('.')\n"
">>> [x for x in p.iterdir() if x.is_dir()]\n"
"[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),\n"
" PosixPath('__pycache__'), PosixPath('build')]"
msgstr ""
">>> p = Sökväg('.')\n"
">>> [x for x in p.iterdir() if x.is_dir()]\n"
"[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),\n"
" PosixPath('__pycache__'), PosixPath('build')]"

msgid "Listing Python source files in this directory tree::"
msgstr "Listar Python-källfiler i detta katalogträd::"

msgid ""
">>> list(p.glob('**/*.py'))\n"
"[PosixPath('test_pathlib.py'), PosixPath('setup.py'),\n"
" PosixPath('pathlib.py'), PosixPath('docs/conf.py'),\n"
" PosixPath('build/lib/pathlib.py')]"
msgstr ""
">>> list(p.glob('**/*.py'))\n"
"[PosixPath('test_pathlib.py'), PosixPath('setup.py'),\n"
" PosixPath('pathlib.py'), PosixPath('docs/conf.py'),\n"
" PosixPath('build/lib/pathlib.py')]"

msgid "Navigating inside a directory tree::"
msgstr "Navigera inuti ett katalogträd::"

msgid ""
">>> p = Path('/etc')\n"
">>> q = p / 'init.d' / 'reboot'\n"
">>> q\n"
"PosixPath('/etc/init.d/reboot')\n"
">>> q.resolve()\n"
"PosixPath('/etc/rc.d/init.d/halt')"
msgstr ""
">>> p = Sökväg('/etc')\n"
">>> q = p / 'init.d' / 'omstart'\n"
">>> q\n"
"PosixPath('/etc/init.d/reboot')\n"
">>> q.resolve()\n"
"PosixPath('/etc/rc.d/init.d/halt')"

msgid "Querying path properties::"
msgstr "Fråga om egenskaper för sökvägen::"

msgid ""
">>> q.exists()\n"
"True\n"
">>> q.is_dir()\n"
"False"
msgstr ""
">>> q.existerar()\n"
"Sant\n"
">>> q.is_dir()\n"
"False"

msgid "Opening a file::"
msgstr "Öppna en fil::"

msgid ""
">>> with q.open() as f: f.readline()\n"
"...\n"
"'#!/bin/bash\\n'"
msgstr ""
">>> med q.open() som f: f.readline()\n"
"...\n"
"'#!/bin/bash\\n'"

msgid "Exceptions"
msgstr "Undantag"

msgid ""
"An exception inheriting :exc:`NotImplementedError` that is raised when an "
"unsupported operation is called on a path object."
msgstr ""
"Ett undantag som ärver :exc:`NotImplementedError` och som uppstår när en "
"åtgärd som inte stöds anropas på ett sökvägsobjekt."

msgid "Pure paths"
msgstr "Rena vägar"

msgid ""
"Pure path objects provide path-handling operations which don't actually "
"access a filesystem.  There are three ways to access these classes, which we "
"also call *flavours*:"
msgstr ""
"Rena sökvägsobjekt tillhandahåller sökvägshanteringsoperationer som faktiskt "
"inte har åtkomst till ett filsystem.  Det finns tre sätt att komma åt dessa "
"klasser, som vi också kallar *flavours*:"

msgid ""
"A generic class that represents the system's path flavour (instantiating it "
"creates either a :class:`PurePosixPath` or a :class:`PureWindowsPath`)::"
msgstr ""
"En generisk klass som representerar systemets sökvägssmak (instansiering av "
"den skapar antingen en :class:`PurePosixPath` eller en :class:"
"`PureWindowsPath`)::"

msgid ""
">>> PurePath('setup.py')      # Running on a Unix machine\n"
"PurePosixPath('setup.py')"
msgstr ""
">>> PurePath('setup.py') # Körs på en Unix-maskin\n"
"PurePosixPath('setup.py')"

msgid ""
"Each element of *pathsegments* can be either a string representing a path "
"segment, or an object implementing the :class:`os.PathLike` interface where "
"the :meth:`~os.PathLike.__fspath__` method returns a string, such as another "
"path object::"
msgstr ""
"Varje element i *pathsegments* kan vara antingen en sträng som representerar "
"ett vägsegment eller ett objekt som implementerar :class:`os.PathLike`-"
"gränssnittet där :meth:`~os.PathLike.__fspath__`-metoden returnerar en "
"sträng, t.ex. ett annat vägobjekt::"

msgid ""
">>> PurePath('foo', 'some/path', 'bar')\n"
"PurePosixPath('foo/some/path/bar')\n"
">>> PurePath(Path('foo'), Path('bar'))\n"
"PurePosixPath('foo/bar')"
msgstr ""
">>> PurePath('foo', 'some/path', 'bar')\n"
"PurePosixPath('foo/some/path/bar')\n"
">>> PurePath(Sökväg('foo'), Sökväg('bar'))\n"
"PurePosixSökväg('foo/bar')"

msgid "When *pathsegments* is empty, the current directory is assumed::"
msgstr "När *pathsegments* är tomt antas den aktuella katalogen::"

msgid ""
">>> PurePath()\n"
"PurePosixPath('.')"
msgstr ""
">>> PurePath()\n"
"PurePosixSökväg('.')"

msgid ""
"If a segment is an absolute path, all previous segments are ignored (like :"
"func:`os.path.join`)::"
msgstr ""
"Om ett segment är en absolut sökväg ignoreras alla tidigare segment (som :"
"func:`os.path.join`)::"

msgid ""
">>> PurePath('/etc', '/usr', 'lib64')\n"
"PurePosixPath('/usr/lib64')\n"
">>> PureWindowsPath('c:/Windows', 'd:bar')\n"
"PureWindowsPath('d:bar')"
msgstr ""
">>> PurePath('/etc', '/usr', 'lib64')\n"
"PurePosixPath('/usr/lib64')\n"
">>> PureWindowsPath('c:/Windows', 'd:bar')\n"
"PureWindowsSökväg('d:bar')"

msgid ""
"On Windows, the drive is not reset when a rooted relative path segment (e."
"g., ``r'\\foo'``) is encountered::"
msgstr ""
"I Windows återställs inte enheten när ett rotat relativt sökvägssegment (t."
"ex. ``r'\\foo'``) påträffas::"

msgid ""
">>> PureWindowsPath('c:/Windows', '/Program Files')\n"
"PureWindowsPath('c:/Program Files')"
msgstr ""
">>> PureWindowsPath('c:/Windows', '/Program Files')\n"
"PureWindowsPath('c:/Programfiler')"

msgid ""
"Spurious slashes and single dots are collapsed, but double dots (``'..'``) "
"and leading double slashes (``'//'``) are not, since this would change the "
"meaning of a path for various reasons (e.g. symbolic links, UNC paths)::"
msgstr ""
"Felaktiga snedstreck och enkla prickar kollapsar, men inte dubbla prickar "
"(``'..'``) och inledande dubbla snedstreck (``'//'``), eftersom detta av "
"olika skäl (t.ex. symboliska länkar, UNC-sökvägar) skulle ändra sökvägens "
"betydelse::"

msgid ""
">>> PurePath('foo//bar')\n"
"PurePosixPath('foo/bar')\n"
">>> PurePath('//foo/bar')\n"
"PurePosixPath('//foo/bar')\n"
">>> PurePath('foo/./bar')\n"
"PurePosixPath('foo/bar')\n"
">>> PurePath('foo/../bar')\n"
"PurePosixPath('foo/../bar')"
msgstr ""
">>> PurePath('foo//bar')\n"
"PurePosixPath('foo/bar')\n"
">>> PurePath('//foo/bar')\n"
"PurePosixSökväg('//foo/bar')\n"
">>> PurePath('foo/./bar')\n"
"PurePosixSökväg('foo/bar')\n"
">>> PurePath('foo/../bar')\n"
"PurePosixPath('foo/../bar')"

msgid ""
"(a naïve approach would make ``PurePosixPath('foo/../bar')`` equivalent to "
"``PurePosixPath('bar')``, which is wrong if ``foo`` is a symbolic link to "
"another directory)"
msgstr ""
"(ett naivt tillvägagångssätt skulle göra ``PurePosixPath('foo/../bar')`` "
"likvärdig med ``PurePosixPath('bar')``, vilket är fel om ``foo`` är en "
"symbolisk länk till en annan katalog)"

msgid ""
"Pure path objects implement the :class:`os.PathLike` interface, allowing "
"them to be used anywhere the interface is accepted."
msgstr ""
"Rena sökvägsobjekt implementerar gränssnittet :class:`os.PathLike`, vilket "
"gör att de kan användas överallt där gränssnittet accepteras."

msgid "Added support for the :class:`os.PathLike` interface."
msgstr "Lagt till stöd för gränssnittet :class:`os.PathLike`."

msgid ""
"A subclass of :class:`PurePath`, this path flavour represents non-Windows "
"filesystem paths::"
msgstr ""
"Denna sökvägssmak är en underklass till :class:`PurePath` och representerar "
"sökvägar som inte är Windows-filsystem::"

msgid ""
">>> PurePosixPath('/etc/hosts')\n"
"PurePosixPath('/etc/hosts')"
msgstr ""
">>> PurePosixPath('/etc/hosts')\n"
"PurePosixPath('/etc/hosts')"

msgid "*pathsegments* is specified similarly to :class:`PurePath`."
msgstr "*pathsegments* specificeras på liknande sätt som :class:`PurePath`."

msgid ""
"A subclass of :class:`PurePath`, this path flavour represents Windows "
"filesystem paths, including `UNC paths`_::"
msgstr ""
"Denna sökvägssmak är en underklass till :class:`PurePath` och representerar "
"sökvägar i Windows filsystem, inklusive `UNC-sökvägar`_::"

msgid ""
">>> PureWindowsPath('c:/', 'Users', 'Ximénez')\n"
"PureWindowsPath('c:/Users/Ximénez')\n"
">>> PureWindowsPath('//server/share/file')\n"
"PureWindowsPath('//server/share/file')"
msgstr ""
">>> PureWindowsPath('c:/', 'Användare', 'Ximénez')\n"
"PureWindowsPath('c:/Användare/Ximénez')\n"
">>> PureWindowsPath('//server/share/file')\n"
"PureWindowsPath('//server/share/file')"

msgid ""
"Regardless of the system you're running on, you can instantiate all of these "
"classes, since they don't provide any operation that does system calls."
msgstr ""
"Oavsett vilket system du kör på kan du instansiera alla dessa klasser, "
"eftersom de inte tillhandahåller någon operation som gör systemanrop."

msgid "General properties"
msgstr "Allmänna egenskaper"

msgid ""
"Paths are immutable and :term:`hashable`.  Paths of a same flavour are "
"comparable and orderable.  These properties respect the flavour's case-"
"folding semantics::"
msgstr ""
"Sökvägar är oföränderliga och :term:`hashable`.  Sökvägar av samma smak är "
"jämförbara och ordningsbara.  Dessa egenskaper respekterar smakens semantik "
"för case-folding::"

msgid ""
">>> PurePosixPath('foo') == PurePosixPath('FOO')\n"
"False\n"
">>> PureWindowsPath('foo') == PureWindowsPath('FOO')\n"
"True\n"
">>> PureWindowsPath('FOO') in { PureWindowsPath('foo') }\n"
"True\n"
">>> PureWindowsPath('C:') < PureWindowsPath('d:')\n"
"True"
msgstr ""
">>> PurePosixPath('foo') == PurePosixPath('FOO')\n"
"Falsk\n"
">>> PureWindowsPath('foo') == PureWindowsPath('FOO')\n"
"Sant\n"
">>> PureWindowsPath('FOO') i { PureWindowsPath('foo') }\n"
"Sant\n"
">>> PureWindowsPath('C:') < PureWindowsPath('d:')\n"
"Sant"

msgid "Paths of a different flavour compare unequal and cannot be ordered::"
msgstr "Banor med olika smak jämför ojämlikt och kan inte beställas::"

msgid ""
">>> PureWindowsPath('foo') == PurePosixPath('foo')\n"
"False\n"
">>> PureWindowsPath('foo') < PurePosixPath('foo')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'PureWindowsPath' and "
"'PurePosixPath'"
msgstr ""
"&gt;&gt;&gt; PureWindowsPath('foo') == PurePosixPath('foo')\n"
"Falskt\n"
"&gt;&gt;&gt; PureWindowsPath('foo') &lt; PurePosixPath('foo')\n"
"Återkoppling (senaste anropet senast):\n"
"  Fil \"&lt;stdin&gt;\", rad 1, i <module>\n"
"TypeError: '&lt;' stöds inte mellan instanser av 'PureWindowsPath' och "
"'PurePosixPath'"

msgid "Operators"
msgstr "Operatorer"

msgid ""
"The slash operator helps create child paths, like :func:`os.path.join`. If "
"the argument is an absolute path, the previous path is ignored. On Windows, "
"the drive is not reset when the argument is a rooted relative path (e.g., "
"``r'\\foo'``)::"
msgstr ""
"Slash-operatorn hjälper till att skapa underordnade sökvägar, som :func:`os."
"path.join`. Om argumentet är en absolut sökväg ignoreras den föregående "
"sökvägen. I Windows återställs inte enheten när argumentet är en rotad "
"relativ sökväg (t.ex. ``r'\\foo'``)::"

msgid ""
">>> p = PurePath('/etc')\n"
">>> p\n"
"PurePosixPath('/etc')\n"
">>> p / 'init.d' / 'apache2'\n"
"PurePosixPath('/etc/init.d/apache2')\n"
">>> q = PurePath('bin')\n"
">>> '/usr' / q\n"
"PurePosixPath('/usr/bin')\n"
">>> p / '/an_absolute_path'\n"
"PurePosixPath('/an_absolute_path')\n"
">>> PureWindowsPath('c:/Windows', '/Program Files')\n"
"PureWindowsPath('c:/Program Files')"
msgstr ""
">>> p = PurePath('/etc')\n"
">>> p\n"
"PurePosixPath('/etc')\n"
">>> p / 'init.d' / 'apache2'\n"
"PurePosixPath('/etc/init.d/apache2')\n"
">>> q = PurePath('bin')\n"
">>> '/usr' / q\n"
"PurePosixSökväg('/usr/bin')\n"
">>> p / '/an_absolute_path'\n"
"PurePosixSökväg('/an_absolute_path')\n"
">>> PureWindowsPath('c:/Windows', '/Programfiler')\n"
"PureWindowsPath('c:/Programfiler')"

msgid ""
"A path object can be used anywhere an object implementing :class:`os."
"PathLike` is accepted::"
msgstr ""
"Ett sökvägsobjekt kan användas var som helst där ett objekt som "
"implementerar :class:`os.PathLike` accepteras::"

msgid ""
">>> import os\n"
">>> p = PurePath('/etc')\n"
">>> os.fspath(p)\n"
"'/etc'"
msgstr ""
">>> import os\n"
">>> p = PurePath('/etc')\n"
">>> os.fspath(p)\n"
"'/etc'"

msgid ""
"The string representation of a path is the raw filesystem path itself (in "
"native form, e.g. with backslashes under Windows), which you can pass to any "
"function taking a file path as a string::"
msgstr ""
"Strängrepresentationen av en sökväg är själva den råa filsystemssökvägen (i "
"ursprunglig form, t.ex. med bindestreck under Windows), som du kan skicka "
"till alla funktioner som tar emot en filväg som en sträng::"

msgid ""
">>> p = PurePath('/etc')\n"
">>> str(p)\n"
"'/etc'\n"
">>> p = PureWindowsPath('c:/Program Files')\n"
">>> str(p)\n"
"'c:\\\\Program Files'"
msgstr ""
">>> p = PurePath('/etc')\n"
">>> str(p)\n"
"'/etc'\n"
">>> p = PureWindowsPath('c:/Programfiler')\n"
">>> str(p)\n"
"'c:\\\\Programfiler'"

msgid ""
"Similarly, calling :class:`bytes` on a path gives the raw filesystem path as "
"a bytes object, as encoded by :func:`os.fsencode`::"
msgstr ""
"På samma sätt ger anrop av :class:`bytes` på en sökväg den råa "
"filsystemssökvägen som ett bytesobjekt, kodat med :func:`os.fsencode`::"

msgid ""
">>> bytes(p)\n"
"b'/etc'"
msgstr ""
">>> bytes(p)\n"
"b'/etc'"

msgid ""
"Calling :class:`bytes` is only recommended under Unix.  Under Windows, the "
"unicode form is the canonical representation of filesystem paths."
msgstr ""
"Att anropa :class:`bytes` är endast rekommenderat under Unix.  Under Windows "
"är unicode-formen den kanoniska representationen av sökvägar i filsystemet."

msgid "Accessing individual parts"
msgstr "Åtkomst till enskilda delar"

msgid ""
"To access the individual \"parts\" (components) of a path, use the following "
"property:"
msgstr ""
"För att komma åt de enskilda \"delarna\" (komponenterna) i en sökväg "
"använder du följande egenskap:"

msgid "A tuple giving access to the path's various components::"
msgstr "En tupel som ger tillgång till sökvägens olika komponenter::"

msgid ""
">>> p = PurePath('/usr/bin/python3')\n"
">>> p.parts\n"
"('/', 'usr', 'bin', 'python3')\n"
"\n"
">>> p = PureWindowsPath('c:/Program Files/PSF')\n"
">>> p.parts\n"
"('c:\\\\', 'Program Files', 'PSF')"
msgstr ""
">>> p = PurePath('/usr/bin/python3')\n"
">>> p.delar\n"
"('/', 'usr', 'bin', 'python3')\n"
"\n"
">>> p = PureWindowsPath('c:/Programfiler/PSF')\n"
">>> p.delar\n"
"('c:\\\\', 'Program Files', 'PSF')"

msgid "(note how the drive and local root are regrouped in a single part)"
msgstr ""
"(notera hur enheten och den lokala roten är omgrupperade i en enda del)"

msgid "Methods and properties"
msgstr "Metoder och egenskaper"

msgid "Pure paths provide the following methods and properties:"
msgstr "Pure paths tillhandahåller följande metoder och egenskaper:"

msgid ""
"The implementation of the :mod:`os.path` module used for low-level path "
"parsing and joining: either :mod:`posixpath` or :mod:`ntpath`."
msgstr ""
"Implementeringen av modulen :mod:`os.path` som används för lågnivåanalys och "
"sammanfogning av sökvägar: antingen :mod:`posixpath` eller :mod:`ntpath`."

msgid "A string representing the drive letter or name, if any::"
msgstr ""
"En sträng som representerar enhetens bokstav eller namn, om sådan finns::"

msgid ""
">>> PureWindowsPath('c:/Program Files/').drive\n"
"'c:'\n"
">>> PureWindowsPath('/Program Files/').drive\n"
"''\n"
">>> PurePosixPath('/etc').drive\n"
"''"
msgstr ""
">>> PureWindowsPath('c:/Program Files/').drive\n"
"'c:'\n"
">>> PureWindowsPath('/Program Files/').drive\n"
"''\n"
">>> PurePosixPath('/etc').drive\n"
"''"

msgid "UNC shares are also considered drives::"
msgstr "UNC-delar betraktas också som enheter::"

msgid ""
">>> PureWindowsPath('//host/share/foo.txt').drive\n"
"'\\\\\\\\host\\\\share'"
msgstr ""
">>> PureWindowsPath('//host/share/foo.txt').drive\n"
"'\\\\\\\\host\\\\share'"

msgid "A string representing the (local or global) root, if any::"
msgstr ""
"En sträng som representerar den (lokala eller globala) roten, om någon::"

msgid ""
">>> PureWindowsPath('c:/Program Files/').root\n"
"'\\\\'\n"
">>> PureWindowsPath('c:Program Files/').root\n"
"''\n"
">>> PurePosixPath('/etc').root\n"
"'/'"
msgstr ""
">>> PureWindowsPath('c:/Program Files/').root\n"
"'\\\\'\n"
">>> PureWindowsPath('c:Program Files/').root\n"
"''\n"
">>> PurePosixPath('/etc').root\n"
"'/'"

msgid "UNC shares always have a root::"
msgstr "UNC-aktier har alltid en root::"

msgid ""
">>> PureWindowsPath('//host/share').root\n"
"'\\\\'"
msgstr ""
">>> PureWindowsPath('//host/share').root\n"
"'\\\\'"

msgid ""
"If the path starts with more than two successive slashes, :class:`~pathlib."
"PurePosixPath` collapses them::"
msgstr ""
"Om sökvägen börjar med mer än två på varandra följande snedstreck, :class:"
"`~pathlib.PurePosixPath` kollapsar dem::"

msgid ""
">>> PurePosixPath('//etc').root\n"
"'//'\n"
">>> PurePosixPath('///etc').root\n"
"'/'\n"
">>> PurePosixPath('////etc').root\n"
"'/'"
msgstr ""
">>> PurePosixPath('//etc').root\n"
"'//'\n"
">>> PurePosixPath('///etc').root\n"
"'/'\n"
">>> PurePosixPath('////etc').root\n"
"'/'"

msgid ""
"This behavior conforms to *The Open Group Base Specifications Issue 6*, "
"paragraph `4.11 Pathname Resolution <https://pubs.opengroup.org/"
"onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11>`_:"
msgstr ""
"Detta beteende överensstämmer med *The Open Group Base Specifications Issue "
"6*, paragraf `4.11 Pathname Resolution <https://pubs.opengroup.org/"
"onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11>`_:"

msgid ""
"*\"A pathname that begins with two successive slashes may be interpreted in "
"an implementation-defined manner, although more than two leading slashes "
"shall be treated as a single slash.\"*"
msgstr ""
"*\"Ett sökvägsnamn som börjar med två på varandra följande snedstreck kan "
"tolkas på ett sätt som definieras av implementationen, även om mer än två "
"inledande snedstreck ska behandlas som ett enda snedstreck.\"*"

msgid "The concatenation of the drive and root::"
msgstr "Sammankopplingen av enheten och roten::"

msgid ""
">>> PureWindowsPath('c:/Program Files/').anchor\n"
"'c:\\\\'\n"
">>> PureWindowsPath('c:Program Files/').anchor\n"
"'c:'\n"
">>> PurePosixPath('/etc').anchor\n"
"'/'\n"
">>> PureWindowsPath('//host/share').anchor\n"
"'\\\\\\\\host\\\\share\\\\'"
msgstr ""
">>> PureWindowsPath('c:/Program Files/').anchor\n"
"'c:\\\\'\n"
">>> PureWindowsPath('c:Program Files/').anchor\n"
"'c:'\n"
">>> PurePosixPath('/etc').ankare\n"
"'/'\n"
">>> PureWindowsPath('//host/share').anchor\n"
"'\\\\\\\\host\\\\share\\\\'"

msgid ""
"An immutable sequence providing access to the logical ancestors of the path::"
msgstr ""
"En oföränderlig sekvens som ger tillgång till logiska förfäder till "
"sökvägen::"

msgid ""
">>> p = PureWindowsPath('c:/foo/bar/setup.py')\n"
">>> p.parents[0]\n"
"PureWindowsPath('c:/foo/bar')\n"
">>> p.parents[1]\n"
"PureWindowsPath('c:/foo')\n"
">>> p.parents[2]\n"
"PureWindowsPath('c:/')"
msgstr ""
">>> p = PureWindowsPath('c:/foo/bar/setup.py')\n"
">>> p.föräldrar[0]\n"
"PureWindowsPath('c:/foo/bar')\n"
">>> p.föräldrar[1]\n"
"PureWindowsPath('c:/foo')\n"
">>> p.föräldrar[2]\n"
"PureWindowsPath('c:/')"

msgid ""
"The parents sequence now supports :term:`slices <slice>` and negative index "
"values."
msgstr ""
"Parent-sekvensen stöder nu :term:`slices <slice>` och negativa indexvärden."

msgid "The logical parent of the path::"
msgstr "Den logiska föräldern till sökvägen::"

msgid ""
">>> p = PurePosixPath('/a/b/c/d')\n"
">>> p.parent\n"
"PurePosixPath('/a/b/c')"
msgstr ""
">>> p = PurePosixPath('/a/b/c/d')\n"
">>> p.förälder\n"
"PurePosixSökväg('/a/b/c')"

msgid "You cannot go past an anchor, or empty path::"
msgstr "Du kan inte gå förbi ett ankare, eller en tom väg::"

msgid ""
">>> p = PurePosixPath('/')\n"
">>> p.parent\n"
"PurePosixPath('/')\n"
">>> p = PurePosixPath('.')\n"
">>> p.parent\n"
"PurePosixPath('.')"
msgstr ""
">>> p = PurePosixPath('/')\n"
">>> p.förälder\n"
"PurePosixSökväg('/')\n"
">>> p = PurePosixPath('.')\n"
">>> p.förälder\n"
"PurePosixPath('.')"

msgid "This is a purely lexical operation, hence the following behaviour::"
msgstr "Detta är en rent lexikal operation, därav följande beteende::"

msgid ""
">>> p = PurePosixPath('foo/..')\n"
">>> p.parent\n"
"PurePosixPath('foo')"
msgstr ""
">>> p = PurePosixPath('foo/...')\n"
">>> p.förälder\n"
"PurePosixSökväg('foo')"

msgid ""
"If you want to walk an arbitrary filesystem path upwards, it is recommended "
"to first call :meth:`Path.resolve` so as to resolve symlinks and eliminate "
"``\"..\"`` components."
msgstr ""
"Om du vill gå en godtycklig filsystemssökväg uppåt rekommenderas att du "
"först anropar :meth:`Path.resolve` för att lösa upp symlänkar och eliminera "
"``\"...\"``-komponenter."

msgid ""
"A string representing the final path component, excluding the drive and "
"root, if any::"
msgstr ""
"En sträng som representerar den slutliga sökvägskomponenten, exklusive "
"enheten och roten, om sådana finns::"

msgid ""
">>> PurePosixPath('my/library/setup.py').name\n"
"'setup.py'"
msgstr ""
">>> PurePosixPath('my/library/setup.py').name\n"
"'setup.py'"

msgid "UNC drive names are not considered::"
msgstr "Namn på UNC-enheter räknas inte som::"

msgid ""
">>> PureWindowsPath('//some/share/setup.py').name\n"
"'setup.py'\n"
">>> PureWindowsPath('//some/share').name\n"
"''"
msgstr ""
">>> PureWindowsPath('//some/share/setup.py').name\n"
"'setup.py'\n"
">>> PureWindowsPath('//some/share').namn\n"
"''"

msgid "The last dot-separated portion of the final component, if any::"
msgstr ""
"Den sista punktseparerade delen av den slutliga komponenten, om sådan finns::"

msgid ""
">>> PurePosixPath('my/library/setup.py').suffix\n"
"'.py'\n"
">>> PurePosixPath('my/library.tar.gz').suffix\n"
"'.gz'\n"
">>> PurePosixPath('my/library').suffix\n"
"''"
msgstr ""
">>> PurePosixPath('my/library/setup.py').suffix\n"
"'.py'\n"
">>> PurePosixPath('my/library.tar.gz').suffix\n"
"'.gz'\n"
">>> PurePosixPath('mitt/bibliotek').suffix\n"
"''"

msgid "This is commonly called the file extension."
msgstr "Detta kallas vanligen filtillägget."

msgid "A single dot (\"``.``\") is considered a valid suffix."
msgstr "En enda punkt (\"``.``\") anses vara ett giltigt suffix."

msgid "A list of the path's suffixes, often called file extensions::"
msgstr "En lista över sökvägens suffix, ofta kallade filtillägg::"

msgid ""
">>> PurePosixPath('my/library.tar.gar').suffixes\n"
"['.tar', '.gar']\n"
">>> PurePosixPath('my/library.tar.gz').suffixes\n"
"['.tar', '.gz']\n"
">>> PurePosixPath('my/library').suffixes\n"
"[]"
msgstr ""
">>> PurePosixPath('my/library.tar.gar').suffixes\n"
"['.tar', '.gar']\n"
">>> PurePosixPath('my/library.tar.gz').suffix\n"
"['.tar', '.gz']\n"
">>> PurePosixPath('my/library').suffix\n"
"[]"

msgid "The final path component, without its suffix::"
msgstr "Den sista komponenten i sökvägen, utan suffixet::"

msgid ""
">>> PurePosixPath('my/library.tar.gz').stem\n"
"'library.tar'\n"
">>> PurePosixPath('my/library.tar').stem\n"
"'library'\n"
">>> PurePosixPath('my/library').stem\n"
"'library'"
msgstr ""
">>> PurePosixPath('my/library.tar.gz').stem\n"
"'bibliotek.tar'\n"
">>> PurePosixPath('mitt/bibliotek.tar').stem\n"
"'bibliotek'\n"
">>> PurePosixPath('mitt/bibliotek').stem\n"
"\"bibliotek"

msgid ""
"Return a string representation of the path with forward slashes (``/``)::"
msgstr ""
"Returnerar en strängrepresentation av sökvägen med snedstreck (``/``)::"

msgid ""
">>> p = PureWindowsPath('c:\\\\windows')\n"
">>> str(p)\n"
"'c:\\\\windows'\n"
">>> p.as_posix()\n"
"'c:/windows'"
msgstr ""
">>> p = PureWindowsPath('c:\\\\windows')\n"
">>> str(p)\n"
"'c:\\\\fönster'\n"
">>> p.as_posix()\n"
"'c:/fönster'"

msgid ""
"Return whether the path is absolute or not.  A path is considered absolute "
"if it has both a root and (if the flavour allows) a drive::"
msgstr ""
"Returnerar om sökvägen är absolut eller inte.  En sökväg anses vara absolut "
"om den har både en rot och (om smaken tillåter det) en drive::"

msgid ""
">>> PurePosixPath('/a/b').is_absolute()\n"
"True\n"
">>> PurePosixPath('a/b').is_absolute()\n"
"False\n"
"\n"
">>> PureWindowsPath('c:/a/b').is_absolute()\n"
"True\n"
">>> PureWindowsPath('/a/b').is_absolute()\n"
"False\n"
">>> PureWindowsPath('c:').is_absolute()\n"
"False\n"
">>> PureWindowsPath('//some/share').is_absolute()\n"
"True"
msgstr ""
">>> PurePosixPath('/a/b').is_absolute()\n"
"Sant\n"
">>> PurePosixPath('a/b').is_absolute()\n"
"Falsk\n"
"\n"
">>> PureWindowsPath('c:/a/b').is_absolute()\n"
"Sant\n"
">>> PureWindowsPath('/a/b').is_absolute()\n"
"Falsk\n"
">>> PureWindowsPath('c:').is_absolute()\n"
"Falsk\n"
">>> PureWindowsPath('//some/share').is_absolute()\n"
"True"

msgid "Return whether or not this path is relative to the *other* path."
msgstr ""
"Returnerar om den här sökvägen är relativ till den *andra* sökvägen eller "
"inte."

msgid ""
"This method is string-based; it neither accesses the filesystem nor treats "
"\"``..``\" segments specially. The following code is equivalent:"
msgstr ""
"Denna metod är strängbaserad; den har varken åtkomst till filsystemet eller "
"behandlar \"``..``\"-segment speciellt. Följande kod är likvärdig:"

msgid ""
"Passing additional arguments is deprecated; if supplied, they are joined "
"with *other*."
msgstr ""
"Att ange ytterligare argument är inte aktuellt; om de anges sammanfogas de "
"med *other*."

msgid ""
"With :class:`PureWindowsPath`, return ``True`` if the path is considered "
"reserved under Windows, ``False`` otherwise.  With :class:`PurePosixPath`, "
"``False`` is always returned."
msgstr ""
"Med :class:`PureWindowsPath` returneras ``True`` om sökvägen anses vara "
"reserverad under Windows, annars ``False``.  Med :class:`PurePosixPath` "
"returneras alltid ``False``."

msgid ""
"Windows path names that contain a colon, or end with a dot or a space, are "
"considered reserved. UNC paths may be reserved."
msgstr ""
"Windows-sökvägsnamn som innehåller ett kolon eller slutar med en punkt eller "
"ett mellanslag betraktas som reserverade. UNC-sökvägar kan vara reserverade."

msgid ""
"This method is deprecated; use :func:`os.path.isreserved` to detect reserved "
"paths on Windows."
msgstr ""
"Denna metod är föråldrad; använd :func:`os.path.isreserved` för att upptäcka "
"reserverade sökvägar i Windows."

msgid ""
"Calling this method is equivalent to combining the path with each of the "
"given *pathsegments* in turn::"
msgstr ""
"Att anropa denna metod motsvarar att kombinera sökvägen med vart och ett av "
"de angivna *sökvägssegmenten* i tur och ordning::"

msgid ""
">>> PurePosixPath('/etc').joinpath('passwd')\n"
"PurePosixPath('/etc/passwd')\n"
">>> PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))\n"
"PurePosixPath('/etc/passwd')\n"
">>> PurePosixPath('/etc').joinpath('init.d', 'apache2')\n"
"PurePosixPath('/etc/init.d/apache2')\n"
">>> PureWindowsPath('c:').joinpath('/Program Files')\n"
"PureWindowsPath('c:/Program Files')"
msgstr ""
">>> PurePosixPath('/etc').joinpath('passwd')\n"
"PurePosixPath('/etc/passwd')\n"
">>> PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))\n"
"PurePosixPath('/etc/passwd')\n"
">>> PurePosixPath('/etc').joinpath('init.d', 'apache2')\n"
"PurePosixPath('/etc/init.d/apache2')\n"
">>> PureWindowsPath('c:').joinpath('/Program Files')\n"
"PureWindowsPath('c:/Programfiler')"

msgid ""
"Match this path against the provided glob-style pattern.  Return ``True`` if "
"matching is successful, ``False`` otherwise.  For example::"
msgstr ""
"Matchar denna sökväg mot det angivna mönstret i glob-stil.  Returnerar "
"``True`` om matchningen lyckas, annars ``False``.  Till exempel::"

msgid ""
">>> PurePath('a/b.py').full_match('a/*.py')\n"
"True\n"
">>> PurePath('a/b.py').full_match('*.py')\n"
"False\n"
">>> PurePath('/a/b/c.py').full_match('/a/**')\n"
"True\n"
">>> PurePath('/a/b/c.py').full_match('**/*.py')\n"
"True"
msgstr ""
">>> PurePath('a/b.py').full_match('a/*.py')\n"
"Sant\n"
">>> PurePath('a/b.py').full_match('*.py')\n"
"Falsk\n"
">>> PurePath('/a/b/c.py').full_match('/a/**')\n"
"Sant\n"
">>> PurePath('/a/b/c.py').full_match('**/*.py')\n"
"Sant"

msgid ":ref:`pathlib-pattern-language` documentation."
msgstr ":ref:`pathlib-pattern-language` dokumentation."

msgid "As with other methods, case-sensitivity follows platform defaults::"
msgstr ""
"Som med andra metoder följer skiftlägeskänsligheten plattformens "
"standardvärden::"

msgid ""
">>> PurePosixPath('b.py').full_match('*.PY')\n"
"False\n"
">>> PureWindowsPath('b.py').full_match('*.PY')\n"
"True"
msgstr ""
">>> PurePosixPath('b.py').full_match('*.PY')\n"
"Falsk\n"
">>> PureWindowsPath('b.py').full_match('*.PY')\n"
"Sant"

msgid ""
"Set *case_sensitive* to ``True`` or ``False`` to override this behaviour."
msgstr ""
"Sätt *case_sensitive* till ``True`` eller ``False`` för att åsidosätta detta "
"beteende."

msgid ""
"Match this path against the provided non-recursive glob-style pattern. "
"Return ``True`` if matching is successful, ``False`` otherwise."
msgstr ""
"Matchar denna sökväg mot det angivna icke-rekursiva mönstret i glob-stil. "
"Returnerar ``True`` om matchningen är lyckad, ``False`` annars."

msgid ""
"This method is similar to :meth:`~PurePath.full_match`, but empty patterns "
"aren't allowed (:exc:`ValueError` is raised), the recursive wildcard "
"\"``**``\" isn't supported (it acts like non-recursive \"``*``\"), and if a "
"relative pattern is provided, then matching is done from the right::"
msgstr ""
"Den här metoden liknar :meth:`~PurePath.full_match`, men tomma mönster "
"tillåts inte (:exc:`ValueError` tas upp), det rekursiva jokertecknet "
"\"``**``\" stöds inte (det fungerar som icke-rekursivt \"``*``\"), och om "
"ett relativt mönster anges görs matchningen från höger::"

msgid ""
">>> PurePath('a/b.py').match('*.py')\n"
"True\n"
">>> PurePath('/a/b/c.py').match('b/*.py')\n"
"True\n"
">>> PurePath('/a/b/c.py').match('a/*.py')\n"
"False"
msgstr ""
">>> PurePath('a/b.py').match('*.py')\n"
"Sant\n"
">>> PurePath('/a/b/c.py').match('b/*.py')\n"
"Sant\n"
">>> PurePath('/a/b/c.py').match('a/*.py')\n"
"Falsk"

msgid "The *pattern* parameter accepts a :term:`path-like object`."
msgstr "Parametern *mönster* accepterar en :term:`path-liknande objekt`."

msgid "The *case_sensitive* parameter was added."
msgstr "Parametern *case_sensitive* har lagts till."

msgid ""
"Compute a version of this path relative to the path represented by *other*.  "
"If it's impossible, :exc:`ValueError` is raised::"
msgstr ""
"Beräkna en version av den här sökvägen i förhållande till den sökväg som "
"representeras av *other*.  Om det är omöjligt, :exc:`ValueError` tas upp::"

msgid ""
">>> p = PurePosixPath('/etc/passwd')\n"
">>> p.relative_to('/')\n"
"PurePosixPath('etc/passwd')\n"
">>> p.relative_to('/etc')\n"
"PurePosixPath('passwd')\n"
">>> p.relative_to('/usr')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"pathlib.py\", line 941, in relative_to\n"
"    raise ValueError(error_message.format(str(self), str(formatted)))\n"
"ValueError: '/etc/passwd' is not in the subpath of '/usr' OR one path is "
"relative and the other is absolute."
msgstr ""
"&gt;&gt;&gt; p = PurePosixPath('/etc/passwd')\n"
"&gt;&gt;&gt; p.relativ_to('/')\n"
"PurePosixSökväg('etc/passwd')\n"
"&gt;&gt;&gt; p.relativ_till('/etc')\n"
"PurePosixSökväg('passwd')\n"
"&gt;&gt;&gt; p.relativ_till('/usr')\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"pathlib.py\", rad 941, i relative_to\n"
"    raise ValueError(error_message.format(str(self), str(formaterad)))\n"
"ValueError: \"/etc/passwd\" finns inte i undervägen till \"/usr\" ELLER en "
"sökväg är relativ och den andra är absolut."

msgid ""
"When *walk_up* is false (the default), the path must start with *other*. "
"When the argument is true, ``..`` entries may be added to form the relative "
"path. In all other cases, such as the paths referencing different drives, :"
"exc:`ValueError` is raised.::"
msgstr ""
"När *walk_up* är false (standard) måste sökvägen börja med *other*. När "
"argumentet är true kan ``..`` poster läggas till för att bilda den relativa "
"sökvägen. I alla andra fall, t.ex. sökvägar som refererar till olika "
"enheter, visas :exc:`ValueError`.::"

msgid ""
">>> p.relative_to('/usr', walk_up=True)\n"
"PurePosixPath('../etc/passwd')\n"
">>> p.relative_to('foo', walk_up=True)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"pathlib.py\", line 941, in relative_to\n"
"    raise ValueError(error_message.format(str(self), str(formatted)))\n"
"ValueError: '/etc/passwd' is not on the same drive as 'foo' OR one path is "
"relative and the other is absolute."
msgstr ""
"&gt;&gt;&gt; p.relative_to('/usr', walk_up=True)\n"
"PurePosixPath('../etc/passwd')\n"
"&gt;&gt;&gt; p.relative_to('foo', walk_up=True)\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"pathlib.py\", rad 941, i relative_to\n"
"    raise ValueError(error_message.format(str(self), str(formatted)))\n"
"ValueError: '/etc/passwd' finns inte på samma enhet som 'foo' ELLER en "
"sökväg är relativ och den andra är absolut."

msgid ""
"This function is part of :class:`PurePath` and works with strings. It does "
"not check or access the underlying file structure. This can impact the "
"*walk_up* option as it assumes that no symlinks are present in the path; "
"call :meth:`~Path.resolve` first if necessary to resolve symlinks."
msgstr ""
"Denna funktion är en del av :class:`PurePath` och arbetar med strängar. Den "
"kontrollerar inte och har inte åtkomst till den underliggande filstrukturen. "
"Detta kan påverka alternativet *walk_up* eftersom det förutsätter att det "
"inte finns några symlänkar i sökvägen; anropa :meth:`~Path.resolve` först om "
"det behövs för att lösa symlänkar."

msgid ""
"The *walk_up* parameter was added (old behavior is the same as "
"``walk_up=False``)."
msgstr ""
"Parametern *walk_up* har lagts till (det gamla beteendet är detsamma som "
"``walk_up=False``)."

msgid ""
"Passing additional positional arguments is deprecated; if supplied, they are "
"joined with *other*."
msgstr ""
"Att ange ytterligare positionella argument är inte aktuellt; om de anges "
"sammanfogas de med *other*."

msgid ""
"Return a new path with the :attr:`name` changed.  If the original path "
"doesn't have a name, ValueError is raised::"
msgstr ""
"Returnerar en ny sökväg med :attr:`name` ändrat.  Om den ursprungliga "
"sökvägen inte har något namn, uppstår ValueError::"

msgid ""
">>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
">>> p.with_name('setup.py')\n"
"PureWindowsPath('c:/Downloads/setup.py')\n"
">>> p = PureWindowsPath('c:/')\n"
">>> p.with_name('setup.py')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"/home/antoine/cpython/default/Lib/pathlib.py\", line 751, in "
"with_name\n"
"    raise ValueError(\"%r has an empty name\" % (self,))\n"
"ValueError: PureWindowsPath('c:/') has an empty name"
msgstr ""
"&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
"&gt;&gt;&gt; p.med_namn('setup.py')\n"
"PureWindowsPath('c:/Downloads/setup.py')\n"
"&gt;&gt;&gt; p = PureWindowsPath('c:/')\n"
"&gt;&gt;&gt; p.med_namn('setup.py')\n"
"Återkoppling (senaste anropet sist):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"/home/antoine/cpython/default/Lib/pathlib.py\", rad 751, i "
"with_name\n"
"    raise ValueError(\"%r har ett tomt namn\" % (self,))\n"
"ValueError: PureWindowsPath('c:/') har ett tomt namn"

msgid ""
"Return a new path with the :attr:`stem` changed.  If the original path "
"doesn't have a name, ValueError is raised::"
msgstr ""
"Returnerar en ny sökväg med :attr:`stem` ändrad.  Om den ursprungliga "
"sökvägen inte har något namn, uppstår ValueError::"

msgid ""
">>> p = PureWindowsPath('c:/Downloads/draft.txt')\n"
">>> p.with_stem('final')\n"
"PureWindowsPath('c:/Downloads/final.txt')\n"
">>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
">>> p.with_stem('lib')\n"
"PureWindowsPath('c:/Downloads/lib.gz')\n"
">>> p = PureWindowsPath('c:/')\n"
">>> p.with_stem('')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"/home/antoine/cpython/default/Lib/pathlib.py\", line 861, in "
"with_stem\n"
"    return self.with_name(stem + self.suffix)\n"
"  File \"/home/antoine/cpython/default/Lib/pathlib.py\", line 851, in "
"with_name\n"
"    raise ValueError(\"%r has an empty name\" % (self,))\n"
"ValueError: PureWindowsPath('c:/') has an empty name"
msgstr ""
"&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/draft.txt')\n"
"&gt;&gt;&gt; p.med_stam('final')\n"
"PureWindowsPath('c:/Nedladdningar/final.txt')\n"
"&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
"&gt;&gt;&gt; p.med_stam('lib')\n"
"PureWindowsPath('c:/Nedladdningar/lib.gz')\n"
"&gt;&gt;&gt; p = PureWindowsPath('c:/')\n"
"&gt;&gt;&gt; p.med_stam('')\n"
"Traceback (senaste anropet senast):\n"
"  Fil \"<stdin>\", rad 1, i <module>\n"
"  Fil \"/home/antoine/cpython/default/Lib/pathlib.py\", rad 861, i "
"with_stem\n"
"    return self.with_name(stam + self.suffix)\n"
"  Fil \"/home/antoine/cpython/default/Lib/pathlib.py\", rad 851, i "
"with_name\n"
"    raise ValueError(\"%r har ett tomt namn\" % (self,))\n"
"ValueError: PureWindowsPath('c:/') har ett tomt namn"

msgid ""
"Return a new path with the :attr:`suffix` changed.  If the original path "
"doesn't have a suffix, the new *suffix* is appended instead.  If the "
"*suffix* is an empty string, the original suffix is removed::"
msgstr ""
"Returnerar en ny sökväg med :attr:`suffix` ändrat.  Om den ursprungliga "
"sökvägen inte har något suffix läggs det nya *suffixet* till istället.  Om "
"*suffix* är en tom sträng tas det ursprungliga suffixet bort::"

msgid ""
">>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
">>> p.with_suffix('.bz2')\n"
"PureWindowsPath('c:/Downloads/pathlib.tar.bz2')\n"
">>> p = PureWindowsPath('README')\n"
">>> p.with_suffix('.txt')\n"
"PureWindowsPath('README.txt')\n"
">>> p = PureWindowsPath('README.txt')\n"
">>> p.with_suffix('')\n"
"PureWindowsPath('README')"
msgstr ""
">>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')\n"
">>> p.med_suffix('.bz2')\n"
"PureWindowsPath('c:/Nedladdningar/pathlib.tar.bz2')\n"
">>> p = PureWindowsPath('README')\n"
">>> p.med_suffix('.txt')\n"
"PureWindowsSökväg('README.txt')\n"
">>> p = PureWindowsPath('README.txt')\n"
">>> p.med_suffix('')\n"
"PureWindowsSökväg('README')"

msgid ""
"A single dot (\"``.``\") is considered a valid suffix. In previous "
"versions, :exc:`ValueError` is raised if a single dot is supplied."
msgstr ""
"En enda punkt (\"``.``\") anses vara ett giltigt suffix. I tidigare "
"versioner gavs :exc:`ValueError` om en enda punkt angavs."

msgid ""
"Create a new path object of the same type by combining the given "
"*pathsegments*. This method is called whenever a derivative path is created, "
"such as from :attr:`parent` and :meth:`relative_to`. Subclasses may override "
"this method to pass information to derivative paths, for example::"
msgstr ""
"Skapar ett nytt sökvägsobjekt av samma typ genom att kombinera de angivna "
"*sökvägssegmenten*. Denna metod anropas när en härledd sökväg skapas, t.ex. "
"från :attr:`parent` och :meth:`relative_to`. Subklasser kan åsidosätta denna "
"metod för att skicka information till härledda sökvägar, till exempel::"

msgid ""
"from pathlib import PurePosixPath\n"
"\n"
"class MyPath(PurePosixPath):\n"
"    def __init__(self, *pathsegments, session_id):\n"
"        super().__init__(*pathsegments)\n"
"        self.session_id = session_id\n"
"\n"
"    def with_segments(self, *pathsegments):\n"
"        return type(self)(*pathsegments, session_id=self.session_id)\n"
"\n"
"etc = MyPath('/etc', session_id=42)\n"
"hosts = etc / 'hosts'\n"
"print(hosts.session_id)  # 42"
msgstr ""
"from pathlib import PurePosixPath\n"
"\n"
"klass MyPath(PurePosixPath):\n"
"    def __init__(self, *vägsegment, session_id):\n"
"        super().__init__(*vägsegment)\n"
"        self.session_id = session_id\n"
"\n"
"    def with_segments(self, *sökvägssegment):\n"
"        return type(self)(*sökvägssegment, session_id=self.session_id)\n"
"\n"
"etc = MyPath('/etc', session_id=42)\n"
"hosts = etc / 'hosts'\n"
"print(hosts.session_id) # 42"

msgid "Concrete paths"
msgstr "Betongvägar"

msgid ""
"Concrete paths are subclasses of the pure path classes.  In addition to "
"operations provided by the latter, they also provide methods to do system "
"calls on path objects.  There are three ways to instantiate concrete paths:"
msgstr ""
"Konkreta sökvägar är subklasser av de rena sökvägsklasserna.  Förutom de "
"operationer som tillhandahålls av de senare, tillhandahåller de också "
"metoder för att göra systemanrop på sökvägsobjekt.  Det finns tre sätt att "
"instansiera konkreta sökvägar:"

msgid ""
"A subclass of :class:`PurePath`, this class represents concrete paths of the "
"system's path flavour (instantiating it creates either a :class:`PosixPath` "
"or a :class:`WindowsPath`)::"
msgstr ""
"Denna klass är en underklass till :class:`PurePath` och representerar "
"konkreta sökvägar av systemets sökvägssmak (genom att instansiera den skapas "
"antingen en :class:`PosixPath` eller en :class:`WindowsPath`)::"

msgid ""
">>> Path('setup.py')\n"
"PosixPath('setup.py')"
msgstr ""
">>> Path('setup.py')\n"
"PosixSökväg('setup.py')"

msgid ""
"A subclass of :class:`Path` and :class:`PurePosixPath`, this class "
"represents concrete non-Windows filesystem paths::"
msgstr ""
"Denna klass är en underklass till :class:`Path` och :class:`PurePosixPath` "
"och representerar konkreta sökvägar till filsystem som inte är Windows::"

msgid ""
">>> PosixPath('/etc/hosts')\n"
"PosixPath('/etc/hosts')"
msgstr ""
">>> PosixPath('/etc/hosts')\n"
"PosixSökväg('/etc/hosts')"

msgid ""
"Raises :exc:`UnsupportedOperation` on Windows. In previous versions, :exc:"
"`NotImplementedError` was raised instead."
msgstr ""
"Utlöser :exc:`UnsupportedOperation` på Windows. I tidigare versioner gavs "
"istället :exc:`NotImplementedError`."

msgid ""
"A subclass of :class:`Path` and :class:`PureWindowsPath`, this class "
"represents concrete Windows filesystem paths::"
msgstr ""
"Denna klass är en underklass till :class:`Path` och :class:`PureWindowsPath` "
"och representerar konkreta sökvägar i Windows filsystem::"

msgid ""
">>> WindowsPath('c:/', 'Users', 'Ximénez')\n"
"WindowsPath('c:/Users/Ximénez')"
msgstr ""
">>> WindowsPath('c:/', 'Users', 'Ximénez')\n"
"WindowsPath('c:/Användare/Ximénez')"

msgid ""
"Raises :exc:`UnsupportedOperation` on non-Windows platforms. In previous "
"versions, :exc:`NotImplementedError` was raised instead."
msgstr ""
"Utlöser :exc:`UnsupportedOperation` på icke-Windows plattformar. I tidigare "
"versioner gavs istället :exc:`NotImplementedError`."

msgid ""
"You can only instantiate the class flavour that corresponds to your system "
"(allowing system calls on non-compatible path flavours could lead to bugs or "
"failures in your application)::"
msgstr ""
"Du kan bara instansiera den klassvariant som motsvarar ditt system (om du "
"tillåter systemanrop på icke-kompatibla klassvarianter kan det leda till "
"buggar eller fel i din applikation)::"

msgid ""
">>> import os\n"
">>> os.name\n"
"'posix'\n"
">>> Path('setup.py')\n"
"PosixPath('setup.py')\n"
">>> PosixPath('setup.py')\n"
"PosixPath('setup.py')\n"
">>> WindowsPath('setup.py')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"pathlib.py\", line 798, in __new__\n"
"    % (cls.__name__,))\n"
"UnsupportedOperation: cannot instantiate 'WindowsPath' on your system"
msgstr ""
">>> import os\n"
">>> os.name\n"
"'posix'\n"
">>> Path('setup.py')\n"
"PosixPath('setup.py')\n"
">>> PosixPath('setup.py')\n"
"PosixPath('setup.py')\n"
">>> WindowsPath('setup.py')\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"pathlib.py\", line 798, in __new__\n"
"    % (cls.__name__,))\n"
"UnsupportedOperation: cannot instantiate 'WindowsPath' on your system"

msgid ""
"Some concrete path methods can raise an :exc:`OSError` if a system call "
"fails (for example because the path doesn't exist)."
msgstr ""
"Vissa konkreta sökvägsmetoder kan ge upphov till ett :exc:`OSError` om ett "
"systemanrop misslyckas (t.ex. för att sökvägen inte finns)."

msgid "Parsing and generating URIs"
msgstr "Parsning och generering av URI:er"

msgid ""
"Concrete path objects can be created from, and represented as, 'file' URIs "
"conforming to :rfc:`8089`."
msgstr ""
"Konkreta sökvägsobjekt kan skapas från, och representeras som, 'file' URI:er "
"som överensstämmer med :rfc:`8089`."

msgid ""
"File URIs are not portable across machines with different :ref:`filesystem "
"encodings <filesystem-encoding>`."
msgstr ""
"Fil-URI:er är inte portabla mellan maskiner med olika :ref:"
"`filsystemskodningar <filesystem-encoding>`."

msgid "Return a new path object from parsing a 'file' URI. For example::"
msgstr ""
"Returnerar ett nytt sökvägsobjekt från parsning av en \"file\"-URI. Till "
"exempel::"

msgid ""
">>> p = Path.from_uri('file:///etc/hosts')\n"
"PosixPath('/etc/hosts')"
msgstr ""
">>> p = Path.from_uri('file:///etc/hosts')\n"
"PosixPath('/etc/hosts')"

msgid "On Windows, DOS device and UNC paths may be parsed from URIs::"
msgstr "I Windows kan DOS-enhets- och UNC-sökvägar tolkas från URI:er::"

msgid ""
">>> p = Path.from_uri('file:///c:/windows')\n"
"WindowsPath('c:/windows')\n"
">>> p = Path.from_uri('file://server/share')\n"
"WindowsPath('//server/share')"
msgstr ""
">>> p = Path.from_uri('file:///c:/windows')\n"
"WindowsPath('c:/windows')\n"
">>> p = Path.from_uri('file://server/share')\n"
"WindowsSökväg('//server/share')"

msgid "Several variant forms are supported::"
msgstr "Flera olika varianter stöds::"

msgid ""
">>> p = Path.from_uri('file:////server/share')\n"
"WindowsPath('//server/share')\n"
">>> p = Path.from_uri('file://///server/share')\n"
"WindowsPath('//server/share')\n"
">>> p = Path.from_uri('file:c:/windows')\n"
"WindowsPath('c:/windows')\n"
">>> p = Path.from_uri('file:/c|/windows')\n"
"WindowsPath('c:/windows')"
msgstr ""
">>> p = Path.from_uri('file:////server/share')\n"
"WindowsPath('//server/share')\n"
">>> p = Path.from_uri('file://///server/share')\n"
"WindowsSökväg('//server/share')\n"
">>> p = Path.from_uri('file:c:/windows')\n"
"WindowsPath('c:/windows')\n"
">>> p = Path.from_uri('file:/c|/windows')\n"
"WindowsPath('c:/windows')"

msgid ""
":exc:`ValueError` is raised if the URI does not start with ``file:``, or the "
"parsed path isn't absolute."
msgstr ""
":exc:`ValueError` uppstår om URI:n inte börjar med ``file:``, eller om den "
"tolkade sökvägen inte är absolut."

msgid ""
"The URL authority is discarded if it matches the local hostname. Otherwise, "
"if the authority isn't empty or ``localhost``, then on Windows a UNC path is "
"returned (as before), and on other platforms a :exc:`ValueError` is raised."
msgstr ""
"URL-auktoriteten kasseras om den matchar det lokala värdnamnet. I annat "
"fall, om auktoriteten inte är tom eller ``localhost``, returneras en UNC-"
"sökväg på Windows (som tidigare), och på andra plattformar genereras ett :"
"exc:`ValueError`."

msgid ""
"Represent the path as a 'file' URI.  :exc:`ValueError` is raised if the path "
"isn't absolute."
msgstr ""
"Representera sökvägen som en 'file' URI. :exc:`ValueError` uppstår om "
"sökvägen inte är absolut."

msgid ""
">>> p = PosixPath('/etc/passwd')\n"
">>> p.as_uri()\n"
"'file:///etc/passwd'\n"
">>> p = WindowsPath('c:/Windows')\n"
">>> p.as_uri()\n"
"'file:///c:/Windows'"
msgstr ""
">>> p = PosixPath('/etc/passwd')\n"
">>> p.as_uri()\n"
"'file:///etc/passwd'\n"
">>> p = WindowsPath('c:/Windows')\n"
">>> p.as_uri()\n"
"'fil:///c:/Windows'"

msgid ""
"Calling this method from :class:`PurePath` rather than :class:`Path` is "
"possible but deprecated. The method's use of :func:`os.fsencode` makes it "
"strictly impure."
msgstr ""
"Att anropa denna metod från :class:`PurePath` istället för :class:`Path` är "
"möjligt men föråldrat. Metodens användning av :func:`os.fsencode` gör den "
"strikt oren."

msgid "Expanding and resolving paths"
msgstr "Utvidgning och upplösning av banor"

msgid ""
"Return a new path object representing the user's home directory (as returned "
"by :func:`os.path.expanduser` with ``~`` construct). If the home directory "
"can't be resolved, :exc:`RuntimeError` is raised."
msgstr ""
"Returnerar ett nytt sökvägsobjekt som representerar användarens hemkatalog "
"(som returneras av :func:`os.path.expanduser` med ``~``-konstruktionen). Om "
"hemkatalogen inte kan lösas ut kommer :exc:`RuntimeError` att visas."

msgid ""
">>> Path.home()\n"
"PosixPath('/home/antoine')"
msgstr ""
">>> Path.home()\n"
"PosixPath('/home/antoine')"

msgid ""
"Return a new path with expanded ``~`` and ``~user`` constructs, as returned "
"by :meth:`os.path.expanduser`. If a home directory can't be resolved, :exc:"
"`RuntimeError` is raised."
msgstr ""
"Returnerar en ny sökväg med utökade ``~`` och ``~user`` konstruktioner, som "
"returneras av :meth:`os.path.expanduser`. Om en hemkatalog inte kan lösas, "
"uppstår :exc:`RuntimeError`."

msgid ""
">>> p = PosixPath('~/films/Monty Python')\n"
">>> p.expanduser()\n"
"PosixPath('/home/eric/films/Monty Python')"
msgstr ""
">>> p = PosixPath('~/filmer/Monty Python')\n"
">>> p.expanduser()\n"
"PosixPath('/home/eric/films/Monty Python')"

msgid ""
"Return a new path object representing the current directory (as returned by :"
"func:`os.getcwd`)::"
msgstr ""
"Returnerar ett nytt sökvägsobjekt som representerar den aktuella katalogen "
"(som returneras av :func:`os.getcwd`)::"

msgid ""
">>> Path.cwd()\n"
"PosixPath('/home/antoine/pathlib')"
msgstr ""
">>> Path.cwd()\n"
"PosixPath('/home/antoine/pathlib')"

msgid ""
"Make the path absolute, without normalization or resolving symlinks. Returns "
"a new path object::"
msgstr ""
"Gör sökvägen absolut, utan normalisering eller lösning av symlänkar. "
"Returnerar ett nytt sökvägsobjekt::"

msgid ""
">>> p = Path('tests')\n"
">>> p\n"
"PosixPath('tests')\n"
">>> p.absolute()\n"
"PosixPath('/home/antoine/pathlib/tests')"
msgstr ""
">>> p = Sökväg('tester')\n"
">>> p\n"
"PosixPath('tester')\n"
">>> p.absolut()\n"
"PosixPath('/home/antoine/pathlib/tests')"

msgid ""
"Make the path absolute, resolving any symlinks.  A new path object is "
"returned::"
msgstr ""
"Gör sökvägen absolut och löser eventuella symlänkar.  Ett nytt sökvägsobjekt "
"returneras::"

msgid ""
">>> p = Path()\n"
">>> p\n"
"PosixPath('.')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib')"
msgstr ""
">>> p = Sökväg()\n"
">>> p\n"
"PosixPath('.')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib')"

msgid ""
"\"``..``\" components are also eliminated (this is the only method to do "
"so)::"
msgstr ""
"\"``..``\"-komponenter elimineras också (detta är den enda metoden som gör "
"det)::"

msgid ""
">>> p = Path('docs/../setup.py')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib/setup.py')"
msgstr ""
">>> p = Path('docs/../setup.py')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib/setup.py')"

msgid ""
"If a path doesn't exist or a symlink loop is encountered, and *strict* is "
"``True``, :exc:`OSError` is raised.  If *strict* is ``False``, the path is "
"resolved as far as possible and any remainder is appended without checking "
"whether it exists."
msgstr ""
"Om en sökväg inte finns eller om en symlänkslinga påträffas, och *strict* är "
"``True``, genereras :exc:`OSError`.  Om *strict* är ``False`` löses sökvägen "
"upp så långt det är möjligt och eventuella rester läggs till utan att "
"kontrollera om den existerar."

msgid "The *strict* parameter was added (pre-3.6 behavior is strict)."
msgstr "Parametern *strict* har lagts till (beteendet före 3.6 är strikt)."

msgid ""
"Symlink loops are treated like other errors: :exc:`OSError` is raised in "
"strict mode, and no exception is raised in non-strict mode. In previous "
"versions, :exc:`RuntimeError` is raised no matter the value of *strict*."
msgstr ""
"Symlink-loopar behandlas som andra fel: :exc:`OSError` aktiveras i strikt "
"läge och inget undantag aktiveras i icke-strikt läge. I tidigare versioner "
"utlöses :exc:`RuntimeError` oavsett värdet på *strict*."

msgid ""
"Return the path to which the symbolic link points (as returned by :func:`os."
"readlink`)::"
msgstr ""
"Returnera sökvägen som den symboliska länken pekar på (som returneras av :"
"func:`os.readlink`)::"

msgid ""
">>> p = Path('mylink')\n"
">>> p.symlink_to('setup.py')\n"
">>> p.readlink()\n"
"PosixPath('setup.py')"
msgstr ""
">>> p = Sökväg('mylink')\n"
">>> p.symlink_to('setup.py')\n"
">>> p.readlink()\n"
"PosixPath('setup.py')"

msgid ""
"Raises :exc:`UnsupportedOperation` if :func:`os.readlink` is not available. "
"In previous versions, :exc:`NotImplementedError` was raised."
msgstr ""
"Utlöser :exc:`UnsupportedOperation` om :func:`os.readlink` inte är "
"tillgänglig. I tidigare versioner gavs :exc:`NotImplementedError`."

msgid "Querying file type and status"
msgstr "Förfrågan om filtyp och status"

msgid ""
":meth:`~Path.exists`, :meth:`~Path.is_dir`, :meth:`~Path.is_file`, :meth:"
"`~Path.is_mount`, :meth:`~Path.is_symlink`, :meth:`~Path.is_block_device`, :"
"meth:`~Path.is_char_device`, :meth:`~Path.is_fifo`, :meth:`~Path.is_socket` "
"now return ``False`` instead of raising an exception for paths that contain "
"characters unrepresentable at the OS level."
msgstr ""
":meth:`~Path.exists`, :meth:`~Path.is_dir`, :meth:`~Path.is_file`, :meth:"
"`~Path.is_mount`, :meth:`~Path.is_symlink`, :meth:`~Path.is_block_device`, :"
"meth:`~Path.is_char_device`, :meth:`~Path.is_fifo`, :meth:`~Path.is_socket` "
"returnerar nu ``False`` istället för att skapa ett undantag för sökvägar som "
"innehåller tecken som inte kan representeras på OS-nivå."

msgid ""
"The methods given above now return ``False`` instead of raising any :exc:"
"`OSError` exception from the operating system. In previous versions, some "
"kinds of :exc:`OSError` exception are raised, and others suppressed. The new "
"behaviour is consistent with :func:`os.path.exists`, :func:`os.path.isdir`, "
"etc. Use :meth:`~Path.stat` to retrieve the file status without suppressing "
"exceptions."
msgstr ""
"Metoderna ovan returnerar nu ``False`` istället för att ge upphov till "
"något :exc:`OSError`-undantag från operativsystemet. I tidigare versioner "
"har vissa typer av :exc:`OSError`-undantag uppstått, medan andra har "
"undertryckts. Det nya beteendet är förenligt med :func:`os.path.exists`, :"
"func:`os.path.isdir`, etc. Använd :meth:`~Path.stat` för att hämta filstatus "
"utan att undertrycka undantag."

msgid ""
"Return an :class:`os.stat_result` object containing information about this "
"path, like :func:`os.stat`. The result is looked up at each call to this "
"method."
msgstr ""
"Returnerar ett :class:`os.stat_result`-objekt som innehåller information om "
"den här sökvägen, som :func:`os.stat`. Resultatet söks upp vid varje anrop "
"till denna metod."

msgid ""
"This method normally follows symlinks; to stat a symlink add the argument "
"``follow_symlinks=False``, or use :meth:`~Path.lstat`."
msgstr ""
"Den här metoden följer normalt symlinks; för att stata en symlink lägg till "
"argumentet ``follow_symlinks=False``, eller använd :meth:`~Path.lstat`."

msgid ""
">>> p = Path('setup.py')\n"
">>> p.stat().st_size\n"
"956\n"
">>> p.stat().st_mtime\n"
"1327883547.852554"
msgstr ""
">>> p = Path('setup.py')\n"
">>> p.stat().st_storlek\n"
"956\n"
">>> p.stat().st_mtime\n"
"1327883547.852554"

msgid "The *follow_symlinks* parameter was added."
msgstr "Parametern *follow_symlinks* har lagts till."

msgid ""
"Like :meth:`Path.stat` but, if the path points to a symbolic link, return "
"the symbolic link's information rather than its target's."
msgstr ""
"Som :meth:`Path.stat`, men om sökvägen pekar på en symbolisk länk returneras "
"den symboliska länkens information i stället för målets."

msgid ""
"Return ``True`` if the path points to an existing file or directory. "
"``False`` will be returned if the path is invalid, inaccessible or missing. "
"Use :meth:`Path.stat` to distinguish between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en befintlig fil eller katalog. "
"``False`` returneras om sökvägen är ogiltig, otillgänglig eller saknas. "
"Använd :meth:`Path.stat` för att skilja mellan dessa fall."

msgid ""
"This method normally follows symlinks; to check if a symlink exists, add the "
"argument ``follow_symlinks=False``."
msgstr ""
"Denna metod följer normalt symlinks; för att kontrollera om en symlink "
"existerar, lägg till argumentet ``follow_symlinks=False``."

msgid ""
">>> Path('.').exists()\n"
"True\n"
">>> Path('setup.py').exists()\n"
"True\n"
">>> Path('/etc').exists()\n"
"True\n"
">>> Path('nonexistentfile').exists()\n"
"False"
msgstr ""
">>> Path('.').exists()\n"
"Sant\n"
">>> Path('setup.py').exists()\n"
"True\n"
">>> Sökväg('/etc').finns()\n"
"Sant\n"
">>> Sökväg('nonexistentfile').exists()\n"
"False"

msgid ""
"Return ``True`` if the path points to a regular file. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a regular file. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en vanlig fil. ``False`` returneras "
"om sökvägen är ogiltig, otillgänglig eller saknas, eller om den pekar på "
"något annat än en vanlig fil. Använd :meth:`Path.stat` för att skilja mellan "
"dessa fall."

msgid ""
"This method normally follows symlinks; to exclude symlinks, add the argument "
"``follow_symlinks=False``."
msgstr ""
"Denna metod följer normalt symlänkar; för att utesluta symlänkar, lägg till "
"argumentet ``follow_symlinks=False``."

msgid ""
"Return ``True`` if the path points to a directory. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a directory. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en katalog. ``False`` returneras om "
"sökvägen är ogiltig, otillgänglig eller saknas, eller om den pekar på något "
"annat än en katalog. Använd :meth:`Path.stat` för att skilja mellan dessa "
"fall."

msgid ""
"This method normally follows symlinks; to exclude symlinks to directories, "
"add the argument ``follow_symlinks=False``."
msgstr ""
"Den här metoden följer normalt symlinks; om du vill utesluta symlinks till "
"kataloger lägger du till argumentet ``follow_symlinks=False``."

msgid ""
"Return ``True`` if the path points to a symbolic link, even if that symlink "
"is broken. ``False`` will be returned if the path is invalid, inaccessible "
"or missing, or if it points to something other than a symbolic link. Use :"
"meth:`Path.stat` to distinguish between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en symbolisk länk, även om "
"symbollänken är bruten. ``False`` returneras om sökvägen är ogiltig, "
"otillgänglig eller saknas, eller om den pekar på något annat än en symbolisk "
"länk. Använd :meth:`Path.stat` för att skilja mellan dessa fall."

msgid ""
"Return ``True`` if the path points to a junction, and ``False`` for any "
"other type of file. Currently only Windows supports junctions."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en korsning och ``False`` för alla "
"andra typer av filer. För närvarande stöder endast Windows junctions."

msgid ""
"Return ``True`` if the path is a :dfn:`mount point`: a point in a file "
"system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`path/..`, is on a different "
"device than *path*, or whether :file:`path/..` and *path* point to the same "
"i-node on the same device --- this should detect mount points for all Unix "
"and POSIX variants.  On Windows, a mount point is considered to be a drive "
"letter root (e.g. ``c:\\``), a UNC share (e.g. ``\\\\server\\share``), or a "
"mounted filesystem directory."
msgstr ""
"Returnerar ``True`` om sökvägen är en :dfn:`mount point`: en punkt i ett "
"filsystem där ett annat filsystem har monterats.  På POSIX kontrollerar "
"funktionen om *sökväg*s förälder, :file:`sökväg/..`, finns på en annan enhet "
"än *sökväg*, eller om :file:`sökväg/..` och *sökväg* pekar på samma i-nod på "
"samma enhet --- detta bör upptäcka monteringspunkter för alla Unix- och "
"POSIX-varianter.  I Windows anses en monteringspunkt vara en enhetsbokstav "
"root (t.ex. ``c:\\``), en UNC-delning (t.ex. ``\\server\\share``) eller en "
"monterad filsystemkatalog."

msgid "Windows support was added."
msgstr "Stöd för Windows har lagts till."

msgid ""
"Return ``True`` if the path points to a Unix socket. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a Unix socket. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en Unix-socket. ``False`` "
"returneras om sökvägen är ogiltig, otillgänglig eller saknas, eller om den "
"pekar på något annat än en Unix-socket. Använd :meth:`Path.stat` för att "
"skilja mellan dessa fall."

msgid ""
"Return ``True`` if the path points to a FIFO. ``False`` will be returned if "
"the path is invalid, inaccessible or missing, or if it points to something "
"other than a FIFO. Use :meth:`Path.stat` to distinguish between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en FIFO. ``False`` returneras om "
"sökvägen är ogiltig, otillgänglig eller saknas, eller om den pekar på något "
"annat än en FIFO. Använd :meth:`Path.stat` för att skilja mellan dessa fall."

msgid ""
"Return ``True`` if the path points to a block device. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a block device. Use :meth:`Path.stat` to distinguish "
"between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en blockenhet. ``False`` returneras "
"om sökvägen är ogiltig, otillgänglig eller saknas, eller om den pekar på "
"något annat än en blockenhet. Använd :meth:`Path.stat` för att skilja mellan "
"dessa fall."

msgid ""
"Return ``True`` if the path points to a character device. ``False`` will be "
"returned if the path is invalid, inaccessible or missing, or if it points to "
"something other than a character device. Use :meth:`Path.stat` to "
"distinguish between these cases."
msgstr ""
"Returnerar ``True`` om sökvägen pekar på en teckenenhet. ``False`` "
"returneras om sökvägen är ogiltig, otillgänglig eller saknas, eller om den "
"pekar på något annat än en teckenenhet. Använd :meth:`Path.stat` för att "
"skilja mellan dessa fall."

msgid ""
"Return whether this path points to the same file as *other_path*, which can "
"be either a Path object, or a string.  The semantics are similar to :func:"
"`os.path.samefile` and :func:`os.path.samestat`."
msgstr ""
"Returnerar om den här sökvägen pekar på samma fil som *other_path*, som kan "
"vara antingen ett Path-objekt eller en sträng.  Semantiken liknar :func:`os."
"path.samefile` och :func:`os.path.samestat`."

msgid ""
"An :exc:`OSError` can be raised if either file cannot be accessed for some "
"reason."
msgstr ""
"Ett :exc:`OSError` kan uppstå om någon av filerna av någon anledning inte "
"går att komma åt."

msgid ""
">>> p = Path('spam')\n"
">>> q = Path('eggs')\n"
">>> p.samefile(q)\n"
"False\n"
">>> p.samefile('spam')\n"
"True"
msgstr ""
">>> p = Sökväg('spam')\n"
">>> q = Sökväg('ägg')\n"
">>> p.samefile(q)\n"
"Falskt\n"
">>> p.samefile('spam')\n"
"Sant"

msgid ""
"A :class:`~pathlib.types.PathInfo` object that supports querying file type "
"information. The object exposes methods that cache their results, which can "
"help reduce the number of system calls needed when switching on file type. "
"For example::"
msgstr ""
"Ett :class:`~pathlib.types.PathInfo`-objekt som stöder frågor om filtyp. "
"Objektet exponerar metoder som cachar sina resultat, vilket kan bidra till "
"att minska antalet systemanrop som behövs när man byter filtyp. Till "
"exempel::"

msgid ""
">>> p = Path('src')\n"
">>> if p.info.is_symlink():\n"
"...     print('symlink')\n"
"... elif p.info.is_dir():\n"
"...     print('directory')\n"
"... elif p.info.exists():\n"
"...     print('something else')\n"
"... else:\n"
"...     print('not found')\n"
"...\n"
"directory"
msgstr ""
">>> p = Path('src')\n"
">>> om p.info.is_symlink():\n"
"... print('symlänk')\n"
"... elif p.info.is_dir():\n"
"... print('katalog')\n"
"... elif p.info.exists():\n"
"... print('något annat')\n"
"... annat:\n"
"... print('hittades inte')\n"
"...\n"
"katalog"

msgid ""
"If the path was generated from :meth:`Path.iterdir` then this attribute is "
"initialized with some information about the file type gleaned from scanning "
"the parent directory. Merely accessing :attr:`Path.info` does not perform "
"any filesystem queries."
msgstr ""
"Om sökvägen genererades från :meth:`Path.iterdir` initieras detta attribut "
"med information om filtypen som erhållits genom att skanna den överordnade "
"katalogen. Enbart åtkomst till :attr:`Path.info` utför inte några "
"filsystemfrågor."

msgid ""
"To fetch up-to-date information, it's best to call :meth:`Path.is_dir`, :"
"meth:`~Path.is_file` and :meth:`~Path.is_symlink` rather than methods of "
"this attribute. There is no way to reset the cache; instead you can create a "
"new path object with an empty info cache via ``p = Path(p)``."
msgstr ""
"För att hämta aktuell information är det bäst att anropa :meth:`Path."
"is_dir`, :meth:`~Path.is_file` och :meth:`~Path.is_symlink` snarare än "
"metoder för detta attribut. Det finns inget sätt att återställa cachen; "
"istället kan du skapa ett nytt sökvägsobjekt med en tom infocache via ``p = "
"Path(p)``."

msgid "Reading and writing files"
msgstr "Läsa och skriva filer"

msgid ""
"Open the file pointed to by the path, like the built-in :func:`open` "
"function does::"
msgstr ""
"Öppna den fil som sökvägen pekar på, på samma sätt som den inbyggda "
"funktionen :func:`open` gör::"

msgid ""
">>> p = Path('setup.py')\n"
">>> with p.open() as f:\n"
"...     f.readline()\n"
"...\n"
"'#!/usr/bin/env python3\\n'"
msgstr ""
">>> p = Path('setup.py')\n"
">>> med p.open() som f:\n"
"... f.readline()\n"
"...\n"
"'#!/usr/bin/env python3\\n'"

msgid "Return the decoded contents of the pointed-to file as a string::"
msgstr ""
"Returnera det avkodade innehållet i den fil som pekas ut som en sträng::"

msgid ""
">>> p = Path('my_text_file')\n"
">>> p.write_text('Text file contents')\n"
"18\n"
">>> p.read_text()\n"
"'Text file contents'"
msgstr ""
">>> p = Sökväg('min_textfil')\n"
">>> p.write_text('Textfilens innehåll')\n"
"18\n"
">>> p.läs_text()\n"
"'Textfilens innehåll'"

msgid ""
"The file is opened and then closed. The optional parameters have the same "
"meaning as in :func:`open`."
msgstr ""
"Filen öppnas och stängs sedan. De valfria parametrarna har samma betydelse "
"som i :func:`open`."

msgid "The *newline* parameter was added."
msgstr "Parametern *newline* har lagts till."

msgid "Return the binary contents of the pointed-to file as a bytes object::"
msgstr ""
"Returnera det binära innehållet i den fil som pekas ut som ett bytesobjekt::"

msgid ""
">>> p = Path('my_binary_file')\n"
">>> p.write_bytes(b'Binary file contents')\n"
"20\n"
">>> p.read_bytes()\n"
"b'Binary file contents'"
msgstr ""
">>> p = Sökväg('min_binärfil')\n"
">>> p.write_bytes(b'Binärfilens innehåll')\n"
"20\n"
">>> p.read_bytes()\n"
"b'Binärfilens innehåll'"

msgid ""
"Open the file pointed to in text mode, write *data* to it, and close the "
"file::"
msgstr ""
"Öppna den fil som pekas ut i textläge, skriv *data* till den och stäng "
"filen::"

msgid ""
"An existing file of the same name is overwritten. The optional parameters "
"have the same meaning as in :func:`open`."
msgstr ""
"En befintlig fil med samma namn skrivs över. De valfria parametrarna har "
"samma betydelse som i :func:`open`."

msgid ""
"Open the file pointed to in bytes mode, write *data* to it, and close the "
"file::"
msgstr ""
"Öppna den fil som pekas ut i bytesläge, skriv *data* till den och stäng "
"filen::"

msgid "An existing file of the same name is overwritten."
msgstr "En befintlig fil med samma namn skrivs över."

msgid "Reading directories"
msgstr "Läsa kataloger"

msgid ""
"When the path points to a directory, yield path objects of the directory "
"contents::"
msgstr ""
"När sökvägen pekar på en katalog, ger sökvägen objekt av kataloginnehållet::"

msgid ""
">>> p = Path('docs')\n"
">>> for child in p.iterdir(): child\n"
"...\n"
"PosixPath('docs/conf.py')\n"
"PosixPath('docs/_templates')\n"
"PosixPath('docs/make.bat')\n"
"PosixPath('docs/index.rst')\n"
"PosixPath('docs/_build')\n"
"PosixPath('docs/_static')\n"
"PosixPath('docs/Makefile')"
msgstr ""
">>> p = Sökväg('docs')\n"
">>> för barn i p.iterdir(): barn\n"
"...\n"
"PosixPath('docs/conf.py')\n"
"PosixPath('docs/_templates')\n"
"PosixPath('docs/make.bat')\n"
"PosixPath('docs/index.rst')\n"
"PosixPath('docs/_build')\n"
"PosixPath('docs/_static')\n"
"PosixPath('docs/Makefile')"

msgid ""
"The children are yielded in arbitrary order, and the special entries ``'.'`` "
"and ``'..'`` are not included.  If a file is removed from or added to the "
"directory after creating the iterator, it is unspecified whether a path "
"object for that file is included."
msgstr ""
"Barnen ges i godtycklig ordning, och de speciella posterna ``'.'`` och "
"``'..'`` inkluderas inte.  Om en fil tas bort från eller läggs till i "
"katalogen efter att iteratorn har skapats, är det ospecificerat om ett "
"sökvägsobjekt för den filen inkluderas."

msgid ""
"If the path is not a directory or otherwise inaccessible, :exc:`OSError` is "
"raised."
msgstr ""
"Om sökvägen inte är en katalog eller på annat sätt är otillgänglig, uppstår :"
"exc:`OSError`."

msgid ""
"Glob the given relative *pattern* in the directory represented by this path, "
"yielding all matching files (of any kind)::"
msgstr ""
"Globalisera det angivna relativa *mönstret* i katalogen som representeras av "
"denna sökväg, vilket ger alla matchande filer (av alla slag)::"

msgid ""
">>> sorted(Path('.').glob('*.py'))\n"
"[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib."
"py')]\n"
">>> sorted(Path('.').glob('*/*.py'))\n"
"[PosixPath('docs/conf.py')]\n"
">>> sorted(Path('.').glob('**/*.py'))\n"
"[PosixPath('build/lib/pathlib.py'),\n"
" PosixPath('docs/conf.py'),\n"
" PosixPath('pathlib.py'),\n"
" PosixPath('setup.py'),\n"
" PosixPath('test_pathlib.py')]"
msgstr ""
">>> sorterad(Path('.').glob('*.py'))\n"
"[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib."
"py')]\n"
">>> sorterad(Path('.').glob('*/*.py'))\n"
"[PosixPath('docs/conf.py')]\n"
">>> sorted(Path('.').glob('**/*.py'))\n"
"[PosixPath('build/lib/pathlib.py'),\n"
" PosixPath('docs/conf.py'),\n"
" PosixPath('pathlib.py'),\n"
" PosixPath('setup.py'),\n"
" PosixPath('test_pathlib.py')]"

msgid ""
"By default, or when the *case_sensitive* keyword-only argument is set to "
"``None``, this method matches paths using platform-specific casing rules: "
"typically, case-sensitive on POSIX, and case-insensitive on Windows. Set "
"*case_sensitive* to ``True`` or ``False`` to override this behaviour."
msgstr ""
"Som standard, eller när det enda nyckelordsargumentet *case_sensitive* är "
"inställt på ``None``, matchar den här metoden sökvägar med hjälp av "
"plattformsspecifika regler för skiftlägeskodning: vanligtvis "
"skiftlägeskänsligt på POSIX och skiftlägesokänsligt på Windows. Ställ in "
"*case_sensitive* till ``True`` eller ``False`` för att åsidosätta detta "
"beteende."

msgid ""
"By default, or when the *recurse_symlinks* keyword-only argument is set to "
"``False``, this method follows symlinks except when expanding \"``**``\" "
"wildcards. Set *recurse_symlinks* to ``True`` to always follow symlinks."
msgstr ""
"Som standard, eller när det enda nyckelordsargumentet *recurse_symlinks* är "
"inställt på ``False``, följer den här metoden symolänkar utom när "
"jokertecken \"``**``\" expanderas. Ställ in *recurse_symlinks* till ``True`` "
"för att alltid följa symboliska länkar."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``pathlib.Path.glob`` with "
"arguments ``self``, ``pattern``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``pathlib.Path.glob`` med "
"argumenten ``self``, ``pattern``."

msgid "The *recurse_symlinks* parameter was added."
msgstr "Parametern *recurse_symlinks* har lagts till."

msgid ""
"Any :exc:`OSError` exceptions raised from scanning the filesystem are "
"suppressed. In previous versions, such exceptions are suppressed in many "
"cases, but not all."
msgstr ""
"Alla :exc:`OSError`-undantag som uppstår vid skanning av filsystemet "
"undertrycks. I tidigare versioner undertrycks sådana undantag i många fall, "
"men inte i alla."

msgid ""
"Glob the given relative *pattern* recursively.  This is like calling :func:"
"`Path.glob` with \"``**/``\" added in front of the *pattern*."
msgstr ""
"Globera det givna relativa *mönstret* rekursivt.  Detta är som att anropa :"
"func:`Path.glob` med \"``**/``\" tillagt framför *mönstret*."

msgid ":ref:`pathlib-pattern-language` and :meth:`Path.glob` documentation."
msgstr ":ref:`pathlib-pattern-language` och :meth:`Path.glob` dokumentation."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``pathlib.Path.rglob`` with "
"arguments ``self``, ``pattern``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``pathlib.Path.rglob`` med "
"argumenten ``self``, ``pattern``."

msgid ""
"Generate the file names in a directory tree by walking the tree either top-"
"down or bottom-up."
msgstr ""
"Generera filnamnen i ett katalogträd genom att gå igenom trädet antingen "
"uppifrån och ner eller nerifrån och upp."

msgid ""
"For each directory in the directory tree rooted at *self* (including *self* "
"but excluding '.' and '..'), the method yields a 3-tuple of ``(dirpath, "
"dirnames, filenames)``."
msgstr ""
"För varje katalog i katalogträdet med rot i *self* (inklusive *self* men "
"exklusive '.' och '...') ger metoden en 3-tupel av ``(dirpath, dirnames, "
"filenames)``."

msgid ""
"*dirpath* is a :class:`Path` to the directory currently being walked, "
"*dirnames* is a list of strings for the names of subdirectories in *dirpath* "
"(excluding ``'.'`` and ``'..'``), and *filenames* is a list of strings for "
"the names of the non-directory files in *dirpath*. To get a full path (which "
"begins with *self*) to a file or directory in *dirpath*, do ``dirpath / "
"name``. Whether or not the lists are sorted is file system-dependent."
msgstr ""
"*dirpath* är en :class:`Sökväg` till den katalog som för närvarande gås "
"igenom, *dirnames* är en lista med strängar för namnen på underkataloger i "
"*dirpath* (exklusive ``'.'`` och ``'..'``), och *filenames* är en lista med "
"strängar för namnen på de filer som inte finns i katalogen i *dirpath*. För "
"att få en fullständig sökväg (som börjar med *self*) till en fil eller "
"katalog i *dirpath*, gör ``dirpath / name``. Huruvida listorna är sorterade "
"eller inte är beroende av filsystemet."

msgid ""
"If the optional argument *top_down* is true (which is the default), the "
"triple for a directory is generated before the triples for any of its "
"subdirectories (directories are walked top-down).  If *top_down* is false, "
"the triple for a directory is generated after the triples for all of its "
"subdirectories (directories are walked bottom-up). No matter the value of "
"*top_down*, the list of subdirectories is retrieved before the triples for "
"the directory and its subdirectories are walked."
msgstr ""
"Om det valfria argumentet *top_down* är true (vilket är standard) genereras "
"trippeln för en katalog före tripplarna för någon av dess underkataloger "
"(kataloger gås igenom uppifrån och ned).  Om *top_down* är false genereras "
"trippeln för en katalog efter tripplarna för alla dess underkataloger "
"(kataloger gås igenom nedifrån och upp). Oavsett värdet på *top_down* hämtas "
"listan med underkataloger innan tripplarna för katalogen och dess "
"underkataloger gås igenom."

msgid ""
"When *top_down* is true, the caller can modify the *dirnames* list in-place "
"(for example, using :keyword:`del` or slice assignment), and :meth:`Path."
"walk` will only recurse into the subdirectories whose names remain in "
"*dirnames*. This can be used to prune the search, or to impose a specific "
"order of visiting, or even to inform :meth:`Path.walk` about directories the "
"caller creates or renames before it resumes :meth:`Path.walk` again. "
"Modifying *dirnames* when *top_down* is false has no effect on the behavior "
"of :meth:`Path.walk` since the directories in *dirnames* have already been "
"generated by the time *dirnames* is yielded to the caller."
msgstr ""
"När *top_down* är true kan anroparen ändra *dirnames*-listan på plats (till "
"exempel med :keyword:`del` eller slice assignment), och :meth:`Path.walk` "
"kommer bara att söka i de underkataloger vars namn finns kvar i *dirnames*. "
"Detta kan användas för att begränsa sökningen, eller för att införa en "
"specifik besöksordning, eller till och med för att informera :meth:`Path."
"walk` om kataloger som anroparen skapar eller byter namn på innan den "
"återupptar :meth:`Path.walk` igen. Att ändra *dirnames* när *top_down* är "
"false har ingen effekt på beteendet hos :meth:`Path.walk` eftersom "
"katalogerna i *dirnames* redan har skapats när *dirnames* överlämnas till "
"den som anropar."

msgid ""
"By default, errors from :func:`os.scandir` are ignored.  If the optional "
"argument *on_error* is specified, it should be a callable; it will be called "
"with one argument, an :exc:`OSError` instance. The callable can handle the "
"error to continue the walk or re-raise it to stop the walk. Note that the "
"filename is available as the ``filename`` attribute of the exception object."
msgstr ""
"Som standard ignoreras fel från :func:`os.scandir`.  Om det valfria "
"argumentet *on_error* anges bör det vara en callable; den kommer att anropas "
"med ett argument, en :exc:`OSError`-instans. Anropsobjektet kan hantera "
"felet för att fortsätta vandringen eller ta upp det igen för att stoppa "
"vandringen. Observera att filnamnet är tillgängligt som attributet "
"``filename`` i undantagsobjektet."

msgid ""
"By default, :meth:`Path.walk` does not follow symbolic links, and instead "
"adds them to the *filenames* list. Set *follow_symlinks* to true to resolve "
"symlinks and place them in *dirnames* and *filenames* as appropriate for "
"their targets, and consequently visit directories pointed to by symlinks "
"(where supported)."
msgstr ""
"Som standard följer :meth:`Path.walk` inte symboliska länkar, utan lägger "
"istället till dem i listan *filnamn*. Ange *follow_symlinks* till true för "
"att lösa upp symboliska länkar och placera dem i *dirnames* och *filenames* "
"på lämpligt sätt för deras mål, och följaktligen besöka kataloger som "
"symboliska länkar pekar på (där detta stöds)."

msgid ""
"Be aware that setting *follow_symlinks* to true can lead to infinite "
"recursion if a link points to a parent directory of itself. :meth:`Path."
"walk` does not keep track of the directories it has already visited."
msgstr ""
"Tänk på att om *follow_symlinks* sätts till true kan det leda till oändlig "
"rekursion om en länk pekar på en överordnad katalog till sig själv. :meth:"
"`Path.walk` håller inte reda på vilka kataloger den redan har besökt."

msgid ""
":meth:`Path.walk` assumes the directories it walks are not modified during "
"execution. For example, if a directory from *dirnames* has been replaced "
"with a symlink and *follow_symlinks* is false, :meth:`Path.walk` will still "
"try to descend into it. To prevent such behavior, remove directories from "
"*dirnames* as appropriate."
msgstr ""
":meth:`Path.walk` förutsätter att de kataloger den går igenom inte ändras "
"under körningen. Om till exempel en katalog från *dirnames* har ersatts med "
"en symlänk och *follow_symlinks* är false, kommer :meth:`Path.walk` ändå att "
"försöka gå ner i den. För att förhindra ett sådant beteende ska du ta bort "
"kataloger från *dirnames* på lämpligt sätt."

msgid ""
"Unlike :func:`os.walk`, :meth:`Path.walk` lists symlinks to directories in "
"*filenames* if *follow_symlinks* is false."
msgstr ""
"Till skillnad från :func:`os.walk` listar :meth:`Path.walk` symlänkar till "
"kataloger i *filnamn* om *follow_symlinks* är false."

msgid ""
"This example displays the number of bytes used by all files in each "
"directory, while ignoring ``__pycache__`` directories::"
msgstr ""
"I det här exemplet visas antalet byte som används av alla filer i varje "
"katalog, samtidigt som katalogerna ``__pycache__`` ignoreras::"

msgid ""
"from pathlib import Path\n"
"for root, dirs, files in Path(\"cpython/Lib/concurrent\")."
"walk(on_error=print):\n"
"  print(\n"
"      root,\n"
"      \"consumes\",\n"
"      sum((root / file).stat().st_size for file in files),\n"
"      \"bytes in\",\n"
"      len(files),\n"
"      \"non-directory files\"\n"
"  )\n"
"  if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')"
msgstr ""
"from pathlib import Path\n"
"for root, dirs, files in Path(\"cpython/Lib/concurrent\")."
"walk(on_error=print):\n"
"  print(\n"
"      root,\n"
"      \"consumes\",\n"
"      sum((root / file).stat().st_size for file in files),\n"
"      \"bytes in\",\n"
"      len(files),\n"
"      \"non-directory files\"\n"
"  )\n"
"  if '__pycache__' in dirs:\n"
"        dirs.remove('__pycache__')"

msgid ""
"This next example is a simple implementation of :func:`shutil.rmtree`. "
"Walking the tree bottom-up is essential as :func:`rmdir` doesn't allow "
"deleting a directory before it is empty::"
msgstr ""
"Nästa exempel är en enkel implementation av :func:`shutil.rmtree`. Att gå "
"igenom trädet nerifrån och upp är nödvändigt eftersom :func:`rmdir` inte "
"tillåter att en katalog tas bort innan den är tom:"

msgid ""
"# Delete everything reachable from the directory \"top\".\n"
"# CAUTION:  This is dangerous! For example, if top == Path('/'),\n"
"# it could delete all of your files.\n"
"for root, dirs, files in top.walk(top_down=False):\n"
"    for name in files:\n"
"        (root / name).unlink()\n"
"    for name in dirs:\n"
"        (root / name).rmdir()"
msgstr ""
"# Ta bort allt som går att nå från katalogen \"top\".\n"
"# FÖRSIKTIGHET: Detta är farligt! Till exempel, om top == Path('/'),\n"
"# kan det radera alla dina filer.\n"
"for root, dirs, files in top.walk(top_down=False):\n"
"    för namn i filer:\n"
"        (rot / namn).unlink()\n"
"    för namn i dirs:\n"
"        (rot / namn).rmdir()"

msgid "Creating files and directories"
msgstr "Skapa filer och kataloger"

msgid ""
"Create a file at this given path.  If *mode* is given, it is combined with "
"the process's ``umask`` value to determine the file mode and access flags.  "
"If the file already exists, the function succeeds when *exist_ok* is true "
"(and its modification time is updated to the current time), otherwise :exc:"
"`FileExistsError` is raised."
msgstr ""
"Skapa en fil på den angivna sökvägen.  Om *mode* anges kombineras det med "
"processens ``umask``-värde för att bestämma filens läge och åtkomstflaggor.  "
"Om filen redan finns, lyckas funktionen när *exist_ok* är sant (och dess "
"modifieringstid uppdateras till aktuell tid), annars uppstår :exc:"
"`FileExistsError`."

msgid ""
"The :meth:`~Path.open`, :meth:`~Path.write_text` and :meth:`~Path."
"write_bytes` methods are often used to create files."
msgstr ""
"Metoderna :meth:`~Path.open`, :meth:`~Path.write_text` och :meth:`~Path."
"write_bytes` används ofta för att skapa filer."

msgid ""
"Create a new directory at this given path.  If *mode* is given, it is "
"combined with the process's ``umask`` value to determine the file mode and "
"access flags.  If the path already exists, :exc:`FileExistsError` is raised."
msgstr ""
"Skapa en ny katalog på den angivna sökvägen.  Om *mode* anges kombineras det "
"med processens ``umask``-värde för att bestämma filläge och åtkomstflaggor.  "
"Om sökvägen redan finns kommer :exc:`FileExistsError` att visas."

msgid ""
"If *parents* is true, any missing parents of this path are created as "
"needed; they are created with the default permissions without taking *mode* "
"into account (mimicking the POSIX ``mkdir -p`` command)."
msgstr ""
"Om *parents* är true, skapas alla saknade föräldrar till den här sökvägen "
"vid behov; de skapas med standardbehörigheter utan att *mode* beaktas "
"(efterliknar POSIX-kommandot ``mkdir -p``)."

msgid ""
"If *parents* is false (the default), a missing parent raises :exc:"
"`FileNotFoundError`."
msgstr ""
"Om *parents* är false (standard), orsakar en saknad förälder :exc:"
"`FileNotFoundError`."

msgid ""
"If *exist_ok* is false (the default), :exc:`FileExistsError` is raised if "
"the target directory already exists."
msgstr ""
"Om *exist_ok* är false (standard) kommer :exc:`FileExistsError` att uppstå "
"om målkatalogen redan existerar."

msgid ""
"If *exist_ok* is true, :exc:`FileExistsError` will not be raised unless the "
"given path already exists in the file system and is not a directory (same "
"behavior as the POSIX ``mkdir -p`` command)."
msgstr ""
"Om *exist_ok* är sant kommer :exc:`FileExistsError` inte att uppstå om inte "
"den angivna sökvägen redan finns i filsystemet och inte är en katalog (samma "
"beteende som POSIX-kommandot ``mkdir -p``)."

msgid "The *exist_ok* parameter was added."
msgstr "Parametern *exist_ok* har lagts till."

msgid "Make this path a symbolic link pointing to *target*."
msgstr "Gör den här sökvägen till en symbolisk länk som pekar på *target*."

msgid ""
"On Windows, a symlink represents either a file or a directory, and does not "
"morph to the target dynamically.  If the target is present, the type of the "
"symlink will be created to match. Otherwise, the symlink will be created as "
"a directory if *target_is_directory* is true or a file symlink (the default) "
"otherwise.  On non-Windows platforms, *target_is_directory* is ignored."
msgstr ""
"I Windows representerar en symlänk antingen en fil eller en katalog, och den "
"flyttas inte dynamiskt till målet.  Om målet finns kommer typen av symlänk "
"att skapas så att den matchar. I annat fall skapas symbollänken som en "
"katalog om *target_is_directory* är sant eller som en filsymlänk (standard) "
"i annat fall.  På icke-Windows-plattformar ignoreras *target_is_directory*."

msgid ""
">>> p = Path('mylink')\n"
">>> p.symlink_to('setup.py')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib/setup.py')\n"
">>> p.stat().st_size\n"
"956\n"
">>> p.lstat().st_size\n"
"8"
msgstr ""
">>> p = Sökväg('mylink')\n"
">>> p.symlink_to('setup.py')\n"
">>> p.resolve()\n"
"PosixPath('/home/antoine/pathlib/setup.py')\n"
">>> p.stat().st_size\n"
"956\n"
">>> p.lstat().st_size\n"
"8"

msgid ""
"The order of arguments (link, target) is the reverse of :func:`os.symlink`'s."
msgstr ""
"Ordningen på argumenten (länk, mål) är den omvända mot :func:`os.symlink`."

msgid ""
"Raises :exc:`UnsupportedOperation` if :func:`os.symlink` is not available. "
"In previous versions, :exc:`NotImplementedError` was raised."
msgstr ""
"Utlöser :exc:`UnsupportedOperation` om :func:`os.symlink` inte är "
"tillgänglig. I tidigare versioner gavs :exc:`NotImplementedError`."

msgid "Make this path a hard link to the same file as *target*."
msgstr "Gör den här sökvägen till en hård länk till samma fil som *target*."

msgid ""
"The order of arguments (link, target) is the reverse of :func:`os.link`'s."
msgstr ""
"Ordningen på argumenten (länk, mål) är den omvända mot :func:`os.link`."

msgid ""
"Raises :exc:`UnsupportedOperation` if :func:`os.link` is not available. In "
"previous versions, :exc:`NotImplementedError` was raised."
msgstr ""
"Visar :exc:`UnsupportedOperation` om :func:`os.link` inte är tillgänglig. I "
"tidigare versioner gavs :exc:`NotImplementedError`."

msgid "Copying, moving and deleting"
msgstr "Kopiera, flytta och radera"

msgid ""
"Copy this file or directory tree to the given *target*, and return a new :"
"class:`!Path` instance pointing to *target*."
msgstr ""
"Kopierar detta fil- eller katalogträd till det angivna *målet* och "
"returnerar en ny :class:`!Path`-instans som pekar på *målet*."

msgid ""
"If the source is a file, the target will be replaced if it is an existing "
"file. If the source is a symlink and *follow_symlinks* is true (the "
"default), the symlink's target is copied. Otherwise, the symlink is "
"recreated at the destination."
msgstr ""
"Om källan är en fil kommer målet att ersättas om det är en befintlig fil. Om "
"källan är en symbolisk länk och *follow_symlinks* är true (standard) "
"kopieras den symboliska länkens mål. Annars återskapas symlänken på "
"destinationen."

msgid ""
"If *preserve_metadata* is false (the default), only directory structures and "
"file data are guaranteed to be copied. Set *preserve_metadata* to true to "
"ensure that file and directory permissions, flags, last access and "
"modification times, and extended attributes are copied where supported. This "
"argument has no effect when copying files on Windows (where metadata is "
"always preserved)."
msgstr ""
"Om *preserve_metadata* är false (standard) är det bara katalogstrukturer och "
"fildata som garanterat kopieras. Ange *preserve_metadata* till true för att "
"säkerställa att fil- och katalogbehörigheter, flaggor, senaste åtkomst- och "
"ändringstider samt utökade attribut kopieras där så stöds. Detta argument "
"har ingen effekt vid kopiering av filer i Windows (där metadata alltid "
"bevaras)."

msgid ""
"Where supported by the operating system and file system, this method "
"performs a lightweight copy, where data blocks are only copied when "
"modified. This is known as copy-on-write."
msgstr ""
"Om operativsystemet och filsystemet stöder den här metoden utförs en "
"lättviktskopiering, där datablock endast kopieras när de ändras. Detta är "
"känt som copy-on-write."

msgid ""
"Copy this file or directory tree into the given *target_dir*, which should "
"be an existing directory. Other arguments are handled identically to :meth:"
"`Path.copy`. Returns a new :class:`!Path` instance pointing to the copy."
msgstr ""
"Kopierar detta fil- eller katalogträd till den angivna *target_dir*, som bör "
"vara en befintlig katalog. Andra argument hanteras identiskt med :meth:`Path."
"copy`. Returnerar en ny :class:`!Path`-instans som pekar på kopian."

msgid ""
"Rename this file or directory to the given *target*, and return a new :class:"
"`!Path` instance pointing to *target*.  On Unix, if *target* exists and is a "
"file, it will be replaced silently if the user has permission. On Windows, "
"if *target* exists, :exc:`FileExistsError` will be raised. *target* can be "
"either a string or another path object::"
msgstr ""
"Byt namn på denna fil eller katalog till det angivna *target* och returnera "
"en ny :class:`!Path`-instans som pekar på *target*.  På Unix, om *target* "
"finns och är en fil, kommer den att ersättas tyst om användaren har "
"behörighet. På Windows, om *target* existerar, kommer :exc:`FileExistsError` "
"att uppstå. *target* kan vara antingen en sträng eller ett annat "
"sökvägsobjekt::"

msgid ""
">>> p = Path('foo')\n"
">>> p.open('w').write('some text')\n"
"9\n"
">>> target = Path('bar')\n"
">>> p.rename(target)\n"
"PosixPath('bar')\n"
">>> target.open().read()\n"
"'some text'"
msgstr ""
">>> p = Sökväg('foo')\n"
">>> p.open('w').write('lite text')\n"
"9\n"
">>> mål = sökväg('bar')\n"
">>> p.rename(mål)\n"
"PosixPath('bar')\n"
">>> target.open().read()\n"
"'lite text'"

msgid ""
"The target path may be absolute or relative. Relative paths are interpreted "
"relative to the current working directory, *not* the directory of the :class:"
"`!Path` object."
msgstr ""
"Målsökvägen kan vara absolut eller relativ. Relativa sökvägar tolkas i "
"förhållande till den aktuella arbetskatalogen, *inte* katalogen för :class:`!"
"Path`-objektet."

msgid ""
"It is implemented in terms of :func:`os.rename` and gives the same "
"guarantees."
msgstr "Den implementeras i form av :func:`os.rename` och ger samma garantier."

msgid "Added return value, return the new :class:`!Path` instance."
msgstr "Lagt till returvärde, returnerar den nya :class:`!Path`-instansen."

msgid ""
"Rename this file or directory to the given *target*, and return a new :class:"
"`!Path` instance pointing to *target*.  If *target* points to an existing "
"file or empty directory, it will be unconditionally replaced."
msgstr ""
"Byt namn på denna fil eller katalog till det angivna *target*, och returnera "
"en ny :class:`!Path`-instans som pekar på *target*.  Om *target* pekar på en "
"befintlig fil eller en tom katalog kommer den ovillkorligen att ersättas."

msgid ""
"Move this file or directory tree to the given *target*, and return a new :"
"class:`!Path` instance pointing to *target*."
msgstr ""
"Flytta detta fil- eller katalogträd till det angivna *målet*, och returnera "
"en ny :class:`!Path`-instans som pekar på *målet*."

msgid ""
"If the *target* doesn't exist it will be created. If both this path and the "
"*target* are existing files, then the target is overwritten. If both paths "
"point to the same file or directory, or the *target* is a non-empty "
"directory, then :exc:`OSError` is raised."
msgstr ""
"Om *target* inte finns kommer den att skapas. Om både den här sökvägen och "
"*target* är befintliga filer, skrivs målet över. Om båda sökvägarna pekar på "
"samma fil eller katalog, eller om *target* är en katalog som inte är tom, "
"kommer :exc:`OSError` att skapas."

msgid ""
"If both paths are on the same filesystem, the move is performed with :func:"
"`os.replace`. Otherwise, this path is copied (preserving metadata and "
"symlinks) and then deleted."
msgstr ""
"Om båda sökvägarna finns i samma filsystem utförs flytten med :func:`os."
"replace`. I annat fall kopieras sökvägen (med metadata och symlänkar "
"bevarade) och raderas sedan."

msgid ""
"Move this file or directory tree into the given *target_dir*, which should "
"be an existing directory. Returns a new :class:`!Path` instance pointing to "
"the moved path."
msgstr ""
"Flyttar detta fil- eller katalogträd till den angivna *target_dir*, som bör "
"vara en befintlig katalog. Returnerar en ny :class:`!Path`-instans som pekar "
"på den flyttade sökvägen."

msgid ""
"Remove this file or symbolic link.  If the path points to a directory, use :"
"func:`Path.rmdir` instead."
msgstr ""
"Ta bort denna fil eller symboliska länk.  Om sökvägen pekar på en katalog, "
"använd :func:`Path.rmdir` istället."

msgid ""
"If *missing_ok* is false (the default), :exc:`FileNotFoundError` is raised "
"if the path does not exist."
msgstr ""
"Om *missing_ok* är false (standard) kommer :exc:`FileNotFoundError` att "
"uppstå om sökvägen inte finns."

msgid ""
"If *missing_ok* is true, :exc:`FileNotFoundError` exceptions will be ignored "
"(same behavior as the POSIX ``rm -f`` command)."
msgstr ""
"Om *missing_ok* är true, ignoreras :exc:`FileNotFoundError` (samma beteende "
"som POSIX-kommandot ``rm -f``)."

msgid "The *missing_ok* parameter was added."
msgstr "Parametern *missing_ok* har lagts till."

msgid "Remove this directory.  The directory must be empty."
msgstr "Ta bort den här katalogen.  Katalogen måste vara tom."

msgid "Permissions and ownership"
msgstr "Behörigheter och ägande"

msgid ""
"Return the name of the user owning the file. :exc:`KeyError` is raised if "
"the file's user identifier (UID) isn't found in the system database."
msgstr ""
"Returnerar namnet på den användare som äger filen. :exc:`KeyError` uppstår "
"om filens användaridentifierare (UID) inte finns i systemdatabasen."

msgid ""
"This method normally follows symlinks; to get the owner of the symlink, add "
"the argument ``follow_symlinks=False``."
msgstr ""
"Denna metod följer normalt symlänkar; för att få ägaren till symlänken, lägg "
"till argumentet ``follow_symlinks=False``."

msgid ""
"Raises :exc:`UnsupportedOperation` if the :mod:`pwd` module is not "
"available. In earlier versions, :exc:`NotImplementedError` was raised."
msgstr ""
"Utlöser :exc:`UnsupportedOperation` om modulen :mod:`pwd` inte är "
"tillgänglig. I tidigare versioner gavs :exc:`NotImplementedError`."

msgid ""
"Return the name of the group owning the file. :exc:`KeyError` is raised if "
"the file's group identifier (GID) isn't found in the system database."
msgstr ""
"Returnerar namnet på den grupp som äger filen. :exc:`KeyError` uppstår om "
"filens gruppidentifierare (GID) inte finns i systemdatabasen."

msgid ""
"This method normally follows symlinks; to get the group of the symlink, add "
"the argument ``follow_symlinks=False``."
msgstr ""
"Denna metod följer normalt symlänkar; för att få gruppen i symbollänken, "
"lägg till argumentet ``follow_symlinks=False``."

msgid ""
"Raises :exc:`UnsupportedOperation` if the :mod:`grp` module is not "
"available. In earlier versions, :exc:`NotImplementedError` was raised."
msgstr ""
"Utlöser :exc:`UnsupportedOperation` om modulen :mod:`grp` inte är "
"tillgänglig. I tidigare versioner gavs :exc:`NotImplementedError`."

msgid "Change the file mode and permissions, like :func:`os.chmod`."
msgstr "Ändra filens läge och behörigheter, som :func:`os.chmod`."

msgid ""
"This method normally follows symlinks. Some Unix flavours support changing "
"permissions on the symlink itself; on these platforms you may add the "
"argument ``follow_symlinks=False``, or use :meth:`~Path.lchmod`."
msgstr ""
"Den här metoden följer normalt symlänkar. Vissa Unix-versioner stöder "
"ändring av behörigheter på själva symbollänken; på dessa plattformar kan du "
"lägga till argumentet ``follow_symlinks=False``, eller använda :meth:`~Path."
"lchmod`."

msgid ""
">>> p = Path('setup.py')\n"
">>> p.stat().st_mode\n"
"33277\n"
">>> p.chmod(0o444)\n"
">>> p.stat().st_mode\n"
"33060"
msgstr ""
">>> p = Path('setup.py')\n"
">>> p.stat().st_mode\n"
"33277\n"
">>> p.chmod(0o444)\n"
">>> p.stat().st_mode\n"
"33060"

msgid ""
"Like :meth:`Path.chmod` but, if the path points to a symbolic link, the "
"symbolic link's mode is changed rather than its target's."
msgstr ""
"Som :meth:`Path.chmod`, men om sökvägen pekar på en symbolisk länk ändras "
"den symboliska länkens läge i stället för målets."

msgid "Pattern language"
msgstr "Mönster språk"

msgid ""
"The following wildcards are supported in patterns for :meth:`~PurePath."
"full_match`, :meth:`~Path.glob` and :meth:`~Path.rglob`:"
msgstr ""
"Följande jokertecken stöds i mönster för :meth:`~PurePath.full_match`, :meth:"
"`~Path.glob` och :meth:`~Path.rglob`:"

msgid "``**`` (entire segment)"
msgstr "``**`` (hela segmentet)"

msgid "Matches any number of file or directory segments, including zero."
msgstr "Matchar valfritt antal fil- eller katalogsegment, inklusive noll."

msgid "``*`` (entire segment)"
msgstr "``*`` (hela segmentet)"

msgid "Matches one file or directory segment."
msgstr "Matchar ett fil- eller katalogsegment."

msgid "``*`` (part of a segment)"
msgstr "``*`` (del av ett segment)"

msgid "Matches any number of non-separator characters, including zero."
msgstr "Matchar valfritt antal tecken utan separator, inklusive noll."

msgid "``?``"
msgstr "``?``"

msgid "Matches one non-separator character."
msgstr "Matchar ett tecken utan separator."

msgid "``[seq]``"
msgstr "``[seq]```"

msgid ""
"Matches one character in *seq*, where *seq* is a sequence of characters. "
"Range expressions are supported; for example, ``[a-z]`` matches any "
"lowercase ASCII letter. Multiple ranges can be combined: ``[a-zA-Z0-9_]`` "
"matches any ASCII letter, digit, or underscore."
msgstr ""
"Matchar ett tecken i *seq*, där *seq* är en sekvens av tecken. Uttryck för "
"intervall stöds, t.ex. ``[a-z]`` matchar alla gemena ASCII-bokstäver. Flera "
"intervall kan kombineras: ``[a-zA-Z0-9_]`` matchar alla ASCII-bokstäver, "
"siffror eller understreck."

msgid "``[!seq]``"
msgstr "``[!seq]```"

msgid ""
"Matches one character not in *seq*, where *seq* follows the same rules as "
"above."
msgstr ""
"Matchar ett tecken som inte finns med i *seq*, där *seq* följer samma regler "
"som ovan."

msgid ""
"For a literal match, wrap the meta-characters in brackets. For example, "
"``\"[?]\"`` matches the character ``\"?\"``."
msgstr ""
"För en bokstavlig matchning omsluter du metatecknen inom parentes. Till "
"exempel matchar ``\"[?]\"`` tecknet ``\"?\"``."

msgid "The \"``**``\" wildcard enables recursive globbing. A few examples:"
msgstr "Jokertecknet \"``**``\" möjliggör rekursiv globbing. Några exempel:"

msgid "Pattern"
msgstr "Mönster"

msgid "Meaning"
msgstr "Betydelse"

msgid "\"``**/*``\""
msgstr "\"``**/*``\""

msgid "Any path with at least one segment."
msgstr "Varje väg med minst ett segment."

msgid "\"``**/*.py``\""
msgstr "\"``**/*.py``\""

msgid "Any path with a final segment ending \"``.py``\"."
msgstr "Alla sökvägar med ett slutsegment som slutar på \"``.py``\"."

msgid "\"``assets/**``\""
msgstr "\"``tillgångar/**``\""

msgid "Any path starting with \"``assets/``\"."
msgstr "Alla sökvägar som börjar med \"``assets/``\"."

msgid "\"``assets/**/*``\""
msgstr "\"``tillgångar/**/*``\""

msgid ""
"Any path starting with \"``assets/``\", excluding \"``assets/``\" itself."
msgstr ""
"Alla sökvägar som börjar med \"``assets/``\", utom själva \"``assets/``\"."

msgid ""
"Globbing with the \"``**``\" wildcard visits every directory in the tree. "
"Large directory trees may take a long time to search."
msgstr ""
"Om du använder jokertecknet \"``**``\" besöks alla kataloger i trädet. Stora "
"katalogträd kan ta lång tid att söka igenom."

msgid ""
"Globbing with a pattern that ends with \"``**``\" returns both files and "
"directories. In previous versions, only directories were returned."
msgstr ""
"Globbing med ett mönster som slutar med \"``**``\" returnerar både filer och "
"kataloger. I tidigare versioner returnerades endast kataloger."

msgid ""
"In :meth:`Path.glob` and :meth:`~Path.rglob`, a trailing slash may be added "
"to the pattern to match only directories."
msgstr ""
"I :meth:`Path.glob` och :meth:`~Path.rglob` kan ett efterföljande snedstreck "
"läggas till i mönstret för att endast matcha kataloger."

msgid ""
"Globbing with a pattern that ends with a pathname components separator (:"
"data:`~os.sep` or :data:`~os.altsep`) returns only directories."
msgstr ""
"Globbing med ett mönster som slutar med en komponentavgränsare för "
"sökvägsnamn (:data:`~os.sep` eller :data:`~os.altsep`) returnerar endast "
"kataloger."

msgid "Comparison to the :mod:`glob` module"
msgstr "Jämförelse med :mod:`glob`-modulen"

msgid ""
"The patterns accepted and results generated by :meth:`Path.glob` and :meth:"
"`Path.rglob` differ slightly from those by the :mod:`glob` module:"
msgstr ""
"De mönster som accepteras och de resultat som genereras av :meth:`Path.glob` "
"och :meth:`Path.rglob` skiljer sig något från dem som genereras av modulen :"
"mod:`glob`:"

msgid ""
"Files beginning with a dot are not special in pathlib. This is like passing "
"``include_hidden=True`` to :func:`glob.glob`."
msgstr ""
"Filer som börjar med en punkt är inte speciella i pathlib. Detta är som att "
"skicka ``include_hidden=True`` till :func:`glob.glob`."

msgid ""
"\"``**``\" pattern components are always recursive in pathlib. This is like "
"passing ``recursive=True`` to :func:`glob.glob`."
msgstr ""
"\"``**``\"-mönsterkomponenter är alltid rekursiva i pathlib. Detta är som "
"att skicka ``recursive=True`` till :func:`glob.glob`."

msgid ""
"\"``**``\" pattern components do not follow symlinks by default in pathlib. "
"This behaviour has no equivalent in :func:`glob.glob`, but you can pass "
"``recurse_symlinks=True`` to :meth:`Path.glob` for compatible behaviour."
msgstr ""
"\"``**``\"-mönsterkomponenter följer inte symlinks som standard i pathlib. "
"Detta beteende har ingen motsvarighet i :func:`glob.glob`, men du kan skicka "
"``recurse_symlinks=True`` till :meth:`Path.glob` för ett kompatibelt "
"beteende."

msgid ""
"Like all :class:`PurePath` and :class:`Path` objects, the values returned "
"from :meth:`Path.glob` and :meth:`Path.rglob` don't include trailing slashes."
msgstr ""
"Liksom alla :class:`PurePath`- och :class:`Path`-objekt innehåller de värden "
"som returneras från :meth:`Path.glob` och :meth:`Path.rglob` inte "
"efterföljande snedstreck."

msgid ""
"The values returned from pathlib's ``path.glob()`` and ``path.rglob()`` "
"include the *path* as a prefix, unlike the results of ``glob."
"glob(root_dir=path)``."
msgstr ""
"De värden som returneras från pathlibs ``path.glob()`` och ``path.rglob()`` "
"inkluderar *path* som prefix, till skillnad från resultaten från ``glob."
"glob(root_dir=path)``."

msgid ""
"The values returned from pathlib's ``path.glob()`` and ``path.rglob()`` may "
"include *path* itself, for example when globbing \"``**``\", whereas the "
"results of ``glob.glob(root_dir=path)`` never include an empty string that "
"would correspond to *path*."
msgstr ""
"De värden som returneras från pathlibs ``path.glob()`` och ``path.rglob()`` "
"kan innehålla *path* själv, till exempel vid globbing av \"``**``\", medan "
"resultaten från ``glob.glob(root_dir=path)`` aldrig innehåller en tom sträng "
"som skulle motsvara *path*."

msgid "Comparison to the :mod:`os` and :mod:`os.path` modules"
msgstr "Jämförelse med modulerna :mod:`os` och :mod:`os.path`"

msgid ""
"pathlib implements path operations using :class:`PurePath` and :class:`Path` "
"objects, and so it's said to be *object-oriented*. On the other hand, the :"
"mod:`os` and :mod:`os.path` modules supply functions that work with low-"
"level ``str`` and ``bytes`` objects, which is a more *procedural* approach. "
"Some users consider the object-oriented style to be more readable."
msgstr ""
"pathlib implementerar sökvägsoperationer med hjälp av :class:`PurePath` och :"
"class:`Path`-objekt, och därför sägs den vara *objektorienterad*. Å andra "
"sidan tillhandahåller modulerna :mod:`os` och :mod:`os.path` funktioner som "
"arbetar med lågnivåobjekten ``str`` och ``bytes``, vilket är ett mer "
"*procedurinriktat* tillvägagångssätt. Vissa användare anser att den "
"objektorienterade stilen är mer läsbar."

msgid ""
"Many functions in :mod:`os` and :mod:`os.path` support ``bytes`` paths and :"
"ref:`paths relative to directory descriptors <dir_fd>`. These features "
"aren't available in pathlib."
msgstr ""
"Många funktioner i :mod:`os` och :mod:`os.path` stöder ``bytes``-sökvägar "
"och :ref:``sökvägar relativt katalogbeskrivare <dir_fd>`. Dessa funktioner "
"är inte tillgängliga i pathlib."

msgid ""
"Python's ``str`` and ``bytes`` types, and portions of the :mod:`os` and :mod:"
"`os.path` modules, are written in C and are very speedy. pathlib is written "
"in pure Python and is often slower, but rarely slow enough to matter."
msgstr ""
"Pythons typer ``str`` och ``bytes``, och delar av modulerna :mod:`os` och :"
"mod:`os.path`, är skrivna i C och är mycket snabba. pathlib är skrivet i ren "
"Python och är ofta långsammare, men sällan tillräckligt långsamt för att det "
"ska spela någon roll."

msgid ""
"pathlib's path normalization is slightly more opinionated and consistent "
"than :mod:`os.path`. For example, whereas :func:`os.path.abspath` eliminates "
"\"``..``\" segments from a path, which may change its meaning if symlinks "
"are involved, :meth:`Path.absolute` preserves these segments for greater "
"safety."
msgstr ""
"pathlibs normalisering av sökvägar är något mer åsiktsbaserad och konsekvent "
"än :mod:`os.path`. Till exempel, medan :func:`os.path.abspath` eliminerar "
"\"``..``\"-segment från en sökväg, vilket kan ändra dess betydelse om "
"symlinks är inblandade, bevarar :meth:`Path.absolute` dessa segment för "
"större säkerhet."

msgid ""
"pathlib's path normalization may render it unsuitable for some applications:"
msgstr ""
"pathlibs normalisering av sökvägar kan göra den olämplig för vissa "
"applikationer:"

msgid ""
"pathlib normalizes ``Path(\"my_folder/\")`` to ``Path(\"my_folder\")``, "
"which changes a path's meaning when supplied to various operating system "
"APIs and command-line utilities. Specifically, the absence of a trailing "
"separator may allow the path to be resolved as either a file or directory, "
"rather than a directory only."
msgstr ""
"pathlib normaliserar ``Path(\"my_folder/\")`` till ``Path(\"my_folder\")``, "
"vilket ändrar en sökvägs betydelse när den tillhandahålls till olika API:er "
"för operativsystem och kommandoradsverktyg. I synnerhet kan avsaknaden av en "
"efterföljande separator göra det möjligt att lösa sökvägen som antingen en "
"fil eller en katalog, snarare än bara en katalog."

msgid ""
"pathlib normalizes ``Path(\"./my_program\")`` to ``Path(\"my_program\")``, "
"which changes a path's meaning when used as an executable search path, such "
"as in a shell or when spawning a child process. Specifically, the absence of "
"a separator in the path may force it to be looked up in :envvar:`PATH` "
"rather than the current directory."
msgstr ""
"pathlib normaliserar ``Path(\"./my_program\")`` till "
"``Path(\"my_program\")``, vilket ändrar en sökvägs betydelse när den används "
"som sökväg för körbara program, t.ex. i ett skal eller när en underordnad "
"process startas. Specifikt kan avsaknaden av en separator i sökvägen tvinga "
"den att letas upp i :envvar:`PATH` i stället för i den aktuella katalogen."

msgid ""
"As a consequence of these differences, pathlib is not a drop-in replacement "
"for :mod:`os.path`."
msgstr ""
"Som en följd av dessa skillnader är pathlib inte en direkt ersättning för :"
"mod:`os.path`."

msgid "Corresponding tools"
msgstr "Motsvarande verktyg"

msgid ""
"Below is a table mapping various :mod:`os` functions to their corresponding :"
"class:`PurePath`/:class:`Path` equivalent."
msgstr ""
"Nedan finns en tabell som mappar olika :mod:`os`-funktioner till deras "
"motsvarande :class:`PurePath`/:class:`Path`-ekvivalenter."

msgid ":mod:`os` and :mod:`os.path`"
msgstr ":mod:`os` och :mod:`os.path`"

msgid ":mod:`pathlib`"
msgstr ":mod:`pathlib`"

msgid ":func:`os.path.dirname`"
msgstr ":func:`os.sökväg.dirnamn`"

msgid ":attr:`PurePath.parent`"
msgstr ":attr:`PurePath.förälder`"

msgid ":func:`os.path.basename`"
msgstr ":func:`os.sökväg.basnamn`"

msgid ":attr:`PurePath.name`"
msgstr ":attr:`PurePath.namn`"

msgid ":func:`os.path.splitext`"
msgstr ":func:`os.sökväg.splitext`"

msgid ":attr:`PurePath.stem`, :attr:`PurePath.suffix`"
msgstr ":attr:`PurePath.stem`, :attr:`PurePath.suffix`"

msgid ":func:`os.path.join`"
msgstr ":func:`os.sökväg.join`"

msgid ":meth:`PurePath.joinpath`"
msgstr ":meth:`PurePath.joinpath`"

msgid ":func:`os.path.isabs`"
msgstr ":func:`os.path.isabs``"

msgid ":meth:`PurePath.is_absolute`"
msgstr ":meth:`PurePath.is_absolute`"

msgid ":func:`os.path.relpath`"
msgstr ":func:`os.path.relpath`"

msgid ":meth:`PurePath.relative_to` [1]_"
msgstr ":meth:`PurePath.relative_to` [1]_"

msgid ":func:`os.path.expanduser`"
msgstr ":func:`os.path.expanduser`"

msgid ":meth:`Path.expanduser` [2]_"
msgstr ":meth:`Path.expanduser` [2]_"

msgid ":func:`os.path.realpath`"
msgstr ":func:`os.path.realpath`"

msgid ":meth:`Path.resolve`"
msgstr ":meth:`Path.resolve`"

msgid ":func:`os.path.abspath`"
msgstr ":func:`os.path.abspath`"

msgid ":meth:`Path.absolute` [3]_"
msgstr ":meth:`Sökväg.absolut` [3]_"

msgid ":func:`os.path.exists`"
msgstr ":func:`os.path.exists`"

msgid ":meth:`Path.exists`"
msgstr ":meth:`Sökväg.finns`"

msgid ":func:`os.path.isfile`"
msgstr ":func:`os.path.isfile`"

msgid ":meth:`Path.is_file`"
msgstr ":meth:`Path.is_file`"

msgid ":func:`os.path.isdir`"
msgstr ":func:`os.sökväg.isdir`"

msgid ":meth:`Path.is_dir`"
msgstr ":meth:`Path.is_dir`"

msgid ":func:`os.path.islink`"
msgstr ":func:`os.sökväg.islink`"

msgid ":meth:`Path.is_symlink`"
msgstr ":meth:`Sökväg.is_symlänk`"

msgid ":func:`os.path.isjunction`"
msgstr ":func:`os.path.isjunction`"

msgid ":meth:`Path.is_junction`"
msgstr ":meth:`Sökväg.is_junction`"

msgid ":func:`os.path.ismount`"
msgstr ":func:`os.sökväg.ismount`"

msgid ":meth:`Path.is_mount`"
msgstr ":meth:`Path.is_mount`"

msgid ":func:`os.path.samefile`"
msgstr ":func:`os.sökväg.samefile`"

msgid ":meth:`Path.samefile`"
msgstr ":meth:`Sökväg.samefile`"

msgid ":func:`os.getcwd`"
msgstr ":func:`os.getcwd`"

msgid ":meth:`Path.cwd`"
msgstr ":meth:`Sökväg.cwd`"

msgid ":func:`os.stat`"
msgstr ":func:`os.stat`"

msgid ":meth:`Path.stat`"
msgstr ":meth:`Sökväg.stat`"

msgid ":func:`os.lstat`"
msgstr ":func:`os.lstat`"

msgid ":meth:`Path.lstat`"
msgstr ":meth:`Sökväg.lstat`"

msgid ":func:`os.listdir`"
msgstr ":func:`os.listdir`"

msgid ":meth:`Path.iterdir`"
msgstr ":meth:`Sökväg.iterdir`"

msgid ":func:`os.walk`"
msgstr ":func:`os.walk`"

msgid ":meth:`Path.walk` [4]_"
msgstr ":meth:`Path.walk` [4]_"

msgid ":func:`os.mkdir`, :func:`os.makedirs`"
msgstr ":func:`os.mkdir`, :func:`os.makedirs`, :func:`os.makedirs`"

msgid ":meth:`Path.mkdir`"
msgstr ":meth:`Sökväg.mkdir`"

msgid ":func:`os.link`"
msgstr ":func:`os.länk`"

msgid ":meth:`Path.hardlink_to`"
msgstr ":meth:`Sökväg.hårdlänk_till`"

msgid ":func:`os.symlink`"
msgstr ":func:`os.symlänk`"

msgid ":meth:`Path.symlink_to`"
msgstr ":meth:`Path.symlink_to`"

msgid ":func:`os.readlink`"
msgstr ":func:`os.readlink`"

msgid ":meth:`Path.readlink`"
msgstr ":meth:`Sökväg.läslänk`"

msgid ":func:`os.rename`"
msgstr ":func:`os.rename`"

msgid ":meth:`Path.rename`"
msgstr ":meth:`Path.rename`"

msgid ":func:`os.replace`"
msgstr ":func:`os.replace`"

msgid ":meth:`Path.replace`"
msgstr ":meth:`Sökväg.ersätt`"

msgid ":func:`os.remove`, :func:`os.unlink`"
msgstr ":func:`os.remove`, :func:`os.unlink`"

msgid ":meth:`Path.unlink`"
msgstr ":meth:`Path.unlink`"

msgid ":func:`os.rmdir`"
msgstr ":func:`os.rmdir`"

msgid ":meth:`Path.rmdir`"
msgstr ":meth:`Sökväg.rmdir`"

msgid ":func:`os.chmod`"
msgstr ":func:`os.chmod`"

msgid ":meth:`Path.chmod`"
msgstr ":meth:`Sökväg.chmod`"

msgid ":func:`os.lchmod`"
msgstr ":func:`os.lchmod`"

msgid ":meth:`Path.lchmod`"
msgstr ":meth:`Sökväg.lchmod`"

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
":func:`os.path.relpath` calls :func:`~os.path.abspath` to make paths "
"absolute and remove \"``..``\" parts, whereas :meth:`PurePath.relative_to` "
"is a lexical operation that raises :exc:`ValueError` when its inputs' "
"anchors differ (e.g. if one path is absolute and the other relative.)"
msgstr ""
":func:`os.path.relpath` anropar :func:`~os.path.abspath` för att göra "
"sökvägar absoluta och ta bort \"``..``\"-delar, medan :meth:`PurePath."
"relative_to` är en lexikal operation som ger upphov till :exc:`ValueError` "
"när dess ingångars ankare skiljer sig åt (t.ex. om en sökväg är absolut och "
"den andra relativ)"

msgid ""
":func:`os.path.expanduser` returns the path unchanged if the home directory "
"can't be resolved, whereas :meth:`Path.expanduser` raises :exc:"
"`RuntimeError`."
msgstr ""
":func:`os.path.expanduser` returnerar sökvägen oförändrad om hemkatalogen "
"inte kan lösas, medan :meth:`Path.expanduser` ger upphov till :exc:"
"`RuntimeError`."

msgid ""
":func:`os.path.abspath` removes \"``..``\" components without resolving "
"symlinks, which may change the meaning of the path, whereas :meth:`Path."
"absolute` leaves any \"``..``\" components in the path."
msgstr ""
":func:`os.path.abspath` tar bort \"``..``\"-komponenter utan att lösa "
"symlänkar, vilket kan ändra sökvägens betydelse, medan :meth:`Path.absolute` "
"lämnar kvar alla \"``..``\"-komponenter i sökvägen."

msgid ""
":func:`os.walk` always follows symlinks when categorizing paths into "
"*dirnames* and *filenames*, whereas :meth:`Path.walk` categorizes all "
"symlinks into *filenames* when *follow_symlinks* is false (the default.)"
msgstr ""
":func:`os.walk` följer alltid symlänkar när sökvägar kategoriseras i "
"*katalognamn* och *filnamn*, medan :meth:`Path.walk` kategoriserar alla "
"symlänkar i *filnamn* när *follow_symlinks* är false (standard)"

msgid "Protocols"
msgstr "Protokoll"

msgid ""
"The :mod:`pathlib.types` module provides types for static type checking."
msgstr ""
"Modulen :mod:`pathlib.types` tillhandahåller typer för statisk typkontroll."

msgid ""
"A :class:`typing.Protocol` describing the :attr:`Path.info <pathlib.Path."
"info>` attribute. Implementations may return cached results from their "
"methods."
msgstr ""
"En :class:`typing.Protocol` som beskriver attributet :attr:`Path.info "
"<pathlib.Path.info>`. Implementationer kan returnera cachade resultat från "
"sina metoder."

msgid ""
"Return ``True`` if the path is an existing file or directory, or any other "
"kind of file; return ``False`` if the path doesn't exist."
msgstr ""
"Returnerar ``True`` om sökvägen är en befintlig fil eller katalog, eller "
"någon annan typ av fil; returnerar ``False`` om sökvägen inte finns."

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` for symlinks without "
"checking if their targets exist."
msgstr ""
"Om *follow_symlinks* är ``False``, returneras ``True`` för symlinks utan att "
"kontrollera om deras mål existerar."

msgid ""
"Return ``True`` if the path is a directory, or a symbolic link pointing to a "
"directory; return ``False`` if the path is (or points to) any other kind of "
"file, or if it doesn't exist."
msgstr ""
"Returnerar ``True`` om sökvägen är en katalog, eller en symbolisk länk som "
"pekar på en katalog; returnerar ``False`` om sökvägen är (eller pekar på) "
"någon annan typ av fil, eller om den inte finns."

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if the path is a "
"directory (without following symlinks); return ``False`` if the path is any "
"other kind of file, or if it doesn't exist."
msgstr ""
"Om *follow_symlinks* är ``False``, returneras ``True`` endast om sökvägen är "
"en katalog (utan att följa symlinks); returneras ``False`` om sökvägen är "
"någon annan typ av fil, eller om den inte finns."

msgid ""
"Return ``True`` if the path is a file, or a symbolic link pointing to a "
"file; return ``False`` if the path is (or points to) a directory or other "
"non-file, or if it doesn't exist."
msgstr ""
"Returnerar ``True`` om sökvägen är en fil eller en symbolisk länk som pekar "
"på en fil; returnerar ``False`` om sökvägen är (eller pekar på) en katalog "
"eller annan icke-fil, eller om den inte finns."

msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if the path is a "
"file (without following symlinks); return ``False`` if the path is a "
"directory or other non-file, or if it doesn't exist."
msgstr ""
"Om *follow_symlinks* är ``False``, returneras ``True`` endast om sökvägen är "
"en fil (utan att följa symlinks); returneras ``False`` om sökvägen är en "
"katalog eller annan icke-fil, eller om den inte finns."

msgid ""
"Return ``True`` if the path is a symbolic link (even if broken); return "
"``False`` if the path is a directory or any kind of file, or if it doesn't "
"exist."
msgstr ""
"Returnerar ``True`` om sökvägen är en symbolisk länk (även om den är "
"bruten); returnerar ``False`` om sökvägen är en katalog eller någon annan "
"typ av fil, eller om den inte finns."

msgid "path"
msgstr "väg"

msgid "operations"
msgstr "verksamhet"
