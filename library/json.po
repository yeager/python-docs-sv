# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!json` --- JSON encoder and decoder"
msgstr ":mod:`!json` --- JSON-kodare och -avkodare"

msgid "**Source code:** :source:`Lib/json/__init__.py`"
msgstr "**Källkod:** :source:`Lib/json/__init__.py`"

msgid ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, specified by :rfc:"
"`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_, is a "
"lightweight data interchange format inspired by `JavaScript <https://en."
"wikipedia.org/wiki/JavaScript>`_ object literal syntax (although it is not a "
"strict subset of JavaScript [#rfc-errata]_ )."
msgstr ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, specificerat av :"
"rfc:`7159` (som föråldrar :rfc:`4627`) och av `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_, är ett "
"lättviktigt datautbytesformat inspirerat av `JavaScript <https://en."
"wikipedia.org/wiki/JavaScript>`_ objektlitteral syntax (även om det inte är "
"en strikt delmängd av JavaScript [#rfc-errata]_ )."

msgid ""
"The term \"object\" in the context of JSON processing in Python can be "
"ambiguous. All values in Python are objects. In JSON, an object refers to "
"any data wrapped in curly braces, similar to a Python dictionary."
msgstr ""
"Termen \"objekt\" i samband med JSON-bearbetning i Python kan vara tvetydig. "
"Alla värden i Python är objekt. I JSON avser ett objekt alla data som är "
"förpackade inom hakparenteser, på samma sätt som en Python-ordbok."

msgid ""
"Be cautious when parsing JSON data from untrusted sources. A malicious JSON "
"string may cause the decoder to consume considerable CPU and memory "
"resources. Limiting the size of data to be parsed is recommended."
msgstr ""
"Var försiktig när du analyserar JSON-data från otillförlitliga källor. En "
"skadlig JSON-sträng kan leda till att avkodaren förbrukar betydande CPU- och "
"minnesresurser. Vi rekommenderar att du begränsar storleken på de data som "
"ska analyseras."

msgid ""
"This module exposes an API familiar to users of the standard library :mod:"
"`marshal` and :mod:`pickle` modules."
msgstr ""
"Denna modul exponerar ett API som är bekant för användare av "
"standardbibliotekets moduler :mod:`marshal` och :mod:`pickle`."

msgid "Encoding basic Python object hierarchies::"
msgstr "Kodning av grundläggande Python-objekthierarkier::"

msgid ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"
msgstr ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"

msgid "Compact encoding::"
msgstr "Kompakt kodning::"

msgid ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"
msgstr ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"

msgid "Pretty printing::"
msgstr "Vacker utskrift::"

msgid ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"
msgstr ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"

msgid "Customizing JSON object encoding::"
msgstr "Anpassa kodning av JSON-objekt::"

msgid ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj."
"imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"
msgstr ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj."
"imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"

msgid "Decoding JSON::"
msgstr "Avkodning av JSON::"

msgid ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"
msgstr ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"

msgid "Customizing JSON object decoding::"
msgstr "Anpassa avkodning av JSON-objekt::"

msgid ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"
msgstr ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"

msgid "Extending :class:`JSONEncoder`::"
msgstr "Förlängning av :class:`JSONEncoder`::"

msgid ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"
msgstr ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"

msgid "Using :mod:`json` from the shell to validate and pretty-print:"
msgstr "Använda :mod:`json` från skalet för att validera och skriva ut snyggt:"

msgid ""
"$ echo '{\"json\":\"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\":\"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

msgid "See :ref:`json-commandline` for detailed documentation."
msgstr "Se :ref:`json-commandline` för detaljerad dokumentation."

msgid ""
"JSON is a subset of `YAML <https://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""
"JSON är en underdel av `YAML <https://yaml.org/>`_ 1.2.  Den JSON som "
"produceras av den här modulens standardinställningar (i synnerhet "
"standardvärdet *separators*) är också en delmängd av YAML 1.0 och 1.1.  Den "
"här modulen kan därför också användas som en YAML-serialisator."

msgid ""
"This module's encoders and decoders preserve input and output order by "
"default.  Order is only lost if the underlying containers are unordered."
msgstr ""
"Den här modulens kodare och avkodare bevarar inmatnings- och "
"utmatningsordning som standard.  Ordningen går bara förlorad om de "
"underliggande behållarna är oordnade."

msgid "Basic Usage"
msgstr "Grundläggande användning"

msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a ``.write()``-"
"supporting :term:`file-like object`) using this :ref:`Python-to-JSON "
"conversion table <py-to-json-table>`."
msgstr ""
"Serialisera *obj* som en JSON-formaterad ström till *fp* (ett ``.write()``-"
"stödjande :term:`filliknande objekt`) med hjälp av denna :ref:`Python-"
"tillJSON-konverteringstabell <py-to-json-table>`."

msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""
"Till skillnad från :mod:`pickle` och :mod:`marshal` är JSON inte ett inramat "
"protokoll, så försök att serialisera flera objekt med upprepade anrop till :"
"func:`dump` med samma *fp* kommer att resultera i en ogiltig JSON-fil."

msgid "Parameters"
msgstr "Parametrar"

msgid "The Python object to be serialized."
msgstr "Python-objektet som ska serialiseras."

msgid ""
"The file-like object *obj* will be serialized to. The :mod:`!json` module "
"always produces :class:`str` objects, not :class:`bytes` objects, therefore "
"``fp.write()`` must support :class:`str` input."
msgstr ""
"Det filliknande objekt som *obj* ska serialiseras till. Modulen :mod:`!json` "
"producerar alltid :class:`str` objekt, inte :class:`bytes` objekt, därför "
"måste ``fp.write()`` stödja :class:`str` indata."

msgid ""
"If ``True``, keys that are not of a basic type (:class:`str`, :class:`int`, :"
"class:`float`, :class:`bool`, ``None``) will be skipped instead of raising "
"a :exc:`TypeError`. Default ``False``."
msgstr ""
"Om ``True``, kommer nycklar som inte är av en grundläggande typ (:class:"
"`str`, :class:`int`, :class:`float`, :class:`bool`, ``None``) att hoppas "
"över istället för att ge upphov till ett :exc:`TypeError`. Standard "
"``False``."

msgid ""
"If ``True`` (the default), the output is guaranteed to have all incoming non-"
"ASCII characters escaped. If ``False``, these characters will be outputted "
"as-is."
msgstr ""
"Om ``True`` (standard) garanteras att alla inkommande icke-ASCII-tecken i "
"utdata är escapade. Om ``False``, kommer dessa tecken att matas ut som de är."

msgid ""
"If ``False``, the circular reference check for container types is skipped "
"and a circular reference will result in a :exc:`RecursionError` (or worse). "
"Default ``True``."
msgstr ""
"Om ``False``, hoppar man över kontrollen av cirkulära referenser för "
"containertyper och en cirkulär referens resulterar i ett :exc:"
"`RecursionError` (eller värre). Standard ``True``."

msgid ""
"If ``False``, serialization of out-of-range :class:`float` values (``nan``, "
"``inf``, ``-inf``) will result in a :exc:`ValueError`, in strict compliance "
"with the JSON specification. If ``True`` (the default), their JavaScript "
"equivalents (``NaN``, ``Infinity``, ``-Infinity``) are used."
msgstr ""
"Om ``False``, serialisering av out-of-range :class:`float`-värden (``nan``, "
"``inf``, ``-inf``) kommer att resultera i en :exc:`ValueError`, i strikt "
"överensstämmelse med JSON-specifikationen. Om ``True`` (standard), används "
"deras JavaScript-ekvivalenter (``NaN``, ``Infinity``, ``-Infinity``)."

msgid ""
"If set, a custom JSON encoder with the :meth:`~JSONEncoder.default` method "
"overridden, for serializing into custom datatypes. If ``None`` (the "
"default), :class:`!JSONEncoder` is used."
msgstr ""
"Om inställd, en anpassad JSON-kodare med :meth:`~JSONEncoder.default`-"
"metoden åsidosatt, för serialisering till anpassade datatyper. Om ``None`` "
"(standard) används :class:`!JSONEncoder`."

msgid ""
"If a positive integer or string, JSON array elements and object members will "
"be pretty-printed with that indent level. A positive integer indents that "
"many spaces per level; a string (such as ``\"\\t\"``) is used to indent each "
"level. If zero, negative, or ``\"\"`` (the empty string), only newlines are "
"inserted. If ``None`` (the default), the most compact representation is used."
msgstr ""
"Om det är ett positivt heltal eller en sträng kommer JSON-arrayelement och "
"objektmedlemmar att skrivas ut med den indragsnivån. Ett positivt heltal "
"indenterar så många mellanslag per nivå; en sträng (t.ex. ``\"\\t\"``) "
"används för att indentera varje nivå. Om noll, negativt eller ``\"\"`` (den "
"tomma strängen) infogas endast nya rader. Om ``None`` (standard) används den "
"mest kompakta representationen."

msgid ""
"A two-tuple: ``(item_separator, key_separator)``. If ``None`` (the default), "
"*separators* defaults to ``(', ', ': ')`` if *indent* is ``None``, and "
"``(',', ': ')`` otherwise. For the most compact JSON, specify ``(',', ':')`` "
"to eliminate whitespace."
msgstr ""
"En två-tupel: ``(item_separator, key_separator)``. Om ``None`` (standard), "
"är *separators* standard ``(', ', ': ')`` om *indent* är ``None``, och "
"``(',', ': ')`` annars. För den mest kompakta JSON, ange ``(',', ':')`` för "
"att eliminera blanksteg."

msgid ""
"A function that is called for objects that can't otherwise be serialized. It "
"should return a JSON encodable version of the object or raise a :exc:"
"`TypeError`. If ``None`` (the default), :exc:`!TypeError` is raised."
msgstr ""
"En funktion som anropas för objekt som inte kan serialiseras på annat sätt. "
"Den ska returnera en JSON-kodbar version av objektet eller ge upphov till "
"ett :exc:`TypeError`. Om ``None`` (standard), kommer :exc:`!TypeError` att "
"returneras."

msgid ""
"If ``True``, dictionaries will be outputted sorted by key. Default ``False``."
msgstr ""
"Om ``True``, kommer ordböcker att matas ut sorterade efter nyckel. Standard "
"``False``."

msgid "Allow strings for *indent* in addition to integers."
msgstr "Tillåt strängar för *indent* i tillägg till heltal."

msgid "Use ``(',', ': ')`` as default if *indent* is not ``None``."
msgstr "Använd ``(',', ': ')`` som standard om *indent* inte är ``None``."

msgid ""
"All optional parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr ""
"Alla valfria parametrar är nu :ref:`keyword-only <keyword-only_parameter>`."

msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion "
"table <py-to-json-table>`.  The arguments have the same meaning as in :func:"
"`dump`."
msgstr ""
"Serialiserar *obj* till en JSON-formaterad :class:`str` med hjälp av denna :"
"ref:`konverteringstabell <py-to-json-table>`.  Argumenten har samma "
"betydelse som i :func:`dump`."

msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""
"Nycklar i nyckel/värde-par i JSON är alltid av typen :class:`str`. När en "
"ordbok konverteras till JSON omvandlas alla nycklar i ordboken till "
"strängar. Om en ordbok konverteras till JSON och sedan tillbaka till en "
"ordbok kan det därför hända att ordboken inte motsvarar den ursprungliga. "
"Det vill säga, ``loads(dumps(x)) != x`` om x har nycklar som inte är "
"strängar."

msgid ""
"Deserialize *fp* to a Python object using the :ref:`JSON-to-Python "
"conversion table <json-to-py-table>`."
msgstr ""
"Deserialisera *fp* till ett Python-objekt med hjälp av :ref:``JSON-till-"
"Python-konverteringstabell <json-to-py-table>``."

msgid ""
"A ``.read()``-supporting :term:`text file` or :term:`binary file` containing "
"the JSON document to be deserialized."
msgstr ""
"En ``.read()``-stödjande :term:`textfil` eller :term:`binärfil` som "
"innehåller det JSON-dokument som ska deserialiseras."

msgid ""
"If set, a custom JSON decoder. Additional keyword arguments to :func:`!load` "
"will be passed to the constructor of *cls*. If ``None`` (the default), :"
"class:`!JSONDecoder` is used."
msgstr ""
"Om inställd, en anpassad JSON-avkodare. Ytterligare nyckelordsargument till :"
"func:`!load` kommer att skickas till konstruktören av *cls*. Om ``None`` "
"(standard), används :class:`!JSONDecoder`."

msgid ""
"If set, a function that is called with the result of any JSON object literal "
"decoded (a :class:`dict`). The return value of this function will be used "
"instead of the :class:`dict`. This feature can be used to implement custom "
"decoders, for example `JSON-RPC <https://www.jsonrpc.org>`_ class hinting. "
"Default ``None``."
msgstr ""
"Om inställd, en funktion som anropas med resultatet av en JSON-"
"objektlitteral som avkodats (en :class:`dict`). Returvärdet för denna "
"funktion kommer att användas istället för :class:`dict`. Denna funktion kan "
"användas för att implementera anpassade avkodare, till exempel `JSON-RPC "
"<https://www.jsonrpc.org>`_ class hinting. Standard ``None``."

msgid ""
"If set, a function that is called with the result of any JSON object literal "
"decoded with an ordered list of pairs. The return value of this function "
"will be used instead of the :class:`dict`. This feature can be used to "
"implement custom decoders. If *object_hook* is also set, *object_pairs_hook* "
"takes priority. Default ``None``."
msgstr ""
"Om inställd, en funktion som anropas med resultatet av en JSON-"
"objektlitteral som avkodas med en ordnad lista av par. Returvärdet för denna "
"funktion kommer att användas i stället för :class:`dict`. Den här funktionen "
"kan användas för att implementera anpassade avkodare. Om *object_hook* också "
"är inställd, har *object_pairs_hook* prioritet. Standard ``None``."

msgid ""
"If set, a function that is called with the string of every JSON float to be "
"decoded. If ``None`` (the default), it is equivalent to ``float(num_str)``. "
"This can be used to parse JSON floats into custom datatypes, for example :"
"class:`decimal.Decimal`."
msgstr ""
"Om den är inställd, en funktion som anropas med strängen för varje JSON-flat "
"som ska avkodas. Om ``None`` (standard), är det likvärdigt med "
"``float(num_str)``. Detta kan användas för att analysera JSON-flottor till "
"anpassade datatyper, t.ex. :class:`decimal.Decimal`."

msgid ""
"If set, a function that is called with the string of every JSON int to be "
"decoded. If ``None`` (the default), it is equivalent to ``int(num_str)``. "
"This can be used to parse JSON integers into custom datatypes, for example :"
"class:`float`."
msgstr ""
"Om den är inställd, en funktion som anropas med strängen för varje JSON int "
"som ska avkodas. Om ``None`` (standard), är det likvärdigt med "
"``int(num_str)``. Detta kan användas för att analysera JSON heltal till "
"anpassade datatyper, t.ex. :class:`float`."

msgid ""
"If set, a function that is called with one of the following strings: ``'-"
"Infinity'``, ``'Infinity'``, or ``'NaN'``. This can be used to raise an "
"exception if invalid JSON numbers are encountered. Default ``None``."
msgstr ""
"Om den är inställd, en funktion som anropas med en av följande strängar: ``'-"
"Infinity'``, ``'Infinity'`` eller ``'NaN'``. Detta kan användas för att "
"skapa ett undantag om ogiltiga JSON-nummer påträffas. Standard ``None``."

msgid "Raises"
msgstr "Höjer"

msgid "When the data being deserialized is not a valid JSON document."
msgstr "När de data som deserialiseras inte är ett giltigt JSON-dokument."

msgid ""
"When the data being deserialized does not contain UTF-8, UTF-16 or UTF-32 "
"encoded data."
msgstr ""
"När de data som deserialiseras inte innehåller UTF-8-, UTF-16- eller UTF-32-"
"kodade data."

msgid "Added the optional *object_pairs_hook* parameter."
msgstr "Lagt till den valfria parametern *object_pairs_hook*."

msgid "*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr "*parse_constant* anropas inte längre på 'null', 'true', 'false'."

msgid ""
"*fp* can now be a :term:`binary file`. The input encoding should be UTF-8, "
"UTF-16 or UTF-32."
msgstr ""
"*fp* kan nu vara en :term:`binärfil`. Kodningen för indata bör vara UTF-8, "
"UTF-16 eller UTF-32."

msgid ""
"The default *parse_int* of :func:`int` now limits the maximum length of the "
"integer string via the interpreter's :ref:`integer string conversion length "
"limitation <int_max_str_digits>` to help avoid denial of service attacks."
msgstr ""
"Standardvärdet *parse_int* för :func:`int` begränsar nu den maximala längden "
"på heltalssträngen via tolkens :ref:`Längdsbegränsning för konvertering av "
"heltalssträngar <int_max_str_digits>` för att undvika "
"överbelastningsattacker."

msgid ""
"Identical to :func:`load`, but instead of a file-like object, deserialize "
"*s* (a :class:`str`, :class:`bytes` or :class:`bytearray` instance "
"containing a JSON document) to a Python object using this :ref:`conversion "
"table <json-to-py-table>`."
msgstr ""
"Identiskt med :func:`load`, men istället för ett filliknande objekt, "
"deserialisera *s* (en :class:`str`, :class:`bytes` eller :class:`bytearray`-"
"instans som innehåller ett JSON-dokument) till ett Python-objekt med hjälp "
"av denna :ref:`konverteringstabell <json-to-py-table>`."

msgid ""
"*s* can now be of type :class:`bytes` or :class:`bytearray`. The input "
"encoding should be UTF-8, UTF-16 or UTF-32."
msgstr ""
"*s* kan nu vara av typen :class:`bytes` eller :class:`bytearray`. Kodningen "
"för indata bör vara UTF-8, UTF-16 eller UTF-32."

msgid "The keyword argument *encoding* has been removed."
msgstr "Nyckelordsargumentet *encoding* har tagits bort."

msgid "Encoders and Decoders"
msgstr "Kodare och avkodare"

msgid "Simple JSON decoder."
msgstr "Enkel JSON-avkodare."

msgid "Performs the following translations in decoding by default:"
msgstr "Utför följande översättningar vid avkodning som standard:"

msgid "JSON"
msgstr "JSON"

msgid "Python"
msgstr "Python"

msgid "object"
msgstr "object"

msgid "dict"
msgstr "dict"

msgid "array"
msgstr "array"

msgid "list"
msgstr "list"

msgid "string"
msgstr "string"

msgid "str"
msgstr "str"

msgid "number (int)"
msgstr "number (int)"

msgid "int"
msgstr "int"

msgid "number (real)"
msgstr "number (real)"

msgid "float"
msgstr "float"

msgid "true"
msgstr "true"

msgid "True"
msgstr "True"

msgid "false"
msgstr "false"

msgid "False"
msgstr "False"

msgid "null"
msgstr "null"

msgid "None"
msgstr "None"

msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr ""
"Den förstår också ``NaN``, ``Infinity`` och ``-Infinity`` som deras "
"motsvarande ``float``-värden, vilket ligger utanför JSON-specifikationen."

msgid ""
"*object_hook* is an optional function that will be called with the result of "
"every JSON object decoded and its return value will be used in place of the "
"given :class:`dict`.  This can be used to provide custom deserializations (e."
"g. to support `JSON-RPC <https://www.jsonrpc.org>`_ class hinting)."
msgstr ""
"*object_hook* är en valfri funktion som kommer att anropas med resultatet av "
"varje JSON-objekt som avkodas och dess returvärde kommer att användas i "
"stället för den angivna :class:`dict`.  Detta kan användas för att "
"tillhandahålla anpassade deserialiseringar (t.ex. för att stödja `JSON-RPC "
"<https://www.jsonrpc.org>`_ class hinting)."

msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of every JSON object decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders.  If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook* är en valfri funktion som anropas med resultatet av "
"varje JSON-objekt som avkodats med en ordnad lista av par.  Returvärdet för "
"*object_pairs_hook* kommer att användas istället för :class:`dict`.  Den här "
"funktionen kan användas för att implementera anpassade avkodare.  Om "
"*object_hook* också är definierad, har *object_pairs_hook* prioritet."

msgid "Added support for *object_pairs_hook*."
msgstr "Lagt till stöd för *object_pairs_hook*."

msgid ""
"*parse_float* is an optional function that will be called with the string of "
"every JSON float to be decoded.  By default, this is equivalent to "
"``float(num_str)``.  This can be used to use another datatype or parser for "
"JSON floats (e.g. :class:`decimal.Decimal`)."
msgstr ""
"*parse_float* är en valfri funktion som anropas med strängen för varje JSON-"
"flat som ska avkodas.  Som standard är detta likvärdigt med "
"``float(num_str)``.  Detta kan användas för att använda en annan datatyp "
"eller parser för JSON-flottor (t.ex. :class:`decimal.Decimal`)."

msgid ""
"*parse_int* is an optional function that will be called with the string of "
"every JSON int to be decoded.  By default, this is equivalent to "
"``int(num_str)``.  This can be used to use another datatype or parser for "
"JSON integers (e.g. :class:`float`)."
msgstr ""
"*parse_int* är en valfri funktion som anropas med strängen för varje JSON-"
"int som ska avkodas.  Som standard är detta likvärdigt med "
"``int(num_str)``.  Detta kan användas för att använda en annan datatyp eller "
"parser för JSON-integraler (t.ex. :class:`float`)."

msgid ""
"*parse_constant* is an optional function that will be called with one of the "
"following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This can be "
"used to raise an exception if invalid JSON numbers are encountered."
msgstr ""
"*parse_constant* är en valfri funktion som kommer att anropas med en av "
"följande strängar: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  Detta kan "
"användas för att skapa ett undantag om ogiltiga JSON-tal påträffas."

msgid ""
"If *strict* is false (``True`` is the default), then control characters will "
"be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""
"Om *strict* är false (``True`` är standard) kommer kontrolltecken att "
"tillåtas i strängar.  Kontrolltecken i det här sammanhanget är de som har "
"teckenkoder i intervallet 0-31, inklusive ``'\\t'`` (tab), ``'\\n'``, "
"``'\\r'`` och ``'\\0'``."

msgid ""
"If the data being deserialized is not a valid JSON document, a :exc:"
"`JSONDecodeError` will be raised."
msgstr ""
"Om data som deserialiseras inte är ett giltigt JSON-dokument, kommer ett :"
"exc:`JSONDecodeError` att uppstå."

msgid "All parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr "Alla parametrar är nu :ref:`keyword-only <keyword-only_parameter>`."

msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)."
msgstr ""
"Returnerar Python-representationen av *s* (en :class:`str`-instans som "
"innehåller ett JSON-dokument)."

msgid ""
":exc:`JSONDecodeError` will be raised if the given JSON document is not "
"valid."
msgstr ""
":exc:`JSONDecodeError` kommer att uppstå om det angivna JSON-dokumentet inte "
"är giltigt."

msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in "
"*s* where the document ended."
msgstr ""
"Avkodar ett JSON-dokument från *s* (en :class:`str` som börjar med ett JSON-"
"dokument) och returnerar en 2-tupel av Python-representationen och indexet i "
"*s* där dokumentet slutade."

msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr ""
"Detta kan användas för att avkoda ett JSON-dokument från en sträng som kan "
"innehålla ovidkommande data i slutet."

msgid "Extensible JSON encoder for Python data structures."
msgstr "Utökad JSON-kodare för Python-datastrukturer."

msgid "Supports the following objects and types by default:"
msgstr "Stöder följande objekt och typer som standard:"

msgid "list, tuple"
msgstr "list, tuple"

msgid "int, float, int- & float-derived Enums"
msgstr "int, float, int- & float-deriverade Enum"

msgid "number"
msgstr "number"

msgid "Added support for int- and float-derived Enum classes."
msgstr "Stöd för int- och float-deriverade Enum-klasser har lagts till."

msgid ""
"To extend this to recognize other objects, subclass and implement a :meth:"
"`~JSONEncoder.default` method with another method that returns a "
"serializable object for ``o`` if possible, otherwise it should call the "
"superclass implementation (to raise :exc:`TypeError`)."
msgstr ""
"För att utöka detta till att känna igen andra objekt, subklassa och "
"implementera en :meth:`~JSONEncoder.default`-metod med en annan metod som "
"returnerar ett serialiserbart objekt för ``o`` om möjligt, annars bör den "
"anropa superklassens implementering (för att höja :exc:`TypeError`)."

msgid ""
"If *skipkeys* is false (the default), a :exc:`TypeError` will be raised when "
"trying to encode keys that are not :class:`str`, :class:`int`, :class:"
"`float`, :class:`bool` or ``None``.  If *skipkeys* is true, such items are "
"simply skipped."
msgstr ""
"Om *skipkeys* är false (standard), kommer ett :exc:`TypeError` att uppstå "
"när man försöker koda nycklar som inte är :class:`str`, :class:`int`, :class:"
"`float`, :class:`bool` eller ``None``.  Om *skipkeys* är true, hoppas sådana "
"objekt helt enkelt över."

msgid ""
"If *ensure_ascii* is true (the default), the output is guaranteed to have "
"all incoming non-ASCII characters escaped.  If *ensure_ascii* is false, "
"these characters will be output as-is."
msgstr ""
"Om *ensure_ascii* är true (standard) garanteras att alla inkommande icke-"
"ASCII-tecken i utdata är escapade.  Om *ensure_ascii* är false kommer dessa "
"tecken att matas ut som de är."

msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause a :exc:`RecursionError`). "
"Otherwise, no such check takes place."
msgstr ""
"Om *check_circular* är true (standard) kommer listor, dicts och anpassade "
"kodade objekt att kontrolleras för cirkulära referenser under kodningen för "
"att förhindra en oändlig rekursion (vilket skulle orsaka ett :exc:"
"`RecursionError`). I annat fall sker ingen sådan kontroll."

msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and ``-"
"Infinity`` will be encoded as such.  This behavior is not JSON specification "
"compliant, but is consistent with most JavaScript based encoders and "
"decoders.  Otherwise, it will be a :exc:`ValueError` to encode such floats."
msgstr ""
"Om *allow_nan* är true (standard) kommer ``NaN``, ``Infinity`` och ``-"
"Infinity`` att kodas som sådana.  Detta beteende är inte förenligt med JSON-"
"specifikationen, men överensstämmer med de flesta JavaScript-baserade kodare "
"och avkodare.  Annars kommer det att vara ett :exc:`ValueError` att koda "
"sådana floats."

msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr ""
"Om *sort_keys* är true (standard: ``False``) kommer utdata från ordböcker "
"att sorteras efter nyckel; detta är användbart för regressionstester för att "
"säkerställa att JSON-serialiseringar kan jämföras på daglig basis."

msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent "
"level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the "
"default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""
"Om *indent* är ett icke-negativt heltal eller en sträng, kommer JSON-"
"arrayelement och objektmedlemmar att skrivas ut med den indentnivån.  En "
"indragsnivå på 0, negativ eller ``\"\"`` infogar bara nya rader.  ``None`` "
"(standard) väljer den mest kompakta representationen. Om du använder ett "
"positivt heltal indenteras så många mellanslag per nivå.  Om *indent* är en "
"sträng (t.ex. ``\"\\t\"``) används den strängen för att indentera varje nivå."

msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and ``(',', "
"': ')`` otherwise.  To get the most compact JSON representation, you should "
"specify ``(',', ':')`` to eliminate whitespace."
msgstr ""
"Om det anges ska *separatorer* vara en tupel av ``(item_separator, "
"key_separator)``.  Standardvärdet är ``(', ', ': ')`` om *indent* är "
"``None`` och ``(',', ': ')`` annars.  För att få den mest kompakta JSON-"
"representationen bör du ange ``(',', ':')`` för att eliminera blanksteg."

msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, :exc:"
"`TypeError` is raised."
msgstr ""
"Om det anges ska *default* vara en funktion som anropas för objekt som inte "
"kan serialiseras på annat sätt.  Den ska returnera en JSON-kodbar version av "
"objektet eller ge upphov till ett :exc:`TypeError`.  Om den inte "
"specificeras, genereras :exc:`TypeError`."

msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a :exc:"
"`TypeError`)."
msgstr ""
"Implementera denna metod i en subklass så att den returnerar ett "
"serialiserbart objekt för *o*, eller anropar basimplementationen (för att "
"skapa ett :exc:`TypeError`)."

msgid ""
"For example, to support arbitrary iterators, you could implement :meth:"
"`~JSONEncoder.default` like this::"
msgstr ""
"Till exempel, för att stödja godtyckliga iteratorer, kan du implementera :"
"meth:`~JSONEncoder.default` så här::"

msgid ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Let the base class default method raise the TypeError\n"
"   return super().default(o)"
msgstr ""
"def default(self, o):\n"
"   försök:\n"
"       iterable = iter(o)\n"
"   utom TypeError:\n"
"       passera\n"
"   else:\n"
"       return list(iterable)\n"
"   # Låt basklassens standardmetod höja TypeError\n"
"   return super().default(o)"

msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr ""
"Returnerar en JSON-strängrepresentation av en Python-datastruktur, *o*.  "
"Till exempel::"

msgid ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"
msgstr ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"

msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr ""
"Kodar det givna objektet, *o*, och ger varje strängrepresentation som är "
"tillgänglig.  Till exempel::"

msgid ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"
msgstr ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"

msgid "Exceptions"
msgstr "Undantag"

msgid "Subclass of :exc:`ValueError` with the following additional attributes:"
msgstr "Underklass till :exc:`ValueError` med följande ytterligare attribut:"

msgid "The unformatted error message."
msgstr "Det oformaterade felmeddelandet."

msgid "The JSON document being parsed."
msgstr "Det JSON-dokument som analyseras."

msgid "The start index of *doc* where parsing failed."
msgstr "Startindex för *doc* där tolkningen misslyckades."

msgid "The line corresponding to *pos*."
msgstr "Den linje som motsvarar *pos*."

msgid "The column corresponding to *pos*."
msgstr "Den kolumn som motsvarar *pos*."

msgid "Standard Compliance and Interoperability"
msgstr "Standardöverensstämmelse och interoperabilitet"

msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_. This "
"section details this module's level of compliance with the RFC. For "
"simplicity, :class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and "
"parameters other than those explicitly mentioned, are not considered."
msgstr ""
"JSON-formatet specificeras av :rfc:`7159` och av `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_. I det "
"här avsnittet beskrivs modulens nivå av överensstämmelse med RFC. För "
"enkelhetens skull beaktas inte underklasserna :class:`JSONEncoder` och :"
"class:`JSONDecoder`, och andra parametrar än de som uttryckligen nämns."

msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In particular:"
msgstr ""
"Denna modul följer inte RFC strikt, utan implementerar vissa tillägg som är "
"giltiga JavaScript men inte giltiga JSON.  Detta gäller i synnerhet följande:"

msgid "Infinite and NaN number values are accepted and output;"
msgstr "Oändliga och NaN-talvärden accepteras och matas ut;"

msgid ""
"Repeated names within an object are accepted, and only the value of the last "
"name-value pair is used."
msgstr ""
"Upprepade namn inom ett objekt accepteras, och endast värdet för det sista "
"namn-värdeparet används."

msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr ""
"Eftersom RFC tillåter RFC-kompatibla parsers att acceptera inmatningstexter "
"som inte är RFC-kompatibla, är den här modulens deserializer tekniskt sett "
"RFC-kompatibel med standardinställningarna."

msgid "Character Encodings"
msgstr "Kodning av tecken"

msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability."
msgstr ""
"RFC kräver att JSON representeras med antingen UTF-8, UTF-16 eller UTF-32, "
"där UTF-8 är den rekommenderade standardversionen för maximal "
"interoperabilitet."

msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets "
"*ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr ""
"Som RFC tillåter, men inte kräver, ställer den här modulens serializer in "
"*ensure_ascii=True* som standard, vilket innebär att utdata escapas så att "
"de resulterande strängarna endast innehåller ASCII-tecken."

msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise directly address the issue of character "
"encodings."
msgstr ""
"Förutom parametern *ensure_ascii* definieras den här modulen strikt i termer "
"av konvertering mellan Python-objekt och :class:`Unicode-strängar <str>`, "
"och tar därför inte direkt upp frågan om teckenkodning."

msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC "
"permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr ""
"Enligt RFC är det förbjudet att lägga till en byteordermark (BOM) i början "
"av en JSON-text, och den här modulens serialiserare lägger inte till någon "
"BOM i utdata. RFC tillåter, men kräver inte, att JSON-deserialiserare "
"ignorerar en initial BOM i sin indata.  Den här modulens deserialiserare ger "
"upphov till ett :exc:`ValueError` när en initial BOM finns."

msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences "
"that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems. "
"By default, this module accepts and outputs (when present in the original :"
"class:`str`) code points for such sequences."
msgstr ""
"RFC förbjuder inte uttryckligen JSON-strängar som innehåller byte-sekvenser "
"som inte motsvarar giltiga Unicode-tecken (t.ex. oparade UTF-16-surrogat), "
"men noterar att de kan orsaka problem med interoperabilitet. Som standard "
"accepterar och matar den här modulen ut (när de finns i den ursprungliga :"
"class:`str`) kodpunkter för sådana sekvenser."

msgid "Infinite and NaN Number Values"
msgstr "Oändliga och NaN-talvärden"

msgid ""
"The RFC does not permit the representation of infinite or NaN number values. "
"Despite that, by default, this module accepts and outputs ``Infinity``, ``-"
"Infinity``, and ``NaN`` as if they were valid JSON number literal values::"
msgstr ""
"RFC tillåter inte representation av oändliga eller NaN-talvärden. Trots "
"detta accepterar och matar den här modulen som standard ut ``Infinity``, ``-"
"Infinity`` och ``NaN`` som om de vore giltiga JSON-numeriska bokstavliga "
"värden::"

msgid ""
">>> # Neither of these calls raises an exception, but the results are not "
"valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"
msgstr ""
">>> # Neither of these calls raises an exception, but the results are not "
"valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"

msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr ""
"I serializern kan parametern *allow_nan* användas för att ändra detta "
"beteende.  I deserializern kan parametern *parse_constant* användas för att "
"ändra detta beteende."

msgid "Repeated Names Within an Object"
msgstr "Upprepade namn inom ett objekt"

msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""
"RFC anger att namnen i ett JSON-objekt ska vara unika, men anger inte hur "
"upprepade namn i JSON-objekt ska hanteras.  Som standard ger den här modulen "
"inte upphov till något undantag, utan ignorerar alla utom det sista namn-"
"värdeparet för ett givet namn::"

msgid ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"
msgstr ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"

msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr ""
"Parametern *object_pairs_hook* kan användas för att ändra detta beteende."

msgid "Top-level Non-Object, Non-Array Values"
msgstr "Värden på högsta nivå som inte är objekt eller arrayer"

msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and "
"this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr ""
"Den gamla versionen av JSON som specificeras av den föråldrade :rfc:`4627` "
"krävde att toppnivåvärdet för en JSON-text måste vara antingen ett JSON-"
"objekt eller en array (Python :class:`dict` eller :class:`list`), och kunde "
"inte vara ett JSON null-, boolean-, nummer- eller strängvärde. :rfc:`7159` "
"tog bort den begränsningen, och den här modulen implementerar inte och har "
"aldrig implementerat den begränsningen i varken dess serializer eller dess "
"deserializer."

msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere "
"to the restriction yourself."
msgstr ""
"För att uppnå maximal interoperabilitet kan det dock vara bra om du själv "
"frivilligt följer begränsningen."

msgid "Implementation Limitations"
msgstr "Begränsningar i genomförandet"

msgid "Some JSON deserializer implementations may set limits on:"
msgstr "Vissa implementeringar av JSON-deserializer kan sätta gränser för:"

msgid "the size of accepted JSON texts"
msgstr "storleken på accepterade JSON-texter"

msgid "the maximum level of nesting of JSON objects and arrays"
msgstr "den maximala nivån för nestning av JSON-objekt och matriser"

msgid "the range and precision of JSON numbers"
msgstr "intervall och precision för JSON-tal"

msgid "the content and maximum length of JSON strings"
msgstr "innehåll och maximal längd för JSON-strängar"

msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr ""
"Denna modul inför inte några sådana begränsningar utöver de som gäller för "
"de relevanta Python-datatyperna själva eller Python-tolken själv."

msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that "
"representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr ""
"När du serialiserar till JSON bör du vara uppmärksam på sådana begränsningar "
"i applikationer som kan konsumera din JSON.  I synnerhet är det vanligt att "
"JSON-tal deserialiseras till IEEE 754-tal med dubbel precision och därmed "
"omfattas av den representationens begränsningar för intervall och "
"precision.  Detta är särskilt relevant vid serialisering av Python :class:"
"`int`-värden av extremt stor magnitud, eller vid serialisering av instanser "
"av \"exotiska\" numeriska typer som :class:`decimal.Decimal`."

msgid "Command-line interface"
msgstr "Kommandoradsgränssnitt"

msgid "**Source code:** :source:`Lib/json/tool.py`"
msgstr "**Källkod:** :source:`Lib/json/tool.py`"

msgid ""
"The :mod:`json` module can be invoked as a script via ``python -m json`` to "
"validate and pretty-print JSON objects. The :mod:`json.tool` submodule "
"implements this interface."
msgstr ""
"Modulen :mod:`json` kan anropas som ett skript via ``python -m json`` för "
"att validera och pretty-printa JSON-objekt. Undermodulen :mod:`json.tool` "
"implementerar detta gränssnitt."

msgid ""
"If the optional ``infile`` and ``outfile`` arguments are not specified, :"
"data:`sys.stdin` and :data:`sys.stdout` will be used respectively:"
msgstr ""
"Om de valfria argumenten ``infile`` och ``outfile`` inte anges, används :"
"data:`sys.stdin` respektive :data:`sys.stdout`:"

msgid ""
"$ echo '{\"json\": \"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\": \"obj\"}' | python -m json\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

msgid ""
"The output is now in the same order as the input. Use the :option:`--sort-"
"keys` option to sort the output of dictionaries alphabetically by key."
msgstr ""
"Utdata är nu i samma ordning som indata. Använd alternativet :option:`--sort-"
"keys` för att sortera utdata från ordböcker alfabetiskt efter nyckel."

msgid ""
"The :mod:`json` module may now be directly executed as ``python -m json``. "
"For backwards compatibility, invoking the CLI as ``python -m json.tool`` "
"remains supported."
msgstr ""
"Modulen :mod:`json` kan nu köras direkt som ``python -m json``. För "
"bakåtkompatibilitet stöds fortfarande att anropa CLI som ``python -m json."
"tool``."

msgid "Command-line options"
msgstr "Alternativ för kommandoraden"

msgid "The JSON file to be validated or pretty-printed:"
msgstr "Den JSON-fil som ska valideras eller skrivas ut:"

msgid ""
"$ python -m json mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"
msgstr ""
"$ python -m json mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"

msgid "If *infile* is not specified, read from :data:`sys.stdin`."
msgstr "Om *infile* inte anges, läs från :data:`sys.stdin`."

msgid ""
"Write the output of the *infile* to the given *outfile*. Otherwise, write it "
"to :data:`sys.stdout`."
msgstr ""
"Skriver utdata från *infile* till den angivna *outfile*. I annat fall skrivs "
"den till :data:`sys.stdout`."

msgid "Sort the output of dictionaries alphabetically by key."
msgstr "Sortera utdata från ordböcker alfabetiskt efter nyckel."

msgid ""
"Disable escaping of non-ascii characters, see :func:`json.dumps` for more "
"information."
msgstr ""
"Inaktivera escaping av icke-ascii-tecken, se :func:`json.dumps` för mer "
"information."

msgid "Parse every input line as separate JSON object."
msgstr "Parsa varje inmatningsrad som ett separat JSON-objekt."

msgid "Mutually exclusive options for whitespace control."
msgstr "Ömsesidigt uteslutande alternativ för kontroll av blanksteg."

msgid "Show the help message."
msgstr "Visa hjälpmeddelandet."

msgid "Footnotes"
msgstr "Fotnoter"

msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE SEPARATOR) "
"and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas JavaScript "
"(as of ECMAScript Edition 5.1) does not."
msgstr ""
"Såsom anges i `the errata for RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, tillåter JSON bokstavliga U+2028 (LINE "
"SEPARATOR) och U+2029 (PARAGRAPH SEPARATOR) tecken i strängar, medan "
"JavaScript (från och med ECMAScript Edition 5.1) inte gör det."
