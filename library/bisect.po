# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!bisect` --- Array bisection algorithm"
msgstr ":mod:`!bisect` --- Bisektionsalgoritm för array"

msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**Källkod:** :source:`Lib/bisect.py`"

msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over linear "
"searches or frequent resorting."
msgstr ""
"Den här modulen ger stöd för att hålla en lista i sorterad ordning utan att "
"behöva sortera listan efter varje inmatning.  För långa listor med objekt "
"med dyra jämförelseoperationer kan detta vara en förbättring jämfört med "
"linjära sökningar eller frekventa sorteringar."

msgid ""
"The module is called :mod:`bisect` because it uses a basic bisection "
"algorithm to do its work.  Unlike other bisection tools that search for a "
"specific value, the functions in this module are designed to locate an "
"insertion point. Accordingly, the functions never call an :meth:`~object."
"__eq__` method to determine whether a value has been found.  Instead, the "
"functions only call the :meth:`~object.__lt__` method and will return an "
"insertion point between values in an array."
msgstr ""
"Modulen kallas :mod:`bisect` eftersom den använder en grundläggande "
"bisektionsalgoritm för att utföra sitt arbete.  Till skillnad från andra "
"bisektionsverktyg som söker efter ett specifikt värde är funktionerna i den "
"här modulen utformade för att hitta en insättningspunkt. Följaktligen "
"anropar funktionerna aldrig en :meth:`~object.__eq__`-metod för att avgöra "
"om ett värde har hittats.  Istället anropar funktionerna endast metoden :"
"meth:`~object.__lt__` och returnerar en insättningspunkt mellan värden i en "
"array."

msgid ""
"The functions in this module are not thread-safe. If multiple threads "
"concurrently use :mod:`bisect` functions on the same sequence, this may "
"result in undefined behaviour. Likewise, if the provided sequence is mutated "
"by a different thread while a :mod:`bisect` function is operating on it, the "
"result is undefined. For example, using :py:func:`~bisect.insort_left` on "
"the same list from multiple threads may result in the list becoming unsorted."
msgstr ""
"Funktionerna i denna modul är inte trådsäkra. Om flera trådar samtidigt "
"använder :mod:`bisect`-funktioner på samma sekvens kan detta leda till "
"odefinierat beteende. På samma sätt blir resultatet odefinierat om den "
"angivna sekvensen muteras av en annan tråd medan en :mod:`bisect`-funktion "
"används på den. Till exempel kan användning av :py:func:`~bisect."
"insort_left` på samma lista från flera trådar resultera i att listan blir "
"osorterad."

msgid "The following functions are provided:"
msgstr "Följande funktioner finns tillgängliga:"

msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list which "
"should be considered; by default the entire list is used.  If *x* is already "
"present in *a*, the insertion point will be before (to the left of) any "
"existing entries.  The return value is suitable for use as the first "
"parameter to ``list.insert()`` assuming that *a* is already sorted."
msgstr ""
"Placera insättningspunkten för *x* i *a* för att bibehålla den sorterade "
"ordningen. Parametrarna *lo* och *hi* kan användas för att ange en delmängd "
"av listan som ska beaktas; som standard används hela listan.  Om *x* redan "
"finns i *a* kommer inmatningspunkten att ligga före (till vänster om) alla "
"befintliga poster.  Returvärdet är lämpligt att använda som första parameter "
"i ``list.insert()`` förutsatt att *a* redan är sorterad."

msgid ""
"The returned insertion point *ip* partitions the array *a* into two slices "
"such that ``all(elem < x for elem in a[lo : ip])`` is true for the left "
"slice and ``all(elem >= x for elem in a[ip : hi])`` is true for the right "
"slice."
msgstr ""
"Den returnerade insättningspunkten *ip* delar upp matrisen *a* i två skivor "
"så att ``all(elem < x for elem in a[lo : ip])`` är sann för den vänstra "
"skivan och ``all(elem >= x for elem in a[ip : hi])`` är sann för den högra "
"skivan."

msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each element in the array.  To support "
"searching complex records, the key function is not applied to the *x* value."
msgstr ""
"*key* anger en :term:`key function` med ett argument som används för att "
"extrahera en jämförelsenyckel från varje element i matrisen.  För att "
"underlätta sökning i komplexa poster tillämpas inte nyckelfunktionen på *x*-"
"värdet."

msgid ""
"If *key* is ``None``, the elements are compared directly and no key function "
"is called."
msgstr ""
"Om *key* är ``None`` jämförs elementen direkt och ingen nyckelfunktion "
"anropas."

msgid "Added the *key* parameter."
msgstr "Lagt till parametern *key*."

msgid ""
"Similar to :py:func:`~bisect.bisect_left`, but returns an insertion point "
"which comes after (to the right of) any existing entries of *x* in *a*."
msgstr ""
"Liknar :py:func:`~bisect.bisect_left`, men returnerar en insättningspunkt "
"som kommer efter (till höger om) alla befintliga poster av *x* i *a*."

msgid ""
"The returned insertion point *ip* partitions the array *a* into two slices "
"such that ``all(elem <= x for elem in a[lo : ip])`` is true for the left "
"slice and ``all(elem > x for elem in a[ip : hi])`` is true for the right "
"slice."
msgstr ""
"Den returnerade insättningspunkten *ip* delar upp matrisen *a* i två skivor "
"så att ``all(elem <= x for elem in a[lo : ip])`` är sann för den vänstra "
"skivan och ``all(elem > x for elem in a[ip : hi])`` är sann för den högra "
"skivan."

msgid "Insert *x* in *a* in sorted order."
msgstr "Infoga *x* i *a* i sorterad ordning."

msgid ""
"This function first runs :py:func:`~bisect.bisect_left` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"Denna funktion kör först :py:func:`~bisect.bisect_left` för att lokalisera "
"en infogningspunkt. Därefter kör den metoden :meth:`!insert` på *a* för att "
"infoga *x* på lämplig plats för att bibehålla sorteringsordningen."

msgid ""
"To support inserting records in a table, the *key* function (if any) is "
"applied to *x* for the search step but not for the insertion step."
msgstr ""
"För att stödja infogning av poster i en tabell tillämpas *key*-funktionen "
"(om sådan finns) på *x* för söksteget men inte för infogningssteget."

msgid ""
"Keep in mind that the *O*\\ (log *n*) search is dominated by the slow *O*\\ "
"(*n*) insertion step."
msgstr ""
"Tänk på att *O*\\ (log *n*)-sökningen domineras av det långsamma *O*\\ (*n*)-"
"insättningssteget."

msgid ""
"Similar to :py:func:`~bisect.insort_left`, but inserting *x* in *a* after "
"any existing entries of *x*."
msgstr ""
"Liknar :py:func:`~bisect.insort_left`, men infogar *x* i *a* efter alla "
"befintliga poster av *x*."

msgid ""
"This function first runs :py:func:`~bisect.bisect_right` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"Denna funktion kör först :py:func:`~bisect.bisect_right` för att lokalisera "
"en insättningspunkt. Därefter kör den metoden :meth:`!insert` på *a* för att "
"infoga *x* på lämplig plats för att bibehålla sorteringsordningen."

msgid "Performance Notes"
msgstr "Anteckningar om prestanda"

msgid ""
"When writing time sensitive code using *bisect()* and *insort()*, keep these "
"thoughts in mind:"
msgstr ""
"När du skriver tidskänslig kod med hjälp av *bisect()* och *insort()* ska du "
"tänka på följande:"

msgid ""
"Bisection is effective for searching ranges of values. For locating specific "
"values, dictionaries are more performant."
msgstr ""
"Bisektion är effektivt för sökning av värdeintervall. För att hitta "
"specifika värden är ordböcker mer effektiva."

msgid ""
"The *insort()* functions are *O*\\ (*n*) because the logarithmic search step "
"is dominated by the linear time insertion step."
msgstr ""
"Funktionerna *insort()* är *O*\\ (*n*) eftersom det logaritmiska söksteget "
"domineras av det linjära tidsinsättningssteget."

msgid ""
"The search functions are stateless and discard key function results after "
"they are used.  Consequently, if the search functions are used in a loop, "
"the key function may be called again and again on the same array elements. "
"If the key function isn't fast, consider wrapping it with :py:func:"
"`functools.cache` to avoid duplicate computations.  Alternatively, consider "
"searching an array of precomputed keys to locate the insertion point (as "
"shown in the examples section below)."
msgstr ""
"Sökfunktionerna är stateless och kasserar nyckelfunktionens resultat efter "
"att de har använts.  Om sökfunktionerna används i en slinga kan "
"nyckelfunktionen därför anropas om och om igen på samma arrayelement. Om "
"nyckelfunktionen inte är snabb kan du överväga att omsluta den med :py:func:"
"`functools.cache` för att undvika dubbla beräkningar.  Alternativt kan du "
"överväga att söka i en matris med förberäknade nycklar för att lokalisera "
"insättningspunkten (som visas i exempelavsnittet nedan)."

msgid ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ is a "
"high performance module that uses *bisect* to managed sorted collections of "
"data."
msgstr ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ är en "
"högpresterande modul som använder *bisect* för att hantera sorterade "
"samlingar av data."

msgid ""
"The `SortedCollection recipe <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ uses bisect to build a full-featured collection class "
"with straight-forward search methods and support for a key-function.  The "
"keys are precomputed to save unnecessary calls to the key function during "
"searches."
msgstr ""
"Receptet `SortedCollection <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ använder bisect för att bygga en fullfjädrad "
"samlingsklass med enkla sökmetoder och stöd för en nyckelfunktion.  "
"Nycklarna är förberäknade för att spara onödiga anrop till nyckelfunktionen "
"under sökningar."

msgid "Searching Sorted Lists"
msgstr "Söka i sorterade listor"

msgid ""
"The above `bisect functions`_ are useful for finding insertion points but "
"can be tricky or awkward to use for common searching tasks. The following "
"five functions show how to transform them into the standard lookups for "
"sorted lists::"
msgstr ""
"Ovanstående `bisect-funktioner`_ är användbara för att hitta "
"insättningspunkter men kan vara knepiga eller besvärliga att använda för "
"vanliga sökuppgifter. Följande fem funktioner visar hur man omvandlar dem "
"till standarduppslagningar för sorterade listor::"

msgid ""
"def index(a, x):\n"
"    'Locate the leftmost value exactly equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a) and a[i] == x:\n"
"        return i\n"
"    raise ValueError\n"
"\n"
"def find_lt(a, x):\n"
"    'Find rightmost value less than x'\n"
"    i = bisect_left(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_le(a, x):\n"
"    'Find rightmost value less than or equal to x'\n"
"    i = bisect_right(a, x)\n"
"    if i:\n"
"        return a[i-1]\n"
"    raise ValueError\n"
"\n"
"def find_gt(a, x):\n"
"    'Find leftmost value greater than x'\n"
"    i = bisect_right(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError\n"
"\n"
"def find_ge(a, x):\n"
"    'Find leftmost item greater than or equal to x'\n"
"    i = bisect_left(a, x)\n"
"    if i != len(a):\n"
"        return a[i]\n"
"    raise ValueError"
msgstr ""
"def index(a, x):\n"
"    \"Leta reda på värdet längst till vänster som är exakt lika med x\n"
"    i = bisect_left(a, x)\n"
"    om i != len(a) och a[i] == x:\n"
"        returnera i\n"
"    höja ValueError\n"
"\n"
"def find_lt(a, x):\n"
"    \"Hitta värdet längst till höger som är mindre än x\n"
"    i = bisect_left(a, x)\n"
"    if i:\n"
"        returnera a[i-1]\n"
"    raise Värdefel\n"
"\n"
"def find_le(a, x):\n"
"    \"Hitta värdet längst till höger som är mindre än eller lika med x\n"
"    i = bisect_right(a, x)\n"
"    om i:\n"
"        returnera a[i-1]\n"
"    raise Värdefel\n"
"\n"
"def find_gt(a, x):\n"
"    \"Hitta värdet längst till vänster som är större än x\n"
"    i = bisect_right(a, x)\n"
"    om i != len(a):\n"
"        returnera a[i]\n"
"    raise VärdeFel\n"
"\n"
"def find_ge(a, x):\n"
"    \"Hitta objektet längst till vänster som är större än eller lika med x\n"
"    i = bisect_left(a, x)\n"
"    om i != len(a):\n"
"        returnera a[i]\n"
"    raise VärdeFel"

msgid "Examples"
msgstr "Exempel"

msgid ""
"The :py:func:`~bisect.bisect` function can be useful for numeric table "
"lookups. This example uses :py:func:`~bisect.bisect` to look up a letter "
"grade for an exam score (say) based on a set of ordered numeric breakpoints: "
"90 and up is an 'A', 80 to 89 is a 'B', and so on::"
msgstr ""
"Funktionen :py:func:`~bisect.bisect` kan vara användbar för numeriska "
"tabelluppslagningar. I detta exempel används :py:func:`~bisect.bisect` för "
"att slå upp ett bokstavsbetyg för ett provresultat (säg) baserat på en "
"uppsättning ordnade numeriska brytpunkter: 90 och uppåt är ett 'A', 80 till "
"89 är ett 'B', och så vidare::"

msgid ""
">>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):\n"
"...     i = bisect(breakpoints, score)\n"
"...     return grades[i]\n"
"...\n"
">>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]\n"
"['F', 'A', 'C', 'C', 'B', 'A', 'A']"
msgstr ""
">>> def grade(score, brytpunkter=[60, 70, 80, 90], betyg='FDCBA'):\n"
"... i = bisect(brytpunkter, poäng)\n"
"... return betyg[i]\n"
"...\n"
">>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]\n"
"['F', 'A', 'C', 'C', 'B', 'A', 'A']"

msgid ""
"The :py:func:`~bisect.bisect` and :py:func:`~bisect.insort` functions also "
"work with lists of tuples.  The *key* argument can serve to extract the "
"field used for ordering records in a table::"
msgstr ""
"Funktionerna :py:func:`~bisect.bisect` och :py:func:`~bisect.insort` "
"fungerar också med listor av tupler.  Argumentet *key* kan användas för att "
"extrahera det fält som används för att ordna poster i en tabell::"

msgid ""
">>> from collections import namedtuple\n"
">>> from operator import attrgetter\n"
">>> from bisect import bisect, insort\n"
">>> from pprint import pprint\n"
"\n"
">>> Movie = namedtuple('Movie', ('name', 'released', 'director'))\n"
"\n"
">>> movies = [\n"
"...     Movie('Jaws', 1975, 'Spielberg'),\n"
"...     Movie('Titanic', 1997, 'Cameron'),\n"
"...     Movie('The Birds', 1963, 'Hitchcock'),\n"
"...     Movie('Aliens', 1986, 'Cameron')\n"
"... ]\n"
"\n"
">>> # Find the first movie released after 1960\n"
">>> by_year = attrgetter('released')\n"
">>> movies.sort(key=by_year)\n"
">>> movies[bisect(movies, 1960, key=by_year)]\n"
"Movie(name='The Birds', released=1963, director='Hitchcock')\n"
"\n"
">>> # Insert a movie while maintaining sort order\n"
">>> romance = Movie('Love Story', 1970, 'Hiller')\n"
">>> insort(movies, romance, key=by_year)\n"
">>> pprint(movies)\n"
"[Movie(name='The Birds', released=1963, director='Hitchcock'),\n"
" Movie(name='Love Story', released=1970, director='Hiller'),\n"
" Movie(name='Jaws', released=1975, director='Spielberg'),\n"
" Movie(name='Aliens', released=1986, director='Cameron'),\n"
" Movie(name='Titanic', released=1997, director='Cameron')]"
msgstr ""
">>> from collections import namedtuple\n"
">>> from operator import attrgetter\n"
">>> from bisect import bisect, insort\n"
">>> from pprint import pprint\n"
"\n"
">>> Movie = namedtuple('Movie', ('name', 'released', 'director'))\n"
"\n"
">>> movies = [\n"
"...     Movie('Jaws', 1975, 'Spielberg'),\n"
"...     Movie('Titanic', 1997, 'Cameron'),\n"
"...     Movie('The Birds', 1963, 'Hitchcock'),\n"
"...     Movie('Aliens', 1986, 'Cameron')\n"
"... ]\n"
"\n"
">>> # Find the first movie released after 1960\n"
">>> by_year = attrgetter('released')\n"
">>> movies.sort(key=by_year)\n"
">>> movies[bisect(movies, 1960, key=by_year)]\n"
"Movie(name='The Birds', released=1963, director='Hitchcock')\n"
"\n"
">>> # Insert a movie while maintaining sort order\n"
">>> romance = Movie('Love Story', 1970, 'Hiller')\n"
">>> insort(movies, romance, key=by_year)\n"
">>> pprint(movies)\n"
"[Movie(name='The Birds', released=1963, director='Hitchcock'),\n"
" Movie(name='Love Story', released=1970, director='Hiller'),\n"
" Movie(name='Jaws', released=1975, director='Spielberg'),\n"
" Movie(name='Aliens', released=1986, director='Cameron'),\n"
" Movie(name='Titanic', released=1997, director='Cameron')]"

msgid ""
"If the key function is expensive, it is possible to avoid repeated function "
"calls by searching a list of precomputed keys to find the index of a record::"
msgstr ""
"Om nyckelfunktionen är dyr är det möjligt att undvika upprepade "
"funktionsanrop genom att söka i en lista med förberäknade nycklar för att "
"hitta indexet för en post::"

msgid ""
">>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]\n"
">>> data.sort(key=lambda r: r[1])       # Or use operator.itemgetter(1).\n"
">>> keys = [r[1] for r in data]         # Precompute a list of keys.\n"
">>> data[bisect_left(keys, 0)]\n"
"('black', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blue', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('red', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('yellow', 8)"
msgstr ""
">>> data = [('röd', 5), ('blå', 1), ('gul', 8), ('svart', 0)]\n"
">>> data.sort(key=lambda r: r[1]) # Eller använd operator.itemgetter(1).\n"
">>> nycklar = [r[1] för r i data]         # Förberäkna en lista med "
"nycklar.\n"
">>> data[bisect_left(keys, 0)]\n"
"('svart', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blå', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('röd', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('gul', 8)"
