# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Functional Programming HOWTO"
msgstr "HOWTO om funktionell programmering"

msgid "Author"
msgstr "Författare"

msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

msgid "Release"
msgstr "Release"

msgid "0.32"
msgstr "0.32"

msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"I det här dokumentet tar vi en rundtur i Pythons funktioner som lämpar sig "
"för att implementera program i en funktionell stil.  Efter en introduktion "
"till begreppen funktionell programmering tittar vi på språkfunktioner som :"
"term:`iterator` och :term:`generator` samt relevanta biblioteksmoduler som :"
"mod:`itertools` och :mod:`functools`."

msgid "Introduction"
msgstr "Introduktion"

msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"Detta avsnitt förklarar det grundläggande konceptet för funktionell "
"programmering; om du bara är intresserad av att lära dig om Python-språkets "
"funktioner, hoppa till nästa avsnitt om :ref:`funktionell-hur-iteratorer`."

msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr "Programmeringsspråk stöder nedbrytning av problem på flera olika sätt:"

msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"De flesta programmeringsspråk är **procedurspråk**: program är listor med "
"instruktioner som talar om för datorn vad den ska göra med programmets "
"indata.  C, Pascal och till och med Unix-shell är procedurspråk."

msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"I **deklarativa** språk skriver du en specifikation som beskriver problemet "
"som ska lösas, och språkets implementation räknar ut hur beräkningen ska "
"utföras på ett effektivt sätt.  SQL är det deklarativa språk som du troligen "
"känner till; en SQL-fråga beskriver den datamängd som du vill hämta, och SQL-"
"motorn avgör om tabeller ska skannas eller index användas, vilka "
"subklausuler som ska utföras först osv."

msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"**Objektorienterade** program manipulerar samlingar av objekt.  Objekt har "
"ett internt tillstånd och stödjer metoder som på något sätt frågar efter "
"eller ändrar detta interna tillstånd. Smalltalk och Java är "
"objektorienterade språk.  C++ och Python är språk som stöder "
"objektorienterad programmering, men som inte tvingar fram användning av "
"objektorienterade funktioner."

msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"*i *funktionell** programmering bryts ett problem ned till en uppsättning "
"funktioner. I idealfallet tar funktioner bara emot indata och producerar "
"utdata, och har inget internt tillstånd som påverkar den utdata som "
"produceras för en given indata.  Välkända funktionella språk är bland annat "
"ML-familjen (Standard ML, OCaml och andra varianter) och Haskell."

msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"Konstruktörerna av vissa datorspråk väljer att betona ett visst sätt att "
"programmera.  Detta gör det ofta svårt att skriva program som använder ett "
"annat synsätt.  Andra språk är multiparadigmspråk som stödjer flera olika "
"synsätt. Lisp, C++ och Python är multiparadigmspråk; du kan skriva program "
"eller bibliotek som till stor del är procedurella, objektorienterade eller "
"funktionella i alla dessa språk.  I ett stort program kan olika delar "
"skrivas med olika metoder; GUI:t kan till exempel vara objektorienterat "
"medan bearbetningslogiken är procedurell eller funktionell."

msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"I ett funktionellt program flödar indata genom en uppsättning funktioner. "
"Varje funktion bearbetar sin indata och producerar en viss utdata.  "
"Funktionell stil avråder från funktioner med sidoeffekter som ändrar internt "
"tillstånd eller gör andra ändringar som inte syns i funktionens returvärde.  "
"Funktioner som inte har några bieffekter alls kallas **rent funktionella**.  "
"Att undvika bieffekter innebär att man inte använder datastrukturer som "
"uppdateras under programmets gång, utan varje funktions utdata får bara bero "
"på dess indata."

msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"Vissa språk är mycket strikta när det gäller renhet och har inte ens "
"assignment statements som ``a=3`` eller ``c = a + b``, men det är svårt att "
"undvika alla bieffekter, till exempel att skriva ut på skärmen eller skriva "
"till en diskfil. Ett annat exempel är ett anrop till funktionen :func:"
"`print` eller :func:`time.sleep`, som inte ger något användbart värde. Båda "
"anropas endast för sina bieffekter, som att skicka lite text till skärmen "
"eller pausa exekveringen i en sekund."

msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"Python-program skrivna i funktionell stil går vanligtvis inte till "
"ytterligheten att undvika alla I/O eller alla tilldelningar; istället "
"tillhandahåller de ett gränssnitt som ser funktionellt ut men använder icke-"
"funktionella funktioner internt. Till exempel kommer implementeringen av en "
"funktion fortfarande att använda tilldelningar till lokala variabler, men "
"kommer inte att ändra globala variabler eller ha andra biverkningar."

msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"Funktionell programmering kan ses som motsatsen till objektorienterad "
"programmering.  Objekt är små kapslar som innehåller ett internt tillstånd "
"tillsammans med en samling metodanrop som låter dig ändra detta tillstånd, "
"och program består av att göra rätt uppsättning tillståndsändringar.  "
"Funktionell programmering vill undvika tillståndsändringar så mycket som "
"möjligt och arbetar med dataflöden mellan funktioner.  I Python kan du "
"kombinera de två metoderna genom att skriva funktioner som tar och "
"returnerar instanser som representerar objekt i din applikation (e-"
"postmeddelanden, transaktioner etc.)."

msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"Funktionell design kan verka som en märklig begränsning att arbeta under.  "
"Varför ska man undvika objekt och bieffekter?  Det finns teoretiska och "
"praktiska fördelar med den funktionella stilen:"

msgid "Formal provability."
msgstr "Formell bevisbarhet."

msgid "Modularity."
msgstr "Modularitet."

msgid "Composability."
msgstr "Komponerbarhet."

msgid "Ease of debugging and testing."
msgstr "Enkel felsökning och testning."

msgid "Formal provability"
msgstr "Formell bevisbarhet"

msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"En teoretisk fördel är att det är lättare att konstruera ett matematiskt "
"bevis för att ett funktionellt program är korrekt."

msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"Under lång tid har forskare varit intresserade av att hitta sätt att "
"matematiskt bevisa att program är korrekta.  Detta skiljer sig från att "
"testa ett program på många olika indata och dra slutsatsen att dess utdata "
"vanligtvis är korrekt, eller att läsa ett programs källkod och dra "
"slutsatsen att koden ser rätt ut; målet är istället ett rigoröst bevis för "
"att ett program ger rätt resultat för alla möjliga indata."

msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"Den teknik som används för att bevisa att program är korrekta är att skriva "
"ner **invarianter**, egenskaper hos indata och hos programmets variabler som "
"alltid är sanna.  För varje kodrad visar man sedan att om invarianterna X "
"och Y är sanna **innan** raden körs, så är de något annorlunda invarianterna "
"X' och Y' sanna **efter** raden körs.  Detta fortsätter tills du når slutet "
"av programmet, då invarianterna ska matcha de önskade villkoren på "
"programmets utdata."

msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"Att funktionell programmering undviker tilldelningar beror på att "
"tilldelningar är svåra att hantera med denna teknik; tilldelningar kan bryta "
"invarianter som var sanna före tilldelningen utan att producera några nya "
"invarianter som kan spridas vidare."

msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"Att bevisa att program är korrekta är tyvärr till stor del opraktiskt och "
"inte relevant för Python-programvara. Även triviala program kräver bevis som "
"är flera sidor långa; korrekthetsbeviset för ett måttligt komplicerat "
"program skulle vara enormt, och få eller inga av de program du använder "
"dagligen (Python-tolken, din XML-parser, din webbläsare) kan bevisas vara "
"korrekta.  Även om du skrev ner eller genererade ett bevis, skulle det då "
"vara frågan om att verifiera beviset; kanske finns det ett fel i det, och du "
"tror felaktigt att du har bevisat att programmet är korrekt."

msgid "Modularity"
msgstr "Modularitet"

msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"En mer praktisk fördel med funktionell programmering är att den tvingar dig "
"att dela upp ditt problem i små bitar.  Program är mer modulära som ett "
"resultat.  Det är lättare att specificera och skriva en liten funktion som "
"gör en sak än en stor funktion som utför en komplicerad transformation.  Små "
"funktioner är också lättare att läsa och att kontrollera om det finns fel."

msgid "Ease of debugging and testing"
msgstr "Enkel felsökning och testning"

msgid "Testing and debugging a functional-style program is easier."
msgstr "Det är enklare att testa och felsöka ett program med funktionell stil."

msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"Felsökningen förenklas av att funktionerna i allmänhet är små och tydligt "
"specificerade.  När ett program inte fungerar är varje funktion en "
"gränssnittspunkt där du kan kontrollera att data är korrekta.  Du kan titta "
"på de mellanliggande in- och utmatningarna för att snabbt isolera den "
"funktion som är ansvarig för en bugg."

msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"Testning är enklare eftersom varje funktion är ett potentiellt objekt för "
"ett enhetstest. Funktionerna är inte beroende av systemtillstånd som måste "
"replikeras innan ett test körs, utan man behöver bara syntetisera rätt "
"indata och sedan kontrollera att utdata motsvarar förväntningarna."

msgid "Composability"
msgstr "Komposabilitet"

msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"När du arbetar med ett funktionellt program kommer du att skriva ett antal "
"funktioner med varierande in- och utgångar.  Vissa av dessa funktioner "
"kommer oundvikligen att vara specialiserade för en viss applikation, men "
"andra kommer att vara användbara i en mängd olika program.  Till exempel kan "
"en funktion som tar en katalogsökväg och returnerar alla XML-filer i "
"katalogen, eller en funktion som tar ett filnamn och returnerar dess "
"innehåll, användas i många olika situationer."

msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"Med tiden kommer du att skapa ett personligt bibliotek med verktyg.  Ofta "
"sätter du ihop nya program genom att ordna befintliga funktioner i en ny "
"konfiguration och skriva några funktioner som är specialiserade för den "
"aktuella uppgiften."

msgid "Iterators"
msgstr "Iteratorer"

msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"Jag ska börja med att titta på en funktion i Python-språket som är en viktig "
"grund för att skriva program i funktionell stil: iteratorer."

msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"En iterator är ett objekt som representerar en ström av data; detta objekt "
"returnerar data ett element i taget.  En iterator i Python måste stödja en "
"metod som heter :meth:`~iterator.__next__` som inte tar några argument och "
"alltid returnerar nästa element i strömmen.  Om det inte finns några fler "
"element i flödet måste :meth:`~iterator.__next__` ge upphov till undantaget :"
"exc:`StopIteration`. Iteratorer behöver dock inte vara ändliga; det är helt "
"rimligt att skriva en iterator som producerar en oändlig ström av data."

msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"Den inbyggda funktionen :func:`iter` tar ett godtyckligt objekt och försöker "
"returnera en iterator som returnerar objektets innehåll eller element, och "
"ger upphov till :exc:`TypeError` om objektet inte stöder iteration.  Flera "
"av Pythons inbyggda datatyper stöder iteration, de vanligaste är listor och "
"ordböcker.  Ett objekt kallas :term:`iterable` om du kan få en iterator för "
"det."

msgid "You can experiment with the iteration interface manually:"
msgstr "Du kan experimentera med iterationsgränssnittet manuellt:"

msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python förväntar sig itererbara objekt i flera olika sammanhang, varav det "
"viktigaste är :keyword:`for`-satsen.  I uttalandet ``for X in Y`` måste Y "
"vara en iterator eller något objekt för vilket :func:`iter` kan skapa en "
"iterator.  Dessa två satser är likvärdiga::"

msgid ""
"for i in iter(obj):\n"
"    print(i)\n"
"\n"
"for i in obj:\n"
"    print(i)"
msgstr ""
"för i i iter(obj):\n"
"    print(i)\n"
"\n"
"för i i obj:\n"
"    print(i)"

msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"Iteratorer kan materialiseras som listor eller tupler med hjälp av "
"konstruktörsfunktionerna :func:`list` eller :func:`tuple`:"

msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"Uppackning av sekvenser stöder även iteratorer: om du vet att en iterator "
"kommer att returnera N element kan du packa upp dem till en N-tupel:"

msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"Inbyggda funktioner som :func:`max` och :func:`min` kan ta ett enda "
"iteratorargument och returnerar det största eller minsta elementet.  "
"Operatorerna ``\"in\"`` och ``\"not in\"`` stöder också iteratorer: ``X i "
"iterator`` är sant om X finns i den ström som returneras av iteratorn.  Du "
"kommer att stöta på uppenbara problem om iteratorn är oändlig; :func:`max`, :"
"func:`min` kommer aldrig att returnera, och om elementet X aldrig visas i "
"strömmen kommer operatorerna ``\"in\"`` och ``\"not in\"`` inte heller att "
"returnera."

msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"Observera att du bara kan gå framåt i en iterator; det finns inget sätt att "
"hämta föregående element, återställa iteratorn eller göra en kopia av den.  "
"Iteratorobjekt kan valfritt tillhandahålla dessa ytterligare funktioner, men "
"iteratorprotokollet specificerar endast :meth:`~iterator.__next__`-metoden.  "
"Funktioner kan därför konsumera all iteratorns utdata, och om du behöver "
"göra något annat med samma ström måste du skapa en ny iterator."

msgid "Data Types That Support Iterators"
msgstr "Datatyper som stöder iteratorer"

msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"Vi har redan sett hur listor och tupler stöder iteratorer.  Faktum är att "
"alla Python-sekvenstyper, till exempel strängar, automatiskt stöder "
"skapandet av en iterator."

msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr ""
"Om du anropar :func:`iter` på en ordbok returneras en iterator som loopar "
"över ordbokens nycklar::"

msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m:\n"
"...     print(key, m[key])\n"
"Jan 1\n"
"Feb 2\n"
"Mar 3\n"
"Apr 4\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Aug 8\n"
"Sep 9\n"
"Oct 10\n"
"Nov 11\n"
"Dec 12"
msgstr ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      \"Jul\": 7, \"Aug\": 8, \"Sep\": 9, 'okt': 10, 'nov': 11, 'Dec': "
"12}\n"
">>> för nyckel i m:\n"
"... print(nyckel, m[nyckel])\n"
"1 januari\n"
"2 februari\n"
"3 mars\n"
"4 april\n"
"5 maj\n"
"6 juni\n"
"7 juli\n"
"Augusti 8\n"
"9 september\n"
"10 oktober\n"
"11 november\n"
"12 dec"

msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"Observera att från och med Python 3.7 är ordbokens iterationsordning "
"garanterad att vara densamma som insättningsordningen. I tidigare versioner "
"var beteendet ospecificerat och kunde variera mellan olika implementeringar."

msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"Om du använder :func:`iter` på en dictionary loopar du alltid över "
"nycklarna, men dictionaries har metoder som returnerar andra iteratorer.  Om "
"du vill iterera över värden eller nyckel/värde-par kan du uttryckligen "
"anropa metoderna :meth:`~dict.values` eller :meth:`~dict.items` för att få "
"en lämplig iterator."

msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"Konstruktören :func:`dict` kan acceptera en iterator som returnerar en "
"ändlig ström av ``(nyckel, värde)``-tupler:"

msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"Filer stöder också iteration genom att anropa metoden :meth:`~io.TextIOBase."
"readline` tills det inte finns några fler rader i filen.  Detta innebär att "
"du kan läsa varje rad i en fil så här::"

msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""
"för rad i filen:\n"
"    # gör något för varje rad\n"
"    ..."

msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"Uppsättningar kan ta sitt innehåll från en iterabel och låta dig iterera "
"över uppsättningens element::"

msgid ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> for i in S:\n"
"...     print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"
msgstr ""
">>> S = {2, 3, 5, 7, 11, 13}\n"
">>> för i i S:\n"
"... print(i)\n"
"2\n"
"3\n"
"5\n"
"7\n"
"11\n"
"13"

msgid "Generator expressions and list comprehensions"
msgstr "Generatoruttryck och listkomprehensioner"

msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"Två vanliga operationer på en iterators utdata är 1) att utföra någon "
"operation för varje element, 2) att välja en delmängd av element som "
"uppfyller något villkor. Om du till exempel har en lista med strängar kanske "
"du vill ta bort efterföljande blanksteg från varje rad eller extrahera alla "
"strängar som innehåller en viss delsträng."

msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"Listkomprehensioner och generatoruttryck (kortform: \"listcomps\" och "
"\"genexps\") är en kortfattad notation för sådana operationer, som lånats "
"från det funktionella programmeringsspråket Haskell (https://www.haskell."
"org/).  Du kan ta bort alla blanksteg från en ström av strängar med följande "
"kod::"

msgid ""
">>> line_list = ['  line 1\\n', 'line 2  \\n', ' \\n', '']\n"
"\n"
">>> # Generator expression -- returns iterator\n"
">>> stripped_iter = (line.strip() for line in line_list)\n"
"\n"
">>> # List comprehension -- returns list\n"
">>> stripped_list = [line.strip() for line in line_list]"
msgstr ""
">>> line_list = [' line 1\\n', 'line 2 \\n', ' \\n', '']\n"
"\n"
">>> # Generatoruttryck -- returnerar iterator\n"
">>> stripped_iter = (linje.strip() för linje i linje_lista)\n"
"\n"
">>> # Listförståelse -- returnerar lista\n"
">>> stripped_list = [line.strip() for line in line_list]"

msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr ""
"Du kan välja endast vissa element genom att lägga till ett ``\"if\"``-"
"villkor::"

msgid ""
">>> stripped_list = [line.strip() for line in line_list\n"
"...                  if line != \"\"]"
msgstr ""
">>> stripped_list = [line.strip() för line i line_list\n"
"... om rad != \"\"]"

msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"Med en list comprehension får du tillbaka en Python-lista; ``stripped_list`` "
"är en lista som innehåller de resulterande raderna, inte en iterator.  "
"Generatoruttryck returnerar en iterator som beräknar värdena efter behov, "
"utan att behöva materialisera alla värden på en gång.  Det innebär att "
"listcomprehensions inte är användbara om du arbetar med iteratorer som "
"returnerar en oändlig ström eller en mycket stor mängd data.  "
"Generatoruttryck är att föredra i dessa situationer."

msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"Generatoruttryck omges av parenteser (\"()\") och listkomprehensioner omges "
"av hakparenteser (\"[]\").  Generatoruttryck har formen::"

msgid ""
"( expression for expr in sequence1\n"
"             if condition1\n"
"             for expr2 in sequence2\n"
"             if condition2\n"
"             for expr3 in sequence3\n"
"             ...\n"
"             if condition3\n"
"             for exprN in sequenceN\n"
"             if conditionN )"
msgstr ""
"( uttryck för expr i sekvens1\n"
"             om villkor1\n"
"             för expr2 i sekvens2\n"
"             om villkor2\n"
"             för expr3 i sekvens3\n"
"             ...\n"
"             om villkor3\n"
"             för exprN i sekvensN\n"
"             om villkorN )"

msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"Även här är det bara de yttre hakparenteserna som är annorlunda "
"(hakparenteser i stället för parenteser)."

msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"Elementen i den genererade utdata kommer att vara de successiva värdena av "
"``uttryck``.  Alla ``if``-klausuler är valfria; om de finns med utvärderas "
"``expression`` och läggs till i resultatet endast när ``condition`` är sant."

msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"Generatoruttryck måste alltid skrivas inom parentes, men även de parenteser "
"som signalerar ett funktionsanrop räknas.  Om du vill skapa en iterator som "
"omedelbart skickas till en funktion kan du skriva::"

msgid "obj_total = sum(obj.count for obj in list_all_objects())"
msgstr "obj_total = sum(obj.count för obj i list_all_objects())"

msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"Klausulerna ``for...in`` innehåller de sekvenser som ska itereras över.  "
"Sekvenserna behöver inte vara lika långa, eftersom de itereras från vänster "
"till höger, **inte** parallellt.  För varje element i ``sekvens1``, loopas "
"``sekvens2`` från början.  ``sekvens3`` loopas sedan över för varje "
"resulterande par av element från ``sekvens1`` och ``sekvens2``."

msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"För att uttrycka det på ett annat sätt är en listförståelse eller ett "
"generatoruttryck likvärdigt med följande Python-kod::"

msgid ""
"for expr1 in sequence1:\n"
"    if not (condition1):\n"
"        continue   # Skip this element\n"
"    for expr2 in sequence2:\n"
"        if not (condition2):\n"
"            continue   # Skip this element\n"
"        ...\n"
"        for exprN in sequenceN:\n"
"            if not (conditionN):\n"
"                continue   # Skip this element\n"
"\n"
"            # Output the value of\n"
"            # the expression."
msgstr ""
"för expr1 i sekvens1:\n"
"    if not (villkor1):\n"
"        continue # Hoppa över detta element\n"
"    för expr2 i sekvens2:\n"
"        if not (condition2):\n"
"            fortsätt # Hoppa över detta element\n"
"        ...\n"
"        för exprN i sekvensN:\n"
"            if not (conditionN):\n"
"                fortsätt # Hoppa över detta element\n"
"\n"
"            # Skriv ut värdet av\n"
"            # uttrycket."

msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"Detta innebär att när det finns flera ``for...in``-klausuler men inga ``if``-"
"klausuler, kommer längden på den resulterande utdatan att vara lika med "
"produkten av längden på alla sekvenser.  Om du har två listor med längden 3, "
"blir utdatalistan 9 element lång:"

msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"För att undvika att införa en tvetydighet i Pythons grammatik, om "
"``expression`` skapar en tupel, måste den omges av parenteser.  Den första "
"listförståelsen nedan är ett syntaxfel, medan den andra är korrekt::"

msgid ""
"# Syntax error\n"
"[x, y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[(x, y) for x in seq1 for y in seq2]"
msgstr ""
"# Syntaxfel\n"
"[x, y för x i seq1 för y i seq2]\n"
"# Korrekt\n"
"[(x, y) för x i seq1 för y i seq2]"

msgid "Generators"
msgstr "Generatorer"

msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"Generatorer är en speciell klass av funktioner som förenklar arbetet med att "
"skriva iteratorer.  Vanliga funktioner beräknar ett värde och returnerar "
"det, men generatorer returnerar en iterator som returnerar en ström av "
"värden."

msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Du är säkert bekant med hur vanliga funktionsanrop fungerar i Python eller "
"C. När du anropar en funktion får den ett privat namnområde där dess lokala "
"variabler skapas.  När funktionen når ett ``return``-slutsats förstörs de "
"lokala variablerna och värdet returneras till anroparen.  Ett senare anrop "
"till samma funktion skapar ett nytt privat namnområde och en ny uppsättning "
"lokala variabler. Men tänk om de lokala variablerna inte kastades bort när "
"en funktion avslutades?  Tänk om du senare kunde återuppta funktionen där "
"den slutade?  Detta är vad generatorer tillhandahåller; de kan betraktas som "
"återupptagbara funktioner."

msgid "Here's the simplest example of a generator function:"
msgstr "Här är det enklaste exemplet på en generatorfunktion:"

msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"Varje funktion som innehåller ett :keyword:`yield`-nyckelord är en "
"generatorfunktion; detta upptäcks av Pythons :term:`bytecode`-kompilator som "
"kompilerar funktionen speciellt som ett resultat."

msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"När du anropar en generatorfunktion returnerar den inte ett enda värde, utan "
"istället ett generatorobjekt som stöder iteratorprotokollet.  Vid exekvering "
"av ``yield``-uttrycket matar generatorn ut värdet för ``i``, på samma sätt "
"som en ``return``-sats.  Den stora skillnaden mellan ``yield`` och en "
"``return``-sats är att när man når en ``yield`` avbryts generatorns "
"exekveringstillstånd och lokala variabler bevaras.  Vid nästa anrop till "
"generatorns :meth:`~generator.__next__`-metod kommer funktionen att "
"återuppta exekveringen."

msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "Här är ett exempel på användning av generatorn ``generate_ints()``:"

msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"Du skulle lika gärna kunna skriva ``for i in generate_ints(5)``, eller ``a, "
"b, c = generate_ints(3)``."

msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"I en generatorfunktion orsakar ``return value`` att ``StopIteration(value)`` "
"utlöses från metoden :meth:`~generator.__next__`.  När detta händer, eller "
"när botten av funktionen har nåtts, avslutas värdeprocesssionen och "
"generatorn kan inte ge några ytterligare värden."

msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"Du kan uppnå effekten av generatorer manuellt genom att skriva din egen "
"klass och lagra alla lokala variabler i generatorn som instansvariabler.  "
"Att returnera en lista med heltal kan till exempel göras genom att sätta "
"``self.count`` till 0 och låta :meth:`~iterator.__next__`-metoden öka ``self."
"count`` och returnera den. Men för en måttligt komplicerad generator kan det "
"vara mycket krångligare att skriva en motsvarande klass."

msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"Testsviten som ingår i Pythons bibliotek, :source:`Lib/test/test_generators."
"py`, innehåller ett antal mer intressanta exempel.  Här är en generator som "
"implementerar en ordnad traversal av ett träd med hjälp av generatorer "
"rekursivt. ::"

msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"\n"
"        yield t.label\n"
"\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""
"# En rekursiv generator som genererar trädblad i ordning.\n"
"def inorder(t):\n"
"    if t:\n"
"        för x i inorder(t.left):\n"
"            avkastning x\n"
"\n"
"        yield t.etikett\n"
"\n"
"        för x i inorder(t.right):\n"
"            avkastning x"

msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"Två andra exempel i ``test_generators.py`` producerar lösningar för N-Queens-"
"problemet (placera N drottningar på ett NxN schackbräde så att ingen "
"drottning hotar en annan) och Knight's Tour (hitta en rutt som tar en "
"riddare till varje ruta på ett NxN schackbräde utan att besöka någon ruta "
"två gånger)."

msgid "Passing values into a generator"
msgstr "Överföra värden till en generator"

msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"I Python 2.4 och tidigare producerade generatorer bara utdata.  När en "
"generators kod anropades för att skapa en iterator fanns det inget sätt att "
"skicka någon ny information till funktionen när dess exekvering återupptas.  "
"Du kan hacka ihop denna förmåga genom att få generatorn att titta på en "
"global variabel eller genom att skicka in något mutabelt objekt som "
"anroparna sedan ändrar, men dessa tillvägagångssätt är röriga."

msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"I Python 2.5 finns det ett enkelt sätt att skicka värden till en generator. :"
"keyword:`yield` blev ett uttryck som returnerar ett värde som kan tilldelas "
"en variabel eller på annat sätt bearbetas::"

msgid "val = (yield i)"
msgstr "val = (avkastning i)"

msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Jag rekommenderar att du **alltid** sätter parenteser runt ett ``yield``-"
"uttryck när du gör något med det returnerade värdet, som i exemplet ovan. "
"Parenteserna är inte alltid nödvändiga, men det är lättare att alltid lägga "
"till dem istället för att behöva komma ihåg när de behövs."

msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` förklarar de exakta reglerna, som är att ett ``yield``-uttryck "
"alltid måste vara inom parentes utom när det förekommer i toppnivåuttrycket "
"på höger sida av en tilldelning.  Detta innebär att du kan skriva ``val = "
"yield i`` men måste använda parenteser när det finns en operation, som i "
"``val = (yield i) + 12``.)"

msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"Värden skickas till en generator genom att anropa dess metod :meth:"
"`send(value) <generator.send>`.  Denna metod återupptar generatorns kod och "
"uttrycket ``yield`` returnerar det angivna värdet.  Om den vanliga metoden :"
"meth:`~generator.__next__` anropas returnerar ``yield`` ``None``."

msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"Här är en enkel räknare som ökar med 1 och gör det möjligt att ändra värdet "
"på den interna räknaren."

msgid ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (yield i)\n"
"        # If value provided, change counter\n"
"        if val is not None:\n"
"            i = val\n"
"        else:\n"
"            i += 1"
msgstr ""
"def counter(maximum):\n"
"    i = 0\n"
"    while i < maximum:\n"
"        val = (avkastning i)\n"
"        # Om värde tillhandahålls, ändra räknaren\n"
"        om val inte är None:\n"
"            i = val\n"
"        i annat fall\n"
"            i += 1"

msgid "And here's an example of changing the counter:"
msgstr "Och här är ett exempel på hur man ändrar räknaren:"

msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"Eftersom ``yield`` ofta kommer att returnera ``None``, bör du alltid "
"kontrollera för detta fall.  Använd inte bara dess värde i uttryck om du "
"inte är säker på att metoden :meth:`~generator.send` kommer att vara den "
"enda metod som används för att återuppta din generatorfunktion."

msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr ""
"Förutom :meth:`~generator.send` finns det två andra metoder för generatorer:"

msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the "
"generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` används för att skapa ett undantag "
"inuti generatorn; undantaget skapas av ``yield``-uttrycket där generatorns "
"exekvering pausas."

msgid ""
":meth:`~generator.close` sends a :exc:`GeneratorExit` exception to the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""
":meth:`~generator.close` skickar ett :exc:`GeneratorExit` undantag till "
"generatorn för att avsluta iterationen.  Vid mottagandet av detta undantag "
"måste generatorns kod antingen höja :exc:`GeneratorExit` eller :exc:"
"`StopIteration`; att fånga undantaget och göra något annat är olagligt och "
"kommer att utlösa ett :exc:`RuntimeError`. :meth:`~generator.close` kommer "
"också att anropas av Pythons skräpsamlare när generatorn är skräpsamlad."

msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"Om du behöver köra upprensningskod när en :exc:`GeneratorExit` inträffar "
"föreslår jag att du använder en ``try: ... finally:`` svit istället för att "
"fånga :exc:`GeneratorExit`."

msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"Den sammantagna effekten av dessa förändringar är att generatorer förvandlas "
"från enkelriktade producenter av information till både producenter och "
"konsumenter."

msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"Generatorer blir också **koroutiner**, en mer generaliserad form av "
"subrutiner. Subrutiner startas vid en punkt och avslutas vid en annan punkt "
"(toppen av funktionen och ett `return`-svar), medan coroutines kan startas, "
"avslutas och återupptas vid många olika punkter (`yield`-svar)."

msgid "Built-in functions"
msgstr "Inbyggda funktioner"

msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"Låt oss titta närmare på inbyggda funktioner som ofta används med iteratorer."

msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr ""
"Två av Pythons inbyggda funktioner, :func:`map` och :func:`filter`, "
"duplicerar funktionerna i generatoruttryck:"

msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...) <map>` returnerar en iterator över sekvensen"

msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."

msgid "You can of course achieve the same effect with a list comprehension."
msgstr "Du kan naturligtvis uppnå samma effekt med en listförståelse."

msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` returnerar en iterator över alla "
"sekvenselement som uppfyller ett visst villkor, och dupliceras på liknande "
"sätt av listförståelser.  Ett **predikat** är en funktion som returnerar "
"sanningsvärdet för ett visst villkor; för användning med :func:`filter` "
"måste predikatet ta ett enda värde."

msgid "This can also be written as a list comprehension:"
msgstr "Detta kan också skrivas som en listförståelse:"

msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` räknar bort elementen i "
"iterabeln och returnerar 2-tuples som innehåller antalet (från *start*) och "
"varje element. ::"

msgid ""
">>> for item in enumerate(['subject', 'verb', 'object']):\n"
"...     print(item)\n"
"(0, 'subject')\n"
"(1, 'verb')\n"
"(2, 'object')"
msgstr ""
">>> for item in enumerate(['subject', 'verb', 'objekt']):\n"
"... print(item)\n"
"(0, 'ämne')\n"
"(1, 'verb')\n"
"(2, 'objekt')"

msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` används ofta när man loopar genom en lista och registrerar "
"de index vid vilka vissa villkor är uppfyllda::"

msgid ""
"f = open('data.txt', 'r')\n"
"for i, line in enumerate(f):\n"
"    if line.strip() == '':\n"
"        print('Blank line at line #%i' % i)"
msgstr ""
"f = open('data.txt', 'r')\n"
"för i, rad i uppräkning(f):\n"
"    if line.strip() == '':\n"
"        print('Blank rad på rad #%i' % i)"

msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` samlar alla "
"element i iterable i en lista, sorterar listan och returnerar det sorterade "
"resultatet.  Argumenten *key* och *reverse* skickas vidare till den "
"konstruerade listans :meth:`~list.sort`-metod. ::"

msgid ""
">>> import random\n"
">>> # Generate 8 random numbers between [0, 10000)\n"
">>> rand_list = random.sample(range(10000), 8)\n"
">>> rand_list\n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorted(rand_list)\n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorted(rand_list, reverse=True)\n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"
msgstr ""
">>> import slumptal\n"
">>> # Generera 8 slumpmässiga nummer mellan [0, 10000)\n"
">>> rand_list = slumpmässigt.urval(intervall(10000), 8)\n"
">>> rand_list\n"
"[769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]\n"
">>> sorterad(rand_lista)\n"
"[769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]\n"
">>> sorterad(rand_list, reverse=True)\n"
"[9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]"

msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr ""
"(För en mer detaljerad diskussion om sortering, se :ref:`sortinghowto`)"

msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"Inbyggnaderna :func:`any(iter) <any>` och :func:`all(iter) <all>` tittar på "
"sanningsvärdena i en iterabels innehåll. :func:`any` returnerar ``True`` om "
"något element i iterabeln är ett sant värde, och :func:`all` returnerar "
"``True`` om alla element är sanna värden:"

msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` tar ett element från varje iterabel och "
"returnerar dem i en tupel::"

msgid ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"
msgstr ""
"zip(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2), ('c', 3)"

msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"Den konstruerar inte en lista i minnet och tömmer inte alla inmatade "
"iteratorer innan den returneras; istället konstrueras och returneras tupler "
"endast om de begärs.  (Den tekniska termen för detta beteende är \"lazy "
"evaluation\" <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"

msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"Denna iterator är avsedd att användas med iterabler som alla har samma "
"längd.  Om iteratorerna är olika långa kommer den resulterande strömmen att "
"vara lika lång som den kortaste iteratorn. ::"

msgid ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"
msgstr ""
"zip(['a', 'b'], (1, 2, 3)) =>\n"
"  ('a', 1), ('b', 2)"

msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"Du bör dock undvika att göra detta, eftersom ett element kan tas från de "
"längre iteratorerna och kasseras.  Detta innebär att du inte kan fortsätta "
"att använda iteratorerna ytterligare eftersom du riskerar att hoppa över ett "
"kasserat element."

msgid "The itertools module"
msgstr "Modulen itertools"

msgid ""
"The :mod:`itertools` module contains a number of commonly used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
"Modulen :mod:`itertools` innehåller ett antal vanligt förekommande "
"iteratorer samt funktioner för att kombinera flera iteratorer.  Detta "
"avsnitt introducerar modulens innehåll genom att visa små exempel."

msgid "The module's functions fall into a few broad classes:"
msgstr "Modulens funktioner kan delas in i ett par breda klasser:"

msgid "Functions that create a new iterator based on an existing iterator."
msgstr "Funktioner som skapar en ny iterator baserat på en befintlig iterator."

msgid "Functions for treating an iterator's elements as function arguments."
msgstr ""
"Funktioner för att behandla en iterators element som funktionsargument."

msgid "Functions for selecting portions of an iterator's output."
msgstr "Funktioner för att välja ut delar av en iterators utdata."

msgid "A function for grouping an iterator's output."
msgstr "En funktion för att gruppera en iterators utdata."

msgid "Creating new iterators"
msgstr "Skapa nya iteratorer"

msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` returnerar en oändlig "
"ström av jämnt fördelade värden.  Du kan välja att ange starttalet, som är 0 "
"som standard, och intervallet mellan talen, som är 1: som standard:"

msgid ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) =>\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."
msgstr ""
"itertools.count() =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"itertools.count(10) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"itertools.count(10, 5) => 10, 15, 20, 25, ..\n"
"  10, 15, 20, 25, 30, 35, 40, 45, 50, 55, ..."

msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` sparar en kopia av "
"innehållet i en angiven iterabel och returnerar en ny iterator som "
"returnerar dess element från första till sista.  Den nya iteratorn kommer "
"att upprepa dessa element i oändlighet. ::"

msgid ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."
msgstr ""
"itertools.cycle([1, 2, 3, 4, 5]) =>\n"
"  1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ..."

msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returnerar det "
"angivna elementet *n* gånger, eller returnerar elementet oändligt om *n* "
"inte anges. ::"

msgid ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"
msgstr ""
"itertools.repeat('abc') =>\n"
"  abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, abc, ...\n"
"itertools.repeat('abc', 5) =>\n"
"  abc, abc, abc, abc, abc"

msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` tar ett "
"godtyckligt antal iteratorer som indata, och returnerar alla element i den "
"första iteratorn, sedan alla element i den andra, och så vidare, tills alla "
"iteratorer har uttömts. ::"

msgid ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"
msgstr ""
"itertools.chain(['a', 'b', 'c'], (1, 2, 3)) =>\n"
"  a, b, c, 1, 2, 3"

msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returnerar en ström som är en del av iteratorn.  Med ett enda *stop*-"
"argument returneras de första *stop*-elementen.  Om du anger ett startindex "
"får du *stop-start*-element, och om du anger ett värde för *step* hoppas "
"elementen över i enlighet med detta.  Till skillnad från Pythons sträng- och "
"listskärning kan du inte använda negativa värden för *start*, *stop* eller "
"*step*:"

msgid ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8) =>\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(range(10), 2, 8, 2) =>\n"
"  2, 4, 6"
msgstr ""
"itertools.islice(range(10), 8) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7\n"
"itertools.islice(intervall(10), 2, 8) => 2, 3, 4, 5, 6, 7\n"
"  2, 3, 4, 5, 6, 7\n"
"itertools.islice(intervall(10), 2, 8, 2) => 2\n"
"  2, 4, 6"

msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replikerar en iterator; den "
"returnerar *n* oberoende iteratorer som alla kommer att returnera innehållet "
"i källiteratorn. Om du inte anger något värde för *n* är standardvärdet 2. "
"Replikering av iteratorer kräver att en del av innehållet i källiteratorn "
"sparas, så detta kan förbruka betydande minne om iteratorn är stor och en av "
"de nya iteratorerna förbrukas mer än de andra. ::"

msgid ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"where iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"and   iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."
msgstr ""
"itertools.tee( itertools.count() ) =>\n"
"   iterA, iterB\n"
"\n"
"där iterA ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...\n"
"\n"
"och iterB ->\n"
"   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..."

msgid "Calling functions on elements"
msgstr "Anropa funktioner på element"

msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
"Modulen :mod:`operator` innehåller en uppsättning funktioner som motsvarar "
"Pythons operatorer.  Några exempel är :func:`operator.add(a, b) <operator."
"add>` (lägger till två värden), :func:`operator.ne(a, b) <operator.ne>` "
"(samma som ``a != b``), och :func:`operator.attrgetter('id') <operator."
"attrgetter>` (returnerar en anropbar funktion som hämtar attributet ``.id``)."

msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` antar att iterable "
"kommer att returnera en ström av tuples, och anropar *func* med dessa tuples "
"som argument::"

msgid ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"
msgstr ""
"itertools.starmap(os.path.join,\n"
"                  [('/bin', 'python'), ('/usr', 'bin', 'java'),\n"
"                   ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n"
"=>\n"
"  /bin/python, /usr/bin/java, /usr/bin/perl, /usr/bin/ruby"

msgid "Selecting elements"
msgstr "Välja element"

msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"En annan grupp av funktioner väljer en delmängd av en iterators element "
"baserat på ett predikat."

msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` är "
"motsatsen till :func:`filter` och returnerar alla element för vilka "
"predikatet returnerar false::"

msgid ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."
msgstr ""
"itertools.filterfalse(is_even, itertools.count()) =>\n"
"  1, 3, 5, 7, 9, 11, 13, 15, ..."

msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` "
"returnerar element så länge som predikatet returnerar sant.  När predikatet "
"returnerar falskt kommer iteratorn att signalera slutet på sina resultat. ::"

msgid ""
"def less_than_10(x):\n"
"    return x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(is_even, itertools.count()) =>\n"
"  0"
msgstr ""
"def less_than_10(x):\n"
"    returnera x < 10\n"
"\n"
"itertools.takewhile(less_than_10, itertools.count()) =>\n"
"  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n"
"\n"
"itertools.takewhile(är_jämn, itertools.count()) =>\n"
"  0"

msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` kasserar "
"element medan predikatet returnerar sant, och returnerar sedan resten av "
"iterabelns resultat. ::"

msgid ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(is_even, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."
msgstr ""
"itertools.dropwhile(less_than_10, itertools.count()) =>\n"
"  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n"
"\n"
"itertools.dropwhile(är_jämn, itertools.count()) =>\n"
"  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ..."

msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` tar två "
"iteratorer och returnerar endast de element i *data* för vilka motsvarande "
"element i *selectors* är sant, och stoppar när någon av dem är uttömd::"

msgid ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"
msgstr ""
"itertools.compress([1, 2, 3, 4, 5], [True, True, False, False, True]) =>\n"
"   1, 2, 5"

msgid "Combinatoric functions"
msgstr "Kombinatoriska funktioner"

msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returnerar en iterator som ger alla möjliga *r*-tupelkombinationer av de "
"element som ingår i *iterable*. ::"

msgid ""
"itertools.combinations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) =>\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"
msgstr ""
"itertools.combinations([1, 2, 3, 4, 5], 2) => (1, 2, 3, (1, 4, 5)\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 3), (2, 4), (2, 5),\n"
"  (3, 4), (3, 5),\n"
"  (4, 5)\n"
"\n"
"itertools.combinations([1, 2, 3, 4, 5], 3) => (1, 2, 3)\n"
"  (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5),\n"
"  (2, 3, 4), (2, 3, 5), (2, 4, 5),\n"
"  (3, 4, 5)"

msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"Elementen i varje tupel kvarstår i samma ordning som *iterable* returnerade "
"dem.  Till exempel är siffran 1 alltid före 2, 3, 4 eller 5 i exemplen "
"ovan.  En liknande funktion, :func:`itertools.permutations(iterable, r=None) "
"<itertools.permutations>`, tar bort denna begränsning av ordningen och "
"returnerar alla möjliga arrangemang av längden *r*::"

msgid ""
"itertools.permutations([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutations([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"
msgstr ""
"itertools.permutationer([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 1), (2, 3), (2, 4), (2, 5),\n"
"  (3, 1), (3, 2), (3, 4), (3, 5),\n"
"  (4, 1), (4, 2), (4, 3), (4, 5),\n"
"  (5, 1), (5, 2), (5, 3), (5, 4)\n"
"\n"
"itertools.permutationer([1, 2, 3, 4, 5]) =>\n"
"  (1, 2, 3, 4, 5), (1, 2, 3, 5, 4), (1, 2, 4, 3, 5),\n"
"  ...\n"
"  (5, 4, 3, 2, 1)"

msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"Om du inte anger något värde för *r* används iterationens längd, vilket "
"innebär att alla element permuteras."

msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"Observera att dessa funktioner producerar alla möjliga kombinationer efter "
"position och inte kräver att innehållet i *iterable* är unikt::"

msgid ""
"itertools.permutations('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"
msgstr ""
"itertools.permutationer('aba', 3) =>\n"
"  ('a', 'b', 'a'), ('a', 'a', 'b'), ('b', 'a', 'a'),\n"
"  ('b', 'a', 'a'), ('a', 'a', 'b'), ('a', 'b', 'a')"

msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"Den identiska tupeln ``('a', 'a', 'b')`` förekommer två gånger, men de två "
"'a'-strängarna kom från olika positioner."

msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
"Funktionen :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` släpper på en annan begränsning: "
"element kan upprepas inom en enda tupel.  Konceptuellt väljs ett element för "
"den första positionen i varje tupel och ersätts sedan innan det andra "
"elementet väljs. ::"

msgid ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) =>\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"
msgstr ""
"itertools.combinations_with_replacement([1, 2, 3, 4, 5], 2) => (1, 1, 2, 1, "
"3, 4, 5)\n"
"  (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),\n"
"  (2, 2), (2, 3), (2, 4), (2, 5),\n"
"  (3, 3), (3, 4), (3, 5),\n"
"  (4, 4), (4, 5),\n"
"  (5, 5)"

msgid "Grouping elements"
msgstr "Gruppering av element"

msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"Den sista funktionen som jag ska diskutera, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, är den mest komplicerade.  "
"``key_func(elem)`` är en funktion som kan beräkna ett nyckelvärde för varje "
"element som returneras av iterable.  Om du inte anger någon nyckelfunktion "
"är nyckeln helt enkelt varje element i sig."

msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` samlar in alla på varandra följande element från "
"den underliggande iterabeln som har samma nyckelvärde och returnerar en "
"ström av 2-tuples som innehåller ett nyckelvärde och en iterator för "
"elementen med den nyckeln."

msgid ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    return city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"where\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 =>\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 =>\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"
msgstr ""
"city_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n"
"             ('Anchorage', 'AK'), ('Nome', 'AK'),\n"
"             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n"
"             ...\n"
"            ]\n"
"\n"
"def get_state(city_state):\n"
"    returnera city_state[1]\n"
"\n"
"itertools.groupby(city_list, get_state) =>\n"
"  ('AL', iterator-1),\n"
"  ('AK', iterator-2),\n"
"  ('AZ', iterator-3), ...\n"
"\n"
"där\n"
"iterator-1 =>\n"
"  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\n"
"iterator-2 => ('Anchor', 'AL')\n"
"  ('Anchorage', 'AK'), ('Nome', 'AK')\n"
"iterator-3 => ('Flagstaff', 'AK')\n"
"  ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')"

msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` förutsätter att innehållet i den underliggande "
"iterabeln redan är sorterat baserat på nyckeln.  Observera att de "
"returnerade iteratorerna också använder den underliggande iterabeln, så du "
"måste konsumera resultaten av iterator-1 innan du begär iterator-2 och dess "
"motsvarande nyckel."

msgid "The functools module"
msgstr "Modulen functools"

msgid ""
"The :mod:`functools` module contains some higher-order functions. A **higher-"
"order function** takes one or more functions as input and returns a new "
"function.  The most useful tool in this module is the :func:`functools."
"partial` function."
msgstr ""
"Modulen :mod:`functools` innehåller några funktioner av högre ordning. En "
"**högre ordningens funktion** tar en eller flera funktioner som indata och "
"returnerar en ny funktion.  Det mest användbara verktyget i denna modul är "
"funktionen :func:`functools.partial`."

msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"För program som är skrivna i en funktionell stil vill du ibland konstruera "
"varianter av befintliga funktioner som har några av parametrarna ifyllda. "
"Tänk på en Python-funktion ``f(a, b, c)``; du kanske vill skapa en ny "
"funktion ``g(b, c)`` som är likvärdig med ``f(1, b, c)``; du fyller i ett "
"värde för en av ``f()``:s parametrar.  Detta kallas \"partiell "
"funktionstillämpning\"."

msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
"Konstruktorn för :func:`~functools.partial` tar argumenten ``(function, "
"arg1, arg2, ..., kwarg1=värde1, kwarg2=värde2)``.  Det resulterande objektet "
"är anropsbart, så du kan bara anropa det för att anropa ``function`` med de "
"ifyllda argumenten."

msgid "Here's a small but realistic example::"
msgstr "Här är ett litet men realistiskt exempel::"

msgid ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"
msgstr ""
"import functools\n"
"\n"
"def log(message, subsystem):\n"
"    \"\"\"Write the contents of 'message' to the specified subsystem.\"\"\"\n"
"    print('%s: %s' % (subsystem, message))\n"
"    ...\n"
"\n"
"server_log = functools.partial(log, subsystem='server')\n"
"server_log('Unable to open socket')"

msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"utför en kumulativ operation på alla iterationens element och kan därför "
"inte tillämpas på oändliga iterationer. *func* måste vara en funktion som "
"tar två element och returnerar ett enda värde. :func:`functools.reduce` tar "
"de två första elementen A och B som returneras av iteratorn och beräknar "
"``func(A, B)``.  Den begär sedan det tredje elementet, C, beräknar "
"``func(func(A, B), C)``, kombinerar detta resultat med det fjärde elementet "
"som returneras och fortsätter tills iteratorn är uttömd.  Om iterabeln inte "
"returnerar några värden alls, uppstår ett :exc:`TypeError` undantag.  Om det "
"initiala värdet anges används det som utgångspunkt och ``func(initial_value, "
"A)`` är den första beräkningen. ::"

msgid ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: reduce() of empty sequence with no initial value\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"
msgstr ""
">>> import operator, functools\n"
">>> functools.reduce(operator.concat, ['A', 'BB', 'C'])\n"
"'ABBC'\n"
">>> functools.reduce(operator.concat, [])\n"
"Traceback (senaste anropet senast):\n"
"  ...\n"
"TypeError: reduce() av tom sekvens utan något initialt värde\n"
">>> functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"6\n"
">>> functools.reduce(operator.mul, [], 1)\n"
"1"

msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"Om du använder :func:`operator.add` med :func:`functools.reduce` kommer du "
"att lägga ihop alla element i iterabeln.  Det här fallet är så vanligt att "
"det finns en speciell inbyggd funktion som heter :func:`sum` för att beräkna "
"det:"

msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr ""
"För många användningar av :func:`functools.reduce` kan det dock vara "
"tydligare att bara skriva den uppenbara :keyword:`for` -loopen::"

msgid ""
"import functools\n"
"# Instead of:\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# You can write:\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"
msgstr ""
"import functools\n"
"# Instead of:\n"
"product = functools.reduce(operator.mul, [1, 2, 3], 1)\n"
"\n"
"# You can write:\n"
"product = 1\n"
"for i in [1, 2, 3]:\n"
"    product *= i"

msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`~itertools.accumulate` returns an "
"iterator that also yields each partial result::"
msgstr ""
"En relaterad funktion är :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  Den utför samma beräkning, men istället för "
"att bara returnera det slutliga resultatet returnerar :func:`~itertools."
"accumulate` en iterator som också ger varje delresultat::"

msgid ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"
msgstr ""
"itertools.accumulate([1, 2, 3, 4, 5]) =>\n"
"  1, 3, 6, 10, 15\n"
"\n"
"itertools.ackumulera([1, 2, 3, 4, 5], operator.mul) =>\n"
"  1, 2, 6, 24, 120"

msgid "The operator module"
msgstr "Operatormodulen"

msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"Modulen :mod:`operator` nämndes tidigare.  Den innehåller en uppsättning "
"funktioner som motsvarar Pythons operatorer.  Dessa funktioner är ofta "
"användbara i funktionell kod eftersom de gör att man slipper skriva triviala "
"funktioner som utför en enda operation."

msgid "Some of the functions in this module are:"
msgstr "Några av funktionerna i denna modul är:"

msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"Matematiska operationer: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."

msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "Logiska operationer: ``not_()``, ``truth()``."

msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "Bitvisa operationer: ``och_()``, ``eller_()``, ``invert()``."

msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr ""
"Jämförelser: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()`` och ``ge()``."

msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "Objektets identitet: ``is_()``, ``is_not()``."

msgid "Consult the operator module's documentation for a complete list."
msgstr "Se operatormodulens dokumentation för en fullständig lista."

msgid "Small functions and the lambda expression"
msgstr "Små funktioner och lambda-uttrycket"

msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"När du skriver program i funktionell stil behöver du ofta små funktioner som "
"fungerar som predikat eller som kombinerar element på något sätt."

msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr ""
"Om det finns en inbyggd Python-funktion eller en modulfunktion som är "
"lämplig behöver du inte definiera en ny funktion alls::"

msgid ""
"stripped_lines = [line.strip() for line in lines]\n"
"existing_files = filter(os.path.exists, file_list)"
msgstr ""
"stripped_lines = [line.strip() för line i lines]\n"
"befintliga_filer = filter(os.path.exists, fil_lista)"

msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"Om den funktion du behöver inte finns, måste du skriva den.  Ett sätt att "
"skriva små funktioner är att använda uttrycket :keyword:`lambda`.  "
"``lambda`` tar ett antal parametrar och ett uttryck som kombinerar dessa "
"parametrar, och skapar en anonym funktion som returnerar värdet av "
"uttrycket::"

msgid ""
"adder = lambda x, y: x+y\n"
"\n"
"print_assign = lambda name, value: name + '=' + str(value)"
msgstr ""
"adderare = lambda x, y: x+y\n"
"\n"
"print_assign = lambda namn, värde: namn + '=' + str(värde)"

msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr ""
"Ett alternativ är att bara använda ``def``-satsen och definiera en funktion "
"på vanligt sätt::"

msgid ""
"def adder(x, y):\n"
"    return x + y\n"
"\n"
"def print_assign(name, value):\n"
"    return name + '=' + str(value)"
msgstr ""
"def adder(x, y):\n"
"    returnerar x + y\n"
"\n"
"def print_assign(namn, värde):\n"
"    return namn + '=' + str(värde)"

msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"Vilket alternativ är att föredra?  Det är en stilfråga; min vanliga kurs är "
"att undvika att använda ``lambda``."

msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"Ett skäl till att jag föredrar ``lambda`` är att det är ganska begränsat "
"vilka funktioner som kan definieras.  Resultatet måste vara beräkningsbart "
"som ett enda uttryck, vilket innebär att du inte kan ha flervägs ``if... "
"elif... else``-jämförelser eller ``try... except``-satser.  Om du försöker "
"göra för mycket i ett ``lambda``-uttalande kommer du att få ett alltför "
"komplicerat uttryck som är svårt att läsa.  Snabbt, vad gör följande kod? ::"

msgid ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"
msgstr ""
"import functools\n"
"total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]"

msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"Du kan räkna ut det, men det tar tid att reda ut uttrycket för att ta reda "
"på vad som händer.  Att använda en kort nästlad ``def``-sats gör saker lite "
"bättre::"

msgid ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"
msgstr ""
"import functools\n"
"def combine(a, b):\n"
"    return 0, a[1] + b[1]\n"
"\n"
"total = functools.reduce(combine, items)[1]"

msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr ""
"Men det bästa av allt hade varit om jag helt enkelt hade använt en ``for``-"
"loop::"

msgid ""
"total = 0\n"
"for a, b in items:\n"
"    total += b"
msgstr ""
"totalt = 0\n"
"för a, b i artiklar:\n"
"    total += b"

msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "Eller den inbyggda :func:`sum` och ett generatoruttryck::"

msgid "total = sum(b for a, b in items)"
msgstr "total = sum(b for a, b in items)"

msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"Många användningar av :func:`functools.reduce` är tydligare när de skrivs "
"som ``for``-loopar."

msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr ""
"Fredrik Lundh föreslog en gång följande uppsättning regler för "
"refaktorisering av användningar av ``lambda``:"

msgid "Write a lambda function."
msgstr "Skriv en lambda-funktion."

msgid "Write a comment explaining what the heck that lambda does."
msgstr "Skriv en kommentar som förklarar vad sjutton den där lambdan gör."

msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr ""
"Studera kommentaren en stund och fundera ut ett namn som fångar essensen i "
"kommentaren."

msgid "Convert the lambda to a def statement, using that name."
msgstr "Konvertera lambdan till en def-sats med det namnet."

msgid "Remove the comment."
msgstr "Ta bort kommentaren."

msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"Jag gillar verkligen de här reglerna, men det är fritt fram att inte hålla "
"med om huruvida den här lambda-fria stilen är bättre."

msgid "Revision History and Acknowledgements"
msgstr "Revideringshistorik och erkännanden"

msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"Författaren vill tacka följande personer för förslag, korrigeringar och "
"hjälp med olika utkast av denna artikel: Ian Bicking, Nick Coghlan, Nick "
"Efford, Raymond Hettinger, Jim Jewett, Mike Krell, Leandro Lameiro, Jussi "
"Salmela, Collin Winter, Blake Winton."

msgid "Version 0.1: posted June 30 2006."
msgstr "Version 0.1: publicerad den 30 juni 2006."

msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "Version 0.11: publicerad den 1 juli 2006.  Rättelser av stavfel."

msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Version 0.2: publicerad 10 juli 2006.  Sammanslagna genexp- och listcomp-"
"avsnitt till ett. Korrigeringar av stavfel."

msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Version 0.21: Lagt till fler referenser som föreslagits på tutor-"
"mailinglistan."

msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Version 0.30: Lägger till ett avsnitt om den ``funktionella`` modulen "
"skriven av Collin Winter; lägger till ett kort avsnitt om operatormodulen; "
"några andra redigeringar."

msgid "References"
msgstr "Referenser"

msgid "General"
msgstr "Allmänt"

msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  The book can be found at https://"
"mitpress.mit.edu/sicp.  In this classic textbook of computer science, "
"chapters 2 and 3 discuss the use of sequences and streams to organize the "
"data flow inside a program.  The book uses Scheme for its examples, but many "
"of the design approaches described in these chapters are applicable to "
"functional-style Python code."
msgstr ""
"**Structure and Interpretation of Computer Programs**, av Harold Abelson och "
"Gerald Jay Sussman med Julie Sussman.  Boken finns tillgänglig på https://"
"mitpress.mit.edu/sicp.  I denna klassiska lärobok i datavetenskap diskuteras "
"i kapitlen 2 och 3 användningen av sekvenser och strömmar för att organisera "
"dataflödet i ett program.  Boken använder Scheme för sina exempel, men många "
"av de designmetoder som beskrivs i dessa kapitel är tillämpliga på Python-"
"kod i funktionell stil."

msgid ""
"https://defmacro.org/2006/06/19/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"https://defmacro.org/2006/06/19/fp.html: En allmän introduktion till "
"funktionell programmering som använder Java-exempel och har en lång "
"historisk introduktion."

msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: Allmän Wikipedia-post "
"som beskriver funktionell programmering."

msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: Inlägg för coroutines."

msgid ""
"https://en.wikipedia.org/wiki/Partial_application: Entry for the concept of "
"partial function application."
msgstr ""
"https://en.wikipedia.org/wiki/Partial_application: Inlägg för begreppet "
"partiell funktionstillämpning."

msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: Inlägg för begreppet currying."

msgid "Python-specific"
msgstr "Python-specifik"

msgid ""
"https://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"https://gnosis.cx/TPiP/: I det första kapitlet i David Mertz bok :title-"
"reference:`Text Processing in Python` diskuteras funktionell programmering "
"för textbearbetning, i avsnittet \"Utilizing Higher-Order Functions in Text "
"Processing\"."

msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://developer.ibm.com/articles/l-"
"prog/>`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, and "
"`part 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Mertz har också skrivit en artikelserie i tre delar om funktionell "
"programmering för IBM:s DeveloperWorks-webbplats; se \"del 1\" <https://"
"developer.ibm.com/articles/l-prog/>`__, \"del 2\" <https://developer.ibm.com/"
"tutorials/l-prog2/>`__ och \"del 3\" <https://developer.ibm.com/tutorials/l-"
"prog3/>`__,"

msgid "Python documentation"
msgstr "Python-dokumentation"

msgid "Documentation for the :mod:`itertools` module."
msgstr "Dokumentation för modulen :mod:`itertools`."

msgid "Documentation for the :mod:`functools` module."
msgstr "Dokumentation för modulen :mod:`functools`."

msgid "Documentation for the :mod:`operator` module."
msgstr "Dokumentation för modulen :mod:`operator`."

msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Generatoruttryck\""

msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Coroutines via Enhanced Generators\" beskriver de nya "
"generatorfunktionerna i Python 2.5."
