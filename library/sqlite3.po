# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`!sqlite3` --- DB-API 2.0-gränssnitt för SQLite-databaser"

msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Källkod:** :source:`Lib/sqlite3/`"

msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite är ett C-bibliotek som tillhandahåller en lättviktig diskbaserad "
"databas som inte kräver en separat serverprocess och som gör det möjligt att "
"komma åt databasen med en icke-standardvariant av frågespråket SQL. Vissa "
"applikationer kan använda SQLite för intern datalagring.  Det är också "
"möjligt att prototypa en applikation med SQLite och sedan porta koden till "
"en större databas som PostgreSQL eller Oracle."

msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.15.2 or newer."
msgstr ""
"Modulen :mod:`!sqlite3` är skriven av Gerhard Häring.  Den tillhandahåller "
"ett SQL-gränssnitt som överensstämmer med DB-API 2.0-specifikationen som "
"beskrivs av :pep:`249` och kräver SQLite 3.15.2 eller nyare."

msgid "This document includes four main sections:"
msgstr "Detta dokument innehåller fyra huvudavsnitt:"

msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ""
":ref:`sqlite3-tutorial` lär ut hur man använder modulen :mod:`!sqlite3`."

msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`sqlite3-reference` beskriver de klasser och funktioner som denna modul "
"definierar."

msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` beskriver hur man hanterar specifika uppgifter."

msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`sqlite3-explanation` ger en djupgående bakgrund till "
"transaktionskontroll."

msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"SQLite-webbsidan; dokumentationen beskriver syntaxen och de tillgängliga "
"datatyperna för den SQL-dialekt som stöds."

msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Handledning, referens och exempel för att lära sig SQL-syntax."

msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - API-specifikation för databaser 2.0"

msgid "PEP written by Marc-André Lemburg."
msgstr "PEP skriven av Marc-André Lemburg."

msgid "Tutorial"
msgstr "Handledning"

msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"I den här handledningen skapar du en databas med Monty Python-filmer med "
"hjälp av grundläggande :mod:`!sqlite3`-funktionalitet. Den förutsätter en "
"grundläggande förståelse för databaskoncept, inklusive `cursors`_ och "
"`transactions`_."

msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"Först måste vi skapa en ny databas och öppna en databasanslutning så att :"
"mod:`!sqlite3` kan arbeta med den. Anropa :func:`sqlite3.connect` för att "
"skapa en anslutning till databasen :file:`tutorial.db` i den aktuella "
"arbetskatalogen, och skapa den implicit om den inte finns:"

msgid ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"
msgstr ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"

msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"Det returnerade :class:`Connection`-objektet ``con`` representerar "
"anslutningen till databasen på disken."

msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"För att kunna utföra SQL-satser och hämta resultat från SQL-frågor måste vi "
"använda en databascursor. Anropa :meth:`con.cursor() <Connection.cursor>` "
"för att skapa :class:`Cursor`:"

msgid "cur = con.cursor()"
msgstr "cur = con.cursor()"

msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"Nu när vi har en databasanslutning och en markör kan vi skapa en "
"databastabell ``movie`` med kolumner för titel, utgivningsår och "
"recensionspoäng. För enkelhetens skull kan vi bara använda kolumnnamn i "
"tabelldeklarationen - tack vare SQLites `flexible typing`_-funktion är det "
"valfritt att ange datatyperna. Kör ``CREATE TABLE``-satsen genom att anropa :"
"meth:`cur.execute(...) <Cursor.execute>`:"

msgid "cur.execute(\"CREATE TABLE movie(title, year, score)\")"
msgstr "cur.execute(\"CREATE TABLE film(titel, år, poäng)\")"

msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"Vi kan verifiera att den nya tabellen har skapats genom att fråga tabellen "
"``qlite_master`` som är inbyggd i SQLite, som nu bör innehålla en post för "
"tabelldefinitionen ``movie`` (se `The Schema Table`_ för detaljer). Exekvera "
"frågan genom att anropa :meth:`cur.execute(...) <Cursor.execute>`, tilldela "
"resultatet till ``res`` och anropa :meth:`res.fetchone() <Cursor.fetchone>` "
"för att hämta den resulterande raden:"

msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"
msgstr ""
">>> res = cur.execute(\"VÄLJ namn FRÅN sqlite_master\")\n"
">>> res.fetchone()\n"
"('film',)"

msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone` will return ``None``:"
msgstr ""
"Vi kan se att tabellen har skapats, eftersom frågan returnerar en :class:"
"`tuple` som innehåller tabellens namn. Om vi frågar ``sqlite_master`` efter "
"en icke-existerande tabell ``spam``, kommer :meth:`!res.fetchone`` att "
"returnera ``None``:"

msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"
msgstr ""
">>> res = cur.execute(\"SELECT namn FRÅN sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() är None\n"
"Sant"

msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"Lägg nu till två rader med data som tillhandahålls som SQL-litteraler genom "
"att köra en ``INSERT``-sats, återigen genom att anropa :meth:`cur."
"execute(...) <Cursor.execute>`:"

msgid ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"
msgstr ""
"cur.execute(\"\"\"\")\n"
"    INSERT INTO film VALUES\n"
"        ('Monty Python och den heliga graalen', 1975, 8,2),\n"
"        ('Och nu till något helt annat', 1971, 7,5)\n"
"\"\"\")"

msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"Satsen ``INSERT`` öppnar implicit en transaktion, som måste bekräftas innan "
"ändringarna sparas i databasen (se :ref:`sqlite3-controlling-transactions` "
"för mer information). Anropa :meth:`con.commit() <Connection.commit>` på "
"anslutningsobjektet för att bekräfta transaktionen:"

msgid "con.commit()"
msgstr "con.commit()"

msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"Vi kan verifiera att data infogades korrekt genom att köra en ``SELECT``-"
"fråga. Använd den numera välkända :meth:`cur.execute(...) <Cursor.execute>` "
"för att tilldela resultatet till ``res``, och anropa :meth:`res.fetchall() "
"<Cursor.fetchall>` för att returnera alla resulterande rader:"

msgid ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"
msgstr ""
">>> res = cur.execute(\"VÄLJ poäng FRÅN film\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"

msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"Resultatet är en :class:`list` med två :class:`!tuple`, en per rad, som var "
"och en innehåller den radens ``score``-värde."

msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"Nu ska du infoga ytterligare tre rader genom att anropa :meth:`cur."
"executemany(...) <Cursor.executemany>`:"

msgid ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Remember to commit the transaction after executing INSERT."
msgstr ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7,9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7,5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8,0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit() # Kom ihåg att genomföra transaktionen efter att du har kört "
"INSERT."

msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"Observera att ``?`` platshållare används för att binda ``data`` till frågan. "
"Använd alltid platshållare istället för :ref:``strängformatering <tut-"
"formatting>`` för att binda Python-värden till SQL-satser, för att undvika "
"`SQL-injektionsattacker`_ (se :ref:`sqlite3-placeholders` för mer "
"information)."

msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"Vi kan verifiera att de nya raderna infogades genom att köra en ``SELECT``-"
"fråga och den här gången iterera över resultaten av frågan:"

msgid ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY "
"year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"
msgstr ""
">>> for row in cur.execute(\"SELECT år, titel FROM film ORDER BY år\"):\n"
"... print(rad)\n"
"(1971, 'Och nu till något helt annat')\n"
"(1975, \"Monty Python och den heliga graalen\")\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, \"Monty Python Live at the Hollywood Bowl\")\n"
"(1983, \"Monty Python's The Meaning of Life\")"

msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"Varje rad är en :class:`tuple` av ``(year, title)`` med två objekt som "
"matchar de kolumner som valts i frågan."

msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"Slutligen kontrollerar du att databasen har skrivits till disken genom att "
"anropa :meth:`con.close() <Connection.close>` för att stänga den befintliga "
"anslutningen, öppna en ny, skapa en ny markör och sedan fråga databasen:"

msgid ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score "
"DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released in "
"{year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', "
"released in 1975\n"
">>> new_con.close()"
msgstr ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"VÄLJ titel, år FRÅN film ORDER BY poäng DESC\")\n"
">>> titel, år = res.fetchone()\n"
">>> print(f'Den Monty Python-film som har högst poäng är {title!r}, släppt i "
"{year}')\n"
"Monty Python-filmen med högst poäng är 'Monty Python and the Holy Grail', "
"släppt 1975\n"
">>> new_con.close()"

msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"Du har nu skapat en SQLite-databas med modulen :mod:`!sqlite3`, lagt in data "
"och hämtat värden från den på flera olika sätt."

msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` för ytterligare läsning:"

msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-platshållare`"

msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-anpassare`"

msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-omvandlare`"

msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-anslutningskontexthanterare`"

msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`sqlite3-explanation` för djupgående bakgrund om transaktionskontroll."

msgid "Reference"
msgstr "Referens"

msgid "Module functions"
msgstr "Modulens funktioner"

msgid "Open a connection to an SQLite database."
msgstr "Öppna en anslutning till en SQLite-databas."

msgid "Parameters"
msgstr "Parametrar"

msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to "
"create an `SQLite database existing only in memory <https://sqlite.org/"
"inmemorydb.html>`_, and open a connection to it."
msgstr ""
"Sökvägen till den databasfil som ska öppnas. Du kan skicka ``\":memory:\"`` "
"för att skapa en `SQLite-databas som bara finns i minnet <https://sqlite.org/"
"inmemorydb.html>`_ och öppna en anslutning till den."

msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"Hur många sekunder anslutningen ska vänta innan den skickar ett :exc:"
"`OperationalError` när en tabell är låst. Om en annan anslutning öppnar en "
"transaktion för att ändra en tabell, kommer tabellen att vara låst tills "
"transaktionen är genomförd. Standard fem sekunder."

msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. By default (``0``), type detection is disabled."
msgstr ""
"Kontrollera om och hur datatyper som inte :ref:``nativt stöds av SQLite "
"<sqlite3-types>`` ska sökas upp för att konverteras till Python-typer, med "
"hjälp av de konverterare som registrerats med :func:`register_converter`. "
"Ställ in den på valfri kombination (med ``|``, bitvis eller) av :const:"
"`PARSE_DECLTYPES` och :const:`PARSE_COLNAMES` för att aktivera detta. "
"Kolumnnamn har företräde framför deklarerade typer om båda flaggorna är "
"inställda. Som standard (``0``) är typdetektering avaktiverad."

msgid ""
"Control legacy transaction handling behaviour. See :attr:`Connection."
"isolation_level` and :ref:`sqlite3-transaction-control-isolation-level` for "
"more information. Can be ``\"DEFERRED\"`` (default), ``\"EXCLUSIVE\"`` or "
"``\"IMMEDIATE\"``; or ``None`` to disable opening transactions implicitly. "
"Has no effect unless :attr:`Connection.autocommit` is set to :const:"
"`~sqlite3.LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""
"Styr beteendet för hantering av äldre transaktioner. Se :attr:`Connection."
"isolation_level` och :ref:`sqlite3-transaction-control-isolation-level` för "
"mer information. Kan vara ``\"DEFERRED\"`` (standard), ``\"EXCLUSIVE\"`` "
"eller ``\"IMMEDIATE\"``; eller ``None`` för att inaktivera implicit öppning "
"av transaktioner. Har ingen effekt om inte :attr:`Connection.autocommit` är "
"satt till :const:`~sqlite3.LEGACY_TRANSACTION_CONTROL` (standard)."

msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"Om ``True`` (standard), kommer :exc:`ProgrammingError` att uppstå om "
"databasanslutningen används av en annan tråd än den som skapade den. Om "
"``False``, kan anslutningen användas av flera trådar; skrivoperationer kan "
"behöva serialiseras av användaren för att undvika datakorruption. Se :attr:"
"`threadsafety` för mer information."

msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"En anpassad underklass av :class:`Connection` för att skapa anslutningen "
"med, om inte standardklassen :class:`Connection` används."

msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
"Antalet satser som :mod:`!sqlite3` ska cacha internt för den här "
"anslutningen för att undvika överbelastning vid parsning. Som standard 128 "
"uttalanden."

msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"Om värdet är ``True`` tolkas *database* som en :abbr:`URI (Uniform Resource "
"Identifier)` med en filsökväg och en valfri frågesträng. Schemadelen *måste* "
"vara ``\"file:\"``, och sökvägen kan vara relativ eller absolut. "
"Frågesträngen gör det möjligt att skicka parametrar till SQLite, vilket "
"möjliggör olika :ref:`sqlite3-uri-tricks`."

msgid ""
"Control :pep:`249` transaction handling behaviour. See :attr:`Connection."
"autocommit` and :ref:`sqlite3-transaction-control-autocommit` for more "
"information. *autocommit* currently defaults to :const:`~sqlite3."
"LEGACY_TRANSACTION_CONTROL`. The default will change to ``False`` in a "
"future Python release."
msgstr ""
"Kontrollerar :pep:`249` transaktionshanteringsbeteende. Se :attr:`Connection."
"autocommit` och :ref:`sqlite3-transaction-control-autocommit` för mer "
"information. *autocommit* är för närvarande standardvärdet för :const:"
"`~sqlite3.LEGACY_TRANSACTION_CONTROL`. Standardvärdet kommer att ändras till "
"``False`` i en framtida Python-version."

msgid "Return type"
msgstr "Typ av retur"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3.connect`` med "
"argumentet ``database``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` med "
"argumentet ``connection_handle``."

msgid "Added the *uri* parameter."
msgstr "Parametern *uri* har lagts till."

msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*databas* kan nu också vara en :term:`path-like object`, inte bara en sträng."

msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr "Lagt till granskningshändelsen ``sqlite3.connect/handle``."

msgid "Added the *autocommit* parameter."
msgstr "Lagt till parametern *autocommit*."

msgid ""
"Positional use of the parameters *timeout*, *detect_types*, "
"*isolation_level*, *check_same_thread*, *factory*, *cached_statements*, and "
"*uri* is deprecated. They will become keyword-only parameters in Python 3.15."
msgstr ""
"Positionell användning av parametrarna *timeout*, *detect_types*, "
"*isolation_level*, *check_same_thread*, *factory*, *cached_statements* och "
"*uri* är föråldrad. De kommer att bli parametrar som endast innehåller "
"nyckelord i Python 3.15."

msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"Returnerar ``True`` om strängen *statement* verkar innehålla en eller flera "
"kompletta SQL-satser. Ingen syntaktisk verifiering eller parsning av något "
"slag utförs, annat än att kontrollera att det inte finns några oavslutade "
"stränglitteraler och att satsen avslutas med ett semikolon."

msgid "For example:"
msgstr "Till exempel:"

msgid ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"
msgstr ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"Sant\n"
">>> sqlite3.complete_statement(\"VÄLJ foo\")\n"
"Falsk"

msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"Denna funktion kan vara användbar vid kommandoradsinmatning för att avgöra "
"om den inmatade texten verkar utgöra en komplett SQL-sats, eller om "
"ytterligare inmatning behövs innan :meth:`~Cursor.execute` anropas."

msgid ""
"See :func:`!runsource` in :source:`Lib/sqlite3/__main__.py` for real-world "
"use."
msgstr ""
"Se :func:`!runsource` i :source:`Lib/sqlite3/__main__.py` för verklig "
"användning."

msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"Aktivera eller inaktivera spårningar av callbacks. Som standard får du inga "
"spårningar i användardefinierade funktioner, aggregat, omvandlare, "
"auktoriseringsanrop etc. Om du vill felsöka dem kan du anropa den här "
"funktionen med *flag* inställd på ``True``. Efteråt kommer du att få "
"spårningar från återkallelser på :data:`sys.stderr`. Använd ``False`` för "
"att inaktivera funktionen igen."

msgid ""
"Errors in user-defined function callbacks are logged as unraisable "
"exceptions. Use an :func:`unraisable hook handler <sys.unraisablehook>` for "
"introspection of the failed callback."
msgstr ""
"Fel i användardefinierade funktionsåterkallelser loggas som ovärderliga "
"undantag. Använd en :func:`unraisable hook handler <sys.unraisablehook>` för "
"introspektion av den misslyckade anropet."

msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"Registrera en *adapter* :term:`callable` för att anpassa Python-typen *type* "
"till en SQLite-typ. Adaptern anropas med ett Python-objekt av typen *type* "
"som enda argument, och måste returnera ett värde av en :ref:`typ som SQLite "
"naturligt förstår <sqlite3-types>`."

msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"Registrera *konverteraren* :term:`callable` för att konvertera SQLite-objekt "
"av typen *typename* till ett Python-objekt av en viss typ. Omvandlaren "
"anropas för alla SQLite-värden av typen *typename*; den får ett :class:"
"`bytes`-objekt och ska returnera ett objekt av önskad Python-typ. Se "
"parametern *detect_types* i :func:`connect` för information om hur "
"typdetektering fungerar."

msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"Obs: *typename* och namnet på typen i din fråga matchas case-insensitivt."

msgid "Module constants"
msgstr "Modul konstanter"

msgid ""
"Set :attr:`~Connection.autocommit` to this constant to select old style (pre-"
"Python 3.12) transaction control behaviour. See :ref:`sqlite3-transaction-"
"control-isolation-level` for more information."
msgstr ""
"Sätt :attr:`~Connection.autocommit` till denna konstant för att välja "
"gammaldags (före Python 3.12) transaktionskontrollbeteende. Se :ref:`sqlite3-"
"transaction-control-isolation-level` för mer information."

msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"Skicka detta flaggvärde till parametern *detect_types* i :func:`connect` för "
"att söka upp en konverteringsfunktion med hjälp av de deklarerade typerna "
"för varje kolumn. Typerna deklareras när databastabellen skapas. :mod:`!"
"sqlite3` söker upp en konverteringsfunktion med det första ordet i den "
"deklarerade typen som nyckel i konverteringsordlistan. Till exempel"

msgid ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! will look up a converter named \"integer\"\n"
"   p point,                ! will look up a converter named \"point\"\n"
"   n number(10)            ! will look up a converter named \"number\"\n"
" )"
msgstr ""
"CREATE TABLE test(\n"
"   i heltal primärnyckel, ! kommer att leta upp en omvandlare med namnet "
"\"heltal\"\n"
"   p punkt, ! kommer att leta upp en omvandlare med namnet \"punkt\"\n"
"   n nummer(10) ! kommer att leta upp en omvandlare som heter \"nummer\"\n"
" )"

msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Denna flagga kan kombineras med :const:`PARSE_COLNAMES` med hjälp av "
"operatorn ``|`` (bitvis eller)."

msgid ""
"Generated fields (for example ``MAX(p)``) are returned as :class:`str`. Use :"
"const:`!PARSE_COLNAMES` to enforce types for such queries."
msgstr ""
"Genererade fält (t.ex. ``MAX(p)``) returneras som :class:`str`. Använd :"
"const:`!PARSE_COLNAMES` för att tvinga fram typer för sådana frågor."

msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The query column name must be "
"wrapped in double quotes (``\"``) and the type name must be wrapped in "
"square brackets (``[]``)."
msgstr ""
"Skicka detta flaggvärde till parametern *detect_types* i :func:`connect` för "
"att söka efter en konverteringsfunktion genom att använda typnamnet, som "
"tolkats från frågekolumnens namn, som nyckel i konverteringsordboken. "
"Frågekolumnnamnet måste vara omslutet av dubbla citattecken (``\"``) och "
"typnamnet måste vara omslutet av hakparenteser (``[]``)."

msgid ""
"SELECT MAX(p) as \"p [point]\" FROM test;  ! will look up converter \"point\""
msgstr ""
"SELECT MAX(p) som \"p [punkt]\" FROM test; ! kommer att leta upp omvandlare "
"\"punkt\""

msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Denna flagga kan kombineras med :const:`PARSE_DECLTYPES` med hjälp av "
"operatorn ``|`` (bitvis eller)."

msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
"Flaggor som ska returneras av *authorizer_callback* :term:`callable` som "
"skickas till :meth:`Connection.set_authorizer`, för att ange om:"

msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "Åtkomst är tillåten (:const:`!SQLITE_OK`),"

msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr "SQL-satsen bör avbrytas med ett fel (:const:`!SQLITE_DENY`)"

msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""
"Kolumnen ska behandlas som ett ``NULL``-värde (:const:`!SQLITE_IGNORE`)"

msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"Strängkonstant som anger den DB-API-nivå som stöds. Krävs av DB-API. "
"Hårdkodad till ``\"2.0\"``."

msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
"Strängkonstant som anger vilken typ av parametermarkörsformatering som "
"förväntas av modulen :mod:`!sqlite3`. Krävs av DB-API. Hårdkodad till "
"``\"qmark\"``."

msgid "The ``named`` DB-API parameter style is also supported."
msgstr "DB-API-parameterstilen ``named`` stöds också."

msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
"Versionsnummer för SQLite-biblioteket för körning som en :class:`string "
"<str>`."

msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
"Versionsnummer för SQLite-biblioteket under körning som en :class:`tuple` "
"av :class:`integers <int>`."

msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
"Heltalskonstant som krävs av DB-API 2.0 och som anger vilken nivå av "
"trådsäkerhet som :mod:`!sqlite3`-modulen stöder. Detta attribut ställs in "
"baserat på standard `threading mode <https://sqlite.org/threadsafe.html>`_ "
"som det underliggande SQLite-biblioteket är kompilerat med. SQLites "
"trådningslägen är:"

msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""
"**En enda tråd**: I detta läge är alla mutexar inaktiverade och SQLite är "
"osäkert att använda i mer än en enda tråd samtidigt."

msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**Multi-tråd**: I det här läget kan SQLite användas säkert av flera trådar, "
"förutsatt att ingen enskild databasanslutning används samtidigt i två eller "
"flera trådar."

msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr ""
"**Serialiserad**: I serialiserat läge kan SQLite användas av flera trådar "
"utan några begränsningar."

msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr ""
"Mappningarna från SQLites trådningslägen till DB-API 2.0:s trådningsnivåer "
"är följande:"

msgid "SQLite threading mode"
msgstr "SQLite-läge för trådning"

msgid ":pep:`threadsafety <0249#threadsafety>`"
msgstr ":pep:`threadsafety <0249#threadsafety>``"

msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

msgid "DB-API 2.0 meaning"
msgstr "DB-API 2.0 betydelse"

msgid "single-thread"
msgstr "enkel tråd"

msgid "0"
msgstr "0"

msgid "Threads may not share the module"
msgstr "Trådarna får inte dela modul"

msgid "multi-thread"
msgstr "flertrådig"

msgid "1"
msgstr "1"

msgid "2"
msgstr "2"

msgid "Threads may share the module, but not connections"
msgstr "Trådar kan dela modul, men inte anslutningar"

msgid "serialized"
msgstr "serialiserad"

msgid "3"
msgstr "3"

msgid "Threads may share the module, connections and cursors"
msgstr "Trådar kan dela modul, anslutningar och markörer"

msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr ""
"Ställ in *threadsafety* dynamiskt istället för att hårdkoda det till ``1``."

msgid ""
"These constants are used for the :meth:`Connection.setconfig` and :meth:"
"`~Connection.getconfig` methods."
msgstr ""
"Dessa konstanter används för metoderna :meth:`Connection.setconfig` och :"
"meth:`~Connection.getconfig`."

msgid ""
"The availability of these constants varies depending on the version of "
"SQLite Python was compiled with."
msgstr ""
"Tillgängligheten för dessa konstanter varierar beroende på vilken version av "
"SQLite Python kompilerades med."

msgid "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"
msgstr "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"

msgid "SQLite docs: Database Connection Configuration Options"
msgstr "Dokument om SQLite: Alternativ för konfiguration av databasanslutning"

msgid "The :data:`!version` and :data:`!version_info` constants."
msgstr "Konstanterna :data:`!version` och :data:`!version_info`."

msgid "Connection objects"
msgstr "Anslutningsobjekt"

msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"Varje öppen SQLite-databas representeras av ett ``Connection``-objekt, som "
"skapas med :func:`sqlite3.connect`. Deras huvudsakliga syfte är att skapa :"
"class:`Cursor`-objekt och :ref:`sqlite3-controlling-transactions`."

msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-anslutning-kortkommandon`"

msgid ""
"A :exc:`ResourceWarning` is emitted if :meth:`close` is not called before a :"
"class:`!Connection` object is deleted."
msgstr ""
"En :exc:`ResourceWarning` skickas ut om :meth:`close` inte anropas innan "
"ett :class:`!Connection`-objekt tas bort."

msgid "An SQLite database connection has the following attributes and methods:"
msgstr "En SQLite-databasanslutning har följande attribut och metoder:"

msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a :term:"
"`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
"Skapa och returnera ett :class:`Cursor`-objekt. Metoden cursor accepterar en "
"enda valfri parameter *factory*. Om den anges måste den vara en :term:"
"`callable` som returnerar en instans av :class:`Cursor` eller dess "
"subklasser."

msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""
"Öppna ett :class:`Blob`-handtag till en befintlig :abbr:`BLOB (Binary Large "
"OBject)`."

msgid "The name of the table where the blob is located."
msgstr "Namnet på den tabell där blobben finns."

msgid "The name of the column where the blob is located."
msgstr "Namnet på den kolumn där blobben är placerad."

msgid "The name of the row where the blob is located."
msgstr "Namnet på den rad där blobben finns."

msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""
"Sätts till ``True`` om blobben ska öppnas utan skrivbehörighet. "
"Standardvärdet är ``False``."

msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr ""
"Namnet på den databas där blobben finns. Standardvärdet är ``\"main\"``."

msgid "Raises"
msgstr "Höjer"

msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "När man försöker öppna en blob i en tabell \"UTAN ROWID\"."

msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
"Blobbstorleken kan inte ändras med hjälp av klassen :class:`Blob`. Använd "
"SQL-funktionen ``zeroblob`` för att skapa en blob med en fast storlek."

msgid ""
"Commit any pending transaction to the database. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was committed by this method."
msgstr ""
"Överför alla pågående transaktioner till databasen. Om :attr:`autocommit` är "
"``True``, eller om det inte finns någon öppen transaktion, gör denna metod "
"ingenting. Om :attr:`!autocommit` är ``False``, öppnas en ny transaktion "
"implicit om en pågående transaktion bekräftades med denna metod."

msgid ""
"Roll back to the start of any pending transaction. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was rolled back by this method."
msgstr ""
"Rullar tillbaka till början av en väntande transaktion. Om :attr:"
"`autocommit` är ``True``, eller om det inte finns någon öppen transaktion, "
"gör denna metod ingenting. Om :attr:`!autocommit` är ``False``, öppnas en ny "
"transaktion implicit om en pågående transaktion rullades tillbaka med denna "
"metod."

msgid ""
"Close the database connection. If :attr:`autocommit` is ``False``, any "
"pending transaction is implicitly rolled back. If :attr:`!autocommit` is "
"``True`` or :data:`LEGACY_TRANSACTION_CONTROL`, no implicit transaction "
"control is executed. Make sure to :meth:`commit` before closing to avoid "
"losing pending changes."
msgstr ""
"Stänger databasanslutningen. Om :attr:`autocommit` är ``False``, kommer alla "
"väntande transaktioner att implicit rullas tillbaka. Om :attr:`!autocommit` "
"är ``True`` eller :data:`LEGACY_TRANSACTION_CONTROL`, utförs ingen implicit "
"transaktionskontroll. Var noga med att :meth:`commit` innan du stänger för "
"att undvika att förlora väntande ändringar."

msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Skapa ett nytt :class:`Cursor`-objekt och anropa :meth:`~Cursor.execute` på "
"det med de angivna *sql* och *parametrarna*. Returnera det nya cursor-"
"objektet."

msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Skapa ett nytt :class:`Cursor`-objekt och anropa :meth:`~Cursor.executemany` "
"på det med de angivna *sql* och *parametrarna*. Returnera det nya cursor-"
"objektet."

msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"Skapa ett nytt :class:`Cursor`-objekt och anropa :meth:`~Cursor."
"executescript` på det med det angivna *sql_script*. Returnera det nya cursor-"
"objektet."

msgid "Create or remove a user-defined SQL function."
msgstr "Skapa eller ta bort en användardefinierad SQL-funktion."

msgid "The name of the SQL function."
msgstr "Namnet på SQL-funktionen."

msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""
"Antalet argument som SQL-funktionen kan acceptera. Om ``-1``, kan den ta "
"emot valfritt antal argument."

msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite <sqlite3-"
"types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""
"En :term:`callable` som anropas när SQL-funktionen anropas. Den anropbara "
"funktionen måste returnera :ref:``en typ som stöds av SQLite <sqlite3-"
"types>`. Ställ in till ``None`` för att ta bort en befintlig SQL-funktion."

msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"Om ``True``, markeras den skapade SQL-funktionen som `deterministisk "
"<https://sqlite.org/deterministic.html>`_, vilket gör att SQLite kan utföra "
"ytterligare optimeringar."

msgid "Added the *deterministic* parameter."
msgstr "Parametern *deterministic* har lagts till."

msgid "Example:"
msgstr "Exempel:"

msgid ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"
msgstr ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"

msgid ""
"Passing *name*, *narg*, and *func* as keyword arguments is deprecated. These "
"parameters will become positional-only in Python 3.15."
msgstr ""
"Att skicka *name*, *narg* och *func* som nyckelordsargument är föråldrat. "
"Dessa parametrar blir endast positionella i Python 3.15."

msgid "Create or remove a user-defined SQL aggregate function."
msgstr "Skapa eller ta bort en användardefinierad SQL-aggregatfunktion."

msgid "The name of the SQL aggregate function."
msgstr "Namnet på SQL-aggregatfunktionen."

msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""
"Det antal argument som SQL-aggregatfunktionen kan acceptera. Om ``-1``, kan "
"den ta emot valfritt antal argument."

msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"En klass måste implementera följande metoder:  * ``step()``: Lägger till en "
"rad i aggregatet. * ``finalize()``: Returnerar aggregatets slutresultat som :"
"ref:``en typ som stöds av SQLite <sqlite3-types>``.  Antalet argument som "
"metoden ``step()`` måste acceptera styrs av *n_arg*.  Ställ in till ``None`` "
"för att ta bort en befintlig SQL-aggregatfunktion."

msgid "A class must implement the following methods:"
msgstr "En klass måste implementera följande metoder:"

msgid "``step()``: Add a row to the aggregate."
msgstr "``step()``: Lägg till en rad i aggregatet."

msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""
"``finalize()``: Returnerar det slutliga resultatet av sammanställningen som :"
"ref:``en typ som stöds av SQLite <sqlite3-types>`."

msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""
"Antalet argument som metoden ``step()`` måste acceptera styrs av *n_arg*."

msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "Sätt till ``None`` för att ta bort en befintlig SQL-aggregatfunktion."

msgid ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"
msgstr ""
"klass MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, värde):\n"
"        self.count += värde\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":minne:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"VÄLJ mysum(i) FRÅN test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"

msgid ""
"Passing *name*, *n_arg*, and *aggregate_class* as keyword arguments is "
"deprecated. These parameters will become positional-only in Python 3.15."
msgstr ""
"Att skicka *name*, *n_arg* och *aggregate_class* som nyckelordsargument är "
"föråldrat. Dessa parametrar blir endast positionella i Python 3.15."

msgid "Create or remove a user-defined aggregate window function."
msgstr "Skapa eller ta bort en användardefinierad aggregatfönsterfunktion."

msgid "The name of the SQL aggregate window function to create or remove."
msgstr ""
"Namnet på den SQL-aggregatfönsterfunktion som ska skapas eller tas bort."

msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""
"Antalet argument som funktionen SQL aggregate window kan acceptera. Om "
"``-1``, kan den ta emot valfritt antal argument."

msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""
"En klass som måste implementera följande metoder:  * ``step()``: Lägg till "
"en rad i det aktuella fönstret. * ``value()``: Returnerar det aktuella "
"värdet för aggregatet. * ``inverse()``: Tar bort en rad från det aktuella "
"fönstret. * ``finalize()``: Returnerar slutresultatet av aggregatet som :ref:"
"``en typ som stöds av SQLite <sqlite3-types>`.  Antalet argument som "
"metoderna ``step()`` och ``value()`` måste acceptera styrs av *num_params*.  "
"Sätts till ``None`` för att ta bort en befintlig SQL aggregate window-"
"funktion."

msgid "A class that must implement the following methods:"
msgstr "En klass som måste implementera följande metoder:"

msgid "``step()``: Add a row to the current window."
msgstr "``step()``: Lägg till en rad i det aktuella fönstret."

msgid "``value()``: Return the current value of the aggregate."
msgstr "``värde()``: Returnerar det aktuella värdet för aggregatet."

msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: Ta bort en rad från det aktuella fönstret."

msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""
"Antalet argument som metoderna ``step()`` och ``value()`` måste acceptera "
"styrs av *num_params*."

msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr ""
"Sätt till ``None`` för att ta bort en befintlig SQL aggregatfönsterfunktion."

msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr ""
"Om den används med en version av SQLite som är äldre än 3.25.0, som inte har "
"stöd för aggregate window-funktioner."

msgid ""
"# Example taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Add a row to the current window.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Return the current value of the aggregate.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove a row from the current window.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Return the final value of the aggregate.\n"
"\n"
"        Any clean-up actions should be placed here.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"# Exempel hämtat från https://www.sqlite.org/windowfunctions."
"html#udfwinfunc\n"
"klass WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, värde):\n"
"        \"\"\"Lägg till en rad i det aktuella fönstret.\"\"\"\n"
"        self.count += värde\n"
"\n"
"    def value(self):\n"
"        \"\"\"Returnera det aktuella värdet för aggregatet.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, värde):\n"
"        \"\"\"Ta bort en rad från det aktuella fönstret.\"\"\"\n"
"        self.count -= värde\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Returnera det slutliga värdet för aggregatet.\n"
"\n"
"        Eventuella rensningsåtgärder bör placeras här.\n"
"        \"\"\"\n"
"        returnera self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":minne:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"värden = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", värden)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x RADAR MELLAN 1 FÖREGÅENDE OCH 1 EFTERFÖLJANDE\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"

msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"Skapa en kollationering med namnet *namn* med hjälp av kollationsfunktionen "
"*callable*. *callable* får två :class:`sträng <str>`-argument, och den ska "
"returnera en :class:`integer <int>`:"

msgid "``1`` if the first is ordered higher than the second"
msgstr "``1`` om den första är högre beställd än den andra"

msgid "``-1`` if the first is ordered lower than the second"
msgstr "``-1`` om den första är lägre ordnad än den andra"

msgid "``0`` if they are ordered equal"
msgstr "``0`` om de är ordnade lika"

msgid "The following example shows a reverse sorting collation:"
msgstr "Följande exempel visar en omvänd sorteringskollation:"

msgid ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"
msgstr ""
"def collate_reverse(sträng1, sträng2):\n"
"    om sträng1 == sträng2:\n"
"        returnera 0\n"
"    elif sträng1 < sträng2:\n"
"        returnera 1\n"
"    annat:\n"
"        returnera -1\n"
"\n"
"con = sqlite3.connect(\":minne:\")\n"
"con.create_collation(\"reverse\", kollationering_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"för rad i cur:\n"
"    print(rad)\n"
"con.close()"

msgid "Remove a collation function by setting *callable* to ``None``."
msgstr ""
"Ta bort en sorteringsfunktion genom att sätta *callable* till ``None``."

msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr ""
"Sorteringsnamnet kan innehålla vilket Unicode-tecken som helst.  Tidigare "
"var endast ASCII-tecken tillåtna."

msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""
"Anropa den här metoden från en annan tråd för att avbryta eventuella frågor "
"som körs på anslutningen. Avbrutna förfrågningar kommer att ge upphov till "
"ett :exc:`OperationalError`."

msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:"
"`SQLITE_IGNORE` to signal how access to the column should be handled by the "
"underlying SQLite library."
msgstr ""
"Registrera :term:`callable` *authorizer_callback* som ska anropas för varje "
"försök att komma åt en kolumn i en tabell i databasen. Återkallelsen bör "
"returnera en av :const:`SQLITE_OK`, :const:`SQLITE_DENY`, eller :const:"
"`SQLITE_IGNORE` för att signalera hur åtkomst till kolumnen ska hanteras av "
"det underliggande SQLite-biblioteket."

msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""
"Det första argumentet till callbacken anger vilken typ av operation som ska "
"auktoriseras. Det andra och tredje argumentet kommer att vara argument eller "
"``None`` beroende på det första argumentet. Det fjärde argumentet är namnet "
"på databasen (\"main\", \"temp\", etc.) om tillämpligt. Det femte argumentet "
"är namnet på den innersta trigger eller vy som är ansvarig för "
"åtkomstförsöket eller ``None`` om åtkomstförsöket kommer direkt från SQL-kod."

msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"Se SQLite-dokumentationen för information om möjliga värden för det första "
"argumentet och betydelsen av det andra och tredje argumentet beroende på det "
"första. Alla nödvändiga konstanter finns tillgängliga i modulen :mod:`!"
"sqlite3`."

msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr "Om du anger ``None`` som *authorizer_callback* inaktiveras authorizer."

msgid "Added support for disabling the authorizer using ``None``."
msgstr "Lagt till stöd för att inaktivera authorizer med hjälp av ``None``."

msgid ""
"Passing *authorizer_callback* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""
"Att skicka *authorizer_callback* som ett nyckelordsargument är föråldrat. "
"Parametern blir endast positionell i Python 3.15."

msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"Registrera :term:`callable` *progress_handler* som ska anropas för varje *n* "
"instruktioner i den virtuella SQLite-maskinen. Detta är användbart om du "
"vill bli anropad från SQLite under långvariga operationer, t.ex. för att "
"uppdatera ett GUI."

msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""
"Om du vill ta bort alla tidigare installerade progress-handläggare anropar "
"du metoden med ``None`` för *progress_handler*."

msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise a :exc:`DatabaseError` "
"exception."
msgstr ""
"Om ett värde som inte är noll returneras från hanterarfunktionen kommer den "
"aktuella frågan att avslutas och ett :exc:`DatabaseError`-undantag att "
"skapas."

msgid ""
"Passing *progress_handler* as a keyword argument is deprecated. The "
"parameter will become positional-only in Python 3.15."
msgstr ""
"Att skicka *progress_handler* som ett nyckelordsargument är föråldrat. "
"Parametern blir endast positionell i Python 3.15."

msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr ""
"Registrera :term:`callable` *trace_callback* som ska anropas för varje SQL-"
"sats som faktiskt körs av SQLite-backend."

msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"Det enda argument som skickas till callbacken är det uttalande (som :class:"
"`str`) som körs. Returvärdet för återuppringningen ignoreras. Observera att "
"backend inte bara kör satser som skickas till :meth:`Cursor.execute`-"
"metoderna.  Andra källor inkluderar :ref:`transaction management <sqlite3-"
"controlling-transactions>` i :mod:`!sqlite3`-modulen och exekveringen av "
"triggers som definieras i den aktuella databasen."

msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""
"Om du anger ``None`` som *trace_callback* inaktiveras spårningsuppringningen."

msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"Undantag som uppstår i trace callback sprids inte. Som ett hjälpmedel för "
"utveckling och felsökning kan du använda :meth:`~sqlite3."
"enable_callback_tracebacks` för att aktivera utskrift av spårningar från "
"undantag som tas upp i trace callback."

msgid ""
"Passing *trace_callback* as a keyword argument is deprecated. The parameter "
"will become positional-only in Python 3.15."
msgstr ""
"Att skicka *trace_callback* som ett nyckelordsargument är föråldrat. "
"Parametern blir endast positionell i Python 3.15."

msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"Aktivera SQLite-motorn att ladda SQLite-tillägg från delade bibliotek om "
"*enabled* är ``True``; annars, avaktivera laddning av SQLite-tillägg. SQLite-"
"tillägg kan definiera nya funktioner, aggregat eller helt nya "
"implementeringar av virtuella tabeller.  Ett välkänt tillägg är fulltext-"
"söktillägget som distribueras med SQLite."

msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
"Modulen :mod:`!sqlite3` är inte byggd med stöd för laddningsbara tillägg som "
"standard, eftersom vissa plattformar (särskilt macOS) har SQLite-bibliotek "
"som är kompilerade utan denna funktion. För att få stöd för laddningsbara "
"tillägg måste du skicka alternativet :option:`--enable-loadable-sqlite-"
"extensions` till :program:`configure`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3."
"enable_load_extension`` med argumenten ``connection``, ``enabled``."

msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "Lagt till granskningshändelsen ``sqlite3.enable_load_extension``."

msgid ""
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension loading again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli "
"peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin "
"onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli "
"cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin "
"sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE "
"name MATCH 'pie'\"):\n"
"    print(row)"
msgstr ""
"con.enable_load_extension(True)\n"
"\n"
"# Ladda tillägget för fulltextsökning\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternativt kan du ladda tillägget med hjälp av ett API-anrop:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# inaktivera laddning av tillägg igen\n"
"con.enable_load_extension(False)\n"
"\n"
"# exempel från SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(namn, ingredienser)\")\n"
"con.executescript(\"\"\"\"\n"
"    INSERT INTO recipe (namn, ingredienser) VALUES('broccoligryta', "
"'broccoli paprika ost tomater');\n"
"    INSERT INTO recept (namn, ingredienser) VALUES('pumpagryta', 'pumpa lök "
"vitlök selleri');\n"
"    INSERT INTO recept (namn, ingredienser) VALUES('broccolipaj', 'broccoli "
"ost lök mjöl');\n"
"    INSERT INTO recept (namn, ingredienser) VALUES('pumpapaj', 'pumpa socker "
"mjöl smör');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE "
"name MATCH 'pie'\"):\n"
"    print(rad)"

msgid ""
"Load an SQLite extension from a shared library. Enable extension loading "
"with :meth:`enable_load_extension` before calling this method."
msgstr ""
"Laddar ett SQLite-tillägg från ett delat bibliotek. Aktivera laddning av "
"tillägg med :meth:`enable_load_extension` innan du anropar den här metoden."

msgid "The path to the SQLite extension."
msgstr "Sökvägen till SQLite-tillägget."

msgid ""
"Entry point name. If ``None`` (the default), SQLite will come up with an "
"entry point name of its own; see the SQLite docs `Loading an Extension`_ for "
"details."
msgstr ""
"Namn på ingångspunkten. Om ``None`` (standard) kommer SQLite att hitta på "
"ett eget namn på ingångspunkten; se SQLite-dokumenten `Loading an "
"Extension`_ för mer information."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"Utlöser en :ref:`auditing event <auditing>` ``sqlite3.load_extension`` med "
"argumenten ``connection``, ``path``."

msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "Lagt till granskningshändelsen ``sqlite3.load_extension``."

msgid "Added the *entrypoint* parameter."
msgstr "Parametern *entrypoint* har lagts till."

msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"Returnerar en :term:`iterator` för att dumpa databasen som SQL-källkod. "
"Användbart när du sparar en databas i minnet för senare återställning. "
"Liknar kommandot ``.dump`` i skalet :program:`sqlite3`."

msgid ""
"An optional ``LIKE`` pattern for database objects to dump, e.g. "
"``prefix_%``. If ``None`` (the default), all database objects will be "
"included."
msgstr ""
"Ett valfritt ``LIKE``-mönster för databasobjekt som ska dumpas, t.ex. "
"``prefix_%``. Om ``None`` (standard) kommer alla databasobjekt att "
"inkluderas."

msgid ""
"# Convert file example.db to SQL dump file dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"
msgstr ""
"# Konvertera filen example.db till SQL-dumpfilen dump.sql\n"
"con = sqlite3.connect('exempel.db')\n"
"med open('dump.sql', 'w') som f:\n"
"    för rad i con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"

msgid ":ref:`sqlite3-howto-encoding`"
msgstr ":ref:`sqlite3-hur-man-kodar`"

msgid "Added the *filter* parameter."
msgstr "Parametern *filter* har lagts till."

msgid "Create a backup of an SQLite database."
msgstr "Skapa en säkerhetskopia av en SQLite-databas."

msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""
"Fungerar även om databasen nås av andra klienter eller samtidigt med samma "
"anslutning."

msgid "The database connection to save the backup to."
msgstr "Den databasanslutning som säkerhetskopian ska sparas i."

msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""
"Antalet sidor som ska kopieras åt gången. Om det är lika med eller mindre än "
"``0`` kopieras hela databasen i ett enda steg. Standardvärdet är ``-1``."

msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for "
"every backup iteration: the *status* of the last iteration, the *remaining* "
"number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""
"Om den är inställd på en :term:`callable`, anropas den med tre "
"heltalsargument för varje backup-iteration: *status* för den senaste "
"iterationen, det *återstående* antalet sidor som fortfarande ska kopieras "
"och det *totala* antalet sidor. Standardvärdet är ``None``."

msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"Namnet på den databas som ska säkerhetskopieras. Antingen ``\"main\"`` "
"(standard) för huvuddatabasen, ``\"temp\"`` för den tillfälliga databasen "
"eller namnet på en anpassad databas som bifogats med SQL-satsen ``ATTACH "
"DATABASE``."

msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""
"Antalet sekunder som ska gå mellan två på varandra följande försök att "
"säkerhetskopiera återstående sidor."

msgid "Example 1, copy an existing database into another:"
msgstr "Exempel 1, kopiera en befintlig databas till en annan:"

msgid ""
"def progress(status, remaining, total):\n"
"    print(f'Copied {total-remaining} of {total} pages...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"def progress(status, återstående, totalt):\n"
"    print(f'Kopierade {total-remaining} av {total} sidor...')\n"
"\n"
"src = sqlite3.connect('exempel.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"med dst:\n"
"    src.backup(dst, sidor=1, framsteg=framsteg)\n"
"dst.close()\n"
"src.close()"

msgid "Example 2, copy an existing database into a transient copy:"
msgstr "Exempel 2, kopiera en befintlig databas till en tillfällig kopia:"

msgid ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"src = sqlite3.connect('exempel.db')\n"
"dst = sqlite3.connect(':minne:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"

msgid "Get a connection runtime limit."
msgstr "Få en gräns för anslutningens körtid."

msgid "The `SQLite limit category`_ to be queried."
msgstr "Den `SQLite-gränskategori`_ som ska frågas."

msgid "If *category* is not recognised by the underlying SQLite library."
msgstr "Om *category* inte känns igen av det underliggande SQLite-biblioteket."

msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr ""
"Exempel, fråga om den maximala längden på en SQL-sats för :class:"
"`Connection`` ``con`` (standardvärdet är 1000000000):"

msgid ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"
msgstr ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"

msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr ""
"Ställ in en gräns för anslutningens körtid. Försök att öka en gräns över "
"dess hårda övre gräns avkortas tyst till den hårda övre gränsen. Oavsett om "
"gränsen har ändrats eller inte, returneras det tidigare värdet för gränsen."

msgid "The `SQLite limit category`_ to be set."
msgstr "Den `SQLite-gränskategori`_ som ska ställas in."

msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr ""
"Värdet på den nya gränsen. Om värdet är negativt är den aktuella gränsen "
"oförändrad."

msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr ""
"Exempel: begränsa antalet anslutna databaser till 1 för :class:`Connection` "
"``con`` (standardgränsen är 10):"

msgid ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"
msgstr ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"

msgid "Query a boolean connection configuration option."
msgstr "Fråga efter ett booleskt alternativ för konfiguration av anslutningen."

msgid "A :ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>`."
msgstr "En :ref:`SQLITE_DBCONFIG-kod <sqlite3-dbconfig-constants>`."

msgid "Set a boolean connection configuration option."
msgstr "Ange ett booleskt alternativ för konfiguration av anslutningen."

msgid ""
"``True`` if the configuration option should be enabled (default); ``False`` "
"if it should be disabled."
msgstr ""
"``True`` om konfigurationsalternativet ska vara aktiverat (standard); "
"``False`` om det ska vara inaktiverat."

msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"Serialisera en databas till ett :class:`bytes`-objekt.  För en vanlig "
"databasfil på disken är serialiseringen bara en kopia av diskfilen.  För en "
"databas i minnet eller en \"temp\"-databas är serialiseringen samma sekvens "
"av bytes som skulle skrivas till disken om databasen säkerhetskopierades "
"till disk."

msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr ""
"Namnet på den databas som ska serialiseras. Standardvärdet är ``\"main\"``."

msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""
"Denna metod är endast tillgänglig om det underliggande SQLite-biblioteket "
"har API:et serialize."

msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""
"Deserialiserar en :meth:`serialized <serialize>` databas till en :class:"
"`Connection`. Den här metoden gör att databasanslutningen kopplar från "
"databasen *namn* och öppnar *namn* igen som en databas i minnet baserat på "
"serialiseringen i *data*."

msgid "A serialized database."
msgstr "En serialiserad databas."

msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr ""
"Databasnamnet som deserialiseringen ska göras till. Standardvärdet är "
"``\"main\"``."

msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr ""
"Om databasanslutningen för närvarande är involverad i en lästransaktion "
"eller en säkerhetskopiering."

msgid "If *data* does not contain a valid SQLite database."
msgstr "Om *data* inte innehåller en giltig SQLite-databas."

msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr "Om :func:`len(data) <len>` är större än ``2**63 - 1``."

msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""
"Denna metod är endast tillgänglig om det underliggande SQLite-biblioteket "
"har API:et deserialize."

msgid ""
"This attribute controls :pep:`249`-compliant transaction behaviour. :attr:`!"
"autocommit` has three allowed values:"
msgstr ""
"Detta attribut styr transaktionsbeteendet i enlighet med :pep:`249`. :attr:`!"
"autocommit` har tre tillåtna värden:"

msgid ""
"``False``: Select :pep:`249`-compliant transaction behaviour, implying that :"
"mod:`!sqlite3` ensures a transaction is always open. Use :meth:`commit` and :"
"meth:`rollback` to close transactions."
msgstr ""
"``False``: Välj :pep:`249`-kompatibelt transaktionsbeteende, vilket innebär "
"att :mod:`!sqlite3` säkerställer att en transaktion alltid är öppen. Använd :"
"meth:`commit` och :meth:`rollback` för att stänga transaktioner."

msgid "This is the recommended value of :attr:`!autocommit`."
msgstr "Detta är det rekommenderade värdet för :attr:`!autocommit`."

msgid ""
"``True``: Use SQLite's `autocommit mode`_. :meth:`commit` and :meth:"
"`rollback` have no effect in this mode."
msgstr ""
"``True``: Använd SQLites `autocommit-läge`_. :meth:`commit` och :meth:"
"`rollback` har ingen effekt i detta läge."

msgid ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 (non-:pep:`249`-"
"compliant) transaction control. See :attr:`isolation_level` for more details."
msgstr ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 (ej:pep:`249`-"
"kompatibel) transaktionskontroll. Se :attr:`isolation_level` för mer "
"information."

msgid "This is currently the default value of :attr:`!autocommit`."
msgstr "Detta är för närvarande standardvärdet för :attr:`!autocommit`."

msgid ""
"Changing :attr:`!autocommit` to ``False`` will open a new transaction, and "
"changing it to ``True`` will commit any pending transaction."
msgstr ""
"Om du ändrar :attr:`!autocommit` till ``False`` öppnas en ny transaktion, "
"och om du ändrar den till ``True`` bekräftas alla pågående transaktioner."

msgid "See :ref:`sqlite3-transaction-control-autocommit` for more details."
msgstr "Se :ref:`sqlite3-transaction-control-autocommit` för mer information."

msgid ""
"The :attr:`isolation_level` attribute has no effect unless :attr:"
"`autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`."
msgstr ""
"Attributet :attr:`isolation_level` har ingen effekt om inte :attr:"
"`autocommit` är :data:`LEGACY_TRANSACTION_CONTROL`."

msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""
"Detta skrivskyddade attribut motsvarar SQLites `autocommit mode`_ på låg "
"nivå."

msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"``True`` om en transaktion är aktiv (det finns ändringar som inte är "
"bekräftade), ``False`` annars."

msgid ""
"Controls the :ref:`legacy transaction handling mode <sqlite3-transaction-"
"control-isolation-level>` of :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, :ref:`implicit transaction management "
"<sqlite3-transaction-control-isolation-level>` is performed."
msgstr ""
"Styr :ref:``legacy transaktionshanteringsläge <sqlite3-transaction-control-"
"isolation-level>`` för :mod:`!sqlite3`. Om inställningen är ``None`` öppnas "
"aldrig transaktioner implicit. Om den är satt till en av ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, eller ``\"EXCLUSIVE\"``, som motsvarar det underliggande "
"`SQLite transaktionsbeteendet`_, utförs :ref:``implicit "
"transaktionshantering <sqlite3-transaction-control-isolation-level>`."

msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"Om den inte åsidosätts av parametern *isolation_level* i :func:`connect`, är "
"standardvärdet ``\"\"``, som är ett alias för ``\"DEFERRED\"``."

msgid ""
"Using :attr:`autocommit` to control transaction handling is recommended over "
"using :attr:`!isolation_level`. :attr:`!isolation_level` has no effect "
"unless :attr:`autocommit` is set to :data:`LEGACY_TRANSACTION_CONTROL` (the "
"default)."
msgstr ""
"Att använda :attr:`autocommit` för att styra transaktionshantering "
"rekommenderas framför att använda :attr:`!isolation_level`. :attr:`!"
"isolation_level` har ingen effekt om inte :attr:`autocommit` är inställd på :"
"data:`LEGACY_TRANSACTION_CONTROL` (standard)."

msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"Det ursprungliga :attr:`~Cursor.row_factory` för :class:`Cursor`-objekt som "
"skapas från den här anslutningen. Tilldelning av detta attribut påverkar "
"inte :attr:`!row_factory` för befintliga markörer som tillhör denna "
"anslutning, endast nya. Är ``None`` som standard, vilket innebär att varje "
"rad returneras som en :class:`tuple`."

msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "Se :ref:`sqlite3-howto-row-factory` för mer information."

msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""
"En :term:`callable` som accepterar en :class:`bytes` parameter och "
"returnerar en textrepresentation av den. Den anropsbara funktionen anropas "
"för SQLite-värden med datatypen ``TEXT``. Som standard är detta attribut "
"inställt på :class:`str`."

msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr "Se :ref:`sqlite3-howto-encoding` för mer information."

msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"Returnerar det totala antalet databasrader som har ändrats, infogats eller "
"tagits bort sedan databasanslutningen öppnades."

msgid "Cursor objects"
msgstr "Cursor-objekt"

msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"Ett ``Cursor``-objekt representerar en ``databascursor`` som används för att "
"exekvera SQL-satser och hantera kontexten för en hämtningsoperation. Cursors "
"skapas med :meth:`Connection.cursor`, eller genom att använda någon av :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."

msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"Markörobjekt är :term:`iteratorer <iterator>`, vilket innebär att om du :"
"meth:`~Cursor.execute` en ``SELECT``-fråga kan du helt enkelt iterera över "
"markören för att hämta de resulterande raderna:"

msgid ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"
msgstr ""
"för rad i cur.execute(\"SELECT t FROM data\"):\n"
"    print(rad)"

msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr "En :class:`Cursor`-instans har följande attribut och metoder."

msgid ""
"Execute a single SQL statement, optionally binding Python values using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""
"Exekvera en enda SQL-sats och bind eventuellt Python-värden med hjälp av :"
"ref:`placeholders <sqlite3-placeholders>`."

msgid "A single SQL statement."
msgstr "En enda SQL-sats."

msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"Python-värden att binda till platshållare i *sql*. En :class:`!dict` om "
"namngivna platshållare används. En :term:`!sequence` om icke namngivna "
"platshållare används. Se :ref:`sqlite3-platshållare`."

msgid ""
"When *sql* contains more than one SQL statement. When :ref:`named "
"placeholders <sqlite3-placeholders>` are used and *parameters* is a sequence "
"instead of a :class:`dict`."
msgstr ""
"När *sql* innehåller mer än en SQL-sats. När :ref:`named placeholders "
"<sqlite3-placeholders>`` används och *parameters* är en sekvens istället för "
"en :class:`dict`."

msgid ""
"If :attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`, :"
"attr:`~Connection.isolation_level` is not ``None``, *sql* is an ``INSERT``, "
"``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is no open "
"transaction, a transaction is implicitly opened before executing *sql*."
msgstr ""
"Om :attr:`~Connection.autocommit` är :data:`LEGACY_TRANSACTION_CONTROL`, :"
"attr:`~Connection.isolation_level` inte är ``None``, *sql* är en ``INSERT``, "
"``UPDATE``, ``DELETE`` eller ``REPLACE``-sats och det inte finns någon öppen "
"transaktion, öppnas en transaktion implicit innan *sql* körs."

msgid ""
":exc:`ProgrammingError` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and *parameters* is a sequence instead of a :class:"
"`dict`."
msgstr ""
":exc:`ProgrammingError` sänds ut om :ref:``named placeholders <sqlite3-"
"placeholders>`` används och *parameters* är en sekvens istället för en :"
"class:`dict`."

msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "Använd :meth:`executescript` för att köra flera SQL-satser."

msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""
"För varje objekt i *parameters*, kör upprepade gånger :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL-satsen "
"*sql*."

msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""
"Använder samma implicita transaktionshantering som :meth:`~Cursor.execute`."

msgid "A single SQL DML statement."
msgstr "En enda SQL DML-sats."

msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"En :term:`!iterabel` av parametrar att binda med platshållarna i *sql*. Se :"
"ref:`sqlite3-platshållare`."

msgid ""
"When *sql* contains more than one SQL statement or is not a DML statement, "
"When :ref:`named placeholders <sqlite3-placeholders>` are used and the items "
"in *parameters* are sequences instead of :class:`dict`\\s."
msgstr ""
"När *sql* innehåller mer än en SQL-sats eller inte är en DML-sats, När :ref:"
"`named placeholders <sqlite3-placeholders>` används och objekten i "
"*parameters* är sekvenser istället för :class:`dict`."

msgid ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur is an sqlite3.Cursor object\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"
msgstr ""
"rader = [\n"
"    (\"rad1\",),\n"
"    (\"rad2\",),\n"
"]\n"
"# cur är ett sqlite3.cursor-objekt\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rader)"

msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr ""
"Alla resulterande rader kasseras, inklusive DML-satser med `RETURNING-"
"klausuler`_."

msgid ""
":exc:`ProgrammingError` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and the items in *parameters* are sequences instead "
"of :class:`dict`\\s."
msgstr ""
":exc:`ProgrammingError` sänds ut om :ref:``namngivna platshållare <sqlite3-"
"placeholders>`` används och objekten i *parameters* är sekvenser istället "
"för :class:`dict`\\s."

msgid ""
"Execute the SQL statements in *sql_script*. If the :attr:`~Connection."
"autocommit` is :data:`LEGACY_TRANSACTION_CONTROL` and there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""
"Exekvera SQL-satserna i *sql_script*. Om :attr:`~Connection.autocommit` är :"
"data:`LEGACY_TRANSACTION_CONTROL` och det finns en väntande transaktion, "
"körs en implicit ``COMMIT``-sats först. Ingen annan implicit "
"transaktionskontroll utförs; eventuell transaktionskontroll måste läggas "
"till i *sql_script*."

msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* måste vara en :class:`sträng <str>`."

msgid ""
"# cur is an sqlite3.Cursor object\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"
msgstr ""
"# cur är ett sqlite3.cursor-objekt\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(förnamn, efternamn, ålder);\n"
"    CREATE TABLE book(titel, författare, publicerad);\n"
"    CREATE TABLE publisher(namn, adress);\n"
"    COMMIT;\n"
"\"\"\")"

msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"Om :attr:`~Cursor.row_factory` är ``None``, returneras nästa "
"resultatuppsättning för radfrågor som en :class:`tuple`. Annars skickas den "
"till radfabriken och dess resultat returneras. Returnera ``None`` om inga "
"fler data finns tillgängliga."

msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""
"Returnerar nästa uppsättning rader i ett frågeresultat som en :class:`list`. "
"Returnerar en tom lista om inga fler rader är tillgängliga."

msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"Antalet rader som ska hämtas per anrop specificeras av parametern *size*. Om "
"*size* inte anges bestämmer :attr:`arraysize` antalet rader som ska hämtas. "
"Om färre än *size* rader är tillgängliga returneras så många rader som är "
"tillgängliga."

msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"Observera att parametern *size* är förknippad med prestandafrågor. För "
"optimal prestanda är det oftast bäst att använda arraysize-attributet. Om "
"parametern *size* används är det bäst att den behåller samma värde från ett :"
"meth:`fetchmany`-anrop till nästa."

msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"Returnerar alla (återstående) rader i ett sökresultat som en :class:`list`. "
"Returnerar en tom lista om inga rader är tillgängliga. Observera att "
"attributet :attr:`arraysize` kan påverka prestandan för denna operation."

msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "Stäng markören nu (i stället för när ``__del__`` anropas)."

msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"Markören kommer att vara oanvändbar från och med nu; ett :exc:"
"`ProgrammingError` undantag kommer att uppstå om någon operation försöker "
"utföras med markören."

msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "Krävs av DB-API. Gör ingenting i :mod:`!sqlite3`."

msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"Läs-/skrivattribut som styr antalet rader som returneras av :meth:"
"`fetchmany`. Standardvärdet är 1, vilket innebär att en enda rad hämtas per "
"anrop."

msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"Skrivskyddat attribut som anger SQLite-databasen :class:`Connection` som hör "
"till markören.  Ett :class:`Cursor`-objekt som skapas genom anrop av :meth:"
"`con.cursor() <Connection.cursor>` kommer att ha ett :attr:`connection`-"
"attribut som hänvisar till *con*:"

msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":minne:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"Sant\n"
">>> con.close()"

msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"Skrivskyddat attribut som tillhandahåller kolumnnamnen för den senaste "
"frågan. För att vara kompatibel med Python DB API returneras en 7-tupel för "
"varje kolumn där de sex sista posterna i varje tupel är ``None``."

msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"Den är också inställd för ``SELECT``-satser utan några matchande rader."

msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"Skrivskyddat attribut som anger rad-id för den senast infogade raden. Det "
"uppdateras endast efter lyckade ``INSERT`` eller ``REPLACE``-satser som "
"använder metoden :meth:`execute`.  För andra satser, efter :meth:"
"`executemany` eller :meth:`executescript`, eller om infogningen "
"misslyckades, lämnas värdet på ``lastrowid`` oförändrat.  Det initiala "
"värdet för ``lastrowid`` är ``None``."

msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "Insättningar i tabellerna ``WITHOUT ROWID`` registreras inte."

msgid "Added support for the ``REPLACE`` statement."
msgstr "Lagt till stöd för ``REPLACE``-satsen."

msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""
"Skrivskyddat attribut som anger antalet ändrade rader för ``INSERT``, "
"``UPDATE``, ``DELETE`` och ``REPLACE``-satser; är ``-1`` för andra satser, "
"inklusive :abbr:`CTE (Common Table Expression)`-frågor. Den uppdateras "
"endast av metoderna :meth:`execute` och :meth:`executemany` efter att satsen "
"har körts färdigt. Detta innebär att alla resulterande rader måste hämtas "
"för att :attr:`!rowcount` ska kunna uppdateras."

msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"Styr hur en rad som hämtas från denna :class:`!Cursor` representeras. Om "
"``None`` representeras en rad som en :class:`tuple`. Kan sättas till den "
"inkluderade :class:`sqlite3.Row`; eller en :term:`callable` som accepterar "
"två argument, ett :class:`Cursor`-objekt och :class:`!tuple` av radvärden, "
"och returnerar ett anpassat objekt som representerar en SQLite-rad."

msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""
"Standardvärdet är det värde som :attr:`Connection.row_factory` angavs till "
"när :class:`!Cursor` skapades. Tilldelning av detta attribut påverkar inte :"
"attr:`Connection.row_factory` för den överordnade anslutningen."

msgid "Row objects"
msgstr "Radobjekt"

msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""
"En :class:`!Row`-instans fungerar som en mycket optimerad :attr:`~Connection."
"row_factory` för :class:`Connection`-objekt. Den stöder iteration, "
"jämlikhetstestning, :func:`len` och :term:`mapping`-åtkomst via kolumnnamn "
"och index."

msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""
"Två :class:`!Row`-objekt jämförs lika om de har identiska kolumnnamn och "
"värden."

msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""
"Returnerar en :class:`lista` med kolumnnamn som :class:`strängar <str>`. "
"Omedelbart efter en fråga är det den första medlemmen i varje tupel i :attr:"
"`Cursor.description`."

msgid "Added support of slicing."
msgstr "Lagt till stöd för skivning."

msgid "Blob objects"
msgstr "Blob-objekt"

msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
"En instans av :class:`Blob` är ett :term:`filliknande objekt` som kan läsa "
"och skriva data i en SQLite :abbr:`BLOB (Binary Large OBject)`. Anropa :func:"
"`len(blob) <len>` för att få storleken (antal byte) på blobben. Använd index "
"och :term:`slices <slice>` för direktåtkomst till blob-data."

msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr ""
"Använd :class:`Blob` som en :term:`context manager` för att säkerställa att "
"blob-handtaget stängs efter användning."

msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Write to our blob, using two write operations:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # Modify the first and last bytes of our blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Read the contents of our blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # outputs \"b'Hello, world!'\"\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":minne:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Skriv till vår blob med hjälp av två skrivoperationer:\n"
"med con.blobopen(\"test\", \"blob_col\", 1) som blob:\n"
"    blob.write(b\"hej, \")\n"
"    blob.write(b\"värld.\")\n"
"    # Ändra den första och sista byten i vår blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Läs innehållet i vår blob\n"
"med con.blobopen(\"test\", \"blob_col\", 1) som blob:\n"
"    hälsning = blob.read()\n"
"\n"
"print(hälsning) # utdata \"b'Hello, world!'\"\n"
"con.close()"

msgid "Close the blob."
msgstr "Stäng blobben."

msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""
"Blobben kommer att vara oanvändbar från denna punkt och framåt.  Ett :class:"
"`~sqlite3.Error` (eller underklass) undantag kommer att utlösas om någon "
"ytterligare operation försöker utföras med blobben."

msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""
"Läser *längd* byte data från blobben vid aktuell offsetposition. Om slutet "
"av blobben nås, kommer data upp till :abbr:`EOF (End of File)` att "
"returneras.  Om *längd* inte specificeras eller är negativ, kommer :meth:"
"`~Blob.read` att läsa till slutet av blobben."

msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""
"Skriv *data* till blobben vid aktuell offset.  Denna funktion kan inte ändra "
"blobbens längd.  Skrivning bortom slutet av blobben kommer att ge upphov "
"till :exc:`ValueError`."

msgid "Return the current access position of the blob."
msgstr "Returnerar den aktuella accesspositionen för blobben."

msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""
"Ställ in blobbens aktuella accessposition till *offset*.  Argumentet "
"*origin* är som standard :const:`os.SEEK_SET` (absolut positionering av "
"blobben). Andra värden för *origin* är :const:`os.SEEK_CUR` (sökning "
"relativt den aktuella positionen) och :const:`os.SEEK_END` (sökning relativt "
"blobbens slut)."

msgid "PrepareProtocol objects"
msgstr "PrepareProtocol-objekt"

msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"PrepareProtocol-typens enda syfte är att fungera som ett :pep:`246`-"
"stilanpassningsprotokoll för objekt som kan :ref:``anpassa sig <sqlite3-"
"conform>` till :ref:``nativa SQLite-typer <sqlite3-types>`."

msgid "Exceptions"
msgstr "Undantag"

msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "Undantagshierarkin definieras av DB-API 2.0 (:pep:`249`)."

msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Detta undantag görs för närvarande inte av modulen :mod:`!sqlite3`, men kan "
"göras av program som använder :mod:`!sqlite3`, t.ex. om en "
"användardefinierad funktion trunkerar data vid inmatning. ``Warning`` är en "
"underklass till :exc:`Exception`."

msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Basklassen för de andra undantagen i den här modulen. Använd denna för att "
"fånga upp alla fel med en enda :keyword:`except`-sats. ``Error`` är en "
"underklass till :exc:`Exception`."

msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr ""
"Om undantaget uppstod inom SQLite-biblioteket läggs följande två attribut "
"till undantaget:"

msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr ""
"Den numeriska felkoden från `SQLite API <https://sqlite.org/rescode.html>`_"

msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr ""
"Det symboliska namnet på den numeriska felkoden från `SQLite API <https://"
"sqlite.org/rescode.html>`_"

msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"Undantag för missbruk av SQLite C API på låg nivå. Med andra ord, om detta "
"undantag tas upp, indikerar det förmodligen en bugg i modulen :mod:`!"
"sqlite3`. ``InterfaceError`` är en underklass till :exc:`Error`."

msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"Undantag för fel som är relaterade till databasen. Detta fungerar som "
"basundantag för flera typer av databasfel. Det kan bara skapas implicit "
"genom de specialiserade underklasserna. ``DatabaseError`` är en underklass "
"till :exc:`Error`."

msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag för fel som orsakas av problem med bearbetade data, t.ex. numeriska "
"värden utanför intervallet och för långa strängar. ``DataError`` är en "
"underklass till :exc:`DatabaseError`."

msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag för fel som är relaterade till databasens funktion och inte "
"nödvändigtvis under programmerarens kontroll. Till exempel, databassökvägen "
"hittades inte, eller en transaktion kunde inte behandlas. "
"``OperationalError`` är en underklass till :exc:`DatabaseError`."

msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag som uppstår när databasens relationsintegritet påverkas, t.ex. när "
"en kontroll av en främmande nyckel misslyckas.  Det är en underklass till :"
"exc:`DatabaseError`."

msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag som uppstår när SQLite stöter på ett internt fel. Om det uppstår "
"kan det tyda på att det finns ett problem med SQLite-biblioteket under "
"körning. ``InternalError`` är en underklass till :exc:`DatabaseError`."

msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""
"Undantag för programmeringsfel i :mod:`!sqlite3` API, t.ex. fel antal "
"bindningar till en fråga eller försök att använda en stängd :class:"
"`Connection`. ``ProgrammingError`` är en underklass till :exc:"
"`DatabaseError`."

msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"Undantag som uppstår om en metod eller databas-API inte stöds av det "
"underliggande SQLite-biblioteket. Till exempel kan *deterministic* sättas "
"till ``True`` i :meth:`~Connection.create_function`, om det underliggande "
"SQLite-biblioteket inte stöder deterministiska funktioner. "
"``NotSupportedError`` är en underklass till :exc:`DatabaseError`."

msgid "SQLite and Python types"
msgstr "SQLite- och Python-typer"

msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite har inbyggt stöd för följande typer: ``NULL``, ``INTEGER``, ``REAL``, "
"``TEXT``, ``BLOB``."

msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr "Följande Python-typer kan alltså skickas till SQLite utan problem:"

msgid "Python type"
msgstr "Python-typ"

msgid "SQLite type"
msgstr "SQLite-typ"

msgid "``None``"
msgstr "``Ingen``"

msgid "``NULL``"
msgstr "``NULL``"

msgid ":class:`int`"
msgstr ":class:`int`"

msgid "``INTEGER``"
msgstr "``INTEGER``"

msgid ":class:`float`"
msgstr ":class:`float`"

msgid "``REAL``"
msgstr "``REAL``"

msgid ":class:`str`"
msgstr ":class:`str`"

msgid "``TEXT``"
msgstr "``TEXT``"

msgid ":class:`bytes`"
msgstr ":class:`bytes`"

msgid "``BLOB``"
msgstr "``BLOB``"

msgid "This is how SQLite types are converted to Python types by default:"
msgstr "Detta är hur SQLite-typer konverteras till Python-typer som standard:"

msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr "beror på :attr:`~Connection.text_factory`, :class:`str` som standard"

msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""
"Typsystemet i modulen :mod:`!sqlite3` är utbyggbart på två sätt: du kan "
"lagra ytterligare Python-typer i en SQLite-databas via :ref:``object "
"adapters <sqlite3-adapters>`, och du kan låta modulen :mod:`!sqlite3` "
"konvertera SQLite-typer till Python-typer via :ref:``converters <sqlite3-"
"converters>`."

msgid "Default adapters and converters (deprecated)"
msgstr "Standardadaptrar och -omvandlare (föråldrad)"

msgid ""
"The default adapters and converters are deprecated as of Python 3.12. "
"Instead, use the :ref:`sqlite3-adapter-converter-recipes` and tailor them to "
"your needs."
msgstr ""
"Standardadaptrarna och -omvandlarna är föråldrade från och med Python 3.12. "
"Använd istället :ref:`sqlite3-adapter-converter-recipes` och skräddarsy dem "
"efter dina behov."

msgid "The deprecated default adapters and converters consist of:"
msgstr "De föråldrade standardadaptrarna och -konverterarna består av:"

msgid ""
"An adapter for :class:`datetime.date` objects to :class:`strings <str>` in "
"`ISO 8601`_ format."
msgstr ""
"En adapter för :class:`datetime.date`-objekt till :class:`strings <str>` i "
"`ISO 8601`_-format."

msgid ""
"An adapter for :class:`datetime.datetime` objects to strings in ISO 8601 "
"format."
msgstr ""
"En adapter för :class:`datetime.datetime`-objekt till strängar i ISO 8601-"
"format."

msgid ""
"A converter for :ref:`declared <sqlite3-converters>` \"date\" types to :"
"class:`datetime.date` objects."
msgstr ""
"En omvandlare för :ref:`declared <sqlite3-converters>` \"date\"-typer till :"
"class:`datetime.date`-objekt."

msgid ""
"A converter for declared \"timestamp\" types to :class:`datetime.datetime` "
"objects. Fractional parts will be truncated to 6 digits (microsecond "
"precision)."
msgstr ""
"En omvandlare för deklarerade \"timestamp\"-typer till :class:`datetime."
"datetime`-objekt. Bråkdelar kommer att trunkeras till 6 siffror "
"(mikrosekundsprecision)."

msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"Standardomvandlaren \"timestamp\" ignorerar UTC-offset i databasen och "
"returnerar alltid ett naivt :class:`datetime.datetime`-objekt. Om du vill "
"bevara UTC-offset i tidsstämplar ska du antingen låta omvandlare vara "
"inaktiverade eller registrera en offsetmedveten omvandlare med :func:"
"`register_converter`."

msgid "Command-line interface"
msgstr "Kommandoradsgränssnitt"

msgid ""
"The :mod:`!sqlite3` module can be invoked as a script, using the "
"interpreter's :option:`-m` switch, in order to provide a simple SQLite "
"shell. The argument signature is as follows::"
msgstr ""
"Modulen :mod:`!sqlite3` kan anropas som ett skript, med hjälp av tolkens "
"switch :option:`-m`, för att tillhandahålla ett enkelt SQLite-skal. "
"Argumentsignaturen är som följer::"

msgid "python -m sqlite3 [-h] [-v] [filename] [sql]"
msgstr "python -m sqlite3 [-h] [-v] [filnamn] [sql]"

msgid "Type ``.quit`` or CTRL-D to exit the shell."
msgstr "Skriv ``.quit`` eller CTRL-D för att avsluta skalet."

msgid "Print CLI help."
msgstr "Skriv ut CLI-hjälp."

msgid "Print underlying SQLite library version."
msgstr "Skriv ut underliggande SQLite-biblioteksversion."

msgid "How-to guides"
msgstr "Hur man gör-guider"

msgid "How to use placeholders to bind values in SQL queries"
msgstr "Så här använder du platshållare för att binda värden i SQL-frågor"

msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"SQL-operationer behöver vanligtvis använda värden från Python-variabler. Var "
"dock försiktig med att använda Pythons strängoperationer för att sätta ihop "
"frågor, eftersom de är sårbara för `SQL-injektionsattacker`_. Till exempel "
"kan en angripare helt enkelt stänga det enkla citatet och injicera ``OR "
"TRUE`` för att välja alla rader::"

msgid ""
">>> # Never do this -- insecure!\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"
msgstr ""
">>> # Gör aldrig detta -- osäkert!\n"
">>> symbol = inmatning()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM aktier WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"

msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"Använd istället DB-API:s parametersubstitution. Om du vill infoga en "
"variabel i en frågesträng använder du en platshållare i strängen och "
"ersätter de faktiska värdena i frågan genom att tillhandahålla dem som en :"
"class:`tuple` av värden till det andra argumentet i markörens :meth:`~Cursor."
"execute`-metod."

msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* must be an instance of a :class:`dict` (or a subclass), "
"which must contain keys for all named parameters; any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"En SQL-sats kan använda en av två typer av platshållare: frågetecken (qmark-"
"stil) eller namngivna platshållare (named-stil). För qmark-stilen måste "
"*parameters* vara en :term:`sequence` vars längd måste motsvara antalet "
"platshållare, annars uppstår ett :exc:`ProgrammingError`. För den namngivna "
"stilen måste *parameters* vara en instans av en :class:`dict` (eller en "
"underklass), som måste innehålla nycklar för alla namngivna parametrar; "
"eventuella extra objekt ignoreras. Här är ett exempel på båda stilarna:"

msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# This is the named style used with executemany():\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# This is the qmark style used in a SELECT query:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":minne:\")\n"
"cur = con.execute(\"CREATE TABLE lang(namn, första_uppträdde)\")\n"
"\n"
"# Detta är den namngivna stil som används med executemany():\n"
"data = (\n"
"    {\"namn\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"år\": 1957},\n"
"    {\"name\": \"Python\", \"år\": 1991},\n"
"    {\"name\": \"Go\", \"år\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:namn, :år)\", data)\n"
"\n"
"# Detta är den qmark-stil som används i en SELECT-fråga:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"

msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""
":pep:`249` numeriska platshållare stöds *inte*. Om de används kommer de att "
"tolkas som namngivna platshållare."

msgid "How to adapt custom Python types to SQLite values"
msgstr "Så här anpassar du anpassade Python-typer till SQLite-värden"

msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"SQLite stöder endast en begränsad uppsättning datatyper. För att lagra "
"anpassade Python-typer i SQLite-databaser, *anpassa* dem till en av :ref:"
"`Python-typer som SQLite förstår inbyggt <sqlite3-types>`."

msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"Det finns två sätt att anpassa Python-objekt till SQLite-typer: att låta "
"ditt objekt anpassa sig självt eller att använda en *adapter callable*. Det "
"senare kommer att ha företräde framför det förra. För ett bibliotek som "
"exporterar en anpassad typ kan det vara vettigt att låta den typen anpassa "
"sig själv. Som applikationsutvecklare kan det vara mer meningsfullt att ta "
"direkt kontroll genom att registrera anpassade adapterfunktioner."

msgid "How to write adaptable objects"
msgstr "Hur man skriver anpassningsbara objekt"

msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"Antag att vi har en :class:`!Point`-klass som representerar ett par "
"koordinater, ``x`` och ``y``, i ett kartesiskt koordinatsystem. "
"Koordinatparet kommer att lagras som en textsträng i databasen, med ett "
"semikolon för att separera koordinaterna. Detta kan implementeras genom att "
"lägga till en metod ``__conform__(self, protocol)`` som returnerar det "
"anpassade värdet. Objektet som skickas till *protocol* kommer att vara av "
"typen :class:`PrepareProtocol`."

msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"klass Punkt:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protokoll):\n"
"        om protokollet är sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":minne:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\",(Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.stäng()"

msgid "How to register adapter callables"
msgstr "Så här registrerar du adapterkallelser"

msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"Den andra möjligheten är att skapa en funktion som konverterar Python-"
"objektet till en SQLite-kompatibel typ. Denna funktion kan sedan registreras "
"med hjälp av :func:`register_adapter`."

msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"klass Punkt:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(punkt):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Punkt, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":minne:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.stäng()"

msgid "How to convert SQLite values to custom Python types"
msgstr "Så här konverterar du SQLite-värden till anpassade Python-typer"

msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""
"Genom att skriva en adapter kan du konvertera *från* anpassade Python-typer "
"*till* SQLite-värden. För att kunna konvertera *från* SQLite-värden *till* "
"anpassade Python-typer använder vi *konverterare*."

msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""
"Låt oss gå tillbaka till :class:`!Point`-klassen. Vi lagrade x- och y-"
"koordinaterna åtskilda med semikolon som strängar i SQLite."

msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""
"Först definierar vi en konverteringsfunktion som tar emot en sträng som "
"parameter och konstruerar ett :class:`!Point`-objekt från den."

msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""
"Konverteringsfunktioner får **alltid** ett :class:`bytes`-objekt, oavsett "
"den underliggande SQLite-datatypen."

msgid ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"
msgstr ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Punkt(x, y)"

msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"Vi måste nu tala om för :mod:`!sqlite3` när den ska konvertera ett givet "
"SQLite-värde. Detta görs när du ansluter till en databas, med hjälp av "
"parametern *detect_types* i :func:`connect`. Det finns tre alternativ:"

msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr "Implicit: sätt *detect_types* till :const:`PARSE_DECLTYPES`"

msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "Explicit: sätt *detect_types* till :const:`PARSE_COLNAMES`"

msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"Båda: sätt *detect_types* till ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Kolumnnamn har företräde framför deklarerade typer."

msgid "The following example illustrates the implicit and explicit approaches:"
msgstr ""
"Följande exempel illustrerar de implicita och explicita tillvägagångssätten:"

msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter and converter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parse using declared types\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parse using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"
msgstr ""
"klass Punkt:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Punkt({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\"))))\n"
"    return Punkt(x, y)\n"
"\n"
"# Registrera adapter och omvandlare\n"
"sqlite3.register_adapter(Punkt, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parsa med hjälp av deklarerade typer\n"
"p = Punkt(4,0, -3,2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p punkt)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"VÄLJ p FRÅN test\")\n"
"print(\"med deklarerade typer:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parsa med hjälp av kolumnnamn\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [punkt]\" FROM test')\n"
"print(\"med kolumnnamn:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"

msgid "Adapter and converter recipes"
msgstr "Adapter- och konverterrecept"

msgid "This section shows recipes for common adapters and converters."
msgstr "I detta avsnitt visas recept för vanliga adaptrar och konvertrar."

msgid ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n"
"    return val.replace(tzinfo=None).isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"Adapt datetime.datetime to Unix timestamp.\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"Convert ISO 8601 date to datetime.date object.\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"Convert ISO 8601 datetime to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", convert_timestamp)"
msgstr ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"Anpassa datetime.date till ISO 8601-datum.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"Anpassa datetime.datetime till tidszon-naivt ISO 8601-datum."
"\"\"\"\n"
"    return val.replace(tzinfo=None).isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"Anpassa datetime.datetime till Unix-tidsstämpel.\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"Konvertera ISO 8601-datum till datetime.date-objekt.\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"Konvertera ISO 8601 datetime till datetime.datetime-objekt.\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"Konvertera Unix epoch-tidsstämpel till datetime.datetime-objekt."
"\"\"\"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", konvertera_timestamp)"

msgid "How to use connection shortcut methods"
msgstr "Så här använder du genvägsmetoder för anslutning"

msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"Med hjälp av metoderna :meth:`~Connection.execute`, :meth:`~Connection."
"executemany` och :meth:`~Connection.executescript` i klassen :class:"
"`Connection` kan din kod skrivas mer koncist eftersom du inte behöver skapa "
"de (ofta överflödiga) :class:`Cursor`-objekten explicit. Istället skapas :"
"class:`Cursor`-objekten implicit och dessa genvägsmetoder returnerar cursor-"
"objekten. På så sätt kan du köra en ``SELECT``-sats och iterera över den "
"direkt med bara ett enda anrop på :class:`Connection`-objektet."

msgid ""
"# Create and fill the table.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", "
"data)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, "
"\"rows\")\n"
"\n"
"# close() is not a shortcut method and it's not called automatically;\n"
"# the connection object should be closed manually\n"
"con.close()"
msgstr ""
"# Skapa och fyll i tabellen.\n"
"con = sqlite3.connect(\":minne:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", "
"data)\n"
"\n"
"# Skriv ut tabellinnehållet\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(rad)\n"
"\n"
"print(\"Jag raderade just\", con.execute(\"DELETE FROM lang\").rowcount, "
"\"rows\")\n"
"\n"
"# close() är inte en genvägsmetod och den anropas inte automatiskt;\n"
"# anslutningsobjektet bör stängas manuellt\n"
"con.close()"

msgid "How to use the connection context manager"
msgstr "Så här använder du kontexthanteraren för anslutningar"

msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back. If :attr:`~Connection.autocommit` "
"is ``False``, a new transaction is implicitly opened after committing or "
"rolling back."
msgstr ""
"Ett :class:`Connection`-objekt kan användas som en kontexthanterare som "
"automatiskt commitar eller rullar tillbaka öppna transaktioner när "
"kontexthanterarens kropp lämnas. Om :keyword:`with`-satsens kropp avslutas "
"utan undantag görs en commit av transaktionen. Om denna commit misslyckas, "
"eller om ``with``-satsen ger upphov till ett undantag som inte fångats upp, "
"rullas transaktionen tillbaka. Om :attr:`~Connection.autocommit` är "
"``False``, öppnas en ny transaktion implicit efter commit eller rollback."

msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, or if :attr:`~Connection.autocommit` is ``True``, the context "
"manager does nothing."
msgstr ""
"Om det inte finns någon öppen transaktion när man lämnar ``with``-satsen, "
"eller om :attr:`~Connection.autocommit` är ``True``, gör kontexthanteraren "
"ingenting."

msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using :meth:"
"`contextlib.closing`."
msgstr ""
"Kontexthanteraren varken öppnar implicit en ny transaktion eller stänger "
"anslutningen. Om du behöver en stängande kontexthanterare, överväg att "
"använda :meth:`contextlib.closing`."

msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an exception,\n"
"# the exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# Connection object used as context manager only commits or rollbacks "
"transactions,\n"
"# so the connection object should be closed manually\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":minne:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Lyckas, con.commit() anropas automatiskt efteråt\n"
"med con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() anropas efter att with-blocket avslutats med ett undantag,\n"
"# undantaget tas fortfarande upp och måste fångas upp\n"
"försök:\n"
"    med con:\n"
"        con.execute(\"INSERT INTO lang(namn) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"kunde inte lägga till Python två gånger\")\n"
"\n"
"# Anslutningsobjektet som används som kontexthanterare överför eller "
"återställer endast transaktioner,\n"
"# så anslutningsobjektet bör stängas manuellt\n"
"con.close()"

msgid "How to work with SQLite URIs"
msgstr "Så här arbetar du med SQLite URI:er"

msgid "Some useful URI tricks include:"
msgstr "Några användbara URI-trick inkluderar:"

msgid "Open a database in read-only mode:"
msgstr "Öppna en databas i skrivskyddat läge:"

msgid ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Återkoppling (senaste anropet senast):\n"
"OperationalError: försök att skriva en skrivskyddad databas\n"
">>> con.close()"

msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"Skapa inte implicit en ny databasfil om den inte redan finns; kommer att ge "
"upphov till :exc:`~sqlite3.OperationalError` om det inte går att skapa en ny "
"fil:"

msgid ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"
msgstr ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Återkoppling (senaste anropet senast):\n"
"OperationalError: det går inte att öppna databasfilen"

msgid "Create a shared named in-memory database:"
msgstr "Skapa en delad namngiven databas i minnet:"

msgid ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"
msgstr ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"med con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO delad VALUES(28)\")\n"
"res = con2.execute(\"VÄLJ data FRÅN delad\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.stäng()\n"
"con2.close()"

msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""
"Mer information om den här funktionen, inklusive en lista med parametrar, "
"finns i `SQLite URI-dokumentation`_."

msgid "How to create and use row factories"
msgstr "Så här skapar och använder du radfabriker"

msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"Som standard representerar :mod:`!sqlite3` varje rad som en :class:`tuple`. "
"Om en :class:`!tuple` inte passar dina behov kan du använda :class:`sqlite3."
"Row`-klassen eller en anpassad :attr:`~Cursor.row_factory`."

msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""
"Även om :attr:`!row_factory` finns som attribut både för :class:`Cursor` "
"och :class:`Connection`, rekommenderas att man anger :class:`Connection."
"row_factory`, så att alla markörer som skapas från anslutningen använder "
"samma radfabrik."

msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""
":class:`!Row` ger indexerad och skiftlägesokänslig namngiven åtkomst till "
"kolumner, med minimal minnesbelastning och prestandapåverkan jämfört med en :"
"class:`!tuple`. För att använda :class:`!Row` som en radfabrik, tilldela den "
"till attributet :attr:`!row_factory`:"

msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"
msgstr ""
">>> con = sqlite3.connect(\":minne:\")\n"
">>> con.row_factory = sqlite3.row"

msgid "Queries now return :class:`!Row` objects:"
msgstr "Frågor returnerar nu :class:`!Row`-objekt:"

msgid ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # Access by index.\n"
"'Earth'\n"
">>> row[\"name\"]    # Access by name.\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # Column names are case-insensitive.\n"
"6378\n"
">>> con.close()"
msgstr ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> rad = res.fetchone()\n"
">>> rad.nycklar()\n"
"['namn', 'radie']\n"
">>> rad[0] # Åtkomst via index.\n"
"'Jord'\n"
">>> row[\"name\"] # Åtkomst efter namn.\n"
"'Earth'\n"
">>> row[\"RADIUS\"] # Kolumnnamnen är skiftlägesokänsliga.\n"
"6378\n"
">>> con.close()"

msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""
"Klausulen ``FROM`` kan utelämnas i ``SELECT``-satsen, som i exemplet ovan. I "
"sådana fall returnerar SQLite en enda rad med kolumner som definieras av "
"uttryck, t.ex. literaler, med de angivna alias ``expr AS alias``."

msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""
"Du kan skapa en egen :attr:`~Cursor.row_factory` som returnerar varje rad "
"som en :class:`dict`, med kolumnnamn mappade till värden:"

msgid ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"
msgstr ""
"def dict_factory(markör, rad):\n"
"    fields = [kolumn[0] för kolumn i cursor.description]\n"
"    return {nyckel: värde för nyckel, värde i zip(fält, rad)}"

msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""
"Med hjälp av den returnerar frågor nu en :class:`!dict` i stället för en :"
"class:`!tuple`:"

msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":minne:\")\n"
">>> con.row_factory = dict_factory\n"
">>> för rad i con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"... print(rad)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"

msgid "The following row factory returns a :term:`named tuple`:"
msgstr "Följande radfabrik returnerar en :term:`named tuple`:"

msgid ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"
msgstr ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(markör, rad):\n"
"    fields = [column[0] for column in cursor.description] (kolumn[0] för "
"kolumn i cursor.description)\n"
"    cls = namedtuple(\"Rad\", fält)\n"
"    return cls._make(rad)"

msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` kan användas på följande sätt:"

msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # Indexed access.\n"
"1\n"
">>> row.b   # Attribute access.\n"
"2\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":minne:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> rad = cur.fetchone()\n"
">>> rad\n"
"Rad(a=1, b=2)\n"
">>> rad[0] # Indexerad åtkomst.\n"
"1\n"
">>> row.b # Attributåtkomst.\n"
"2\n"
">>> con.close()"

msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""
"Med några justeringar kan ovanstående recept anpassas så att man använder "
"en :class:`~dataclasses.dataclass`, eller någon annan anpassad klass, i "
"stället för en :class:`~collections.namedtuple`."

msgid "How to handle non-UTF-8 text encodings"
msgstr "Hur man hanterar textkodningar som inte är UTF-8"

msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might "
"fail for other encodings and invalid UTF-8. You can use a custom :attr:"
"`~Connection.text_factory` to handle such cases."
msgstr ""
"Som standard använder :mod:`!sqlite3` :class:`str` för att anpassa SQLite-"
"värden med datatypen ``TEXT``. Detta fungerar bra för UTF-8-kodad text, men "
"det kan misslyckas för andra kodningar och ogiltig UTF-8. Du kan använda en "
"anpassad :attr:`~Connection.text_factory` för att hantera sådana fall."

msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or "
"even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance :py:"
"data:`!con` connected to this database, we can decode the Latin-2 encoded "
"text using this :attr:`~Connection.text_factory`:"
msgstr ""
"På grund av SQLites `flexibla typning`_ är det inte ovanligt att "
"tabellkolumner med datatypen ``TEXT`` innehåller icke-UTF-8-kodningar eller "
"till och med godtyckliga data. För att demonstrera, låt oss anta att vi har "
"en databas med ISO-8859-2 (Latin-2) kodad text, till exempel en tabell med "
"tjeckisk-engelska ordboksinlägg. Om vi antar att vi nu har en :class:"
"`Connection`-instans :py:data:`!con` ansluten till denna databas, kan vi "
"avkoda den Latin-2-kodade texten med hjälp av denna :attr:`~Connection."
"text_factory`:"

msgid "con.text_factory = lambda data: str(data, encoding=\"latin2\")"
msgstr "con.text_factory = lambda data: str(data, kodning=\"latin2\")"

msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you "
"can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""
"För ogiltiga UTF-8 eller godtyckliga data som lagras i tabellkolumnerna "
"``TEXT`` kan du använda följande teknik, lånad från :ref:`unicode-howto``:"

msgid "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"
msgstr "con.text_factory = lambda data: str(data, fel=\"surrogateescape\")"

msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ""
"Modulen :mod:`!sqlite3` har inte stöd för strängar som innehåller surrogat."

msgid ":ref:`unicode-howto`"
msgstr ":ref:`unicode-howto`"

msgid "Explanation"
msgstr "Förklaring"

msgid "Transaction control"
msgstr "Kontroll av transaktioner"

msgid ""
":mod:`!sqlite3` offers multiple methods of controlling whether, when and how "
"database transactions are opened and closed. :ref:`sqlite3-transaction-"
"control-autocommit` is recommended, while :ref:`sqlite3-transaction-control-"
"isolation-level` retains the pre-Python 3.12 behaviour."
msgstr ""
":mod:`!sqlite3` erbjuder flera metoder för att kontrollera om, när och hur "
"databastransaktioner öppnas och stängs. :ref:`sqlite3-transaction-control-"
"autocommit` rekommenderas, medan :ref:`sqlite3-transaction-control-isolation-"
"level` behåller beteendet från före Python 3.12."

msgid "Transaction control via the ``autocommit`` attribute"
msgstr "Transaktionsstyrning via attributet ``autocommit``"

msgid ""
"The recommended way of controlling transaction behaviour is through the :"
"attr:`Connection.autocommit` attribute, which should preferably be set using "
"the *autocommit* parameter of :func:`connect`."
msgstr ""
"Det rekommenderade sättet att styra transaktionsbeteendet är genom "
"attributet :attr:`Connection.autocommit`, som helst bör ställas in med hjälp "
"av parametern *autocommit* i :func:`connect`."

msgid ""
"It is suggested to set *autocommit* to ``False``, which implies :pep:`249`-"
"compliant transaction control. This means:"
msgstr ""
"Det är rekommenderat att sätta *autocommit* till ``False``, vilket innebär :"
"pep:`249`-kompatibel transaktionskontroll. Detta innebär att:"

msgid ""
":mod:`!sqlite3` ensures that a transaction is always open, so :func:"
"`connect`, :meth:`Connection.commit`, and :meth:`Connection.rollback` will "
"implicitly open a new transaction (immediately after closing the pending "
"one, for the latter two). :mod:`!sqlite3` uses ``BEGIN DEFERRED`` statements "
"when opening transactions."
msgstr ""
":mod:`!sqlite3` säkerställer att en transaktion alltid är öppen, så :func:"
"`connect`, :meth:`Connection.commit` och :meth:`Connection.rollback` kommer "
"implicit att öppna en ny transaktion (omedelbart efter att den väntande har "
"stängts, för de två senare). :mod:`!sqlite3` använder ``BEGIN DEFERRED``-"
"satser när transaktioner öppnas."

msgid "Transactions should be committed explicitly using :meth:`!commit`."
msgstr "Transaktioner bör bekräftas uttryckligen med :meth:`!commit`."

msgid "Transactions should be rolled back explicitly using :meth:`!rollback`."
msgstr "Transaktioner bör rullas tillbaka uttryckligen med :meth:`!rollback`."

msgid ""
"An implicit rollback is performed if the database is :meth:`~Connection."
"close`-ed with pending changes."
msgstr ""
"En implicit rollback utförs om databasen :meth:`~Connection.close`-ed med "
"pågående ändringar."

msgid ""
"Set *autocommit* to ``True`` to enable SQLite's `autocommit mode`_. In this "
"mode, :meth:`Connection.commit` and :meth:`Connection.rollback` have no "
"effect. Note that SQLite's autocommit mode is distinct from the :pep:`249`-"
"compliant :attr:`Connection.autocommit` attribute; use :attr:`Connection."
"in_transaction` to query the low-level SQLite autocommit mode."
msgstr ""
"Sätt *autocommit* till ``True`` för att aktivera SQLites `autocommit-läge`_. "
"I detta läge har :meth:`Connection.commit` och :meth:`Connection.rollback` "
"ingen effekt. Observera att SQLites autocommit-läge skiljer sig från det :"
"pep:`249`-kompatibla attributet :attr:`Connection.autocommit`; använd :attr:"
"`Connection.in_transaction` för att fråga om SQLites autocommit-läge på låg "
"nivå."

msgid ""
"Set *autocommit* to :data:`LEGACY_TRANSACTION_CONTROL` to leave transaction "
"control behaviour to the :attr:`Connection.isolation_level` attribute. See :"
"ref:`sqlite3-transaction-control-isolation-level` for more information."
msgstr ""
"Sätt *autocommit* till :data:`LEGACY_TRANSACTION_CONTROL` för att överlåta "
"transaktionskontrollbeteendet till attributet :attr:`Connection."
"isolation_level`. Se :ref:`sqlite3-transaction-control-isolation-level` för "
"mer information."

msgid "Transaction control via the ``isolation_level`` attribute"
msgstr ""
"Transaktionskontroll via attributet ``isolation_level`` (isoleringsnivå)"

msgid ""
"The recommended way of controlling transactions is via the :attr:"
"`~Connection.autocommit` attribute. See :ref:`sqlite3-transaction-control-"
"autocommit`."
msgstr ""
"Det rekommenderade sättet att kontrollera transaktioner är via attributet :"
"attr:`~Connection.autocommit`. Se :ref:`sqlite3-transaction-control-"
"autocommit`."

msgid ""
"If :attr:`Connection.autocommit` is set to :data:"
"`LEGACY_TRANSACTION_CONTROL` (the default), transaction behaviour is "
"controlled using the :attr:`Connection.isolation_level` attribute. "
"Otherwise, :attr:`!isolation_level` has no effect."
msgstr ""
"Om :attr:`Connection.autocommit` är satt till :data:"
"`LEGACY_TRANSACTION_CONTROL` (standard), styrs transaktionsbeteendet med "
"attributet :attr:`Connection.isolation_level`. I annat fall har :attr:`!"
"isolation_level` ingen effekt."

msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"Om anslutningsattributet :attr:`~Connection.isolation_level` inte är "
"``None`` öppnas nya transaktioner implicit innan :meth:`~Cursor.execute` "
"och :meth:`~Cursor.executemany` utför ``INSERT``, ``UPDATE``, ``DELETE`` "
"eller ``REPLACE``-satser; för andra satser utförs ingen implicit "
"transaktionshantering. Använd metoderna :meth:`~Connection.commit` och :meth:"
"`~Connection.rollback` för att binda respektive rulla tillbaka pågående "
"transaktioner. Du kan välja det underliggande `SQLite-"
"transaktionsbeteendet`_ - det vill säga om och vilken typ av ``BEGIN``-"
"satser som :mod:`!sqlite3` implicit utför - via attributet :attr:"
"`~Connection.isolation_level`."

msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
"Om :attr:`~Connection.isolation_level` är satt till ``None``, öppnas inga "
"transaktioner alls implicit. Detta lämnar det underliggande SQLite-"
"biblioteket i `autocommit mode`_, men gör det också möjligt för användaren "
"att utföra sin egen transaktionshantering med hjälp av explicita SQL-satser. "
"Det underliggande SQLite-bibliotekets autocommit-läge kan efterfrågas med "
"hjälp av attributet :attr:`~Connection.in_transaction`."

msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
"Metoden :meth:`~Cursor.executescript` binder implicit alla väntande "
"transaktioner innan det angivna SQL-skriptet körs, oavsett värdet på :attr:"
"`~Connection.isolation_level`."

msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`!sqlite3` brukade implicit binda en öppen transaktion före DDL-"
"satser.  Detta är inte längre fallet."

msgid ""
"The recommended way of controlling transactions is now via the :attr:"
"`~Connection.autocommit` attribute."
msgstr ""
"Det rekommenderade sättet att kontrollera transaktioner är nu via "
"attributet :attr:`~Connection.autocommit`."

msgid "? (question mark)"
msgstr "? (frågetecken)"

msgid "in SQL statements"
msgstr "i SQL-satser"

msgid ": (colon)"
msgstr ": (kolon)"
