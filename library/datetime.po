# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ":mod:`!datetime` --- Basic date and time types"
msgstr ":mod:`!datetime` --- Grundläggande datum- och tidstyper"

msgid "**Source code:** :source:`Lib/datetime.py`"
msgstr "**Källkod:** :source:`Lib/datetime.py`"

msgid ""
"The :mod:`!datetime` module supplies classes for manipulating dates and "
"times."
msgstr ""
"Modulen :mod:`!datetime` innehåller klasser för manipulering av datum och "
"tid."

msgid ""
"While date and time arithmetic is supported, the focus of the implementation "
"is on efficient attribute extraction for output formatting and manipulation."
msgstr ""
"Även om aritmetik för datum och tid stöds ligger fokus i implementeringen på "
"effektiv attributextraktion för formatering och hantering av utdata."

msgid "Skip to :ref:`the format codes <format-codes>`."
msgstr "Hoppa till :ref:`formatkoderna <format-codes>`."

msgid "Module :mod:`calendar`"
msgstr "Modul :mod:`kalender`"

msgid "General calendar related functions."
msgstr "Allmänna kalenderrelaterade funktioner."

msgid "Module :mod:`time`"
msgstr "Modul :mod:`tid`"

msgid "Time access and conversions."
msgstr "Tidstillgång och konverteringar."

msgid "Module :mod:`zoneinfo`"
msgstr "Modul :mod:`zoneinfo`"

msgid "Concrete time zones representing the IANA time zone database."
msgstr "Konkreta tidszoner som representerar IANA:s tidszonsdatabas."

msgid "Package `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"
msgstr "Paketet `dateutil <https://dateutil.readthedocs.io/en/stable/>`_"

msgid "Third-party library with expanded time zone and parsing support."
msgstr "Tredjepartsbibliotek med utökat stöd för tidszoner och parsning."

msgid "Package :pypi:`DateType`"
msgstr "Paket :pypi:`DateType`"

msgid ""
"Third-party library that introduces distinct static types to e.g. allow :"
"term:`static type checkers <static type checker>` to differentiate between "
"naive and aware datetimes."
msgstr ""
"Tredjepartsbibliotek som introducerar distinkta statiska typer för att t.ex. "
"tillåta :term:`static type checkers <static type checker>` att skilja mellan "
"naiva och medvetna datatider."

msgid "Aware and Naive Objects"
msgstr "Medvetna och naiva objekt"

msgid ""
"Date and time objects may be categorized as \"aware\" or \"naive\" depending "
"on whether or not they include time zone information."
msgstr ""
"Datum- och tidsobjekt kan kategoriseras som \"medvetna\" eller \"naiva\" "
"beroende på om de innehåller tidszoninformation eller inte."

msgid ""
"With sufficient knowledge of applicable algorithmic and political time "
"adjustments, such as time zone and daylight saving time information, an "
"**aware** object can locate itself relative to other aware objects. An aware "
"object represents a specific moment in time that is not open to "
"interpretation. [#]_"
msgstr ""
"Med tillräcklig kunskap om tillämpliga algoritmiska och politiska "
"tidsjusteringar, t.ex. information om tidszoner och sommartid, kan ett "
"**medvetet** objekt lokalisera sig självt i förhållande till andra medvetna "
"objekt. Ett medvetet objekt representerar ett specifikt ögonblick i tiden "
"som inte är öppet för tolkning. "

msgid ""
"A **naive** object does not contain enough information to unambiguously "
"locate itself relative to other date/time objects. Whether a naive object "
"represents Coordinated Universal Time (UTC), local time, or time in some "
"other time zone is purely up to the program, just like it is up to the "
"program whether a particular number represents metres, miles, or mass. Naive "
"objects are easy to understand and to work with, at the cost of ignoring "
"some aspects of reality."
msgstr ""
"Ett **naivt** objekt innehåller inte tillräckligt med information för att "
"entydigt lokalisera sig själv i förhållande till andra datum-/tidsobjekt. "
"Det är helt upp till programmet att avgöra om ett naivt objekt representerar "
"UTC (Coordinated Universal Time), lokal tid eller tid i någon annan tidszon, "
"precis som det är upp till programmet att avgöra om ett visst tal "
"representerar meter, miles eller massa. Naiva objekt är lätta att förstå och "
"arbeta med, men till priset av att de ignorerar vissa aspekter av "
"verkligheten."

msgid ""
"For applications requiring aware objects, :class:`.datetime` and :class:`."
"time` objects have an optional time zone information attribute, :attr:`!"
"tzinfo`, that can be set to an instance of a subclass of the abstract :class:"
"`tzinfo` class. These :class:`tzinfo` objects capture information about the "
"offset from UTC time, the time zone name, and whether daylight saving time "
"is in effect."
msgstr ""
"För tillämpningar som kräver medvetna objekt har objekten :class:`.datetime` "
"och :class:`.time` ett valfritt attribut för tidszonsinformation, :attr:`!"
"tzinfo`, som kan sättas till en instans av en underklass av den abstrakta "
"klassen :class:`tzinfo`. Dessa :class:`tzinfo`-objekt innehåller information "
"om förskjutningen från UTC-tiden, tidszonens namn och om sommartid gäller."

msgid ""
"Only one concrete :class:`tzinfo` class, the :class:`timezone` class, is "
"supplied by the :mod:`!datetime` module. The :class:`!timezone` class can "
"represent simple time zones with fixed offsets from UTC, such as UTC itself "
"or North American EST and EDT time zones. Supporting time zones at deeper "
"levels of detail is up to the application. The rules for time adjustment "
"across the world are more political than rational, change frequently, and "
"there is no standard suitable for every application aside from UTC."
msgstr ""
"Endast en konkret :class:`tzinfo`-klass, :class:`timezone`-klassen, "
"tillhandahålls av :mod:`!datetime`-modulen. Klassen :class:`!timezone` kan "
"representera enkla tidszoner med fasta förskjutningar från UTC, t.ex. UTC "
"själv eller nordamerikanska EST- och EDT-tidszoner. Stöd för tidszoner på "
"djupare detaljnivåer är upp till applikationen. Reglerna för tidsjustering "
"över hela världen är mer politiska än rationella, ändras ofta och det finns "
"ingen standard som är lämplig för alla tillämpningar förutom UTC."

msgid "Constants"
msgstr "Konstanter"

msgid "The :mod:`!datetime` module exports the following constants:"
msgstr "Modulen :mod:`!datetime` exporterar följande konstanter:"

msgid ""
"The smallest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MINYEAR` is 1."
msgstr ""
"Det minsta tillåtna årtalet i ett :class:`date`- eller :class:`.datetime`-"
"objekt. :const:`MINYEAR` är 1."

msgid ""
"The largest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MAXYEAR` is 9999."
msgstr ""
"Det största tillåtna årtalet i ett :class:`date`- eller :class:`.datetime`-"
"objekt. :const:`MAXYEAR` är 9999."

msgid "Alias for the UTC time zone singleton :attr:`datetime.timezone.utc`."
msgstr "Alias för UTC-tidszonens singleton :attr:`datetime.timezone.utc`."

msgid "Available Types"
msgstr "Tillgängliga typer"

msgid ""
"An idealized naive date, assuming the current Gregorian calendar always was, "
"and always will be, in effect. Attributes: :attr:`year`, :attr:`month`, and :"
"attr:`day`."
msgstr ""
"Ett idealiserat naivt datum som utgår från att den nuvarande gregorianska "
"kalendern alltid har gällt och alltid kommer att gälla. Attribut: :attr:"
"`year`, :attr:`month`, och :attr:`day`."

msgid ""
"An idealized time, independent of any particular day, assuming that every "
"day has exactly 24\\*60\\*60 seconds.  (There is no notion of \"leap "
"seconds\" here.) Attributes: :attr:`hour`, :attr:`minute`, :attr:`second`, :"
"attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"En idealiserad tid, oberoende av en viss dag, under antagandet att varje dag "
"har exakt 24\\*60\\*60 sekunder.  (Det finns ingen uppfattning om "
"\"skottsekunder\" här.) Attribut: :attr:`hour`, :attr:`minute`, :attr:"
"`second`, :attr:`microsecond` och :attr:`.tzinfo`."

msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"En kombination av ett datum och en tid. Attribut: :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond` och :attr:`.tzinfo`."

msgid ""
"A duration expressing the difference between two :class:`.datetime` or :"
"class:`date` instances to microsecond resolution."
msgstr ""
"En varaktighet som uttrycker skillnaden mellan två :class:`.datetime`- "
"eller :class:`date`-instanser med mikrosekunders upplösning."

msgid ""
"An abstract base class for time zone information objects. These are used by "
"the :class:`.datetime` and :class:`.time` classes to provide a customizable "
"notion of time adjustment (for example, to account for time zone and/or "
"daylight saving time)."
msgstr ""
"En abstrakt basklass för objekt med information om tidszoner. Dessa används "
"av klasserna :class:`.datetime` och :class:`.time` för att ge en "
"anpassningsbar uppfattning om tidsjustering (t.ex. för att ta hänsyn till "
"tidszon och/eller sommartid)."

msgid ""
"A class that implements the :class:`tzinfo` abstract base class as a fixed "
"offset from the UTC."
msgstr ""
"En klass som implementerar den abstrakta basklassen :class:`tzinfo` som en "
"fast förskjutning från UTC."

msgid "Objects of these types are immutable."
msgstr "Objekt av dessa typer är oföränderliga."

msgid "Subclass relationships::"
msgstr "Relationer mellan underklasser::"

msgid ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"        timezone\n"
"    time\n"
"    date\n"
"        datetime"
msgstr ""
"objekt\n"
"    timedelta\n"
"    tzinfo\n"
"        tidszon\n"
"    tid\n"
"    datum\n"
"        datatid"

msgid "Common Properties"
msgstr "Gemensamma egenskaper"

msgid ""
"The :class:`date`, :class:`.datetime`, :class:`.time`, and :class:`timezone` "
"types share these common features:"
msgstr ""
"Typerna :class:`date`, :class:`.datetime`, :class:`.time` och :class:"
"`timezone` har dessa gemensamma egenskaper:"

msgid ""
"Objects of these types are :term:`hashable`, meaning that they can be used "
"as dictionary keys."
msgstr ""
"Objekt av dessa typer är :term:`hashable`, vilket innebär att de kan "
"användas som nycklar i en ordbok."

msgid ""
"Objects of these types support efficient pickling via the :mod:`pickle` "
"module."
msgstr ""
"Objekt av dessa typer stöder effektiv pickling via modulen :mod:`pickle`."

msgid "Determining if an Object is Aware or Naive"
msgstr "Avgöra om ett objekt är medvetet eller naivt"

msgid "Objects of the :class:`date` type are always naive."
msgstr "Objekt av typen :class:`date` är alltid naiva."

msgid ""
"An object of type :class:`.time` or :class:`.datetime` may be aware or naive."
msgstr ""
"Ett objekt av typen :class:`.time` eller :class:`.datetime` kan vara "
"medvetet eller naivt."

msgid ""
"A :class:`.datetime` object ``d`` is aware if both of the following hold:"
msgstr ""
"Ett :class:`.datetime`-objekt ``d`` är medvetet om båda följande gäller:"

msgid "``d.tzinfo`` is not ``None``"
msgstr "``d.tzinfo`` är inte ``None``"

msgid "``d.tzinfo.utcoffset(d)`` does not return ``None``"
msgstr "``d.tzinfo.utcoffset(d)`` returnerar inte ``None``"

msgid "Otherwise, ``d`` is naive."
msgstr "Annars är ``d`` naivt."

msgid "A :class:`.time` object ``t`` is aware if both of the following hold:"
msgstr ""
"Ett :class:`.time`-objekt ``t`` är medvetet om båda följande villkor är "
"uppfyllda:"

msgid "``t.tzinfo`` is not ``None``"
msgstr "``t.tzinfo`` är inte ``None``"

msgid "``t.tzinfo.utcoffset(None)`` does not return ``None``."
msgstr "```t.tzinfo.utcoffset(None)`` returnerar inte ``None``."

msgid "Otherwise, ``t`` is naive."
msgstr "Annars är ``t`` naivt."

msgid ""
"The distinction between aware and naive doesn't apply to :class:`timedelta` "
"objects."
msgstr ""
"Skillnaden mellan medveten och naiv gäller inte för :class:`timedelta`-"
"objekt."

msgid ":class:`timedelta` Objects"
msgstr ":class:`timedelta` Objekt"

msgid ""
"A :class:`timedelta` object represents a duration, the difference between "
"two :class:`.datetime` or :class:`date` instances."
msgstr ""
"Ett :class:`timedelta`-objekt representerar en varaktighet, skillnaden "
"mellan två :class:`.datetime`- eller :class:`date`-instanser."

msgid ""
"All arguments are optional and default to 0. Arguments may be integers or "
"floats, and may be positive or negative."
msgstr ""
"Alla argument är valfria och är som standard 0. Argumenten kan vara heltal "
"eller flyttal och kan vara positiva eller negativa."

msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally. Arguments "
"are converted to those units:"
msgstr ""
"Endast *dagar*, *sekunder* och *mikrosekunder* lagras internt. Argument "
"konverteras till dessa enheter:"

msgid "A millisecond is converted to 1000 microseconds."
msgstr "En millisekund omvandlas till 1000 mikrosekunder."

msgid "A minute is converted to 60 seconds."
msgstr "En minut omvandlas till 60 sekunder."

msgid "An hour is converted to 3600 seconds."
msgstr "En timme omvandlas till 3600 sekunder."

msgid "A week is converted to 7 days."
msgstr "En vecka omvandlas till 7 dagar."

msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr ""
"och dagar, sekunder och mikrosekunder normaliseras sedan så att "
"representationen blir unik, med"

msgid "``0 <= microseconds < 1000000``"
msgstr "``0 <= mikrosekunder < 1000000```"

msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr "``0 <= sekunder < 3600*24`` (antalet sekunder på en dag)"

msgid "``-999999999 <= days <= 999999999``"
msgstr "``-999999999 <= dagar <= 999999999```"

msgid ""
"The following example illustrates how any arguments besides *days*, "
"*seconds* and *microseconds* are \"merged\" and normalized into those three "
"resulting attributes::"
msgstr ""
"Följande exempel illustrerar hur alla argument utöver *dagar*, *sekunder* "
"och *mikrosekunder* \"slås samman\" och normaliseras till dessa tre "
"resulterande attribut::"

msgid ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"
msgstr ""
">>> from datetime import timedelta\n"
">>> delta = timedelta(\n"
"...     days=50,\n"
"...     seconds=27,\n"
"...     microseconds=10,\n"
"...     milliseconds=29000,\n"
"...     minutes=5,\n"
"...     hours=8,\n"
"...     weeks=2\n"
"... )\n"
">>> # Only days, seconds, and microseconds remain\n"
">>> delta\n"
"datetime.timedelta(days=64, seconds=29156, microseconds=10)"

msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and their "
"sum is rounded to the nearest microsecond using round-half-to-even "
"tiebreaker. If no argument is a float, the conversion and normalization "
"processes are exact (no information is lost)."
msgstr ""
"Om något argument är en float och det finns bråkdelar av mikrosekunder, "
"kombineras de bråkdelar av mikrosekunder som återstår från alla argument och "
"summan avrundas till närmaste mikrosekund med hjälp av tiebreakermetoden "
"\"round-half-to-even\". Om inget argument är en float är omvandlings- och "
"normaliseringsprocesserna exakta (ingen information går förlorad)."

msgid ""
"If the normalized value of days lies outside the indicated range, :exc:"
"`OverflowError` is raised."
msgstr ""
"Om det normaliserade värdet av dagar ligger utanför det angivna "
"intervallet, :exc:`OverflowError`."

msgid ""
"Note that normalization of negative values may be surprising at first. For "
"example::"
msgstr ""
"Observera att normalisering av negativa värden kan vara överraskande till en "
"början. Till exempel::"

msgid ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"
msgstr ""
">>> from datetime import timedelta\n"
">>> d = timedelta(microseconds=-1)\n"
">>> (d.days, d.seconds, d.microseconds)\n"
"(-1, 86399, 999999)"

msgid ""
"Since the string representation of :class:`!timedelta` objects can be "
"confusing, use the following recipe to produce a more readable format:"
msgstr ""
"Eftersom strängrepresentationen av :class:`!timedelta`-objekt kan vara "
"förvirrande, kan du använda följande recept för att producera ett mer "
"läsbart format:"

msgid ""
">>> def pretty_timedelta(td):\n"
"...     if td.days >= 0:\n"
"...         return str(td)\n"
"...     return f'-({-td!s})'\n"
"...\n"
">>> d = timedelta(hours=-1)\n"
">>> str(d)  # not human-friendly\n"
"'-1 day, 23:00:00'\n"
">>> pretty_timedelta(d)\n"
"'-(1:00:00)'"
msgstr ""
">>> def pretty_timedelta(td):\n"
"... if td.days >= 0:\n"
"... return str(td)\n"
"... return f'-({-td!s})'\n"
"...\n"
">>> d = timedelta(timmar=-1)\n"
">>> str(d) # inte människovänligt\n"
"\"-1 dag, 23:00:00\n"
">>> pretty_timedelta(d)\n"
"'-(1:00:00)'"

msgid "Class attributes:"
msgstr "Klassens attribut:"

msgid "The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr ""
"Det mest negativa :class:`timedelta`-objektet, ``timedelta(-999999999)``."

msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""
"Det mest positiva :class:`timedelta`-objektet, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."

msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"Den minsta möjliga skillnaden mellan icke jämlika :class:`timedelta`-objekt, "
"``timedelta(microseconds=1)``."

msgid ""
"Note that, because of normalization, ``timedelta.max`` is greater than ``-"
"timedelta.min``. ``-timedelta.max`` is not representable as a :class:"
"`timedelta` object."
msgstr ""
"Observera att på grund av normaliseringen är ``timedelta.max`` större än ``-"
"timedelta.min``. ``-timedelta.max`` är inte representerbar som ett :class:"
"`timedelta`-objekt."

msgid "Instance attributes (read-only):"
msgstr "Instansattribut (skrivskyddad):"

msgid "Between -999,999,999 and 999,999,999 inclusive."
msgstr "Mellan -999,999,999 och 999,999,999 inklusive."

msgid "Between 0 and 86,399 inclusive."
msgstr "Mellan 0 och 86.399 inklusive."

msgid ""
"It is a somewhat common bug for code to unintentionally use this attribute "
"when it is actually intended to get a :meth:`~timedelta.total_seconds` value "
"instead:"
msgstr ""
"Det är ett ganska vanligt fel att kod oavsiktligt använder detta attribut "
"när det egentligen är avsett att få ett :meth:`~timedelta.total_seconds`-"
"värde istället:"

msgid ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"
msgstr ""
">>> from datetime import timedelta\n"
">>> duration = timedelta(seconds=11235813)\n"
">>> duration.days, duration.seconds\n"
"(130, 3813)\n"
">>> duration.total_seconds()\n"
"11235813.0"

msgid "Between 0 and 999,999 inclusive."
msgstr "Mellan 0 och 999.999 inklusive."

msgid "Supported operations:"
msgstr "Operationer som stöds:"

msgid "Operation"
msgstr "Operation"

msgid "Result"
msgstr "Resultat"

msgid "``t1 = t2 + t3``"
msgstr "``t1 = t2 + t3``"

msgid ""
"Sum of ``t2`` and ``t3``. Afterwards ``t1 - t2 == t3`` and ``t1 - t3 == t2`` "
"are true. (1)"
msgstr ""
"Summan av ``t2`` och ``t3``. Efteråt är ``t1 - t2 == t3`` och ``t1 - t3 == "
"t2`` sanna. (1)"

msgid "``t1 = t2 - t3``"
msgstr "``t1 = t2 - t3``"

msgid ""
"Difference of ``t2``  and ``t3``. Afterwards ``t1 == t2 - t3`` and ``t2 == "
"t1 + t3`` are true. (1)(6)"
msgstr ""
"Skillnad mellan ``t2`` och ``t3``. Efteråt är ``t1 == t2 - t3`` och ``t2 == "
"t1 + t3`` sanna. (1)(6)"

msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr "``t1 = t2 * i eller t1 = i * t2``"

msgid ""
"Delta multiplied by an integer. Afterwards ``t1 // i == t2`` is true, "
"provided ``i != 0``."
msgstr ""
"Delta multiplicerat med ett heltal. Efteråt är ``t1 // i == t2`` sant, "
"förutsatt att ``i != 0``."

msgid "In general, ``t1  * i == t1 * (i-1) + t1`` is true. (1)"
msgstr "I allmänhet är ``t1 * i == t1 * (i-1) + t1`` sant. (1)"

msgid "``t1 = t2 * f or t1 = f * t2``"
msgstr "``t1 = t2 * f eller t1 = f * t2``"

msgid ""
"Delta multiplied by a float. The result is rounded to the nearest multiple "
"of timedelta.resolution using round-half-to-even."
msgstr ""
"Delta multiplicerat med ett flyttal. Resultatet avrundas till närmaste "
"multipel av timedelta.resolution med hjälp av round-half-to-even."

msgid "``f = t2 / t3``"
msgstr "``f = t2 / t3``"

msgid ""
"Division (3) of overall duration ``t2`` by interval unit ``t3``. Returns a :"
"class:`float` object."
msgstr ""
"Division (3) av total varaktighet ``t2`` med intervallenhet ``t3``. "
"Returnerar ett :class:`float`-objekt."

msgid "``t1 = t2 / f or t1 = t2 / i``"
msgstr "``t1 = t2 / f eller t1 = t2 / i``"

msgid ""
"Delta divided by a float or an int. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"Delta dividerat med en float eller en int. Resultatet avrundas till närmaste "
"multipel av timedelta.resolution med hjälp av round-half-to-even."

msgid "``t1 = t2 // i`` or ``t1 = t2 // t3``"
msgstr "``t1 = t2 // i`` eller ``t1 = t2 // t3``"

msgid ""
"The floor is computed and the remainder (if any) is thrown away. In the "
"second case, an integer is returned. (3)"
msgstr ""
"Golvet beräknas och återstoden (om någon) kastas bort. I det andra fallet "
"returneras ett heltal. (3)"

msgid "``t1 = t2 % t3``"
msgstr "``t1 = t2 % t3``"

msgid "The remainder is computed as a :class:`timedelta` object. (3)"
msgstr "Återstoden beräknas som ett :class:`timedelta`-objekt. (3)"

msgid "``q, r = divmod(t1, t2)``"
msgstr "``q, r = divmod(t1, t2)``"

msgid ""
"Computes the quotient and the remainder: ``q = t1 // t2`` (3) and ``r = t1 % "
"t2``. ``q`` is an integer and ``r`` is a :class:`timedelta` object."
msgstr ""
"Beräknar kvoten och resten: ``q = t1 // t2`` (3) och ``r = t1 % t2``. ``q`` "
"är ett heltal och ``r`` är ett :class:`timedelta`-objekt."

msgid "``+t1``"
msgstr "``+t1``"

msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr "Returnerar ett :class:`timedelta`-objekt med samma värde. (2)"

msgid "``-t1``"
msgstr "``-t1``"

msgid ""
"Equivalent to ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``, and to "
"``t1 * -1``. (1)(4)"
msgstr ""
"Motsvarar ``timedelta(-t1.days, -t1.seconds, -t1.microseconds)``, och ``t1 * "
"-1``. (1)(4)"

msgid "``abs(t)``"
msgstr "``abs(t)``"

msgid ""
"Equivalent to ``+t`` when ``t.days >= 0``, and to ``-t`` when ``t.days < "
"0``. (2)"
msgstr ""
"Motsvarar ``+t`` när ``t.days >= 0``, och ``-t`` när ``t.days < 0``. (2)"

msgid "``str(t)``"
msgstr "``str(t)```"

msgid ""
"Returns a string in the form ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D is "
"negative for negative ``t``. (5)"
msgstr ""
"Returnerar en sträng i formen ``[D dag[ar], ][H]H:MM:SS[.UUUUUU]``, där D är "
"negativ för negativ ``t``. (5)"

msgid "``repr(t)``"
msgstr "``repr(t)```"

msgid ""
"Returns a string representation of the :class:`timedelta` object as a "
"constructor call with canonical attribute values."
msgstr ""
"Returnerar en strängrepresentation av :class:`timedelta`-objektet som ett "
"anrop från konstruktören med kanoniska attributvärden."

msgid "Notes:"
msgstr "Anteckningar:"

msgid "This is exact but may overflow."
msgstr "Detta är exakt men kan överfyllas."

msgid "This is exact and cannot overflow."
msgstr "Detta är exakt och kan inte rinna över."

msgid "Division by zero raises :exc:`ZeroDivisionError`."
msgstr "Division med noll ger upphov till :exc:`ZeroDivisionError`."

msgid "``-timedelta.max`` is not representable as a :class:`timedelta` object."
msgstr ""
"``-timedelta.max`` kan inte representeras som ett :class:`timedelta`-objekt."

msgid ""
"String representations of :class:`timedelta` objects are normalized "
"similarly to their internal representation. This leads to somewhat unusual "
"results for negative timedeltas. For example::"
msgstr ""
"Strängrepresentationer av :class:`timedelta`-objekt normaliseras på samma "
"sätt som deras interna representation. Detta leder till något ovanliga "
"resultat för negativa timedelta. Till exempel::"

msgid ""
">>> timedelta(hours=-5)\n"
"datetime.timedelta(days=-1, seconds=68400)\n"
">>> print(_)\n"
"-1 day, 19:00:00"
msgstr ""
">>> timedelta(timmar=-5)\n"
"datetime.timedelta(dagar=-1, sekunder=68400)\n"
">>> skriv ut(_)\n"
"-1 dag, 19:00:00"

msgid ""
"The expression ``t2 - t3`` will always be equal to the expression ``t2 + (-"
"t3)`` except when t3 is equal to ``timedelta.max``; in that case the former "
"will produce a result while the latter will overflow."
msgstr ""
"Uttrycket ``t2 - t3`` kommer alltid att vara lika med uttrycket ``t2 + (-"
"t3)`` utom när t3 är lika med ``timedelta.max``; i så fall kommer det förra "
"att ge ett resultat medan det senare kommer att överskridas."

msgid ""
"In addition to the operations listed above, :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and :class:`."
"datetime` objects (see below)."
msgstr ""
"Förutom de operationer som anges ovan stöder :class:`timedelta`-objekt vissa "
"additioner och subtraktioner med :class:`date`- och :class:`.datetime`-"
"objekt (se nedan)."

msgid ""
"Floor division and true division of a :class:`timedelta` object by another :"
"class:`timedelta` object are now supported, as are remainder operations and "
"the :func:`divmod` function. True division and multiplication of a :class:"
"`timedelta` object by a :class:`float` object are now supported."
msgstr ""
"Floor division och true division av ett :class:`timedelta`-objekt med ett "
"annat :class:`timedelta`-objekt stöds nu, liksom restoperationer och "
"funktionen :func:`divmod`. Sann division och multiplikation av ett :class:"
"`timedelta`-objekt med ett :class:`float`-objekt stöds nu."

msgid ":class:`timedelta` objects support equality and order comparisons."
msgstr ":class:`timedelta`-objekt stöder jämlikhets- och ordningsjämförelser."

msgid ""
"In Boolean contexts, a :class:`timedelta` object is considered to be true if "
"and only if it isn't equal to ``timedelta(0)``."
msgstr ""
"I booleska sammanhang anses ett :class:`timedelta`-objekt vara sant om och "
"endast om det inte är lika med ``timedelta(0)``."

msgid "Instance methods:"
msgstr "Instansmetoder:"

msgid ""
"Return the total number of seconds contained in the duration. Equivalent to "
"``td / timedelta(seconds=1)``. For interval units other than seconds, use "
"the division form directly (e.g. ``td / timedelta(microseconds=1)``)."
msgstr ""
"Returnerar det totala antalet sekunder som ingår i varaktigheten. Motsvarar "
"``td / timedelta(sekunder=1)``. För andra intervallenheter än sekunder, "
"använd divisionsformen direkt (t.ex. ``td / timedelta(microseconds=1)``)."

msgid ""
"Note that for very large time intervals (greater than 270 years on most "
"platforms) this method will lose microsecond accuracy."
msgstr ""
"Observera att för mycket stora tidsintervall (större än 270 år på de flesta "
"plattformar) kommer denna metod att förlora mikrosekundsnoggrannhet."

msgid "Examples of usage: :class:`timedelta`"
msgstr "Exempel på användning: :class:`timedelta`"

msgid "An additional example of normalization::"
msgstr "Ytterligare ett exempel på normalisering::"

msgid ""
">>> # Components of another_year add up to exactly 365 days\n"
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"...                          minutes=50, seconds=600)\n"
">>> year == another_year\n"
"True\n"
">>> year.total_seconds()\n"
"31536000.0"
msgstr ""
">>> # Komponenterna i another_year summerar till exakt 365 dagar\n"
">>> from datetime import timedelta\n"
">>> år = timedelta(dagar=365)\n"
">>> another_year = timedelta(weeks=40, days=84, hours=23,\n"
"... minuter=50, sekunder=600)\n"
">>> år == ett annat_år\n"
"Sant\n"
">>> year.total_sekunder()\n"
"31536000.0"

msgid "Examples of :class:`timedelta` arithmetic::"
msgstr "Exempel på aritmetik för :class:`timedelta`::"

msgid ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"
msgstr ""
">>> from datetime import timedelta\n"
">>> year = timedelta(days=365)\n"
">>> ten_years = 10 * year\n"
">>> ten_years\n"
"datetime.timedelta(days=3650)\n"
">>> ten_years.days // 365\n"
"10\n"
">>> nine_years = ten_years - year\n"
">>> nine_years\n"
"datetime.timedelta(days=3285)\n"
">>> three_years = nine_years // 3\n"
">>> three_years, three_years.days // 365\n"
"(datetime.timedelta(days=1095), 3)"

msgid ":class:`date` Objects"
msgstr ":class:`datum` Objekt"

msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended in "
"both directions."
msgstr ""
"Ett :class:`date`-objekt representerar ett datum (år, månad och dag) i en "
"idealiserad kalender, den nuvarande gregorianska kalendern som är obegränsat "
"förlängd i båda riktningarna."

msgid ""
"January 1 of year 1 is called day number 1, January 2 of year 1 is called "
"day number 2, and so on. [#]_"
msgstr ""
"Den 1 januari år 1 kallas dag nummer 1, den 2 januari år 1 kallas dag nummer "
"2, och så vidare. [#]_"

msgid ""
"All arguments are required. Arguments must be integers, in the following "
"ranges:"
msgstr ""
"Alla argument är obligatoriska. Argumenten måste vara heltal inom följande "
"intervall:"

msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr "``MINYEAR <= år <= MAXYEAR``"

msgid "``1 <= month <= 12``"
msgstr "``1 <= månad <= 12```"

msgid "``1 <= day <= number of days in the given month and year``"
msgstr "``1 <= dag <= antal dagar i den angivna månaden och året``"

msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr ""
"Om ett argument utanför dessa intervall anges, kommer :exc:`ValueError` att "
"tas upp."

msgid "Other constructors, all class methods:"
msgstr "Övriga konstruktörer, alla klassmetoder:"

msgid "Return the current local date."
msgstr "Returnera aktuellt lokalt datum."

msgid "This is equivalent to ``date.fromtimestamp(time.time())``."
msgstr "Detta är likvärdigt med ``date.fromtimestamp(time.time())``."

msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`."
msgstr ""
"Returnerar det lokala datumet som motsvarar POSIX-tidstämpeln, såsom det "
"returneras av :func:`time.time`."

msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`localtime` function, and :exc:"
"`OSError` on :c:func:`localtime` failure. It's common for this to be "
"restricted to years from 1970 through 2038. Note that on non-POSIX systems "
"that include leap seconds in their notion of a timestamp, leap seconds are "
"ignored by :meth:`fromtimestamp`."
msgstr ""
"Detta kan ge upphov till :exc:`OverflowError`, om tidsstämpeln ligger "
"utanför det värdeintervall som stöds av plattform C :c:func:`localtime`-"
"funktionen, och :exc:`OSError` om :c:func:`localtime` misslyckas. Det är "
"vanligt att detta begränsas till år från 1970 till 2038. Observera att på "
"icke-POSIX-system som inkluderar skottsekunder i sin uppfattning om en "
"tidsstämpel, ignoreras skottsekunder av :meth:`fromtimestamp`."

msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`localtime` failure."
msgstr ""
"Utlös :exc:`OverflowError` istället för :exc:`ValueError` om tidsstämpeln "
"ligger utanför det värdeintervall som stöds av plattform C :c:func:"
"`localtime`-funktionen. Skapa :exc:`OSError` istället för :exc:`ValueError` "
"om :c:func:`localtime` misslyckas."

msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1."
msgstr ""
"Returnera datumet som motsvarar den proleptiska gregorianska ordinalen, där "
"1 januari år 1 har ordinal 1."

msgid ""
":exc:`ValueError` is raised unless ``1 <= ordinal <= date.max.toordinal()``. "
"For any date ``d``, ``date.fromordinal(d.toordinal()) == d``."
msgstr ""
":exc:`ValueError` uppstår om inte ``1 <= ordinal <= date.max.toordinal()``. "
"För varje datum ``d``, ``date.fromordinal(d.toordinal()) == d``."

msgid ""
"Return a :class:`date` corresponding to a *date_string* given in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Returnerar ett :class:`date` som motsvarar en *date_string* som anges i "
"valfritt giltigt ISO 8601-format, med följande undantag:"

msgid ""
"Reduced precision dates are not currently supported (``YYYY-MM``, ``YYYY``)."
msgstr ""
"Datum med reducerad precision stöds inte för närvarande (``YYYY-MM``, "
"``YYYY``)."

msgid ""
"Extended date representations are not currently supported (``±YYYYYY-MM-"
"DD``)."
msgstr ""
"Utökade datumrepresentationer stöds inte för närvarande (``±YYYYYY-MM-DD``)."

msgid "Ordinal dates are not currently supported (``YYYY-OOO``)."
msgstr "Ordinarie datum stöds inte för närvarande (``YYYY-OOO``)."

msgid "Examples::"
msgstr "Exempel::"

msgid ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"
msgstr ""
">>> from datetime import date\n"
">>> date.fromisoformat('2019-12-04')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('20191204')\n"
"datetime.date(2019, 12, 4)\n"
">>> date.fromisoformat('2021-W01-1')\n"
"datetime.date(2021, 1, 4)"

msgid "Previously, this method only supported the format ``YYYY-MM-DD``."
msgstr "Tidigare stödde denna metod endast formatet \"YYYYY-MM-DD\"."

msgid ""
"Return a :class:`date` corresponding to the ISO calendar date specified by "
"year, week and day. This is the inverse of the function :meth:`date."
"isocalendar`."
msgstr ""
"Returnerar ett :class:`date` som motsvarar det ISO-kalenderdatum som anges "
"med år, vecka och dag. Detta är inversen av funktionen :meth:`date."
"isocalendar`."

msgid ""
"Return a :class:`.date` corresponding to *date_string*, parsed according to "
"*format*. This is equivalent to::"
msgstr ""
"Returnerar en :class:`.date` som motsvarar *date_string*, tolkad enligt "
"*format*. Detta är likvärdigt med::"

msgid "date(*(time.strptime(date_string, format)[0:3]))"
msgstr "date(*(time.strptime(date_string, format)[0:3]))"

msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed "
"by :func:`time.strptime` or if it returns a value which isn't a time tuple.  "
"See also :ref:`strftime-strptime-behavior` and :meth:`date.fromisoformat`."
msgstr ""
":exc:`ValueError` uppstår om datumsträngen och formatet inte kan tolkas av :"
"func:`time.strptime` eller om det returnerar ett värde som inte är en "
"tidstupel.  Se även :ref:`strftime-strptime-behavior` och :meth:`date."
"fromisoformat`."

msgid ""
"If *format* specifies a day of month without a year a :exc:"
"`DeprecationWarning` is emitted.  This is to avoid a quadrennial leap year "
"bug in code seeking to parse only a month and day as the default year used "
"in absence of one in the format is not a leap year. Such *format* values may "
"raise an error as of Python 3.15.  The workaround is to always include a "
"year in your *format*.  If parsing *date_string* values that do not have a "
"year, explicitly add a year that is a leap year before parsing:"
msgstr ""
"Om *format* anger en dag eller månad utan årtal kommer en :exc:"
"`DeprecationWarning` att skickas ut.  Detta för att undvika en bugg för "
"skottår i kod som försöker tolka endast en månad och dag eftersom "
"standardåret som används om det inte finns något i formatet inte är ett "
"skottår. Sådana *format*-värden kan ge upphov till ett fel från och med "
"Python 3.15.  Lösningen är att alltid inkludera ett år i ditt *format*.  Om "
"du analyserar *date_string*-värden som inte har ett år, lägg uttryckligen "
"till ett år som är ett skottår innan du analyserar:"

msgid ""
">>> from datetime import date\n"
">>> date_string = \"02/29\"\n"
">>> when = date.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # Avoids "
"leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"
msgstr ""
">>> from datetime import date\n"
">>> date_string = \"02/29\"\n"
">>> when = date.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # Avoids "
"leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"

msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr "Det tidigaste representerbara datumet, ``date(MINYEAR, 1, 1)``."

msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr "Det senaste representerbara datumet, ``date(MAXYEAR, 12, 31)``."

msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr ""
"Den minsta möjliga skillnaden mellan datumobjekt som inte är lika, "
"``timedelta(days=1)``."

msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr "Mellan :const:`MINYEAR` och :const:`MAXYEAR` inklusive."

msgid "Between 1 and 12 inclusive."
msgstr "Mellan 1 och 12 inklusive."

msgid "Between 1 and the number of days in the given month of the given year."
msgstr "Mellan 1 och antalet dagar i den givna månaden i det givna året."

msgid "``date2 = date1 + timedelta``"
msgstr "``datum2 = datum1 + timedelta``"

msgid "``date2`` will be ``timedelta.days`` days after ``date1``. (1)"
msgstr ""
"``datum2`` kommer att vara ``timedelta.days`` dagar efter ``datum1``. (1)"

msgid "``date2 = date1 - timedelta``"
msgstr "``datum2 = datum1 - timedelta``"

msgid "Computes ``date2`` such that ``date2 + timedelta == date1``. (2)"
msgstr "Beräknar ``date2`` så att ``date2 + timedelta == date1``. (2)"

msgid "``timedelta = date1 - date2``"
msgstr "``timedelta = datum1 - datum2``"

msgid "\\(3)"
msgstr "\\(3)"

msgid "``date1 == date2``"
msgstr "``datum1 == datum2``"

msgid "``date1 != date2``"
msgstr "``datum1 != datum2``"

msgid "Equality comparison. (4)"
msgstr "Jämförelse av jämlikhet. (4)"

msgid "``date1 < date2``"
msgstr "``datum1 < datum2``"

msgid "``date1 > date2``"
msgstr "``datum1 > datum2``"

msgid "``date1 <= date2``"
msgstr "``datum1 <= datum2``"

msgid "``date1 >= date2``"
msgstr "``datum1 >= datum2``"

msgid "Order comparison. (5)"
msgstr "Jämförelse av order. (5)"

msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``. Afterward ``date2 - date1 == timedelta.days``. "
"``timedelta.seconds`` and ``timedelta.microseconds`` are ignored. :exc:"
"`OverflowError` is raised if ``date2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""
"*date2* flyttas framåt i tiden om ``timedelta.days > 0``, eller bakåt om "
"``timedelta.days < 0``. Därefter ``date2 - date1 == timedelta.days``. "
"``timedelta.seconds`` och ``timedelta.microseconds`` ignoreras. :exc:"
"`OverflowError`` uppstår om ``date2.year`` skulle vara mindre än :const:"
"`MINYEAR`` eller större än :const:`MAXYEAR`."

msgid "``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr "``timedelta.seconds`` och ``timedelta.microseconds`` ignoreras."

msgid ""
"This is exact, and cannot overflow. ``timedelta.seconds`` and ``timedelta."
"microseconds`` are 0, and ``date2 + timedelta == date1`` after."
msgstr ""
"Detta är exakt och kan inte överskridas. ``timedelta.seconds`` och "
"``timedelta.microseconds`` är 0, och ``date2 + timedelta == date1`` efter."

msgid ":class:`date` objects are equal if they represent the same date."
msgstr ":class:`date`-objekt är lika om de representerar samma datum."

msgid ""
":class:`!date` objects that are not also :class:`.datetime` instances are "
"never equal to :class:`!datetime` objects, even if they represent the same "
"date."
msgstr ""
":class:`!date`-objekt som inte också är :class:`.datetime`-instanser är "
"aldrig lika med :class:`!datetime`-objekt, även om de representerar samma "
"datum."

msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. In other words, ``date1 < date2`` if and only if ``date1.toordinal() < "
"date2.toordinal()``."
msgstr ""
"*date1* anses vara mindre än *date2* när *date1* föregår *date2* i tid. Med "
"andra ord, ``datum1 < datum2`` om och endast om ``datum1.toordinal() < "
"datum2.toordinal()``."

msgid ""
"Order comparison between a :class:`!date` object that is not also a :class:`."
"datetime` instance and a :class:`!datetime` object raises :exc:`TypeError`."
msgstr ""
"Orderjämförelse mellan ett :class:`!date`-objekt som inte också är en :class:"
"`.datetime`-instans och ett :class:`!datetime`-objekt ger upphov till :exc:"
"`TypeError`."

msgid ""
"Comparison between :class:`.datetime` object and an instance of the :class:"
"`date` subclass that is not a :class:`!datetime` subclass no longer converts "
"the latter to :class:`!date`, ignoring the time part and the time zone. The "
"default behavior can be changed by overriding the special comparison methods "
"in subclasses."
msgstr ""
"Jämförelse mellan :class:`.datetime`-objekt och en instans av underklassen :"
"class:`date` som inte är en underklass till :class:`!datetime` konverterar "
"inte längre den senare till :class:`!date`, utan att ta hänsyn till "
"tidsdelen och tidszonen. Standardbeteendet kan ändras genom att åsidosätta "
"de speciella jämförelsemetoderna i underklasser."

msgid ""
"In Boolean contexts, all :class:`date` objects are considered to be true."
msgstr "I booleska kontexter anses alla :class:`date`-objekt vara sanna."

msgid ""
"Return a new :class:`date` object with the same values, but with specified "
"parameters updated."
msgstr ""
"Returnerar ett nytt :class:`date`-objekt med samma värden, men med angivna "
"parametrar uppdaterade."

msgid "Example::"
msgstr "Exempel::"

msgid ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"
msgstr ""
">>> from datetime import date\n"
">>> d = date(2002, 12, 31)\n"
">>> d.replace(day=26)\n"
"datetime.date(2002, 12, 26)"

msgid ""
"The generic function :func:`copy.replace` also supports :class:`date` "
"objects."
msgstr ""
"Den generiska funktionen :func:`copy.replace` stöder även :class:`date`-"
"objekt."

msgid ""
"Return a :class:`time.struct_time` such as returned by :func:`time."
"localtime`."
msgstr ""
"Returnerar en :class:`time.struct_time` såsom den som returneras av :func:"
"`time.localtime`."

msgid "The hours, minutes and seconds are 0, and the DST flag is -1."
msgstr "Timmar, minuter och sekunder är 0 och DST-flaggan är -1."

msgid "``d.timetuple()`` is equivalent to::"
msgstr "``d.timetuple()`` är likvärdigt med::"

msgid ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))"
msgstr ""
"time.struct_time((d.year, d.month, d.day, 0, 0, 0, 0, d.weekday(), yday, -1))"

msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st."
msgstr ""
"där ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` är "
"dagsnumret inom det aktuella året med början med 1 för 1 januari."

msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of year "
"1 has ordinal 1. For any :class:`date` object ``d``, ``date.fromordinal(d."
"toordinal()) == d``."
msgstr ""
"Returnerar den proleptiska gregorianska ordinalen för datumet, där 1 januari "
"år 1 har ordinal 1. För varje :class:`date`-objekt ``d``, ``date."
"fromordinal(d.toordinal()) == d``."

msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See also :"
"meth:`isoweekday`."
msgstr ""
"Returnerar veckodagen som ett heltal, där måndag är 0 och söndag är 6. Till "
"exempel, ``date(2002, 12, 4).weekday() == 2``, en onsdag. Se även :meth:"
"`isoweekday`."

msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. See also :"
"meth:`weekday`, :meth:`isocalendar`."
msgstr ""
"Returnerar veckodagen som ett heltal, där måndag är 1 och söndag är 7. Till "
"exempel, ``date(2002, 12, 4).isoweekday() == 3``, en onsdag. Se även :meth:"
"`weekday`, :meth:`isocalendar`."

msgid ""
"Return a :term:`named tuple` object with three components: ``year``, "
"``week`` and ``weekday``."
msgstr ""
"Returnerar ett :term:`named tuple`-objekt med tre komponenter: ``år``, "
"``vecka`` och ``veckodag``."

msgid ""
"The ISO calendar is a widely used variant of the Gregorian calendar. [#]_"
msgstr ""
"ISO-kalendern är en allmänt använd variant av den gregorianska kalendern. "
"[#]_"

msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on a "
"Monday and ends on a Sunday. The first week of an ISO year is the first "
"(Gregorian) calendar week of a year containing a Thursday. This is called "
"week number 1, and the ISO year of that Thursday is the same as its "
"Gregorian year."
msgstr ""
"ISO-året består av 52 eller 53 hela veckor, och där en vecka börjar på en "
"måndag och slutar på en söndag. Den första veckan i ett ISO-år är den första "
"(gregorianska) kalenderveckan i ett år som innehåller en torsdag. Detta "
"kallas vecka nummer 1, och ISO-året för den torsdagen är detsamma som dess "
"gregorianska år."

msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year 2004 "
"begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004::"
msgstr ""
"Till exempel börjar 2004 på en torsdag, så den första veckan i ISO-året 2004 "
"börjar måndagen den 29 december 2003 och slutar söndagen den 4 januari 2004:"

msgid ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"
msgstr ""
">>> from datetime import date\n"
">>> date(2003, 12, 29).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=1)\n"
">>> date(2004, 1, 4).isocalendar()\n"
"datetime.IsoCalendarDate(year=2004, week=1, weekday=7)"

msgid "Result changed from a tuple to a :term:`named tuple`."
msgstr "Resultatet ändrades från en tuple till en :term:`named tuple`."

msgid ""
"Return a string representing the date in ISO 8601 format, ``YYYY-MM-DD``::"
msgstr ""
"Returnerar en sträng som representerar datumet i ISO 8601-format, ``YYYY-MM-"
"DD``::"

msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).isoformat()\n"
"'2002-12-04'"

msgid "For a date ``d``, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr "För ett datum ``d`` är ``str(d)`` likvärdigt med ``d.isoformat()``."

msgid "Return a string representing the date::"
msgstr "Returnerar en sträng som representerar datumet::"

msgid ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"
msgstr ""
">>> from datetime import date\n"
">>> date(2002, 12, 4).ctime()\n"
"'Wed Dec  4 00:00:00 2002'"

msgid "``d.ctime()`` is equivalent to::"
msgstr "``d.ctime()`` är likvärdigt med::"

msgid "time.ctime(time.mktime(d.timetuple()))"
msgstr "time.ctime(time.mktime(d.timetuple()))"

msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`date.ctime` does not invoke) conforms to "
"the C standard."
msgstr ""
"på plattformar där den inbyggda C-funktionen :c:func:`ctime` (som :func:"
"`time.ctime` åberopar, men som :meth:`date.ctime` inte åberopar) "
"överensstämmer med C-standarden."

msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. See also :ref:`strftime-strptime-behavior` and :meth:`date."
"isoformat`."
msgstr ""
"Returnerar en sträng som representerar datumet, styrd av en explicit "
"formatsträng. Formatkoder som hänvisar till timmar, minuter eller sekunder "
"får 0 värden. Se även :ref:`strftime-strptime-behavior` och :meth:`date."
"isoformat`."

msgid ""
"Same as :meth:`.date.strftime`. This makes it possible to specify a format "
"string for a :class:`.date` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`date.isoformat`."
msgstr ""
"Samma som :meth:`.date.strftime`. Detta gör det möjligt att ange en "
"formatsträng för ett :class:`.date`-objekt i :ref:``formatted string "
"literals <f-strings>`` och när man använder :meth:`str.format`. Se även :ref:"
"`strftime-strptime-behavior` och :meth:`date.isoformat`."

msgid "Examples of Usage: :class:`date`"
msgstr "Exempel på användning: :class:`date`"

msgid "Example of counting days to an event::"
msgstr "Exempel på att räkna dagar till en händelse::"

msgid ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"
msgstr ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
"...\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"

msgid "More examples of working with :class:`date`:"
msgstr "Fler exempel på att arbeta med :class:`date`:"

msgid ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Methods related to formatting string output\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'\n"
">>> d.ctime()\n"
"'Mon Mar 11 00:00:00 2002'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\")\n"
"'The day is 11, the month is March.'\n"
"\n"
">>> # Methods for to extracting 'components' under different calendars\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:\n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
"\n"
">>> # A date object is immutable; all operations produce a new object\n"
">>> d.replace(year=2005)\n"
"datetime.date(2005, 3, 11)"
msgstr ""
">>> from datetime import datum\n"
">>> d = date.fromordinal(730920) # 730920:e dagen efter 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
"\n"
">>> # Metoder relaterade till formatering av strängutmatning\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"\"Måndag 11. Mars 2002'\n"
">>> d.ctime()\n"
"'Mån Mar 11 00:00:00 2002'\n"
">>> '{1} är {0:%d}, {2} är {0:%B}.'.format(d, \"dag\", \"månad\")\n"
"\"Dagen är 11, månaden är mars\n"
"\n"
">>> # Metoder för att extrahera \"komponenter\" under olika kalendrar\n"
">>> t = d.timetuple()\n"
">>> for i in t:\n"
"... print(i)\n"
"2002 # år\n"
"3 # månad\n"
"11 # dag\n"
"0\n"
"0\n"
"0\n"
"0 # veckodag (0 = måndag)\n"
"70 # 70:e dagen på året\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> för i i ic:\n"
"... print(i)\n"
"2002 # ISO-år\n"
"11 # ISO veckonummer\n"
"1 # ISO dagnummer ( 1 = måndag )\n"
"\n"
">>> # Ett datumobjekt är oföränderligt; alla operationer producerar ett nytt "
"objekt\n"
">>> d.replace(år=2005)\n"
"datetime.datum(2005, 3, 11)"

msgid ":class:`.datetime` Objects"
msgstr ":class:`.datetime` Objekt"

msgid ""
"A :class:`.datetime` object is a single object containing all the "
"information from a :class:`date` object and a :class:`.time` object."
msgstr ""
"Ett :class:`.datetime`-objekt är ett enda objekt som innehåller all "
"information från ett :class:`date`-objekt och ett :class:`.time`-objekt."

msgid ""
"Like a :class:`date` object, :class:`.datetime` assumes the current "
"Gregorian calendar extended in both directions; like a :class:`.time` "
"object, :class:`.datetime` assumes there are exactly 3600\\*24 seconds in "
"every day."
msgstr ""
"Liksom ett :class:`date`-objekt förutsätter :class:`.datetime` att den "
"aktuella gregorianska kalendern är förlängd i båda riktningarna; liksom ett :"
"class:`.time`-objekt förutsätter :class:`.datetime` att det finns exakt "
"3600\\*24 sekunder varje dag."

msgid "Constructor:"
msgstr "Konstruktör:"

msgid ""
"The *year*, *month* and *day* arguments are required. *tzinfo* may be "
"``None``, or an instance of a :class:`tzinfo` subclass. The remaining "
"arguments must be integers in the following ranges:"
msgstr ""
"Argumenten *year*, *month* och *day* är obligatoriska. *tzinfo* kan vara "
"``None``, eller en instans av en :class:`tzinfo`-underklass. De återstående "
"argumenten måste vara heltal inom följande intervall:"

msgid "``MINYEAR <= year <= MAXYEAR``,"
msgstr "``MINYEAR <= år <= MAXYEAR``,"

msgid "``1 <= month <= 12``,"
msgstr "``1 <= månad <= 12``,"

msgid "``1 <= day <= number of days in the given month and year``,"
msgstr "``1 <= dag <= antal dagar i den angivna månaden och året``,"

msgid "``0 <= hour < 24``,"
msgstr "``0 <= timme < 24``,"

msgid "``0 <= minute < 60``,"
msgstr "``0 <= minut < 60``,"

msgid "``0 <= second < 60``,"
msgstr "``0 <= sekund < 60``,"

msgid "``0 <= microsecond < 1000000``,"
msgstr "``0 <= mikrosekund < 1000000``,"

msgid "``fold in [0, 1]``."
msgstr "``veck i [0, 1]``."

msgid "Added the *fold* parameter."
msgstr "Lagt till parametern *fold*."

msgid "Return the current local date and time, with :attr:`.tzinfo` ``None``."
msgstr ""
"Returnerar aktuellt lokalt datum och tid, med :attr:`.tzinfo` ``None``."

msgid "Equivalent to::"
msgstr "Motsvarar::"

msgid "datetime.fromtimestamp(time.time())"
msgstr "datetime.fromtimestamp(time.time())"

msgid "See also :meth:`now`, :meth:`fromtimestamp`."
msgstr "Se även :meth:`now`, :meth:`fromtimestamp`."

msgid ""
"This method is functionally equivalent to :meth:`now`, but without a ``tz`` "
"parameter."
msgstr ""
"Denna metod är funktionellt likvärdig med :meth:`now`, men utan parametern "
"``tz``."

msgid "Return the current local date and time."
msgstr "Återge aktuellt lokalt datum och lokal tid."

msgid ""
"If optional argument *tz* is ``None`` or not specified, this is like :meth:"
"`today`, but, if possible, supplies more precision than can be gotten from "
"going through a :func:`time.time` timestamp (for example, this may be "
"possible on platforms supplying the C :c:func:`gettimeofday` function)."
msgstr ""
"Om det valfria argumentet *tz* är ``None`` eller inte anges, är detta som :"
"meth:`today`, men ger om möjligt mer precision än vad som kan erhållas genom "
"att gå igenom en :func:`time.time`-tidsstämpel (detta kan till exempel vara "
"möjligt på plattformar som tillhandahåller C :c:func:`gettimeofday`-"
"funktionen)."

msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the current date and time are converted to *tz*’s time zone."
msgstr ""
"Om *tz* inte är ``None`` måste det vara en instans av en :class:`tzinfo`-"
"underklass, och aktuellt datum och aktuell tid konverteras till *tz*:s "
"tidszon."

msgid "This function is preferred over :meth:`today` and :meth:`utcnow`."
msgstr ""
"Denna funktion är att föredra framför :meth:`today` och :meth:`utcnow`."

msgid ""
"Subsequent calls to :meth:`!datetime.now` may return the same instant "
"depending on the precision of the underlying clock."
msgstr ""
"Efterföljande anrop till :meth:`!datetime.now` kan returnera samma ögonblick "
"beroende på precisionen i den underliggande klockan."

msgid "Return the current UTC date and time, with :attr:`.tzinfo` ``None``."
msgstr ""
"Returnerar aktuellt UTC-datum och UTC-tid, med :attr:`.tzinfo` ``None``."

msgid ""
"This is like :meth:`now`, but returns the current UTC date and time, as a "
"naive :class:`.datetime` object. An aware current UTC datetime can be "
"obtained by calling ``datetime.now(timezone.utc)``. See also :meth:`now`."
msgstr ""
"Detta är som :meth:`now`, men returnerar aktuellt UTC-datum och tid, som ett "
"naivt :class:`.datetime`-objekt. En medveten aktuell UTC-datatid kan "
"erhållas genom att anropa ``datetime.now(timezone.utc)``. Se även :meth:"
"`now`."

msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing the "
"current time in UTC is by calling ``datetime.now(timezone.utc)``."
msgstr ""
"Eftersom naiva ``datetime``-objekt behandlas av många ``datetime``-metoder "
"som lokala tider, är det att föredra att använda medvetna datatider för att "
"representera tider i UTC. Det rekommenderade sättet att skapa ett objekt som "
"representerar den aktuella tiden i UTC är därför att anropa ``datetime."
"now(timezone.utc)``."

msgid "Use :meth:`datetime.now` with :const:`UTC` instead."
msgstr "Använd :meth:`datetime.now` med :const:`UTC` istället."

msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such as "
"is returned by :func:`time.time`. If optional argument *tz* is ``None`` or "
"not specified, the timestamp is converted to the platform's local date and "
"time, and the returned :class:`.datetime` object is naive."
msgstr ""
"Returnerar det lokala datumet och tiden som motsvarar POSIX-tidstämpeln, "
"såsom den returneras av :func:`time.time`. Om det valfria argumentet *tz* är "
"``None`` eller inte anges, konverteras tidsmarkören till plattformens lokala "
"datum och tid och det returnerade :class:`.datetime`-objektet är naivt."

msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the timestamp is converted to *tz*’s time zone."
msgstr ""
"Om *tz* inte är ``None`` måste det vara en instans av en :class:`tzinfo`-"
"underklass, och tidsstämpeln konverteras till *tz*:s tidszon."

msgid ""
":meth:`fromtimestamp` may raise :exc:`OverflowError`, if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions, and :exc:`OSError` on :c:func:`localtime` or :"
"c:func:`gmtime` failure. It's common for this to be restricted to years in "
"1970 through 2038. Note that on non-POSIX systems that include leap seconds "
"in their notion of a timestamp, leap seconds are ignored by :meth:"
"`fromtimestamp`, and then it's possible to have two timestamps differing by "
"a second that yield identical :class:`.datetime` objects. This method is "
"preferred over :meth:`utcfromtimestamp`."
msgstr ""
":meth:`fromtimestamp` kan ge upphov till :exc:`OverflowError`, om "
"tidsstämpeln är utanför det värdeintervall som stöds av plattformens C-"
"funktioner :c:func:`localtime` eller :c:func:`gmtime`, och :exc:`OSError` "
"om :c:func:`localtime` eller :c:func:`gmtime` misslyckas. Det är vanligt att "
"detta begränsas till år 1970 till och med 2038. Observera att på icke-POSIX-"
"system som inkluderar skottsekunder i sin uppfattning av en tidsstämpel, "
"ignoreras skottsekunder av :meth:`fromtimestamp`, och då är det möjligt att "
"ha två tidsstämplar som skiljer sig med en sekund som ger identiska :class:`."
"datetime`-objekt. Denna metod är att föredra framför :meth:"
"`utcfromtimestamp`."

msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`localtime` "
"or :c:func:`gmtime` functions. Raise :exc:`OSError` instead of :exc:"
"`ValueError` on :c:func:`localtime` or :c:func:`gmtime` failure."
msgstr ""
"Skapa :exc:`OverflowError` istället för :exc:`ValueError` om tidsstämpeln "
"ligger utanför det värdeintervall som stöds av plattform C-funktionerna :c:"
"func:`localtime` eller :c:func:`gmtime`. Skapa :exc:`OSError` istället för :"
"exc:`ValueError` om :c:func:`localtime` eller :c:func:`gmtime` misslyckas."

msgid ":meth:`fromtimestamp` may return instances with :attr:`.fold` set to 1."
msgstr ""
":meth:`fromtimestamp` kan returnera instanser med :attr:`.fold` satt till 1."

msgid ""
"Return the UTC :class:`.datetime` corresponding to the POSIX timestamp, "
"with :attr:`.tzinfo` ``None``.  (The resulting object is naive.)"
msgstr ""
"Returnerar UTC :class:`.datetime` motsvarande POSIX-tidsstämpeln, med :attr:"
"`.tzinfo` ``None``.  (Det resulterande objektet är naivt.)"

msgid ""
"This may raise :exc:`OverflowError`, if the timestamp is out of the range of "
"values supported by the platform C :c:func:`gmtime` function, and :exc:"
"`OSError` on :c:func:`gmtime` failure. It's common for this to be restricted "
"to years in 1970 through 2038."
msgstr ""
"Detta kan ge upphov till :exc:`OverflowError`, om tidsstämpeln ligger "
"utanför det värdeintervall som stöds av plattform C :c:func:`gmtime`-"
"funktionen, och :exc:`OSError` om :c:func:`gmtime` misslyckas. Det är "
"vanligt att detta är begränsat till år 1970 till 2038."

msgid "To get an aware :class:`.datetime` object, call :meth:`fromtimestamp`::"
msgstr ""
"För att få ett medvetet :class:`.datetime`-objekt, anropa :meth:"
"`fromtimestamp`::"

msgid "datetime.fromtimestamp(timestamp, timezone.utc)"
msgstr "datetime.fromtimestamp(timestamp, tidszon.utc)"

msgid ""
"On the POSIX compliant platforms, it is equivalent to the following "
"expression::"
msgstr ""
"På POSIX-kompatibla plattformar är det likvärdigt med följande uttryck::"

msgid ""
"datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)"
msgstr ""
"datetime(1970, 1, 1, tzinfo=tidszon.utc) + timedelta(sekunder=tidstämpel)"

msgid ""
"except the latter formula always supports the full years range: between :"
"const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ""
"förutom att den senare formeln alltid stöder hela årsintervallet: mellan :"
"const:`MINYEAR` och :const:`MAXYEAR` inklusive."

msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC. As such, the recommended way to create an object representing a "
"specific timestamp in UTC is by calling ``datetime.fromtimestamp(timestamp, "
"tz=timezone.utc)``."
msgstr ""
"Eftersom naiva ``datetime``-objekt behandlas av många ``datetime``-metoder "
"som lokala tider, är det att föredra att använda medvetna datatider för att "
"representera tider i UTC. Därför är det rekommenderade sättet att skapa ett "
"objekt som representerar en specifik tidsstämpel i UTC att anropa ``datetime."
"fromtimestamp(timestamp, tz=timezone.utc)``."

msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp is "
"out of the range of values supported by the platform C :c:func:`gmtime` "
"function. Raise :exc:`OSError` instead of :exc:`ValueError` on :c:func:"
"`gmtime` failure."
msgstr ""
"Utlös :exc:`OverflowError` istället för :exc:`ValueError` om tidsstämpeln "
"ligger utanför det värdeintervall som stöds av plattform C :c:func:`gmtime`-"
"funktionen. Skapa :exc:`OSError` istället för :exc:`ValueError` om :c:func:"
"`gmtime` misslyckas."

msgid "Use :meth:`datetime.fromtimestamp` with :const:`UTC` instead."
msgstr "Använd :meth:`datetime.fromtimestamp` med :const:`UTC` istället."

msgid ""
"Return the :class:`.datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``. The hour, "
"minute, second and microsecond of the result are all 0, and :attr:`.tzinfo` "
"is ``None``."
msgstr ""
"Returnerar :class:`.datetime` motsvarande den proleptiska gregorianska "
"ordinalen, där 1 januari år 1 har ordinal 1. :exc:`ValueError` uppstår om "
"inte ``1 <= ordinal <= datetime.max.toordinal()``. Timmen, minuten, sekunden "
"och mikrosekunden i resultatet är alla 0, och :attr:`.tzinfo` är ``None``."

msgid ""
"Return a new :class:`.datetime` object whose date components are equal to "
"the given :class:`date` object's, and whose time components are equal to the "
"given :class:`.time` object's. If the *tzinfo* argument is provided, its "
"value is used to set the :attr:`.tzinfo` attribute of the result, otherwise "
"the :attr:`~.time.tzinfo` attribute of the *time* argument is used.  If the "
"*date* argument is a :class:`.datetime` object, its time components and :"
"attr:`.tzinfo` attributes are ignored."
msgstr ""
"Returnerar ett nytt :class:`.datetime`-objekt vars datumkomponenter är lika "
"med det givna :class:`date`-objektets och vars tidskomponenter är lika med "
"det givna :class:`.time`-objektets. Om argumentet *tzinfo* anges används "
"dess värde för att ange attributet :attr:`.tzinfo` för resultatet, annars "
"används attributet :attr:`~.time.tzinfo` för argumentet *time*.  Om *date*-"
"argumentet är ett :class:`.datetime`-objekt ignoreras dess tidskomponenter "
"och :attr:`.tzinfo`-attribut."

msgid ""
"For any :class:`.datetime` object ``d``, ``d == datetime.combine(d.date(), d."
"time(), d.tzinfo)``."
msgstr ""
"För varje :class:`.datetime`-objekt ``d``, ``d == datetime.combine(d.date(), "
"d.time(), d.tzinfo)``."

msgid "Added the *tzinfo* argument."
msgstr "Lagt till argumentet *tzinfo*."

msgid ""
"Return a :class:`.datetime` corresponding to a *date_string* in any valid "
"ISO 8601 format, with the following exceptions:"
msgstr ""
"Returnera en :class:`.datetime` som motsvarar en *date_string* i valfritt "
"giltigt ISO 8601-format, med följande undantag:"

msgid "Time zone offsets may have fractional seconds."
msgstr "Tidszonsförskjutningar kan ha bråkdelar av sekunder."

msgid "The ``T`` separator may be replaced by any single unicode character."
msgstr "Avgränsaren ``T`` kan ersättas med valfritt unicode-tecken."

msgid "Fractional hours and minutes are not supported."
msgstr "Bråkdelar av timmar och minuter stöds inte."

msgid ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone."
"utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.fromisoformat('2011-11-04')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('20111104')\n"
"datetime.datetime(2011, 11, 4, 0, 0)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23Z')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)\n"
">>> datetime.fromisoformat('20111104T000523')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23)\n"
">>> datetime.fromisoformat('2011-W01-2T00:05:23.283')\n"
"datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)\n"
">>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone."
"utc)\n"
">>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')\n"
"datetime.datetime(2011, 11, 4, 0, 5, 23,\n"
"    tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))"

msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`date.isoformat` or :meth:`datetime.isoformat`."
msgstr ""
"Tidigare stödde den här metoden endast format som kunde anges av :meth:`date."
"isoformat` eller :meth:`datetime.isoformat`."

msgid ""
"Return a :class:`.datetime` corresponding to the ISO calendar date specified "
"by year, week and day. The non-date components of the datetime are populated "
"with their normal default values. This is the inverse of the function :meth:"
"`datetime.isocalendar`."
msgstr ""
"Returnerar en :class:`.datetime` som motsvarar ISO-kalenderdatumet "
"specificerat med år, vecka och dag. De komponenter i datetime som inte är "
"datum fylls i med sina normala standardvärden. Detta är inversen av "
"funktionen :meth:`datetime.isocalendar`."

msgid ""
"Return a :class:`.datetime` corresponding to *date_string*, parsed according "
"to *format*."
msgstr ""
"Returnerar en :class:`.datetime` som motsvarar *date_string*, tolkad enligt "
"*format*."

msgid ""
"If *format* does not contain microseconds or time zone information, this is "
"equivalent to::"
msgstr ""
"Om *format* inte innehåller mikrosekunder eller information om tidszon "
"motsvarar detta::"

msgid "datetime(*(time.strptime(date_string, format)[0:6]))"
msgstr "datetime(*(time.strptime(date_string, format)[0:6]))"

msgid ""
":exc:`ValueError` is raised if the date_string and format can't be parsed "
"by :func:`time.strptime` or if it returns a value which isn't a time tuple.  "
"See also :ref:`strftime-strptime-behavior` and :meth:`datetime."
"fromisoformat`."
msgstr ""
":exc:`ValueError` uppstår om datumsträngen och formatet inte kan tolkas av :"
"func:`time.strptime` eller om det returnerar ett värde som inte är en "
"tidstupel.  Se även :ref:`strftime-strptime-behavior` och :meth:`datetime."
"fromisoformat`."

msgid ""
"If *format* specifies a day of month without a year a :exc:"
"`DeprecationWarning` is now emitted.  This is to avoid a quadrennial leap "
"year bug in code seeking to parse only a month and day as the default year "
"used in absence of one in the format is not a leap year. Such *format* "
"values may raise an error as of Python 3.15.  The workaround is to always "
"include a year in your *format*.  If parsing *date_string* values that do "
"not have a year, explicitly add a year that is a leap year before parsing:"
msgstr ""
"Om *format* anger en dag eller månad utan årtal skickas nu en :exc:"
"`DeprecationWarning` ut.  Detta för att undvika en bugg för skottår i kod "
"som försöker tolka endast en månad och dag eftersom standardåret som används "
"om det inte finns något i formatet inte är ett skottår. Sådana *format*-"
"värden kan ge upphov till ett fel från och med Python 3.15.  Lösningen är "
"att alltid inkludera ett år i ditt *format*.  Om du analyserar *date_string*-"
"värden som inte har ett år, lägg uttryckligen till ett år som är ett skottår "
"innan du analyserar:"

msgid ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # "
"Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"
msgstr ""
">>> from datetime import datetime\n"
">>> date_string = \"02/29\"\n"
">>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\")  # "
"Avoids leap year bug.\n"
">>> when.strftime(\"%B %d\")\n"
"'February 29'"

msgid ""
"The earliest representable :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr ""
"Den tidigaste representerbara :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."

msgid ""
"The latest representable :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, 23, "
"59, 59, 999999, tzinfo=None)``."
msgstr ""
"Den senaste representerbara :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, "
"23, 59, 59, 999999, tzinfo=None)``."

msgid ""
"The smallest possible difference between non-equal :class:`.datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"Den minsta möjliga skillnaden mellan icke lika :class:`.datetime`-objekt, "
"``timedelta(microseconds=1)``."

msgid "In ``range(24)``."
msgstr "I ``range(24)``."

msgid "In ``range(60)``."
msgstr "I ``range(60)``."

msgid "In ``range(1000000)``."
msgstr "I ``intervall(1000000)``."

msgid ""
"The object passed as the *tzinfo* argument to the :class:`.datetime` "
"constructor, or ``None`` if none was passed."
msgstr ""
"Det objekt som skickades som *tzinfo*-argument till :class:`.datetime`-"
"konstruktören, eller ``None`` om inget skickades."

msgid ""
"In ``[0, 1]``. Used to disambiguate wall times during a repeated interval. "
"(A repeated interval occurs when clocks are rolled back at the end of "
"daylight saving time or when the UTC offset for the current zone is "
"decreased for political reasons.) The values 0 and 1 represent, "
"respectively, the earlier and later of the two moments with the same wall "
"time representation."
msgstr ""
"I ``[0, 1]``. Används för att särskilja väggtider under ett upprepat "
"intervall. (Ett upprepat intervall inträffar när klockorna ställs tillbaka i "
"slutet av sommartiden eller när UTC-offset för den aktuella zonen minskas av "
"politiska skäl) Värdena 0 och 1 representerar den tidigare respektive den "
"senare av de två tidpunkterna med samma väggtidsrepresentation."

msgid "``datetime2 = datetime1 + timedelta``"
msgstr "``datetime2 = datetime1 + timedelta``"

msgid "\\(1)"
msgstr "\\(1)"

msgid "``datetime2 = datetime1 - timedelta``"
msgstr "``datetime2 = datetime1 - timedelta``"

msgid "\\(2)"
msgstr "\\(2)"

msgid "``timedelta = datetime1 - datetime2``"
msgstr "``timedelta = datetime1 - datetime2``"

msgid "``datetime1 == datetime2``"
msgstr "``datetime1 == datetime2``"

msgid "``datetime1 != datetime2``"
msgstr "``datetime1 != datetime2``"

msgid "``datetime1 < datetime2``"
msgstr "``datetime1 < datetime2``"

msgid "``datetime1 > datetime2``"
msgstr "``datumtid1 > datumtid2``"

msgid "``datetime1 <= datetime2``"
msgstr "``datetime1 <= datetime2``"

msgid "``datetime1 >= datetime2``"
msgstr "``datumtid1 >= datumtid2``"

msgid ""
"``datetime2`` is a duration of ``timedelta`` removed from ``datetime1``, "
"moving forward in time if ``timedelta.days > 0``, or backward if ``timedelta."
"days < 0``. The result has the same :attr:`~.datetime.tzinfo` attribute as "
"the input datetime, and ``datetime2 - datetime1 == timedelta`` after. :exc:"
"`OverflowError` is raised if ``datetime2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`. Note that no time zone "
"adjustments are done even if the input is an aware object."
msgstr ""
"``datetime2`` är en varaktighet av ``timedelta`` borttagen från "
"``datetime1``, som rör sig framåt i tiden om ``timedelta.days > 0``, eller "
"bakåt om ``timedelta.days < 0``. Resultatet har samma :attr:`~.datetime."
"tzinfo`-attribut som den ingående datatiden, och ``datetime2 - datetime1 == "
"timedelta`` efter. :exc:`OverflowError` uppstår om ``datetime2.year`` skulle "
"vara mindre än :const:`MINYEAR`` eller större än :const:`MAXYEAR``. "
"Observera att inga tidszonsjusteringar görs även om indata är ett aware-"
"objekt."

msgid ""
"Computes the ``datetime2`` such that ``datetime2 + timedelta == datetime1``. "
"As for addition, the result has the same :attr:`~.datetime.tzinfo` attribute "
"as the input datetime, and no time zone adjustments are done even if the "
"input is aware."
msgstr ""
"Beräknar ``datetime2`` så att ``datetime2 + timedelta == datetime1``. När "
"det gäller tillägg har resultatet samma :attr:`~.datetime.tzinfo`-attribut "
"som den ingående datatiden, och inga tidszonjusteringar görs även om den "
"ingående datatiden är medveten."

msgid ""
"Subtraction of a :class:`.datetime` from a :class:`.datetime` is defined "
"only if both operands are naive, or if both are aware. If one is aware and "
"the other is naive, :exc:`TypeError` is raised."
msgstr ""
"Subtraktion av en :class:`.datetime` från en :class:`.datetime` definieras "
"endast om båda operanderna är naiva, eller om båda är medvetna. Om en är "
"medveten och den andra är naiv, uppstår :exc:`TypeError`."

msgid ""
"If both are naive, or both are aware and have the same :attr:`~.datetime."
"tzinfo` attribute, the :attr:`~.datetime.tzinfo` attributes are ignored, and "
"the result is a :class:`timedelta` object ``t`` such that ``datetime2 + t == "
"datetime1``. No time zone adjustments are done in this case."
msgstr ""
"Om båda är naiva, eller båda är medvetna och har samma :attr:`~.datetime."
"tzinfo`-attribut, ignoreras :attr:`~.datetime.tzinfo`-attributen och "
"resultatet är ett :class:`timedelta`-objekt ``t`` så att ``datetime2 + t == "
"datetime1``. Inga tidszonjusteringar görs i det här fallet."

msgid ""
"If both are aware and have different :attr:`~.datetime.tzinfo` attributes, "
"``a-b`` acts as if ``a`` and ``b`` were first converted to naive UTC "
"datetimes. The result is ``(a.replace(tzinfo=None) - a.utcoffset()) - (b."
"replace(tzinfo=None) - b.utcoffset())`` except that the implementation never "
"overflows."
msgstr ""
"Om båda är medvetna och har olika :attr:`~.datetime.tzinfo`-attribut, "
"fungerar ``a-b`` som om ``a`` och ``b`` först konverterades till naiva UTC-"
"datatider. Resultatet är ``(a.replace(tzinfo=None) - a.utcoffset()) - (b."
"replace(tzinfo=None) - b.utcoffset())`` förutom att implementationen aldrig "
"överflödar."

msgid ""
":class:`.datetime` objects are equal if they represent the same date and "
"time, taking into account the time zone."
msgstr ""
":class:`.datetime`-objekt är lika om de representerar samma datum och tid, "
"med hänsyn tagen till tidszonen."

msgid "Naive and aware :class:`!datetime` objects are never equal."
msgstr "Naivt och medvetet :class:`!datetime`-objekt är aldrig lika."

msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows. :class:`!datetime` instances in a repeated "
"interval are never equal to :class:`!datetime` instances in other time zone."
msgstr ""
"Om båda jämförelseobjekten är medvetna och har samma attribut :attr:`!"
"tzinfo`, ignoreras attributen :attr:`!tzinfo` och :attr:`~.datetime.fold` "
"och basdatumen jämförs. Om båda jämförelseobjekten är medvetna och har "
"olika :attr:`~.datetime.tzinfo`-attribut, fungerar jämförelsen som om "
"jämförelseobjekten först konverterades till UTC-datatider, förutom att "
"implementationen aldrig överflödar. :class:`!datetime`-instanser i ett "
"upprepat intervall är aldrig lika med :class:`!datetime`-instanser i en "
"annan tidszon."

msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes "
"*datetime2* in time, taking into account the time zone."
msgstr ""
"*datetime1* anses vara kortare än *datetime2* när *datetime1* föregår "
"*datetime2* i tid, med hänsyn tagen till tidszonen."

msgid ""
"Order comparison between naive and aware :class:`.datetime` objects raises :"
"exc:`TypeError`."
msgstr ""
"Orderjämförelse mellan naiva och medvetna :class:`.datetime`-objekt ger "
"upphov till :exc:`TypeError`."

msgid ""
"If both comparands are aware, and have the same :attr:`!tzinfo` attribute, "
"the :attr:`!tzinfo` and :attr:`~.datetime.fold` attributes are ignored and "
"the base datetimes are compared. If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparison acts as "
"comparands were first converted to UTC datetimes except that the "
"implementation never overflows."
msgstr ""
"Om båda jämförelseobjekten är medvetna och har samma attribut :attr:`!"
"tzinfo`, ignoreras attributen :attr:`!tzinfo` och :attr:`~.datetime.fold` "
"och basdatumen jämförs. Om båda jämförelseobjekten är medvetna och har "
"olika :attr:`~.datetime.tzinfo`-attribut, fungerar jämförelsen som om "
"jämförelseobjekten först konverterades till UTC-datatider, förutom att "
"implementationen aldrig överflödar."

msgid ""
"Equality comparisons between aware and naive :class:`.datetime` instances "
"don't raise :exc:`TypeError`."
msgstr ""
"Jämlikhetsjämförelser mellan medvetna och naiva :class:`.datetime`-instanser "
"ger inte upphov till :exc:`TypeError`."

msgid "Return :class:`date` object with same year, month and day."
msgstr "Returnerar :class:`date`-objekt med samma år, månad och dag."

msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond and "
"fold. :attr:`.tzinfo` is ``None``. See also method :meth:`timetz`."
msgstr ""
"Returnerar :class:`.time`-objekt med samma timme, minut, sekund, mikrosekund "
"och vikning. :attr:`.tzinfo` är ``None``. Se även metod :meth:`timetz`."

msgid "The fold value is copied to the returned :class:`.time` object."
msgstr "Fold-värdet kopieras till det returnerade :class:`.time`-objektet."

msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond, "
"fold, and tzinfo attributes. See also method :meth:`time`."
msgstr ""
"Returnerar :class:`.time`-objekt med samma tim-, minut-, sekund-, "
"mikrosekund-, fold- och tzinfo-attribut. Se även metoden :meth:`time`."

msgid ""
"Return a new :class:`datetime` object with the same attributes, but with "
"specified parameters updated. Note that ``tzinfo=None`` can be specified to "
"create a naive datetime from an aware datetime with no conversion of date "
"and time data."
msgstr ""
"Returnerar ett nytt :class:`datetime`-objekt med samma attribut, men med "
"angivna parametrar uppdaterade. Observera att ``tzinfo=None`` kan anges för "
"att skapa en naiv datatid från en medveten datatid utan konvertering av "
"datum- och tidsdata."

msgid ""
":class:`.datetime` objects are also supported by generic function :func:"
"`copy.replace`."
msgstr ""
":class:`.datetime`-objekt stöds också av den generiska funktionen :func:"
"`copy.replace`."

msgid ""
"Return a :class:`.datetime` object with new :attr:`.tzinfo` attribute *tz*, "
"adjusting the date and time data so the result is the same UTC time as "
"*self*, but in *tz*'s local time."
msgstr ""
"Returnerar ett :class:`.datetime`-objekt med det nya :attr:`.tzinfo`-"
"attributet *tz*, som justerar datum- och tidsdata så att resultatet är samma "
"UTC-tid som *self*, men i *tz*:s lokala tid."

msgid ""
"If provided, *tz* must be an instance of a :class:`tzinfo` subclass, and "
"its :meth:`utcoffset` and :meth:`dst` methods must not return ``None``. If "
"*self* is naive, it is presumed to represent time in the system time zone."
msgstr ""
"Om *tz* anges måste den vara en instans av en underklass till :class:"
"`tzinfo`, och dess metoder :meth:`utcoffset` och :meth:`dst` får inte "
"returnera ``None``. Om *self* är naiv, antas den representera tiden i "
"systemets tidszon."

msgid ""
"If called without arguments (or with ``tz=None``) the system local time zone "
"is assumed for the target time zone. The ``.tzinfo`` attribute of the "
"converted datetime instance will be set to an instance of :class:`timezone` "
"with the zone name and offset obtained from the OS."
msgstr ""
"Om den anropas utan argument (eller med ``tz=None``) antas systemets lokala "
"tidszon för måltidszonen. Attributet ``.tzinfo`` för den konverterade "
"datetime-instansen kommer att sättas till en instans av :class:`timezone` "
"med zonnamnet och offset som erhållits från operativsystemet."

msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  no "
"adjustment of date or time data is performed. Else the result is local time "
"in the time zone *tz*, representing the same UTC time as *self*:  after "
"``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will have the same "
"date and time data as ``dt - dt.utcoffset()``."
msgstr ""
"Om ``self.tzinfo`` är *tz*, är ``self.astimezone(tz)`` lika med *self*: "
"ingen justering av datum- eller tidsdata utförs. Annars är resultatet lokal "
"tid i tidszonen *tz*, som representerar samma UTC-tid som *self*: efter "
"``astz = dt.astimezone(tz)`` kommer ``astz - astz.utcoffset()`` att ha samma "
"datum- och tidsdata som ``dt - dt.utcoffset()``."

msgid ""
"If you merely want to attach a :class:`timezone` object *tz* to a datetime "
"*dt* without adjustment of date and time data, use ``dt."
"replace(tzinfo=tz)``. If you merely want to remove the :class:`!timezone` "
"object from an aware datetime *dt* without conversion of date and time data, "
"use ``dt.replace(tzinfo=None)``."
msgstr ""
"Om du bara vill bifoga ett :class:`timezone`-objekt *tz* till en datetime "
"*dt* utan att justera datum- och tidsdata, använd ``dt.replace(tzinfo=tz)``. "
"Om du bara vill ta bort :class:`!timezone`-objektet från en medveten "
"datetime *dt* utan konvertering av datum- och tidsdata, använd ``dt."
"replace(tzinfo=None)``."

msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in a :"
"class:`tzinfo` subclass to affect the result returned by :meth:`astimezone`. "
"Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""
"Observera att standardmetoden :meth:`tzinfo.fromutc` kan åsidosättas i en :"
"class:`tzinfo`-underklass för att påverka det resultat som returneras av :"
"meth:`astimezone`. Om man bortser från felfall fungerar :meth:`astimezone` "
"på följande sätt::"

msgid ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new timezone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"
msgstr ""
"def astimezone(self, tz):\n"
"    om self.tzinfo är tz:\n"
"        returnera själv\n"
"    # Konvertera self till UTC och bifoga det nya tidszonobjektet.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Konvertera från UTC till tz:s lokala tid.\n"
"    return tz.fromutc(utc)"

msgid "*tz* now can be omitted."
msgstr "*tz* kan nu utelämnas."

msgid ""
"The :meth:`astimezone` method can now be called on naive instances that are "
"presumed to represent system local time."
msgstr ""
"Metoden :meth:`astimezone` kan nu anropas på naiva instanser som antas "
"representera systemets lokala tid."

msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(self)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Om :attr:`.tzinfo` är ``None``, returneras ``None``, annars returneras "
"``self.tzinfo.utcoffset(self)``, och ett undantag uppstår om det senare inte "
"returnerar ``None`` eller ett :class:`timedelta`-objekt med magnitud mindre "
"än en dag."

msgid "The UTC offset is not restricted to a whole number of minutes."
msgstr "UTC-förskjutningen är inte begränsad till ett helt antal minuter."

msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(self)``, and raises an exception if the latter doesn't return ``None`` "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Om :attr:`.tzinfo` är ``None``, returneras ``None``, annars returneras "
"``self.tzinfo.dst(self)``, och ett undantag uppstår om det senare inte "
"returnerar ``None`` eller ett :class:`timedelta`-objekt med magnitud mindre "
"än en dag."

msgid "The DST offset is not restricted to a whole number of minutes."
msgstr "DST-förskjutningen är inte begränsad till ett helt antal minuter."

msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(self)``, raises an exception if the latter doesn't return ``None`` or "
"a string object,"
msgstr ""
"Om :attr:`.tzinfo` är ``None``, returnerar ``None``, annars returnerar "
"``self.tzinfo.tzname(self)``, utlöser ett undantag om det senare inte "
"returnerar ``None`` eller ett strängobjekt,"

msgid ""
"time.struct_time((d.year, d.month, d.day,\n"
"                  d.hour, d.minute, d.second,\n"
"                  d.weekday(), yday, dst))"
msgstr ""
"time.struct_time((d.år, d.månad, d.dag,\n"
"                  d.timme, d.minut, d.sekund,\n"
"                  d.veckodag(), yday, dst))"

msgid ""
"where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` is the "
"day number within the current year starting with 1 for January 1st. The :"
"attr:`~time.struct_time.tm_isdst` flag of the result is set according to "
"the :meth:`dst` method: :attr:`.tzinfo` is ``None`` or :meth:`dst` returns "
"``None``, :attr:`!tm_isdst` is set to ``-1``; else if :meth:`dst` returns a "
"non-zero value, :attr:`!tm_isdst` is set to 1; else :attr:`!tm_isdst` is set "
"to 0."
msgstr ""
"där ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1`` är "
"dagsnumret inom det aktuella året med början med 1 för den 1 januari. "
"Flaggan :attr:`~time.struct_time.tm_isdst` för resultatet sätts i enlighet "
"med metoden :meth:`dst`: :attr:`.tzinfo` är ``None`` eller :meth:`dst` "
"returnerar ``None``, :attr:`!tm_isdst` sätts till ``-1``; annars om :meth:"
"`dst` returnerar ett värde som inte är noll, sätts :attr:`!tm_isdst` till 1; "
"annars sätts :attr:`!tm_isdst` till 0."

msgid ""
"If :class:`.datetime` instance ``d`` is naive, this is the same as ``d."
"timetuple()`` except that :attr:`~.time.struct_time.tm_isdst` is forced to 0 "
"regardless of what ``d.dst()`` returns. DST is never in effect for a UTC "
"time."
msgstr ""
"Om :class:`.datetime`-instansen ``d`` är naiv, är detta samma sak som ``d."
"timetuple()`` förutom att :attr:`~.time.struct_time.tm_isdst` tvingas till 0 "
"oavsett vad ``d.dst()`` returnerar. DST är aldrig i kraft för en UTC-tid."

msgid ""
"If ``d`` is aware, ``d`` is normalized to UTC time, by subtracting ``d."
"utcoffset()``, and a :class:`time.struct_time` for the normalized time is "
"returned. :attr:`!tm_isdst` is forced to 0. Note that an :exc:"
"`OverflowError` may be raised if ``d.year`` was ``MINYEAR`` or ``MAXYEAR`` "
"and UTC adjustment spills over a year boundary."
msgstr ""
"Om ``d`` är medveten, normaliseras ``d`` till UTC-tid, genom att subtrahera "
"``d.utcoffset()``, och en :class:`time.struct_time` för den normaliserade "
"tiden returneras. :attr:`!tm_isdst` tvingas till 0. Observera att ett :exc:"
"`OverflowError` kan uppstå om ``d.year`` var ``MINYEAR`` eller ``MAXYEAR`` "
"och UTC-justering spiller över en årsgräns."

msgid ""
"Because naive ``datetime`` objects are treated by many ``datetime`` methods "
"as local times, it is preferred to use aware datetimes to represent times in "
"UTC; as a result, using :meth:`datetime.utctimetuple` may give misleading "
"results. If you have a naive ``datetime`` representing UTC, use ``datetime."
"replace(tzinfo=timezone.utc)`` to make it aware, at which point you can use :"
"meth:`.datetime.timetuple`."
msgstr ""
"Eftersom naiva ``datetime``-objekt behandlas av många ``datetime``-metoder "
"som lokala tider, är det att föredra att använda medvetna datatider för att "
"representera tider i UTC; som ett resultat kan användning av :meth:`datetime."
"utctimetuple` ge missvisande resultat. Om du har en naiv ``datetime`` som "
"representerar UTC, använd ``datetime.replace(tzinfo=timezone.utc)`` för att "
"göra den medveten, varpå du kan använda :meth:`.datetime.timetuple`."

msgid ""
"Return the proleptic Gregorian ordinal of the date. The same as ``self."
"date().toordinal()``."
msgstr ""
"Returnerar den proleptiska gregorianska ordinalen för datumet. Samma som "
"``self.date().toordinal()``."

msgid ""
"Return POSIX timestamp corresponding to the :class:`.datetime` instance. The "
"return value is a :class:`float` similar to that returned by :func:`time."
"time`."
msgstr ""
"Returnerar POSIX-tidsstämpel motsvarande :class:`.datetime`-instansen. "
"Returvärdet är en :class:`float` liknande den som returneras av :func:`time."
"time`."

msgid ""
"Naive :class:`.datetime` instances are assumed to represent local time and "
"this method relies on the platform C :c:func:`mktime` function to perform "
"the conversion. Since :class:`.datetime` supports wider range of values "
"than :c:func:`mktime` on many platforms, this method may raise :exc:"
"`OverflowError` or :exc:`OSError` for times far in the past or far in the "
"future."
msgstr ""
"Naiva :class:`.datetime`-instanser antas representera lokal tid och den här "
"metoden förlitar sig på plattform C :c:func:`mktime`-funktionen för att "
"utföra konverteringen. Eftersom :class:`.datetime` har stöd för ett större "
"antal värden än :c:func:`mktime` på många plattformar, kan denna metod ge "
"upphov till :exc:`OverflowError` eller :exc:`OSError` för tider långt "
"tillbaka i tiden eller långt in i framtiden."

msgid ""
"For aware :class:`.datetime` instances, the return value is computed as::"
msgstr "För medvetna :class:`.datetime`-instanser beräknas returvärdet som::"

msgid "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()"
msgstr "(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_sekunder()"

msgid ""
"The :meth:`timestamp` method uses the :attr:`.fold` attribute to "
"disambiguate the times during a repeated interval."
msgstr ""
"Metoden :meth:`timestamp` använder attributet :attr:`.fold` för att "
"särskilja tiderna under ett upprepat intervall."

msgid ""
"There is no method to obtain the POSIX timestamp directly from a naive :"
"class:`.datetime` instance representing UTC time. If your application uses "
"this convention and your system time zone is not set to UTC, you can obtain "
"the POSIX timestamp by supplying ``tzinfo=timezone.utc``::"
msgstr ""
"Det finns ingen metod för att erhålla POSIX-tidsstämpeln direkt från en "
"naiv :class:`.datetime`-instans som representerar UTC-tid. Om ditt program "
"använder den här konventionen och systemets tidszon inte är inställd på UTC, "
"kan du få POSIX-tidsstämpeln genom att ange ``tzinfo=timezone.utc``::"

msgid "timestamp = dt.replace(tzinfo=timezone.utc).timestamp()"
msgstr "timestamp = dt.replace(tzinfo=tidszon.utc).timestamp()"

msgid "or by calculating the timestamp directly::"
msgstr "eller genom att beräkna tidsstämpeln direkt::"

msgid "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)"
msgstr "timestamp = (dt - datetime(1970, 1, 1)) / timedelta(sekunder=1)"

msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""
"Returnerar veckodagen som ett heltal, där måndag är 0 och söndag är 6. Samma "
"som ``self.date().weekday()``. Se även :meth:`isoweekday`."

msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"The same as ``self.date().isoweekday()``. See also :meth:`weekday`, :meth:"
"`isocalendar`."
msgstr ""
"Returnerar veckodagen som ett heltal, där måndag är 1 och söndag är 7. Samma "
"som ``self.date().isoweekday()``. Se även :meth:`weekday`, :meth:"
"`isocalendar`."

msgid ""
"Return a :term:`named tuple` with three components: ``year``, ``week`` and "
"``weekday``. The same as ``self.date().isocalendar()``."
msgstr ""
"Returnerar en :term:`named tuple` med tre komponenter: ``år``, ``vecka`` och "
"``veckodag``. Samma som ``self.date().isocalendar()``."

msgid "Return a string representing the date and time in ISO 8601 format:"
msgstr ""
"Returnerar en sträng som representerar datum och tid i ISO 8601-format:"

msgid "``YYYY-MM-DDTHH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "```YYYY-MM-DDTHH:MM:SS.ffffff``, om :attr:`microsecond` inte är 0"

msgid "``YYYY-MM-DDTHH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``YYYY-MM-DDTHH:MM:SS``, om :attr:`microsecond` är 0"

msgid ""
"If :meth:`utcoffset` does not return ``None``, a string is appended, giving "
"the UTC offset:"
msgstr ""
"Om :meth:`utcoffset` inte returnerar ``None``, läggs en sträng till som "
"anger UTC-offset:"

msgid ""
"``YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` "
"is not 0"
msgstr ""
"```YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, om :attr:`microsecond` "
"inte är 0"

msgid ""
"``YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``,  if :attr:`microsecond` is 0"
msgstr ""
"```YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]``, om :attr:`microsecond` är 0"

msgid ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()\n"
"'2019-05-18T15:17:08.132263'\n"
">>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()\n"
"'2019-05-18T15:17:00+00:00'"

msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character separator, "
"placed between the date and time portions of the result. For example::"
msgstr ""
"Det valfria argumentet *sep* (standard ``'T'``) är en enteckensseparator som "
"placeras mellan datum- och tidsdelarna i resultatet. Till exempel::"

msgid ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"
msgstr ""
">>> from datetime import tzinfo, timedelta, datetime\n"
">>> class TZ(tzinfo):\n"
"...     \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\"\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=-6, minutes=-39)\n"
"...\n"
">>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')\n"
"'2002-12-25 00:00:00-06:39'\n"
">>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()\n"
"'2009-11-27T00:00:00.000100-06:39'"

msgid ""
"The optional argument *timespec* specifies the number of additional "
"components of the time to include (the default is ``'auto'``). It can be one "
"of the following:"
msgstr ""
"Det valfria argumentet *timespec* anger antalet ytterligare komponenter i "
"tiden som ska inkluderas (standardvärdet är ``'auto'``). Det kan vara något "
"av följande:"

msgid ""
"``'auto'``: Same as ``'seconds'`` if :attr:`microsecond` is 0, same as "
"``'microseconds'`` otherwise."
msgstr ""
"``'auto'``: Samma som ``'seconds'`` om :attr:`microsecond` är 0, samma som "
"``'microseconds'`` annars."

msgid "``'hours'``: Include the :attr:`hour` in the two-digit ``HH`` format."
msgstr ""
"``'timmar'``: Inkluderar :attr:`hour` i det tvåsiffriga formatet ``HH``."

msgid ""
"``'minutes'``: Include :attr:`hour` and :attr:`minute` in ``HH:MM`` format."
msgstr ""
"``'minuter``: Inkludera :attr:`hour` och :attr:`minute` i formatet ``HH:MM``."

msgid ""
"``'seconds'``: Include :attr:`hour`, :attr:`minute`, and :attr:`second` in "
"``HH:MM:SS`` format."
msgstr ""
"``'seconds'``: Inkludera :attr:`hour`, :attr:`minute` och :attr:`second` i "
"formatet ``HH:MM:SS``."

msgid ""
"``'milliseconds'``: Include full time, but truncate fractional second part "
"to milliseconds. ``HH:MM:SS.sss`` format."
msgstr ""
"``'millisekunder'``: Inkludera hela tiden, men trunkera bråkdelen av "
"sekunddelen till millisekunder. format ``HH:MM:SS.sss``."

msgid "``'microseconds'``: Include full time in ``HH:MM:SS.ffffff`` format."
msgstr ""
"``'mikrosekunder'``: Inkludera full tid i formatet ``HH:MM:SS.ffffff``."

msgid "Excluded time components are truncated, not rounded."
msgstr "Exkluderade tidskomponenter är trunkerade, inte avrundade."

msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument::"
msgstr ""
":exc:`ValueError` kommer att uppstå på ett ogiltigt *timespec* argument::"

msgid ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime.now().isoformat(timespec='minutes')\n"
"'2002-12-25T00:00'\n"
">>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'2015-01-01T12:30:59.000000'"

msgid "Added the *timespec* parameter."
msgstr "Parametern *timespec* har lagts till."

msgid ""
"For a :class:`.datetime` instance ``d``, ``str(d)`` is equivalent to ``d."
"isoformat(' ')``."
msgstr ""
"För en :class:`.datetime`-instans ``d`` är ``str(d)`` ekvivalent med ``d."
"isoformat(' ')``."

msgid "Return a string representing the date and time::"
msgstr "Returnerar en sträng som representerar datum och tid::"

msgid ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"
msgstr ""
">>> from datetime import datetime\n"
">>> datetime(2002, 12, 4, 20, 30, 40).ctime()\n"
"'Wed Dec  4 20:30:40 2002'"

msgid ""
"The output string will *not* include time zone information, regardless of "
"whether the input is aware or naive."
msgstr ""
"Utdatasträngen kommer *inte* att innehålla tidszoninformation, oavsett om "
"indata är medveten eller naiv."

msgid ""
"on platforms where the native C :c:func:`ctime` function (which :func:`time."
"ctime` invokes, but which :meth:`datetime.ctime` does not invoke) conforms "
"to the C standard."
msgstr ""
"på plattformar där den inbyggda C-funktionen :c:func:`ctime` (som :func:"
"`time.ctime` anropar, men som :meth:`datetime.ctime` inte anropar) "
"överensstämmer med C-standarden."

msgid ""
"Return a string representing the date and time, controlled by an explicit "
"format string. See also :ref:`strftime-strptime-behavior` and :meth:"
"`datetime.isoformat`."
msgstr ""
"Returnerar en sträng som representerar datum och tid, styrd av en explicit "
"formatsträng. Se även :ref:`strftime-strptime-behavior` och :meth:`datetime."
"isoformat`."

msgid ""
"Same as :meth:`.datetime.strftime`. This makes it possible to specify a "
"format string for a :class:`.datetime` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. See also :ref:"
"`strftime-strptime-behavior` and :meth:`datetime.isoformat`."
msgstr ""
"Samma som :meth:`.datetime.strftime`. Detta gör det möjligt att ange en "
"formatsträng för ett :class:`.datetime`-objekt i :ref:``formatted string "
"literals <f-strings>`` och när man använder :meth:`str.format`. Se även :ref:"
"`strftime-strptime-behavior` och :meth:`datetime.isoformat`."

msgid "Examples of Usage: :class:`.datetime`"
msgstr "Exempel på användning: :class:`.datetime`"

msgid "Examples of working with :class:`.datetime` objects:"
msgstr "Exempel på hur man arbetar med :class:`.datetime`-objekt:"

msgid ""
">>> from datetime import datetime, date, time, timezone\n"
"\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Using datetime.now()\n"
">>> datetime.now()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.now(timezone.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone."
"utc)\n"
"\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
"\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:\n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
"\n"
">>> # Formatting a datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'\n"
">>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'."
"format(dt, \"day\", \"month\", \"time\")\n"
"'The day is 21, the month is November, the time is 04:30PM.'"
msgstr ""
">>> from datetime import datetime, datum, tid, tidszon\n"
"\n"
">>> # Använda datetime.combine()\n"
">>> d = datum(2005, 7, 14)\n"
">>> t = tid(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
"\n"
">>> # Använda datetime.now()\n"
">>> datetime.nu()\n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043) # GMT +1\n"
">>> datetime.now(tidszon.utc)\n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone."
"utc)\n"
"\n"
">>> # Använda datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
"\n"
">>> # Använd datetime.timetuple() för att få en tupel av alla attribut\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:\n"
"... print(it)\n"
"...\n"
"2006 # år\n"
"11 # månad\n"
"21 # dag\n"
"16 # timme\n"
"30 # minut\n"
"0 # sekund\n"
"1 # veckodag (0 = måndag)\n"
"325 # antal dagar sedan den 1 januari\n"
"-1 # dst - metoden tzinfo.dst() returnerade None\n"
"\n"
">>> # Datum i ISO-format\n"
">>> ic = dt.isocalendar()\n"
">>> för det i ic:\n"
"... print(it)\n"
"...\n"
"2006 # ISO-år\n"
"47 # ISO-vecka\n"
"2 # ISO-veckodag\n"
"\n"
">>> # Formatering av en datatid\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tisdag 21. November 2006 04:30PM'\n"
">>> '{1} är {0:%d}, {2} är {0:%B}, {3} är {0:%I:%M%p}.'.format(dt, \"dag\", "
"\"månad\", \"tid\")\n"
"\"Dagen är 21, månaden är november, tiden är 04:30"

msgid ""
"The example below defines a :class:`tzinfo` subclass capturing time zone "
"information for Kabul, Afghanistan, which used +4 UTC until 1945 and then "
"+4:30 UTC thereafter::"
msgstr ""
"I exemplet nedan definieras en :class:`tzinfo`-underklass som samlar in "
"tidszoninformation för Kabul, Afghanistan, som använde +4 UTC fram till 1945 "
"och därefter +4:30 UTC:"

msgid ""
"from datetime import timedelta, datetime, tzinfo, timezone\n"
"\n"
"class KabulTz(tzinfo):\n"
"    # Kabul used +4 until 1945, when they moved to +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if dt.year < 1945:\n"
"            return timedelta(hours=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # An ambiguous (\"imaginary\") half-hour range representing\n"
"            # a 'fold' in time due to the shift from +4 to +4:30.\n"
"            # If dt falls in the imaginary range, use fold to decide how\n"
"            # to resolve. See PEP495.\n"
"            return timedelta(hours=4, minutes=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(hours=4, minutes=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Follow same validations as in datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() requires a datetime argument\")\n"
"        if dt.tzinfo is not self:\n"
"            raise ValueError(\"dt.tzinfo is not self\")\n"
"\n"
"        # A custom implementation is required for fromutc as\n"
"        # the input to this function is a datetime with utc values\n"
"        # but with a tzinfo set to self.\n"
"        # See datetime.astimezone or fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(hours=4, minutes=30)\n"
"        else:\n"
"            return dt + timedelta(hours=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul does not observe daylight saving time.\n"
"        return timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            return \"+04:30\"\n"
"        return \"+04\""
msgstr ""
"from datetime import timedelta, datetime, tzinfo, tidszon\n"
"\n"
"klass KabulTz(tzinfo):\n"
"    # Kabul använde +4 fram till 1945, då de gick över till +4:30\n"
"    UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        om dt.år < 1945:\n"
"            return timedelta(timmar=4)\n"
"        elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, "
"30):\n"
"            # Ett tvetydigt (\"imaginärt\") halvtimmesintervall som "
"representerar\n"
"            # ett \"veck\" i tiden på grund av skiftet från +4 till +4:30.\n"
"            # Om dt faller inom det imaginära intervallet, använd fold för "
"att bestämma hur\n"
"            # hur det ska lösas. Se PEP495.\n"
"            return timedelta(timmar=4, minuter=(30 if dt.fold else 0))\n"
"        else:\n"
"            return timedelta(timmar=4, minuter=30)\n"
"\n"
"    def fromutc(self, dt):\n"
"        # Följ samma valideringar som i datetime.tzinfo\n"
"        if not isinstance(dt, datetime):\n"
"            raise TypeError(\"fromutc() kräver ett datetime-argument\")\n"
"        om dt.tzinfo inte är self:\n"
"            raise ValueError(\"dt.tzinfo är inte self\")\n"
"\n"
"        # En anpassad implementering krävs för fromutc eftersom\n"
"        # indata till denna funktion är en datatid med utc-värden\n"
"        # men med en tzinfo inställd på self.\n"
"        # Se datetime.astimezone eller fromtimestamp.\n"
"        if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:\n"
"            return dt + timedelta(timmar=4, minuter=30)\n"
"        i annat fall\n"
"            return dt + timedelta(timmar=4)\n"
"\n"
"    def dst(self, dt):\n"
"        # Kabul följer inte sommartid.\n"
"        returnera timedelta(0)\n"
"\n"
"    def tzname(self, dt):\n"
"        if dt >= self.UTC_MOVE_DATE:\n"
"            returnera \"+04:30\"\n"
"        return \"+04\""

msgid "Usage of ``KabulTz`` from above::"
msgstr "Användning av ``KabulTz`` från ovan::"

msgid ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datetime before the change\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datetime after the change\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Convert datetime to another time zone\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"True"
msgstr ""
">>> tz1 = KabulTz()\n"
"\n"
">>> # Datatid före förändringen\n"
">>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)\n"
">>> print(dt1.utcoffset())\n"
"4:00:00\n"
"\n"
">>> # Datatid efter ändringen\n"
">>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)\n"
">>> print(dt2.utcoffset())\n"
"4:30:00\n"
"\n"
">>> # Konvertera datatid till en annan tidszon\n"
">>> dt3 = dt2.astimezone(timezone.utc)\n"
">>> dt3\n"
"datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)\n"
">>> dt2\n"
"datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())\n"
">>> dt2 == dt3\n"
"Sant"

msgid ":class:`.time` Objects"
msgstr ":class:`.time` Objekt"

msgid ""
"A :class:`.time` object represents a (local) time of day, independent of any "
"particular day, and subject to adjustment via a :class:`tzinfo` object."
msgstr ""
"Ett :class:`.time`-objekt representerar en (lokal) tid på dygnet, oberoende "
"av en viss dag, och kan justeras via ett :class:`tzinfo`-objekt."

msgid ""
"All arguments are optional. *tzinfo* may be ``None``, or an instance of a :"
"class:`tzinfo` subclass. The remaining arguments must be integers in the "
"following ranges:"
msgstr ""
"Alla argument är valfria. *tzinfo* kan vara ``None``, eller en instans av "
"en :class:`tzinfo`-underklass. De återstående argumenten måste vara heltal "
"inom följande intervall:"

msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised. "
"All default to 0 except *tzinfo*, which defaults to ``None``."
msgstr ""
"Om ett argument utanför dessa intervall anges, kommer :exc:`ValueError` att "
"uppstå. Alla har standardvärdet 0 utom *tzinfo*, som har standardvärdet "
"``None``."

msgid "The earliest representable :class:`.time`, ``time(0, 0, 0, 0)``."
msgstr "Den tidigaste representerbara :class:`.time`, ``time(0, 0, 0, 0)``."

msgid "The latest representable :class:`.time`, ``time(23, 59, 59, 999999)``."
msgstr ""
"Den senaste representerbara :class:`.time`, ``time(23, 59, 59, 999999)``."

msgid ""
"The smallest possible difference between non-equal :class:`.time` objects, "
"``timedelta(microseconds=1)``, although note that arithmetic on :class:`."
"time` objects is not supported."
msgstr ""
"Den minsta möjliga skillnaden mellan icke lika :class:`.time`-objekt, "
"``timedelta(microseconds=1)``, men observera att aritmetik på :class:`.time`-"
"objekt inte stöds."

msgid ""
"The object passed as the tzinfo argument to the :class:`.time` constructor, "
"or ``None`` if none was passed."
msgstr ""
"Det objekt som skickades som tzinfo-argument till :class:`.time`-"
"konstruktören, eller ``None`` om inget skickades."

msgid ""
":class:`.time` objects support equality and order comparisons, where ``a`` "
"is considered less than ``b`` when ``a`` precedes ``b`` in time."
msgstr ""
":class:`.time`-objekt stöder jämlikhets- och ordningsjämförelser, där ``a`` "
"anses vara mindre än ``b`` när ``a`` föregår ``b`` i tid."

msgid ""
"Naive and aware :class:`!time` objects are never equal. Order comparison "
"between naive and aware :class:`!time` objects raises :exc:`TypeError`."
msgstr ""
"Naiva och medvetna :class:`!time`-objekt är aldrig lika. Orderjämförelse "
"mellan naiva och medvetna :class:`!time`-objekt ger upphov till :exc:"
"`TypeError`."

msgid ""
"If both comparands are aware, and have the same :attr:`~.time.tzinfo` "
"attribute, the :attr:`!tzinfo` and :attr:`!fold` attributes are ignored and "
"the base times are compared. If both comparands are aware and have "
"different :attr:`!tzinfo` attributes, the comparands are first adjusted by "
"subtracting their UTC offsets (obtained from ``self.utcoffset()``)."
msgstr ""
"Om båda jämförelseobjekten är medvetna och har samma attribut :attr:`~.time."
"tzinfo`, ignoreras attributen :attr:`!tzinfo` och :attr:`!fold` och "
"bastiderna jämförs. Om båda jämförelsetiderna är medvetna och har olika :"
"attr:`!tzinfo`-attribut, justeras jämförelsetiderna först genom att "
"subtrahera deras UTC-offset (erhållen från ``self.utcoffset()``)."

msgid ""
"Equality comparisons between aware and naive :class:`.time` instances don't "
"raise :exc:`TypeError`."
msgstr ""
"Jämlikhetsjämförelser mellan medvetna och naiva :class:`.time`-instanser ger "
"inte upphov till :exc:`TypeError`."

msgid ""
"In Boolean contexts, a :class:`.time` object is always considered to be true."
msgstr ""
"I booleska sammanhang anses ett :class:`.time`-objekt alltid vara sant."

msgid ""
"Before Python 3.5, a :class:`.time` object was considered to be false if it "
"represented midnight in UTC. This behavior was considered obscure and error-"
"prone and has been removed in Python 3.5. See :issue:`13936` for full "
"details."
msgstr ""
"Före Python 3.5 ansågs ett :class:`.time`-objekt vara falskt om det "
"representerade midnatt i UTC. Detta beteende ansågs obskyrt och felbenäget "
"och har tagits bort i Python 3.5. Se :issue:`13936` för fullständiga "
"detaljer."

msgid "Other constructors:"
msgstr "Andra konstruktörer:"

msgid ""
"Return a :class:`.time` corresponding to a *time_string* in any valid ISO "
"8601 format, with the following exceptions:"
msgstr ""
"Returnera en :class:`.time` som motsvarar en *time_string* i valfritt "
"giltigt ISO 8601-format, med följande undantag:"

msgid ""
"The leading ``T``, normally required in cases where there may be ambiguity "
"between a date and a time, is not required."
msgstr ""
"Det inledande ``T``, som normalt krävs i fall där det kan råda oklarhet "
"mellan ett datum och en tid, krävs inte."

msgid ""
"Fractional seconds may have any number of digits (anything beyond 6 will be "
"truncated)."
msgstr "Bråksekunder kan ha valfritt antal siffror (allt över 6 trunkeras)."

msgid "Examples:"
msgstr "Exempel:"

msgid ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime."
"timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"
msgstr ""
">>> from datetime import time\n"
">>> time.fromisoformat('04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T04:23:01')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('T042301')\n"
"datetime.time(4, 23, 1)\n"
">>> time.fromisoformat('04:23:01.000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01,000384')\n"
"datetime.time(4, 23, 1, 384)\n"
">>> time.fromisoformat('04:23:01+04:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime."
"timedelta(seconds=14400)))\n"
">>> time.fromisoformat('04:23:01Z')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)\n"
">>> time.fromisoformat('04:23:01+00:00')\n"
"datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)"

msgid ""
"Previously, this method only supported formats that could be emitted by :"
"meth:`time.isoformat`."
msgstr ""
"Tidigare stödde den här metoden endast format som kunde utfärdas av :meth:"
"`time.isoformat`."

msgid ""
"Return a :class:`.time` corresponding to *date_string*, parsed according to "
"*format*."
msgstr ""
"Returnerar en :class:`.time` som motsvarar *date_string*, tolkad enligt "
"*format*."

msgid ""
"If *format* does not contain microseconds or timezone information, this is "
"equivalent to::"
msgstr ""
"Om *format* inte innehåller mikrosekunder eller tidszonsinformation "
"motsvarar detta::"

msgid "time(*(time.strptime(date_string, format)[3:6]))"
msgstr "tid(*(tid.strptime(datum_sträng, format)[3:6]))"

msgid ""
":exc:`ValueError` is raised if the *date_string* and *format* cannot be "
"parsed by :func:`time.strptime` or if it returns a value which is not a time "
"tuple.  See also :ref:`strftime-strptime-behavior` and :meth:`time."
"fromisoformat`."
msgstr ""
":exc:`ValueError` uppstår om *date_string* och *format* inte kan tolkas av :"
"func:`time.strptime` eller om den returnerar ett värde som inte är en "
"tidstupel.  Se även :ref:`strftime-strptime-behavior` och :meth:`time."
"fromisoformat`."

msgid ""
"Return a new :class:`.time` with the same values, but with specified "
"parameters updated. Note that ``tzinfo=None`` can be specified to create a "
"naive :class:`.time` from an aware :class:`.time`, without conversion of the "
"time data."
msgstr ""
"Returnerar en ny :class:`.time` med samma värden, men med angivna parametrar "
"uppdaterade. Observera att ``tzinfo=None`` kan anges för att skapa en naiv :"
"class:`.time` från en aware :class:`.time`, utan konvertering av tidsdata."

msgid ""
":class:`.time` objects are also supported by generic function :func:`copy."
"replace`."
msgstr ""
":class:`.time`-objekt stöds också av den generiska funktionen :func:`copy."
"replace`."

msgid "Return a string representing the time in ISO 8601 format, one of:"
msgstr "Returnerar en sträng som representerar tiden i ISO 8601-format, en av:"

msgid "``HH:MM:SS.ffffff``, if :attr:`microsecond` is not 0"
msgstr "``HH:MM:SS.ffffff``, om :attr:`microsecond` inte är 0"

msgid "``HH:MM:SS``, if :attr:`microsecond` is 0"
msgstr "``HH:MM:SS``, om :attr:`microsekund` är 0"

msgid ""
"``HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, if :meth:`utcoffset` does not "
"return ``None``"
msgstr ""
"```HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]``, om :meth:`utcoffset` inte "
"returnerar ``None``"

msgid ""
"``HH:MM:SS+HH:MM[:SS[.ffffff]]``, if :attr:`microsecond` is 0 and :meth:"
"`utcoffset` does not return ``None``"
msgstr ""
"```HH:MM:SS+HH:MM[:SS[.ffffff]]``, om :attr:`microsecond` är 0 och :meth:"
"`utcoffset` inte returnerar ``None``"

msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument."
msgstr ""
":exc:`ValueError` kommer att uppstå vid ett ogiltigt *timespec*-argument."

msgid ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456)."
"isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"
msgstr ""
">>> from datetime import time\n"
">>> time(hour=12, minute=34, second=56, microsecond=123456)."
"isoformat(timespec='minutes')\n"
"'12:34'\n"
">>> dt = time(hour=12, minute=34, second=56, microsecond=0)\n"
">>> dt.isoformat(timespec='microseconds')\n"
"'12:34:56.000000'\n"
">>> dt.isoformat(timespec='auto')\n"
"'12:34:56'"

msgid "For a time ``t``, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr "För en tid ``t`` är ``str(t)`` ekvivalent med ``t.isoformat()``."

msgid ""
"Return a string representing the time, controlled by an explicit format "
"string.  See also :ref:`strftime-strptime-behavior` and :meth:`time."
"isoformat`."
msgstr ""
"Returnerar en sträng som representerar tiden, styrd av en explicit "
"formatsträng.  Se även :ref:`strftime-strptime-behavior` och :meth:`time."
"isoformat`."

msgid ""
"Same as :meth:`.time.strftime`. This makes it possible to specify a format "
"string for a :class:`.time` object in :ref:`formatted string literals <f-"
"strings>` and when using :meth:`str.format`. See also :ref:`strftime-"
"strptime-behavior` and :meth:`time.isoformat`."
msgstr ""
"Samma som :meth:`.time.strftime`. Detta gör det möjligt att ange en "
"formatsträng för ett :class:`.time`-objekt i :ref:``formatted string "
"literals <f-strings>`` och när man använder :meth:`str.format`. Se även :ref:"
"`strftime-strptime-behavior` och :meth:`time.isoformat`."

msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(None)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Om :attr:`.tzinfo` är ``None``, returneras ``None``, annars returneras "
"``self.tzinfo.utcoffset(None)``, och ett undantag uppstår om det senare inte "
"returnerar ``None`` eller ett :class:`timedelta`-objekt med magnitud mindre "
"än en dag."

msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(None)``, and raises an exception if the latter doesn't return ``None``, "
"or a :class:`timedelta` object with magnitude less than one day."
msgstr ""
"Om :attr:`.tzinfo` är ``None``, returneras ``None``, annars returneras "
"``self.tzinfo.dst(None)``, och ett undantag uppstår om det senare inte "
"returnerar ``None``, eller ett :class:`timedelta` objekt med magnitud mindre "
"än en dag."

msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(None)``, or raises an exception if the latter doesn't return ``None`` "
"or a string object."
msgstr ""
"Om :attr:`.tzinfo` är ``None``, returneras ``None``, annars returneras "
"``self.tzinfo.tzname(None)``, eller så uppstår ett undantag om det senare "
"inte returnerar ``None`` eller ett strängobjekt."

msgid "Examples of Usage: :class:`.time`"
msgstr "Exempel på användning: :class:`.time`"

msgid "Examples of working with a :class:`.time` object::"
msgstr "Exempel på att arbeta med ett :class:`.time`-objekt::"

msgid ""
">>> from datetime import time, tzinfo, timedelta\n"
">>> class TZ1(tzinfo):\n"
"...     def utcoffset(self, dt):\n"
"...         return timedelta(hours=1)\n"
"...     def dst(self, dt):\n"
"...         return timedelta(0)\n"
"...     def tzname(self,dt):\n"
"...         return \"+01:00\"\n"
"...     def  __repr__(self):\n"
"...         return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = time(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'The {} is {:%H:%M}.'.format(\"time\", t)\n"
"'The time is 12:10.'"
msgstr ""
">>> from datetime import tid, tzinfo, timedelta\n"
">>> klass TZ1(tzinfo):\n"
"... def utcoffset(self, dt):\n"
"... return timedelta(timmar=1)\n"
"... def dst(self, dt):\n"
"... return timedelta(0)\n"
"... def tzname(self,dt):\n"
"... return \"+01:00\"\n"
"... def __repr__(self):\n"
"... return f\"{self.__class__.__name__}()\"\n"
"...\n"
">>> t = tid(12, 10, 30, tzinfo=TZ1())\n"
">>> t\n"
"datetime.time(12, 10, 30, tzinfo=TZ1())\n"
">>> t.isoformat()\n"
"'12:10:30+01:00'\n"
">>> t.dst()\n"
"datetime.timedelta(0)\n"
">>> t.tzname()\n"
"'+01:00'\n"
">>> t.strftime(\"%H:%M:%S %Z\")\n"
"'12:10:30 +01:00'\n"
">>> 'Klockan {} är {:%H:%M}.'.format(\"tid\", t)\n"
"\"Klockan är 12:10"

msgid ":class:`tzinfo` Objects"
msgstr ":class:`tzinfo` Objekt"

msgid ""
"This is an abstract base class, meaning that this class should not be "
"instantiated directly.  Define a subclass of :class:`tzinfo` to capture "
"information about a particular time zone."
msgstr ""
"Detta är en abstrakt basklass, vilket innebär att denna klass inte bör "
"instansieras direkt.  Definiera en subklass av :class:`tzinfo` för att fånga "
"information om en viss tidszon."

msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to the "
"constructors for :class:`.datetime` and :class:`.time` objects. The latter "
"objects view their attributes as being in local time, and the :class:"
"`tzinfo` object supports methods revealing offset of local time from UTC, "
"the name of the time zone, and DST offset, all relative to a date or time "
"object passed to them."
msgstr ""
"En instans av (en konkret underklass av) :class:`tzinfo` kan skickas till "
"konstruktörerna för objekten :class:`.datetime` och :class:`.time`. De "
"senare objekten ser sina attribut som i lokal tid, och objektet :class:"
"`tzinfo` stöder metoder som avslöjar förskjutning av lokal tid från UTC, "
"namnet på tidszonen och DST-förskjutning, allt i förhållande till ett datum- "
"eller tidsobjekt som skickas till dem."

msgid ""
"You need to derive a concrete subclass, and (at least) supply "
"implementations of the standard :class:`tzinfo` methods needed by the :class:"
"`.datetime` methods you use. The :mod:`!datetime` module provides :class:"
"`timezone`, a simple concrete subclass of :class:`tzinfo` which can "
"represent time zones with fixed offset from UTC such as UTC itself or North "
"American EST and EDT."
msgstr ""
"Du måste härleda en konkret underklass och (åtminstone) tillhandahålla "
"implementeringar av standardmetoderna :class:`tzinfo` som behövs av de :"
"class:`.datetime`-metoder du använder. Modulen :mod:`!datetime` "
"tillhandahåller :class:`timezone`, en enkel konkret underklass till :class:"
"`tzinfo` som kan representera tidszoner med fast förskjutning från UTC, t."
"ex. UTC själv eller nordamerikanska EST och EDT."

msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have an :"
"meth:`~object.__init__` method that can be called with no arguments, "
"otherwise it can be pickled but possibly not unpickled again. This is a "
"technical requirement that may be relaxed in the future."
msgstr ""
"Särskilt krav för betning:  En :class:`tzinfo` subklass måste ha en :meth:"
"`~object.__init__` metod som kan anropas utan argument, annars kan den "
"picklas men eventuellt inte unpicklas igen. Detta är ett tekniskt krav som "
"kan komma att lättas på i framtiden."

msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the following "
"methods. Exactly which methods are needed depends on the uses made of aware :"
"mod:`!datetime` objects. If in doubt, simply implement all of them."
msgstr ""
"En konkret subklass av :class:`tzinfo` kan behöva implementera följande "
"metoder. Exakt vilka metoder som behövs beror på hur medvetna :mod:`!"
"datetime`-objekt används. Om du är osäker, implementera helt enkelt alla."

msgid ""
"Return offset of local time from UTC, as a :class:`timedelta` object that is "
"positive east of UTC. If local time is west of UTC, this should be negative."
msgstr ""
"Returnerar förskjutning av lokal tid från UTC, som ett :class:`timedelta`-"
"objekt som är positivt öster om UTC. Om lokal tid är väster om UTC bör detta "
"vara negativt."

msgid ""
"This represents the *total* offset from UTC; for example, if a :class:"
"`tzinfo` object represents both time zone and DST adjustments, :meth:"
"`utcoffset` should return their sum. If the UTC offset isn't known, return "
"``None``. Else the value returned must be a :class:`timedelta` object "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)`` (the "
"magnitude of the offset must be less than one day). Most implementations of :"
"meth:`utcoffset` will probably look like one of these two::"
msgstr ""
"Detta representerar den *totala* förskjutningen från UTC; till exempel, om "
"ett :class:`tzinfo`-objekt representerar både tidszon- och DST-justeringar, "
"bör :meth:`utcoffset` returnera summan av dessa. Om UTC-förskjutningen inte "
"är känd, returneras ``None``. Annars måste värdet som returneras vara ett :"
"class:`timedelta`-objekt strikt mellan ``-timedelta(hours=24)`` och "
"``timedelta(hours=24)`` (storleken på förskjutningen måste vara mindre än en "
"dag). De flesta implementationer av :meth:`utcoffset` kommer förmodligen att "
"se ut som en av dessa två::"

msgid ""
"return CONSTANT                 # fixed-offset class\n"
"return CONSTANT + self.dst(dt)  # daylight-aware class"
msgstr ""
"return CONSTANT # klass för fast offset\n"
"return CONSTANT + self.dst(dt) # dagsljusmedveten klass"

msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not return "
"``None`` either."
msgstr ""
"Om :meth:`utcoffset` inte returnerar ``None``, bör inte heller :meth:`dst` "
"returnera ``None``."

msgid ""
"The default implementation of :meth:`utcoffset` raises :exc:"
"`NotImplementedError`."
msgstr ""
"Standardimplementeringen av :meth:`utcoffset` ger upphov till :exc:"
"`NotImplementedError`."

msgid ""
"Return the daylight saving time (DST) adjustment, as a :class:`timedelta` "
"object or ``None`` if DST information isn't known."
msgstr ""
"Returnerar justeringen av sommartid (DST) som ett :class:`timedelta`-objekt "
"eller ``None`` om DST-information inte är känd."

msgid ""
"Return ``timedelta(0)`` if DST is not in effect. If DST is in effect, return "
"the offset as a :class:`timedelta` object (see :meth:`utcoffset` for "
"details). Note that DST offset, if applicable, has already been added to the "
"UTC offset returned by :meth:`utcoffset`, so there's no need to consult :"
"meth:`dst` unless you're interested in obtaining DST info separately. For "
"example, :meth:`datetime.timetuple` calls its :attr:`~.datetime.tzinfo` "
"attribute's :meth:`dst` method to determine how the :attr:`~time.struct_time."
"tm_isdst` flag should be set, and :meth:`tzinfo.fromutc` calls :meth:`dst` "
"to account for DST changes when crossing time zones."
msgstr ""
"Returnerar ``timedelta(0)`` om DST inte är i kraft. Om DST gäller, "
"returneras förskjutningen som ett :class:`timedelta`-objekt (se :meth:"
"`utcoffset` för detaljer). Observera att DST-offset, om tillämpligt, redan "
"har lagts till UTC-offset som returneras av :meth:`utcoffset`, så det finns "
"inget behov av att konsultera :meth:`dst` om du inte är intresserad av att "
"få DST-information separat. Till exempel anropar :meth:`datetime.timetuple` "
"sitt :attr:`~.datetime.tzinfo`-attributs :meth:`dst`-metod för att avgöra "
"hur flaggan :attr:`~time.struct_time.tm_isdst` ska sättas, och :meth:`tzinfo."
"fromutc` anropar :meth:`dst` för att ta hänsyn till DST-ändringar när man "
"korsar tidszoner."

msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard and "
"daylight times must be consistent in this sense:"
msgstr ""
"En instans *tz* av en :class:`tzinfo`-underklass som modellerar både "
"standardtid och dagtid måste vara konsekvent i denna mening:"

msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr "``tz.utcoffset(dt) - tz.dst(dt)``"

msgid ""
"must return the same result for every :class:`.datetime` *dt* with ``dt."
"tzinfo == tz``. For sane :class:`tzinfo` subclasses, this expression yields "
"the time zone's \"standard offset\", which should not depend on the date or "
"the time, but only on geographic location. The implementation of :meth:"
"`datetime.astimezone` relies on this, but cannot detect violations; it's the "
"programmer's responsibility to ensure it. If a :class:`tzinfo` subclass "
"cannot guarantee this, it may be able to override the default implementation "
"of :meth:`tzinfo.fromutc` to work correctly with :meth:`~.datetime."
"astimezone` regardless."
msgstr ""
"måste returnera samma resultat för varje :class:`.datetime` *dt* med ``dt."
"tzinfo == tz``. För sunda :class:`tzinfo`-underklasser ger detta uttryck "
"tidszonens \"standardförskjutning\", som inte bör bero på datum eller tid, "
"utan endast på geografisk plats. Implementationen av :meth:`datetime."
"astimezone` förlitar sig på detta, men kan inte upptäcka överträdelser; det "
"är programmerarens ansvar att säkerställa det. Om en :class:`tzinfo`-"
"underklass inte kan garantera detta, kan den kanske åsidosätta "
"standardimplementeringen av :meth:`tzinfo.fromutc` för att fungera korrekt "
"med :meth:`~.datetime.astimezone` oavsett."

msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr ""
"De flesta implementationer av :meth:`dst` kommer förmodligen att se ut som "
"en av dessa två::"

msgid ""
"def dst(self, dt):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"
msgstr ""
"def dst(self, dt):\n"
"    # en klass med fast offset: tar inte hänsyn till DST\n"
"    returnera timedelta(0)"

msgid "or::"
msgstr "eller::"

msgid ""
"def dst(self, dt):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"
msgstr ""
"def dst(själv, dt):\n"
"    # Kod för att ställa in dston och dstoff till tidszonens DST\n"
"    # övergångstider baserat på inmatningen dt.year, och uttryckt\n"
"    # i lokal standardtid.\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        returnera timedelta(timmar=1)\n"
"    i annat fall\n"
"        returnera timedelta(0)"

msgid ""
"The default implementation of :meth:`dst` raises :exc:`NotImplementedError`."
msgstr ""
"Standardimplementeringen av :meth:`dst` ger upphov till :exc:"
"`NotImplementedError`."

msgid ""
"Return the time zone name corresponding to the :class:`.datetime` object "
"*dt*, as a string. Nothing about string names is defined by the :mod:`!"
"datetime` module, and there's no requirement that it mean anything in "
"particular. For example, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, "
"``\"-5:00\"``, ``\"EDT\"``, ``\"US/Eastern\"``, ``\"America/New York\"`` are "
"all valid replies. Return ``None`` if a string name isn't known. Note that "
"this is a method rather than a fixed string primarily because some :class:"
"`tzinfo` subclasses will wish to return different names depending on the "
"specific value of *dt* passed, especially if the :class:`tzinfo` class is "
"accounting for daylight time."
msgstr ""
"Returnerar tidszonens namn som motsvarar :class:`.datetime`-objektet *dt*, "
"som en sträng. Ingenting om strängnamn definieras av :mod:`!datetime`-"
"modulen, och det finns inget krav på att det ska betyda något särskilt. Till "
"exempel, ``\"GMT\"``, ``\"UTC\"``, ``\"-500\"``, ``\"-5:00\"``, ``\"EDT\"``, "
"``\"US/Eastern\"``, ``\"America/New York\"`` är alla giltiga svar. "
"Returnerar ``None`` om ett strängnamn inte är känt. Observera att detta är "
"en metod snarare än en fast sträng, främst eftersom vissa :class:`tzinfo`-"
"underklasser kommer att vilja returnera olika namn beroende på det specifika "
"värdet för *dt* som skickas, särskilt om :class:`tzinfo`-klassen tar hänsyn "
"till sommartid."

msgid ""
"The default implementation of :meth:`tzname` raises :exc:"
"`NotImplementedError`."
msgstr ""
"Standardimplementeringen av :meth:`tzname` ger upphov till :exc:"
"`NotImplementedError`."

msgid ""
"These methods are called by a :class:`.datetime` or :class:`.time` object, "
"in response to their methods of the same names. A :class:`.datetime` object "
"passes itself as the argument, and a :class:`.time` object passes ``None`` "
"as the argument. A :class:`tzinfo` subclass's methods should therefore be "
"prepared to accept a *dt* argument of ``None``, or of class :class:`."
"datetime`."
msgstr ""
"Dessa metoder anropas av ett :class:`.datetime`- eller :class:`.time`-objekt "
"som svar på deras metoder med samma namn. Ett :class:`.datetime`-objekt "
"skickar sig själv som argument, och ett :class:`.time`-objekt skickar "
"``None`` som argument. En :class:`tzinfo`-underklass metoder bör därför vara "
"förberedda på att acceptera ett *dt*-argument av ``None``, eller av klassen :"
"class:`.datetime`."

msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best "
"response. For example, returning ``None`` is appropriate if the class wishes "
"to say that time objects don't participate in the :class:`tzinfo` protocols. "
"It may be more useful for ``utcoffset(None)`` to return the standard UTC "
"offset, as there is no other convention for discovering the standard offset."
msgstr ""
"När ``None`` skickas, är det upp till klassens designer att bestämma det "
"bästa svaret. Att returnera ``None`` är till exempel lämpligt om klassen "
"vill säga att tidsobjekt inte deltar i :class:`tzinfo`-protokollen. Det kan "
"vara mer användbart för ``utcoffset(None)`` att returnera standard UTC-"
"offset, eftersom det inte finns någon annan konvention för att upptäcka "
"standardoffset."

msgid ""
"When a :class:`.datetime` object is passed in response to a :class:`."
"datetime` method, ``dt.tzinfo`` is the same object as *self*. :class:"
"`tzinfo` methods can rely on this, unless user code calls :class:`tzinfo` "
"methods directly. The intent is that the :class:`tzinfo` methods interpret "
"*dt* as being in local time, and not need worry about objects in other time "
"zones."
msgstr ""
"När ett :class:`.datetime`-objekt skickas som svar till en :class:`."
"datetime`-metod är ``dt.tzinfo`` samma objekt som *self*. :class:`tzinfo`-"
"metoder kan förlita sig på detta, såvida inte användarkoden anropar :class:"
"`tzinfo`-metoder direkt. Avsikten är att :class:`tzinfo`-metoderna ska tolka "
"*dt* som lokal tid och inte behöva bekymra sig om objekt i andra tidszoner."

msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr ""
"Det finns ytterligare en :class:`tzinfo`-metod som en subklass kan vilja "
"åsidosätta:"

msgid ""
"This is called from the default :meth:`datetime.astimezone` implementation. "
"When called from that, ``dt.tzinfo`` is *self*, and *dt*'s date and time "
"data are to be viewed as expressing a UTC time. The purpose of :meth:"
"`fromutc` is to adjust the date and time data, returning an equivalent "
"datetime in *self*'s local time."
msgstr ""
"Detta anropas från standardimplementeringen :meth:`datetime.astimezone`. När "
"det anropas därifrån är ``dt.tzinfo`` *self*, och *dt*:s datum- och tidsdata "
"ska ses som uttryck för en UTC-tid. Syftet med :meth:`fromutc` är att "
"justera datum- och tidsdata och returnera en motsvarande datatid i *self*:s "
"lokala tid."

msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default :meth:"
"`fromutc` implementation without problems. It's strong enough to handle "
"fixed-offset time zones, and time zones accounting for both standard and "
"daylight time, and the latter even if the DST transition times differ in "
"different years. An example of a time zone the default :meth:`fromutc` "
"implementation may not handle correctly in all cases is one where the "
"standard offset (from UTC) depends on the specific date and time passed, "
"which can happen for political reasons. The default implementations of :meth:"
"`~.datetime.astimezone` and :meth:`fromutc` may not produce the result you "
"want if the result is one of the hours straddling the moment the standard "
"offset changes."
msgstr ""
"De flesta :class:`tzinfo`-underklasser bör kunna ärva "
"standardimplementeringen av :meth:`fromutc` utan problem. Den är "
"tillräckligt stark för att hantera tidszoner med fast offset och tidszoner "
"som redovisar både standardtid och sommartid, och det senare även om "
"övergångstiderna till sommartid skiljer sig åt mellan olika år. Ett exempel "
"på en tidszon som standardimplementeringen av :meth:`fromutc` kanske inte "
"hanterar korrekt i alla fall är en tidszon där standardförskjutningen (från "
"UTC) beror på det specifika datumet och tiden som passerat, vilket kan hända "
"av politiska skäl. Standardimplementeringarna av :meth:`~.datetime."
"astimezone` och :meth:`fromutc` kanske inte ger det resultat du vill ha om "
"resultatet är en av de timmar som sträcker sig över det ögonblick då "
"standardförskjutningen ändras."

msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation "
"acts like::"
msgstr ""
"Standardimplementeringen av :meth:`fromutc`, som hoppar över kod för "
"felfall, fungerar på följande sätt::"

msgid ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"
msgstr ""
"def fromutc(self, dt):\n"
"    # raise ValueError fel om dt.tzinfo inte är self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # ger upphov till ValueError om dtoff är None eller dtdst är None\n"
"    delta = dtoff - dtdst # detta är self:s standardförskjutning\n"
"    if delta:\n"
"        dt += delta # konvertera till lokal standardtid\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError om dtdst är None\n"
"    if dtdst:\n"
"        returnera dt + dtdst\n"
"    else:\n"
"        returnera dt"

msgid ""
"In the following :download:`tzinfo_examples.py <../includes/tzinfo_examples."
"py>` file there are some examples of :class:`tzinfo` classes:"
msgstr ""
"I följande :download:`tzinfo_examples.py <../includes/tzinfo_examples.py>`-"
"fil finns några exempel på :class:`tzinfo`-klasser:"

msgid ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"
msgstr ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"SECOND = timedelta(seconds=1)\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"# (May result in wrong values on historical times in\n"
"#  timezones where UTC offset and/or the DST rules had\n"
"#  changed in the past.)\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND\n"
"        args = _time.localtime(stamp)[:6]\n"
"        dst_diff = DSTDIFF // SECOND\n"
"        # Detect fold\n"
"        fold = (args == _time.localtime(stamp - dst_diff))\n"
"        return datetime(*args, microsecond=dt.microsecond,\n"
"                        tzinfo=self, fold=fold)\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, 0)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# https://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 2)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time) on the last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 2)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time)\n"
"# on the last Sunday of October, which is the first Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"def us_dst_range(year):\n"
"    # Find start and end times for US DST. For years before 1967, return\n"
"    # start = end for no DST.\n"
"    if 2006 < year:\n"
"        dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"    elif 1986 < year < 2007:\n"
"        dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"    elif 1966 < year < 1987:\n"
"        dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"    else:\n"
"        return (datetime(year, 1, 1), ) * 2\n"
"\n"
"    start = first_sunday_on_or_after(dststart.replace(year=year))\n"
"    end = first_sunday_on_or_after(dstend.replace(year=year))\n"
"    return start, end\n"
"\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        dt = dt.replace(tzinfo=None)\n"
"        if start + HOUR <= dt < end - HOUR:\n"
"            # DST is in effect.\n"
"            return HOUR\n"
"        if end - HOUR <= dt < end:\n"
"            # Fold (an ambiguous hour): use dt.fold to disambiguate.\n"
"            return ZERO if dt.fold else HOUR\n"
"        if start <= dt < start + HOUR:\n"
"            # Gap (a non-existent hour): reverse the fold rule.\n"
"            return HOUR if dt.fold else ZERO\n"
"        # DST is off.\n"
"        return ZERO\n"
"\n"
"    def fromutc(self, dt):\n"
"        assert dt.tzinfo is self\n"
"        start, end = us_dst_range(dt.year)\n"
"        start = start.replace(tzinfo=self)\n"
"        end = end.replace(tzinfo=self)\n"
"        std_time = dt + self.stdoffset\n"
"        dst_time = std_time + HOUR\n"
"        if end <= dst_time < end + HOUR:\n"
"            # Repeated hour\n"
"            return std_time.replace(fold=1)\n"
"        if std_time < start or dst_time >= end:\n"
"            # Standard time\n"
"            return std_time\n"
"        if start <= std_time < end - HOUR:\n"
"            # Daylight saving time\n"
"            return dst_time\n"
"\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"

msgid ""
"Note that there are unavoidable subtleties twice per year in a :class:"
"`tzinfo` subclass accounting for both standard and daylight time, at the DST "
"transition points. For concreteness, consider US Eastern (UTC -0500), where "
"EDT begins the minute after 1:59 (EST) on the second Sunday in March, and "
"ends the minute after 1:59 (EDT) on the first Sunday in November::"
msgstr ""
"Observera att det finns oundvikliga subtiliteter två gånger per år i en :"
"class:`tzinfo`-underklass som tar hänsyn till både standardtid och "
"sommartid, vid övergångspunkterna för sommartid. För att vara konkret, tänk "
"på US Eastern (UTC -0500), där EDT börjar minuten efter 1:59 (EST) den andra "
"söndagen i mars och slutar minuten efter 1:59 (EDT) den första söndagen i "
"november::"

msgid ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"
msgstr ""
"  UTC 3:MM 4:MM 5:MM 6:MM 7:MM 8:MM\n"
"  EST 22:MM 23:MM 0:MM 1:MM 2:MM 3:MM\n"
"  EDT 23:MM 0:MM 1:MM 2:MM 3:MM 4:MM\n"
"\n"
"start 22:MM 23:MM 0:MM 1:MM 3:MM 4:MM\n"
"\n"
"  slut 23:MM 0:MM 1:MM 1:MM 2:MM 3:MM"

msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from 1:59 "
"to 3:00. A wall time of the form 2:MM doesn't really make sense on that day, "
"so ``astimezone(Eastern)`` won't deliver a result with ``hour == 2`` on the "
"day DST begins. For example, at the Spring forward transition of 2016, we "
"get::"
msgstr ""
"När DST startar (startlinjen) hoppar den lokala väggklockan från 1:59 till "
"3:00. En väggtid av formen 2:MM är inte riktigt meningsfull den dagen, så "
"``astimezone(Eastern)`` kommer inte att leverera ett resultat med ``hour == "
"2`` den dagen DST börjar. Till exempel, vid vårens framåtriktade övergång "
"2016 får vi::"

msgid ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"
msgstr ""
">>> from datetime import datetime, timezone\n"
">>> from tzinfo_examples import HOUR, Eastern\n"
">>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname())\n"
"...\n"
"05:00:00 UTC = 00:00:00 EST\n"
"06:00:00 UTC = 01:00:00 EST\n"
"07:00:00 UTC = 03:00:00 EDT\n"
"08:00:00 UTC = 04:00:00 EDT"

msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: the "
"last hour of daylight time. In Eastern, that's times of the form 5:MM UTC on "
"the day daylight time ends. The local wall clock leaps from 1:59 (daylight "
"time) back to 1:00 (standard time) again. Local times of the form 1:MM are "
"ambiguous. :meth:`~.datetime.astimezone` mimics the local clock's behavior "
"by mapping two adjacent UTC hours into the same local hour then. In the "
"Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when "
"converted to Eastern, but earlier times have the :attr:`~.datetime.fold` "
"attribute set to 0 and the later times have it set to 1. For example, at the "
"Fall back transition of 2016, we get::"
msgstr ""
"När sommartiden upphör (raden \"end\") uppstår ett potentiellt värre "
"problem: det finns en timme som inte kan stavas entydigt i lokal väggtid: "
"den sista timmen med sommartid. I Eastern är det tider av formen 5:MM UTC på "
"den dag då sommartiden slutar. Den lokala väggklockan hoppar från 1:59 "
"(sommartid) tillbaka till 1:00 (normaltid) igen. Lokala tider av formen 1:MM "
"är tvetydiga. :meth:`~.datetime.astimezone` efterliknar den lokala klockans "
"beteende genom att mappa två intilliggande UTC-timmar till samma lokala "
"timme. I exemplet Eastern mappar UTC-tider av formen 5:MM och 6:MM båda till "
"1:MM när de konverteras till Eastern, men de tidigare tiderna har "
"attributet :attr:`~.datetime.fold` satt till 0 och de senare tiderna har det "
"satt till 1. Till exempel, vid övergången Fall back 2016, får vi::"

msgid ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)\n"
">>> for i in range(4):\n"
"...     u = u0 + i*HOUR\n"
"...     t = u.astimezone(Eastern)\n"
"...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"
msgstr ""
">>> u0 = datetime(2016, 11, 6, 4, tzinfo=tidszon.utc)\n"
">>> för i i intervall(4):\n"
"... u = u0 + i*HOUR\n"
"... t = u.astimezone(Eastern)\n"
"... print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)\n"
"...\n"
"04:00:00 UTC = 00:00:00 EDT 0\n"
"05:00:00 UTC = 01:00:00 EDT 0\n"
"06:00:00 UTC = 01:00:00 EST 1\n"
"07:00:00 UTC = 02:00:00 EST 0"

msgid ""
"Note that the :class:`.datetime` instances that differ only by the value of "
"the :attr:`~.datetime.fold` attribute are considered equal in comparisons."
msgstr ""
"Observera att :class:`.datetime`-instanser som skiljer sig åt endast genom "
"värdet på attributet :attr:`~.datetime.fold` betraktas som likvärdiga i "
"jämförelser."

msgid ""
"Applications that can't bear wall-time ambiguities should explicitly check "
"the value of the :attr:`~.datetime.fold` attribute or avoid using hybrid :"
"class:`tzinfo` subclasses; there are no ambiguities when using :class:"
"`timezone`, or any other fixed-offset :class:`tzinfo` subclass (such as a "
"class representing only EST (fixed offset -5 hours), or only EDT (fixed "
"offset -4 hours))."
msgstr ""
"Program som inte tål tvetydigheter i väggtid bör uttryckligen kontrollera "
"värdet på attributet :attr:`~.datetime.fold` eller undvika att använda "
"hybrid-underklasser av :class:`tzinfo`; det finns inga tvetydigheter när man "
"använder :class:`timezone` eller någon annan underklass av :class:`tzinfo` "
"med fast offset (t.ex. en klass som endast representerar EST (fast offset -5 "
"timmar) eller endast EDT (fast offset -4 timmar))."

msgid ":mod:`zoneinfo`"
msgstr ":mod:`zoneinfo`"

msgid ""
"The :mod:`!datetime` module has a basic :class:`timezone` class (for "
"handling arbitrary fixed offsets from UTC) and its :attr:`timezone.utc` "
"attribute (a UTC :class:`!timezone` instance)."
msgstr ""
"Modulen :mod:`!datetime` har en grundläggande :class:`timezone`-klass (för "
"hantering av godtyckliga fasta förskjutningar från UTC) och dess :attr:"
"`timezone.utc`-attribut (en UTC :class:`!timezone`-instans)."

msgid ""
"``zoneinfo`` brings the *IANA time zone database* (also known as the Olson "
"database) to Python, and its usage is recommended."
msgstr ""
"``zoneinfo`` ger *IANA-tidszonsdatabasen* (även känd som Olson-databasen) "
"till Python, och dess användning rekommenderas."

msgid "`IANA time zone database <https://www.iana.org/time-zones>`_"
msgstr "`IANA tidszon databas <https://www.iana.org/time-zones>`_"

msgid ""
"The Time Zone Database (often called tz, tzdata or zoneinfo) contains code "
"and data that represent the history of local time for many representative "
"locations around the globe. It is updated periodically to reflect changes "
"made by political bodies to time zone boundaries, UTC offsets, and daylight-"
"saving rules."
msgstr ""
"Time Zone Database (ofta kallad tz, tzdata eller zoneinfo) innehåller kod "
"och data som representerar den lokala tidens historia för många "
"representativa platser runt om i världen. Den uppdateras regelbundet för att "
"återspegla ändringar som gjorts av politiska organ i tidszonsgränser, UTC-"
"förskjutningar och regler för sommartid."

msgid ":class:`timezone` Objects"
msgstr ":class:`tidszon` Objekt"

msgid ""
"The :class:`timezone` class is a subclass of :class:`tzinfo`, each instance "
"of which represents a time zone defined by a fixed offset from UTC."
msgstr ""
"Klassen :class:`timezone` är en underklass till :class:`tzinfo`, där varje "
"instans representerar en tidszon som definieras av en fast förskjutning från "
"UTC."

msgid ""
"Objects of this class cannot be used to represent time zone information in "
"the locations where different offsets are used in different days of the year "
"or where historical changes have been made to civil time."
msgstr ""
"Objekt av denna klass kan inte användas för att representera "
"tidszonsinformation på platser där olika förskjutningar används under olika "
"dagar på året eller där historiska förändringar har gjorts av civiltiden."

msgid ""
"The *offset* argument must be specified as a :class:`timedelta` object "
"representing the difference between the local time and UTC. It must be "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)``, "
"otherwise :exc:`ValueError` is raised."
msgstr ""
"Argumentet *offset* måste anges som ett :class:`timedelta`-objekt som "
"representerar skillnaden mellan den lokala tiden och UTC. Det måste vara "
"strikt mellan ``-timedelta(hours=24)`` och ``timedelta(hours=24)``, annars "
"uppstår :exc:`ValueError`."

msgid ""
"The *name* argument is optional. If specified it must be a string that will "
"be used as the value returned by the :meth:`datetime.tzname` method."
msgstr ""
"Argumentet *name* är valfritt. Om det anges måste det vara en sträng som "
"kommer att användas som det värde som returneras av :meth:`datetime.tzname`-"
"metoden."

msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed."
msgstr ""
"Returnerar det fasta värde som anges när :class:`timezone`-instansen "
"konstrueras."

msgid ""
"The *dt* argument is ignored. The return value is a :class:`timedelta` "
"instance equal to the difference between the local time and UTC."
msgstr ""
"Argumentet *dt* ignoreras. Returvärdet är en :class:`timedelta`-instans som "
"är lika med skillnaden mellan den lokala tiden och UTC."

msgid ""
"If *name* is not provided in the constructor, the name returned by "
"``tzname(dt)`` is generated from the value of the ``offset`` as follows. If "
"*offset* is ``timedelta(0)``, the name is \"UTC\", otherwise it is a string "
"in the format ``UTC±HH:MM``, where ± is the sign of ``offset``, HH and MM "
"are two digits of ``offset.hours`` and ``offset.minutes`` respectively."
msgstr ""
"Om *name* inte anges i konstruktorn, genereras det namn som returneras av "
"``tzname(dt)`` från värdet på ``offset`` enligt följande. Om *offset* är "
"``timedelta(0)`` är namnet \"UTC\", annars är det en sträng i formatet "
"``UTC±HH:MM``, där ± är tecknet för ``offset``, HH och MM är två siffror i "
"``offset.hours`` respektive ``offset.minutes``."

msgid ""
"Name generated from ``offset=timedelta(0)`` is now plain ``'UTC'``, not "
"``'UTC+00:00'``."
msgstr ""
"Namn som genereras från ``offset=timedelta(0)`` är nu vanligt ``'UTC'``, "
"inte ``'UTC+00:00'``."

msgid "Always returns ``None``."
msgstr "Returnerar alltid ``None``."

msgid ""
"Return ``dt + offset``. The *dt* argument must be an aware :class:`."
"datetime` instance, with ``tzinfo`` set to ``self``."
msgstr ""
"Returnerar ``dt + offset``. Argumentet *dt* måste vara en medveten :class:`."
"datetime`-instans, med ``tzinfo`` satt till ``self``."

msgid "The UTC time zone, ``timezone(timedelta(0))``."
msgstr "UTC-tidszonen, ``timezone(timedelta(0))``."

msgid ":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Behavior"
msgstr ":meth:`~.datetime.strftime` och :meth:`~.datetime.strptime` Behavior"

msgid ""
":class:`date`, :class:`.datetime`, and :class:`.time` objects all support a "
"``strftime(format)`` method, to create a string representing the time under "
"the control of an explicit format string."
msgstr ""
"objekten :class:`date`, :class:`.datetime` och :class:`.time` har alla stöd "
"för metoden ``strftime(format)``, som skapar en sträng som representerar "
"tiden under kontroll av en explicit formatsträng."

msgid ""
"Conversely, the :meth:`date.strptime`, :meth:`datetime.strptime` and :meth:"
"`time.strptime` class methods create an object from a string representing "
"the time and a corresponding format string."
msgstr ""
"Omvänt skapar klassmetoderna :meth:`date.strptime`, :meth:`datetime."
"strptime` och :meth:`time.strptime` ett objekt från en sträng som "
"representerar tiden och en motsvarande formatsträng."

msgid ""
"The table below provides a high-level comparison of :meth:`~.datetime."
"strftime` versus :meth:`~.datetime.strptime`:"
msgstr ""
"Tabellen nedan ger en jämförelse på hög nivå mellan :meth:`~.datetime."
"strftime` och :meth:`~.datetime.strptime`:"

msgid "``strftime``"
msgstr "``strftime``"

msgid "``strptime``"
msgstr "``strptime``"

msgid "Usage"
msgstr "Användning"

msgid "Convert object to a string according to a given format"
msgstr "Konverterar objekt till en sträng enligt ett givet format"

msgid "Parse a string into an object given a corresponding format"
msgstr "Parsa en sträng till ett objekt med ett motsvarande format"

msgid "Type of method"
msgstr "Typ av metod"

msgid "Instance method"
msgstr "Instansmetod"

msgid "Class method"
msgstr "Klassmetod"

msgid "Signature"
msgstr "Underskrift"

msgid "``strftime(format)``"
msgstr "``strftime(format)```"

msgid "``strptime(date_string, format)``"
msgstr "``strptime(datum_sträng, format)``"

msgid ""
":meth:`~.datetime.strftime` and :meth:`~.datetime.strptime` Format Codes"
msgstr ""
":meth:`~.datetime.strftime` och :meth:`~.datetime.strptime` Formatkoder"

msgid ""
"These methods accept format codes that can be used to parse and format "
"dates::"
msgstr ""
"Dessa metoder accepterar formatkoder som kan användas för att analysera och "
"formatera datum::"

msgid ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"'Mon 31 Jan 2022, 11:59PM'"
msgstr ""
">>> datetime.strptime('31/01/22 23:59:59.999999',\n"
"...                   '%d/%m/%y %H:%M:%S.%f')\n"
"datetime.datetime(2022, 1, 31, 23, 59, 59, 59, 999999)\n"
">>> _.strftime('%a %d %b %Y, %I:%M%p')\n"
"\"Mån 31 jan 2022, 11:59PM"

msgid ""
"The following is a list of all the format codes that the 1989 C standard "
"requires, and these work on all platforms with a standard C implementation."
msgstr ""
"Nedan följer en lista över alla formatkoder som krävs enligt 1989 års C-"
"standard, och dessa fungerar på alla plattformar med en standard C-"
"implementering."

msgid "Directive"
msgstr "Direktiv"

msgid "Meaning"
msgstr "Betydelse"

msgid "Example"
msgstr "Exempel"

msgid "Notes"
msgstr "Anteckningar"

msgid "``%a``"
msgstr "``%a``"

msgid "Weekday as locale's abbreviated name."
msgstr "Veckodag som lokalens förkortade namn."

msgid "Sun, Mon, ..., Sat (en_US);"
msgstr "Sön, mån, ..., lör (en_US);"

msgid "So, Mo, ..., Sa (de_DE)"
msgstr "Så, Mo, ..., Sa (de_DE)"

msgid "``%A``"
msgstr "``%A``"

msgid "Weekday as locale's full name."
msgstr "Veckodag som lokalens fullständiga namn."

msgid "Sunday, Monday, ..., Saturday (en_US);"
msgstr "Söndag, måndag, ..., lördag (en_US);"

msgid "Sonntag, Montag, ..., Samstag (de_DE)"
msgstr "Sonntag, Montag, ..., Samstag (de_DE)"

msgid "``%w``"
msgstr "``%w``"

msgid "Weekday as a decimal number, where 0 is Sunday and 6 is Saturday."
msgstr "Veckodag som ett decimaltal, där 0 är söndag och 6 är lördag."

msgid "0, 1, ..., 6"
msgstr "0, 1, ..., 6"

msgid "``%d``"
msgstr "``%d``"

msgid "Day of the month as a zero-padded decimal number."
msgstr "Månadens dag som ett nollställt decimaltal."

msgid "01, 02, ..., 31"
msgstr "01, 02, ..., 31"

msgid "\\(9)"
msgstr "\\(9)"

msgid "``%b``"
msgstr "``%b``"

msgid "Month as locale's abbreviated name."
msgstr "Månad som lokalens förkortade namn."

msgid "Jan, Feb, ..., Dec (en_US);"
msgstr "Jan, feb, ..., dec (en_US);"

msgid "Jan, Feb, ..., Dez (de_DE)"
msgstr "Jan, Feb, ..., Dez (de_DE)"

msgid "``%B``"
msgstr "``%B``"

msgid "Month as locale's full name."
msgstr "Månad som lokalens fullständiga namn."

msgid "January, February, ..., December (en_US);"
msgstr "Januari, februari, ..., december (en_US);"

msgid "Januar, Februar, ..., Dezember (de_DE)"
msgstr "Januari, februari, ..., december (de_DE)"

msgid "``%m``"
msgstr "``%m``"

msgid "Month as a zero-padded decimal number."
msgstr "Månad som ett nollfyllt decimaltal."

msgid "01, 02, ..., 12"
msgstr "01, 02, ..., 12"

msgid "``%y``"
msgstr "``%y``"

msgid "Year without century as a zero-padded decimal number."
msgstr "Årtal utan sekel som nollställt decimaltal."

msgid "00, 01, ..., 99"
msgstr "00, 01, ..., 99"

msgid "``%Y``"
msgstr "``%Y``"

msgid "Year with century as a decimal number."
msgstr "År med sekel som decimaltal."

msgid "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"
msgstr "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"

msgid "``%H``"
msgstr "``%H``"

msgid "Hour (24-hour clock) as a zero-padded decimal number."
msgstr "Timme (24-timmarsklocka) som ett decimaltal med nolltillägg."

msgid "00, 01, ..., 23"
msgstr "00, 01, ..., 23"

msgid "``%I``"
msgstr "``%I``"

msgid "Hour (12-hour clock) as a zero-padded decimal number."
msgstr "Timme (12-timmars klocka) som ett decimaltal med nolltillägg."

msgid "``%p``"
msgstr "``%p``"

msgid "Locale's equivalent of either AM or PM."
msgstr "Lokalens motsvarighet till antingen AM eller PM."

msgid "AM, PM (en_US);"
msgstr "AM, PM (en_US);"

msgid "am, pm (de_DE)"
msgstr "am, pm (de_DE)"

msgid "\\(1), \\(3)"
msgstr "\\(1), \\(3)"

msgid "``%M``"
msgstr "``%M``"

msgid "Minute as a zero-padded decimal number."
msgstr "Minut som ett nollfyllt decimaltal."

msgid "00, 01, ..., 59"
msgstr "00, 01, ..., 59"

msgid "``%S``"
msgstr "``%S``"

msgid "Second as a zero-padded decimal number."
msgstr "Andra som ett nollfyllt decimaltal."

msgid "\\(4), \\(9)"
msgstr "\\(4), \\(9)"

msgid "``%f``"
msgstr "``%f``"

msgid "Microsecond as a decimal number, zero-padded to 6 digits."
msgstr "Mikrosekund som ett decimaltal, nollställt till 6 siffror."

msgid "000000, 000001, ..., 999999"
msgstr "000000, 000001, ..., 999999"

msgid "\\(5)"
msgstr "\\(5)"

msgid "``%z``"
msgstr "``%z``"

msgid ""
"UTC offset in the form ``±HHMM[SS[.ffffff]]`` (empty string if the object is "
"naive)."
msgstr ""
"UTC-offset i formen ``±HHMM[SS[.ffffff]]`` (tom sträng om objektet är naivt)."

msgid "(empty), +0000, -0400, +1030, +063415, -030712.345216"
msgstr "(tom), +0000, -0400, +1030, +063415, -030712.345216"

msgid "\\(6)"
msgstr "\\(6)"

msgid "``%Z``"
msgstr "``%Z``"

msgid "Time zone name (empty string if the object is naive)."
msgstr "Tidszonens namn (tom sträng om objektet är naivt)."

msgid "(empty), UTC, GMT"
msgstr "(tom), UTC, GMT"

msgid "``%j``"
msgstr "``%j``"

msgid "Day of the year as a zero-padded decimal number."
msgstr "Årets dag som ett nollställt decimaltal."

msgid "001, 002, ..., 366"
msgstr "001, 002, ..., 366"

msgid "``%U``"
msgstr "``%U``"

msgid ""
"Week number of the year (Sunday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Sunday are "
"considered to be in week 0."
msgstr ""
"Veckonummer för året (söndag som första dag i veckan) som ett nollställt "
"decimaltal. Alla dagar i ett nytt år som föregår den första söndagen anses "
"vara i vecka 0."

msgid "00, 01, ..., 53"
msgstr "00, 01, ..., 53"

msgid "\\(7), \\(9)"
msgstr "\\(7), \\(9)"

msgid "``%W``"
msgstr "``%W``"

msgid ""
"Week number of the year (Monday as the first day of the week) as a zero-"
"padded decimal number. All days in a new year preceding the first Monday are "
"considered to be in week 0."
msgstr ""
"Veckonummer för året (måndag som första dag i veckan) som ett nollställt "
"decimaltal. Alla dagar i ett nytt år som föregår den första måndagen anses "
"vara i vecka 0."

msgid "``%c``"
msgstr "``%c``"

msgid "Locale's appropriate date and time representation."
msgstr "Locales lämpliga datum- och tidsrepresentation."

msgid "Tue Aug 16 21:30:00 1988 (en_US);"
msgstr "Tue Aug 16 21:30:00 1988 (en_US);"

msgid "Di 16 Aug 21:30:00 1988 (de_DE)"
msgstr "Di 16 Aug 21:30:00 1988 (de_DE)"

msgid "``%x``"
msgstr "``%x``"

msgid "Locale's appropriate date representation."
msgstr "Locales lämpliga datumrepresentation."

msgid "08/16/88 (None);"
msgstr "08/16/88 (Ingen);"

msgid "08/16/1988 (en_US);"
msgstr "08/16/1988 (en_US);"

msgid "16.08.1988 (de_DE)"
msgstr "16.08.1988 (de_DE)"

msgid "``%X``"
msgstr "``%X``"

msgid "Locale's appropriate time representation."
msgstr "Locales lämpliga tidsrepresentation."

msgid "21:30:00 (en_US);"
msgstr "21:30:00 (en_US);"

msgid "21:30:00 (de_DE)"
msgstr "21:30:00 (de_DE)"

msgid "``%%``"
msgstr "``%%``"

msgid "A literal ``'%'`` character."
msgstr "Ett bokstavligt ``'%'``-tecken."

msgid "%"
msgstr "%"

msgid ""
"Several additional directives not required by the C89 standard are included "
"for convenience. These parameters all correspond to ISO 8601 date values."
msgstr ""
"Flera ytterligare direktiv som inte krävs enligt C89-standarden ingår för "
"enkelhetens skull. Alla dessa parametrar motsvarar ISO 8601 datumvärden."

msgid "``%G``"
msgstr "``%G``"

msgid ""
"ISO 8601 year with century representing the year that contains the greater "
"part of the ISO week (``%V``)."
msgstr ""
"ISO 8601 år med århundrade som representerar det år som innehåller större "
"delen av ISO-veckan (``%V``)."

msgid "\\(8)"
msgstr "\\(8)"

msgid "``%u``"
msgstr "``%u``"

msgid "ISO 8601 weekday as a decimal number where 1 is Monday."
msgstr "ISO 8601 veckodag som ett decimaltal där 1 är måndag."

msgid "1, 2, ..., 7"
msgstr "1, 2, ..., 7"

msgid "``%V``"
msgstr "``%V``"

msgid ""
"ISO 8601 week as a decimal number with Monday as the first day of the week. "
"Week 01 is the week containing Jan 4."
msgstr ""
"ISO 8601-vecka som ett decimaltal med måndag som första dag i veckan. Vecka "
"01 är den vecka som innehåller den 4 januari."

msgid "01, 02, ..., 53"
msgstr "01, 02, ..., 53"

msgid "\\(8), \\(9)"
msgstr "\\(8), \\(9)"

msgid "``%:z``"
msgstr "``%:z``"

msgid ""
"UTC offset in the form ``±HH:MM[:SS[.ffffff]]`` (empty string if the object "
"is naive)."
msgstr ""
"UTC-offset i formen ``±HH:MM[:SS[.ffffff]]`` (tom sträng om objektet är "
"naivt)."

msgid "(empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"
msgstr "(tom), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216"

msgid ""
"These may not be available on all platforms when used with the :meth:`~."
"datetime.strftime` method. The ISO 8601 year and ISO 8601 week directives "
"are not interchangeable with the year and week number directives above. "
"Calling :meth:`~.datetime.strptime` with incomplete or ambiguous ISO 8601 "
"directives will raise a :exc:`ValueError`."
msgstr ""
"Dessa kanske inte är tillgängliga på alla plattformar när de används med "
"metoden :meth:`~.datetime.strftime`. Direktiven ISO 8601 år och ISO 8601 "
"vecka är inte utbytbara med direktiven för år och veckonummer ovan. Anrop "
"av :meth:`~.datetime.strptime` med ofullständiga eller tvetydiga ISO 8601-"
"direktiv kommer att ge upphov till ett :exc:`ValueError`."

msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :c:func:`strftime` function, and "
"platform variations are common. To see the full set of format codes "
"supported on your platform, consult the :manpage:`strftime(3)` "
"documentation. There are also differences between platforms in handling of "
"unsupported format specifiers."
msgstr ""
"Den fullständiga uppsättningen formatkoder som stöds varierar mellan olika "
"plattformar, eftersom Python anropar plattform C-bibliotekets :c:func:"
"`strftime`-funktion, och plattformsvariationer är vanliga. För att se den "
"fullständiga uppsättningen formatkoder som stöds på din plattform, se :"
"manpage:`strftime(3)`-dokumentationen. Det finns också skillnader mellan "
"plattformar i hanteringen av formatspecifikatorer som inte stöds."

msgid "``%G``, ``%u`` and ``%V`` were added."
msgstr "``%G``, ``%u`` och ``%V`` lades till."

msgid "``%:z`` was added."
msgstr "``%:z`` lades till."

msgid "Technical Detail"
msgstr "Tekniska detaljer"

msgid ""
"Broadly speaking, ``d.strftime(fmt)`` acts like the :mod:`time` module's "
"``time.strftime(fmt, d.timetuple())`` although not all objects support a :"
"meth:`~date.timetuple` method."
msgstr ""
"I stort sett fungerar ``d.strftime(fmt)`` som :mod:`time`-modulens ``time."
"strftime(fmt, d.timetuple())`` även om inte alla objekt stöder en :meth:"
"`~date.timetuple`-metod."

msgid ""
"For the :meth:`.datetime.strptime` class method, the default value is "
"``1900-01-01T00:00:00.000``: any components not specified in the format "
"string will be pulled from the default value. [#]_"
msgstr ""
"För klassmetoden :meth:`.datetime.strptime` är standardvärdet "
"``1900-01-01T00:00:00.000``: alla komponenter som inte anges i "
"formatsträngen hämtas från standardvärdet. [#]_"

msgid "Using ``datetime.strptime(date_string, format)`` is equivalent to::"
msgstr ""
"Att använda ``datetime.strptime(date_string, format)`` är likvärdigt med::"

msgid ""
"except when the format includes sub-second components or time zone offset "
"information, which are supported in ``datetime.strptime`` but are discarded "
"by ``time.strptime``."
msgstr ""
"utom när formatet innehåller subsekundkomponenter eller information om "
"tidszonsförskjutning, som stöds i ``datetime.strptime`` men kasseras av "
"``time.strptime``."

msgid ""
"For :class:`.time` objects, the format codes for year, month, and day should "
"not be used, as :class:`!time` objects have no such values. If they're used "
"anyway, 1900 is substituted for the year, and 1 for the month and day."
msgstr ""
"För :class:`.time`-objekt bör formatkoderna för år, månad och dag inte "
"användas, eftersom :class:`!time`-objekt inte har några sådana värden. Om de "
"ändå används, ersätts år med 1900 och månad och dag med 1."

msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, and "
"microseconds should not be used, as :class:`date` objects have no such "
"values. If they're used anyway, 0 is substituted for them."
msgstr ""
"För :class:`date`-objekt ska formatkoderna för timmar, minuter, sekunder och "
"mikrosekunder inte användas, eftersom :class:`date`-objekt inte har några "
"sådana värden. Om de ändå används, ersätts de med 0."

msgid ""
"For the same reason, handling of format strings containing Unicode code "
"points that can't be represented in the charset of the current locale is "
"also platform-dependent. On some platforms such code points are preserved "
"intact in the output, while on others ``strftime`` may raise :exc:"
"`UnicodeError` or return an empty string instead."
msgstr ""
"Av samma anledning är hanteringen av formatsträngar som innehåller Unicode-"
"kodpunkter som inte kan representeras i den aktuella lokalens "
"teckenuppsättning också plattformsberoende. På vissa plattformar bevaras "
"sådana kodpunkter intakta i utdata, medan på andra kan ``strftime`` ge "
"upphov till :exc:`UnicodeError` eller returnera en tom sträng istället."

msgid ""
"Because the format depends on the current locale, care should be taken when "
"making assumptions about the output value. Field orderings will vary (for "
"example, \"month/day/year\" versus \"day/month/year\"), and the output may "
"contain non-ASCII characters."
msgstr ""
"Eftersom formatet beror på den aktuella språkdräkten bör man vara försiktig "
"när man gör antaganden om utdatavärdet. Fältordningen kan variera (t.ex. "
"\"månad/dag/år\" jämfört med \"dag/månad/år\") och utdata kan innehålla icke-"
"ASCII-tecken."

msgid ""
"The :meth:`~.datetime.strptime` method can parse years in the full [1, 9999] "
"range, but years < 1000 must be zero-filled to 4-digit width."
msgstr ""
"Metoden :meth:`~.datetime.strptime` kan tolka årtal i hela intervallet [1, "
"9999], men år < 1000 måste nollställas till 4-siffrig bredd."

msgid ""
"In previous versions, :meth:`~.datetime.strftime` method was restricted to "
"years >= 1900."
msgstr ""
"I tidigare versioner var metoden :meth:`~.datetime.strftime` begränsad till "
"år >= 1900."

msgid ""
"In version 3.2, :meth:`~.datetime.strftime` method was restricted to years "
">= 1000."
msgstr ""
"I version 3.2 var metoden :meth:`~.datetime.strftime` begränsad till år >= "
"1000."

msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%p`` directive "
"only affects the output hour field if the ``%I`` directive is used to parse "
"the hour."
msgstr ""
"När det används med metoden :meth:`~.datetime.strptime` påverkar direktivet "
"``%p`` endast fältet för utmatad timme om direktivet ``%I`` används för att "
"analysera timmen."

msgid ""
"Unlike the :mod:`time` module, the :mod:`!datetime` module does not support "
"leap seconds."
msgstr ""
"Till skillnad från modulen :mod:`time` har modulen :mod:`!datetime` inte "
"stöd för skottsekunder."

msgid ""
"When used with the :meth:`~.datetime.strptime` method, the ``%f`` directive "
"accepts from one to six digits and zero pads on the right. ``%f`` is an "
"extension to the set of format characters in the C standard (but implemented "
"separately in datetime objects, and therefore always available)."
msgstr ""
"När det används med metoden :meth:`~.datetime.strptime` accepterar "
"direktivet ``%f`` en till sex siffror och nollställen till höger. ``%f`` är "
"en utökning av uppsättningen formattecken i C-standarden (men implementeras "
"separat i datetime-objekt och är därför alltid tillgängliga)."

msgid ""
"For a naive object, the ``%z``, ``%:z`` and ``%Z`` format codes are replaced "
"by empty strings."
msgstr ""
"För ett naivt objekt ersätts formatkoderna ``%z``, ``%:z`` och ``%Z`` med "
"tomma strängar."

msgid "For an aware object:"
msgstr "För ett medvetet objekt:"

msgid ""
":meth:`~.datetime.utcoffset` is transformed into a string of the form "
"``±HHMM[SS[.ffffff]]``, where ``HH`` is a 2-digit string giving the number "
"of UTC offset hours, ``MM`` is a 2-digit string giving the number of UTC "
"offset minutes, ``SS`` is a 2-digit string giving the number of UTC offset "
"seconds and ``ffffff`` is a 6-digit string giving the number of UTC offset "
"microseconds. The ``ffffff`` part is omitted when the offset is a whole "
"number of seconds and both the ``ffffff`` and the ``SS`` part is omitted "
"when the offset is a whole number of minutes. For example, if :meth:`~."
"datetime.utcoffset` returns ``timedelta(hours=-3, minutes=-30)``, ``%z`` is "
"replaced with the string ``'-0330'``."
msgstr ""
":meth:`~.datetime.utcoffset` omvandlas till en sträng av formen ``±HHMM[SS[."
"ffffff]]``, där ``HH`` är en tvåsiffrig sträng som anger antalet UTC-"
"förskjutna timmar, ``MM`` är en tvåsiffrig sträng som anger antalet UTC-"
"förskjutna minuter, ``SS`` är en tvåsiffrig sträng som anger antalet UTC-"
"förskjutna sekunder och ``ffffffff`` är en sexsiffrig sträng som anger "
"antalet UTC-förskjutna mikrosekunder. Delen ``ffffffff`` utelämnas när "
"förskjutningen är ett helt antal sekunder och både delen ``ffffffff`` och "
"``SS`` utelämnas när förskjutningen är ett helt antal minuter. Om :meth:`~."
"datetime.utcoffset` till exempel returnerar ``timedelta(hours=-3, "
"minutes=-30)``, ersätts ``%z`` med strängen ``'-0330'``."

msgid ""
"When the ``%z`` directive is provided to the  :meth:`~.datetime.strptime` "
"method, the UTC offsets can have a colon as a separator between hours, "
"minutes and seconds. For example, ``'+01:00:00'`` will be parsed as an "
"offset of one hour. In addition, providing ``'Z'`` is identical to "
"``'+00:00'``."
msgstr ""
"När direktivet ``%z`` ges till metoden :meth:`~.datetime.strptime` kan UTC-"
"offseten ha ett kolon som separator mellan timmar, minuter och sekunder. "
"Till exempel kommer ``'+01:00:00'`` att tolkas som en förskjutning på en "
"timme. Att ange ``'Z'`` är dessutom identiskt med ``'+00:00'``."

msgid ""
"Behaves exactly as ``%z``, but has a colon separator added between hours, "
"minutes and seconds."
msgstr ""
"Uppför sig exakt som ``%z``, men har en kolonavgränsare mellan timmar, "
"minuter och sekunder."

msgid ""
"In :meth:`~.datetime.strftime`, ``%Z`` is replaced by an empty string if :"
"meth:`~.datetime.tzname` returns ``None``; otherwise ``%Z`` is replaced by "
"the returned value, which must be a string."
msgstr ""
"I :meth:`~.datetime.strftime` ersätts ``%Z`` med en tom sträng om :meth:`~."
"datetime.tzname` returnerar ``None``; annars ersätts ``%Z`` med det "
"returnerade värdet, som måste vara en sträng."

msgid ":meth:`~.datetime.strptime` only accepts certain values for ``%Z``:"
msgstr ":meth:`~.datetime.strptime` accepterar bara vissa värden för ``%Z``:"

msgid "any value in ``time.tzname`` for your machine's locale"
msgstr "valfritt värde i ``time.tzname`` för din maskins locale"

msgid "the hard-coded values ``UTC`` and ``GMT``"
msgstr "de hårdkodade värdena ``UTC`` och ``GMT``"

msgid ""
"So someone living in Japan may have ``JST``, ``UTC``, and ``GMT`` as valid "
"values, but probably not ``EST``. It will raise ``ValueError`` for invalid "
"values."
msgstr ""
"Så någon som bor i Japan kan ha ``JST``, ``UTC`` och ``GMT`` som giltiga "
"värden, men förmodligen inte ``EST``. Det kommer att ge upphov till "
"``ValueError`` för ogiltiga värden."

msgid ""
"When the ``%z`` directive is provided to the :meth:`~.datetime.strptime` "
"method, an aware :class:`.datetime` object will be produced. The ``tzinfo`` "
"of the result will be set to a :class:`timezone` instance."
msgstr ""
"När direktivet ``%z`` ges till metoden :meth:`~.datetime.strptime`, kommer "
"ett medvetet :class:`.datetime`-objekt att produceras. Resultatets "
"``tzinfo`` kommer att sättas till en :class:`timezone`-instans."

msgid ""
"When used with the :meth:`~.datetime.strptime` method, ``%U`` and ``%W`` are "
"only used in calculations when the day of the week and the calendar year "
"(``%Y``) are specified."
msgstr ""
"När de används med metoden :meth:`~.datetime.strptime` används ``%U`` och "
"``%W`` endast i beräkningar när veckodagen och kalenderåret (``%Y``) anges."

msgid ""
"Similar to ``%U`` and ``%W``, ``%V`` is only used in calculations when the "
"day of the week and the ISO year (``%G``) are specified in a :meth:`~."
"datetime.strptime` format string. Also note that ``%G`` and ``%Y`` are not "
"interchangeable."
msgstr ""
"I likhet med ``%U`` och ``%W`` används ``%V`` endast i beräkningar när "
"veckodagen och ISO-året (``%G``) anges i en :meth:`~.datetime.strptime`-"
"formatsträng. Observera också att ``%G`` och ``%Y`` inte är utbytbara."

msgid ""
"When used with the :meth:`~.datetime.strptime` method, the leading zero is "
"optional for  formats ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W``, and ``%V``. Format ``%y`` does require a leading "
"zero."
msgstr ""
"När den används med metoden :meth:`~.datetime.strptime` är den inledande "
"nollan valfri för formaten ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, "
"``%j``, ``%U``, ``%W`` och ``%V``. Formatet ``%y`` kräver en inledande nolla."

msgid ""
"When parsing a month and day using :meth:`~.datetime.strptime`, always "
"include a year in the format.  If the value you need to parse lacks a year, "
"append an explicit dummy leap year.  Otherwise your code will raise an "
"exception when it encounters leap day because the default year used by the "
"parser is not a leap year.  Users run into this bug every four years..."
msgstr ""
"När du analyserar en månad och dag med :meth:`~.datetime.strptime` ska du "
"alltid inkludera ett år i formatet.  Om det värde du behöver analysera "
"saknar ett år, lägg till ett explicit dummy skottår.  Annars kommer din kod "
"att ge upphov till ett undantag när den stöter på skottdagen eftersom det "
"standardår som används av parsern inte är ett skottår.  Användare stöter på "
"den här buggen vart fjärde år..."

msgid ""
">>> month_day = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\")  # No leap year "
"bug.\n"
"datetime.datetime(1984, 2, 29, 0, 0)"
msgstr ""
">>> månad_dag = \"02/29\"\n"
">>> datetime.strptime(f\"{month_day};1984\",\"%m/%d;%Y\") # Inget fel med "
"skottår.\n"
"datetime.datetime(1984, 2, 29, 0, 0)"

msgid ""
":meth:`~.datetime.strptime` calls using a format string containing a day of "
"month without a year now emit a :exc:`DeprecationWarning`. In 3.15 or later "
"we may change this into an error or change the default year to a leap year. "
"See :gh:`70647`."
msgstr ""
":meth:`~.datetime.strptime` anrop som använder en formatsträng som "
"innehåller en dag i månaden utan årtal ger nu en :exc:`DeprecationWarning`. "
"I 3.15 eller senare kan vi ändra detta till ett fel eller ändra standardåret "
"till ett skottår. Se :gh:`70647`."

msgid "Footnotes"
msgstr "Fotnoter"

msgid "If, that is, we ignore the effects of Relativity"
msgstr "Om vi alltså bortser från effekterna av relativitetsteorin"

msgid ""
"This matches the definition of the \"proleptic Gregorian\" calendar in "
"Dershowitz and Reingold's book *Calendrical Calculations*, where it's the "
"base calendar for all computations. See the book for algorithms for "
"converting between proleptic Gregorian ordinals and many other calendar "
"systems."
msgstr ""
"Detta stämmer överens med definitionen av den \"proleptiska gregorianska\" "
"kalendern i Dershowitz och Reingolds bok *Calendrical Calculations*, där den "
"är baskalendern för alla beräkningar. Se boken för algoritmer för "
"konvertering mellan proleptiska gregorianska ordinaler och många andra "
"kalendersystem."

msgid ""
"See R. H. van Gent's `guide to the mathematics of the ISO 8601 calendar "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/"
"~gent0113/calendar/isocalendar.htm>`_ for a good explanation."
msgstr ""
"Se R. H. van Gents \"Guide to the mathematics of the ISO 8601 calendar\" "
"<https://web.archive.org/web/20220531051136/https://webspace.science.uu.nl/"
"~gent0113/calendar/isocalendar.htm>`_ för en bra förklaring."

msgid ""
"Passing ``datetime.strptime('Feb 29', '%b %d')`` will fail since 1900 is not "
"a leap year."
msgstr ""
"Att skicka ``datetime.strptime('Feb 29', '%b %d')`` kommer att misslyckas "
"eftersom 1900 inte är ett skottår."

msgid "% (percent)"
msgstr "% (procent)"

msgid "datetime format"
msgstr "datetime-format"
