# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Sorting Techniques"
msgstr "Sorteringstekniker"

msgid "Author"
msgstr "Författare"

msgid "Andrew Dalke and Raymond Hettinger"
msgstr "Andrew Dalke och Raymond Hettinger"

msgid ""
"Python lists have a built-in :meth:`list.sort` method that modifies the list "
"in-place.  There is also a :func:`sorted` built-in function that builds a "
"new sorted list from an iterable."
msgstr ""
"Python-listor har en inbyggd :meth:`list.sort`-metod som modifierar listan "
"på plats.  Det finns också en inbyggd funktion :func:`sorted` som bygger en "
"ny sorterad lista från en iterabel."

msgid ""
"In this document, we explore the various techniques for sorting data using "
"Python."
msgstr ""
"I det här dokumentet utforskar vi olika tekniker för att sortera data med "
"hjälp av Python."

msgid "Sorting Basics"
msgstr "Sortering - grunderna"

msgid ""
"A simple ascending sort is very easy: just call the :func:`sorted` function. "
"It returns a new sorted list:"
msgstr ""
"En enkel stigande sortering är mycket enkel: anropa bara funktionen :func:"
"`sorted`. Den returnerar en ny sorterad lista:"

msgid ""
">>> sorted([5, 2, 3, 1, 4])\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> sorted([5, 2, 3, 1, 4])\n"
"[1, 2, 3, 4, 5]"

msgid ""
"You can also use the :meth:`list.sort` method. It modifies the list in-place "
"(and returns ``None`` to avoid confusion). Usually it's less convenient "
"than :func:`sorted` - but if you don't need the original list, it's slightly "
"more efficient."
msgstr ""
"Du kan också använda metoden :meth:`list.sort`. Den ändrar listan på plats "
"(och returnerar ``None`` för att undvika förvirring). Vanligtvis är det "
"mindre bekvämt än :func:`sorted` - men om du inte behöver den ursprungliga "
"listan är det något mer effektivt."

msgid ""
">>> a = [5, 2, 3, 1, 4]\n"
">>> a.sort()\n"
">>> a\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> a = [5, 2, 3, 1, 4]\n"
">>> a.sort()\n"
">>> a\n"
"[1, 2, 3, 4, 5]"

msgid ""
"Another difference is that the :meth:`list.sort` method is only defined for "
"lists. In contrast, the :func:`sorted` function accepts any iterable."
msgstr ""
"En annan skillnad är att metoden :meth:`list.sort` endast är definierad för "
"listor. Däremot accepterar funktionen :func:`sorted` vilken iterabel som "
"helst."

msgid ""
">>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\n"
"[1, 2, 3, 4, 5]"
msgstr ""
">>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})\n"
"[1, 2, 3, 4, 5]"

msgid "Key Functions"
msgstr "Viktiga funktioner"

msgid ""
"The :meth:`list.sort` method and the functions :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nsmallest`, and :func:`heapq.nlargest` have a *key* "
"parameter to specify a function (or other callable) to be called on each "
"list element prior to making comparisons."
msgstr ""
"Metoden :meth:`list.sort` och funktionerna :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nsmallest` och :func:`heapq.nlargest` har en *key*-"
"parameter för att ange en funktion (eller annan anropsbar funktion) som ska "
"anropas för varje listelement innan jämförelser görs."

msgid ""
"For example, here's a case-insensitive string comparison using :meth:`str."
"casefold`:"
msgstr ""
"Här är till exempel en strängjämförelse utan skiftlägeskänslighet med hjälp "
"av :meth:`str.casefold`:"

msgid ""
">>> sorted(\"This is a test string from Andrew\".split(), key=str.casefold)\n"
"['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']"
msgstr ""
">>> sorted(\"This is a test string from Andrew\".split(), key=str.casefold)\n"
"['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']"

msgid ""
"The value of the *key* parameter should be a function (or other callable) "
"that takes a single argument and returns a key to use for sorting purposes. "
"This technique is fast because the key function is called exactly once for "
"each input record."
msgstr ""
"Värdet på parametern *key* bör vara en funktion (eller annan anropsbar "
"funktion) som tar ett enda argument och returnerar en nyckel som kan "
"användas för sortering. Den här tekniken är snabb eftersom nyckelfunktionen "
"anropas exakt en gång för varje inmatad post."

msgid ""
"A common pattern is to sort complex objects using some of the object's "
"indices as keys. For example:"
msgstr ""
"Ett vanligt mönster är att sortera komplexa objekt med hjälp av några av "
"objektets index som nycklar. Ett exempel:"

msgid ""
">>> student_tuples = [\n"
"...     ('john', 'A', 15),\n"
"...     ('jane', 'B', 12),\n"
"...     ('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_tuples, key=lambda student: student[2])   # sort by age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> student_tuples = [\n"
"...     ('john', 'A', 15),\n"
"...     ('jane', 'B', 12),\n"
"...     ('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_tuples, key=lambda student: student[2])   # sort by age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

msgid ""
"The same technique works for objects with named attributes. For example:"
msgstr "Samma teknik fungerar för objekt med namngivna attribut. Till exempel:"

msgid ""
">>> class Student:\n"
"...     def __init__(self, name, grade, age):\n"
"...         self.name = name\n"
"...         self.grade = grade\n"
"...         self.age = age\n"
"...     def __repr__(self):\n"
"...         return repr((self.name, self.grade, self.age))\n"
"\n"
">>> student_objects = [\n"
"...     Student('john', 'A', 15),\n"
"...     Student('jane', 'B', 12),\n"
"...     Student('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_objects, key=lambda student: student.age)   # sort by "
"age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> class Student:\n"
"...     def __init__(self, name, grade, age):\n"
"...         self.name = name\n"
"...         self.grade = grade\n"
"...         self.age = age\n"
"...     def __repr__(self):\n"
"...         return repr((self.name, self.grade, self.age))\n"
"\n"
">>> student_objects = [\n"
"...     Student('john', 'A', 15),\n"
"...     Student('jane', 'B', 12),\n"
"...     Student('dave', 'B', 10),\n"
"... ]\n"
">>> sorted(student_objects, key=lambda student: student.age)   # sort by "
"age\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

msgid ""
"Objects with named attributes can be made by a regular class as shown above, "
"or they can be instances of :class:`~dataclasses.dataclass` or a :term:"
"`named tuple`."
msgstr ""
"Objekt med namngivna attribut kan skapas av en vanlig klass som visas ovan, "
"eller så kan de vara instanser av :class:`~dataclasses.dataclass` eller en :"
"term:`named tuple`."

msgid "Operator Module Functions and Partial Function Evaluation"
msgstr "Operatormodulens funktioner och utvärdering av partiella funktioner"

msgid ""
"The :term:`key function` patterns shown above are very common, so Python "
"provides convenience functions to make accessor functions easier and faster. "
"The :mod:`operator` module has :func:`~operator.itemgetter`, :func:"
"`~operator.attrgetter`, and a :func:`~operator.methodcaller` function."
msgstr ""
"Mönstren :term:`key function` ovan är mycket vanliga, så Python "
"tillhandahåller bekvämlighetsfunktioner för att göra accessorfunktioner "
"enklare och snabbare. Modulen :mod:`operator` har :func:`~operator."
"itemgetter`, :func:`~operator.attrgetter` och en :func:`~operator."
"methodcaller`-funktion."

msgid "Using those functions, the above examples become simpler and faster:"
msgstr "Med hjälp av dessa funktioner blir exemplen ovan enklare och snabbare:"

msgid ""
">>> from operator import itemgetter, attrgetter\n"
"\n"
">>> sorted(student_tuples, key=itemgetter(2))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> from operator import itemgetter, attrgetter\n"
"\n"
">>> sorted(student_tuples, key=itemgetter(2))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

msgid ""
"The operator module functions allow multiple levels of sorting. For example, "
"to sort by *grade* then by *age*:"
msgstr ""
"Operatormodulens funktioner tillåter flera sorteringsnivåer. Du kan till "
"exempel sortera efter *grad* och sedan efter *ålder*:"

msgid ""
">>> sorted(student_tuples, key=itemgetter(1,2))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('grade', 'age'))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]"
msgstr ""
">>> sorted(student_tuples, key=itemgetter(1,2))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('grade', 'age'))\n"
"[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]"

msgid ""
"The :mod:`functools` module provides another helpful tool for making key-"
"functions.  The :func:`~functools.partial` function can reduce the `arity "
"<https://en.wikipedia.org/wiki/Arity>`_ of a multi-argument function making "
"it suitable for use as a key-function."
msgstr ""
"Modulen :mod:`functools` tillhandahåller ett annat användbart verktyg för "
"att skapa nyckelfunktioner.  Funktionen :func:`~functools.partial` kan "
"minska `ariteten <https://en.wikipedia.org/wiki/Arity>`_ hos en funktion med "
"flera argument, vilket gör den lämplig att använda som en nyckelfunktion."

msgid ""
">>> from functools import partial\n"
">>> from unicodedata import normalize\n"
"\n"
">>> names = 'Zoë Åbjørn Núñez Élana Zeke Abe Nubia Eloise'.split()\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFD'))\n"
"['Abe', 'Åbjørn', 'Eloise', 'Élana', 'Nubia', 'Núñez', 'Zeke', 'Zoë']\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFC'))\n"
"['Abe', 'Eloise', 'Nubia', 'Núñez', 'Zeke', 'Zoë', 'Åbjørn', 'Élana']"
msgstr ""
">>> from functools import partial\n"
">>> from unicodedata import normalize\n"
"\n"
">>> names = 'Zoë Åbjørn Núñez Élana Zeke Abe Nubia Eloise'.split()\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFD'))\n"
"['Abe', 'Åbjørn', 'Eloise', 'Élana', 'Nubia', 'Núñez', 'Zeke', 'Zoë']\n"
"\n"
">>> sorted(names, key=partial(normalize, 'NFC'))\n"
"['Abe', 'Eloise', 'Nubia', 'Núñez', 'Zeke', 'Zoë', 'Åbjørn', 'Élana']"

msgid "Ascending and Descending"
msgstr "Stigande och fallande"

msgid ""
"Both :meth:`list.sort` and :func:`sorted` accept a *reverse* parameter with "
"a boolean value. This is used to flag descending sorts. For example, to get "
"the student data in reverse *age* order:"
msgstr ""
"Både :meth:`list.sort` och :func:`sorted` accepterar en *reverse* parameter "
"med ett booleskt värde. Detta används för att flagga nedåtgående "
"sorteringar. Till exempel för att få studentdata i omvänd *ålders* ordning:"

msgid ""
">>> sorted(student_tuples, key=itemgetter(2), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"
msgstr ""
">>> sorted(student_tuples, key=itemgetter(2), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n"
"\n"
">>> sorted(student_objects, key=attrgetter('age'), reverse=True)\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"

msgid "Sort Stability and Complex Sorts"
msgstr "Sorteringsstabilitet och komplexa sorteringar"

msgid ""
"Sorts are guaranteed to be `stable <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\. That means that when multiple records have "
"the same key, their original order is preserved."
msgstr ""
"Sorteringar är garanterat \"stabila\" <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\. Det innebär att när flera poster har samma "
"nyckel bevaras deras ursprungliga ordning."

msgid ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> sorted(data, key=itemgetter(0))\n"
"[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]"
msgstr ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> sorted(data, key=itemgetter(0))\n"
"[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]"

msgid ""
"Notice how the two records for *blue* retain their original order so that "
"``('blue', 1)`` is guaranteed to precede ``('blue', 2)``."
msgstr ""
"Lägg märke till hur de två posterna för *blue* behåller sin ursprungliga "
"ordning så att ``('blue', 1)`` garanterat kommer före ``('blue', 2)``."

msgid ""
"This wonderful property lets you build complex sorts in a series of sorting "
"steps. For example, to sort the student data by descending *grade* and then "
"ascending *age*, do the *age* sort first and then sort again using *grade*:"
msgstr ""
"Med denna underbara egenskap kan du bygga upp komplexa sorteringar i en "
"serie sorteringssteg. Om du t.ex. vill sortera elevdata efter fallande "
"*grad* och sedan stigande *ålder*, gör du först *ålder*-sorteringen och "
"sedan sorterar du igen med *grad*:"

msgid ""
">>> s = sorted(student_objects, key=attrgetter('age'))     # sort on "
"secondary key\n"
">>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on "
"primary key, descending\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> s = sorted(student_objects, key=attrgetter('age'))     # sort on "
"secondary key\n"
">>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on "
"primary key, descending\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

msgid ""
"This can be abstracted out into a wrapper function that can take a list and "
"tuples of field and order to sort them on multiple passes."
msgstr ""
"Detta kan abstraheras till en omslagsfunktion som kan ta en lista och tupler "
"av fält och ordning för att sortera dem i flera omgångar."

msgid ""
">>> def multisort(xs, specs):\n"
"...     for key, reverse in reversed(specs):\n"
"...         xs.sort(key=attrgetter(key), reverse=reverse)\n"
"...     return xs\n"
"\n"
">>> multisort(list(student_objects), (('grade', True), ('age', False)))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> def multisort(xs, specs):\n"
"...     for key, reverse in reversed(specs):\n"
"...         xs.sort(key=attrgetter(key), reverse=reverse)\n"
"...     return xs\n"
"\n"
">>> multisort(list(student_objects), (('grade', True), ('age', False)))\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

msgid ""
"The `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ algorithm used in "
"Python does multiple sorts efficiently because it can take advantage of any "
"ordering already present in a dataset."
msgstr ""
"Algoritmen `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ som används i "
"Python gör multipla sorteringar på ett effektivt sätt eftersom den kan dra "
"nytta av all ordning som redan finns i en dataset."

msgid "Decorate-Sort-Undecorate"
msgstr "Dekorera-Sortera-Undekorera"

msgid "This idiom is called Decorate-Sort-Undecorate after its three steps:"
msgstr "Detta idiom kallas Decorate-Sort-Undecorate efter sina tre steg:"

msgid ""
"First, the initial list is decorated with new values that control the sort "
"order."
msgstr ""
"Först dekoreras den ursprungliga listan med nya värden som styr "
"sorteringsordningen."

msgid "Second, the decorated list is sorted."
msgstr "För det andra sorteras den dekorerade listan."

msgid ""
"Finally, the decorations are removed, creating a list that contains only the "
"initial values in the new order."
msgstr ""
"Slutligen tas dekorationerna bort, vilket skapar en lista som endast "
"innehåller de ursprungliga värdena i den nya ordningen."

msgid ""
"For example, to sort the student data by *grade* using the DSU approach:"
msgstr ""
"Till exempel för att sortera studentdata efter *klass* med DSU-metoden:"

msgid ""
">>> decorated = [(student.grade, i, student) for i, student in "
"enumerate(student_objects)]\n"
">>> decorated.sort()\n"
">>> [student for grade, i, student in decorated]               # undecorate\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"
msgstr ""
">>> decorated = [(student.grade, i, student) for i, student in "
"enumerate(student_objects)]\n"
">>> decorated.sort()\n"
">>> [student for grade, i, student in decorated]               # undecorate\n"
"[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]"

msgid ""
"This idiom works because tuples are compared lexicographically; the first "
"items are compared; if they are the same then the second items are compared, "
"and so on."
msgstr ""
"Detta idiom fungerar eftersom tupler jämförs lexikografiskt; de första "
"objekten jämförs; om de är desamma jämförs de andra objekten, och så vidare."

msgid ""
"It is not strictly necessary in all cases to include the index *i* in the "
"decorated list, but including it gives two benefits:"
msgstr ""
"Det är inte alltid nödvändigt att inkludera index *i* i den dekorerade "
"listan, men det finns två fördelar med att inkludera det:"

msgid ""
"The sort is stable -- if two items have the same key, their order will be "
"preserved in the sorted list."
msgstr ""
"Sorteringen är stabil - om två objekt har samma nyckel kommer deras ordning "
"att bevaras i den sorterade listan."

msgid ""
"The original items do not have to be comparable because the ordering of the "
"decorated tuples will be determined by at most the first two items. So for "
"example the original list could contain complex numbers which cannot be "
"sorted directly."
msgstr ""
"De ursprungliga posterna behöver inte vara jämförbara eftersom ordningen på "
"de dekorerade tuplerna kommer att bestämmas av högst de två första posterna. "
"Den ursprungliga listan kan t.ex. innehålla komplexa tal som inte kan "
"sorteras direkt."

msgid ""
"Another name for this idiom is `Schwartzian transform <https://en.wikipedia."
"org/wiki/Schwartzian_transform>`_\\, after Randal L. Schwartz, who "
"popularized it among Perl programmers."
msgstr ""
"Ett annat namn för detta idiom är \"Schwartzian transform\" <https://en."
"wikipedia.org/wiki/Schwartzian_transform>`_\\, efter Randal L. Schwartz, som "
"populariserade det bland Perl-programmerare."

msgid ""
"Now that Python sorting provides key-functions, this technique is not often "
"needed."
msgstr ""
"Nu när Python-sortering tillhandahåller nyckelfunktioner behövs inte denna "
"teknik så ofta."

msgid "Comparison Functions"
msgstr "Jämförelsefunktioner"

msgid ""
"Unlike key functions that return an absolute value for sorting, a comparison "
"function computes the relative ordering for two inputs."
msgstr ""
"Till skillnad från nyckelfunktioner som returnerar ett absolut värde för "
"sortering, beräknar en jämförelsefunktion den relativa ordningen för två "
"indata."

msgid ""
"For example, a `balance scale <https://upload.wikimedia.org/wikipedia/"
"commons/1/17/Balance_à_tabac_1850.JPG>`_ compares two samples giving a "
"relative ordering: lighter, equal, or heavier. Likewise, a comparison "
"function such as ``cmp(a, b)`` will return a negative value for less-than, "
"zero if the inputs are equal, or a positive value for greater-than."
msgstr ""
"En \"balansskala\" <https://upload.wikimedia.org/wikipedia/commons/1/17/"
"Balance_à_tabac_1850.JPG>`_ jämför t.ex. två prover och ger en relativ "
"ordning: lättare, lika eller tyngre. På samma sätt kommer en "
"jämförelsefunktion som ``cmp(a, b)`` att returnera ett negativt värde för "
"mindre än, noll om indata är lika, eller ett positivt värde för större än."

msgid ""
"It is common to encounter comparison functions when translating algorithms "
"from other languages.  Also, some libraries provide comparison functions as "
"part of their API.  For example, :func:`locale.strcoll` is a comparison "
"function."
msgstr ""
"Det är vanligt att man stöter på jämförelsefunktioner när man översätter "
"algoritmer från andra språk.  Vissa bibliotek tillhandahåller också "
"jämförelsefunktioner som en del av sitt API.  Till exempel är :func:`locale."
"strcoll` en jämförelsefunktion."

msgid ""
"To accommodate those situations, Python provides :class:`functools."
"cmp_to_key` to wrap the comparison function to make it usable as a key "
"function::"
msgstr ""
"För att tillgodose dessa situationer tillhandahåller Python :class:"
"`functools.cmp_to_key` för att omsluta jämförelsefunktionen så att den kan "
"användas som en nyckelfunktion::"

msgid "sorted(words, key=cmp_to_key(strcoll))  # locale-aware sort order"
msgstr "sorted(words, key=cmp_to_key(strcoll))  # locale-aware sort order"

msgid "Strategies For Unorderable Types and Values"
msgstr "Strategier för oordningsbara typer och värden"

msgid ""
"A number of type and value issues can arise when sorting. Here are some "
"strategies that can help:"
msgstr ""
"Ett antal typ- och värdeproblem kan uppstå vid sortering. Här är några "
"strategier som kan hjälpa till:"

msgid "Convert non-comparable input types to strings prior to sorting:"
msgstr "Konvertera icke-jämförbara indatatyper till strängar före sortering:"

msgid ""
">>> data = ['twelve', '11', 10]\n"
">>> sorted(map(str, data))\n"
"['10', '11', 'twelve']"
msgstr ""
">>> data = ['twelve', '11', 10]\n"
">>> sorted(map(str, data))\n"
"['10', '11', 'twelve']"

msgid ""
"This is needed because most cross-type comparisons raise a :exc:`TypeError`."
msgstr ""
"Detta behövs eftersom de flesta korsvisa typjämförelser ger upphov till ett :"
"exc:`TypeError`."

msgid "Remove special values prior to sorting:"
msgstr "Avlägsna särskilda värden före sortering:"

msgid ""
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
">>> data = [3.3, float('nan'), 1.1, 2.2]\n"
">>> sorted(filterfalse(isnan, data))\n"
"[1.1, 2.2, 3.3]"
msgstr ""
">>> from math import isnan\n"
">>> from itertools import filterfalse\n"
">>> data = [3.3, float('nan'), 1.1, 2.2]\n"
">>> sorted(filterfalse(isnan, data))\n"
"[1.1, 2.2, 3.3]"

msgid ""
"This is needed because the `IEEE-754 standard <https://en.wikipedia.org/wiki/"
"IEEE_754>`_ specifies that, \"Every NaN shall compare unordered with "
"everything, including itself.\""
msgstr ""
"Detta behövs eftersom standarden `IEEE-754 <https://en.wikipedia.org/wiki/"
"IEEE_754>`_ anger att \"Varje NaN ska jämföra oordnat med allt, inklusive "
"sig själv.\""

msgid "Likewise, ``None`` can be stripped from datasets as well:"
msgstr "På samma sätt kan ``None`` också tas bort från dataset:"

msgid ""
">>> data = [3.3, None, 1.1, 2.2]\n"
">>> sorted(x for x in data if x is not None)\n"
"[1.1, 2.2, 3.3]"
msgstr ""
">>> data = [3.3, None, 1.1, 2.2]\n"
">>> sorted(x for x in data if x is not None)\n"
"[1.1, 2.2, 3.3]"

msgid "This is needed because ``None`` is not comparable to other types."
msgstr "Detta behövs eftersom ``None`` inte är jämförbar med andra typer."

msgid "Convert mapping types into sorted item lists before sorting:"
msgstr "Konvertera mappningstyper till sorterade objektlistor före sortering:"

msgid ""
">>> data = [{'a': 1}, {'b': 2}]\n"
">>> sorted(data, key=lambda d: sorted(d.items()))\n"
"[{'a': 1}, {'b': 2}]"
msgstr ""
">>> data = [{'a': 1}, {'b': 2}]\n"
">>> sorted(data, key=lambda d: sorted(d.items()))\n"
"[{'a': 1}, {'b': 2}]"

msgid ""
"This is needed because dict-to-dict comparisons raise a :exc:`TypeError`."
msgstr ""
"Detta behövs eftersom jämförelser mellan dikt och dikt ger upphov till ett :"
"exc:`TypeError`."

msgid "Convert set types into sorted lists before sorting:"
msgstr "Konvertera set-typer till sorterade listor före sortering:"

msgid ""
">>> data = [{'a', 'b', 'c'}, {'b', 'c', 'd'}]\n"
">>> sorted(map(sorted, data))\n"
"[['a', 'b', 'c'], ['b', 'c', 'd']]"
msgstr ""
">>> data = [{'a', 'b', 'c'}, {'b', 'c', 'd'}]\n"
">>> sorted(map(sorted, data))\n"
"[['a', 'b', 'c'], ['b', 'c', 'd']]"

msgid ""
"This is needed because the elements contained in set types do not have a "
"deterministic order.  For example, ``list({'a', 'b'})`` may produce either "
"``['a', 'b']`` or ``['b', 'a']``."
msgstr ""
"Detta behövs eftersom elementen i set-typer inte har en deterministisk "
"ordning.  Till exempel kan ``list({'a', 'b'})`` producera antingen ``['a', "
"'b']`` eller ``['b', 'a']``."

msgid "Odds and Ends"
msgstr "Lite av varje"

msgid ""
"For locale aware sorting, use :func:`locale.strxfrm` for a key function or :"
"func:`locale.strcoll` for a comparison function.  This is necessary because "
"\"alphabetical\" sort orderings can vary across cultures even if the "
"underlying alphabet is the same."
msgstr ""
"För lokalanpassad sortering, använd :func:`locale.strxfrm` för en "
"nyckelfunktion eller :func:`locale.strcoll` för en jämförelsefunktion.  "
"Detta är nödvändigt eftersom \"alfabetiska\" sorteringsordningar kan variera "
"mellan olika kulturer även om det underliggande alfabetet är detsamma."

msgid ""
"The *reverse* parameter still maintains sort stability (so that records with "
"equal keys retain the original order). Interestingly, that effect can be "
"simulated without the parameter by using the builtin :func:`reversed` "
"function twice:"
msgstr ""
"Parametern *reverse* upprätthåller fortfarande sorteringsstabiliteten (så "
"att poster med lika nycklar behåller den ursprungliga ordningen). Intressant "
"nog kan denna effekt simuleras utan parametern genom att använda den "
"inbyggda funktionen :func:`reversed` två gånger:"

msgid ""
">>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]\n"
">>> standard_way = sorted(data, key=itemgetter(0), reverse=True)\n"
">>> double_reversed = list(reversed(sorted(reversed(data), "
"key=itemgetter(0))))\n"
">>> assert standard_way == double_reversed\n"
">>> standard_way\n"
"[('red', 1), ('red', 2), ('blue', 1), ('blue', 2)]"
msgstr ""
">>> data = [('röd', 1), ('blå', 1), ('röd', 2), ('blå', 2)]\n"
">>> standard_way = sorterad(data, nyckel=itemgetter(0), reverse=True)\n"
">>> double_reversed = list(reversed(sorted(reversed(data), "
"key=itemgetter(0))))\n"
">>> assert standard_way == double_reversed\n"
">>> standard_väg\n"
"[('röd', 1), ('röd', 2), ('blå', 1), ('blå', 2)]"

msgid ""
"The sort routines use ``<`` when making comparisons between two objects. So, "
"it is easy to add a standard sort order to a class by defining an :meth:"
"`~object.__lt__` method:"
msgstr ""
"Sorteringsrutinerna använder ``<`` när de gör jämförelser mellan två objekt. "
"Det är alltså enkelt att lägga till en standardsorteringsordning i en klass "
"genom att definiera en :meth:`~object.__lt__`-metod:"

msgid ""
">>> Student.__lt__ = lambda self, other: self.age < other.age\n"
">>> sorted(student_objects)\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"
msgstr ""
">>> Student.__lt__ = lambda self, other: self.ålder < other.ålder\n"
">>> sorterad(student_objekt)\n"
"[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]"

msgid ""
"However, note that ``<`` can fall back to using :meth:`~object.__gt__` if :"
"meth:`~object.__lt__` is not implemented (see :func:`object.__lt__` for "
"details on the mechanics).  To avoid surprises, :pep:`8` recommends that all "
"six comparison methods be implemented. The :func:`~functools.total_ordering` "
"decorator is provided to make that task easier."
msgstr ""
"Observera dock att ``<`` kan falla tillbaka till att använda :meth:`~object."
"__gt__` om :meth:`~object.__lt__` inte är implementerad (se :func:`object."
"__lt__` för detaljer om mekaniken).  För att undvika överraskningar "
"rekommenderar :pep:`8` att alla sex jämförelsemetoderna implementeras. "
"Dekoratorn :func:`~functools.total_ordering` tillhandahålls för att göra den "
"uppgiften enklare."

msgid ""
"Key functions need not depend directly on the objects being sorted. A key "
"function can also access external resources. For instance, if the student "
"grades are stored in a dictionary, they can be used to sort a separate list "
"of student names:"
msgstr ""
"Nyckelfunktioner behöver inte vara direkt beroende av de objekt som "
"sorteras. En nyckelfunktion kan också komma åt externa resurser. Om t.ex. "
"elevbetygen lagras i en ordbok kan de användas för att sortera en separat "
"lista med elevnamn:"

msgid ""
">>> students = ['dave', 'john', 'jane']\n"
">>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}\n"
">>> sorted(students, key=newgrades.__getitem__)\n"
"['jane', 'dave', 'john']"
msgstr ""
">>> studenter = ['dave', 'john', 'jane']\n"
">>> newgrades = {'john': 'F', 'jane': 'A', 'dave': 'C'}\n"
">>> sorterad(studenter, nyckel=newgrades.__getitem__)\n"
"['jane', 'dave', 'john']"

msgid "Partial Sorts"
msgstr "Partiell sortering"

msgid ""
"Some applications require only some of the data to be ordered.  The standard "
"library provides several tools that do less work than a full sort:"
msgstr ""
"Vissa applikationer kräver att endast en del av datan ska sorteras.  "
"Standardbiblioteket innehåller flera verktyg som gör mindre arbete än en "
"fullständig sortering:"

msgid ""
":func:`min` and :func:`max` return the smallest and largest values, "
"respectively.  These functions make a single pass over the input data and "
"require almost no auxiliary memory."
msgstr ""
":func:`min` och :func:`max` returnerar det minsta respektive det största "
"värdet.  Dessa funktioner gör en enda genomgång av indata och kräver nästan "
"inget extra minne."

msgid ""
":func:`heapq.nsmallest` and :func:`heapq.nlargest` return the *n* smallest "
"and largest values, respectively.  These functions make a single pass over "
"the data keeping only *n* elements in memory at a time.  For values of *n* "
"that are small relative to the number of inputs, these functions make far "
"fewer comparisons than a full sort."
msgstr ""
":func:`heapq.nsmallest` och :func:`heapq.nlargest` returnerar de *n* minsta "
"respektive största värdena.  Dessa funktioner gör en enda genomgång av data "
"och behåller bara *n* element i minnet åt gången.  För värden på *n* som är "
"små i förhållande till antalet indata gör dessa funktioner mycket färre "
"jämförelser än en fullständig sortering."

msgid ""
":func:`heapq.heappush` and :func:`heapq.heappop` create and maintain a "
"partially sorted arrangement of data that keeps the smallest element at "
"position ``0``.  These functions are suitable for implementing priority "
"queues which are commonly used for task scheduling."
msgstr ""
":func:`heapq.heappush` och :func:`heapq.heappop` skapar och upprätthåller "
"ett delvis sorterat arrangemang av data som håller det minsta elementet på "
"position ``0``.  Dessa funktioner är lämpliga för att implementera "
"prioritetsköer som ofta används för schemaläggning av uppgifter."
