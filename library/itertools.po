# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 14:19+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid ""
":mod:`!itertools` --- Functions creating iterators for efficient looping"
msgstr ""
":mod:`!itertools` --- Funktioner som skapar iteratorer för effektiv loopning"

msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""
"Denna modul implementerar ett antal :term:`iterator`-byggstenar inspirerade "
"av konstruktioner från APL, Haskell och SML.  Var och en har omarbetats i en "
"form som passar Python."

msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""
"Modulen standardiserar en kärna av snabba, minneseffektiva verktyg som är "
"användbara var för sig eller i kombination.  Tillsammans bildar de en "
"\"iteratoralgebra\" som gör det möjligt att konstruera specialiserade "
"verktyg på ett kortfattat och effektivt sätt i ren Python."

msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""
"I SML finns till exempel ett verktyg för tabulering: ``tabulate(f)`` som "
"producerar en sekvens ``f(0), f(1), ...``.  Samma effekt kan uppnås i Python "
"genom att kombinera :func:`map` och :func:`count` för att bilda ``map(f, "
"count())``."

msgid "**Infinite iterators:**"
msgstr "**Obegränsade iteratorer: **"

msgid "Iterator"
msgstr "Iterator"

msgid "Arguments"
msgstr "Argument"

msgid "Results"
msgstr "Resultat"

msgid "Example"
msgstr "Exempel"

msgid ":func:`count`"
msgstr ":func:`count`"

msgid "[start[, step]]"
msgstr "[start[, step]]"

msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

msgid "``count(10) → 10 11 12 13 14 ...``"
msgstr "``count(10) → 10 11 12 13 14 ...``"

msgid ":func:`cycle`"
msgstr ":func:`cycle`"

msgid "p"
msgstr "p"

msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

msgid "``cycle('ABCD') → A B C D A B C D ...``"
msgstr "``cycle('ABCD') → A B C D A B C D ...``"

msgid ":func:`repeat`"
msgstr ":func:`repeat`"

msgid "elem [,n]"
msgstr "elem [,n]"

msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... oändligt eller upp till n gånger"

msgid "``repeat(10, 3) → 10 10 10``"
msgstr "``repeat(10, 3) → 10 10 10``"

msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**Iteratorer som slutar på den kortaste inmatningssekvensen: **"

msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

msgid "p [,func]"
msgstr "p [,func]"

msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

msgid "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) → 1 3 6 10 15``"

msgid ":func:`batched`"
msgstr ":func:`batched`"

msgid "p, n"
msgstr "p, n"

msgid "(p0, p1, ..., p_n-1), ..."
msgstr "(p0, p1, ..., p_n-1), ..."

msgid "``batched('ABCDEFG', n=2) → AB CD EF G``"
msgstr "``batched('ABCDEFG', n=2) → AB CD EF G``"

msgid ":func:`chain`"
msgstr ":func:`chain`"

msgid "p, q, ..."
msgstr "p, q, ..."

msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

msgid "``chain('ABC', 'DEF') → A B C D E F``"
msgstr "``chain('ABC', 'DEF') → A B C D E F``"

msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

msgid "iterable"
msgstr "itererbar"

msgid "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) → A B C D E F``"

msgid ":func:`compress`"
msgstr ":func:`compress`"

msgid "data, selectors"
msgstr "data, selectors"

msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

msgid "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) → A C E F``"

msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

msgid "predicate, seq"
msgstr "predicate, seq"

msgid "seq[n], seq[n+1], starting when predicate fails"
msgstr "seq[n], seq[n+1], startar när predikatet misslyckas"

msgid "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8``"

msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

msgid "elements of seq where predicate(elem) fails"
msgstr "element i seq där predikat(elem) misslyckas"

msgid "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"
msgstr "``filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8``"

msgid ":func:`groupby`"
msgstr ":func:`groupby`"

msgid "iterable[, key]"
msgstr "iterable[, key]"

msgid "sub-iterators grouped by value of key(v)"
msgstr "underiteratorer grupperade efter nyckelns värde(v)"

msgid "``groupby(['A','B','DEF'], len) → (1, A B) (3, DEF)``"
msgstr "``groupby(['A','B','DEF'], len) → (1, A B) (3, DEF)``"

msgid ":func:`islice`"
msgstr ":func:`islice`"

msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

msgid "elements from seq[start:stop:step]"
msgstr "element från seq[start:stopp:steg]"

msgid "``islice('ABCDEFG', 2, None) → C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) → C D E F G``"

msgid ":func:`pairwise`"
msgstr ":func:`pairwise`"

msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], p[1]), (p[1], p[2])"

msgid "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"
msgstr "``pairwise('ABCDEFG') → AB BC CD DE EF FG``"

msgid ":func:`starmap`"
msgstr ":func:`starmap`"

msgid "func, seq"
msgstr "func, seq"

msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000``"

msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

msgid "seq[0], seq[1], until predicate fails"
msgstr "seq[0], seq[1], tills predikatet misslyckas"

msgid "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4``"

msgid ":func:`tee`"
msgstr ":func:`tee`"

msgid "it, n"
msgstr "it, n"

msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn delar upp en iterator i n"

msgid "``tee('ABC', 2) → A B C, A B C``"
msgstr "``tee('ABC', 2) → A B C, A B C``"

msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

msgid "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-``"

msgid "**Combinatoric iterators:**"
msgstr "**Kombinatoriska iteratorer: **"

msgid ":func:`product`"
msgstr ":func:`product`"

msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

msgid "cartesian product, equivalent to a nested for-loop"
msgstr "cartesiansk produkt, motsvarande en nästlad for-loop"

msgid ":func:`permutations`"
msgstr ":func:`permutations`"

msgid "p[, r]"
msgstr "p[, r]"

msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr "r-längds tupler, alla möjliga ordningar, inga upprepade element"

msgid ":func:`combinations`"
msgstr ":func:`combinations`"

msgid "p, r"
msgstr "p, r"

msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "r-långa tupler, i sorterad ordning, inga upprepade element"

msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "r-långa tuples, i sorterad ordning, med upprepade element"

msgid "Examples"
msgstr "Exempel"

msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

msgid "Itertool Functions"
msgstr "Itertool-funktioner"

msgid ""
"The following functions all construct and return iterators. Some provide "
"streams of infinite length, so they should only be accessed by functions or "
"loops that truncate the stream."
msgstr ""
"Följande funktioner konstruerar och returnerar alla iteratorer. Vissa ger "
"oändligt långa strömmar, så de bör endast användas av funktioner eller "
"loopar som förkortar strömmen."

msgid ""
"Make an iterator that returns accumulated sums or accumulated results from "
"other binary functions."
msgstr ""
"Skapa en iterator som returnerar ackumulerade summor eller ackumulerade "
"resultat från andra binära funktioner."

msgid ""
"The *function* defaults to addition.  The *function* should accept two "
"arguments, an accumulated total and a value from the *iterable*."
msgstr ""
"Standardvärdet för *funktionen* är addition.  *Funktionen* ska acceptera två "
"argument, en ackumulerad summa och ett värde från *iterabeln*."

msgid ""
"If an *initial* value is provided, the accumulation will start with that "
"value and the output will have one more element than the input iterable."
msgstr ""
"Om ett *initial* värde anges kommer ackumuleringen att börja med det värdet "
"och utmatningen kommer att ha ett element mer än den ingående iterabeln."

msgid "Roughly equivalent to::"
msgstr "Ungefär motsvarande::"

msgid ""
"def accumulate(iterable, function=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) → 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120\n"
"\n"
"    iterator = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(iterator)\n"
"        except StopIteration:\n"
"            return\n"
"\n"
"    yield total\n"
"    for element in iterator:\n"
"        total = function(total, element)\n"
"        yield total"
msgstr ""
"def accumulate(iterable, function=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) → 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) → 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) → 1 2 6 24 120\n"
"\n"
"    iterator = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(iterator)\n"
"        except StopIteration:\n"
"            return\n"
"\n"
"    yield total\n"
"    for element in iterator:\n"
"        total = function(total, element)\n"
"        yield total"

msgid ""
"To compute a running minimum, set *function* to :func:`min`. For a running "
"maximum, set *function* to :func:`max`. Or for a running product, set "
"*function* to :func:`operator.mul`. To build an `amortization table <https://"
"www.ramseysolutions.com/real-estate/amortization-schedule>`_, accumulate the "
"interest and apply payments:"
msgstr ""
"För att beräkna ett löpande minimum, sätt *function* till :func:`min`. För "
"ett löpande maximum, sätt *function* till :func:`max`. Eller för en löpande "
"produkt, sätt *function* till :func:`operator.mul`. För att bygga en "
"\"amorteringstabell\" <https://www.ramseysolutions.com/real-estate/"
"amortization-schedule>`_, ackumulera räntan och använd betalningar:"

msgid ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, max))              # running maximum\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
">>> list(accumulate(data, operator.mul))     # running product\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
"\n"
"# Amortize a 5% loan of 1000 with 10 annual payments of 90\n"
">>> update = lambda balance, payment: round(balance * 1.05) - payment\n"
">>> list(accumulate(repeat(90, 10), update, initial=1_000))\n"
"[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]"
msgstr ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, max))              # running maximum\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
">>> list(accumulate(data, operator.mul))     # running product\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
"\n"
"# Amortize a 5% loan of 1000 with 10 annual payments of 90\n"
">>> update = lambda balance, payment: round(balance * 1.05) - payment\n"
">>> list(accumulate(repeat(90, 10), update, initial=1_000))\n"
"[1000, 960, 918, 874, 828, 779, 728, 674, 618, 559, 497]"

msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr ""
"Se :func:`functools.reduce` för en liknande funktion som bara returnerar det "
"slutliga ackumulerade värdet."

msgid "Added the optional *function* parameter."
msgstr "Lagt till den valfria parametern *function*."

msgid "Added the optional *initial* parameter."
msgstr "Den valfria parametern *initial* har lagts till."

msgid ""
"Batch data from the *iterable* into tuples of length *n*. The last batch may "
"be shorter than *n*."
msgstr ""
"Batcha data från *iterable* till tupler av längden *n*. Den sista satsen kan "
"vara kortare än *n*."

msgid ""
"If *strict* is true, will raise a :exc:`ValueError` if the final batch is "
"shorter than *n*."
msgstr ""
"Om *strict* är true, kommer ett :exc:`ValueError` att uppstå om den slutliga "
"batchen är kortare än *n*."

msgid ""
"Loops over the input iterable and accumulates data into tuples up to size "
"*n*.  The input is consumed lazily, just enough to fill a batch. The result "
"is yielded as soon as the batch is full or when the input iterable is "
"exhausted:"
msgstr ""
"Loopar över inmatningens iterabel och ackumulerar data i tupler upp till "
"storlek *n*.  Indata konsumeras lättsinnigt, bara tillräckligt för att fylla "
"en batch. Resultatet ges så snart batchen är full eller när den ingående "
"iterabeln är uttömd:"

msgid ""
">>> flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', 'sweet']\n"
">>> unflattened = list(batched(flattened_data, 2))\n"
">>> unflattened\n"
"[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]"
msgstr ""
">>> flattened_data = ['roses', 'red', 'violets', 'blue', 'sugar', 'sweet']\n"
">>> unflattened = list(batched(flattened_data, 2))\n"
">>> unflattened\n"
"[('roses', 'red'), ('violets', 'blue'), ('sugar', 'sweet')]"

msgid ""
"def batched(iterable, n, *, strict=False):\n"
"    # batched('ABCDEFG', 2) → AB CD EF G\n"
"    if n < 1:\n"
"        raise ValueError('n must be at least one')\n"
"    iterator = iter(iterable)\n"
"    while batch := tuple(islice(iterator, n)):\n"
"        if strict and len(batch) != n:\n"
"            raise ValueError('batched(): incomplete batch')\n"
"        yield batch"
msgstr ""
"def batched(iterabel, n, *, strict=False):\n"
"    # batched('ABCDEFG', 2) → AB CD EF G\n"
"    om n < 1:\n"
"        raise ValueError('n måste vara minst ett')\n"
"    iterator = iter(iterabel)\n"
"    while batch := tuple(islice(iterator, n)):\n"
"        if strict och len(batch) != n:\n"
"            raise ValueError('batched(): ofullständig batch')\n"
"        avkastning batch"

msgid "Added the *strict* option."
msgstr "Lagt till alternativet *strict*."

msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  This combines multiple data sources into a single iterator.  "
"Roughly equivalent to::"
msgstr ""
"Skapa en iterator som returnerar element från den första iterabeln tills den "
"är uttömd, sedan fortsätter den till nästa iterabel tills alla iterabler är "
"uttömda.  Detta kombinerar flera datakällor till en enda iterator.  Ungefär "
"likvärdigt med::"

msgid ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"

msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ""
"Alternativ konstruktör för :func:`chain`.  Får kedjade ingångar från ett "
"enda iterabelt argument som utvärderas latent.  Ungefär likvärdig med::"

msgid ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"
msgstr ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) → A B C D E F\n"
"    for iterable in iterables:\n"
"        yield from iterable"

msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr "Returnerar *r* långa undersekvenser av element från indata *iterable*."

msgid ""
"The output is a subsequence of :func:`product` keeping only entries that are "
"subsequences of the *iterable*.  The length of the output is given by :func:"
"`math.comb` which computes ``n! / r! / (n - r)!`` when ``0 ≤ r ≤ n`` or zero "
"when ``r > n``."
msgstr ""
"Utdata är en undersekvens av :func:`product` som bara innehåller poster som "
"är undersekvenser av *iterable*.  Längden på utmatningen ges av :func:`math."
"comb` som beräknar ``n! / r! / (n - r)!`` när ``0 ≤ r ≤ n`` eller noll när "
"``r > n``."

msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. If the input *iterable* is sorted, the output "
"tuples will be produced in sorted order."
msgstr ""
"Kombinationstuplarna skickas ut i lexikografisk ordning enligt ordningen i "
"indata *iterable*. Om indata *iterable* är sorterad, kommer utdatatuplarna "
"att produceras i sorterad ordning."

msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"If the input elements are unique, there will be no repeated values within "
"each combination."
msgstr ""
"Element behandlas som unika baserat på deras position, inte på deras värde.  "
"Om inmatningselementen är unika kommer det inte att finnas några upprepade "
"värden inom varje kombination."

msgid ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) → AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) → 012 013 023 123\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) → AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) → 012 013 023 123\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"

msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr ""
"Returnerar *r* långa undersekvenser av element från indata *iterable* vilket "
"gör att enskilda element kan upprepas mer än en gång."

msgid ""
"The output is a subsequence of :func:`product` that keeps only entries that "
"are subsequences (with possible repeated elements) of the *iterable*.  The "
"number of subsequence returned is ``(n + r - 1)! / r! / (n - 1)!`` when ``n "
"> 0``."
msgstr ""
"Utdata är en undersekvens av :func:`product` som endast innehåller poster "
"som är undersekvenser (med möjliga upprepade element) av *iterable*.  "
"Antalet undersekvenser som returneras är ``(n + r - 1)! / r! / (n - 1)!``` "
"när ``n > 0``."

msgid ""
"The combination tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. if the input *iterable* is sorted, the output "
"tuples will be produced in sorted order."
msgstr ""
"Kombinationstuplerna skickas ut i lexikografisk ordning enligt ordningen på "
"indata *iterable*. Om indata *iterable* är sorterad kommer utdatatuplerna "
"att produceras i sorterad ordning."

msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"If the input elements are unique, the generated combinations will also be "
"unique."
msgstr ""
"Element behandlas som unika baserat på deras position, inte på deras värde.  "
"Om inmatningselementen är unika kommer de genererade kombinationerna också "
"att vara unika."

msgid ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) → AA AB AC BB BC CC\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"

msgid ""
"Make an iterator that returns elements from *data* where the corresponding "
"element in *selectors* is true.  Stops when either the *data* or *selectors* "
"iterables have been exhausted.  Roughly equivalent to::"
msgstr ""
"Skapa en iterator som returnerar element från *data* där motsvarande element "
"i *selectors* är sant.  Stoppar när antingen iteratorerna *data* eller "
"*selectors* har uttömts.  Ungefär likvärdig med::"

msgid ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F\n"
"    return (datum for datum, selector in zip(data, selectors) if selector)"
msgstr ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) → A C E F\n"
"    return (datum for datum, selector in zip(data, selectors) if selector)"

msgid ""
"Make an iterator that returns evenly spaced values beginning with *start*. "
"Can be used with :func:`map` to generate consecutive data points or with :"
"func:`zip` to add sequence numbers.  Roughly equivalent to::"
msgstr ""
"Skapa en iterator som returnerar jämnt fördelade värden som börjar med "
"*start*. Kan användas med :func:`map` för att generera konsekutiva "
"datapunkter eller med :func:`zip` för att lägga till sekvensnummer.  Ungefär "
"likvärdig med::"

msgid ""
"def count(start=0, step=1):\n"
"    # count(10) → 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) → 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"
msgstr ""
"def count(start=0, step=1):\n"
"    # count(10) → 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) → 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"

msgid ""
"When counting with floating-point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""
"När man räknar med flyttal kan man ibland uppnå bättre noggrannhet genom att "
"ersätta multiplikativ kod som t.ex: ``(start + steg * i för i i count())``."

msgid "Added *step* argument and allowed non-integer arguments."
msgstr "Lagt till *step*-argumentet och tillåter argument som inte är heltal."

msgid ""
"Make an iterator returning elements from the *iterable* and saving a copy of "
"each.  When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"Skapa en iterator som returnerar element från *iterabeln* och sparar en "
"kopia av varje element.  När iterabeln är uttömd returnerar du element från "
"den sparade kopian.  Upprepas på obestämd tid.  Ungefär likvärdig med::"

msgid ""
"def cycle(iterable):\n"
"    # cycle('ABCD') → A B C D A B C D A B C D ...\n"
"\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"\n"
"    while saved:\n"
"        for element in saved:\n"
"            yield element"
msgstr ""
"def cycle(iterable):\n"
"    # cycle('ABCD') → A B C D A B C D A B C D ...\n"
"\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"\n"
"    while saved:\n"
"        for element in saved:\n"
"            yield element"

msgid ""
"This itertool may require significant auxiliary storage (depending on the "
"length of the iterable)."
msgstr ""
"Detta itertool kan kräva betydande extra lagring (beroende på iterabelns "
"längd)."

msgid ""
"Make an iterator that drops elements from the *iterable* while the "
"*predicate* is true and afterwards returns every element.  Roughly "
"equivalent to::"
msgstr ""
"Skapa en iterator som tar bort element från *iterable* medan *predicate* är "
"sant och därefter returnerar varje element.  Ungefär likvärdig med::"

msgid ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8\n"
"\n"
"    iterator = iter(iterable)\n"
"    for x in iterator:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"\n"
"    for x in iterator:\n"
"        yield x"
msgstr ""
"def dropwhile(predikat, iterabel):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,3,8]) → 6 3 8\n"
"\n"
"    iterator = iter(iterabel)\n"
"    för x i iterator:\n"
"        if not predicate(x):\n"
"            ge x\n"
"            bryt\n"
"\n"
"    för x i iterator:\n"
"        avkastning x"

msgid ""
"Note this does not produce *any* output until the predicate first becomes "
"false, so this itertool may have a lengthy start-up time."
msgstr ""
"Observera att detta inte producerar *någon* utdata förrän predikatet först "
"blir falskt, så detta itertool kan ha en lång starttid."

msgid ""
"Make an iterator that filters elements from the *iterable* returning only "
"those for which the *predicate* returns a false value.  If *predicate* is "
"``None``, returns the items that are false.  Roughly equivalent to::"
msgstr ""
"Skapa en iterator som filtrerar element från *iterable* och returnerar "
"endast de element för vilka *predicate* returnerar ett falskt värde.  Om "
"*predicate* är ``None``, returneras de objekt som är falska.  Ungefär "
"likvärdig med::"

msgid ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8\n"
"\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"
msgstr ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x<5, [1,4,6,3,8]) → 6 8\n"
"\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"

msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""
"Skapa en iterator som returnerar på varandra följande nycklar och grupper "
"från *iterable*. *key* är en funktion som beräknar ett nyckelvärde för varje "
"element.  Om den inte specificeras eller är ``None``, är *key* som standard "
"en identitetsfunktion och returnerar elementet oförändrat.  I allmänhet "
"måste iterabeln redan vara sorterad på samma nyckelfunktion."

msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""
":func:`groupby` fungerar på samma sätt som ``uniq``-filtret i Unix.  Det "
"genererar en paus eller en ny grupp varje gång värdet på nyckelfunktionen "
"ändras (vilket är anledningen till att det vanligtvis är nödvändigt att ha "
"sorterat data med samma nyckelfunktion).  Detta beteende skiljer sig från "
"SQL:s GROUP BY som aggregerar gemensamma element oberoende av deras "
"inmatningsordning."

msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""
"Den returnerade gruppen är i sig en iterator som delar den underliggande "
"iterabeln med :func:`groupby`.  Eftersom källan är delad är den föregående "
"gruppen inte längre synlig när :func:`groupby`-objektet flyttas fram.  Så om "
"dessa data behövs senare bör de lagras som en lista:"

msgid ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # Store group iterator as a list\n"
"    uniquekeys.append(k)"
msgstr ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # Store group iterator as a list\n"
"    uniquekeys.append(k)"

msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` är ungefär likvärdigt med::"

msgid ""
"def groupby(iterable, key=None):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D\n"
"\n"
"    keyfunc = (lambda x: x) if key is None else key\n"
"    iterator = iter(iterable)\n"
"    exhausted = False\n"
"\n"
"    def _grouper(target_key):\n"
"        nonlocal curr_value, curr_key, exhausted\n"
"        yield curr_value\n"
"        for curr_value in iterator:\n"
"            curr_key = keyfunc(curr_value)\n"
"            if curr_key != target_key:\n"
"                return\n"
"            yield curr_value\n"
"        exhausted = True\n"
"\n"
"    try:\n"
"        curr_value = next(iterator)\n"
"    except StopIteration:\n"
"        return\n"
"    curr_key = keyfunc(curr_value)\n"
"\n"
"    while not exhausted:\n"
"        target_key = curr_key\n"
"        curr_group = _grouper(target_key)\n"
"        yield curr_key, curr_group\n"
"        if curr_key == target_key:\n"
"            for _ in curr_group:\n"
"                pass"
msgstr ""
"def groupby(iterable, key=None):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] → A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] → AAAA BBB CC D\n"
"\n"
"    keyfunc = (lambda x: x) if key is None else key\n"
"    iterator = iter(iterable)\n"
"    exhausted = False\n"
"\n"
"    def _grouper(target_key):\n"
"        nonlocal curr_value, curr_key, exhausted\n"
"        yield curr_value\n"
"        for curr_value in iterator:\n"
"            curr_key = keyfunc(curr_value)\n"
"            if curr_key != target_key:\n"
"                return\n"
"            yield curr_value\n"
"        exhausted = True\n"
"\n"
"    try:\n"
"        curr_value = next(iterator)\n"
"    except StopIteration:\n"
"        return\n"
"    curr_key = keyfunc(curr_value)\n"
"\n"
"    while not exhausted:\n"
"        target_key = curr_key\n"
"        curr_group = _grouper(target_key)\n"
"        yield curr_key, curr_group\n"
"        if curr_key == target_key:\n"
"            for _ in curr_group:\n"
"                pass"

msgid ""
"Make an iterator that returns selected elements from the iterable. Works "
"like sequence slicing but does not support negative values for *start*, "
"*stop*, or *step*."
msgstr ""
"Skapa en iterator som returnerar valda element från iterabeln. Fungerar som "
"sequence slicing men stöder inte negativa värden för *start*, *stop* eller "
"*step*."

msgid ""
"If *start* is zero or ``None``, iteration starts at zero.  Otherwise, "
"elements from the iterable are skipped until *start* is reached."
msgstr ""
"Om *start* är noll eller ``None`` börjar iterationen vid noll.  I annat fall "
"hoppas element från iterationen över tills *start* nås."

msgid ""
"If *stop* is ``None``, iteration continues until the input is exhausted, if "
"at all.  Otherwise, it stops at the specified position."
msgstr ""
"Om *stop* är ``None`` fortsätter iterationen tills inmatningen är uttömd, om "
"alls.  Annars stannar den vid den angivna positionen."

msgid ""
"If *step* is ``None``, the step defaults to one.  Elements are returned "
"consecutively unless *step* is set higher than one which results in items "
"being skipped."
msgstr ""
"Om *step* är ``None`` är standardsteget ett.  Element returneras i följd "
"såvida inte *step* är högre än ett, vilket resulterar i att element hoppas "
"över."

msgid ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) → A B\n"
"    # islice('ABCDEFG', 2, 4) → C D\n"
"    # islice('ABCDEFG', 2, None) → C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) → A C E G\n"
"\n"
"    s = slice(*args)\n"
"    start = 0 if s.start is None else s.start\n"
"    stop = s.stop\n"
"    step = 1 if s.step is None else s.step\n"
"    if start < 0 or (stop is not None and stop < 0) or step <= 0:\n"
"        raise ValueError\n"
"\n"
"    indices = count() if stop is None else range(max(start, stop))\n"
"    next_i = start\n"
"    for i, element in zip(indices, iterable):\n"
"        if i == next_i:\n"
"            yield element\n"
"            next_i += step"
msgstr ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) → A B\n"
"    # islice('ABCDEFG', 2, 4) → C D\n"
"    # islice('ABCDEFG', 2, None) → C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) → A C E G\n"
"\n"
"    s = slice(*args)\n"
"    start = 0 if s.start is None else s.start\n"
"    stop = s.stop\n"
"    step = 1 if s.step is None else s.step\n"
"    if start < 0 or (stop is not None and stop < 0) or step <= 0:\n"
"        raise ValueError\n"
"\n"
"    indices = count() if stop is None else range(max(start, stop))\n"
"    next_i = start\n"
"    for i, element in zip(indices, iterable):\n"
"        if i == next_i:\n"
"            yield element\n"
"            next_i += step"

msgid ""
"If the input is an iterator, then fully consuming the *islice* advances the "
"input iterator by ``max(start, stop)`` steps regardless of the *step* value."
msgstr ""
"Om indata är en iterator, kommer fullständig konsumtion av *islice* att "
"flytta fram indata-iteratorn med ``max(start, stop)`` steg oavsett *step*-"
"värdet."

msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr "Returnerar successiva överlappande par hämtade från indata *iterable*."

msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two "
"values."
msgstr ""
"Antalet 2-tupler i utgångsiteratorn kommer att vara en färre än antalet "
"ingångar.  Den kommer att vara tom om inmatningsiterabeln har färre än två "
"värden."

msgid ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') → AB BC CD DE EF FG\n"
"\n"
"    iterator = iter(iterable)\n"
"    a = next(iterator, None)\n"
"\n"
"    for b in iterator:\n"
"        yield a, b\n"
"        a = b"
msgstr ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') → AB BC CD DE EF FG\n"
"\n"
"    iterator = iter(iterable)\n"
"    a = next(iterator, None)\n"
"\n"
"    for b in iterator:\n"
"        yield a, b\n"
"        a = b"

msgid ""
"Return successive *r* length `permutations of elements <https://www."
"britannica.com/science/permutation>`_ from the *iterable*."
msgstr ""
"Returnera successiva *r* långa `permutationer av element <https://www."
"britannica.com/science/permutation>`_ från *iterable*."

msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr ""
"Om *r* inte anges eller är ``None``, är *r* standardvärdet för längden på "
"*iterable* och alla möjliga permutationer med full längd genereras."

msgid ""
"The output is a subsequence of :func:`product` where entries with repeated "
"elements have been filtered out.  The length of the output is given by :func:"
"`math.perm` which computes ``n! / (n - r)!`` when ``0 ≤ r ≤ n`` or zero when "
"``r > n``."
msgstr ""
"Utdata är en delsekvens av :func:`product` där poster med upprepade element "
"har filtrerats bort.  Längden på utmatningen ges av :func:`math.perm` som "
"beräknar ``n! / (n - r)!`` när ``0 ≤ r ≤ n`` eller noll när ``r > n``."

msgid ""
"The permutation tuples are emitted in lexicographic order according to the "
"order of the input *iterable*.  If the input *iterable* is sorted, the "
"output tuples will be produced in sorted order."
msgstr ""
"Permutationstuplerna skickas ut i lexikografisk ordning enligt ordningen i "
"indata *iterable*.  Om indata *iterable* är sorterad, kommer utdatatuplarna "
"att produceras i sorterad ordning."

msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"If the input elements are unique, there will be no repeated values within a "
"permutation."
msgstr ""
"Elementen behandlas som unika baserat på deras position, inte på deras "
"värde.  Om inmatningselementen är unika kommer det inte att finnas några "
"upprepade värden inom en permutation."

msgid ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) → 012 021 102 120 201 210\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"
msgstr ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) → 012 021 102 120 201 210\n"
"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"

msgid ""
"`Cartesian product <https://en.wikipedia.org/wiki/Cartesian_product>`_ of "
"the input iterables."
msgstr ""
"`Cartesiansk produkt <https://en.wikipedia.org/wiki/Cartesian_product>`_ av "
"de ingående iterablerna."

msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""
"Motsvarar i stort sett kapslade for-slingor i ett generatoruttryck. Till "
"exempel ger ``product(A, B)`` samma resultat som ``((x,y) for x in A for y "
"in B)``."

msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""
"De nästlade looparna går som en odometer där elementet längst till höger "
"avancerar vid varje iteration.  Detta mönster skapar en lexikografisk "
"ordning så att om indatans iterabler är sorterade, skickas produkttuplerna "
"ut i sorterad ordning."

msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"Om du vill beräkna produkten av en iterabel med sig själv anger du antalet "
"repetitioner med det valfria nyckelordsargumentet *repeat*.  Till exempel "
"betyder ``product(A, repeat=4)`` samma sak som ``product(A, A, A, A)``."

msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr ""
"Denna funktion motsvarar i stort sett följande kod, förutom att den faktiska "
"implementeringen inte bygger upp mellanresultat i minnet::"

msgid ""
"def product(*iterables, repeat=1):\n"
"    # product('ABCD', 'xy') → Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) → 000 001 010 011 100 101 110 111\n"
"\n"
"    if repeat < 0:\n"
"        raise ValueError('repeat argument cannot be negative')\n"
"    pools = [tuple(pool) for pool in iterables] * repeat\n"
"\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"\n"
"    for prod in result:\n"
"        yield tuple(prod)"
msgstr ""
"def product(*iterables, repeat=1):\n"
"    # product('ABCD', 'xy') → Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) → 000 001 010 011 100 101 110 111\n"
"\n"
"    if repeat < 0:\n"
"        raise ValueError('repeat argument cannot be negative')\n"
"    pools = [tuple(pool) for pool in iterables] * repeat\n"
"\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"\n"
"    for prod in result:\n"
"        yield tuple(prod)"

msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it "
"is only useful with finite inputs."
msgstr ""
"Innan :func:`product` körs förbrukar den helt de ingående iterablerna och "
"behåller värdepooler i minnet för att generera produkterna.  Följaktligen är "
"den endast användbar med ändliga indata."

msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr ""
"Skapa en iterator som returnerar *objekt* om och om igen. Körs på obestämd "
"tid om inte argumentet *times* anges."

msgid ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) → 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"
msgstr ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) → 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"

msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*:"
msgstr ""
"En vanlig användning av *repeat* är att leverera en ström av konstanta "
"värden till *map* eller *zip*:"

msgid ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

msgid ""
"Make an iterator that computes the *function* using arguments obtained from "
"the *iterable*.  Used instead of :func:`map` when argument parameters have "
"already been \"pre-zipped\" into tuples."
msgstr ""
"Skapa en iterator som beräknar *funktionen* med hjälp av argument som hämtas "
"från *iterabeln*.  Används istället för :func:`map` när argumentparametrar "
"redan har \"förzippats\" till tupler."

msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""
"Skillnaden mellan :func:`map` och :func:`starmap` motsvarar skillnaden "
"mellan ``function(a,b)`` och ``function(*c)``. Ungefär likvärdig med::"

msgid ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"
msgstr ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) → 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"

msgid ""
"Make an iterator that returns elements from the *iterable* as long as the "
"*predicate* is true.  Roughly equivalent to::"
msgstr ""
"Gör en iterator som returnerar element från *iterable* så länge som "
"*predicate* är sant.  Ungefär likvärdig med::"

msgid ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            break\n"
"        yield x"
msgstr ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,3,8]) → 1 4\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            break\n"
"        yield x"

msgid ""
"Note, the element that first fails the predicate condition is consumed from "
"the input iterator and there is no way to access it. This could be an issue "
"if an application wants to further consume the input iterator after "
"*takewhile* has been run to exhaustion.  To work around this problem, "
"consider using `more-itertools before_and_after() <https://more-itertools."
"readthedocs.io/en/stable/api.html#more_itertools.before_and_after>`_ instead."
msgstr ""
"Observera att det element som först misslyckas med predikatsvillkoret "
"konsumeras från inmatningsiteratorn och det finns inget sätt att komma åt "
"det. Detta kan vara ett problem om en applikation vill fortsätta att "
"konsumera inmatningsiteratorn efter att *takewhile* har körts till "
"utmattning.  För att komma runt detta problem kan du överväga att använda "
"`more-itertools before_and_after() <https://more-itertools.readthedocs.io/en/"
"stable/api.html#more_itertools.before_and_after>`_ istället."

msgid "Return *n* independent iterators from a single iterable."
msgstr "Returnerar *n* oberoende iteratorer från en enda iterabel."

msgid ""
"def tee(iterable, n=2):\n"
"    if n < 0:\n"
"        raise ValueError\n"
"    if n == 0:\n"
"        return ()\n"
"    iterator = _tee(iterable)\n"
"    result = [iterator]\n"
"    for _ in range(n - 1):\n"
"        result.append(_tee(iterator))\n"
"    return tuple(result)\n"
"\n"
"class _tee:\n"
"\n"
"    def __init__(self, iterable):\n"
"        it = iter(iterable)\n"
"        if isinstance(it, _tee):\n"
"            self.iterator = it.iterator\n"
"            self.link = it.link\n"
"        else:\n"
"            self.iterator = it\n"
"            self.link = [None, None]\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        link = self.link\n"
"        if link[1] is None:\n"
"            link[0] = next(self.iterator)\n"
"            link[1] = [None, None]\n"
"        value, self.link = link\n"
"        return value"
msgstr ""
"def tee(iterable, n=2):\n"
"    if n < 0:\n"
"        raise ValueError\n"
"    if n == 0:\n"
"        return ()\n"
"    iterator = _tee(iterable)\n"
"    result = [iterator]\n"
"    for _ in range(n - 1):\n"
"        result.append(_tee(iterator))\n"
"    return tuple(result)\n"
"\n"
"class _tee:\n"
"\n"
"    def __init__(self, iterable):\n"
"        it = iter(iterable)\n"
"        if isinstance(it, _tee):\n"
"            self.iterator = it.iterator\n"
"            self.link = it.link\n"
"        else:\n"
"            self.iterator = it\n"
"            self.link = [None, None]\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        link = self.link\n"
"        if link[1] is None:\n"
"            link[0] = next(self.iterator)\n"
"            link[1] = [None, None]\n"
"        value, self.link = link\n"
"        return value"

msgid ""
"When the input *iterable* is already a tee iterator object, all members of "
"the return tuple are constructed as if they had been produced by the "
"upstream :func:`tee` call.  This \"flattening step\" allows nested :func:"
"`tee` calls to share the same underlying data chain and to have a single "
"update step rather than a chain of calls."
msgstr ""
"När indata *iterable* redan är ett tee iterator-objekt, konstrueras alla "
"medlemmar i retur-tupeln som om de hade producerats av :func:`tee`-anropet "
"uppströms.  Detta \"utjämningssteg\" gör att nästlade :func:`tee`-anrop kan "
"dela samma underliggande datakedja och ha ett enda uppdateringssteg i "
"stället för en kedja av anrop."

msgid "The flattening property makes tee iterators efficiently peekable:"
msgstr "Flattening-egenskapen gör att tee-iteratorer effektivt kan tittas på:"

msgid ""
"def lookahead(tee_iterator):\n"
"     \"Return the next value without moving the input forward\"\n"
"     [forked_iterator] = tee(tee_iterator, 1)\n"
"     return next(forked_iterator)"
msgstr ""
"def lookahead(tee_iterator):\n"
"     \"Return the next value without moving the input forward\"\n"
"     [forked_iterator] = tee(tee_iterator, 1)\n"
"     return next(forked_iterator)"

msgid ""
">>> iterator = iter('abcdef')\n"
">>> [iterator] = tee(iterator, 1)   # Make the input peekable\n"
">>> next(iterator)                  # Move the iterator forward\n"
"'a'\n"
">>> lookahead(iterator)             # Check next value\n"
"'b'\n"
">>> next(iterator)                  # Continue moving forward\n"
"'b'"
msgstr ""
">>> iterator = iter('abcdef')\n"
">>> [iterator] = tee(iterator, 1)   # Make the input peekable\n"
">>> next(iterator)                  # Move the iterator forward\n"
"'a'\n"
">>> lookahead(iterator)             # Check next value\n"
"'b'\n"
">>> next(iterator)                  # Continue moving forward\n"
"'b'"

msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when simultaneously using iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""
"``tee`` iteratorer är inte trådsäkra. Ett :exc:`RuntimeError` kan uppstå vid "
"samtidig användning av iteratorer som returneras av samma :func:`tee`-anrop, "
"även om den ursprungliga *iterable* är trådlös."

msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use :"
"func:`list` instead of :func:`tee`."
msgstr ""
"Detta itertool kan kräva betydande extra lagring (beroende på hur mycket "
"temporär data som behöver lagras). Om en iterator använder det mesta eller "
"all data innan en annan iterator startar, är det i allmänhet snabbare att "
"använda :func:`list` i stället för :func:`tee`."

msgid "Make an iterator that aggregates elements from each of the *iterables*."
msgstr ""
"Skapa en iterator som aggregerar element från var och en av *iteratorerna*."

msgid ""
"If the iterables are of uneven length, missing values are filled-in with "
"*fillvalue*.  If not specified, *fillvalue* defaults to ``None``."
msgstr ""
"Om iterablerna är av ojämn längd fylls saknade värden i med *fillvalue*.  Om "
"det inte anges är *fillvalue* standardvärdet ``None``."

msgid "Iteration continues until the longest iterable is exhausted."
msgstr "Iterationen fortsätter tills den längsta iteratorn är uttömd."

msgid ""
"def zip_longest(*iterables, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-\n"
"\n"
"    iterators = list(map(iter, iterables))\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"\n"
"    while True:\n"
"        values = []\n"
"        for i, iterator in enumerate(iterators):\n"
"            try:\n"
"                value = next(iterator)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"
msgstr ""
"def zip_longest(*iterables, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') → Ax By C- D-\n"
"\n"
"    iterators = list(map(iter, iterables))\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"\n"
"    while True:\n"
"        values = []\n"
"        for i, iterator in enumerate(iterators):\n"
"            try:\n"
"                value = next(iterator)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"

msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`zip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`)."
msgstr ""
"Om en av iterationerna är potentiellt oändlig bör funktionen :func:"
"`zip_longest` omslutas av något som begränsar antalet anrop (t.ex. :func:"
"`islice` eller :func:`takewhile`)."

msgid "Itertools Recipes"
msgstr "Itertools Recept"

msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr ""
"I det här avsnittet visas recept för att skapa en utökad verktygssats med "
"hjälp av befintliga itertools som byggstenar."

msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes "
"show various ways of thinking about individual tools — for example, that "
"``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``starmap()`` and ``repeat()`` can work together.  The recipes "
"also show patterns for using itertools with the :mod:`operator` and :mod:"
"`collections` modules as well as with the built-in itertools such as "
"``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""
"Det primära syftet med itertools-recepten är pedagogiskt.  Recepten visar "
"olika sätt att tänka på enskilda verktyg - till exempel att ``chain."
"from_iterable`` är relaterat till begreppet utplattning.  Recepten ger också "
"idéer om hur verktygen kan kombineras - till exempel hur ``starmap()`` och "
"``repeat()`` kan fungera tillsammans.  Recepten visar också mönster för hur "
"itertools kan användas med modulerna :mod:`operator` och :mod:`collections` "
"samt med de inbyggda itertools som ``map()``, ``filter()``, ``reversed()`` "
"och ``enumerate()``."

msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started out "
"as recipes.  Currently, the ``sliding_window()``, ``iter_index()``, and "
"``sieve()`` recipes are being tested to see whether they prove their worth."
msgstr ""
"Ett sekundärt syfte med recepten är att fungera som en inkubator.  Itertools "
"``accumulate()``, ``compress()`` och ``pairwise()`` började som recept.  För "
"närvarande testas recepten ``liding_window()``, ``iter_index()`` och "
"``sieve()`` för att se om de visar sitt värde."

msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the :pypi:`more-itertools` project found on the Python Package Index::"
msgstr ""
"I stort sett alla dessa recept och många, många andra kan installeras från :"
"pypi:`more-itertools`-projektet som finns på Python Package Index::"

msgid "python -m pip install more-itertools"
msgstr "python -m pip install more-itertools"

msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one at a "
"time rather than bringing the whole iterable into memory all at once. Code "
"volume is kept small by linking the tools together in a `functional style "
"<https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf>`_.  High "
"speed is retained by preferring \"vectorized\" building blocks over the use "
"of for-loops and :term:`generators <generator>` which incur interpreter "
"overhead."
msgstr ""
"Många av recepten erbjuder samma höga prestanda som den underliggande "
"verktygsmängden. Överlägsen minnesprestanda bibehålls genom att bearbeta "
"element ett i taget snarare än att föra in hela iterabeln i minnet på en "
"gång. Kodvolymen hålls liten genom att verktygen länkas samman i en "
"\"funktionell stil\" &lt;https://www.cs.kent.ac.uk/people/staff/dat/miranda/"
"whyfp90.pdf&gt;`_.  Hög hastighet bibehålls genom att föredra "
"\"vektoriserade\" byggblock framför användning av for-loopar och :term:"
"`generators <generator>` som medför tolkningsoverhead."

msgid ""
"from collections import Counter, deque\n"
"from contextlib import suppress\n"
"from functools import reduce\n"
"from math import comb, prod, sumprod, isqrt\n"
"from operator import itemgetter, getitem, mul, neg\n"
"\n"
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list.\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def prepend(value, iterable):\n"
"    \"Prepend a single value in front of an iterable.\"\n"
"    # prepend(1, [2, 3, 4]) → 1 2 3 4\n"
"    return chain([value], iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def repeatfunc(function, times=None, *args):\n"
"    \"Repeat calls to a function with specified arguments.\"\n"
"    if times is None:\n"
"        return starmap(function, repeat(args))\n"
"    return starmap(function, repeat(args, times))\n"
"\n"
"def flatten(list_of_lists):\n"
"    \"Flatten one level of nesting.\"\n"
"    return chain.from_iterable(list_of_lists)\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times.\"\n"
"    return chain.from_iterable(repeat(tuple(iterable), n))\n"
"\n"
"def loops(n):\n"
"    \"Loop n times. Like range(n) but without creating integers.\"\n"
"    # for _ in loops(100): ...\n"
"    return repeat(None, n)\n"
"\n"
"def tail(n, iterable):\n"
"    \"Return an iterator over the last n items.\"\n"
"    # tail(3, 'ABCDEFG') → E F G\n"
"    return iter(deque(iterable, maxlen=n))\n"
"\n"
"def consume(iterator, n=None):\n"
"    \"Advance the iterator n-steps ahead. If n is None, consume entirely.\"\n"
"    # Use functions that consume iterators at C speed.\n"
"    if n is None:\n"
"        deque(iterator, maxlen=0)\n"
"    else:\n"
"        next(islice(iterator, n, n), None)\n"
"\n"
"def nth(iterable, n, default=None):\n"
"    \"Returns the nth item or a default value.\"\n"
"    return next(islice(iterable, n, None), default)\n"
"\n"
"def quantify(iterable, predicate=bool):\n"
"    \"Given a predicate that returns True or False, count the True results."
"\"\n"
"    return sum(map(predicate, iterable))\n"
"\n"
"def first_true(iterable, default=False, predicate=None):\n"
"    \"Returns the first true value or the *default* if there is no true "
"value.\"\n"
"    # first_true([a,b,c], x) → a or b or c or x\n"
"    # first_true([a,b], x, f) → a if f(a) else b if f(b) else x\n"
"    return next(filter(predicate, iterable), default)\n"
"\n"
"def all_equal(iterable, key=None):\n"
"    \"Returns True if all the elements are equal to each other.\"\n"
"    # all_equal('4٤௪౪໔', key=int) → True\n"
"    return len(take(2, groupby(iterable, key))) <= 1\n"
"\n"
"def unique_justseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember only the element "
"just seen.\"\n"
"    # unique_justseen('AAAABBBCCDAABBB') → A B C D A B\n"
"    # unique_justseen('ABBcCAD', str.casefold) → A B c A D\n"
"    if key is None:\n"
"        return map(itemgetter(0), groupby(iterable))\n"
"    return map(next, map(itemgetter(1), groupby(iterable, key)))\n"
"\n"
"def unique_everseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember all elements ever "
"seen.\"\n"
"    # unique_everseen('AAAABBBCCDAABBB') → A B C D\n"
"    # unique_everseen('ABBcCAD', str.casefold) → A B c D\n"
"    seen = set()\n"
"    if key is None:\n"
"        for element in filterfalse(seen.__contains__, iterable):\n"
"            seen.add(element)\n"
"            yield element\n"
"    else:\n"
"        for element in iterable:\n"
"            k = key(element)\n"
"            if k not in seen:\n"
"                seen.add(k)\n"
"                yield element\n"
"\n"
"def unique(iterable, key=None, reverse=False):\n"
"   \"Yield unique elements in sorted order. Supports unhashable inputs.\"\n"
"   # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4]\n"
"   sequenced = sorted(iterable, key=key, reverse=reverse)\n"
"   return unique_justseen(sequenced, key=key)\n"
"\n"
"def sliding_window(iterable, n):\n"
"    \"Collect data into overlapping fixed-length chunks or blocks.\"\n"
"    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG\n"
"    iterator = iter(iterable)\n"
"    window = deque(islice(iterator, n - 1), maxlen=n)\n"
"    for x in iterator:\n"
"        window.append(x)\n"
"        yield tuple(window)\n"
"\n"
"def grouper(iterable, n, *, incomplete='fill', fillvalue=None):\n"
"    \"Collect data into non-overlapping fixed-length chunks or blocks.\"\n"
"    # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx\n"
"    # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError\n"
"    # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF\n"
"    iterators = [iter(iterable)] * n\n"
"    match incomplete:\n"
"        case 'fill':\n"
"            return zip_longest(*iterators, fillvalue=fillvalue)\n"
"        case 'strict':\n"
"            return zip(*iterators, strict=True)\n"
"        case 'ignore':\n"
"            return zip(*iterators)\n"
"        case _:\n"
"            raise ValueError('Expected fill, strict, or ignore')\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"Visit input iterables in a cycle until each is exhausted.\"\n"
"    # roundrobin('ABC', 'D', 'EF') → A D E B F C\n"
"    # Algorithm credited to George Sakkis\n"
"    iterators = map(iter, iterables)\n"
"    for num_active in range(len(iterables), 0, -1):\n"
"        iterators = cycle(islice(iterators, num_active))\n"
"        yield from map(next, iterators)\n"
"\n"
"def subslices(seq):\n"
"    \"Return all contiguous non-empty subslices of a sequence.\"\n"
"    # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D\n"
"    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n"
"    return map(getitem, repeat(seq), slices)\n"
"\n"
"def iter_index(iterable, value, start=0, stop=None):\n"
"    \"Return indices where a value occurs in a sequence or iterable.\"\n"
"    # iter_index('AABCADEAF', 'A') → 0 1 4 7\n"
"    seq_index = getattr(iterable, 'index', None)\n"
"    if seq_index is None:\n"
"        iterator = islice(iterable, start, stop)\n"
"        for i, element in enumerate(iterator, start):\n"
"            if element is value or element == value:\n"
"                yield i\n"
"    else:\n"
"        stop = len(iterable) if stop is None else stop\n"
"        i = start\n"
"        with suppress(ValueError):\n"
"            while True:\n"
"                yield (i := seq_index(value, i, stop))\n"
"                i += 1\n"
"\n"
"def iter_except(function, exception, first=None):\n"
"    \"Convert a call-until-exception interface to an iterator interface.\"\n"
"    # iter_except(d.popitem, KeyError) → non-blocking dictionary iterator\n"
"    with suppress(exception):\n"
"        if first is not None:\n"
"            yield first()\n"
"        while True:\n"
"            yield function()"
msgstr ""
"from collections import Counter, deque\n"
"from contextlib import suppress\n"
"from functools import reduce\n"
"from math import comb, prod, sumprod, isqrt\n"
"from operator import itemgetter, getitem, mul, neg\n"
"\n"
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list.\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def prepend(value, iterable):\n"
"    \"Prepend a single value in front of an iterable.\"\n"
"    # prepend(1, [2, 3, 4]) → 1 2 3 4\n"
"    return chain([value], iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def repeatfunc(function, times=None, *args):\n"
"    \"Repeat calls to a function with specified arguments.\"\n"
"    if times is None:\n"
"        return starmap(function, repeat(args))\n"
"    return starmap(function, repeat(args, times))\n"
"\n"
"def flatten(list_of_lists):\n"
"    \"Flatten one level of nesting.\"\n"
"    return chain.from_iterable(list_of_lists)\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times.\"\n"
"    return chain.from_iterable(repeat(tuple(iterable), n))\n"
"\n"
"def loops(n):\n"
"    \"Loop n times. Like range(n) but without creating integers.\"\n"
"    # for _ in loops(100): ...\n"
"    return repeat(None, n)\n"
"\n"
"def tail(n, iterable):\n"
"    \"Return an iterator over the last n items.\"\n"
"    # tail(3, 'ABCDEFG') → E F G\n"
"    return iter(deque(iterable, maxlen=n))\n"
"\n"
"def consume(iterator, n=None):\n"
"    \"Advance the iterator n-steps ahead. If n is None, consume entirely.\"\n"
"    # Use functions that consume iterators at C speed.\n"
"    if n is None:\n"
"        deque(iterator, maxlen=0)\n"
"    else:\n"
"        next(islice(iterator, n, n), None)\n"
"\n"
"def nth(iterable, n, default=None):\n"
"    \"Returns the nth item or a default value.\"\n"
"    return next(islice(iterable, n, None), default)\n"
"\n"
"def quantify(iterable, predicate=bool):\n"
"    \"Given a predicate that returns True or False, count the True results."
"\"\n"
"    return sum(map(predicate, iterable))\n"
"\n"
"def first_true(iterable, default=False, predicate=None):\n"
"    \"Returns the first true value or the *default* if there is no true "
"value.\"\n"
"    # first_true([a,b,c], x) → a or b or c or x\n"
"    # first_true([a,b], x, f) → a if f(a) else b if f(b) else x\n"
"    return next(filter(predicate, iterable), default)\n"
"\n"
"def all_equal(iterable, key=None):\n"
"    \"Returns True if all the elements are equal to each other.\"\n"
"    # all_equal('4٤௪౪໔', key=int) → True\n"
"    return len(take(2, groupby(iterable, key))) <= 1\n"
"\n"
"def unique_justseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember only the element "
"just seen.\"\n"
"    # unique_justseen('AAAABBBCCDAABBB') → A B C D A B\n"
"    # unique_justseen('ABBcCAD', str.casefold) → A B c A D\n"
"    if key is None:\n"
"        return map(itemgetter(0), groupby(iterable))\n"
"    return map(next, map(itemgetter(1), groupby(iterable, key)))\n"
"\n"
"def unique_everseen(iterable, key=None):\n"
"    \"Yield unique elements, preserving order. Remember all elements ever "
"seen.\"\n"
"    # unique_everseen('AAAABBBCCDAABBB') → A B C D\n"
"    # unique_everseen('ABBcCAD', str.casefold) → A B c D\n"
"    seen = set()\n"
"    if key is None:\n"
"        for element in filterfalse(seen.__contains__, iterable):\n"
"            seen.add(element)\n"
"            yield element\n"
"    else:\n"
"        for element in iterable:\n"
"            k = key(element)\n"
"            if k not in seen:\n"
"                seen.add(k)\n"
"                yield element\n"
"\n"
"def unique(iterable, key=None, reverse=False):\n"
"   \"Yield unique elements in sorted order. Supports unhashable inputs.\"\n"
"   # unique([[1, 2], [3, 4], [1, 2]]) → [1, 2] [3, 4]\n"
"   sequenced = sorted(iterable, key=key, reverse=reverse)\n"
"   return unique_justseen(sequenced, key=key)\n"
"\n"
"def sliding_window(iterable, n):\n"
"    \"Collect data into overlapping fixed-length chunks or blocks.\"\n"
"    # sliding_window('ABCDEFG', 4) → ABCD BCDE CDEF DEFG\n"
"    iterator = iter(iterable)\n"
"    window = deque(islice(iterator, n - 1), maxlen=n)\n"
"    for x in iterator:\n"
"        window.append(x)\n"
"        yield tuple(window)\n"
"\n"
"def grouper(iterable, n, *, incomplete='fill', fillvalue=None):\n"
"    \"Collect data into non-overlapping fixed-length chunks or blocks.\"\n"
"    # grouper('ABCDEFG', 3, fillvalue='x') → ABC DEF Gxx\n"
"    # grouper('ABCDEFG', 3, incomplete='strict') → ABC DEF ValueError\n"
"    # grouper('ABCDEFG', 3, incomplete='ignore') → ABC DEF\n"
"    iterators = [iter(iterable)] * n\n"
"    match incomplete:\n"
"        case 'fill':\n"
"            return zip_longest(*iterators, fillvalue=fillvalue)\n"
"        case 'strict':\n"
"            return zip(*iterators, strict=True)\n"
"        case 'ignore':\n"
"            return zip(*iterators)\n"
"        case _:\n"
"            raise ValueError('Expected fill, strict, or ignore')\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"Visit input iterables in a cycle until each is exhausted.\"\n"
"    # roundrobin('ABC', 'D', 'EF') → A D E B F C\n"
"    # Algorithm credited to George Sakkis\n"
"    iterators = map(iter, iterables)\n"
"    for num_active in range(len(iterables), 0, -1):\n"
"        iterators = cycle(islice(iterators, num_active))\n"
"        yield from map(next, iterators)\n"
"\n"
"def subslices(seq):\n"
"    \"Return all contiguous non-empty subslices of a sequence.\"\n"
"    # subslices('ABCD') → A AB ABC ABCD B BC BCD C CD D\n"
"    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n"
"    return map(getitem, repeat(seq), slices)\n"
"\n"
"def iter_index(iterable, value, start=0, stop=None):\n"
"    \"Return indices where a value occurs in a sequence or iterable.\"\n"
"    # iter_index('AABCADEAF', 'A') → 0 1 4 7\n"
"    seq_index = getattr(iterable, 'index', None)\n"
"    if seq_index is None:\n"
"        iterator = islice(iterable, start, stop)\n"
"        for i, element in enumerate(iterator, start):\n"
"            if element is value or element == value:\n"
"                yield i\n"
"    else:\n"
"        stop = len(iterable) if stop is None else stop\n"
"        i = start\n"
"        with suppress(ValueError):\n"
"            while True:\n"
"                yield (i := seq_index(value, i, stop))\n"
"                i += 1\n"
"\n"
"def iter_except(function, exception, first=None):\n"
"    \"Convert a call-until-exception interface to an iterator interface.\"\n"
"    # iter_except(d.popitem, KeyError) → non-blocking dictionary iterator\n"
"    with suppress(exception):\n"
"        if first is not None:\n"
"            yield first()\n"
"        while True:\n"
"            yield function()"

msgid "The following recipes have a more mathematical flavor:"
msgstr "Följande recept har en mer matematisk smak:"

msgid ""
"def multinomial(*counts):\n"
"    \"Number of distinct arrangements of a multiset.\"\n"
"    # Counter('abracadabra').values() → 5 2 2 1 1\n"
"    # multinomial(5, 2, 2, 1, 1) → 83160\n"
"    return prod(map(comb, accumulate(counts), counts))\n"
"\n"
"def powerset(iterable):\n"
"    \"Subsequences of the iterable from shortest to longest.\"\n"
"    # powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n"
"\n"
"def sum_of_squares(iterable):\n"
"    \"Add up the squares of the input values.\"\n"
"    # sum_of_squares([10, 20, 30]) → 1400\n"
"    return sumprod(*tee(iterable))\n"
"\n"
"def reshape(matrix, columns):\n"
"    \"Reshape a 2-D matrix to have a given number of columns.\"\n"
"    # reshape([(0, 1), (2, 3), (4, 5)], 3) →  (0, 1, 2), (3, 4, 5)\n"
"    return batched(chain.from_iterable(matrix), columns, strict=True)\n"
"\n"
"def transpose(matrix):\n"
"    \"Swap the rows and columns of a 2-D matrix.\"\n"
"    # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)\n"
"    return zip(*matrix, strict=True)\n"
"\n"
"def matmul(m1, m2):\n"
"    \"Multiply two matrices.\"\n"
"    # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)\n"
"    n = len(m2[0])\n"
"    return batched(starmap(sumprod, product(m1, transpose(m2))), n)\n"
"\n"
"def convolve(signal, kernel):\n"
"    \"\"\"Discrete linear convolution of two iterables.\n"
"    Equivalent to polynomial multiplication.\n"
"\n"
"    Convolutions are mathematically commutative; however, the inputs are\n"
"    evaluated differently.  The signal is consumed lazily and can be\n"
"    infinite. The kernel is fully consumed before the calculations begin.\n"
"\n"
"    Article:  https://betterexplained.com/articles/intuitive-convolution/\n"
"    Video:    https://www.youtube.com/watch?v=KuXjwB4LzSA\n"
"    \"\"\"\n"
"    # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60\n"
"    # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)\n"
"    # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate\n"
"    # convolve(data, [1, -2, 1]) → 2nd derivative estimate\n"
"    kernel = tuple(kernel)[::-1]\n"
"    n = len(kernel)\n"
"    padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))\n"
"    windowed_signal = sliding_window(padded_signal, n)\n"
"    return map(sumprod, repeat(kernel), windowed_signal)\n"
"\n"
"def polynomial_from_roots(roots):\n"
"    \"\"\"Compute a polynomial's coefficients from its roots.\n"
"\n"
"       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60\n"
"    \"\"\"\n"
"    # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]\n"
"    factors = zip(repeat(1), map(neg, roots))\n"
"    return list(reduce(convolve, factors, [1]))\n"
"\n"
"def polynomial_eval(coefficients, x):\n"
"    \"\"\"Evaluate a polynomial at a specific value.\n"
"\n"
"    Computes with better numeric stability than Horner's method.\n"
"    \"\"\"\n"
"    # Evaluate x³ -4x² -17x + 60 at x = 5\n"
"    # polynomial_eval([1, -4, -17, 60], x=5) → 0\n"
"    n = len(coefficients)\n"
"    if not n:\n"
"        return type(x)(0)\n"
"    powers = map(pow, repeat(x), reversed(range(n)))\n"
"    return sumprod(coefficients, powers)\n"
"\n"
"def polynomial_derivative(coefficients):\n"
"    \"\"\"Compute the first derivative of a polynomial.\n"
"\n"
"       f(x)  =  x³ -4x² -17x + 60\n"
"       f'(x) = 3x² -8x  -17\n"
"    \"\"\"\n"
"    # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]\n"
"    n = len(coefficients)\n"
"    powers = reversed(range(1, n))\n"
"    return list(map(mul, coefficients, powers))\n"
"\n"
"def sieve(n):\n"
"    \"Primes less than n.\"\n"
"    # sieve(30) → 2 3 5 7 11 13 17 19 23 29\n"
"    if n > 2:\n"
"        yield 2\n"
"    data = bytearray((0, 1)) * (n // 2)\n"
"    for p in iter_index(data, 1, start=3, stop=isqrt(n) + 1):\n"
"        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))\n"
"    yield from iter_index(data, 1, start=3)\n"
"\n"
"def factor(n):\n"
"    \"Prime factors of n.\"\n"
"    # factor(99) → 3 3 11\n"
"    # factor(1_000_000_000_000_007) → 47 59 360620266859\n"
"    # factor(1_000_000_000_000_403) → 1000000000000403\n"
"    for prime in sieve(isqrt(n) + 1):\n"
"        while not n % prime:\n"
"            yield prime\n"
"            n //= prime\n"
"            if n == 1:\n"
"                return\n"
"    if n > 1:\n"
"        yield n\n"
"\n"
"def is_prime(n):\n"
"    \"Return True if n is prime.\"\n"
"    # is_prime(1_000_000_000_000_403) → True\n"
"    return n > 1 and next(factor(n)) == n\n"
"\n"
"def totient(n):\n"
"    \"Count of natural numbers up to n that are coprime to n.\"\n"
"    # https://mathworld.wolfram.com/TotientFunction.html\n"
"    # totient(12) → 4 because len([1, 5, 7, 11]) == 4\n"
"    for prime in set(factor(n)):\n"
"        n -= n // prime\n"
"    return n"
msgstr ""
"def multinomial(*counts):\n"
"    \"Number of distinct arrangements of a multiset.\"\n"
"    # Counter('abracadabra').values() → 5 2 2 1 1\n"
"    # multinomial(5, 2, 2, 1, 1) → 83160\n"
"    return prod(map(comb, accumulate(counts), counts))\n"
"\n"
"def powerset(iterable):\n"
"    \"Subsequences of the iterable from shortest to longest.\"\n"
"    # powerset([1,2,3]) → () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n"
"\n"
"def sum_of_squares(iterable):\n"
"    \"Add up the squares of the input values.\"\n"
"    # sum_of_squares([10, 20, 30]) → 1400\n"
"    return sumprod(*tee(iterable))\n"
"\n"
"def reshape(matrix, columns):\n"
"    \"Reshape a 2-D matrix to have a given number of columns.\"\n"
"    # reshape([(0, 1), (2, 3), (4, 5)], 3) →  (0, 1, 2), (3, 4, 5)\n"
"    return batched(chain.from_iterable(matrix), columns, strict=True)\n"
"\n"
"def transpose(matrix):\n"
"    \"Swap the rows and columns of a 2-D matrix.\"\n"
"    # transpose([(1, 2, 3), (11, 22, 33)]) → (1, 11) (2, 22) (3, 33)\n"
"    return zip(*matrix, strict=True)\n"
"\n"
"def matmul(m1, m2):\n"
"    \"Multiply two matrices.\"\n"
"    # matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]) → (49, 80), (41, 60)\n"
"    n = len(m2[0])\n"
"    return batched(starmap(sumprod, product(m1, transpose(m2))), n)\n"
"\n"
"def convolve(signal, kernel):\n"
"    \"\"\"Discrete linear convolution of two iterables.\n"
"    Equivalent to polynomial multiplication.\n"
"\n"
"    Convolutions are mathematically commutative; however, the inputs are\n"
"    evaluated differently.  The signal is consumed lazily and can be\n"
"    infinite. The kernel is fully consumed before the calculations begin.\n"
"\n"
"    Article:  https://betterexplained.com/articles/intuitive-convolution/\n"
"    Video:    https://www.youtube.com/watch?v=KuXjwB4LzSA\n"
"    \"\"\"\n"
"    # convolve([1, -1, -20], [1, -3]) → 1 -4 -17 60\n"
"    # convolve(data, [0.25, 0.25, 0.25, 0.25]) → Moving average (blur)\n"
"    # convolve(data, [1/2, 0, -1/2]) → 1st derivative estimate\n"
"    # convolve(data, [1, -2, 1]) → 2nd derivative estimate\n"
"    kernel = tuple(kernel)[::-1]\n"
"    n = len(kernel)\n"
"    padded_signal = chain(repeat(0, n-1), signal, repeat(0, n-1))\n"
"    windowed_signal = sliding_window(padded_signal, n)\n"
"    return map(sumprod, repeat(kernel), windowed_signal)\n"
"\n"
"def polynomial_from_roots(roots):\n"
"    \"\"\"Compute a polynomial's coefficients from its roots.\n"
"\n"
"       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60\n"
"    \"\"\"\n"
"    # polynomial_from_roots([5, -4, 3]) → [1, -4, -17, 60]\n"
"    factors = zip(repeat(1), map(neg, roots))\n"
"    return list(reduce(convolve, factors, [1]))\n"
"\n"
"def polynomial_eval(coefficients, x):\n"
"    \"\"\"Evaluate a polynomial at a specific value.\n"
"\n"
"    Computes with better numeric stability than Horner's method.\n"
"    \"\"\"\n"
"    # Evaluate x³ -4x² -17x + 60 at x = 5\n"
"    # polynomial_eval([1, -4, -17, 60], x=5) → 0\n"
"    n = len(coefficients)\n"
"    if not n:\n"
"        return type(x)(0)\n"
"    powers = map(pow, repeat(x), reversed(range(n)))\n"
"    return sumprod(coefficients, powers)\n"
"\n"
"def polynomial_derivative(coefficients):\n"
"    \"\"\"Compute the first derivative of a polynomial.\n"
"\n"
"       f(x)  =  x³ -4x² -17x + 60\n"
"       f'(x) = 3x² -8x  -17\n"
"    \"\"\"\n"
"    # polynomial_derivative([1, -4, -17, 60]) → [3, -8, -17]\n"
"    n = len(coefficients)\n"
"    powers = reversed(range(1, n))\n"
"    return list(map(mul, coefficients, powers))\n"
"\n"
"def sieve(n):\n"
"    \"Primes less than n.\"\n"
"    # sieve(30) → 2 3 5 7 11 13 17 19 23 29\n"
"    if n > 2:\n"
"        yield 2\n"
"    data = bytearray((0, 1)) * (n // 2)\n"
"    for p in iter_index(data, 1, start=3, stop=isqrt(n) + 1):\n"
"        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))\n"
"    yield from iter_index(data, 1, start=3)\n"
"\n"
"def factor(n):\n"
"    \"Prime factors of n.\"\n"
"    # factor(99) → 3 3 11\n"
"    # factor(1_000_000_000_000_007) → 47 59 360620266859\n"
"    # factor(1_000_000_000_000_403) → 1000000000000403\n"
"    for prime in sieve(isqrt(n) + 1):\n"
"        while not n % prime:\n"
"            yield prime\n"
"            n //= prime\n"
"            if n == 1:\n"
"                return\n"
"    if n > 1:\n"
"        yield n\n"
"\n"
"def is_prime(n):\n"
"    \"Return True if n is prime.\"\n"
"    # is_prime(1_000_000_000_000_403) → True\n"
"    return n > 1 and next(factor(n)) == n\n"
"\n"
"def totient(n):\n"
"    \"Count of natural numbers up to n that are coprime to n.\"\n"
"    # https://mathworld.wolfram.com/TotientFunction.html\n"
"    # totient(12) → 4 because len([1, 5, 7, 11]) == 4\n"
"    for prime in set(factor(n)):\n"
"        n -= n // prime\n"
"    return n"
