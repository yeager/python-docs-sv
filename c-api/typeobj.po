# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Type Object Structures"
msgstr "Typobjektstrukturer"

msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"En av de kanske viktigaste strukturerna i Pythons objektsystem är den "
"struktur som definierar en ny typ: :c:type:`PyTypeObject`-strukturen.  "
"Typobjekt kan hanteras med hjälp av någon av funktionerna ``PyObject_*`` "
"eller ``PyType_*``, men erbjuder inte mycket som är intressant för de flesta "
"Python-applikationer. Dessa objekt är grundläggande för hur objekt beter "
"sig, så de är mycket viktiga för själva tolken och för alla tilläggsmoduler "
"som implementerar nya typer."

msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Typobjekt är ganska stora jämfört med de flesta standardtyperna. Anledningen "
"till storleken är att varje typobjekt lagrar ett stort antal värden, "
"mestadels C-funktionspekare, som var och en implementerar en liten del av "
"typens funktionalitet.  Fälten i typobjektet granskas i detalj i detta "
"avsnitt.  Fälten kommer att beskrivas i den ordning de förekommer i "
"strukturen."

msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"Förutom följande snabbreferens ger avsnittet :ref:`typedef-examples` en "
"snabb inblick i betydelsen och användningen av :c:type:`PyTypeObject`."

msgid "Quick Reference"
msgstr "Snabbreferens"

msgid "\"tp slots\""
msgstr "\"tp slots\""

msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject Slot [#slots]_"

msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Typ <slot-typedefs-table>`"

msgid "special methods/attrs"
msgstr "speciella metoder/attribut"

msgid "Info [#cols]_"
msgstr "Info [#cols]_ _ Info"

msgid "O"
msgstr "A"

msgid "T"
msgstr "T"

msgid "D"
msgstr "D"

msgid "I"
msgstr "I"

msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R>:c:member:`~PyTypeObject.tp_name`"

msgid "const char *"
msgstr "konst char *"

msgid "__name__"
msgstr "__namn__"

msgid "X"
msgstr "X"

msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

msgid ":c:type:`destructor`"
msgstr ":c:type:`destruktor`"

msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

msgid "__getattribute__, __getattr__"
msgstr "__getattribut__, __getattr__"

msgid "G"
msgstr "G"

msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

msgid "%"
msgstr "%"

msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

msgid "__repr__"
msgstr "__repr__"

msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

msgid "__hash__"
msgstr "__hash__"

msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

msgid "__call__"
msgstr "__anropa__"

msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

msgid "__str__"
msgstr "__str__"

msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

msgid "unsigned long"
msgstr "osignerad lång"

msgid "?"
msgstr "?"

msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

msgid "__doc__"
msgstr "__doc__"

msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

msgid ":c:type:`inquiry`"
msgstr ":c:type:`förfrågan`"

msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"

msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

msgid "__iter__"
msgstr "__iter__"

msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

msgid "__next__"
msgstr "nästa"

msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

msgid "__base__"
msgstr "__bas"

msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

msgid "__dict__"
msgstr "__dict__"

msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

msgid "__get__"
msgstr "__get__"

msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

msgid "__set__, __delete__"
msgstr "__set__, __delete__"

msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_dictoffset`)"

msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

msgid "__init__"
msgstr "__init__"

msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

msgid "__new__"
msgstr "__ny"

msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

msgid "__bases__"
msgstr "baser"

msgid "~"
msgstr "~"

msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

msgid "__mro__"
msgstr "det är inte sant"

msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

msgid "void *"
msgstr "tomrum *"

msgid "__subclasses__"
msgstr "__underklasser"

msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

msgid "unsigned int"
msgstr "osignerad int"

msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

msgid "__del__"
msgstr "__del__"

msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vektorcallfunc`"

msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_watched`]"

msgid "unsigned char"
msgstr "obetecknad char"

msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr ""
"**()**: Ett slotnamn inom parentes anger att det (i praktiken) är föråldrat."

msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""
"**<>**: Namn inom hakparenteser bör initialt sättas till ``NULL`` och "
"behandlas som skrivskyddade."

msgid "**[]**: Names in square brackets are for internal use only."
msgstr "**[]**: Namn inom hakparentes är endast för internt bruk."

msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""
"**<R>** (som prefix) betyder att fältet är obligatoriskt (måste vara icke-"
"``NULL``)."

msgid "Columns:"
msgstr "Kolumner:"

msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**: inställd på :c:data:`PyBaseObject_Type`"

msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**: inställd på :c:data:`PyType_Type`"

msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**: standard (om slot är inställd på ``NULL``)"

msgid ""
"X - PyType_Ready sets this value if it is NULL\n"
"~ - PyType_Ready always sets this value (it should be NULL)\n"
"? - PyType_Ready may set this value depending on other slots\n"
"\n"
"Also see the inheritance column (\"I\")."
msgstr ""
"X - PyType_Ready ställer in detta värde om det är NULL\n"
"~ - PyType_Ready ställer alltid in detta värde (det ska vara NULL)\n"
"? - PyType_Ready kan ställa in detta värde beroende på andra slots\n"
"\n"
"Se även kolumnen för arv (\"I\")."

msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: arv"

msgid ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* "
"value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's "
"description\n"
"? - it's complicated; see the slot's description"
msgstr ""
"X - typplatsen ärvs via *PyType_Ready* om den definieras med ett *NULL*-"
"värde\n"
"% - understrukturens slots ärvs individuellt\n"
"G - ärvs, men endast i kombination med andra slots; se slotens beskrivning\n"
"? - det är komplicerat; se slotens beskrivning"

msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Observera att vissa slots faktiskt ärvs genom den normala "
"attributuppslagningskedjan."

msgid "sub-slots"
msgstr "underluckor"

msgid "Slot"
msgstr "Tidslucka"

msgid "special methods"
msgstr "särskilda metoder"

msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

msgid "__await__"
msgstr "vänta.."

msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

msgid "__aiter__"
msgstr "__aiter__"

msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

msgid "__anext__"
msgstr "__anext__"

msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

msgid "__add__ __radd__"
msgstr "__add__ __radd__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

msgid "__iadd__"
msgstr "__iadd__"

msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

msgid "__isub__"
msgstr "__isub__"

msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

msgid "__imul__"
msgstr "__imul__"

msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

msgid "__imod__"
msgstr "__imod__"

msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

msgid "__ipow__"
msgstr "__ipow__"

msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

msgid "__neg__"
msgstr "__neg__"

msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

msgid "__pos__"
msgstr "__pos__"

msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

msgid "__abs__"
msgstr "det är inte sant"

msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

msgid "__bool__"
msgstr "__bool"

msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

msgid "__invert__"
msgstr "__invertera__"

msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

msgid "__ilshift__"
msgstr "__ilshift__"

msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rshift__ __rshift__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

msgid "__irshift__"
msgstr "jag har inte tid"

msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

msgid "__and__ __rand__"
msgstr "__and__ __rand__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

msgid "__iand__"
msgstr "__iand__"

msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

msgid "__ixor__"
msgstr "__ixor__"

msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

msgid "__or__ __ror__"
msgstr "__eller__ __ror__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

msgid "__ior__"
msgstr "jag är inte här"

msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

msgid "__int__"
msgstr "__int__"

msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

msgid "__float__"
msgstr "__flödesvärde"

msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

msgid "__floordiv__"
msgstr "__floordiv__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

msgid "__ifloordiv__"
msgstr "__ifloordiv__"

msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

msgid "__truediv__"
msgstr "__truediv__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

msgid "__itruediv__"
msgstr "__itruediv__"

msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

msgid "__index__"
msgstr "__index__"

msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

msgid "__imatmul__"
msgstr "__imatmul__"

msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

msgid "__len__"
msgstr "__len__"

msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

msgid "__getitem__"
msgstr "__hämta objekt"

msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

msgid "__setitem__, __delitem__"
msgstr "__sätt objekt__, __ta bort objekt"

msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

msgid "__add__"
msgstr "__tillägg__"

msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

msgid "__mul__"
msgstr "__mul__"

msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

msgid "__contains__"
msgstr "innehåller"

msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

msgid "__buffer__"
msgstr "__buffer__"

msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

msgid "__release_\\ buffer\\__"
msgstr "buffert"

msgid "slot typedefs"
msgstr "slot typdefinitioner"

msgid "typedef"
msgstr "typdefinierad"

msgid "Parameter Types"
msgstr "Parametertyper"

msgid "Return Type"
msgstr "Typ av retur"

msgid "void"
msgstr "void"

msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

msgid "int"
msgstr "int"

msgid "Py_hash_t"
msgstr "Py_hash_t"

msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Se :ref:`slot-typedefs` nedan för mer information."

msgid "PyTypeObject Definition"
msgstr "PyTypeObject Definition"

msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/cpython/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"Strukturdefinitionen för :c:type:`PyTypeObject` finns i :file:`Include/"
"cpython/object.h`.  För att underlätta referensen upprepar detta den "
"definition som finns där:"

msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache; /* no longer used */\n"
"    void *tp_subclasses;  /* for static builtin types this is an index */\n"
"    PyObject *tp_weaklist; /* not used for static builtin types */\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6.\n"
"     * If zero, the cache is invalid and must be initialized.\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"\n"
"    /* Number of tp_version_tag values used.\n"
"     * Set to _Py_ATTR_CACHE_UNUSED if the attribute cache is\n"
"     * disabled for this type (e.g. due to custom MRO entries).\n"
"     * Otherwise, limited to MAX_VERSIONS_PER_CLASS (defined elsewhere).\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"
msgstr ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* För utskrift, i formatet \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* För allokering */\n"
"\n"
"    /* Metoder för att implementera standardoperationer */\n"
"\n"
"    destruktor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* tidigare känd som tp_compare (Python 2)\n"
"                                    eller tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Metodsviter för standardklasser */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* Fler standardoperationer (här för binär kompatibilitet) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Funktioner för att komma åt objekt som inmatnings-/utmatningsbuffert "
"*/\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flaggor för att definiera förekomst av valfria/utökade funktioner */\n"
"    osignerad lång tp_flags;\n"
"\n"
"    const char *tp_doc; /* Dokumentationssträng */\n"
"\n"
"    /* Tilldelad betydelse i version 2.0 */\n"
"    /* anropsfunktion för alla tillgängliga objekt */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* radera referenser till inneslutna objekt */\n"
"    förfrågan tp_clear;\n"
"\n"
"    /* Tilldelad betydelse i version 2.1 */\n"
"    /* rika jämförelser */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* Möjliggör svag referens */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iteratorer */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attributbeskrivare och underklassningsgrejer */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // Stark referens på en heap-typ, lånad referens på en statisk typ\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Rutin för fritt minne på låg nivå */\n"
"    inquiry tp_is_gc; /* För PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* metodupplösningsordning */\n"
"    PyObject *tp_cache; /* används inte längre */\n"
"    void *tp_subclasses; /* för statiska inbyggda typer är detta ett index "
"*/\n"
"    PyObject *tp_weaklist; /* används inte för statiska inbyggda typer */\n"
"    destruktor tp_del;\n"
"\n"
"    /* Typattribut för cacheversionstagg. Tillagd i version 2.6.\n"
"     * Om noll är cacheminnet ogiltigt och måste initialiseras.\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destruktor tp_finalize;\n"
"    vektorcallfunc tp_vectorcall;\n"
"\n"
"    /* bituppsättning av vilka typövervakare som bryr sig om denna typ */\n"
"    osignerad char tp_watched;\n"
"\n"
"    /* Antal använda tp_version_tag-värden.\n"
"     * Sätts till _Py_ATTR_CACHE_UNUSED om attributcachen är\n"
"     * inaktiverad för den här typen (t.ex. på grund av anpassade MRO-"
"poster).\n"
"     * Annars begränsat till MAX_VERSIONS_PER_CLASS (definieras på annan "
"plats).\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"

msgid "PyObject Slots"
msgstr "PyObject-spelautomater"

msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by :"
"c:func:`!type_new`, usually called from a class statement). Note that :c:"
"data:`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject."
"tp_itemsize`, which means that its instances (i.e. type objects) *must* have "
"the :c:member:`~PyVarObject.ob_size` field."
msgstr ""
"Typobjektstrukturen utökar :c:type:`PyVarObject`-strukturen. Fältet :c:"
"member:`~PyVarObject.ob_size` används för dynamiska typer (skapade av :c:"
"func:`!type_new`, som vanligtvis anropas från en class statement). Observera "
"att :c:data:`PyType_Type` (metatypen) initialiserar :c:member:`~PyTypeObject."
"tp_itemsize`, vilket innebär att dess instanser (dvs. typobjekt) *måste* ha "
"fältet :c:member:`~PyVarObject.ob_size`."

msgid ":c:member:`PyObject.ob_refcnt`"
msgstr ":c:member:`PyObject.ob_refcnt`"

msgid ""
"The type object's reference count is initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :c:member:"
"`~PyObject.ob_type` points back to the type) do *not* count as references.  "
"But for :ref:`dynamically allocated type objects <heap-types>`, the "
"instances *do* count as references."
msgstr ""
"Typobjektets referensantal initialiseras till ``1`` av makrot "
"``PyObject_HEAD_INIT``.  Observera att för :ref:`statiskt allokerade "
"typobjekt <static-types>` räknas typens instanser (objekt vars :c:member:"
"`~PyObject.ob_type` pekar tillbaka på typen) *inte* som referenser.  Men "
"för :ref:``dynamiskt allokerade typobjekt <heap-types>` räknas förekomsterna "
"*som* referenser."

msgid "**Inheritance:**"
msgstr "**Arv:**"

msgid "This field is not inherited by subtypes."
msgstr "Detta fält ärvs inte av subtyper."

msgid ":c:member:`PyObject.ob_type`"
msgstr ":c:member:`PyObject.ob_type`"

msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Detta är typens typ, med andra ord dess metatyp.  Den initialiseras av "
"argumentet till makrot ``PyObject_HEAD_INIT``, och dess värde bör normalt "
"vara ``&PyType_Type``.  Men för dynamiskt laddningsbara tilläggsmoduler som "
"måste kunna användas på Windows (åtminstone), klagar kompilatorn på att "
"detta inte är en giltig initierare.  Därför är konventionen att skicka "
"``NULL`` till makrot ``PyObject_HEAD_INIT`` och att initiera detta fält "
"explicit i början av modulens initialiseringsfunktion, innan något annat "
"görs.  Detta görs typiskt så här::"

msgid "Foo_Type.ob_type = &PyType_Type;"
msgstr "Foo_Type.ob_type = &PyType_Type;"

msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, and if "
"so, initializes it to the :c:member:`~PyObject.ob_type` field of the base "
"class. :c:func:`PyType_Ready` will not change this field if it is non-zero."
msgstr ""
"Detta bör göras innan några instanser av typen skapas. :c:func:"
"`PyType_Ready` kontrollerar om :c:member:`~PyObject.ob_type` är ``NULL``, "
"och initialiserar det i så fall till fältet :c:member:`~PyObject.ob_type` i "
"basklassen. :c:func:`PyType_Ready` ändrar inte detta fält om det är icke-"
"noll."

msgid "This field is inherited by subtypes."
msgstr "Detta fält ärvs av subtyperna."

msgid "PyVarObject Slots"
msgstr "PyVarObject platser"

msgid ":c:member:`PyVarObject.ob_size`"
msgstr ":c:member:`PyVarObject.ob_size`"

msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"För :ref:``statiskt allokerade typobjekt <static-types>`, bör detta "
"initialiseras till noll. För :ref:``dynamiskt allokerade typobjekt <heap-"
"types>`, har detta fält en speciell intern betydelse."

msgid "This field should be accessed using the :c:func:`Py_SIZE()` macro."
msgstr "Detta fält bör nås med hjälp av makrot :c:func:`Py_SIZE()`."

msgid "PyTypeObject Slots"
msgstr "PyTypeObject platser"

msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:data:"
"`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as defaults.)"
msgstr ""
"Varje slot har ett avsnitt som beskriver nedärvning.  Om :c:func:"
"`PyType_Ready` kan sätta ett värde när fältet är satt till ``NULL`` så "
"kommer det också att finnas en \"Default\" sektion.  (Observera att många "
"fält som anges i :c:data:`PyBaseObject_Type` och :c:data:`PyType_Type` "
"fungerar som standardvärden)"

msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in subpackage :"
"mod:`!Q` in package :mod:`!P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Pekare till en NUL-avslutad sträng som innehåller typens namn. För typer som "
"är tillgängliga som modulglobaler ska strängen vara det fullständiga "
"modulnamnet, följt av en punkt, följt av typnamnet; för inbyggda typer ska "
"det bara vara typnamnet.  Om modulen är en undermodul till ett paket ingår "
"det fullständiga paketnamnet i det fullständiga modulnamnet.  Till exempel, "
"en typ med namnet :class:`!T` definierad i modul :mod:`!M` i underpaket :mod:"
"`!Q` i paket :mod:`!P` bör ha :c:member:`~PyTypeObject.tp_name` "
"initialiseraren ``\"P.Q.M.T\"``."

msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"För :ref:``dynamiskt allokerade typobjekt <heap-types>`` bör detta bara vara "
"typnamnet och modulnamnet som uttryckligen lagras i typdikten som värde för "
"nyckeln ``'__module__'``."

msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`~type.__module__` attribute, and everything after "
"the last dot is made accessible as the :attr:`~type.__name__` attribute."
msgstr ""
"För :ref:``statiskt allokerade typobjekt <static-types>`` ska fältet "
"*tp_name* innehålla en punkt. Allt före den sista punkten görs tillgängligt "
"som attributet :attr:`~type.__module__`, och allt efter den sista punkten "
"görs tillgängligt som attributet :attr:`~type.__name__`."

msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~type.__name__` attribute, and the :attr:"
"`~type.__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"Om ingen punkt finns, görs hela fältet :c:member:`~PyTypeObject.tp_name` "
"tillgängligt som attributet :attr:`~type.__name__`, och attributet :attr:"
"`~type.__module__` är odefinierat (om det inte uttryckligen har angetts i "
"ordlistan, enligt vad som förklaras ovan).  Detta innebär att din typ inte "
"kommer att kunna plockas.  Dessutom kommer den inte att listas i "
"moduldokumentationer som skapats med pydoc."

msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Detta fält får inte vara ``NULL``.  Det är det enda obligatoriska fältet i :"
"c:func:`PyTypeObject` (förutom eventuellt :c:member:`~PyTypeObject."
"tp_itemsize`)."

msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"Dessa fält gör det möjligt att beräkna storleken i bytes för instanser av "
"typen."

msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`!tp_itemsize` field, types with variable-length instances have a "
"non-zero :c:member:`!tp_itemsize` field.  For a type with fixed-length "
"instances, all instances have the same size, given in :c:member:`!"
"tp_basicsize`. (Exceptions to this rule can be made using :c:func:"
"`PyUnstable_Object_GC_NewWithExtraData`.)"
msgstr ""
"Det finns två typer av typer: typer med instanser med fast längd har fältet :"
"c:member:`!tp_itemsize` som är noll, medan typer med instanser med variabel "
"längd har fältet :c:member:`!tp_itemsize` som inte är noll.  För en typ med "
"instanser med fast längd har alla instanser samma storlek, angiven i :c:"
"member:`!tp_basicsize`. (Undantag från denna regel kan göras med hjälp av :c:"
"func:`PyUnstable_Object_GC_NewWithExtraData`)"

msgid ""
"For a type with variable-length instances, the instances must have an :c:"
"member:`~PyVarObject.ob_size` field, and the instance size is :c:member:`!"
"tp_basicsize` plus N times :c:member:`!tp_itemsize`, where N is the "
"\"length\" of the object."
msgstr ""
"För en typ med instanser med variabel längd måste instanserna ha ett fält :c:"
"member:`~PyVarObject.ob_size`, och instansstorleken är :c:member:`!"
"tp_basicsize` plus N gånger :c:member:`!tp_itemsize`, där N är objektets "
"\"längd\"."

msgid ""
"Functions like :c:func:`PyObject_NewVar` will take the value of N as an "
"argument, and store in the instance's :c:member:`~PyVarObject.ob_size` "
"field. Note that the :c:member:`~PyVarObject.ob_size` field may later be "
"used for other purposes. For example, :py:type:`int` instances use the bits "
"of :c:member:`~PyVarObject.ob_size` in an implementation-defined way; the "
"underlying storage and its size should be accessed using :c:func:"
"`PyLong_Export`."
msgstr ""
"Funktioner som :c:func:`PyObject_NewVar` tar värdet av N som ett argument "
"och lagrar det i instansens :c:member:`~PyVarObject.ob_size`-fält. Observera "
"att fältet :c:member:`~PyVarObject.ob_size` senare kan användas för andra "
"ändamål. Exempelvis använder instanser av :py:type:`int` bitarna i :c:member:"
"`~PyVarObject.ob_size` på ett implementationsdefinierat sätt; den "
"underliggande lagringen och dess storlek bör nås med hjälp av :c:func:"
"`PyLong_Export`."

msgid ""
"The :c:member:`~PyVarObject.ob_size` field should be accessed using the :c:"
"func:`Py_SIZE()` and :c:func:`Py_SET_SIZE()` macros."
msgstr ""
"Fältet :c:member:`~PyVarObject.ob_size` bör nås med hjälp av makrona :c:func:"
"`Py_SIZE()` och :c:func:`Py_SET_SIZE()`."

msgid ""
"Also, the presence of an :c:member:`~PyVarObject.ob_size` field in the "
"instance layout doesn't mean that the instance structure is variable-length. "
"For example, the :py:type:`list` type has fixed-length instances, yet those "
"instances have a :c:member:`~PyVarObject.ob_size` field. (As with :py:type:"
"`int`, avoid reading lists' :c:member:`!ob_size` directly. Call :c:func:"
"`PyList_Size` instead.)"
msgstr ""
"Att det finns ett fält :c:member:`~PyVarObject.ob_size` i instanslayouten "
"betyder inte heller att instansstrukturen har variabel längd. Till exempel "
"har typen :py:type:`list` instanser med fast längd, men dessa instanser har "
"ändå ett fält :c:member:`~PyVarObject.ob_size`. (Precis som med :py:type:"
"`int` bör du undvika att läsa listors :c:member:`!ob_size` direkt. Anropa :c:"
"func:`PyList_Size` istället)"

msgid ""
"The :c:member:`!tp_basicsize` includes size needed for data of the type's :c:"
"member:`~PyTypeObject.tp_base`, plus any extra data needed by each instance."
msgstr ""
"I :c:member:`!tp_basicsize` ingår den storlek som behövs för data i typens :"
"c:member:`~PyTypeObject.tp_base`, plus eventuella extra data som behövs för "
"varje instans."

msgid ""
"The  correct way to set :c:member:`!tp_basicsize` is to use the ``sizeof`` "
"operator on the struct used to declare the instance layout. This struct must "
"include the struct used to declare the base type. In other words, :c:member:"
"`!tp_basicsize` must be greater than or equal to the base's :c:member:`!"
"tp_basicsize`."
msgstr ""
"Det korrekta sättet att ange :c:member:`!tp_basicsize` är att använda "
"operatorn ``sizeof`` på den struct som används för att deklarera "
"instanslayouten. Denna struct måste inkludera den struct som används för att "
"deklarera bastypen. Med andra ord måste :c:member:`!tp_basicsize` vara "
"större än eller lika med basens :c:member:`!tp_basicsize`."

msgid ""
"Since every type is a subtype of :py:type:`object`, this struct must "
"include :c:type:`PyObject` or :c:type:`PyVarObject` (depending on whether :c:"
"member:`~PyVarObject.ob_size` should be included). These are usually defined "
"by the macro :c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD`, "
"respectively."
msgstr ""
"Eftersom varje typ är en subtyp av :py:type:`object` måste denna struktur "
"innehålla :c:type:`PyObject` eller :c:type:`PyVarObject` (beroende på om :c:"
"member:`~PyVarObject.ob_size` ska ingå). Dessa definieras vanligtvis av "
"makrot :c:macro:`PyObject_HEAD` respektive :c:macro:`PyObject_VAR_HEAD`."

msgid ""
"The basic size does not include the GC header size, as that header is not "
"part of :c:macro:`PyObject_HEAD`."
msgstr ""
"Grundstorleken inkluderar inte storleken på GC-huvudet, eftersom det huvudet "
"inte ingår i :c:macro:`PyObject_HEAD`."

msgid ""
"For cases where struct used to declare the base type is unknown, see :c:"
"member:`PyType_Spec.basicsize` and :c:func:`PyType_FromMetaclass`."
msgstr ""
"För fall där struct som används för att deklarera bastypen är okänd, se :c:"
"member:`PyType_Spec.basicsize` och :c:func:`PyType_FromMetaclass`."

msgid "Notes about alignment:"
msgstr "Anmärkningar om anpassning:"

msgid ""
":c:member:`!tp_basicsize` must be a multiple of ``_Alignof(PyObject)``. When "
"using ``sizeof`` on a ``struct`` that includes :c:macro:`PyObject_HEAD`, as "
"recommended, the compiler ensures this. When not using a C ``struct``, or "
"when using compiler extensions like ``__attribute__((packed))``, it is up to "
"you."
msgstr ""
":c:member:`!tp_basicsize` måste vara en multipel av ``_Alignof(PyObject)``. "
"När du använder ``sizeof`` på en ``struct`` som innehåller :c:macro:"
"`PyObject_HEAD`, som rekommenderat, säkerställer kompilatorn detta. Om du "
"inte använder en C-struktur, eller om du använder kompilatortillägg som "
"``__attribute__((packed))``, är det upp till dig."

msgid ""
"If the variable items require a particular alignment, :c:member:`!"
"tp_basicsize` and :c:member:`!tp_itemsize` must each be a multiple of that "
"alignment. For example, if a type's variable part stores a ``double``, it is "
"your responsibility that both fields are a multiple of ``_Alignof(double)``."
msgstr ""
"Om de variabla objekten kräver en viss inriktning måste :c:member:`!"
"tp_basicsize` och :c:member:`!tp_itemsize` var och en vara en multipel av "
"den inriktningen. Om t.ex. en variabeldel av en typ lagrar en ``double``, är "
"det ditt ansvar att båda fälten är en multipel av ``_Alignof(double)``."

msgid ""
"These fields are inherited separately by subtypes. (That is, if the field is "
"set to zero, :c:func:`PyType_Ready` will copy the value from the base type, "
"indicating that the instances do not need additional storage.)"
msgstr ""
"Dessa fält ärvs separat av subtyperna. (Det vill säga, om fältet är satt "
"till noll kommer :c:func:`PyType_Ready` att kopiera värdet från bastypen, "
"vilket indikerar att instanserna inte behöver ytterligare lagring)"

msgid ""
"If the base type has a non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is "
"generally not safe to set :c:member:`~PyTypeObject.tp_itemsize` to a "
"different non-zero value in a subtype (though this depends on the "
"implementation of the base type)."
msgstr ""
"Om bastypen har ett icke-nollvärde för :c:member:`~PyTypeObject.tp_itemsize` "
"är det i allmänhet inte säkert att ange :c:member:`~PyTypeObject."
"tp_itemsize` till ett annat icke-nollvärde i en subtyp (detta beror dock på "
"implementeringen av bastypen)."

msgid ""
"A pointer to the instance destructor function.  The function signature is::"
msgstr ""
"En pekare till instansens destruktorfunktion.  Funktionens signatur är::"

msgid "void tp_dealloc(PyObject *self);"
msgstr "void tp_dealloc(PyObject *self);"

msgid ""
"The destructor function should remove all references which the instance owns "
"(e.g., call :c:func:`Py_CLEAR`), free all memory buffers owned by the "
"instance, and call the type's :c:member:`~PyTypeObject.tp_free` function to "
"free the object itself."
msgstr ""
"Destruktorfunktionen ska ta bort alla referenser som instansen äger (t.ex. "
"anropa :c:func:`Py_CLEAR`), frigöra alla minnesbuffertar som instansen äger "
"och anropa typens :c:member:`~PyTypeObject.tp_free`-funktion för att frigöra "
"själva objektet."

msgid ""
"If you may call functions that may set the error indicator, you must use :c:"
"func:`PyErr_GetRaisedException` and :c:func:`PyErr_SetRaisedException` to "
"ensure you don't clobber a preexisting error indicator (the deallocation "
"could have occurred while processing a different error):"
msgstr ""
"Om du kan anropa funktioner som kan ställa in felindikatorn måste du "
"använda :c:func:`PyErr_GetRaisedException` och :c:func:"
"`PyErr_SetRaisedException` för att säkerställa att du inte slår ut en redan "
"existerande felindikator (deallokeringen kan ha inträffat under behandlingen "
"av ett annat fel):"

msgid ""
"static void\n"
"foo_dealloc(foo_object *self)\n"
"{\n"
"    PyObject *et, *ev, *etb;\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"    ...\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"statiskt void\n"
"foo_dealloc(foo_objekt *self)\n"
"{\n"
"    PyObject *et, *ev, *etb;\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"    ...\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

msgid ""
"The dealloc handler itself must not raise an exception; if it hits an error "
"case it should call :c:func:`PyErr_FormatUnraisable` to log (and clear) an "
"unraisable exception."
msgstr ""
"Själva dealloc-hanteraren får inte ge upphov till ett undantag; om den "
"stöter på ett felfall bör den anropa :c:func:`PyErr_FormatUnraisable` för "
"att logga (och rensa) ett undantag som inte går att radera."

msgid "No guarantees are made about when an object is destroyed, except:"
msgstr "Det finns inga garantier för när ett objekt förstörs, förutom:"

msgid ""
"Python will destroy an object immediately or some time after the final "
"reference to the object is deleted, unless its finalizer (:c:member:"
"`~PyTypeObject.tp_finalize`) subsequently resurrects the object."
msgstr ""
"Python kommer att förstöra ett objekt omedelbart eller en tid efter att den "
"sista referensen till objektet har tagits bort, såvida inte dess finalizer (:"
"c:member:`~PyTypeObject.tp_finalize`) därefter återupplivar objektet."

msgid ""
"An object will not be destroyed while it is being automatically finalized (:"
"c:member:`~PyTypeObject.tp_finalize`) or automatically cleared (:c:member:"
"`~PyTypeObject.tp_clear`)."
msgstr ""
"Ett objekt kommer inte att förstöras medan det automatiskt slutförs (:c:"
"member:`~PyTypeObject.tp_finalize`) eller automatiskt rensas (:c:member:"
"`~PyTypeObject.tp_clear`)."

msgid ""
"CPython currently destroys an object immediately from :c:func:`Py_DECREF` "
"when the new reference count is zero, but this may change in a future "
"version."
msgstr ""
"CPython förstör för närvarande ett objekt omedelbart från :c:func:"
"`Py_DECREF` när det nya referensantalet är noll, men detta kan ändras i en "
"framtida version."

msgid ""
"It is recommended to call :c:func:`PyObject_CallFinalizerFromDealloc` at the "
"beginning of :c:member:`!tp_dealloc` to guarantee that the object is always "
"finalized before destruction."
msgstr ""
"Det rekommenderas att anropa :c:func:`PyObject_CallFinalizerFromDealloc` i "
"början av :c:member:`!tp_dealloc` för att garantera att objektet alltid är "
"finalized innan det förstörs."

msgid ""
"If the type supports garbage collection (the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag is set), the destructor should call :c:func:`PyObject_GC_UnTrack` "
"before clearing any member fields."
msgstr ""
"Om typen stödjer garbage collection (flaggan :c:macro:`Py_TPFLAGS_HAVE_GC` "
"är satt) ska destruktorn anropa :c:func:`PyObject_GC_UnTrack` innan den "
"rensar några medlemsfält."

msgid ""
"It is permissible to call :c:member:`~PyTypeObject.tp_clear` from :c:member:"
"`!tp_dealloc` to reduce code duplication and to guarantee that the object is "
"always cleared before destruction.  Beware that :c:member:`!tp_clear` might "
"have already been called."
msgstr ""
"Det är tillåtet att anropa :c:member:`~PyTypeObject.tp_clear` från :c:member:"
"`!tp_dealloc` för att minska koddubblering och för att garantera att "
"objektet alltid rensas innan det förstörs.  Tänk på att :c:member:`!"
"tp_clear` redan kan ha anropats."

msgid ""
"If the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object (via :c:"
"func:`Py_DECREF`) after calling the type deallocator.  See the example code "
"below.::"
msgstr ""
"Om typen är heap-allokerad (:c:macro:`Py_TPFLAGS_HEAPTYPE`), bör "
"deallokatorn släppa den ägda referensen till sitt typobjekt (via :c:func:"
"`Py_DECREF`) efter anropet till typdeallokatorn.  Se exempelkoden nedan.::"

msgid ""
"static void\n"
"foo_dealloc(PyObject *op)\n"
"{\n"
"   foo_object *self = (foo_object *) op;\n"
"   PyObject_GC_UnTrack(self);\n"
"   Py_CLEAR(self->ref);\n"
"   Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"statiskt void\n"
"foo_dealloc(PyObject *op)\n"
"{\n"
"   foo_object *self = (foo_object *) op;\n"
"   PyObject_GC_UnTrack(self);\n"
"   Py_CLEAR(själv>ref);\n"
"   Py_TYPE(self)->tp_free(self);\n"
"}"

msgid ""
":c:member:`!tp_dealloc` must leave the exception status unchanged.  If it "
"needs to call something that might raise an exception, the exception state "
"must be backed up first and restored later (after logging any exceptions "
"with :c:func:`PyErr_WriteUnraisable`)."
msgstr ""
":c:member:`!tp_dealloc` måste lämna undantagsstatusen oförändrad.  Om den "
"behöver anropa något som kan ge upphov till ett undantag, måste "
"undantagstillståndet först säkerhetskopieras och återställas senare (efter "
"loggning av eventuella undantag med :c:func:`PyErr_WriteUnraisable`)."

msgid "Example::"
msgstr "Exempel::"

msgid ""
"static void\n"
"foo_dealloc(PyObject *self)\n"
"{\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    if (PyObject_CallFinalizerFromDealloc(self) < 0) {\n"
"        // self was resurrected.\n"
"        goto done;\n"
"    }\n"
"\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HAVE_GC) {\n"
"        PyObject_GC_UnTrack(self);\n"
"    }\n"
"\n"
"    // Optional, but convenient to avoid code duplication.\n"
"    if (tp->tp_clear && tp->tp_clear(self) < 0) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"\n"
"    // Any additional destruction goes here.\n"
"\n"
"    tp->tp_free(self);\n"
"    self = NULL;  // In case PyErr_WriteUnraisable() is called below.\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"        Py_CLEAR(tp);\n"
"    }\n"
"\n"
"done:\n"
"    // Optional, if something was called that might have raised an\n"
"    // exception.\n"
"    if (PyErr_Occurred()) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"statiskt void\n"
"foo_dealloc(PyObject *self)\n"
"{\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    if (PyObject_CallFinalizerFromDealloc(self) < 0) {\n"
"        // self återupplivades.\n"
"        goto done;\n"
"    }\n"
"\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HAVE_GC) {\n"
"        PyObject_GC_UnTrack(self);\n"
"    }\n"
"\n"
"    // Valfritt, men praktiskt för att undvika koddubblering.\n"
"    if (tp->tp_clear && tp->tp_clear(self) < 0) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"\n"
"    // Eventuell ytterligare förstörelse hamnar här.\n"
"\n"
"    tp->tp_free(self);\n"
"    self = NULL; // Ifall PyErr_WriteUnraisable() anropas nedan.\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"        Py_CLEAR(tp);\n"
"    }\n"
"\n"
"done:\n"
"    // Valfritt, om något anropades som kan ha gett upphov till ett\n"
"    // undantag.\n"
"    if (PyErr_Occurred()) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

msgid ""
":c:member:`!tp_dealloc` may be called from any Python thread, not just the "
"thread which created the object (if the object becomes part of a refcount "
"cycle, that cycle might be collected by a garbage collection on any "
"thread).  This is not a problem for Python API calls, since the thread on "
"which :c:member:`!tp_dealloc` is called with an :term:`attached thread "
"state`.  However, if the object being destroyed in turn destroys objects "
"from some other C library, care should be taken to ensure that destroying "
"those objects on the thread which called :c:member:`!tp_dealloc` will not "
"violate any assumptions of the library."
msgstr ""
":c:member:`!tp_dealloc` kan anropas från vilken Python-tråd som helst, inte "
"bara den tråd som skapade objektet (om objektet blir en del av en refcount-"
"cykel kan den cykeln samlas in av en garbage collection på vilken tråd som "
"helst).  Detta är inte ett problem för Python API-anrop, eftersom den tråd "
"som :c:member:`!tp_dealloc` anropas från har en :term:`attached thread "
"state`.  Men om objektet som förstörs i sin tur förstör objekt från något "
"annat C-bibliotek, bör man se till att förstörelsen av dessa objekt i den "
"tråd som anropade :c:member:`!tp_dealloc` inte bryter mot några antaganden i "
"biblioteket."

msgid ""
":ref:`life-cycle` for details about how this slot relates to other slots."
msgstr ""
":ref:`life-cycle` för detaljer om hur denna slot förhåller sig till andra "
"slots."

msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"En valfri offset till en funktion per instans som implementerar anrop av "
"objektet med hjälp av :ref:`vectorcall-protokollet <vectorcall>`, ett "
"effektivare alternativ till den enklare :c:member:`~PyTypeObject.tp_call`."

msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Detta fält används endast om flaggan :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` "
"är satt. Om så är fallet måste detta vara ett positivt heltal som innehåller "
"offset i instansen för en pekare av typen :c:type:`vectorcallfunc`."

msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Poängaren *vectorcallfunc* kan vara ``NULL``, i vilket fall instansen beter "
"sig som om :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` inte var inställd: anrop av "
"instansen faller tillbaka till :c:member:`~PyTypeObject.tp_call`."

msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Alla klasser som ställer in ``Py_TPFLAGS_HAVE_VECTORCALL`` måste också "
"ställa in :c:member:`~PyTypeObject.tp_call` och se till att dess beteende är "
"förenligt med funktionen *vectorcallfunc*. Detta kan göras genom att ställa "
"in *tp_call* till :c:func:`PyVectorcall_Call`."

msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"Före version 3.8 hette denna slot ``tp_print``. I Python 2.x användes den "
"för utskrift till en fil. I Python 3.0 till 3.7 var den oanvänd."

msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user sets :attr:"
"`~object.__call__` in Python code, only *tp_call* is updated, likely making "
"it inconsistent with the vectorcall function. Since 3.12, setting "
"``__call__`` will disable vectorcall optimization by clearing the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""
"Före version 3.12 var det inte rekommenderat för :ref:`mutable heap types "
"<heap-types>` att implementera vectorcall-protokollet. När en användare "
"ställer in :attr:`~object.__call__` i Python-kod, uppdateras endast "
"*tp_call*, vilket sannolikt gör den inkonsekvent med vectorcall-funktionen. "
"Sedan 3.12 kommer inställningen ``__call__`` att inaktivera vectorcall-"
"optimering genom att rensa flaggan :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL`."

msgid ""
"This field is always inherited. However, the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not set, "
"then the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:"
"func:`PyVectorcall_Call` is explicitly called."
msgstr ""
"Detta fält är alltid ärftligt. Dock är :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` "
"flaggan inte alltid ärvd. Om den inte är satt, kommer subklassen inte att "
"använda :ref:`vectorcall <vectorcall>`, förutom när :c:func:"
"`PyVectorcall_Call` explicit anropas."

msgid "An optional pointer to the get-attribute-string function."
msgstr "En valfri pekare till funktionen get-attribute-string."

msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Detta fält är föråldrat.  När det definieras bör det peka på en funktion som "
"fungerar på samma sätt som :c:member:`~PyTypeObject.tp_getattro`-funktionen, "
"men som tar en C-sträng istället för ett Python-strängobjekt för att ge "
"attributnamnet."

msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"
msgstr ""
"Grupp: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_getattro`: en subtyp ärver både :c:member:`~PyTypeObject.tp_getattr` och :"
"c:member:`~PyTypeObject.tp_getattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_getattr` och :c:member:`~PyTypeObject.tp_getattro` båda är "
"``NULL``."

msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr ""
"En valfri pekare till funktionen för att ställa in och ta bort attribut."

msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Detta fält är föråldrat.  När det definieras bör det peka på en funktion som "
"fungerar på samma sätt som :c:member:`~PyTypeObject.tp_setattro`-funktionen, "
"men som tar en C-sträng istället för ett Python-strängobjekt för att ge "
"attributnamnet."

msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"
msgstr ""
"Grupp: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_setattro`: en subtyp ärver både :c:member:`~PyTypeObject.tp_setattr` och :"
"c:member:`~PyTypeObject.tp_setattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_setattr` och :c:member:`~PyTypeObject.tp_setattro` båda är "
"``NULL``."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar protokollen :term:`awaitable` och :"
"term:`asynchronous iterator` på C-nivå.  Se :ref:`async-structs` för "
"detaljer."

msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Tidigare känd som ``tp_compare`` och ``tp_reserved``."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_async` ärvs inte, men de ingående "
"fälten ärvs individuellt."

msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"En valfri pekare till en funktion som implementerar den inbyggda funktionen :"
"func:`repr`."

msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_Repr`::"

msgid "PyObject *tp_repr(PyObject *self);"
msgstr "PyObject *tp_repr(PyObject *self);"

msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"Funktionen måste returnera en sträng eller ett Unicode-objekt.  Helst ska "
"denna funktion returnera en sträng som, när den skickas till :func:`eval`, i "
"en lämplig miljö, returnerar ett objekt med samma värde.  Om detta inte är "
"möjligt, bör den returnera en sträng som börjar med ``'<'`` och slutar med "
"``'>'`` från vilken både typen och värdet på objektet kan härledas."

msgid "**Default:**"
msgstr "**Förval:**"

msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Om detta fält inte är inställt returneras en sträng av formen ``<%s object "
"at %p>``, där ``%s`` ersätts av typnamnet och ``%p`` av objektets "
"minnesadress."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar nummerprotokollet.  Dessa fält är "
"dokumenterade i :ref:`number-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_number` ärvs inte, men de ingående "
"fälten ärvs individuellt."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar sekvensprotokollet.  Dessa fält är "
"dokumenterade i :ref:`sequence-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_sequence` ärvs inte, men de ingående "
"fälten ärvs individuellt."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar mappningsprotokollet.  Dessa fält är "
"dokumenterade i :ref:`mapping-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_mapping` ärvs inte, men de ingående "
"fälten ärvs individuellt."

msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"En valfri pekare till en funktion som implementerar den inbyggda funktionen :"
"func:`hash`."

msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_Hash`::"

msgid "Py_hash_t tp_hash(PyObject *);"
msgstr "Py_hash_t tp_hash(PyObject *);"

msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"Värdet ``-1`` ska inte returneras som ett normalt returvärde; när ett fel "
"inträffar under beräkningen av hashvärdet ska funktionen sätta ett undantag "
"och returnera ``-1``."

msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object raises :exc:"
"`TypeError`. This is the same as setting it to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"När detta fält inte är inställt (*och* :c:member:`~PyTypeObject."
"tp_richcompare` inte är inställt), kommer ett försök att ta objektets hash "
"att ge upphov till :exc:`TypeError`. Detta är samma sak som att sätta den "
"till :c:func:`PyObject_HashNotImplemented`."

msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Detta fält kan explicit sättas till :c:func:`PyObject_HashNotImplemented` "
"för att blockera arv av hash-metoden från en överordnad typ. Detta tolkas "
"som motsvarigheten till ``__hash__ = None`` på Python-nivå, vilket gör att "
"``isinstance(o, collections.Hashable)`` korrekt returnerar ``False``. "
"Observera att det omvända också är sant - att sätta ``__hash__ = None`` på "
"en klass på Python-nivå kommer att resultera i att ``tp_hash`` slot sätts "
"till :c:func:`PyObject_HashNotImplemented`."

msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"
msgstr ""
"Grupp: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_richcompare`: en subtyp ärver både :c:member:`~PyTypeObject."
"tp_richcompare` och :c:member:`~PyTypeObject.tp_hash`, när subtypens :c:"
"member:`~PyTypeObject.tp_richcompare` och :c:member:`~PyTypeObject.tp_hash` "
"båda är ``NULL``."

msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericHash`."
msgstr ":c:data:`PyBaseObject_Type` använder :c:func:`PyObject_GenericHash`."

msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"En valfri pekare till en funktion som implementerar anrop av objektet.  "
"Denna bör vara ``NULL`` om objektet inte är anropsbart.  Signaturen är "
"densamma som för :c:func:`PyObject_Call`::"

msgid "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"
msgstr "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"

msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"En valfri pekare till en funktion som implementerar den inbyggda "
"operationen :func:`str`.  (Observera att :class:`str` nu är en typ och att :"
"func:`str` anropar konstruktören för den typen.  Denna konstruktör anropar :"
"c:func:`PyObject_Str` för att göra det faktiska arbetet, och :c:func:"
"`PyObject_Str` kommer att anropa denna hanterare)"

msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_Str`::"

msgid "PyObject *tp_str(PyObject *self);"
msgstr "PyObject *tp_str(PyObject *self);"

msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"Funktionen måste returnera en sträng eller ett Unicode-objekt.  Det bör vara "
"en \"vänlig\" strängrepresentation av objektet, eftersom det är den "
"representation som kommer att användas, bland annat, av funktionen :func:"
"`print`."

msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"När detta fält inte är inställt anropas :c:func:`PyObject_Repr` för att "
"returnera en strängrepresentation."

msgid "An optional pointer to the get-attribute function."
msgstr "En valfri pekare till funktionen get-attribute."

msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_GetAttr`::"

msgid "PyObject *tp_getattro(PyObject *self, PyObject *attr);"
msgstr "PyObject *tp_getattro(PyObject *self, PyObject *attr);"

msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"Det är oftast lämpligt att ställa in detta fält till :c:func:"
"`PyObject_GenericGetAttr`, som implementerar det normala sättet att leta "
"efter objektattribut."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_getattr`: en subtyp ärver både :c:member:`~PyTypeObject.tp_getattr` och :"
"c:member:`~PyTypeObject.tp_getattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_getattr` och :c:member:`~PyTypeObject.tp_getattro` båda är "
"``NULL``."

msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` använder :c:func:`PyObject_GenericGetAttr`."

msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "Signaturen är densamma som för :c:func:`PyObject_SetAttr`::"

msgid "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"
msgstr "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"

msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Dessutom måste det finnas stöd för att sätta *value* till ``NULL`` för att "
"ta bort ett attribut.  Det är vanligtvis bekvämt att ställa in detta fält "
"till :c:func:`PyObject_GenericSetAttr`, som implementerar det normala sättet "
"att ställa in objektattribut."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_setattr`: en subtyp ärver både :c:member:`~PyTypeObject.tp_setattr` och :"
"c:member:`~PyTypeObject.tp_setattro` från sin bastyp när subtypens :c:member:"
"`~PyTypeObject.tp_setattr` och :c:member:`~PyTypeObject.tp_setattro` båda är "
"``NULL``."

msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` använder :c:func:`PyObject_GenericSetAttr`."

msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Pekare till en ytterligare struktur som innehåller fält som endast är "
"relevanta för objekt som implementerar buffertgränssnittet.  Dessa fält är "
"dokumenterade i :ref:`buffer-structs`."

msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Fältet :c:member:`~PyTypeObject.tp_as_buffer` ärvs inte, men de ingående "
"fälten ärvs individuellt."

msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Detta fält är en bitmask med olika flaggor.  Vissa flaggor anger varierande "
"semantik för vissa situationer; andra används för att ange att vissa fält i "
"typobjektet (eller i de tilläggsstrukturer som refereras via :c:member:"
"`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject.tp_as_sequence`, :c:"
"member:`~PyTypeObject.tp_as_mapping`, och :c:member:`~PyTypeObject."
"tp_as_buffer`) som historiskt sett inte alltid funnits är giltiga; om en "
"sådan flaggbit är klar får de typfält som den skyddar inte nås och måste "
"anses ha värdet noll eller ``NULL`` istället."

msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""
"Nedärvningen av detta fält är komplicerad.  De flesta flaggbitar ärvs "
"individuellt, dvs. om bastypen har en flaggbit inställd ärver subtypen denna "
"flaggbit.  De flaggbitar som hör till tilläggsstrukturer ärvs strikt om "
"tilläggsstrukturen ärvs, d.v.s. bastypens värde på flaggbiten kopieras till "
"subtypen tillsammans med en pekare till tilläggsstrukturen.  Flaggbiten :c:"
"macro:`Py_TPFLAGS_HAVE_GC` ärvs tillsammans med fälten :c:member:"
"`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear`, dvs. om "
"flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC` är klar i subtypen och fälten :c:"
"member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear` i "
"subtypen finns och har värdena ``NULL``."

msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:data:`PyBaseObject_Type` använder ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."

msgid "**Bit Masks:**"
msgstr "**Bitmasker:**"

msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"Följande bitmasker är för närvarande definierade; dessa kan kombineras med "
"operatorn ``|`` för att bilda värdet i fältet :c:member:`~PyTypeObject."
"tp_flags`.  Makrot :c:func:`PyType_HasFeature` tar en typ och ett "
"flaggvärde, *tp* och *f*, och kontrollerar om ``tp->tp_flags & f`` är icke-"
"noll."

msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :c:member:`~PyObject.ob_type` field of its instances is considered "
"a reference to the type, and the type object is INCREF'ed when a new "
"instance is created, and DECREF'ed when an instance is destroyed (this does "
"not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed). Heap types should also :ref:"
"`support garbage collection <supporting-cycle-detection>` as they can form a "
"reference cycle with their own module object."
msgstr ""
"Denna bit är inställd när själva typobjektet allokeras på heapen, t.ex. "
"typer som skapas dynamiskt med :c:func:`PyType_FromSpec`.  I detta fall "
"betraktas fältet :c:member:`~PyObject.ob_type` i dess instanser som en "
"referens till typen, och typobjektet INCREF'ed när en ny instans skapas, och "
"DECREF'ed när en instans förstörs (detta gäller inte instanser av subtyper; "
"endast den typ som instansens ob_type refererar till INCREF'ed eller "
"DECREF'ed). Heap-typer bör också :ref:`stödja garbage collection <supporting-"
"cycle-detection>` eftersom de kan bilda en referenscykel med sitt eget "
"modulobjekt."

msgid "???"
msgstr "???"

msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Denna bit är satt när typen kan användas som bastyp för en annan typ.  Om "
"denna bit är klar kan typen inte subtypas (på samma sätt som en \"final\"-"
"klass i Java)."

msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Denna bit är inställd när typobjektet har initialiserats fullständigt av :c:"
"func:`PyType_Ready`."

msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Denna bit är inställd när :c:func:`PyType_Ready` håller på att initiera "
"typobjektet."

msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, memory for new instances (see :c:member:`~PyTypeObject.tp_alloc`) must "
"be allocated using :c:macro:`PyObject_GC_New` or :c:func:"
"`PyType_GenericAlloc` and deallocated (see :c:member:`~PyTypeObject."
"tp_free`) using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`."
msgstr ""
"Denna bit är inställd när objektet stöder garbage collection.  Om denna bit "
"är inställd måste minne för nya instanser (se :c:member:`~PyTypeObject."
"tp_alloc`) allokeras med :c:macro:`PyObject_GC_New` eller :c:func:"
"`PyType_GenericAlloc` och avallokeras (se :c:member:`~PyTypeObject.tp_free`) "
"med :c:func:`PyObject_GC_Del`.  Mer information finns i avsnitt :ref:"
"`supporting-cycle-detection`."

msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"
msgstr ""
"Grupp: :c:makro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"

msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:"
"member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` "
"fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL`` "
"values."
msgstr ""
"Flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC` ärvs tillsammans med fälten :c:"
"member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear`, "
"dvs.  om flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC` är klar i subtypen och "
"fälten :c:member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject."
"tp_clear` i subtypen finns och har värdena ``NULL``."

msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Detta är en bitmask med alla de bitar som rör förekomsten av vissa fält i "
"typobjektet och dess tilläggsstrukturer. För närvarande innehåller den "
"följande bitar: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

msgid "This bit indicates that objects behave like unbound methods."
msgstr "Denna bit indikerar att objekt beter sig som obundna metoder."

msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Om denna flagga är inställd för ``typ(meth)``, då:"

msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (med ``obj`` inte None) måste vara "
"likvärdig med ``meth(obj, *args, **kwds)``."

msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` måste vara likvärdig med "
"``meth(*args, **kwds)``."

msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Denna flagga möjliggör en optimering för typiska metodanrop som ``obj."
"meth()``: den undviker att skapa ett tillfälligt \"bound method\"-objekt för "
"``obj.meth``."

msgid ""
"This flag is never inherited by types without the :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is inherited "
"whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"Denna flagga ärvs aldrig av typer som inte har flaggan :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` inställd.  För tilläggstyper ärvs den närhelst :c:"
"member:`~PyTypeObject.tp_descr_get` ärvs."

msgid ""
"This bit indicates that instances of the class have a :attr:`~object."
"__dict__` attribute, and that the space for the dictionary is managed by the "
"VM."
msgstr ""
"Denna bit anger att instanser av klassen har attributet :attr:`~object."
"__dict__` och att utrymmet för ordlistan hanteras av den virtuella datorn."

msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr ""
"Om denna flagga är satt, bör :c:macro:`Py_TPFLAGS_HAVE_GC` också vara satt."

msgid ""
"The type traverse function must call :c:func:`PyObject_VisitManagedDict` and "
"its clear function must call :c:func:`PyObject_ClearManagedDict`."
msgstr ""
"Typövergångsfunktionen måste anropa :c:func:`PyObject_VisitManagedDict` och "
"dess rensningsfunktion måste anropa :c:func:`PyObject_ClearManagedDict`."

msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset` "
"field is set in a superclass."
msgstr ""
"Denna flagga ärvs om inte fältet :c:member:`~PyTypeObject.tp_dictoffset` är "
"inställt i en superklass."

msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr "Denna bit anger att instanser av klassen ska vara svagt refererbara."

msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject."
"tp_weaklistoffset` field is set in a superclass."
msgstr ""
"Denna flagga ärvs om inte fältet :c:member:`~PyTypeObject.tp_weaklistoffset` "
"är inställt i en superklass."

msgid ""
"Only usable with variable-size types, i.e. ones with non-zero :c:member:"
"`~PyTypeObject.tp_itemsize`."
msgstr ""
"Används endast med typer med variabel storlek, dvs. sådana som har :c:member:"
"`~PyTypeObject.tp_itemsize` som inte är noll."

msgid ""
"Indicates that the variable-sized portion of an instance of this type is at "
"the end of the instance's memory area, at an offset of ``Py_TYPE(obj)-"
">tp_basicsize`` (which may be different in each subclass)."
msgstr ""
"Indikerar att den variabelstora delen av en instans av denna typ är i slutet "
"av instansens minnesområde, vid en offset av ``Py_TYPE(obj)->tp_basicsize`` "
"(som kan vara annorlunda i varje underklass)."

msgid ""
"When setting this flag, be sure that all superclasses either use this memory "
"layout, or are not variable-sized. Python does not check this."
msgstr ""
"När du ställer in denna flagga måste du se till att alla superklasser "
"antingen använder denna minneslayout eller inte har variabel storlek. Python "
"kontrollerar inte detta."

msgid "This flag is inherited."
msgstr "Denna flagga ärvs."

msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"Dessa flaggor används av funktioner som :c:func:`PyLong_Check` för att "
"snabbt avgöra om en typ är en underklass av en inbyggd typ; sådana specifika "
"kontroller är snabbare än en generisk kontroll, som :c:func:"
"`PyObject_IsInstance`. Anpassade typer som ärver från inbyggda typer bör ha "
"sina :c:member:`~PyTypeObject.tp_flags` inställda på lämpligt sätt, annars "
"kommer koden som interagerar med sådana typer att bete sig annorlunda "
"beroende på vilken typ av kontroll som används."

msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Denna bit är inställd när :c:member:`~PyTypeObject.tp_finalize` finns i "
"typstrukturen."

msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Denna flagga är inte längre nödvändig, eftersom tolken antar att :c:member:"
"`~PyTypeObject.tp_finalize` alltid finns i typstrukturen."

msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Denna bit är inställd när klassen implementerar :ref:`vectorcall-protokollet "
"<vectorcall>`. Se :c:member:`~PyTypeObject.tp_vectorcall_offset` för "
"detaljer."

msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also inherited."
msgstr "Denna bit ärvs om :c:member:`~PyTypeObject.tp_call` också ärvs."

msgid ""
"This flag is now removed from a class when the class's :py:meth:`~object."
"__call__` method is reassigned."
msgstr ""
"Denna flagga tas nu bort från en klass när klassens :py:meth:`~object."
"__call__`-metod tilldelas på nytt."

msgid "This flag can now be inherited by mutable classes."
msgstr "Denna flagga kan nu ärvas av mutabla klasser."

msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Denna bit är inställd för typobjekt som är oföränderliga: typattribut kan "
"inte ställas in eller tas bort."

msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` tillämpar automatiskt denna flagga på :ref:`static "
"types <static-types>`."

msgid "This flag is not inherited."
msgstr "Denna flagga är inte ärftlig."

msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"Tillåt inte att skapa instanser av typen: sätt :c:member:`~PyTypeObject."
"tp_new` till NULL och skapa inte nyckeln ``__new__`` i typordboken."

msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"Flaggan måste anges innan typen skapas, inte efteråt. Den måste till exempel "
"ställas in innan :c:func:`PyType_Ready` anropas på typen."

msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"Flaggan sätts automatiskt på :ref:`static types <static-types>` om :c:member:"
"`~PyTypeObject.tp_base` är NULL eller ``&amp;PyBaseObject_Type`` och :c:"
"member:`~PyTypeObject.tp_new` är NULL."

msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"Denna flagga ärvs inte. Underklasser kommer dock inte att kunna instansieras "
"om de inte tillhandahåller en icke-NULL :c:member:`~PyTypeObject.tp_new` "
"(vilket endast är möjligt via C API)."

msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"Använd inte denna flagga för att inte tillåta instansiering av en klass "
"direkt men tillåta instansiering av dess underklasser (t.ex. för en :term:"
"`abstrakt basklass`). Gör istället så att :c:member:`~PyTypeObject.tp_new` "
"bara lyckas för underklasser."

msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Denna bit indikerar att instanser av klassen kan matcha mappningsmönster när "
"de används som ämne för ett :keyword:`match`-block. Den sätts automatiskt "
"vid registrering eller underklassning av :class:`collections.abc.Mapping`, "
"och avmarkeras vid registrering av :class:`collections.abc.Sequence`."

msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":c:macro:`Py_TPFLAGS_MAPPING` och :c:macro:`Py_TPFLAGS_SEQUENCE` är "
"ömsesidigt uteslutande; det är ett fel att aktivera båda flaggorna samtidigt."

msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Denna flagga ärvs av typer som inte redan har satt :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."

msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Matchning av strukturella mönster: Specifikation"

msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Denna bit indikerar att instanser av klassen kan matcha sekvensmönster när "
"de används som subjekt i ett :keyword:`match`-block. Den sätts automatiskt "
"vid registrering eller underklassning av :class:`collections.abc.Sequence`, "
"och avmarkeras vid registrering av :class:`collections.abc.Mapping`."

msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_MAPPING`."
msgstr ""
"Denna flagga ärvs av typer som inte redan har satt :c:macro:"
"`Py_TPFLAGS_MAPPING`."

msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr ""
"Internt. Denna flagga ska inte ställas in eller tas bort. För att indikera "
"att en klass har ändrats anropa :c:func:`PyType_Modified`"

msgid ""
"This flag is present in header files, but is not be used. It will be removed "
"in a future version of CPython"
msgstr ""
"Denna flagga finns i header-filer, men används inte. Den kommer att tas bort "
"i en framtida version av CPython"

msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`~type.__doc__` attribute on "
"the type and instances of the type."
msgstr ""
"En valfri pekare till en NUL-avslutad C-sträng som anger dokumentsträngen "
"för detta typobjekt.  Detta exponeras som attributet :attr:`~type.__doc__` "
"på typen och instanser av typen."

msgid "This field is *not* inherited by subtypes."
msgstr "Detta fält ärvs *inte* av subtyper."

msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"En valfri pekare till en traversalfunktion för skräpsamlaren.  Denna används "
"endast om flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC` är satt.  Signaturen är::"

msgid "int tp_traverse(PyObject *self, visitproc visit, void *arg);"
msgstr "int tp_traverse(PyObject *self, visitproc visit, void *arg);"

msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Mer information om Pythons skräpplockningssystem finns i avsnitt :ref:"
"`supporting-cycle-detection`."

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`!local_traverse` from the :mod:"
"`!_thread` extension module::"
msgstr ""
"Pekaren :c:member:`~PyTypeObject.tp_traverse` används av garbage collector "
"för att upptäcka referenscykler. En typisk implementering av en :c:member:"
"`~PyTypeObject.tp_traverse`-funktion anropar helt enkelt :c:func:`Py_VISIT` "
"på var och en av instansens medlemmar som är Python-objekt som instansen "
"äger. Detta är till exempel funktionen :c:func:`!local_traverse` från "
"tilläggsmodulen :mod:`!_thread`::"

msgid ""
"static int\n"
"local_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"local_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(själv>kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"

msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Observera att :c:func:`Py_VISIT` endast anropas på de medlemmar som kan "
"delta i referenscykler.  Även om det också finns en ``self->key``-medlem, "
"kan den bara vara ``NULL`` eller en Python-sträng och kan därför inte vara "
"en del av en referenscykel."

msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"Å andra sidan, även om du vet att en medlem aldrig kan ingå i en cykel, kan "
"du som felsökningshjälp vilja besöka den ändå, bara för att :mod:`gc`-"
"modulens :func:`~gc.get_referents`-funktion ska inkludera den."

msgid ""
"Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"
msgstr "Heap-typer (:c:macro:`Py_TPFLAGS_HEAPTYPE`) måste besöka sin typ med::"

msgid "Py_VISIT(Py_TYPE(self));"
msgstr "Py_VISIT(Py_TYPE(self));"

msgid ""
"It is only needed since Python 3.9. To support Python 3.8 and older, this "
"line must be conditional::"
msgstr ""
"Den behövs bara sedan Python 3.9. För att stödja Python 3.8 och äldre måste "
"denna rad vara villkorlig::"

msgid ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"
msgstr ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"

msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the traverse function must call :c:func:"
"`PyObject_VisitManagedDict` like this::"
msgstr ""
"Om bit :c:macro:`Py_TPFLAGS_MANAGED_DICT` är inställd i fältet :c:member:"
"`~PyTypeObject.tp_flags` måste traversefunktionen anropa :c:func:"
"`PyObject_VisitManagedDict` så här::"

msgid "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"
msgstr "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"

msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"Vid implementering av :c:member:`~PyTypeObject.tp_traverse`, måste endast de "
"medlemmar som instansen *äger* (genom att ha :term:`strong references "
"<strong reference>` till dem) besökas. Om ett objekt t.ex. stöder svaga "
"referenser via :c:member:`~PyTypeObject.tp_weaklist` slot, får pekaren som "
"stöder den länkade listan (som *tp_weaklist* pekar på) **inte** besökas "
"eftersom instansen inte direkt äger de svaga referenserna till sig själv "
"(weakreference-listan finns där för att stödja maskineriet för svaga "
"referenser, men instansen har ingen stark referens till elementen inuti den, "
"eftersom de får tas bort även om instansen fortfarande lever)."

msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`!local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Observera att :c:func:`Py_VISIT` kräver att parametrarna *visit* och *arg* "
"till :c:func:`!local_traverse` har dessa specifika namn; ge dem inte vilka "
"namn som helst."

msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
"Instanser av :ref:``heap-allocated types <heap-types>` håller en referens "
"till sin typ. Deras traversalfunktion måste därför antingen besöka :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, eller delegera detta ansvar genom att anropa "
"``tp_traverse`` av en annan heap-allokerad typ (såsom en heap-allokerad "
"superklass). Om de inte gör det kan det hända att typobjektet inte är "
"garbage-collected."

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` function can be called from any "
"thread."
msgstr ""
"Funktionen :c:member:`~PyTypeObject.tp_traverse` kan anropas från vilken "
"tråd som helst."

msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Heap-allokerade typer förväntas besöka ``Py_TYPE(self)`` i ``tp_traverse``.  "
"I tidigare versioner av Python, på grund av `bug 40217 <https://bugs.python."
"org/issue40217>`_, kan detta leda till krascher i underklasser."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_clear` och flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC`: flaggbiten, :c:"
"member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear` "
"ärvs alla från bastypen om de alla är noll i subtypen."

msgid "An optional pointer to a clear function.  The signature is::"
msgstr "En valfri pekare till en tydlig funktion.  Signaturen är::"

msgid "int tp_clear(PyObject *);"
msgstr "int tp_clear(PyObject *);"

msgid ""
"The purpose of this function is to break reference cycles that are causing "
"a :term:`cyclic isolate` so that the objects can be safely destroyed.  A "
"cleared object is a partially destroyed object; the object is not obligated "
"to satisfy design invariants held during normal use."
msgstr ""
"Syftet med denna funktion är att bryta referenscykler som orsakar en :term:"
"`cyclic isolate` så att objekten kan förstöras på ett säkert sätt.  Ett "
"rensat objekt är ett delvis förstört objekt; objektet är inte skyldigt att "
"uppfylla designinvarianter som hålls under normal användning."

msgid ""
":c:member:`!tp_clear` does not need to delete references to objects that "
"can't participate in reference cycles, such as Python strings or Python "
"integers.  However, it may be convenient to clear all references, and write "
"the type's :c:member:`~PyTypeObject.tp_dealloc` function to invoke :c:member:"
"`!tp_clear` to avoid code duplication.  (Beware that :c:member:`!tp_clear` "
"might have already been called. Prefer calling idempotent functions like :c:"
"func:`Py_CLEAR`.)"
msgstr ""
":c:member:`!tp_clear` behöver inte radera referenser till objekt som inte "
"kan delta i referenscykler, t.ex. Python-strängar eller Python-integraler.  "
"Det kan dock vara bekvämt att rensa alla referenser och skriva typens :c:"
"member:`~PyTypeObject.tp_dealloc`-funktion för att anropa :c:member:`!"
"tp_clear` för att undvika koddubblering.  (Tänk på att :c:member:`!tp_clear` "
"kanske redan har anropats. Föredra att anropa idempotenta funktioner som :c:"
"func:`Py_CLEAR`)"

msgid ""
"Any non-trivial cleanup should be performed in :c:member:`~PyTypeObject."
"tp_finalize` instead of :c:member:`!tp_clear`."
msgstr ""
"All icke-trivial upprensning bör utföras i :c:member:`~PyTypeObject."
"tp_finalize` istället för :c:member:`!tp_clear`."

msgid ""
"If :c:member:`!tp_clear` fails to break a reference cycle then the objects "
"in the :term:`cyclic isolate` may remain indefinitely uncollectable "
"(\"leak\").  See :data:`gc.garbage`."
msgstr ""
"Om :c:member:`!tp_clear` misslyckas med att bryta en referenscykel kan "
"objekten i :term:`cyclic isolate` förbli obegränsat oinsamlingsbara "
"(\"läcka\").  Se :data:`gc.garbage`."

msgid ""
"Referents (direct and indirect) might have already been cleared; they are "
"not guaranteed to be in a consistent state."
msgstr ""
"Referenser (direkta och indirekta) kan redan ha rensats; det är inte "
"garanterat att de är i ett konsekvent tillstånd."

msgid ""
"The :c:member:`~PyTypeObject.tp_clear` function can be called from any "
"thread."
msgstr ""
"Funktionen :c:member:`~PyTypeObject.tp_clear` kan anropas från vilken tråd "
"som helst."

msgid ""
"An object is not guaranteed to be automatically cleared before its "
"destructor (:c:member:`~PyTypeObject.tp_dealloc`) is called."
msgstr ""
"Det är inte garanterat att ett objekt automatiskt rensas innan dess "
"destruktor (:c:member:`~PyTypeObject.tp_dealloc`) anropas."

msgid ""
"This function differs from the destructor (:c:member:`~PyTypeObject."
"tp_dealloc`) in the following ways:"
msgstr ""
"Denna funktion skiljer sig från destruktorn (:c:member:`~PyTypeObject."
"tp_dealloc`) på följande sätt:"

msgid ""
"The purpose of clearing an object is to remove references to other objects "
"that might participate in a reference cycle.  The purpose of the destructor, "
"on the other hand, is a superset: it must release *all* resources it owns, "
"including references to objects that cannot participate in a reference cycle "
"(e.g., integers) as well as the object's own memory (by calling :c:member:"
"`~PyTypeObject.tp_free`)."
msgstr ""
"Syftet med att cleara ett objekt är att ta bort referenser till andra objekt "
"som kan delta i en referenscykel.  Destruktorns syfte är å andra sidan ett "
"överordnat: den måste frigöra *alla* resurser som den äger, inklusive "
"referenser till objekt som inte kan delta i en referenscykel (t.ex. heltal) "
"samt objektets eget minne (genom att anropa :c:member:`~PyTypeObject."
"tp_free`)."

msgid ""
"When :c:member:`!tp_clear` is called, other objects might still hold "
"references to the object being cleared.  Because of this, :c:member:`!"
"tp_clear` must not deallocate the object's own memory (:c:member:"
"`~PyTypeObject.tp_free`).  The destructor, on the other hand, is only called "
"when no (strong) references exist, and as such, must safely destroy the "
"object itself by deallocating it."
msgstr ""
"När :c:member:`!tp_clear` anropas kan andra objekt fortfarande ha referenser "
"till det objekt som rensas.  På grund av detta får :c:member:`!tp_clear` "
"inte deallokera objektets eget minne (:c:member:`~PyTypeObject.tp_free`).  "
"Destruktorn, å andra sidan, anropas endast när inga (starka) referenser "
"finns, och måste därför på ett säkert sätt förstöra själva objektet genom "
"att avallokera det."

msgid ""
":c:member:`!tp_clear` might never be automatically called.  An object's "
"destructor, on the other hand, will be automatically called some time after "
"the object becomes unreachable (i.e., either there are no references to the "
"object or the object is a member of a :term:`cyclic isolate`)."
msgstr ""
":c:member:`!tp_clear` kanske aldrig anropas automatiskt.  Ett objekts "
"destruktor kommer däremot att anropas automatiskt en tid efter det att "
"objektet blir oåtkomligt (dvs. antingen finns det inga referenser till "
"objektet eller så är objektet medlem i en :term:`cyclic isolate`)."

msgid ""
"No guarantees are made about when, if, or how often Python automatically "
"clears an object, except:"
msgstr ""
"Inga garantier görs om när, om eller hur ofta Python automatiskt rensar ett "
"objekt, förutom:"

msgid ""
"Python will not automatically clear an object if it is reachable, i.e., "
"there is a reference to it and it is not a member of a :term:`cyclic "
"isolate`."
msgstr ""
"Python rensar inte automatiskt ett objekt om det är nåbart, dvs. om det "
"finns en referens till det och det inte är en medlem av en :term:`cyklisk "
"isolat`."

msgid ""
"Python will not automatically clear an object if it has not been "
"automatically finalized (see :c:member:`~PyTypeObject.tp_finalize`).  (If "
"the finalizer resurrected the object, the object may or may not be "
"automatically finalized again before it is cleared.)"
msgstr ""
"Python kommer inte automatiskt att rensa ett objekt om det inte har blivit "
"automatiskt finaliserat (se :c:member:`~PyTypeObject.tp_finalize`).  (Om "
"finaliseraren återupplivade objektet kan det hända att objektet automatiskt "
"finaliseras igen innan det rensas)"

msgid ""
"If an object is a member of a :term:`cyclic isolate`, Python will not "
"automatically clear it if any member of the cyclic isolate has not yet been "
"automatically finalized (:c:member:`~PyTypeObject.tp_finalize`)."
msgstr ""
"Om ett objekt är medlem i ett :term:`cykliskt isolat`, kommer Python inte "
"automatiskt att rensa det om någon medlem i det cykliska isolatet ännu inte "
"har slutförts automatiskt (:c:member:`~PyTypeObject.tp_finalize`)."

msgid ""
"Python will not destroy an object until after any automatic calls to its :c:"
"member:`!tp_clear` function have returned.  This ensures that the act of "
"breaking a reference cycle does not invalidate the ``self`` pointer while :c:"
"member:`!tp_clear` is still executing."
msgstr ""
"Python kommer inte att förstöra ett objekt förrän efter att alla automatiska "
"anrop till dess :c:member:`!tp_clear`-funktion har returnerats.  Detta "
"säkerställer att handlingen att bryta en referenscykel inte ogiltigförklarar "
"``self``-pekaren medan :c:member:`!tp_clear` fortfarande körs."

msgid ""
"Python will not automatically call :c:member:`!tp_clear` multiple times "
"concurrently."
msgstr ""
"Python kommer inte automatiskt att anropa :c:member:`!tp_clear` flera gånger "
"samtidigt."

msgid ""
"CPython currently only automatically clears objects as needed to break "
"reference cycles in a :term:`cyclic isolate`, but future versions might "
"clear objects regularly before their destruction."
msgstr ""
"CPython rensar för närvarande bara automatiskt objekt när det behövs för att "
"bryta referenscykler i en :term:`cyklisk isolat`, men framtida versioner kan "
"rensa objekt regelbundet innan de förstörs."

msgid ""
"Taken together, all :c:member:`~PyTypeObject.tp_clear` functions in the "
"system must combine to break all reference cycles.  This is subtle, and if "
"in any doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For "
"example, the tuple type does not implement a :c:member:`~PyTypeObject."
"tp_clear` function, because it's possible to prove that no reference cycle "
"can be composed entirely of tuples.  Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types are responsible for breaking any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Sammantaget måste alla :c:member:`~PyTypeObject.tp_clear`-funktioner i "
"systemet kombineras för att bryta alla referenscykler.  Detta är subtilt, "
"och om du är osäker kan du använda en :c:member:`~PyTypeObject.tp_clear`-"
"funktion.  Till exempel implementerar inte tupeltypen en :c:member:"
"`~PyTypeObject.tp_clear`-funktion, eftersom det är möjligt att bevisa att "
"ingen referenscykel kan bestå helt av tuplar.  Därför är :c:member:"
"`~PyTypeObject.tp_clear`-funktioner av andra typer ansvariga för att bryta "
"alla cykler som innehåller en tupel.  Detta är inte omedelbart uppenbart, "
"och det finns sällan en bra anledning att undvika att implementera :c:member:"
"`~PyTypeObject.tp_clear`."

msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Implementeringar av :c:member:`~PyTypeObject.tp_clear` bör ta bort "
"instansens referenser till de av dess medlemmar som kan vara Python-objekt, "
"och sätta dess pekare till dessa medlemmar till ``NULL``, som i följande "
"exempel::"

msgid ""
"static int\n"
"local_clear(PyObject *op)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""
"statisk int\n"
"local_clear(PyObject *op)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_CLEAR(själv>nyckel);\n"
"    Py_CLEAR(själv>args);\n"
"    Py_CLEAR(själv>kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"

msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released (via :"
"c:func:`Py_DECREF`) until after the pointer to the contained object is set "
"to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity "
"that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"Makrot :c:func:`Py_CLEAR` bör användas eftersom det är känsligt att rensa "
"referenser: referensen till det ingående objektet får inte släppas (via :c:"
"func:`Py_DECREF`) förrän efter att pekaren till det ingående objektet har "
"satts till ``NULL``.  Detta beror på att frigörandet av referensen kan leda "
"till att det inneslutna objektet blir skräp, vilket utlöser en kedja av "
"återvinningsaktiviteter som kan inkludera anrop av godtycklig Python-kod (på "
"grund av finalizers eller weakref callbacks som är associerade med det "
"inneslutna objektet). Om det är möjligt för sådan kod att referera till "
"*self* igen, är det viktigt att pekaren till det inneslutna objektet är "
"``NULL`` vid den tidpunkten, så att *self* vet att det inneslutna objektet "
"inte längre kan användas.  Makrot :c:func:`Py_CLEAR` utför dessa operationer "
"i en säker ordning."

msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the traverse function must call :c:func:"
"`PyObject_ClearManagedDict` like this::"
msgstr ""
"Om bitarna :c:macro:`Py_TPFLAGS_MANAGED_DICT` är inställda i fältet :c:"
"member:`~PyTypeObject.tp_flags`, måste traversefunktionen anropa :c:func:"
"`PyObject_ClearManagedDict` så här::"

msgid "PyObject_ClearManagedDict((PyObject*)self);"
msgstr "PyObject_ClearManagedDict((PyObject*)self);"

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :"
"c:member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_traverse` och flaggbiten :c:macro:`Py_TPFLAGS_HAVE_GC`: flaggbiten, :c:"
"member:`~PyTypeObject.tp_traverse` och :c:member:`~PyTypeObject.tp_clear` "
"ärvs alla från bastypen om de alla är noll i subtypen."

msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"En valfri pekare till den rika jämförelsefunktionen, vars signatur är::"

msgid "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"
msgstr "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"

msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Den första parametern är garanterat en instans av den typ som definieras av :"
"c:type:`PyTypeObject`."

msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"Funktionen ska returnera resultatet av jämförelsen (vanligtvis ``Py_True`` "
"eller ``Py_False``).  Om jämförelsen är odefinierad måste den returnera "
"``Py_NotImplemented``, om ett annat fel inträffade måste den returnera "
"``NULL`` och sätta ett undantagsvillkor."

msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Följande konstanter är definierade för att användas som det tredje "
"argumentet för :c:member:`~PyTypeObject.tp_richcompare` och för :c:func:"
"`PyObject_RichCompare`:"

msgid "Constant"
msgstr "Konstant"

msgid "Comparison"
msgstr "Jämförelse"

msgid "``<``"
msgstr "``<``"

msgid "``<=``"
msgstr "``<=``"

msgid "``==``"
msgstr "``==``"

msgid "``!=``"
msgstr "``!=``"

msgid "``>``"
msgstr "``>``"

msgid "``>=``"
msgstr "``>=``"

msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"Följande makro är definierat för att underlätta skrivandet av rika "
"jämförelsefunktioner:"

msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Returnerar ``Py_True`` eller ``Py_False`` från funktionen, beroende på "
"resultatet av en jämförelse. VAL_A och VAL_B måste kunna ordnas av C:s "
"jämförelseoperatorer (de kan t.ex. vara C:s ints eller floats). Det tredje "
"argumentet specificerar den begärda operationen, som för :c:func:"
"`PyObject_RichCompare`."

msgid "The returned value is a new :term:`strong reference`."
msgstr "Det returnerade värdet är en ny :term:`strong reference`."

msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "Vid fel, anger ett undantag och returnerar ``NULL`` från funktionen."

msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Detta fält ärvs av subtyper tillsammans med :c:member:`~PyTypeObject."
"tp_hash`: en subtyp ärver :c:member:`~PyTypeObject.tp_richcompare` och :c:"
"member:`~PyTypeObject.tp_hash` när subtypens :c:member:`~PyTypeObject."
"tp_richcompare` och :c:member:`~PyTypeObject.tp_hash` båda är ``NULL``."

msgid ""
":c:data:`PyBaseObject_Type` provides a :c:member:`~PyTypeObject."
"tp_richcompare` implementation, which may be inherited.  However, if only :c:"
"member:`~PyTypeObject.tp_hash` is defined, not even the inherited function "
"is used and instances of the type will not be able to participate in any "
"comparisons."
msgstr ""
":c:data:`PyBaseObject_Type` tillhandahåller en :c:member:`~PyTypeObject."
"tp_richcompare`-implementation, som kan ärvas.  Men om endast :c:member:"
"`~PyTypeObject.tp_hash` definieras, används inte ens den ärvda funktionen "
"och instanser av typen kommer inte att kunna delta i några jämförelser."

msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` "
"should be used instead, if at all possible."
msgstr ""
"Även om detta fält fortfarande stöds bör :c:macro:"
"`Py_TPFLAGS_MANAGED_WEAKREF` användas i stället, om det är möjligt."

msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type :c:expr:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Om instanserna av denna typ är svagt refererbara, är detta fält större än "
"noll och innehåller offset i instansstrukturen för huvudet på listan över "
"svaga referenser (ignorerar GC-headern, om sådan finns); denna offset "
"används av funktionerna :c:func:`PyObject_ClearWeakRefs` och "
"``PyWeakref_*``.  Instansstrukturen måste innehålla ett fält av typen :c:"
"expr:`PyObject*` som initialiseras till ``NULL``."

msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"Förväxla inte detta fält med :c:member:`~PyTypeObject.tp_weaklist`; det är "
"listhuvudet för svaga referenser till typobjektet självt."

msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit "
"and :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"Det är ett fel att ange både :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit och :"
"c:member:`~PyTypeObject.tp_weaklistoffset`."

msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Detta fält ärvs av subtyper, men se de regler som anges nedan. En subtyp kan "
"åsidosätta denna offset; detta innebär att subtypen använder ett annat "
"listhuvud för svaga referenser än bastypen.  Eftersom listhuvudet alltid "
"hittas via :c:member:`~PyTypeObject.tp_weaklistoffset`, bör detta inte vara "
"något problem."

msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject."
"tp_weaklistoffset` will be set to a negative value, to indicate that it is "
"unsafe to use this field."
msgstr ""
"Om bitarna :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` är inställda i fältet :c:"
"member:`~PyTypeObject.tp_flags`, kommer :c:member:`~PyTypeObject."
"tp_weaklistoffset` att sättas till ett negativt värde, för att indikera att "
"det är osäkert att använda detta fält."

msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"En valfri pekare till en funktion som returnerar en :term:`iterator` för "
"objektet.  Dess närvaro signalerar normalt att instanser av denna typ är :"
"term:`iterabla` (även om sekvenser kan vara iterabla utan denna funktion)."

msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Denna funktion har samma signatur som :c:func:`PyObject_GetIter`::"

msgid "PyObject *tp_iter(PyObject *self);"
msgstr "PyObject *tp_iter(PyObject *self);"

msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr ""
"En valfri pekare till en funktion som returnerar nästa objekt i en :term:"
"`iterator`. Signaturen är::"

msgid "PyObject *tp_iternext(PyObject *self);"
msgstr "PyObject *tp_iternext(PyObject *self);"

msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"När iteratorn är uttömd måste den returnera ``NULL``; ett :exc:"
"`StopIteration` undantag kan eller kan inte ställas in.  När ett annat fel "
"inträffar måste den också returnera ``NULL``.  Dess närvaro signalerar att "
"förekomsterna av denna typ är iteratorer."

msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Iteratortyper bör också definiera funktionen :c:member:`~PyTypeObject."
"tp_iter`, och den funktionen bör returnera själva iteratorinstansen (inte en "
"ny iteratorinstans)."

msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Denna funktion har samma signatur som :c:func:`PyIter_Next`."

msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"En valfri pekare till en statisk ``NULL``-terminerad array av :c:type:"
"`PyMethodDef`-strukturer, som deklarerar vanliga metoder av denna typ."

msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"För varje post i matrisen läggs en post till i typens dictionary (se :c:"
"member:`~PyTypeObject.tp_dict` nedan) som innehåller en metoddeskriptor."

msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (metoder ärvs genom en annan mekanism)."

msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"En valfri pekare till en statisk ``NULL``-terminerad array av :c:type:"
"`PyMemberDef`-strukturer, som deklarerar vanliga datamedlemmar (fält eller "
"slots) för instanser av denna typ."

msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"För varje post i matrisen läggs en post till i typens dictionary (se :c:"
"member:`~PyTypeObject.tp_dict` nedan) som innehåller en medlemsdeskriptor."

msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (medlemmar ärvs genom en annan mekanism)."

msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"En valfri pekare till en statisk ``NULL``-terminerad array av :c:type:"
"`PyGetSetDef`-strukturer, som deklarerar beräknade attribut för instanser av "
"denna typ."

msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"För varje post i matrisen läggs en post till i typens dictionary (se :c:"
"member:`~PyTypeObject.tp_dict` nedan) som innehåller en getset-descriptor."

msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (beräknade attribut ärvs genom en annan "
"mekanism)."

msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"En valfri pekare till en bastyp från vilken typegenskaper ärvs.  På denna "
"nivå stöds endast enkel nedärvning; multipel nedärvning kräver att ett "
"typobjekt skapas dynamiskt genom att anropa metatypen."

msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"Slotinitialisering är föremål för reglerna för initialisering av globaler. "
"C99 kräver att initialisatorerna är \"adresskonstanter\".  "
"Funktionsbeteckningar som :c:func:`PyType_GenericNew`, med implicit "
"konvertering till en pekare, är giltiga C99-adresskonstanter."

msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"data:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"Den unära operatorn '&' som används på en icke-statisk variabel som :c:data:"
"`PyBaseObject_Type` är dock inte nödvändig för att producera en "
"adresskonstant.  Kompilatorer kan stödja detta (gcc gör det), MSVC gör det "
"inte. Båda kompilatorerna är strikt standardkonforma i detta speciella "
"beteende."

msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"Följaktligen bör :c:member:`~PyTypeObject.tp_base` anges i tilläggsmodulens "
"init-funktion."

msgid "This field is not inherited by subtypes (obviously)."
msgstr "Detta fält ärvs inte av subtyper (naturligtvis)."

msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"Detta fält är som standard ``&PyBaseObject_Type`` (som för Python-"
"programmerare är känt som typen :class:`object`)."

msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "Typens ordbok lagras här av :c:func:`PyType_Ready`."

msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`~object."
"__add__`).  Once initialization for the type has finished, this field should "
"be treated as read-only."
msgstr ""
"Detta fält bör normalt initialiseras till ``NULL`` innan PyType_Ready "
"anropas; det kan också initialiseras till en dictionary som innehåller "
"initiala attribut för typen.  När :c:func:`PyType_Ready` har initialiserat "
"typen kan extra attribut för typen läggas till i denna ordbok endast om de "
"inte motsvarar överbelastade operationer (som :meth:`~object.__add__`).  När "
"initialiseringen av typen har avslutats bör detta fält behandlas som "
"skrivskyddat."

msgid ""
"Some types may not store their dictionary in this slot. Use :c:func:"
"`PyType_GetDict` to retrieve the dictionary for an arbitrary type."
msgstr ""
"Vissa typer kanske inte lagrar sin ordbok i denna slot. Använd :c:func:"
"`PyType_GetDict` för att hämta ordlistan för en godtycklig typ."

msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. Use :c:"
"func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""
"Intern detalj: För statiska inbyggda typer är detta alltid ``NULL``. "
"Istället lagras dict för sådana typer på ``PyInterpreterState``. Använd :c:"
"func:`PyType_GetDict` för att få fram dict för en godtycklig typ."

msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Detta fält ärvs inte av subtyper (även om de attribut som definieras här "
"ärvs genom en annan mekanism)."

msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Om detta fält är ``NULL`` kommer :c:func:`PyType_Ready` att tilldela det en "
"ny ordbok."

msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"Det är inte säkert att använda :c:func:`PyDict_SetItem` på eller på annat "
"sätt modifiera :c:member:`~PyTypeObject.tp_dict` med dictionary C-API."

msgid "An optional pointer to a \"descriptor get\" function."
msgstr "En valfri pekare till en \"descriptor get\"-funktion."

msgid "The function signature is::"
msgstr "Funktionens signatur är::"

msgid "PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"
msgstr ""
"PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"

msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"En valfri pekare till en funktion för att ställa in och ta bort en "
"descriptors värde."

msgid "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"
msgstr "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"

msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "Argumentet *värde* sätts till ``NULL`` för att ta bort värdet."

msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr ""
"Även om detta fält fortfarande stöds, bör :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"användas istället, om det är möjligt."

msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Om instanserna av denna typ har en ordbok som innehåller instansvariabler, "
"är detta fält icke-noll och innehåller offset i instanserna av typen av "
"instansvariabelordboken; denna offset används av :c:func:"
"`PyObject_GenericGetAttr`."

msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"Förväxla inte detta fält med :c:member:`~PyTypeObject.tp_dict`; det är "
"ordlistan för attribut för själva typobjektet."

msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr "Värdet anger ordbokens förskjutning från början av instansstrukturen."

msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call :c:func:"
"`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict` may "
"need to allocate memory for the dictionary, so it is may be more efficient "
"to call :c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""
":c:member:`~PyTypeObject.tp_dictoffset` bör betraktas som skrivskyddad. För "
"att få pekaren till ordlistan anropa :c:func:`PyObject_GenericGetDict`. "
"Anrop av :c:func:`PyObject_GenericGetDict` kan behöva allokera minne för "
"ordlistan, så det kan vara mer effektivt att anropa :c:func:"
"`PyObject_GetAttr` när man vill komma åt ett attribut på objektet."

msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit and :c:"
"member:`~PyTypeObject.tp_dictoffset`."
msgstr ""
"Det är ett fel att ange både :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit och :c:"
"member:`~PyTypeObject.tp_dictoffset`."

msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the dictionary "
"at the previous offset. To properly support inheritance, use :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""
"Detta fält ärvs av subtyper. En subtyp bör inte åsidosätta denna offset; det "
"kan vara osäkert om C-kod försöker komma åt ordboken vid den tidigare "
"offset. För att korrekt stödja arv, använd :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`."

msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"Denna slot har ingen standard.  För :ref:``static types <static-types>``, om "
"fältet är ``NULL`` så skapas ingen :attr:`~object.__dict__` för instanser."

msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject.tp_dictoffset` "
"will be set to ``-1``, to indicate that it is unsafe to use this field."
msgstr ""
"Om bitarna :c:macro:`Py_TPFLAGS_MANAGED_DICT` är inställda i fältet :c:"
"member:`~PyTypeObject.tp_flags`, så kommer :c:member:`~PyTypeObject."
"tp_dictoffset` att sättas till ``-1``, för att indikera att det är osäkert "
"att använda detta fält."

msgid "An optional pointer to an instance initialization function."
msgstr "En valfri pekare till en instansinitialiseringsfunktion."

msgid ""
"This function corresponds to the :meth:`~object.__init__` method of "
"classes.  Like :meth:`!__init__`, it is possible to create an instance "
"without calling :meth:`!__init__`, and it is possible to reinitialize an "
"instance by calling its :meth:`!__init__` method again."
msgstr ""
"Denna funktion motsvarar metoden :meth:`~object.__init__` för klasser.  "
"Precis som :meth:`!__init__` är det möjligt att skapa en instans utan att "
"anropa :meth:`!__init__`, och det är möjligt att återinitialisera en instans "
"genom att anropa dess :meth:`!__init__`-metod igen."

msgid "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"
msgstr "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"

msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`~object.__init__`."
msgstr ""
"Argumentet self är den instans som ska initialiseras; argumenten *args* och "
"*kwds* representerar positions- och nyckelordsargument för anropet till :"
"meth:`~object.__init__`."

msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"Funktionen :c:member:`~PyTypeObject.tp_init`, om den inte är ``NULL``, "
"anropas när en instans skapas normalt genom att anropa dess typ, efter att "
"typens funktion :c:member:`~PyTypeObject.tp_new` har returnerat en instans "
"av typen.  Om funktionen :c:member:`~PyTypeObject.tp_new` returnerar en "
"instans av någon annan typ som inte är en subtyp av den ursprungliga typen "
"anropas ingen funktion :c:member:`~PyTypeObject.tp_init`; om :c:member:"
"`~PyTypeObject.tp_new` returnerar en instans av en subtyp av den "
"ursprungliga typen anropas subtypens funktion :c:member:`~PyTypeObject."
"tp_init`."

msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr "Returnerar ``0`` vid framgång, ``-1`` och anger ett undantag vid fel."

msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr "För :ref:`static types <static-types>` har detta fält ingen standard."

msgid "An optional pointer to an instance allocation function."
msgstr "En valfri pekare till en funktion för instansallokering."

msgid "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"
msgstr "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"

msgid ""
"Static subtypes inherit this slot, which will be :c:func:"
"`PyType_GenericAlloc` if inherited from :class:`object`."
msgstr ""
"Statiska subtyper ärver denna slot, som kommer att vara :c:func:"
"`PyType_GenericAlloc` om den ärvs från :class:`object`."

msgid ":ref:`Heap subtypes <heap-types>` do not inherit this slot."
msgstr ":ref:`Heap subtyper <heap-types>` ärver inte denna slot."

msgid ""
"For heap subtypes, this field is always set to :c:func:`PyType_GenericAlloc`."
msgstr ""
"För subtyper av heap är detta fält alltid inställt på :c:func:"
"`PyType_GenericAlloc`."

msgid "For static subtypes, this slot is inherited (see above)."
msgstr "För statiska subtyper ärvs denna plats (se ovan)."

msgid "An optional pointer to an instance creation function."
msgstr "En valfri pekare till en funktion för att skapa en instans."

msgid ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"
msgstr ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"

msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"Argumentet *subtype* är typen av det objekt som skapas; argumenten *args* "
"och *kwds* representerar positions- och nyckelordsargument i anropet till "
"typen.  Observera att *subtype* inte behöver vara lika med den typ vars :c:"
"member:`~PyTypeObject.tp_new`-funktion anropas; det kan vara en subtyp av "
"den typen (men inte en orelaterad typ)."

msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"Funktionen :c:member:`~PyTypeObject.tp_new` bör anropa ``subtype-"
">tp_alloc(subtype, nitems)`` för att allokera utrymme för objektet, och "
"sedan bara göra så mycket ytterligare initialisering som är absolut "
"nödvändigt.  Initialisering som säkert kan ignoreras eller upprepas bör "
"placeras i handlaren :c:member:`~PyTypeObject.tp_init`.  En bra tumregel är "
"att för oföränderliga typer bör all initialisering ske i :c:member:"
"`~PyTypeObject.tp_new`, medan för föränderliga typer bör de flesta "
"initialiseringar skjutas upp till :c:member:`~PyTypeObject.tp_init`."

msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""
"Ange flaggan :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` för att inte "
"tillåta att instanser av typen skapas i Python."

msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"Detta fält ärvs av subtyper, förutom att det inte ärvs av :ref:`static types "
"<static-types>` vars :c:member:`~PyTypeObject.tp_base` är ``NULL`` eller "
"``&amp;PyBaseObject_Type``."

msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"För :ref:`static types <static-types>` har detta fält ingen standard. Detta "
"innebär att om slot definieras som ``NULL`` kan typen inte anropas för att "
"skapa nya instanser; förmodligen finns det något annat sätt att skapa "
"instanser, som en fabriksfunktion."

msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"En valfri pekare till en funktion för avallokering av instanser.  Dess "
"signatur är::"

msgid "void tp_free(void *self);"
msgstr "void tp_free(void *self);"

msgid ""
"This function must free the memory allocated by :c:member:`~PyTypeObject."
"tp_alloc`."
msgstr ""
"Denna funktion måste frigöra det minne som allokerats av :c:member:"
"`~PyTypeObject.tp_alloc`."

msgid ""
"Static subtypes inherit this slot, which will be :c:func:`PyObject_Free` if "
"inherited from :class:`object`.  Exception: If the type supports garbage "
"collection (i.e., the :c:macro:`Py_TPFLAGS_HAVE_GC` flag is set in :c:member:"
"`~PyTypeObject.tp_flags`) and it would inherit :c:func:`PyObject_Free`, then "
"this slot is not inherited but instead defaults to :c:func:`PyObject_GC_Del`."
msgstr ""
"Statiska subtyper ärver denna slot, som kommer att vara :c:func:"
"`PyObject_Free` om den ärvs från :class:`object`.  Undantag för detta: Om "
"typen stöder garbage collection (dvs. flaggan :c:macro:`Py_TPFLAGS_HAVE_GC` "
"är inställd i :c:member:`~PyTypeObject.tp_flags`) och den skulle ärva :c:"
"func:`PyObject_Free`, ärvs inte denna slot utan är istället standardvärdet "
"för :c:func:`PyObject_GC_Del`."

msgid ""
"For :ref:`heap subtypes <heap-types>`, this slot defaults to a deallocator "
"suitable to match :c:func:`PyType_GenericAlloc` and the value of the :c:"
"macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"För :ref:``heap subtypes <heap-types>``, är standardvärdet för denna plats "
"en deallokator som är lämplig för att matcha :c:func:`PyType_GenericAlloc` "
"och värdet på flaggan :c:macro:`Py_TPFLAGS_HAVE_GC`."

msgid "An optional pointer to a function called by the garbage collector."
msgstr "En valfri pekare till en funktion som anropas av skräpsamlaren."

msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"Garbage collector behöver veta om ett visst objekt är insamlingsbart eller "
"inte.  Normalt räcker det att titta på objekttypens fält :c:member:"
"`~PyTypeObject.tp_flags` och kontrollera flaggbiten :c:macro:"
"`Py_TPFLAGS_HAVE_GC`.  Men vissa typer har en blandning av statiskt och "
"dynamiskt allokerade instanser, och de statiskt allokerade instanserna är "
"inte insamlingsbara.  Sådana typer bör definiera denna funktion; den bör "
"returnera ``1`` för en samlingsbar instans och ``0`` för en icke-samlingsbar "
"instans. Signaturen är::"

msgid "int tp_is_gc(PyObject *self);"
msgstr "int tp_is_gc(PyObject *self);"

msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(Det enda exemplet på detta är typerna själva.  Metatypen, :c:data:"
"`PyType_Type`, definierar den här funktionen för att skilja mellan statiskt "
"och :ref:`dynamiskt allokerade typer <heap-types>`.)"

msgid ""
"This slot has no default.  If this field is ``NULL``, :c:macro:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Denna slot har ingen standard.  Om detta fält är ``NULL``, används :c:macro:"
"`Py_TPFLAGS_HAVE_GC` som funktionell motsvarighet."

msgid "Tuple of base types."
msgstr "Tupel av bastyper."

msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"Detta fält bör sättas till ``NULL`` och behandlas som skrivskyddat. Python "
"kommer att fylla i det när typen är :c:func:`initialiserad <PyType_Ready>`."

msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of :c:func:"
"`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"För dynamiskt skapade klasser kan ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` användas istället för *bases*-argumentet i :c:func:"
"`PyType_FromSpecWithBases`. Argumentformen är att föredra."

msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""
"Multipel nedärvning fungerar inte bra för statiskt definierade typer. Om du "
"ställer in ``tp_bases`` till en tupel kommer Python inte att ge upphov till "
"ett fel, men vissa slots kommer endast att ärvas från den första basen."

msgid "This field is not inherited."
msgstr "Detta fält är inte ärftligt."

msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Tupel som innehåller den utökade uppsättningen bastyper, som börjar med "
"typen själv och slutar med :class:`object`, i Method Resolution Order."

msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr "Detta fält är inte ärftligt, utan beräknas av :c:func:`PyType_Ready`."

msgid "Unused.  Internal use only."
msgstr "Oanvänd.  Endast för internt bruk."

msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid pointer."
msgstr ""
"En samling av underklasser.  Endast för internt bruk.  Kan vara en ogiltig "
"pekare."

msgid ""
"To get a list of subclasses, call the Python method :py:meth:`~type."
"__subclasses__`."
msgstr ""
"För att få en lista över underklasser anropar du Python-metoden :py:meth:"
"`~type.__subclasses__`."

msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The "
"type was changed to :c:expr:`void*` to indicate this."
msgstr ""
"För vissa typer innehåller detta fält inte ett giltigt :c:expr:`PyObject*`. "
"Typen ändrades till :c:expr:`void*` för att ange detta."

msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Svag referenslistans huvud, för svaga referenser till detta typobjekt.  Ärvs "
"inte.  Endast för internt bruk."

msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, even "
"if weakrefs are added.  Instead, the weakrefs for each are stored on "
"``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""
"Intern detalj: För de statiska inbyggda typerna är detta alltid ``NULL``, "
"även om weakrefs läggs till.  Istället lagras weakrefs för var och en på "
"``PyInterpreterState``.  Använd det publika C-API:et eller det interna "
"makrot ``_PyObject_GET_WEAKREFS_LISTPTR()`` för att undvika skillnaden."

msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Detta fält är föråldrat.  Använd :c:member:`~PyTypeObject.tp_finalize` "
"istället."

msgid "Used to index into the method cache.  Internal use only."
msgstr "Används för att indexera till metodcachen.  Endast för internt bruk."

msgid ""
"An optional pointer to an instance finalization function.  This is the C "
"implementation of the :meth:`~object.__del__` special method.  Its signature "
"is::"
msgstr ""
"En valfri pekare till en funktion för att avsluta en instans.  Detta är C-"
"implementeringen av specialmetoden :meth:`~object.__del__`.  Dess signatur "
"är::"

msgid "void tp_finalize(PyObject *self);"
msgstr "void tp_finalize(PyObject *self);"

msgid ""
"The primary purpose of finalization is to perform any non-trivial cleanup "
"that must be performed before the object is destroyed, while the object and "
"any other objects it directly or indirectly references are still in a "
"consistent state.  The finalizer is allowed to execute arbitrary Python code."
msgstr ""
"Det primära syftet med finalization är att utföra alla icke-triviala "
"rensningar som måste utföras innan objektet förstörs, medan objektet och "
"alla andra objekt som det direkt eller indirekt refererar till fortfarande "
"är i ett konsekvent tillstånd.  Finalizern tillåts exekvera godtycklig "
"Python-kod."

msgid ""
"Before Python automatically finalizes an object, some of the object's direct "
"or indirect referents might have themselves been automatically finalized. "
"However, none of the referents will have been automatically cleared (:c:"
"member:`~PyTypeObject.tp_clear`) yet."
msgstr ""
"Innan Python automatiskt finaliserar ett objekt kan några av objektets "
"direkta eller indirekta referenter själva ha finaliserats automatiskt. Ingen "
"av referenterna kommer dock att ha blivit automatiskt rensade (:c:member:"
"`~PyTypeObject.tp_clear`) ännu."

msgid ""
"Other non-finalized objects might still be using a finalized object, so the "
"finalizer must leave the object in a sane state (e.g., invariants are still "
"met)."
msgstr ""
"Andra icke-finaliserade objekt kan fortfarande använda ett finaliserat "
"objekt, så finaliseraren måste lämna objektet i ett sunt tillstånd (t.ex. "
"invarianter är fortfarande uppfyllda)."

msgid ""
"After Python automatically finalizes an object, Python might start "
"automatically clearing (:c:member:`~PyTypeObject.tp_clear`) the object and "
"its referents (direct and indirect).  Cleared objects are not guaranteed to "
"be in a consistent state; a finalized object must be able to tolerate "
"cleared referents."
msgstr ""
"Efter att Python automatiskt har slutfört ett objekt kan Python automatiskt "
"börja rensa (:c:member:`~PyTypeObject.tp_clear`) objektet och dess "
"referenter (direkta och indirekta).  Rensade objekt garanteras inte att vara "
"i ett konsekvent tillstånd; ett färdigställt objekt måste kunna tolerera "
"rensade referenter."

msgid ""
"An object is not guaranteed to be automatically finalized before its "
"destructor (:c:member:`~PyTypeObject.tp_dealloc`) is called.  It is "
"recommended to call :c:func:`PyObject_CallFinalizerFromDealloc` at the "
"beginning of :c:member:`!tp_dealloc` to guarantee that the object is always "
"finalized before destruction."
msgstr ""
"Det är inte garanterat att ett objekt automatiskt finaliseras innan dess "
"destruktor (:c:member:`~PyTypeObject.tp_dealloc`) anropas.  Det "
"rekommenderas att anropa :c:func:`PyObject_CallFinalizerFromDealloc` i "
"början av :c:member:`!tp_dealloc` för att garantera att objektet alltid "
"slutförs innan det förstörs."

msgid ""
"The :c:member:`~PyTypeObject.tp_finalize` function can be called from any "
"thread, although the :term:`GIL` will be held."
msgstr ""
"Funktionen :c:member:`~PyTypeObject.tp_finalize` kan anropas från valfri "
"tråd, även om :term:`GIL` kommer att hållas kvar."

msgid ""
"The :c:member:`!tp_finalize` function can be called during shutdown, after "
"some global variables have been deleted.  See the documentation of the :meth:"
"`~object.__del__` method for details."
msgstr ""
"Funktionen :c:member:`!tp_finalize` kan anropas under nedstängning, efter "
"att vissa globala variabler har tagits bort.  Se dokumentationen för "
"metoden :meth:`~object.__del__` för detaljer."

msgid ""
"When Python finalizes an object, it behaves like the following algorithm:"
msgstr "När Python finaliserar ett objekt beter det sig som följande algoritm:"

msgid ""
"Python might mark the object as *finalized*.  Currently, Python always marks "
"objects whose type supports garbage collection (i.e., the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag is set in :c:member:`~PyTypeObject.tp_flags`) and "
"never marks other types of objects; this might change in a future version."
msgstr ""
"Python kan markera objektet som *finalized*.  För närvarande markerar Python "
"alltid objekt vars typ stöder garbage collection (dvs. flaggan :c:macro:"
"`Py_TPFLAGS_HAVE_GC` är inställd i :c:member:`~PyTypeObject.tp_flags`) och "
"markerar aldrig andra typer av objekt; detta kan ändras i en framtida "
"version."

msgid ""
"If the object is not marked as *finalized* and its :c:member:`!tp_finalize` "
"finalizer function is non-``NULL``, the finalizer function is called."
msgstr ""
"Om objektet inte är markerat som *finalized* och dess :c:member:`!"
"tp_finalize` finalizer-funktion är icke-``NULL``, anropas finalizer-"
"funktionen."

msgid ""
"If the finalizer function was called and the finalizer made the object "
"reachable (i.e., there is a reference to the object and it is not a member "
"of a :term:`cyclic isolate`), then the finalizer is said to have "
"*resurrected* the object.  It is unspecified whether the finalizer can also "
"resurrect the object by adding a new reference to the object that does not "
"make it reachable, i.e., the object is (still) a member of a cyclic isolate."
msgstr ""
"Om finalizer-funktionen anropades och finalizer gjorde objektet nåbart (dvs. "
"det finns en referens till objektet och det är inte medlem i ett :term:"
"`cykliskt isolat`), sägs finalizer ha *återuppväckt* objektet.  Det är "
"ospecificerat om finalizern också kan återuppliva objektet genom att lägga "
"till en ny referens till objektet som inte gör det nåbart, dvs. objektet är "
"(fortfarande) medlem i ett cykliskt isolat."

msgid ""
"If the finalizer resurrected the object, the object's pending destruction is "
"canceled and the object's *finalized* mark might be removed if present.  "
"Currently, Python never removes the *finalized* mark; this might change in a "
"future version."
msgstr ""
"Om finalizer återuppväckte objektet avbryts objektets väntande förstörelse "
"och objektets *finalized*-märke kan tas bort om det finns.  För närvarande "
"tar Python aldrig bort *finalized*-markeringen; detta kan ändras i en "
"framtida version."

msgid ""
"*Automatic finalization* refers to any finalization performed by Python "
"except via calls to :c:func:`PyObject_CallFinalizer` or :c:func:"
"`PyObject_CallFinalizerFromDealloc`.  No guarantees are made about when, if, "
"or how often an object is automatically finalized, except:"
msgstr ""
"*Automatisk finalisering* avser all finalisering som utförs av Python utom "
"via anrop till :c:func:`PyObject_CallFinalizer` eller :c:func:"
"`PyObject_CallFinalizerFromDealloc`.  Inga garantier ges för när, om eller "
"hur ofta ett objekt automatiskt slutförs, förutom:"

msgid ""
"Python will not automatically finalize an object if it is reachable, i.e., "
"there is a reference to it and it is not a member of a :term:`cyclic "
"isolate`."
msgstr ""
"Python kommer inte automatiskt att avsluta ett objekt om det är nåbart, dvs. "
"det finns en referens till det och det är inte en medlem av en :term:"
"`cyklisk isolat`."

msgid ""
"Python will not automatically finalize an object if finalizing it would not "
"mark the object as *finalized*.  Currently, this applies to objects whose "
"type does not support garbage collection, i.e., the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag is not set.  Such objects can still be manually "
"finalized by calling :c:func:`PyObject_CallFinalizer` or :c:func:"
"`PyObject_CallFinalizerFromDealloc`."
msgstr ""
"Python kommer inte automatiskt att slutföra ett objekt om det inte skulle "
"markera objektet som *slutfört*.  För närvarande gäller detta för objekt "
"vars typ inte stöder garbage collection, dvs. flaggan :c:macro:"
"`Py_TPFLAGS_HAVE_GC` är inte inställd.  Sådana objekt kan fortfarande "
"slutföras manuellt genom att anropa :c:func:`PyObject_CallFinalizer` eller :"
"c:func:`PyObject_CallFinalizerFromDealloc`."

msgid ""
"Python will not automatically finalize any two members of a :term:`cyclic "
"isolate` concurrently."
msgstr ""
"Python kommer inte automatiskt att slutföra två medlemmar av en :term:"
"`cyklisk isolat` samtidigt."

msgid ""
"Python will not automatically finalize an object after it has automatically "
"cleared (:c:member:`~PyTypeObject.tp_clear`) the object."
msgstr ""
"Python kommer inte automatiskt att slutföra ett objekt efter att det "
"automatiskt har rensat (:c:member:`~PyTypeObject.tp_clear`) objektet."

msgid ""
"If an object is a member of a :term:`cyclic isolate`, Python will not "
"automatically finalize it after automatically clearing (see :c:member:"
"`~PyTypeObject.tp_clear`) any other member."
msgstr ""
"Om ett objekt är medlem i ett :term:`cykliskt isolat`, kommer Python inte "
"automatiskt att slutföra det efter att automatiskt ha rensat (se :c:member:"
"`~PyTypeObject.tp_clear`) någon annan medlem."

msgid ""
"Python will automatically finalize every member of a :term:`cyclic isolate` "
"before it automatically clears (see :c:member:`~PyTypeObject.tp_clear`) any "
"of them."
msgstr ""
"Python kommer automatiskt att slutföra varje medlem i en :term:`cyklisk "
"isolat` innan den automatiskt rensar (se :c:member:`~PyTypeObject.tp_clear`) "
"någon av dem."

msgid ""
"If Python is going to automatically clear an object (:c:member:"
"`~PyTypeObject.tp_clear`), it will automatically finalize the object first."
msgstr ""
"Om Python automatiskt ska rensa ett objekt (:c:member:`~PyTypeObject."
"tp_clear`), kommer det automatiskt att slutföra objektet först."

msgid ""
"Python currently only automatically finalizes objects that are members of a :"
"term:`cyclic isolate`, but future versions might finalize objects regularly "
"before their destruction."
msgstr ""
"Python slutför för närvarande endast automatiskt objekt som är medlemmar i "
"en :term:`cykliskt isolat`, men framtida versioner kan komma att slutföra "
"objekt regelbundet innan de förstörs."

msgid ""
"To manually finalize an object, do not call this function directly; call :c:"
"func:`PyObject_CallFinalizer` or :c:func:`PyObject_CallFinalizerFromDealloc` "
"instead."
msgstr ""
"Om du vill slutföra ett objekt manuellt ska du inte anropa den här "
"funktionen direkt, utan anropa istället :c:func:`PyObject_CallFinalizer` "
"eller :c:func:`PyObject_CallFinalizerFromDealloc`."

msgid ""
":c:member:`~PyTypeObject.tp_finalize` should leave the current exception "
"status unchanged.  The recommended way to write a non-trivial finalizer is "
"to back up the exception at the beginning by calling :c:func:"
"`PyErr_GetRaisedException` and restore the exception at the end by calling :"
"c:func:`PyErr_SetRaisedException`.  If an exception is encountered in the "
"middle of the finalizer, log and clear it with :c:func:"
"`PyErr_WriteUnraisable` or :c:func:`PyErr_FormatUnraisable`.  For example::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` bör lämna den aktuella "
"undantagsstatusen oförändrad.  Det rekommenderade sättet att skriva en icke-"
"trivial finalizer är att säkerhetskopiera undantaget i början genom att "
"anropa :c:func:`PyErr_GetRaisedException` och återställa undantaget i slutet "
"genom att anropa :c:func:`PyErr_SetRaisedException`.  Om ett undantag "
"påträffas i mitten av finalizer, logga och rensa det med :c:func:"
"`PyErr_WriteUnraisable` eller :c:func:`PyErr_FormatUnraisable`.  Till "
"exempel::"

msgid ""
"static void\n"
"foo_finalize(PyObject *self)\n"
"{\n"
"    // Save the current exception, if any.\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    // ...\n"
"\n"
"    if (do_something_that_might_raise() != success_indicator) {\n"
"        PyErr_WriteUnraisable(self);\n"
"        goto done;\n"
"    }\n"
"\n"
"done:\n"
"    // Restore the saved exception.  This silently discards any exception\n"
"    // raised above, so be sure to call PyErr_WriteUnraisable first if\n"
"    // necessary.\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"statiskt void\n"
"foo_finalize(PyObject *self)\n"
"{\n"
"    // Spara det aktuella undantaget, om det finns något.\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    // ...\n"
"\n"
"    if (do_something_that_might_raise() != success_indicator) {\n"
"        PyErr_WriteUnraisable(self);\n"
"        goto done;\n"
"    }\n"
"\n"
"done:\n"
"    // Återställer det sparade undantaget.  Detta förkastar i tysthet alla "
"undantag\n"
"    // som tagits upp ovan, så se till att anropa PyErr_WriteUnraisable "
"först om\n"
"    // nödvändigt.\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

msgid ""
"Before version 3.8 it was necessary to set the :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be used.  "
"This is no longer required."
msgstr ""
"Före version 3.8 var det nödvändigt att sätta flaggbiten :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` för att detta fält skulle kunna användas.  Detta "
"är inte längre nödvändigt."

msgid ":pep:`442`: \"Safe object finalization\""
msgstr ":pep:`442`: \"Säkert objekt färdigställs\""

msgid ":c:func:`PyObject_CallFinalizer`"
msgstr ":c:func:`PyObject_CallFinalizer`"

msgid ":c:func:`PyObject_CallFinalizerFromDealloc`"
msgstr ":c:func:`PyObject_CallFinalizerFromDealloc`"

msgid ""
"A :ref:`vectorcall function <vectorcall>` to use for calls of this type "
"object (rather than instances). In other words, ``tp_vectorcall`` can be "
"used to optimize ``type.__call__``, which typically returns a new instance "
"of *type*."
msgstr ""
"En :ref:`vectorcall-funktion <vectorcall>` att använda för anrop av detta "
"typobjekt (snarare än instanser). Med andra ord kan ``tp_vectorcall`` "
"användas för att optimera ``type.__call__``, som vanligtvis returnerar en ny "
"instans av *type*."

msgid ""
"As with any vectorcall function, if ``tp_vectorcall`` is ``NULL``, the "
"*tp_call* protocol (``Py_TYPE(type)->tp_call``) is used instead."
msgstr ""
"Som med alla vectorcall-funktioner, om ``tp_vectorcall`` är ``NULL``, "
"används *tp_call*-protokollet (``Py_TYPE(type)->tp_call``) istället."

msgid ""
"The :ref:`vectorcall protocol <vectorcall>` requires that the vectorcall "
"function has the same behavior as the corresponding ``tp_call``. This means "
"that ``type->tp_vectorcall`` must match the behavior of ``Py_TYPE(type)-"
">tp_call``."
msgstr ""
":ref:``vectorcall protokollet <vectorcall>`` kräver att vectorcall "
"funktionen har samma beteende som motsvarande ``tp_call``. Detta innebär att "
"``type-&gt;tp_vectorcall`` måste matcha beteendet hos ``Py_TYPE(type)-&gt;"
"tp_call``."

msgid ""
"Specifically, if *type* uses the default metaclass, ``type->tp_vectorcall`` "
"must behave the same as :c:expr:`PyType_Type->tp_call`, which:"
msgstr ""
"Specifikt, om *type* använder standardmetaklassen, måste ``type-"
">tp_vectorcall`` bete sig på samma sätt som :c:expr:`PyType_Type->tp_call`, "
"vilket:"

msgid "calls ``type->tp_new``,"
msgstr "anropar ``type->tp_new``,"

msgid ""
"if the result is a subclass of *type*, calls ``type->tp_init`` on the result "
"of ``tp_new``, and"
msgstr ""
"om resultatet är en subklass av *type*, anropar ``type->tp_init`` på "
"resultatet av ``tp_new``, och"

msgid "returns the result of ``tp_new``."
msgstr "returnerar resultatet av ``tp_new``."

msgid ""
"Typically, ``tp_vectorcall`` is overridden to optimize this process for "
"specific :c:member:`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject."
"tp_init`. When doing this for user-subclassable types, note that both can be "
"overridden (using :py:func:`~object.__new__` and :py:func:`~object."
"__init__`, respectively)."
msgstr ""
"Vanligtvis är ``tp_vectorcall`` åsidosatt för att optimera denna process för "
"specifika :c:member:`~PyTypeObject.tp_new` och :c:member:`~PyTypeObject."
"tp_init`. När du gör detta för användarsubklassbara typer, notera att båda "
"kan åsidosättas (med :py:func:`~object.__new__` respektive :py:func:`~object."
"__init__`)."

msgid "This field is never inherited."
msgstr "Detta fält är aldrig ärftligt."

msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(fältet har funnits sedan 3.8 men det används bara sedan 3.9)"

msgid "Internal. Do not use."
msgstr "Internt. Får inte användas."

msgid "Static Types"
msgstr "Statiska typer"

msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Traditionellt är typer som definieras i C-kod *statiska*, det vill säga en "
"statisk :c:type:`PyTypeObject`-struktur definieras direkt i koden och "
"initieras med :c:func:`PyType_Ready`."

msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Detta resulterar i typer som är begränsade i förhållande till de typer som "
"definieras i Python:"

msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Statiska typer är begränsade till en bas, dvs. de kan inte använda multipel "
"nedärvning."

msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Statiska typobjekt (men inte nödvändigtvis deras instanser) är "
"oföränderliga. Det är inte möjligt att lägga till eller ändra typobjektets "
"attribut från Python."

msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Statiska typobjekt delas mellan :ref:`undertolkare <sub-interpreter-"
"support>`, så de bör inte innehålla något undertolkarspecifikt tillstånd."

msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"Eftersom :c:type:`PyTypeObject` endast är en del av :ref:`Limited API "
"<limited-c-api>` som en opak struktur, måste alla tilläggsmoduler som "
"använder statiska typer kompileras för en specifik mindre Python-version."

msgid "Heap Types"
msgstr "Typer av högar"

msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :c:macro:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Ett alternativ till :ref:``static types <static-types>`` är *heap-allocated "
"types*, eller kort och gott *heap types*, som nära motsvarar klasser skapade "
"av Pythons ``class``-sats. Heap-typer har flaggan :c:macro:"
"`Py_TPFLAGS_HEAPTYPE` inställd."

msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec`, or :c:func:`PyType_FromMetaclass`."
msgstr ""
"Detta görs genom att fylla en :c:type:`PyType_Spec`-struktur och anropa :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec`, eller :c:func:`PyType_FromMetaclass`."

msgid "Number Object Structures"
msgstr "Strukturer för nummerobjekt"

msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som ett objekt använder "
"för att implementera nummerprotokollet.  Varje funktion används av "
"funktionen med liknande namn som dokumenteras i avsnittet :ref:`number`."

msgid "Here is the structure definition::"
msgstr "Här är strukturdefinitionen::"

msgid ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"
msgstr ""
"typedef struct {\n"
"     binärfunktion nb_add;\n"
"     binärfunktion nb_subtrahera;\n"
"     binärfunktion nb_multiplicera;\n"
"     binaryfunc nb_remainder;\n"
"     binärfunktion nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     förfrågan nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binärfunktion nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binärfunktion nb_and;\n"
"     binärfunktion nb_xor;\n"
"     binärfunktion nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binärfunktion nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binärfunktion nb_inplace_multiplicera;\n"
"     binärfunktion nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binärfunktion nb_inplace_lshift;\n"
"     binärfunktion nb_inplace_rshift;\n"
"     binärfunktion nb_inplace_and;\n"
"     binärfunktion nb_inplace_xor;\n"
"     binärfunktion nb_inplace_or;\n"
"\n"
"     binärfunktion nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binärfunktion nb_matris_multiplicera;\n"
"     binärfunktion nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"

msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Binära och ternära funktioner måste kontrollera typen av alla sina operander "
"och implementera nödvändiga konverteringar (minst en av operanderna är en "
"instans av den definierade typen).  Om operationen inte är definierad för de "
"givna operanderna måste binära och ternära funktioner returnera "
"``Py_NotImplemented``, om ett annat fel inträffade måste de returnera "
"``NULL`` och ange ett undantag."

msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in "
"Python 3.0.1."
msgstr ""
"Fältet :c:member:`~PyNumberMethods.nb_reserved` bör alltid vara ``NULL``.  "
"Det kallades tidigare :c:member:`!nb_long`, och döptes om i Python 3.0.1."

msgid "Mapping Object Structures"
msgstr "Mappning av objektstrukturer"

msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Denna struktur innehåller pekare till de funktioner som ett objekt använder "
"för att implementera mappningsprotokollet.  Den har tre medlemmar:"

msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Denna funktion används av :c:func:`PyMapping_Size` och :c:func:"
"`PyObject_Size`, och har samma signatur.  Denna slot kan sättas till "
"``NULL`` om objektet inte har någon definierad längd."

msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Denna funktion används av :c:func:`PyObject_GetItem` och :c:func:"
"`PySequence_GetSlice`, och har samma signatur som :c:func:`!"
"PyObject_GetItem`.  Denna slot måste vara fylld för att funktionen :c:func:"
"`PyMapping_Check` ska returnera ``1``, annars kan den vara ``NULL``."

msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and :c:func:"
"`PySequence_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Denna funktion används av :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` och :c:func:"
"`PySequence_DelSlice`.  Den har samma signatur som :c:func:`!"
"PyObject_SetItem`, men *v* kan också sättas till ``NULL`` för att radera ett "
"objekt.  Om denna slot är ``NULL`` har objektet inte stöd för tilldelning "
"och borttagning av objekt."

msgid "Sequence Object Structures"
msgstr "Strukturer för sekvensobjekt"

msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som ett objekt använder "
"för att implementera sekvensprotokollet."

msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Denna funktion används av :c:func:`PySequence_Size` och :c:func:"
"`PyObject_Size`, och har samma signatur.  Den används också för att hantera "
"negativa index via :c:member:`~PySequenceMethods.sq_item` och :c:member:"
"`~PySequenceMethods.sq_ass_item`."

msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_Concat` och har samma "
"signatur.  Den används också av operatorn ``+``, efter att ha försökt "
"numerisk addition via :c:member:`~PyNumberMethods.nb_add` slot."

msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_Repeat` och har samma "
"signatur.  Den används också av operatorn ``*``, efter att ha försökt "
"numerisk multiplikation via :c:member:`~PyNumberMethods.nb_multiply` slot."

msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Denna funktion används av :c:func:`PySequence_GetItem` och har samma "
"signatur.  Den används också av :c:func:`PyObject_GetItem`, efter att ha "
"provat prenumerationen via :c:member:`~PyMappingMethods.mp_subscript` slot. "
"Denna slot måste vara fylld för att funktionen :c:func:`PySequence_Check` "
"skall returnera ``1``, annars kan den vara ``NULL``."

msgid ""
"Negative indexes are handled as follows: if the :c:member:"
"`~PySequenceMethods.sq_length` slot is filled, it is called and the sequence "
"length is used to compute a positive index which is passed to  :c:member:"
"`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is ``NULL``, the "
"index is passed as is to the function."
msgstr ""
"Negativa index hanteras på följande sätt: om :c:member:`~PySequenceMethods."
"sq_length` är fylld, anropas den och sekvenslängden används för att beräkna "
"ett positivt index som skickas till :c:member:`~PySequenceMethods.sq_item`.  "
"Om :c:member:`!sq_length` är ``NULL``, skickas indexet som det är till "
"funktionen."

msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Denna funktion används av :c:func:`PySequence_SetItem` och har samma "
"signatur.  Den används också av :c:func:`PyObject_SetItem` och :c:func:"
"`PyObject_DelItem`, efter att ha försökt tilldelning och borttagning av "
"objekt via :c:member:`~PyMappingMethods.mp_ass_subscript` slot. Denna slot "
"kan lämnas till ``NULL`` om objektet inte stöder tilldelning och borttagning "
"av objekt."

msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Denna funktion kan användas av :c:func:`PySequence_Contains` och har samma "
"signatur.  Denna plats kan lämnas till ``NULL``, i detta fall kommer :c:func:"
"`!PySequence_Contains` helt enkelt att korsa sekvensen tills den hittar en "
"matchning."

msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_InPlaceConcat` och har samma "
"signatur.  Den bör modifiera sin första operand och returnera den.  Denna "
"plats kan lämnas till ``NULL``, i detta fall kommer :c:func:`!"
"PySequence_InPlaceConcat` att falla tillbaka till :c:func:"
"`PySequence_Concat`.  Den används också av den utökade tilldelningen ``+=``, "
"efter att ha försökt numerisk in-place addition via :c:member:"
"`~PyNumberMethods.nb_inplace_add` slot."

msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Denna funktion används av :c:func:`PySequence_InPlaceRepeat` och har samma "
"signatur.  Den bör modifiera sin första operand och returnera den.  Denna "
"plats kan lämnas till ``NULL``, i detta fall kommer :c:func:`!"
"PySequence_InPlaceRepeat` att falla tillbaka till :c:func:"
"`PySequence_Repeat`.  Den används också av den utökade tilldelningen ``*=``, "
"efter att ha försökt numerisk multiplikation på plats via :c:member:"
"`~PyNumberMethods.nb_inplace_multiply` slot."

msgid "Buffer Object Structures"
msgstr "Strukturer för buffertobjekt"

msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som krävs enligt :ref:"
"`Buffer protocol <bufferobjects>`. Protokollet definierar hur ett "
"exportobjekt kan exponera sina interna data till konsumentobjekt."

msgid "The signature of this function is::"
msgstr "Signaturen för denna funktion är::"

msgid "int (PyObject *exporter, Py_buffer *view, int flags);"
msgstr "int (PyObject *exporter, Py_buffer *view, int flags);"

msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Hantera en begäran till *exporter* om att fylla i *view* enligt "
"specifikationen i *flags*. Med undantag för punkt (3) MÅSTE en "
"implementering av denna funktion vidta följande steg:"

msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, set :c:"
"expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Kontrollera om begäran kan uppfyllas. Om inte, skapa :exc:`BufferError`, "
"sätt :c:expr:`view->obj` till ``NULL`` och returnera ``-1``."

msgid "Fill in the requested fields."
msgstr "Fyll i de begärda fälten."

msgid "Increment an internal counter for the number of exports."
msgstr "Öka en intern räknare för antalet exporter."

msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""
"Sätt :c:expr:`view->obj` till *exporter* och inkrementera :c:expr:`view-"
">obj`."

msgid "Return ``0``."
msgstr "Returnera ``0``."

msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Om *exporter* är en del av en kedja eller ett träd av buffertleverantörer "
"kan två huvudsakliga system användas:"

msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"expr:`view->obj` to a new reference to itself."
msgstr ""
"Återexportera: Varje medlem i trädet fungerar som det exporterande objektet "
"och sätter :c:expr:`view->obj` till en ny referens till sig själv."

msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"Redirect: Buffertbegäran omdirigeras till trädets rotobjekt. Här kommer :c:"
"expr:`view->obj` att vara en ny referens till rotobjektet."

msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"De enskilda fälten i *view* beskrivs i avsnitt :ref:`Buffertstruktur <buffer-"
"structure>`, reglerna för hur en exportör måste reagera på specifika "
"förfrågningar finns i avsnitt :ref:`Buffertförfrågningstyper <buffer-request-"
"types>`."

msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Allt minne som pekas ut i :c:type:`Py_buffer`-strukturen tillhör exportören "
"och måste förbli giltigt tills det inte finns några konsumenter kvar. :c:"
"member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:"
"`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` och :c:member:"
"`~Py_buffer.internal` är skrivskyddade för konsumenten."

msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` ger ett enkelt sätt att exponera en enkel "
"bytesbuffert samtidigt som alla typer av förfrågningar hanteras korrekt."

msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` är gränssnittet för den konsument som omsluter "
"denna funktion."

msgid "void (PyObject *exporter, Py_buffer *view);"
msgstr "void (PyObject *exporter, Py_buffer *view);"

msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Hanterar en begäran om att frigöra buffertens resurser. Om inga resurser "
"behöver frigöras kan :c:member:`PyBufferProcs.bf_releasebuffer` vara "
"``NULL``. Annars kommer en standardimplementering av denna funktion att "
"vidta dessa valfria steg:"

msgid "Decrement an internal counter for the number of exports."
msgstr "Minskar en intern räknare för antalet exporter."

msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Om räknaren är ``0``, frigör allt minne som är associerat med *view*."

msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"Exportören MÅSTE använda fältet :c:member:`~Py_buffer.internal` för att "
"hålla reda på buffertspecifika resurser. Detta fält är garanterat konstant, "
"medan en konsument KAN skicka en kopia av den ursprungliga bufferten som "
"*view*-argument."

msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Denna funktion FÅR INTE decimera :c:expr:`view->obj`, eftersom det görs "
"automatiskt i :c:func:`PyBuffer_Release` (detta system är användbart för att "
"bryta referenscykler)."

msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` är gränssnittet för den konsument som omsluter "
"denna funktion."

msgid "Async Object Structures"
msgstr "Strukturer för asynkrona objekt"

msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Denna struktur innehåller pekare till de funktioner som krävs för att "
"implementera objekten :term:`awaitable` och :term:`asynchronous iterator`."

msgid ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"
msgstr ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"

msgid "PyObject *am_await(PyObject *self);"
msgstr "PyObject *am_await(PyObject *self);"

msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"Det returnerade objektet måste vara en :term:`iterator`, d.v.s. :c:func:"
"`PyIter_Check` måste returnera ``1`` för det."

msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Denna slot kan sättas till ``NULL`` om ett objekt inte är en :term:"
"`awaitable`."

msgid "PyObject *am_aiter(PyObject *self);"
msgstr "PyObject *am_aiter(PyObject *self);"

msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`~object."
"__anext__` for details."
msgstr ""
"Måste returnera ett :term:`asynkron iterator`-objekt. Se :meth:`~object."
"__anext__` för detaljer."

msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Denna slot kan sättas till ``NULL`` om ett objekt inte implementerar "
"asynkront iterationsprotokoll."

msgid "PyObject *am_anext(PyObject *self);"
msgstr "PyObject *am_anext(PyObject *self);"

msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""
"Måste returnera ett :term:`awaitable`-objekt. Se :meth:`~object.__anext__` "
"för detaljer. Denna slot kan sättas till ``NULL``."

msgid "PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"
msgstr ""
"PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"

msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Se :c:func:`PyIter_Send` för detaljer. Denna slot kan sättas till ``NULL``."

msgid "Slot Type typedefs"
msgstr "Slotstyp typedef"

msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` and :c:member:`~PyObject."
"ob_type` set to the type argument.  If the type's :c:member:`~PyTypeObject."
"tp_itemsize` is non-zero, the object's :c:member:`~PyVarObject.ob_size` "
"field should be initialized to *nitems* and the length of the allocated "
"memory block should be ``tp_basicsize + nitems*tp_itemsize``, rounded up to "
"a multiple of ``sizeof(void*)``; otherwise, *nitems* is not used and the "
"length of the block should be :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Syftet med denna funktion är att separera minnesallokering från "
"minnesinitialisering.  Den ska returnera en pekare till ett minnesblock som "
"är tillräckligt långt för instansen, lämpligt inriktat och initialiserat "
"till nollor, men med :c:member:`~PyObject.ob_refcnt` satt till ``1`` och :c:"
"member:`~PyObject.ob_type` satt till typargumentet.  Om typens :c:member:"
"`~PyTypeObject.tp_itemsize` inte är noll, ska objektets :c:member:"
"`~PyVarObject.ob_size` initialiseras till *nitems* och längden på det "
"allokerade minnesblocket blir ``tp_basicsize + nitems*tp_itemsize``, "
"avrundat uppåt till en multipel av ``sizeof(void*)``; annars används inte "
"*nitems* och längden på blocket blir :c:member:`~PyTypeObject.tp_basicsize``."

msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Denna funktion bör inte göra någon annan instansinitialisering, inte ens för "
"att allokera ytterligare minne; det bör göras av :c:member:`~PyTypeObject."
"tp_new`."

msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Se :c:member:`~PyTypeObject.tp_free`."

msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Se :c:member:`~PyTypeObject.tp_new`."

msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Se :c:member:`~PyTypeObject.tp_init`."

msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Se :c:member:`~PyTypeObject.tp_repr`."

msgid "Return the value of the named attribute for the object."
msgstr "Returnerar värdet på det namngivna attributet för objektet."

msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Ställ in värdet på det namngivna attributet för objektet. Argumentet value "
"sätts till ``NULL`` för att ta bort attributet."

msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Se :c:member:`~PyTypeObject.tp_getattro`."

msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Se :c:member:`~PyTypeObject.tp_setattro`."

msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "Se :c:member:`~PyTypeObject.tp_descr_get`."

msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "Se :c:member:`~PyTypeObject.tp_descr_set`."

msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Se :c:member:`~PyTypeObject.tp_hash`."

msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Se :c:member:`~PyTypeObject.tp_richcompare`."

msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Se :c:member:`~PyTypeObject.tp_iter`."

msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Se :c:member:`~PyTypeObject.tp_iternext`."

msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "Se :c:member:`~PyAsyncMethods.am_send`."

msgid "Examples"
msgstr "Exempel"

msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Följande är enkla exempel på Python-typdefinitioner.  De inkluderar vanlig "
"användning som du kan stöta på.  Några demonstrerar knepiga hörnfall.  För "
"fler exempel, praktisk information och en handledning, se :ref:`defining-new-"
"types` och :ref:`new-types-topics`."

msgid "A basic :ref:`static type <static-types>`::"
msgstr "En grundläggande :ref:`statisk typ <static-types>`::"

msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_Huvud\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"Mina objekt\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"Du kan också hitta äldre kod (särskilt i CPython-kodbasen) med en mer "
"utförlig initialiserare::"

msgid ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"
msgstr ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\", /* tp_name */\n"
"    sizeof(MyObject), /* tp_basicsize */\n"
"    0, /* tp_itemsize */\n"
"    (destructor)myobj_dealloc, /* tp_dealloc */\n"
"    0, /* tp_vectorcall_offset */\n"
"    0, /* tp_getattr */\n"
"    0, /* tp_setattr */\n"
"    0, /* tp_as_async */\n"
"    (reprfunc)myobj_repr, /* tp_repr */\n"
"    0, /* tp_as_number */\n"
"    0, /* tp_as_sequence */\n"
"    0, /* tp_as_mapping */\n"
"    0, /* tp_hash */\n"
"    0, /* tp_call */\n"
"    0, /* tp_str */\n"
"    0, /* tp_getattro */\n"
"    0, /* tp_setattro */\n"
"    0, /* tp_as_buffer */\n"
"    0, /* tp_flags */\n"
"    PyDoc_STR(\"Mina objekt\"), /* tp_doc */\n"
"    0, /* tp_traverse */\n"
"    0, /* tp_clear */\n"
"    0, /* tp_richcompare */\n"
"    0, /* tp_weaklistoffset */\n"
"    0, /* tp_iter */\n"
"    0, /* tp_iternext */\n"
"    0, /* tp_methods */\n"
"    0, /* tp_members */\n"
"    0, /* tp_getset */\n"
"    0, /* tp_base */\n"
"    0, /* tp_dict */\n"
"    0, /* tp_descr_get */\n"
"    0, /* tp_descr_set */\n"
"    0, /* tp_dictoffset */\n"
"    0, /* tp_init */\n"
"    0, /* tp_alloc */\n"
"    myobj_new, /* tp_new */\n"
"};"

msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "En typ som stöder weakrefs, instance dicts och hashing::"

msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObjekt_Huvud\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"Mina objekt\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT | "
"Py_TPFLAGS_MANAGED_DICT | Py\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (förfrågan)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"

msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"En str-underklass som inte kan underklassas och inte kan anropas för att "
"skapa instanser (t.ex. använder en separat fabriksfunktion) med :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flagga::"

msgid ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyUnicodeObject rå;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"statiskt PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL, // satt till &PyUnicode_Type i modulinit\n"
"    .tp_doc = PyDoc_STR(\"min anpassade str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"Den enklaste :ref:` `statiska typen <static-types>` med instanser av fast "
"längd::"

msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"

msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"Den enklaste :ref:`statiska typen <static-types>` med instanser av variabel "
"längd::"

msgid ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"statisk PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"

msgid "built-in function"
msgstr "inbyggd funktion"

msgid "repr"
msgstr "repr"

msgid "hash"
msgstr "hash"
