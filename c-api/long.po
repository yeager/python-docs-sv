# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 14:20+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "Integer Objects"
msgstr "Heltalsobjekt"

msgid ""
"All integers are implemented as \"long\" integer objects of arbitrary size."
msgstr ""
"Alla heltal är implementerade som \"långa\" heltalsobjekt av godtycklig "
"storlek."

msgid ""
"On error, most ``PyLong_As*`` APIs return ``(return type)-1`` which cannot "
"be distinguished from a number.  Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"Vid fel returnerar de flesta ``PyLong_As*`` API:er ``(return type)-1`` som "
"inte kan särskiljas från ett tal.  Använd :c:func:`PyErr_Occurred` för att "
"särskilja."

msgid "This subtype of :c:type:`PyObject` represents a Python integer object."
msgstr ""
"Denna subtyp av :c:type:`PyObject` representerar ett Python-objekt med "
"heltal."

msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python integer type. "
"This is the same object as :class:`int` in the Python layer."
msgstr ""
"Denna instans av :c:type:`PyTypeObject` representerar Pythons heltalstyp. "
"Detta är samma objekt som :class:`int` i Python-lagret."

msgid ""
"Return true if its argument is a :c:type:`PyLongObject` or a subtype of :c:"
"type:`PyLongObject`.  This function always succeeds."
msgstr ""
"Returnerar true om dess argument är ett :c:type:`PyLongObject` eller en "
"subtyp av :c:type:`PyLongObject`.  Denna funktion lyckas alltid."

msgid ""
"Return true if its argument is a :c:type:`PyLongObject`, but not a subtype "
"of :c:type:`PyLongObject`.  This function always succeeds."
msgstr ""
"Returnerar true om dess argument är ett :c:type:`PyLongObject`, men inte en "
"subtyp av :c:type:`PyLongObject`.  Denna funktion lyckas alltid."

msgid ""
"Return a new :c:type:`PyLongObject` object from *v*, or ``NULL`` on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från *v*, eller ``NULL`` "
"om det misslyckas."

msgid ""
"The current implementation keeps an array of integer objects for all "
"integers between ``-5`` and ``256``. When you create an int in that range "
"you actually just get back a reference to the existing object."
msgstr ""
"Den nuvarande implementationen håller en array av heltalsobjekt för alla "
"heltal mellan ``-5`` och ``256``. När du skapar ett int i det intervallet "
"får du faktiskt bara tillbaka en referens till det befintliga objektet."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:expr:`unsigned long`, "
"or ``NULL`` on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från ett C :c:expr:"
"`unsigned long`, eller ``NULL`` om det misslyckas."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:type:`Py_ssize_t`, or "
"``NULL`` on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från en C :c:type:"
"`Py_ssize_t`, eller ``NULL`` vid fel."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:type:`size_t`, or "
"``NULL`` on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från en C :c:type:"
"`size_t`, eller ``NULL`` om det misslyckas."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:expr:`long long`, or "
"``NULL`` on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från ett C :c:expr:`long "
"long`, eller ``NULL`` om det misslyckas."

msgid ""
"Return a new :c:type:`PyLongObject` object from a signed C :c:expr:`int32_t` "
"or :c:expr:`int64_t`, or ``NULL`` with an exception set on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från en signerad C :c:expr:"
"`int32_t` eller :c:expr:`int64_t`, eller ``NULL`` med ett undantag om det "
"misslyckas."

msgid ""
"Return a new :c:type:`PyLongObject` object from a C :c:expr:`unsigned long "
"long`, or ``NULL`` on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från ett C :c:expr:"
"`unsigned long long`, eller ``NULL`` om det misslyckas."

msgid ""
"Return a new :c:type:`PyLongObject` object from an unsigned C :c:expr:"
"`uint32_t` or :c:expr:`uint64_t`, or ``NULL`` with an exception set on "
"failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från en osignerad C :c:"
"expr:`uint32_t` eller :c:expr:`uint64_t`, eller ``NULL`` med ett undantag om "
"det misslyckas."

msgid ""
"Return a new :c:type:`PyLongObject` object from the integer part of *v*, or "
"``NULL`` on failure."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject`-objekt från heltalsdelen av *v*, "
"eller ``NULL`` om det misslyckas."

msgid ""
"Return a new :c:type:`PyLongObject` based on the string value in *str*, "
"which is interpreted according to the radix in *base*, or ``NULL`` on "
"failure.  If *pend* is non-``NULL``, *\\*pend* will point to the end of "
"*str* on success or to the first character that could not be processed on "
"error.  If *base* is ``0``, *str* is interpreted using the :ref:`integers` "
"definition; in this case, leading zeros in a non-zero decimal number raises "
"a :exc:`ValueError`.  If *base* is not ``0``, it must be between ``2`` and "
"``36``, inclusive.  Leading and trailing whitespace and single underscores "
"after a base specifier and between digits are ignored.  If there are no "
"digits or *str* is not NULL-terminated following the digits and trailing "
"whitespace, :exc:`ValueError` will be raised."
msgstr ""
"Returnerar ett nytt :c:type:`PyLongObject` baserat på strängvärdet i *str*, "
"som tolkas enligt radix i *base*, eller ``NULL`` om det misslyckas.  Om "
"*pend* är icke-``NULL`` kommer *\\*pend* att peka på slutet av *str* vid "
"framgång eller på det första tecknet som inte kunde bearbetas vid fel.  Om "
"*base* är ``0`` tolkas *str* med hjälp av :ref:`integers`-definitionen; i "
"det här fallet ger inledande nollor i ett decimaltal som inte är noll upphov "
"till :exc:`ValueError`.  Om *base* inte är ``0`` måste det vara mellan ``2`` "
"och ``36``, inklusive.  Ledande och efterföljande blanksteg och enkla "
"understrykningstecken efter en basspecifikation och mellan siffror "
"ignoreras.  Om det inte finns några siffror eller om *str* inte är NULL-"
"terminerad efter siffrorna och efterföljande blanksteg, kommer :exc:"
"`ValueError` att tas upp."

msgid ""
":c:func:`PyLong_AsNativeBytes()` and :c:func:`PyLong_FromNativeBytes()` "
"functions can be used to convert a :c:type:`PyLongObject` to/from an array "
"of bytes in base ``256``."
msgstr ""
"funktionerna :c:func:`PyLong_AsNativeBytes()` och :c:func:"
"`PyLong_FromNativeBytes()` kan användas för att konvertera ett :c:type:"
"`PyLongObject` till/från en array av bytes i basen ``256``."

msgid ""
"Convert a sequence of Unicode digits in the string *u* to a Python integer "
"value."
msgstr ""
"Konverterar en sekvens av Unicode-siffror i strängen *u* till ett "
"heltalsvärde i Python."

msgid ""
"Create a Python integer from the pointer *p*. The pointer value can be "
"retrieved from the resulting value using :c:func:`PyLong_AsVoidPtr`."
msgstr ""
"Skapar ett Python heltal från pekaren *p*. Pekarens värde kan hämtas från "
"det resulterande värdet med hjälp av :c:func:`PyLong_AsVoidPtr`."

msgid ""
"Create a Python integer from the value contained in the first *n_bytes* of "
"*buffer*, interpreted as a two's-complement signed number."
msgstr ""
"Skapa ett Python-integral från det värde som finns i de första *n_bytes* i "
"*buffer*, tolkat som ett tvåkompletterat signerat tal."

msgid ""
"*flags* are as for :c:func:`PyLong_AsNativeBytes`. Passing ``-1`` will "
"select the native endian that CPython was compiled with and assume that the "
"most-significant bit is a sign bit. Passing "
"``Py_ASNATIVEBYTES_UNSIGNED_BUFFER`` will produce the same result as "
"calling :c:func:`PyLong_FromUnsignedNativeBytes`. Other flags are ignored."
msgstr ""
"*flags* är som för :c:func:`PyLong_AsNativeBytes`. Om du anger ``-1`` kommer "
"du att välja den inbyggda endian som CPython kompilerades med och anta att "
"den mest signifikanta biten är en teckenbit. Att skicka "
"``Py_ASNATIVEBYTES_UNSIGNED_BUFFER`` kommer att ge samma resultat som att "
"anropa :c:func:`PyLong_FromUnsignedNativeBytes`. Andra flaggor ignoreras."

msgid ""
"Create a Python integer from the value contained in the first *n_bytes* of "
"*buffer*, interpreted as an unsigned number."
msgstr ""
"Skapa ett Python-integral från det värde som finns i de första *n_bytes* i "
"*buffer*, tolkat som ett osignerat tal."

msgid ""
"*flags* are as for :c:func:`PyLong_AsNativeBytes`. Passing ``-1`` will "
"select the native endian that CPython was compiled with and assume that the "
"most-significant bit is not a sign bit. Flags other than endian are ignored."
msgstr ""
"*flags* är som för :c:func:`PyLong_AsNativeBytes`. Om du skickar ``-1`` "
"kommer du att välja den inbyggda endian som CPython kompilerades med och "
"anta att den mest signifikanta biten inte är en teckenbit. Andra flaggor än "
"endian ignoreras."

msgid ""
"Return a C :c:expr:`long` representation of *obj*.  If *obj* is not an "
"instance of :c:type:`PyLongObject`, first call its :meth:`~object.__index__` "
"method (if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:expr:`long`-representation av *obj*.  Om *obj* inte är en "
"instans av :c:type:`PyLongObject`, anropa först dess :meth:`~object."
"__index__`-metod (om sådan finns) för att konvertera den till en :c:type:"
"`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *obj* is out of range for a :c:"
"expr:`long`."
msgstr ""
"Utlös :exc:`OverflowError` om värdet på *obj* är utanför intervallet för en :"
"c:expr:`long`."

msgid "Returns ``-1`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"Returnerar ``-1`` vid fel.  Använd :c:func:`PyErr_Occurred` för att "
"särskilja."

msgid "Use :meth:`~object.__index__` if available."
msgstr "Använd :meth:`~object.__index__` om det finns tillgängligt."

msgid "This function will no longer use :meth:`~object.__int__`."
msgstr "Denna funktion kommer inte längre att använda :meth:`~object.__int__`."

msgid ""
"A :term:`soft deprecated` alias. Exactly equivalent to the preferred "
"``PyLong_AsLong``. In particular, it can fail with :exc:`OverflowError` or "
"another exception."
msgstr ""
"Ett :term:`soft deprecated` alias. Exakt likvärdigt med det föredragna "
"``PyLong_AsLong``. I synnerhet kan det misslyckas med :exc:`OverflowError` "
"eller något annat undantag."

msgid "The function is soft deprecated."
msgstr "Funktionen är föråldrad."

msgid ""
"Similar to :c:func:`PyLong_AsLong`, but store the result in a C :c:expr:"
"`int` instead of a C :c:expr:`long`."
msgstr ""
"Liknar :c:func:`PyLong_AsLong`, men lagrar resultatet i en C :c:expr:`int` "
"istället för en C :c:expr:`long`."

msgid ""
"If the value of *obj* is greater than :c:macro:`LONG_MAX` or less than :c:"
"macro:`LONG_MIN`, set *\\*overflow* to ``1`` or ``-1``, respectively, and "
"return ``-1``; otherwise, set *\\*overflow* to ``0``.  If any other "
"exception occurs set *\\*overflow* to ``0`` and return ``-1`` as usual."
msgstr ""
"Om värdet på *obj* är större än :c:macro:`LONG_MAX` eller mindre än :c:macro:"
"`LONG_MIN`, sätt *\\*overflow* till ``1`` respektive ``-1`` och returnera "
"``-1``; annars sätt *\\*overflow* till ``0``.  Om något annat undantag "
"inträffar, sätt *\\*overflow* till ``0`` och returnera ``-1`` som vanligt."

msgid ""
"Return a C :c:expr:`long long` representation of *obj*.  If *obj* is not an "
"instance of :c:type:`PyLongObject`, first call its :meth:`~object.__index__` "
"method (if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:expr:`long long`-representation av *obj*.  Om *obj* inte "
"är en instans av :c:type:`PyLongObject`, anropa först dess :meth:`~object."
"__index__`-metod (om sådan finns) för att konvertera den till en :c:type:"
"`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *obj* is out of range for a :c:"
"expr:`long long`."
msgstr ""
"Utlös :exc:`OverflowError` om värdet på *obj* är utanför intervallet för "
"ett :c:expr:`long long`."

msgid ""
"If the value of *obj* is greater than :c:macro:`LLONG_MAX` or less than :c:"
"macro:`LLONG_MIN`, set *\\*overflow* to ``1`` or ``-1``, respectively, and "
"return ``-1``; otherwise, set *\\*overflow* to ``0``.  If any other "
"exception occurs set *\\*overflow* to ``0`` and return ``-1`` as usual."
msgstr ""
"Om värdet på *obj* är större än :c:macro:`LLONG_MAX` eller mindre än :c:"
"macro:`LLONG_MIN`, sätt *\\*overflow* till ``1`` respektive ``-1`` och "
"returnera ``-1``; annars sätt *\\*overflow* till ``0``.  Om något annat "
"undantag inträffar, sätt *\\*overflow* till ``0`` och returnera ``-1`` som "
"vanligt."

msgid ""
"Return a C :c:type:`Py_ssize_t` representation of *pylong*.  *pylong* must "
"be an instance of :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:type:`Py_ssize_t`-representation av *pylong*.  *pylong* "
"måste vara en instans av :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"type:`Py_ssize_t`."
msgstr ""
"Utlös :exc:`OverflowError` om värdet på *pylong* är utanför intervallet för "
"en :c:type:`Py_ssize_t`."

msgid ""
"Return a C :c:expr:`unsigned long` representation of *pylong*.  *pylong* "
"must be an instance of :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:expr:`unsigned long`-representation av *pylong*.  "
"*pylong* måste vara en instans av :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"expr:`unsigned long`."
msgstr ""
"Utlös :exc:`OverflowError` om värdet på *pylong* är utanför intervallet för "
"en :c:expr:`unsigned long`."

msgid ""
"Returns ``(unsigned long)-1`` on error. Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"Returnerar ``(unsigned long)-1`` vid fel. Använd :c:func:`PyErr_Occurred` "
"för att särskilja."

msgid ""
"Return a C :c:type:`size_t` representation of *pylong*.  *pylong* must be an "
"instance of :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:type:`size_t`-representation av *pylong*.  *pylong* måste "
"vara en instans av :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"type:`size_t`."
msgstr ""
"Utlös :exc:`OverflowError` om värdet på *pylong* är utanför intervallet för "
"en :c:type:`size_t`."

msgid ""
"Returns ``(size_t)-1`` on error. Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"Returnerar ``(size_t)-1`` vid fel. Använd :c:func:`PyErr_Occurred` för att "
"särskilja."

msgid ""
"Return a C :c:expr:`unsigned long long` representation of *pylong*.  "
"*pylong* must be an instance of :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:expr:`unsigned long long`-representation av *pylong*.  "
"*pylong* måste vara en instans av :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for an :"
"c:expr:`unsigned long long`."
msgstr ""
"Utlös :exc:`OverflowError` om värdet på *pylong* är utanför intervallet för "
"en :c:expr:`unsigned long long`."

msgid ""
"Returns ``(unsigned long long)-1`` on error. Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"Returnerar ``(unsigned long long)-1`` vid fel. Använd :c:func:"
"`PyErr_Occurred` för att särskilja."

msgid ""
"A negative *pylong* now raises :exc:`OverflowError`, not :exc:`TypeError`."
msgstr ""
"En negativ *pylong* ger nu upphov till :exc:`OverflowError`, inte :exc:"
"`TypeError`."

msgid ""
"Return a C :c:expr:`unsigned long` representation of *obj*.  If *obj* is not "
"an instance of :c:type:`PyLongObject`, first call its :meth:`~object."
"__index__` method (if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:expr:`unsigned long`-representation av *obj*.  Om *obj* "
"inte är en instans av :c:type:`PyLongObject`, anropa först dess :meth:"
"`~object.__index__`-metod (om sådan finns) för att konvertera den till en :c:"
"type:`PyLongObject`."

msgid ""
"If the value of *obj* is out of range for an :c:expr:`unsigned long`, return "
"the reduction of that value modulo ``ULONG_MAX + 1``."
msgstr ""
"Om värdet på *obj* är utanför intervallet för en :c:expr:`unsigned long`, "
"returneras minskningen av värdet modulo ``ULONG_MAX + 1``."

msgid ""
"Returns ``(unsigned long)-1`` on error.  Use :c:func:`PyErr_Occurred` to "
"disambiguate."
msgstr ""
"Returnerar ``(unsigned long)-1`` vid fel.  Använd :c:func:`PyErr_Occurred` "
"för att särskilja."

msgid ""
"Return a C :c:expr:`unsigned long long` representation of *obj*.  If *obj* "
"is not an instance of :c:type:`PyLongObject`, first call its :meth:`~object."
"__index__` method (if present) to convert it to a :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:expr:`unsigned long long`-representation av *obj*.  Om "
"*obj* inte är en instans av :c:type:`PyLongObject`, anropa först dess :meth:"
"`~object.__index__`-metod (om sådan finns) för att konvertera den till en :c:"
"type:`PyLongObject`."

msgid ""
"If the value of *obj* is out of range for an :c:expr:`unsigned long long`, "
"return the reduction of that value modulo ``ULLONG_MAX + 1``."
msgstr ""
"Om värdet på *obj* är utanför intervallet för en :c:expr:`unsigned long "
"long`, returneras reduktionen av värdet modulo ``ULLONG_MAX + 1``."

msgid ""
"Returns ``(unsigned long long)-1`` on error.  Use :c:func:`PyErr_Occurred` "
"to disambiguate."
msgstr ""
"Returnerar ``(unsigned long long)-1`` vid fel.  Använd :c:func:"
"`PyErr_Occurred` för att särskilja."

msgid ""
"Set *\\*value* to a signed C :c:expr:`int32_t` or :c:expr:`int64_t` "
"representation of *obj*."
msgstr ""
"Sätt *\\*värde* till en signerad C :c:expr:`int32_t` eller :c:expr:`int64_t` "
"representation av *obj*."

msgid "If the *obj* value is out of range, raise an :exc:`OverflowError`."
msgstr ""
"Om *obj*-värdet ligger utanför intervallet genereras ett :exc:"
"`OverflowError`."

msgid ""
"Set *\\*value* and return ``0`` on success. Set an exception and return "
"``-1`` on error."
msgstr ""
"Ställ in *\\*värde* och returnera ``0`` vid framgång. Ställ in ett undantag "
"och returnera ``-1`` vid fel."

msgid "*value* must not be ``NULL``."
msgstr "*värde* får inte vara ``NULL``."

msgid ""
"Set *\\*value* to an unsigned C :c:expr:`uint32_t` or :c:expr:`uint64_t` "
"representation of *obj*."
msgstr ""
"Sätt *\\*värde* till en osignerad C :c:expr:`uint32_t` eller :c:expr:"
"`uint64_t` representation av *obj*."

msgid ""
"If *obj* is not an instance of :c:type:`PyLongObject`, first call its :meth:"
"`~object.__index__` method (if present) to convert it to a :c:type:"
"`PyLongObject`."
msgstr ""
"Om *obj* inte är en instans av :c:type:`PyLongObject`, anropa först dess :"
"meth:`~object.__index__`-metod (om sådan finns) för att konvertera den till "
"en :c:type:`PyLongObject`."

msgid "If *obj* is negative, raise a :exc:`ValueError`."
msgstr "Om *obj* är negativ, skapa ett :exc:`ValueError`."

msgid ""
"Return a C :c:expr:`double` representation of *pylong*.  *pylong* must be an "
"instance of :c:type:`PyLongObject`."
msgstr ""
"Returnerar en C :c:expr:`double`-representation av *pylong*.  *pylong* måste "
"vara en instans av :c:type:`PyLongObject`."

msgid ""
"Raise :exc:`OverflowError` if the value of *pylong* is out of range for a :c:"
"expr:`double`."
msgstr ""
"Utlös :exc:`OverflowError` om värdet på *pylong* är utanför intervallet för "
"en :c:expr:`double`."

msgid ""
"Returns ``-1.0`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"Returnerar ``-1.0`` vid fel.  Använd :c:func:`PyErr_Occurred` för att "
"undvika tvetydighet."

msgid ""
"Convert a Python integer *pylong* to a C :c:expr:`void` pointer. If *pylong* "
"cannot be converted, an :exc:`OverflowError` will be raised.  This is only "
"assured to produce a usable :c:expr:`void` pointer for values created with :"
"c:func:`PyLong_FromVoidPtr`."
msgstr ""
"Konverterar ett Python-heltal *pylong* till en C :c:expr:`void`-pekare. Om "
"*pylong* inte kan konverteras, kommer ett :exc:`OverflowError` att uppstå.  "
"Detta är endast säkerställt för att producera en användbar :c:expr:`void`-"
"pekare för värden som skapats med :c:func:`PyLong_FromVoidPtr`."

msgid ""
"Returns ``NULL`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"Returnerar ``NULL`` vid fel.  Använd :c:func:`PyErr_Occurred` för att "
"särskilja."

msgid ""
"Copy the Python integer value *pylong* to a native *buffer* of size "
"*n_bytes*. The *flags* can be set to ``-1`` to behave similarly to a C cast, "
"or to values documented below to control the behavior."
msgstr ""
"Kopierar Python-heltalvärdet *pylong* till en inbyggd *buffer* med storleken "
"*n_bytes*. *flags* kan sättas till ``-1`` för att bete sig på liknande sätt "
"som en C-cast, eller till värden som dokumenteras nedan för att styra "
"beteendet."

msgid ""
"Returns ``-1`` with an exception raised on error.  This may happen if "
"*pylong* cannot be interpreted as an integer, or if *pylong* was negative "
"and the ``Py_ASNATIVEBYTES_REJECT_NEGATIVE`` flag was set."
msgstr ""
"Returnerar ``-1`` med ett undantag vid fel.  Detta kan hända om *pylong* "
"inte kan tolkas som ett heltal, eller om *pylong* var negativt och flaggan "
"``Py_ASNATIVEBYTES_REJECT_NEGATIVE`` var inställd."

msgid ""
"Otherwise, returns the number of bytes required to store the value. If this "
"is equal to or less than *n_bytes*, the entire value was copied. All "
"*n_bytes* of the buffer are written: large buffers are padded with zeroes."
msgstr ""
"I annat fall returneras det antal byte som krävs för att lagra värdet. Om "
"detta är lika med eller mindre än *n_bytes* har hela värdet kopierats. Alla "
"*n_bytes* i bufferten skrivs: stora buffertar fylls på med nollor."

msgid ""
"If the returned value is greater than *n_bytes*, the value was truncated: as "
"many of the lowest bits of the value as could fit are written, and the "
"higher bits are ignored. This matches the typical behavior of a C-style "
"downcast."
msgstr ""
"Om det returnerade värdet är större än *n_bytes* har värdet trunkerats: så "
"många av de lägsta bitarna av värdet som ryms skrivs in och de högre bitarna "
"ignoreras. Detta motsvarar det typiska beteendet hos en C-stil downcast."

msgid ""
"Overflow is not considered an error. If the returned value is larger than "
"*n_bytes*, most significant bits were discarded."
msgstr ""
"Överflöde betraktas inte som ett fel. Om det returnerade värdet är större än "
"*n_bytes*, har de mest signifikanta bitarna tagits bort."

msgid "``0`` will never be returned."
msgstr "``0`` kommer aldrig att returneras."

msgid "Values are always copied as two's-complement."
msgstr "Värdena kopieras alltid som tvåkomplement."

msgid "Usage example::"
msgstr "Exempel på användning::"

msgid ""
"int32_t value;\n"
"Py_ssize_t bytes = PyLong_AsNativeBytes(pylong, &value, sizeof(value), -1);\n"
"if (bytes < 0) {\n"
"    // Failed. A Python exception was set with the reason.\n"
"    return NULL;\n"
"}\n"
"else if (bytes <= (Py_ssize_t)sizeof(value)) {\n"
"    // Success!\n"
"}\n"
"else {\n"
"    // Overflow occurred, but 'value' contains the truncated\n"
"    // lowest bits of pylong.\n"
"}"
msgstr ""
"int32_t värde;\n"
"Py_ssize_t bytes = PyLong_AsNativeBytes(pylong, &värde, sizeof(värde), -1);\n"
"if (bytes < 0) {\n"
"    // Misslyckades. Ett Python-undantag skapades med orsaken.\n"
"    returnera NULL;\n"
"}\n"
"else if (bytes <= (Py_ssize_t)sizeof(värde)) {\n"
"    // Framgång!\n"
"}\n"
"else {\n"
"    // Överflöde inträffade, men 'värde' innehåller de trunkerade\n"
"    // lägsta bitarna av pylong.\n"
"}"

msgid ""
"Passing zero to *n_bytes* will return the size of a buffer that would be "
"large enough to hold the value. This may be larger than technically "
"necessary, but not unreasonably so. If *n_bytes=0*, *buffer* may be ``NULL``."
msgstr ""
"Om du anger noll till *n_bytes* returneras storleken på en buffert som "
"skulle vara tillräckligt stor för att rymma värdet. Denna kan vara större än "
"vad som är tekniskt nödvändigt, men inte orimligt. Om *n_bytes=0* kan "
"*buffer* vara ``NULL``."

msgid ""
"Passing *n_bytes=0* to this function is not an accurate way to determine the "
"bit length of the value."
msgstr ""
"Att skicka *n_bytes=0* till den här funktionen är inte ett korrekt sätt att "
"bestämma bitlängden för värdet."

msgid ""
"To get at the entire Python value of an unknown size, the function can be "
"called twice: first to determine the buffer size, then to fill it::"
msgstr ""
"För att komma åt hela Python-värdet av en okänd storlek kan funktionen "
"anropas två gånger: först för att bestämma buffertstorleken, sedan för att "
"fylla den::"

msgid ""
"// Ask how much space we need.\n"
"Py_ssize_t expected = PyLong_AsNativeBytes(pylong, NULL, 0, -1);\n"
"if (expected < 0) {\n"
"    // Failed. A Python exception was set with the reason.\n"
"    return NULL;\n"
"}\n"
"assert(expected != 0);  // Impossible per the API definition.\n"
"uint8_t *bignum = malloc(expected);\n"
"if (!bignum) {\n"
"    PyErr_SetString(PyExc_MemoryError, \"bignum malloc failed.\");\n"
"    return NULL;\n"
"}\n"
"// Safely get the entire value.\n"
"Py_ssize_t bytes = PyLong_AsNativeBytes(pylong, bignum, expected, -1);\n"
"if (bytes < 0) {  // Exception has been set.\n"
"    free(bignum);\n"
"    return NULL;\n"
"}\n"
"else if (bytes > expected) {  // This should not be possible.\n"
"    PyErr_SetString(PyExc_RuntimeError,\n"
"        \"Unexpected bignum truncation after a size check.\");\n"
"    free(bignum);\n"
"    return NULL;\n"
"}\n"
"// The expected success given the above pre-check.\n"
"// ... use bignum ...\n"
"free(bignum);"
msgstr ""
"// Fråga hur mycket utrymme vi behöver.\n"
"Py_ssize_t expected = PyLong_AsNativeBytes(pylong, NULL, 0, -1);\n"
"if (expected < 0) {\n"
"    // Misslyckades. Ett Python-undantag skapades med orsaken.\n"
"    returnera NULL;\n"
"}\n"
"assert(expected != 0); // Omöjligt enligt API-definitionen.\n"
"uint8_t *bignum = malloc(expected);\n"
"if (!bignum) {\n"
"    PyErr_SetString(PyExc_MemoryError, \"malloc för bignum misslyckades."
"\");\n"
"    returnera NULL;\n"
"}\n"
"// Hämta hela värdet på ett säkert sätt.\n"
"Py_ssize_t bytes = PyLong_AsNativeBytes(pylong, bignum, expected, -1);\n"
"if (bytes < 0) { // Undantaget har ställts in.\n"
"    free(bignum);\n"
"    returnerar NULL;\n"
"}\n"
"else if (bytes > expected) { // Detta borde inte vara möjligt.\n"
"    PyErr_SetString(PyExc_RuntimeError,\n"
"        \"Oväntad avkortning av bignum efter en storlekskontroll.\");\n"
"    free(bignum);\n"
"    returnera NULL;\n"
"}\n"
"// Den förväntade framgången med tanke på ovanstående förkontroll.\n"
"// ... använd bignum ...\n"
"free(bignum);"

msgid ""
"*flags* is either ``-1`` (``Py_ASNATIVEBYTES_DEFAULTS``) to select defaults "
"that behave most like a C cast, or a combination of the other flags in the "
"table below. Note that ``-1`` cannot be combined with other flags."
msgstr ""
"*flags* är antingen ``-1`` (``Py_ASNATIVEBYTES_DEFAULTS``) för att välja "
"standardvärden som beter sig mest som en C-cast, eller en kombination av de "
"andra flaggorna i tabellen nedan. Observera att ``-1`` inte kan kombineras "
"med andra flaggor."

msgid ""
"Currently, ``-1`` corresponds to ``Py_ASNATIVEBYTES_NATIVE_ENDIAN | "
"Py_ASNATIVEBYTES_UNSIGNED_BUFFER``."
msgstr ""
"För närvarande motsvarar ``-1`` ``Py_ASNATIVEBYTES_NATIVE_ENDIAN | "
"Py_ASNATIVEBYTES_UNSIGNED_BUFFER``."

msgid "Flag"
msgstr "Flagga"

msgid "Value"
msgstr "Värde"

msgid "``-1``"
msgstr "``-1``"

msgid "``0``"
msgstr "``0``"

msgid "``1``"
msgstr "``1``"

msgid "``3``"
msgstr "``3``"

msgid "``4``"
msgstr "``4``"

msgid "``8``"
msgstr "``8``"

msgid "``16``"
msgstr "``16``"

msgid ""
"Specifying ``Py_ASNATIVEBYTES_NATIVE_ENDIAN`` will override any other endian "
"flags. Passing ``2`` is reserved."
msgstr ""
"Om du anger ``Py_ASNATIVEBYTES_NATIVE_ENDIAN`` åsidosätts alla andra endian-"
"flaggor. Att skicka ``2`` är reserverat."

msgid ""
"By default, sufficient buffer will be requested to include a sign bit. For "
"example, when converting 128 with *n_bytes=1*, the function will return 2 "
"(or more) in order to store a zero sign bit."
msgstr ""
"Som standard kommer tillräcklig buffert att begäras för att inkludera en "
"teckenbit. Till exempel, vid konvertering av 128 med *n_bytes=1*, kommer "
"funktionen att returnera 2 (eller mer) för att lagra en nollteckenbit."

msgid ""
"If ``Py_ASNATIVEBYTES_UNSIGNED_BUFFER`` is specified, a zero sign bit will "
"be omitted from size calculations. This allows, for example, 128 to fit in a "
"single-byte buffer. If the destination buffer is later treated as signed, a "
"positive input value may become negative. Note that the flag does not affect "
"handling of negative values: for those, space for a sign bit is always "
"requested."
msgstr ""
"Om ``Py_ASNATIVEBYTES_UNSIGNED_BUFFER`` anges kommer en bit med nolltecken "
"att utelämnas vid storleksberäkningar. Detta gör att t.ex. 128 kan rymmas i "
"en buffert på en byte. Om målbufferten senare behandlas som signerad kan ett "
"positivt ingångsvärde bli negativt. Observera att flaggan inte påverkar "
"hanteringen av negativa värden: för dessa begärs alltid utrymme för en "
"teckenbit."

msgid ""
"Specifying ``Py_ASNATIVEBYTES_REJECT_NEGATIVE`` causes an exception to be "
"set if *pylong* is negative. Without this flag, negative values will be "
"copied provided there is enough space for at least one sign bit, regardless "
"of whether ``Py_ASNATIVEBYTES_UNSIGNED_BUFFER`` was specified."
msgstr ""
"Om du anger ``Py_ASNATIVEBYTES_REJECT_NEGATIVE`` kommer ett undantag att "
"ställas in om *pylong* är negativt. Utan denna flagga kommer negativa värden "
"att kopieras förutsatt att det finns tillräckligt med utrymme för minst en "
"teckenbit, oavsett om ``Py_ASNATIVEBYTES_UNSIGNED_BUFFER`` har angetts."

msgid ""
"If ``Py_ASNATIVEBYTES_ALLOW_INDEX`` is specified and a non-integer value is "
"passed, its :meth:`~object.__index__` method will be called first. This may "
"result in Python code executing and other threads being allowed to run, "
"which could cause changes to other objects or values in use. When *flags* is "
"``-1``, this option is not set, and non-integer values will raise :exc:"
"`TypeError`."
msgstr ""
"Om ``Py_ASNATIVEBYTES_ALLOW_INDEX`` specificeras och ett icke-integer värde "
"skickas, kommer dess :meth:`~object.__index__` metod att anropas först. "
"Detta kan resultera i att Python-kod exekveras och att andra trådar tillåts "
"köras, vilket kan orsaka ändringar i andra objekt eller värden som används. "
"När *flags* är ``-1`` anges inte detta alternativ, och värden som inte är "
"heltal kommer att ge upphov till :exc:`TypeError`."

msgid ""
"With the default *flags* (``-1``, or *UNSIGNED_BUFFER*  without "
"*REJECT_NEGATIVE*), multiple Python integers can map to a single value "
"without overflow. For example, both ``255`` and ``-1`` fit a single-byte "
"buffer and set all its bits. This matches typical C cast behavior."
msgstr ""
"Med standard *flags* (``-1``, eller *UNSIGNED_BUFFER* utan "
"*REJECT_NEGATIVE*), kan flera Python heltal mappas till ett enda värde utan "
"överflöd. Till exempel, både ``255`` och ``-1`` passar en buffert på en byte "
"och ställer in alla dess bitar. Detta matchar typiskt C cast-beteende."

msgid "Get the sign of the integer object *obj*."
msgstr "Hämta tecknet för heltalsobjektet *obj*."

msgid ""
"On success, set *\\*sign* to the integer sign  (0, -1 or +1 for zero, "
"negative or positive integer, respectively) and return 0."
msgstr ""
"Vid framgång, sätt *\\*sign* till heltalstecknet (0, -1 eller +1 för noll, "
"negativt respektive positivt heltal) och returnera 0."

msgid ""
"On failure, return -1 with an exception set.  This function always succeeds "
"if *obj* is a :c:type:`PyLongObject` or its subtype."
msgstr ""
"Om funktionen misslyckas returneras -1 med en undantagsuppsättning.  Denna "
"funktion lyckas alltid om *obj* är en :c:type:`PyLongObject` eller dess "
"subtyp."

msgid "Check if the integer object *obj* is positive (``obj > 0``)."
msgstr "Kontrollera om heltalsobjektet *obj* är positivt (``obj > 0``)."

msgid ""
"If *obj* is an instance of :c:type:`PyLongObject` or its subtype, return "
"``1`` when it's positive and ``0`` otherwise.  Else set an exception and "
"return ``-1``."
msgstr ""
"Om *obj* är en instans av :c:type:`PyLongObject` eller dess subtyp, "
"returnera ``1`` när den är positiv och ``0`` annars.  Annars anges ett "
"undantag och ``-1`` returneras."

msgid "Check if the integer object *obj* is negative (``obj < 0``)."
msgstr "Kontrollera om heltalsobjektet *obj* är negativt (``obj < 0``)."

msgid ""
"If *obj* is an instance of :c:type:`PyLongObject` or its subtype, return "
"``1`` when it's negative and ``0`` otherwise.  Else set an exception and "
"return ``-1``."
msgstr ""
"Om *obj* är en instans av :c:type:`PyLongObject` eller dess subtyp, "
"returnera ``1`` när den är negativ och ``0`` annars.  Annars anges ett "
"undantag och ``-1`` returneras."

msgid "Check if the integer object *obj* is zero."
msgstr "Kontrollera om heltalsobjektet *obj* är noll."

msgid ""
"If *obj* is an instance of :c:type:`PyLongObject` or its subtype, return "
"``1`` when it's zero and ``0`` otherwise.  Else set an exception and return "
"``-1``."
msgstr ""
"Om *obj* är en instans av :c:type:`PyLongObject` eller dess subtyp, "
"returnera ``1`` när den är noll och ``0`` annars.  Annars anges ett undantag "
"och ``-1`` returneras."

msgid ""
"On success, return a read only :term:`named tuple`, that holds information "
"about Python's internal representation of integers. See :data:`sys.int_info` "
"for description of individual fields."
msgstr ""
"Vid framgång returneras en skrivskyddad :term:`named tuple`, som innehåller "
"information om Pythons interna representation av heltal. Se :data:`sys."
"int_info` för beskrivning av enskilda fält."

msgid "On failure, return ``NULL`` with an exception set."
msgstr "Vid misslyckande returneras ``NULL`` med en undantagsuppsättning."

msgid "Return 1 if *op* is compact, 0 otherwise."
msgstr "Returnerar 1 om *op* är kompakt, 0 annars."

msgid ""
"This function makes it possible for performance-critical code to implement a "
"“fast path” for small integers. For compact values use :c:func:"
"`PyUnstable_Long_CompactValue`; for others fall back to a :c:func:"
"`PyLong_As* <PyLong_AsSize_t>` function or :c:func:`PyLong_AsNativeBytes`."
msgstr ""
"Denna funktion gör det möjligt för prestandakritisk kod att implementera en "
"\"snabb väg\" för små heltal. För kompakta värden använd :c:func:"
"`PyUnstable_Long_CompactValue`; för andra använd en :c:func:`PyLong_As* "
"<PyLong_AsSize_t>` funktion eller :c:func:`PyLong_AsNativeBytes`."

msgid "The speedup is expected to be negligible for most users."
msgstr "Hastighetsökningen förväntas vara försumbar för de flesta användare."

msgid ""
"Exactly what values are considered compact is an implementation detail and "
"is subject to change."
msgstr ""
"Exakt vilka värden som anses vara kompakta är en implementeringsdetalj och "
"kan komma att ändras."

msgid ""
"If *op* is compact, as determined by :c:func:`PyUnstable_Long_IsCompact`, "
"return its value."
msgstr ""
"Om *op* är kompakt, vilket bestäms av :c:func:`PyUnstable_Long_IsCompact`, "
"returneras dess värde."

msgid "Otherwise, the return value is undefined."
msgstr "I annat fall är returvärdet odefinierat."

msgid "Export API"
msgstr "Exportera API"

msgid ""
"Layout of an array of \"digits\" (\"limbs\" in the GMP terminology), used to "
"represent absolute value for arbitrary precision integers."
msgstr ""
"Layout av en matris med \"siffror\" (\"lemmar\" i GMP-terminologin), som "
"används för att representera absolut värde för heltal med godtycklig "
"precision."

msgid ""
"Use :c:func:`PyLong_GetNativeLayout` to get the native layout of Python :"
"class:`int` objects, used internally for integers with \"big enough\" "
"absolute value."
msgstr ""
"Använd :c:func:`PyLong_GetNativeLayout` för att få den ursprungliga layouten "
"för Python :class:`int`-objekt, som används internt för heltal med "
"\"tillräckligt stort\" absolut värde."

msgid ""
"See also :data:`sys.int_info` which exposes similar information in Python."
msgstr "Se även :data:`sys.int_info` som visar liknande information i Python."

msgid ""
"Bits per digit. For example, a 15 bit digit means that bits 0-14 contain "
"meaningful information."
msgstr ""
"Bitar per siffra. En 15-bitarssiffra innebär t.ex. att bitarna 0-14 "
"innehåller meningsfull information."

msgid ""
"Digit size in bytes. For example, a 15 bit digit will require at least 2 "
"bytes."
msgstr "Sifferstorlek i byte. En 15-bitarssiffra kräver t.ex. minst 2 byte."

msgid "Digits order:"
msgstr "Sifferordning:"

msgid "``1`` for most significant digit first"
msgstr "``1`` för den mest signifikanta siffran först"

msgid "``-1`` for least significant digit first"
msgstr "``-1`` för den minst signifikanta siffran först"

msgid "Digit endianness:"
msgstr "Siffra endianness:"

msgid "``1`` for most significant byte first (big endian)"
msgstr "``1`` för den mest signifikanta byten först (big endian)"

msgid "``-1`` for least significant byte first (little endian)"
msgstr "``-1`` för minst signifikanta byte först (little endian)"

msgid "Get the native layout of Python :class:`int` objects."
msgstr "Hämta den ursprungliga layouten för Python :class:`int`-objekt."

msgid "See the :c:struct:`PyLongLayout` structure."
msgstr "Se strukturen :c:struct:`PyLongLayout`."

msgid ""
"The function must not be called before Python initialization nor after "
"Python finalization. The returned layout is valid until Python is finalized. "
"The layout is the same for all Python sub-interpreters in a process, and so "
"it can be cached."
msgstr ""
"Funktionen får inte anropas före initialisering av Python och inte heller "
"efter slutförande av Python. Den returnerade layouten är giltig tills Python "
"är slutfört. Layouten är densamma för alla Python-undertolkare i en process "
"och kan därför cachelagras."

msgid "Export of a Python :class:`int` object."
msgstr "Export av ett Python :class:`int`-objekt."

msgid "There are two cases:"
msgstr "Det finns två fall:"

msgid ""
"If :c:member:`digits` is ``NULL``, only use the :c:member:`value` member."
msgstr ""
"Om :c:member:`digits` är ``NULL``, använd endast medlemmen :c:member:`value`."

msgid ""
"If :c:member:`digits` is not ``NULL``, use :c:member:`negative`, :c:member:"
"`ndigits` and :c:member:`digits` members."
msgstr ""
"Om :c:member:`digits` inte är ``NULL``, använd medlemmarna :c:member:"
"`negative`, :c:member:`ndigits` och :c:member:`digits`."

msgid ""
"The native integer value of the exported :class:`int` object. Only valid if :"
"c:member:`digits` is ``NULL``."
msgstr ""
"Det ursprungliga heltalsvärdet för det exporterade :class:`int`-objektet. "
"Endast giltigt om :c:member:`digits` är ``NULL``."

msgid ""
"``1`` if the number is negative, ``0`` otherwise. Only valid if :c:member:"
"`digits` is not ``NULL``."
msgstr ""
"``1`` om talet är negativt, ``0`` annars. Gäller endast om :c:member:"
"`digits` inte är ``NULL``."

msgid ""
"Number of digits in :c:member:`digits` array. Only valid if :c:member:"
"`digits` is not ``NULL``."
msgstr ""
"Antal siffror i :c:member:`digits` array. Endast giltigt om :c:member:"
"`digits` inte är ``NULL``."

msgid "Read-only array of unsigned digits. Can be ``NULL``."
msgstr "Skrivskyddad array av osignerade siffror. Kan vara ``NULL``."

msgid "Export a Python :class:`int` object."
msgstr "Exportera ett Python :class:`int`-objekt."

msgid ""
"*export_long* must point to a :c:struct:`PyLongExport` structure allocated "
"by the caller. It must not be ``NULL``."
msgstr ""
"*export_long* måste peka på en :c:struct:`PyLongExport`-struktur som "
"allokerats av anroparen. Den får inte vara ``NULL``."

msgid ""
"On success, fill in *\\*export_long* and return ``0``. On error, set an "
"exception and return ``-1``."
msgstr ""
"Vid framgång, fyll i *\\*export_long* och returnera ``0``. Vid fel, ange ett "
"undantag och returnera ``-1``."

msgid ""
":c:func:`PyLong_FreeExport` must be called when the export is no longer "
"needed."
msgstr ""
":c:func:`PyLong_FreeExport` måste anropas när exporten inte längre behövs."

msgid ""
"This function always succeeds if *obj* is a Python :class:`int` object or a "
"subclass."
msgstr ""
"Denna funktion lyckas alltid om *obj* är ett Python :class:`int`-objekt "
"eller en underklass."

msgid "Release the export *export_long* created by :c:func:`PyLong_Export`."
msgstr "Frigör exporten *export_long* som skapats av :c:func:`PyLong_Export`."

msgid ""
"Calling :c:func:`PyLong_FreeExport` is optional if *export_long->digits* is "
"``NULL``."
msgstr ""
"Anrop av :c:func:`PyLong_FreeExport` är valfritt om *export_long->digits* är "
"``NULL``."

msgid "PyLongWriter API"
msgstr "PyLongWriter API"

msgid "The :c:type:`PyLongWriter` API can be used to import an integer."
msgstr ""
"API:et :c:type:`PyLongWriter` kan användas för att importera ett heltal."

msgid "A Python :class:`int` writer instance."
msgstr "En Python :class:`int` skrivarinstans."

msgid ""
"The instance must be destroyed by :c:func:`PyLongWriter_Finish` or :c:func:"
"`PyLongWriter_Discard`."
msgstr ""
"Instansen måste förstöras av :c:func:`PyLongWriter_Finish` eller :c:func:"
"`PyLongWriter_Discard`."

msgid "Create a :c:type:`PyLongWriter`."
msgstr "Skapa en :c:type:`PyLongWriter`."

msgid ""
"On success, allocate *\\*digits* and return a writer. On error, set an "
"exception and return ``NULL``."
msgstr ""
"Vid framgång, allokera *\\*digits* och returnera en skrivare. Vid fel, sätt "
"ett undantag och returnera ``NULL``."

msgid "*negative* is ``1`` if the number is negative, or ``0`` otherwise."
msgstr "*negative* är ``1`` om talet är negativt, eller ``0`` annars."

msgid ""
"*ndigits* is the number of digits in the *digits* array. It must be greater "
"than 0."
msgstr ""
"*ndigits* är antalet siffror i *digits*-arrayen. Det måste vara större än 0."

msgid "*digits* must not be NULL."
msgstr "*digits* får inte vara NULL."

msgid ""
"After a successful call to this function, the caller should fill in the "
"array of digits *digits* and then call :c:func:`PyLongWriter_Finish` to get "
"a Python :class:`int`. The layout of *digits* is described by :c:func:"
"`PyLong_GetNativeLayout`."
msgstr ""
"Efter ett lyckat anrop till denna funktion bör anroparen fylla i matrisen "
"med siffror *digits* och sedan anropa :c:func:`PyLongWriter_Finish` för att "
"få en Python :class:`int`. Layouten för *digits* beskrivs av :c:func:"
"`PyLong_GetNativeLayout`."

msgid ""
"Digits must be in the range [``0``; ``(1 << bits_per_digit) - 1``] (where "
"the :c:struct:`~PyLongLayout.bits_per_digit` is the number of bits per "
"digit). Any unused most significant digits must be set to ``0``."
msgstr ""
"Siffrorna måste ligga i intervallet [``0``; ``(1 << bits_per_digit) - 1``] "
"(där :c:struct:`~PyLongLayout.bits_per_digit` är antalet bitar per siffra). "
"Alla oanvända mest signifikanta siffror måste sättas till ``0``."

msgid ""
"Alternately, call :c:func:`PyLongWriter_Discard` to destroy the writer "
"instance without creating an :class:`~int` object."
msgstr ""
"Alternativt kan du anropa :c:func:`PyLongWriter_Discard` för att förstöra "
"skrivarinstansen utan att skapa ett :class:`~int`-objekt."

msgid ""
"Finish a :c:type:`PyLongWriter` created by :c:func:`PyLongWriter_Create`."
msgstr ""
"Avsluta en :c:type:`PyLongWriter` som skapats av :c:func:"
"`PyLongWriter_Create`."

msgid ""
"On success, return a Python :class:`int` object. On error, set an exception "
"and return ``NULL``."
msgstr ""
"Vid framgång returneras ett Python :class:`int`-objekt. Vid fel, sätt ett "
"undantag och returnera ``NULL``."

msgid ""
"The function takes care of normalizing the digits and converts the object to "
"a compact integer if needed."
msgstr ""
"Funktionen tar hand om normaliseringen av siffrorna och konverterar objektet "
"till ett kompakt heltal om det behövs."

msgid "The writer instance and the *digits* array are invalid after the call."
msgstr "Writer-instansen och *digits*-arrayen är ogiltiga efter anropet."

msgid ""
"Discard a :c:type:`PyLongWriter` created by :c:func:`PyLongWriter_Create`."
msgstr ""
"Kassera en :c:type:`PyLongWriter` som skapats av :c:func:"
"`PyLongWriter_Create`."

msgid "If *writer* is ``NULL``, no operation is performed."
msgstr "Om *writer* är ``NULL`` utförs ingen åtgärd."

msgid "object"
msgstr "objekt"

msgid "long integer"
msgstr "lång heltal"

msgid "integer"
msgstr "heltal"

msgid "LONG_MAX (C macro)"
msgstr "LONG_MAX (C-makro)"

msgid "OverflowError (built-in exception)"
msgstr "OverflowError (inbyggt undantag)"

msgid "PY_SSIZE_T_MAX (C macro)"
msgstr "PY_SSIZE_T_MAX (C-makro)"

msgid "ULONG_MAX (C macro)"
msgstr "ULONG_MAX (C-makro)"

msgid "SIZE_MAX (C macro)"
msgstr "SIZE_MAX (C-makro)"
